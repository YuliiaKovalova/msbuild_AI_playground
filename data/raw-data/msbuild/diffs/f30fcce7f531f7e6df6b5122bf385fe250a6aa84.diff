diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index b379b227dd6..ee898fac36b 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -154,7 +154,7 @@
     <!-- Copy our binaries to the x64 location. -->
      <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
           DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
-    
+
     <!-- Copy our freshly-built props and targets, overwriting anything we copied from the machine -->
     <Copy SourceFiles="@(FreshlyBuiltRootProjects)"
           DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')" />
diff --git a/eng/build.ps1 b/eng/build.ps1
index f2a094600c1..d9f579c7eec 100644
--- a/eng/build.ps1
+++ b/eng/build.ps1
@@ -40,7 +40,7 @@ function Print-Usage() {
   Write-Host "  -verbosity <value>      Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
   Write-Host "  -binaryLog              Output binary log (short: -bl)"
   Write-Host ""
- 
+
   Write-Host "Actions:"
   Write-Host "  -restore                Restore dependencies (short: -r)"
   Write-Host "  -build                  Build solution (short: -b)"
@@ -55,14 +55,14 @@ function Print-Usage() {
   Write-Host "  -sign                   Sign build outputs"
   Write-Host "  -publish                Publish artifacts (e.g. symbols)"
   Write-Host ""
- 
+
   Write-Host "Advanced settings:"
   Write-Host "  -projects <value>       Semi-colon delimited list of sln/proj's to build. Globbing is supported (*.sln)"
   Write-Host "  -ci                     Set when running on CI server"
   Write-Host "  -prepareMachine         Prepare machine for CI run"
   Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
   Write-Host ""
- 
+
   Write-Host "Official build settings:"
   Write-Host "  -officialBuildId                            An official build id, e.g. 20190102.3"
   Write-Host "  -officialSkipApplyOptimizationData <bool>   Pass 'true' to not apply optimization data"
@@ -158,7 +158,7 @@ function Check-EditedFiles() {
 
 try {
   Process-Arguments
- 
+
   # Import Arcade functions
   . (Join-Path $PSScriptRoot "common\tools.ps1")
   . (Join-Path $PSScriptRoot "configure-toolset.ps1")
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index c9bc90217fe..2ae9de4ba96 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -12,7 +12,7 @@ Set-StrictMode -Version "Latest"
 $ErrorActionPreference = "Stop"
 
 function Copy-WithBackup ($origin) {
-    $directoryPart = Join-Path -Path $destination $origin.IntermediaryDirectories 
+    $directoryPart = Join-Path -Path $destination $origin.IntermediaryDirectories
     $destinationPath = Join-Path -Path $directoryPart (Split-Path $origin.SourceFile -leaf)
 
     if (Test-Path $destinationPath -PathType Leaf) {
diff --git a/scripts/EnumerateMSBuild.ps1 b/scripts/EnumerateMSBuild.ps1
index d8ac8f262e6..115cdd8f108 100644
--- a/scripts/EnumerateMSBuild.ps1
+++ b/scripts/EnumerateMSBuild.ps1
@@ -33,7 +33,7 @@ foreach ($instance in $vsInstances)
     $instancePath = $instance.installationPath
     Write-Log "********************" -LogToConsole $False
     Write-Log "Found VS Instance: $instanceName"
-    
+
     # Look at each dll/exe in the MSBuild bin folder and get their ProductVersion
     ls -File -Recurse -Include ('*.dll', '*.exe') -Path "$instancePath\MSBuild\15.0\Bin" | % VersionInfo | Format-Table -AutoSize InternalName, ProductVersion, FileName | Out-File $logFile -Width 1000 -Append unicode
     ls -File -Recurse -Include ('*.dll', '*.exe') -Path "$instancePath\MSBuild\Current\Bin" | % VersionInfo | Format-Table -AutoSize InternalName, ProductVersion, FileName | Out-File $logFile -Width 1000 -Append unicode
@@ -68,4 +68,4 @@ Write-Log "********************" -LogToConsole $False
 $logFile = Get-ChildItem -File -Path $logFile
 
 Write-Host
-Write-Host "Output saved to $logFile"
\ No newline at end of file
+Write-Host "Output saved to $logFile"
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 8d354afd72e..fb4e9d1afdc 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -395,7 +395,7 @@ public void ValidXmlInvalidSyntaxInChildElement()
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                            <XXX YYY='ZZZ'/>
-                        </ItemGroup> 
+                        </ItemGroup>
                     </Project>
                 ";
 
@@ -416,7 +416,7 @@ public void ValidXmlInvalidSyntaxOpenFromDiskTwice()
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                            <XXX YYY='ZZZ'/>
-                        </ItemGroup> 
+                        </ItemGroup>
                     </Project>
                 ";
 
@@ -1392,7 +1392,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- new comment -->property value<!-- new comment --></P>
   </PropertyGroup>
-  
+
   <!-- new comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1412,7 +1412,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- new comment -->property value<!-- new comment --></P>
   </PropertyGroup>
-  
+
   <!-- new comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1428,7 +1428,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- changed comment -->property value<!-- changed comment --></P>
   </PropertyGroup>
-  
+
   <!-- changed comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1448,7 +1448,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- new comment -->property value<!-- new comment --></P>
   </PropertyGroup>
-  
+
   <!-- new comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1463,7 +1463,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P>property value</P>
   </PropertyGroup>
-  
+
   <ItemGroup>
     <i Include=`a`>
       <m>metadata value</m>
@@ -1562,7 +1562,7 @@ public void ReloadedStateIsResilientToChangesAndDiskRoundtrip()
 @"
 <!-- changed comment -->
 <Project xmlns=`msbuildnamespace`>
-  
+
   <!-- changed comment -->
   <ItemGroup>
 
@@ -1580,7 +1580,7 @@ public void ReloadedStateIsResilientToChangesAndDiskRoundtrip()
 @"
 <!-- changed comment -->
 <Project xmlns=`msbuildnamespace`>
-  
+
   <!-- changed comment -->
   <PropertyGroup>
     <P>v</P>
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index a7be71e809a..5323c0fd85e 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -1839,11 +1839,11 @@ public void ChooseWhenTrue()
                             <When Condition='true'>
                               <PropertyGroup>
                                 <p>v1</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i1' />
                               </ItemGroup>
-                            </When>      
+                            </When>
                         </Choose>
                     </Project>
                 ");
@@ -1866,19 +1866,19 @@ public void ChooseSecondWhenTrue()
                             <When Condition='false'>
                               <PropertyGroup>
                                 <p>v1</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i1' />
                               </ItemGroup>
-                            </When>   
+                            </When>
                             <When Condition='true'>
                               <PropertyGroup>
                                 <p>v2</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i2' />
                               </ItemGroup>
-                            </When>    
+                            </When>
                         </Choose>
                     </Project>
                 ");
@@ -1901,19 +1901,19 @@ public void ChooseOtherwise()
                             <When Condition='false'>
                               <PropertyGroup>
                                 <p>v1</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i1' />
                               </ItemGroup>
-                            </When>   
+                            </When>
                             <Otherwise>
                               <PropertyGroup>
                                 <p>v2</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i2' />
                               </ItemGroup>
-                            </Otherwise>    
+                            </Otherwise>
                         </Choose>
                     </Project>
                 ");
@@ -1940,13 +1940,13 @@ public void ChooseTwoPasses()
                               </ItemGroup>
                               <PropertyGroup>
                                 <p>@(i);v1</p>
-                              </PropertyGroup> 
-                            </When>      
+                              </PropertyGroup>
+                            </When>
                         </Choose>
 
                       <PropertyGroup>
                         <p2>v2</p2>
-                      </PropertyGroup> 
+                      </PropertyGroup>
 
                         <Choose>
                             <When Condition='false'/>
@@ -1956,13 +1956,13 @@ public void ChooseTwoPasses()
                               </ItemGroup>
                               <PropertyGroup>
                                 <q>@(j);v1</q>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                             </Otherwise>
                         </Choose>
 
                       <PropertyGroup>
                         <q2>v2</q2>
-                      </PropertyGroup> 
+                      </PropertyGroup>
                     </Project>
                 ");
 
@@ -2019,14 +2019,14 @@ public void ChooseSeesItemDefinitions()
                                   <m>%(m);m1</m>
                                 </i>
                               </ItemGroup>
-                            </When>      
+                            </When>
                         </Choose>
 
                       <ItemDefinitionGroup>
                         <i>
                           <m>m0</m>
                         </i>
-                      </ItemDefinitionGroup> 
+                      </ItemDefinitionGroup>
 
                     </Project>
                 ");
@@ -3078,7 +3078,7 @@ public void GetItemProvenanceWhenExcludeHasIndirectReferences()
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P>1;2;3;@(B)</P>  
+                    <P>1;2;3;@(B)</P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3104,7 +3104,7 @@ public void GetItemProvenanceWhenIncludeHasIndirectReferences()
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P>1;2;3;@(B)</P>  
+                    <P>1;2;3;@(B)</P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3130,7 +3130,7 @@ public void GetItemProvenanceWhenIncludeHasIndirectItemReferencesAndOnlyGlobsExi
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P>@(B)</P>  
+                    <P>@(B)</P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3158,7 +3158,7 @@ public void GetItemProvenanceShouldReturnInconclusiveWhenIndirectPropertyDoesNot
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P></P>  
+                    <P></P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3918,7 +3918,7 @@ public void ProjectImportedEventFalseCondition()
                     eventArgs.LineNumber.ShouldBe(6);
                     eventArgs.ColumnNumber.ShouldBe(3);
 
-                    logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to false condition; ( \'$(Something)\' == \'nothing\' ) was evaluated as ( \'\' == \'nothing\' )."); 
+                    logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to false condition; ( \'$(Something)\' == \'nothing\' ) was evaluated as ( \'\' == \'nothing\' ).");
                 }
             }
         }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index b09519f9f71..fb37180fcf7 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -277,10 +277,10 @@ public void VerifyEnvironmentSavedBetweenCalls()
 </UsingTask>
                         <Target Name='SetEnv'>
                             <SetEnvv/>
-                        </Target>        
+                        </Target>
                         <Target Name='Message1'>
                             <Exec Command='echo What does a cat say : " + (NativeMethodsShared.IsWindows ? "%MOO%" : "$MOO") + @"' />
-                        </Target>       
+                        </Target>
 </Project>
 ");
 
@@ -311,7 +311,7 @@ public void VerifyEnvironmentSavedBetweenCalls()
 
         /// <summary>
         /// Verify if idle nodes are shutdown when BuildManager.ShutdownAllNodes is evoked.
-        /// The final number of nodes has to be less or equal the number of nodes already in 
+        /// The final number of nodes has to be less or equal the number of nodes already in
         /// the system before this method was called.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
@@ -344,11 +344,11 @@ public void ShutdownNodesAfterParallelBuild(int numberOfParallelProjectsToBuild,
             // Generate a theoretically unique directory to put our dummy projects in.
             string shutdownProjectDirectory = Path.Combine(Path.GetTempPath(), String.Format(CultureInfo.InvariantCulture, "VSNodeShutdown_{0}_UnitTest", Process.GetCurrentProcess().Id));
 
-            // Create the dummy projects we'll be "building" as our excuse to connect to and shut down 
-            // all the nodes. 
+            // Create the dummy projects we'll be "building" as our excuse to connect to and shut down
+            // all the nodes.
             ProjectInstance rootProject = GenerateDummyProjects(shutdownProjectDirectory, numberOfParallelProjectsToBuild, projectCollection);
 
-            // Build the projects. 
+            // Build the projects.
             var buildParameters = new BuildParameters(projectCollection)
             {
                 OnlyLogCriticalEvents = true,
@@ -362,9 +362,9 @@ public void ShutdownNodesAfterParallelBuild(int numberOfParallelProjectsToBuild,
             // Tell the build manager to not disturb process wide state
             var requestData = new BuildRequestData(rootProject, new[] { "Build" }, null);
 
-            // Use a separate BuildManager for the node shutdown build, so that we don't have 
-            // to worry about taking dependencies on whether or not the existing ones have already 
-            // disappeared. 
+            // Use a separate BuildManager for the node shutdown build, so that we don't have
+            // to worry about taking dependencies on whether or not the existing ones have already
+            // disappeared.
             var shutdownManager = new BuildManager("IdleNodeShutdown");
             shutdownManager.Build(buildParameters, requestData);
 
@@ -551,7 +551,7 @@ public void RequestedResultsAreSatisfied()
         }
 
         /// <summary>
-        /// Make sure when we are doing an in-process build that even if the environment variable MSBUILDFORWARDPROPERTIESFROMCHILD is set that we still 
+        /// Make sure when we are doing an in-process build that even if the environment variable MSBUILDFORWARDPROPERTIESFROMCHILD is set that we still
         /// get all of the initial properties.
         /// </summary>
         [Fact]
@@ -631,7 +631,7 @@ public void InProcMsBuildForwardAllPropertiesFromChild()
         }
 
         /// <summary>
-        /// Make sure when we launch a child node and set MsBuildForwardAllPropertiesFromChild that we get all of our properties. This needs to happen 
+        /// Make sure when we launch a child node and set MsBuildForwardAllPropertiesFromChild that we get all of our properties. This needs to happen
         /// even if the msbuildforwardpropertiesfromchild is set to something.
         /// </summary>
         [Fact]
@@ -835,7 +835,7 @@ public void ForwardNoPropertiesLaunchChildNode()
         }
 
         /// <summary>
-        /// We want to pass the toolsets from the parent to the child nodes so that any custom toolsets 
+        /// We want to pass the toolsets from the parent to the child nodes so that any custom toolsets
         /// defined on the parent are also available on the child nodes for tasks which use the global project
         /// collection
         /// </summary>
@@ -858,7 +858,7 @@ public void VerifyCustomToolSetsPropagated()
                                <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.dll'/>
 <Code Type='Method'>
  <![CDATA[
-                    
+
                                 public override bool Execute()
                                 {
                                     bool foundToolSet = false;
@@ -963,7 +963,7 @@ public void DeferredMessageShouldBeLogged()
               <Project>
                  <Target Name='Build'>
                      <Message Text='[Message]' Importance='high'/>
-                     <Warning Text='[Warn]'/>	
+                     <Warning Text='[Warn]'/>
                 </Target>
               </Project>
             ");
@@ -1019,7 +1019,7 @@ public void DeferredMessageShouldBeLogged()
         }
 
         /// <summary>
-        /// A build with a message, error and warning, verify that 
+        /// A build with a message, error and warning, verify that
         /// we only get errors, warnings, and project started and finished when OnlyLogCriticalEvents is true
         /// </summary>
         [Fact]
@@ -1029,7 +1029,7 @@ public void SimpleBuildWithFailureAndWarningOnlyLogCriticalEventsTrue()
               <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                  <Target Name='test'>
                      <Message Text='[Message]' Importance='high'/>
-                     <Warning Text='[warn]'/>	
+                     <Warning Text='[warn]'/>
                      <Error Text='[errormessage]'/>
                 </Target>
               </Project>
@@ -1053,7 +1053,7 @@ public void SimpleBuildWithFailureAndWarningOnlyLogCriticalEventsTrue()
         }
 
         /// <summary>
-        /// A build with a message, error and warning, verify that 
+        /// A build with a message, error and warning, verify that
         /// we only get errors, warnings, messages, task and target messages OnlyLogCriticalEvents is false
         /// </summary>
         [Fact]
@@ -1063,7 +1063,7 @@ public void SimpleBuildWithFailureAndWarningOnlyLogCriticalEventsFalse()
               <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                  <Target Name='test'>
                      <Message Text='[message]' Importance='high'/>
-                     <Warning Text='[warn]'/>	
+                     <Warning Text='[warn]'/>
                      <Error Text='[errormessage]'/>
                 </Target>
               </Project>
@@ -1386,9 +1386,9 @@ public void OverlappingBuildSubmissions()
         }
 
         /// <summary>
-        /// If two overlapping submissions are executed against the same project, with at least one 
-        /// target involved that skipped, make sure that the second one successfully completes 
-        /// (retrieved from the cache). 
+        /// If two overlapping submissions are executed against the same project, with at least one
+        /// target involved that skipped, make sure that the second one successfully completes
+        /// (retrieved from the cache).
         /// </summary>
         [Fact]
         public void OverlappingIdenticalBuildSubmissions()
@@ -1419,9 +1419,9 @@ public void OverlappingIdenticalBuildSubmissions()
         }
 
         /// <summary>
-        /// With two overlapping submissions, the first of which skips a target and the second 
-        /// of which should not, ensure that the second submission does not, in fact, skip 
-        /// the target.  (E.g. despite the fact that the target results are in the cache already 
+        /// With two overlapping submissions, the first of which skips a target and the second
+        /// of which should not, ensure that the second submission does not, in fact, skip
+        /// the target.  (E.g. despite the fact that the target results are in the cache already
         /// as 'skipped', ensure that we retry execution in case conditions have changed.)
         /// </summary>
         [Fact]
@@ -1619,7 +1619,7 @@ public void CancelledBuildInTaskHostWithDelay20()
 
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.. task, we should
-        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly. 
+        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
         /// </summary>
         [Fact]
         public void CancelledBuildWithDelay40()
@@ -1650,7 +1650,7 @@ public void CancelledBuildWithDelay40()
 #if FEATURE_TASKHOST
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should
-        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly. 
+        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
         /// </summary>
         [Fact]
         public void CancelledBuildInTaskHostWithDelay40()
@@ -2122,7 +2122,7 @@ public void Regress239661()
  </Target>
 </Project>
 ");
-            
+
             string fileName = _env.CreateFile(".proj").Path;
             File.WriteAllText(fileName, contents);
             var data = new BuildRequestData(fileName, _projectCollection.GlobalProperties, MSBuildDefaultToolsVersion, new string[0], null);
@@ -2180,9 +2180,9 @@ public void ProjectInstanceTransfersToOOPNode()
  </PropertyGroup>
 <ItemGroup>
   <Foo Include='foo'/>
-  <Foo2 Include='foo2'/>    
+  <Foo2 Include='foo2'/>
 </ItemGroup>
- <Target Name='test'>   
+ <Target Name='test'>
    <Message Text='[$(DeleteMe)]'/>
    <Message Text='[$(Unmodified)]'/>
    <Message Text='[$(VirtualProp)]'/>
@@ -2242,7 +2242,7 @@ public void ProjectInstanceLimitedTransferToOOPNode()
    <Unmodified>unmodified</Unmodified>
    <VirtualProp>original</VirtualProp>
  </PropertyGroup>
- <Target Name='test'>   
+ <Target Name='test'>
    <Message Text='[$(Unmodified)]'/>
    <Message Text='[$(VirtualProp)]'/>
  </Target>
@@ -2293,7 +2293,7 @@ public void CacheLifetime()
                 {
                     innerBuildCacheDirectory = BuildAndCheckCache(innerBuildManager, new[] { outerBuildCacheDirectory });
 
-                    // Force the cache for this build manager (and only this build manager) to be cleared.  It should leave 
+                    // Force the cache for this build manager (and only this build manager) to be cleared.  It should leave
                     // behind the results from the other one.
                     innerBuildManager.ResetCaches();
                 }
@@ -2309,9 +2309,9 @@ public void CacheLifetime()
         }
 
         /// <summary>
-        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the 
+        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the
         /// overall build result -- and thus the return value of the MSBuild task -- should reflect
-        /// that failure. 
+        /// that failure.
         /// </summary>
         [Theory]
         [InlineData(false)]
@@ -2325,9 +2325,9 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disableInP
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <MSBuild Projects=`" + projB + @"` />
- 
+
     <Warning Text=`We shouldn't reach here.` />
-  </Target>    
+  </Target>
 </Project>
 ";
 
@@ -2357,10 +2357,10 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disableInP
         }
 
         /// <summary>
-        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the 
+        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the
         /// overall build result -- and thus the return value of the MSBuild task -- should reflect
-        /// that failure.  Specifically tests where there are multiple entrypoint targets with 
-        /// AfterTargets, only one of which fails. 
+        /// that failure.  Specifically tests where there are multiple entrypoint targets with
+        /// AfterTargets, only one of which fails.
         /// </summary>
         [Theory]
         [InlineData(false)]
@@ -2374,9 +2374,9 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure_MultipleEntrypo
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <MSBuild Projects=`" + projB + @"` Targets=`Build;Build2` />
- 
+
     <Warning Text=`We shouldn't reach here.` />
-  </Target>    
+  </Target>
 </Project>
 ";
 
@@ -2423,9 +2423,9 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure_MultipleEntrypo
         }
 
         /// <summary>
-        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the 
+        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the
         /// overall build result -- and thus the return value of the MSBuild task -- should reflect
-        /// that failure. This should also be true if the AfterTarget is an AfterTarget of the 
+        /// that failure. This should also be true if the AfterTarget is an AfterTarget of the
         /// entrypoint target.
         /// </summary>
         [Theory]
@@ -2440,9 +2440,9 @@ public void FailedNestedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disa
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <MSBuild Projects=`" + projB + @"` />
- 
+
     <Warning Text=`We shouldn't reach here.` />
-  </Target>    
+  </Target>
 </Project>
 ";
 
@@ -2476,9 +2476,9 @@ public void FailedNestedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disa
         }
 
         /// <summary>
-        /// If a project is called into twice, with two different entrypoint targets that 
-        /// depend on non-overlapping sets of targets, and the first fails, the second 
-        /// should not inherit that failure if all the targets it calls succeed. 
+        /// If a project is called into twice, with two different entrypoint targets that
+        /// depend on non-overlapping sets of targets, and the first fails, the second
+        /// should not inherit that failure if all the targets it calls succeed.
         /// </summary>
         [Fact]
         public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResults()
@@ -2489,7 +2489,7 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
             string contentsA = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
-  
+
    <Message Text=`The next MSBuild call should FAIL, but the build will continue.` />
    <MSBuild Projects=`" + projB + @"` Targets=`Build` ContinueOnError=`true` />
    <Message Text=`The next MSBuild call should SUCCEED without error.` />
@@ -2503,8 +2503,8 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
   <Target Name=`Build`>
     <Error Text=`Forced error in Build` />
   </Target>
-  
-  
+
+
   <Target Name=`GetTargetPath`>
     <Message Text=`Success` />
   </Target>
@@ -2524,9 +2524,9 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
         }
 
         /// <summary>
-        /// In a situation where we have two requests calling into the same project, with different entry point 
-        /// targets, one of which depends on "A;B", the other of which depends on "B", which has a dependency of 
-        /// its own on "A", that we still properly build.  
+        /// In a situation where we have two requests calling into the same project, with different entry point
+        /// targets, one of which depends on "A;B", the other of which depends on "B", which has a dependency of
+        /// its own on "A", that we still properly build.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "https://github.com/Microsoft/msbuild/issues/933")]
@@ -2545,7 +2545,7 @@ public void Regress473114()
             string contentsA = @"<?xml version='1.0' encoding='utf-8'?>
 <Project ToolsVersion='4.0' DefaultTargets='Build' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
   <ItemGroup>
-    <ProjectReference Include='" + projD + @"' /> 
+    <ProjectReference Include='" + projD + @"' />
     <ProjectReference Include='" + projC + @"' />
     <ProjectReference Include='" + projB + @"' />
   </ItemGroup>
@@ -2615,19 +2615,19 @@ public void Regress473114()
         }
 
         /// <summary>
-        /// If two requests are made for the same project, and they call in with 
-        /// just the right timing such that: 
+        /// If two requests are made for the same project, and they call in with
+        /// just the right timing such that:
         /// - request 1 builds for a while, reaches a P2P, and blocks
-        /// - request 2 starts building, skips for a while, reaches the above P2P, and 
-        ///   blocks waiting for request 1's results 
+        /// - request 2 starts building, skips for a while, reaches the above P2P, and
+        ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
-        /// Then request 2 should end up exiting in the same fashion.  
-        /// 
-        /// This simple test verifies that if there are two error targets in a row, the 
-        /// second request will bail out where the first request did, as though it had 
-        /// executed the target, rather than skipping and continuing. 
+        ///
+        /// Then request 2 should end up exiting in the same fashion.
+        ///
+        /// This simple test verifies that if there are two error targets in a row, the
+        /// second request will bail out where the first request did, as though it had
+        /// executed the target, rather than skipping and continuing.
         /// </summary>
 #if MONO
         [Fact(Skip = "https://github.com/Microsoft/msbuild/issues/1240")]
@@ -2704,9 +2704,9 @@ public void VerifyMultipleRequestForSameProjectWithErrors_Simple()
         ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
+        ///
         /// Then request 2 should end up exiting in the same fashion.
-        /// 
+        ///
         /// This simple test verifies that if there are two error targets in a row, and the
         /// first has a chain of OnError targets, the OnError targets will all execute as
         /// expected in the first request, but be skipped by the second (since if it's "skipping
@@ -2824,9 +2824,9 @@ public void VerifyMultipleRequestForSameProjectWithErrors_OnErrorChain()
         ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
+        ///
         /// Then request 2 should end up exiting in the same fashion.
-        /// 
+        ///
         /// This simple test verifies that if there are two error targets in a row, AND
         /// they're marked as ContinueOnError=ErrorAndContinue, then we won't bail, but
         /// will continue executing (on the first request) or skipping (on the second)
@@ -2908,18 +2908,18 @@ public void VerifyMultipleRequestForSameProjectWithErrors_ErrorAndContinue()
         }
 
         /// <summary>
-        /// If two requests are made for the same project, and they call in with 
-        /// just the right timing such that: 
+        /// If two requests are made for the same project, and they call in with
+        /// just the right timing such that:
         /// - request 1 builds for a while, reaches a P2P, and blocks
-        /// - request 2 starts building, skips for a while, reaches the above P2P, and 
-        ///   blocks waiting for request 1's results 
+        /// - request 2 starts building, skips for a while, reaches the above P2P, and
+        ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
-        /// Then request 2 should end up exiting in the same fashion.  
-        /// 
-        /// This test verifies that if the errors are in AfterTargets, we still 
-        /// exit as though the target that those targets run after has already run. 
+        ///
+        /// Then request 2 should end up exiting in the same fashion.
+        ///
+        /// This test verifies that if the errors are in AfterTargets, we still
+        /// exit as though the target that those targets run after has already run.
         /// </summary>
 #if MONO
         [Fact(Skip = "https://github.com/Microsoft/msbuild/issues/1240")]
@@ -2989,10 +2989,10 @@ public void VerifyMultipleRequestForSameProjectWithErrors_AfterTargets()
         }
 
         /// <summary>
-        /// Related to the two tests above, if two requests are made for the same project, but 
-        /// for different entry targets, and a target fails in the first request, if the second 
-        /// request also runs that target, its skip-unsuccessful should behave in the same 
-        /// way as if the target had actually errored. 
+        /// Related to the two tests above, if two requests are made for the same project, but
+        /// for different entry targets, and a target fails in the first request, if the second
+        /// request also runs that target, its skip-unsuccessful should behave in the same
+        /// way as if the target had actually errored.
         /// </summary>
         [Fact]
         public void VerifyMultipleRequestForSameProjectWithErrors_DifferentEntrypoints()
@@ -3002,7 +3002,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_DifferentEntrypoints()
 
             string contentsA = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
-  <ItemGroup> 
+  <ItemGroup>
     <PR Include=`" + projB + @"`>
       <Targets>Build</Targets>
     </PR>
@@ -3119,7 +3119,7 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData()
         }
 
         /// <summary>
-        /// Verify that we can submit multiple simultaneous submissions with 
+        /// Verify that we can submit multiple simultaneous submissions with
         /// legacy threading mode active and successfully build, and that one of those
         /// submissions can P2P to the other.
         /// </summary>
@@ -3200,12 +3200,12 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P()
         }
 
         /// <summary>
-        /// Verify that we can submit multiple simultaneous submissions with 
+        /// Verify that we can submit multiple simultaneous submissions with
         /// legacy threading mode active and successfully build, and that one of those
         /// submissions can P2P to the other.
-        /// 
-        /// A variation of the above test, where multiple nodes are available, so the 
-        /// submissions aren't restricted to running strictly serially by the single in-proc 
+        ///
+        /// A variation of the above test, where multiple nodes are available, so the
+        /// submissions aren't restricted to running strictly serially by the single in-proc
         /// node.
         /// </summary>
 #if MONO
@@ -3308,7 +3308,7 @@ public void Regress265010()
 <ItemGroup>
   <Item Include='BaseItem'/>
 </ItemGroup>
- <Target Name='BaseTest'>   
+ <Target Name='BaseTest'>
    <Message Text='[$(Prop)]'/>
    <Message Text='[@(Item)]'/>
     <PropertyGroup>
@@ -3319,7 +3319,7 @@ public void Regress265010()
     </ItemGroup>
  </Target>
 
- <Target Name='MovedTest'>   
+ <Target Name='MovedTest'>
    <Message Text='[$(Prop)]'/>
    <Message Text='[@(Item)]'/>
  </Target>
@@ -3452,13 +3452,13 @@ private static string BuildAndCheckCache(BuildManager localBuildManager, IEnumer
         {
             string contents = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
- <Target Name='One' Outputs='one.txt'>   
+ <Target Name='One' Outputs='one.txt'>
  </Target>
 
- <Target Name='Two' Outputs='two.txt'>   
+ <Target Name='Two' Outputs='two.txt'>
  </Target>
 
- <Target Name='Three' Outputs='three.txt'>   
+ <Target Name='Three' Outputs='three.txt'>
  </Target>
 </Project>
 ");
@@ -3580,8 +3580,8 @@ private static ProjectInstance GenerateDummyProjects(string shutdownProjectDirec
             Directory.CreateDirectory(shutdownProjectDirectory);
 
             // Generate the project.  It will have the following format.  Setting the AdditionalProperties
-            // causes the projects to be built to be separate configs, which allows us to build the same project 
-            // a bunch of times in parallel.  
+            // causes the projects to be built to be separate configs, which allows us to build the same project
+            // a bunch of times in parallel.
             //
             // <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'/>
             //   <ItemGroup>
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index e365cb9265f..41e2d74ef72 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -36,7 +36,7 @@ public class ToolsetRegistryReader_Tests : IDisposable
         private const string testRegistryPath = @"msbuildUnitTests";
 
         /// <summary>
-        /// Store the value of the "VisualStudioVersion" environment variable here so that 
+        /// Store the value of the "VisualStudioVersion" environment variable here so that
         /// we can unset it for the duration of the test.
         /// </summary>
         private string _oldVisualStudioVersion;
@@ -341,8 +341,8 @@ public void ReadRegistry_IgnoreSubToolsetSubKeys()
         }
 
         /// <summary>
-        /// Verifies that if a value is defined in both the base toolset and the 
-        /// selected subtoolset, the subtoolset value overrides -- even if that 
+        /// Verifies that if a value is defined in both the base toolset and the
+        /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
         [Fact]
@@ -381,8 +381,8 @@ public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         }
 
         /// <summary>
-        /// Verifies that if a value is defined in both the base toolset and the 
-        /// selected subtoolset, the subtoolset value overrides -- even if that 
+        /// Verifies that if a value is defined in both the base toolset and the
+        /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index ca20d9c66cb..ab0a67d26a1 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -629,7 +629,7 @@ public void UsePropertyBeforeSet()
                                      <PropertyGroup>
                                          <Foo>$(baz) $(bar)</Foo>
                                          <bar>Something</bar>
-                                         <baz>Something</baz>   
+                                         <baz>Something</baz>
                                      </PropertyGroup>
 
                                   <Target Name=""Test""/>
@@ -675,7 +675,7 @@ public void UsePropertyBeforeSetDuplicates()
                                          <Foo1>$(baz) $(bar)</Foo1>
                                          <Foo>$(baz) $(bar)</Foo>
                                          <bar>Something</bar>
-                                         <baz>Something</baz>   
+                                         <baz>Something</baz>
                                      </PropertyGroup>
 
                                   <Target Name=""Test""/>
@@ -1860,12 +1860,12 @@ public void AllEvaluatedItems()
                         <Choose>
                           <When Condition='false'>
                             <ItemGroup>
-                              <i Include='i4'/>                     
+                              <i Include='i4'/>
                             </ItemGroup>
                           </When>
                           <When Condition='true'>
                             <ItemGroup>
-                              <i Include='i1'>                     
+                              <i Include='i1'>
                                 <m>m2</m>
                               </i>
                             </ItemGroup>
@@ -1876,7 +1876,7 @@ public void AllEvaluatedItems()
                           <When Condition='false'/>
                           <Otherwise>
                             <ItemGroup>
-                              <i Include='i5'/>                     
+                              <i Include='i5'/>
                             </ItemGroup>
                           </Otherwise>
                         </Choose>
@@ -4340,7 +4340,7 @@ public void ThrownInvalidProjectExceptionProperlyHandled()
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"
                              <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns='msbuildnamespace'>
-                                
+
                                 <Import Project=""import.proj"" />
 
                             </Project>");
@@ -4392,9 +4392,9 @@ public void ThrownInvalidProjectExceptionProperlyHandled()
         /// <summary>
         /// Tests that an import, target, or task with a condition that contains an error but is short-circuited does not fail the build.  This can happen when you have a condition like:
         /// 'true' == 'false' AND '$([MSBuild]::GetDirectoryNameOfFileAbove($(NonExistentProperty), init.props))' != ''
-        /// 
+        ///
         /// The first condition is false so the second condition is not evaluated.  But in some cases we double evaluate the condition to log it.  The second evaluation will fail because it evaluates the whole string.
-        /// 
+        ///
         /// https://github.com/Microsoft/msbuild/issues/2259
         /// </summary>
         [Theory]
diff --git a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
index 73ba89b0e9b..2aa10111eeb 100644
--- a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
@@ -110,7 +110,7 @@ public void RemoveShouldPreserveIntermediaryReferences(string content)
                 {"m1", "m1_contents"},
                 {"m2", "m2_contents"}
             };
-            
+
             var itemsForI = items.Where(i => i.ItemType == "i").ToList();
             ObjectModelHelpers.AssertItems(new[] { "a", "b", "c" }, itemsForI, expectedMetadata);
 
@@ -508,7 +508,7 @@ public void MultipleInterItemDependenciesOnSameItemOperation()
                 new Dictionary<string, string>
                 {
                     {"m", "i2"}
-                }, 
+                },
                 i1BaseMetadata,
                 i1BaseMetadata
             };
@@ -528,7 +528,7 @@ public void MultipleInterItemDependenciesOnSameItemOperation()
         public void LongIncludeChain()
         {
             const int INCLUDE_COUNT = 10000;
-            
+
             //  This was about the minimum count needed to repro a StackOverflowException
             //const int INCLUDE_COUNT = 4000;
 
@@ -605,7 +605,7 @@ public void LazyWildcardExpansionDoesNotEvaluateWildCardsIfNotReferenced()
                 }
 
                 Assert.Equal(expectedItems, project.GetConcatenatedItemsOfType("i2"));
-                
+
                 var fullPathItems = project.GetConcatenatedItemsOfType("FullPath");
                 Assert.Contains("a.cs", fullPathItems);
                 Assert.Contains("b.cs", fullPathItems);
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index f158ca5a2bb..6af01de8d64 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -461,7 +461,7 @@ private Project(string projectFile, IDictionary<string, string> globalProperties
             {
                 // If possible, clear out the XML we just loaded into the XML cache:
                 // if we had loaded the XML from disk into the cache within this constructor,
-                // and then are are bailing out because there is a typo in the XML such that 
+                // and then are are bailing out because there is a typo in the XML such that
                 // evaluation failed, we don't want to leave the bad XML in the cache;
                 // the user wouldn't be able to fix the XML file and try again.
                 if (!ExceptionHandling.IsCriticalException(ex))
@@ -2503,7 +2503,7 @@ private List<GlobResult> GetAllGlobs(List<ProjectItemElement> projectItemElement
                 // 5. <I Include="C"/>
                 // 6. <I Remove="..."/> // this remove applies to the includes at 1, 3, 5
                 // So A's applicable removes are composed of:
-                // 
+                //
                 // The applicable removes for the element at position 1 (xml element A) are composed of:
                 // - all the removes seen by the next include statement of I's type (xml element B, position 3, which appears after A in file order). In this example that's Removes at positions 4 and 6.
                 // - new removes between A and B. In this example that's Remove 2.
@@ -2634,7 +2634,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>.
             /// </summary>
-            /// /// <param name="item"> 
+            /// /// <param name="item">
             /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
             /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
             /// The element that produced this <paramref name="item"/> is included in the results.
@@ -3163,7 +3163,7 @@ public override void RemoveItems(IEnumerable<ProjectItem> items)
                 ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
 
                 // Copying to a list makes it possible to remove
-                // all items of a particular type with 
+                // all items of a particular type with
                 //   RemoveItems(p.GetItems("mytype"))
                 // without modifying the collection during enumeration.
                 var itemsList = new List<ProjectItem>(items);
@@ -3586,7 +3586,7 @@ private void ReevaluateIfNecessary(
                 EvaluationContext evaluationContext = null)
             {
                 // We will skip the evaluation if the flag is set. This will give us better performance on scenarios
-                // that we know we don't have to reevaluate. One example is project conversion bulk addfiles and set attributes. 
+                // that we know we don't have to reevaluate. One example is project conversion bulk addfiles and set attributes.
                 if (!SkipEvaluation && !ProjectCollection.SkipEvaluation && IsDirty)
                 {
                     try
@@ -3684,9 +3684,9 @@ internal void Initialize(IDictionary<string, string> globalProperties, string to
                     {
                         if (String.Equals(pair.Key, Constants.SubToolsetVersionPropertyName, StringComparison.OrdinalIgnoreCase) && subToolsetVersion != null)
                         {
-                            // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property, 
-                            // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at 
-                            // a later point. 
+                            // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property,
+                            // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at
+                            // a later point.
                             globalPropertiesCollection.Set(ProjectPropertyInstance.Create(pair.Key, subToolsetVersion));
                         }
                         else
@@ -4185,7 +4185,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSyste
 
                 _globalPropertiesToTreatAsLocal?.Clear();
 
-                // Include the main project in the list of imports, as this list is 
+                // Include the main project in the list of imports, as this list is
                 // used to figure out if any of them have changed.
                 RecordImport(null, Project.Xml, Project.Xml.Version, null);
 
@@ -4225,7 +4225,7 @@ out var usingDifferentToolsVersionFromProjectFile
                     SubToolsetVersion = Toolset.GenerateSubToolsetVersion(GlobalPropertiesDictionary);
                 }
 
-                // Create a task registry which will fall back on the toolset task registry if necessary.          
+                // Create a task registry which will fall back on the toolset task registry if necessary.
                 TaskRegistry = new TaskRegistry(Toolset, Project.ProjectCollection.ProjectRootElementCache);
             }
 
@@ -4235,7 +4235,7 @@ out var usingDifferentToolsVersionFromProjectFile
             /// </summary>
             public void FinishEvaluation()
             {
-                // We assume there will be no further changes to the targets collection 
+                // We assume there will be no further changes to the targets collection
                 // This also makes sure that we are thread safe
                 Targets.MakeReadOnly();
 
@@ -4254,7 +4254,7 @@ public void FinishEvaluation()
                     }
                     else
                     {
-                        // Else we'll guess that this latest one is a potential match for the next, 
+                        // Else we'll guess that this latest one is a potential match for the next,
                         // if it actually has any elements (eg., it's not a .user or .filters file)
                         if (Targets.Count > 0)
                         {
@@ -4489,7 +4489,7 @@ internal bool RemoveItem(ProjectItem item)
 
                 // This remove will not succeed if the item include was changed.
                 // If many items are modified and then removed, this will leak them
-                // until the next reevaluation.                
+                // until the next reevaluation.
                 ItemsByEvaluatedIncludeCache.Remove(item.EvaluatedInclude, item);
 
                 ItemsIgnoringCondition.Remove(item);
diff --git a/src/Build/Definition/ProjectImportPathMatch.cs b/src/Build/Definition/ProjectImportPathMatch.cs
index f31d63fb957..1c670eb06a4 100644
--- a/src/Build/Definition/ProjectImportPathMatch.cs
+++ b/src/Build/Definition/ProjectImportPathMatch.cs
@@ -62,4 +62,4 @@ internal static ProjectImportPathMatch FactoryForDeserialization(ITranslator tra
             return new ProjectImportPathMatch(translator);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index a4e4d21565b..77d32963bf6 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -485,7 +485,7 @@ public string DefaultSubToolsetVersion
                         return Constants.Dev10SubToolsetValue;
                     }
 
-                    // 2) Otherwise, just pick the highest available. 
+                    // 2) Otherwise, just pick the highest available.
                     SortedDictionary<Version, string> subToolsetsWithVersion = new SortedDictionary<Version, string>();
                     List<string> additionalSubToolsetNames = new List<string>();
 
@@ -499,7 +499,7 @@ public string DefaultSubToolsetVersion
                         }
                         else
                         {
-                            // if it doesn't parse to an actual version number, shrug and just add it to the end. 
+                            // if it doesn't parse to an actual version number, shrug and just add it to the end.
                             additionalSubToolsetNames.Add(subToolsetName);
                         }
                     }
@@ -538,11 +538,11 @@ internal static bool Dev10IsInstalled
                 {
                     try
                     {
-                        // Figure out whether Dev10 is currently installed using the following heuristic: 
-                        // - Check whether the overall key (installed if any version of Dev10 is installed) is there. 
-                        //   - If it's not, no version of Dev10 exists or has ever existed on this machine, so return 'false'. 
-                        //   - If it is, we know that some version of Dev10 has been installed at some point, but we don't know 
-                        //     for sure whether it's still there or not.  Check the inndividual keys for {Pro, Premium, Ultimate, 
+                        // Figure out whether Dev10 is currently installed using the following heuristic:
+                        // - Check whether the overall key (installed if any version of Dev10 is installed) is there.
+                        //   - If it's not, no version of Dev10 exists or has ever existed on this machine, so return 'false'.
+                        //   - If it is, we know that some version of Dev10 has been installed at some point, but we don't know
+                        //     for sure whether it's still there or not.  Check the inndividual keys for {Pro, Premium, Ultimate,
                         //     C# Express, VB Express, C++ Express, VWD Express, LightSwitch} 2010
                         //     - If even one of them exists, return 'true'.
                         //     - Otherwise, return 'false.
@@ -804,7 +804,7 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
                 }
             }
 
-            // Next, try the toolset environment properties 
+            // Next, try the toolset environment properties
             if (_environmentProperties != null)
             {
                 ProjectPropertyInstance visualStudioVersionProperty = _environmentProperties[Constants.SubToolsetVersionPropertyName];
@@ -823,8 +823,8 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
                 subToolsetVersion = SubToolsets.Keys.FirstOrDefault(version => visualStudioVersionFromSolutionAsVersion.Equals(VersionUtilities.ConvertToVersion(version)));
             }
 
-            // Solution version also didn't work out, so fall back to default. 
-            // If subToolsetVersion is null, there simply wasn't a matching solution version. 
+            // Solution version also didn't work out, so fall back to default.
+            // If subToolsetVersion is null, there simply wasn't a matching solution version.
             return subToolsetVersion ?? (DefaultSubToolsetVersion);
         }
 
@@ -920,12 +920,12 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
 
-                    // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the 
-                    // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.  
+                    // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
+                    // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
                     int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
 
-                    // GenerateSubToolsetVersion checks the environment and global properties, so it's safe to go ahead and gather the 
-                    // subtoolset properties here without fearing that we'll have somehow come up with the wrong subtoolset version. 
+                    // GenerateSubToolsetVersion checks the environment and global properties, so it's safe to go ahead and gather the
+                    // subtoolset properties here without fearing that we'll have somehow come up with the wrong subtoolset version.
                     string subToolsetVersion = this.GenerateSubToolsetVersion();
                     SubToolset subToolset;
                     ICollection<ProjectPropertyInstance> subToolsetProperties = null;
@@ -941,10 +941,10 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
                     _propertyBag = new PropertyDictionary<ProjectPropertyInstance>(count);
 
-                    // Should be imported in the same order as in the evaluator:  
+                    // Should be imported in the same order as in the evaluator:
                     // - Environment
                     // - Toolset
-                    // - Subtoolset (if any) 
+                    // - Subtoolset (if any)
                     // - Global
                     _propertyBag.ImportProperties(_environmentProperties);
 
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index e2081dc5ad7..d49b10b1cf2 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -323,7 +323,7 @@ private static string GetValue(RegistryKeyWrapper wrapper, string valueName)
                 object result = wrapper.GetValue(valueName);
 
                 // RegistryKey.GetValue returns null if the value is not present
-                // and String.Empty if the value is present and no data is defined. 
+                // and String.Empty if the value is present and no data is defined.
                 // We preserve this distinction, because a string property in the registry with
                 // no value really has an empty string for a value (which is a valid property value)
                 // rather than null for a value (which is an invalid property value)
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index d47f970c517..cc71aafa860 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -696,7 +696,7 @@ private void Evaluate()
                     }
                 }
 
-                // If there was no DefaultTargets attribute found in the depth first pass, 
+                // If there was no DefaultTargets attribute found in the depth first pass,
                 // use the name of the first target. If there isn't any target, don't error until build time.
 
                 if (_data.DefaultTargets == null)
@@ -748,7 +748,7 @@ private void Evaluate()
 
                     if (Traits.Instance.EscapeHatches.DebugEvaluation)
                     {
-                        // This is so important for VS performance it's worth always tracing; accidentally having 
+                        // This is so important for VS performance it's worth always tracing; accidentally having
                         // inconsistent sets of global properties will cause reevaluations, which are wasteful and incorrect
                         if (_projectRootElement.Count > 0) // VB/C# will new up empty projects; they aren't worth recording
                         {
@@ -1002,7 +1002,7 @@ private void EvaluateUsingTaskElement(string directoryOfImportingFile, ProjectUs
         /// </summary>
         private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<ProjectTargetElement> activeTargetsByEvaluationOrder, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets)
         {
-            // If we already have read a target instance for this element, use that. 
+            // If we already have read a target instance for this element, use that.
             ProjectTargetInstance targetInstance = targetElement.TargetInstance ?? ReadNewTargetElement(targetElement, _projectSupportsReturnsAttribute[(ProjectRootElement)targetElement.Parent], _evaluationProfiler);
 
             string targetName = targetElement.Name;
@@ -1192,9 +1192,9 @@ private void AddToolsetProperties()
             }
             else
             {
-                // Make the subtoolset version itself available as a property -- but only if it's not already set. 
+                // Make the subtoolset version itself available as a property -- but only if it's not already set.
                 // Because some people may be depending on this value even if there isn't a matching sub-toolset,
-                // set the property even if there is no matching sub-toolset.  
+                // set the property even if there is no matching sub-toolset.
                 if (!_data.Properties.Contains(Constants.SubToolsetVersionPropertyName))
                 {
                     _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
@@ -1249,8 +1249,8 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
             using (_evaluationProfiler.TrackElement(propertyElement))
             {
                 // Global properties cannot be overridden.  We silently ignore them if we try.  Legacy behavior.
-                // That is, unless this global property has been explicitly labeled as one that we want to treat as overridable for the duration 
-                // of this project (or import). 
+                // That is, unless this global property has been explicitly labeled as one that we want to treat as overridable for the duration
+                // of this project (or import).
                 if (
                         ((IDictionary<string, ProjectPropertyInstance>)_data.GlobalPropertiesDictionary).ContainsKey(propertyElement.Name) &&
                         !_data.GlobalPropertiesToTreatAsLocal.Contains(propertyElement.Name)
@@ -2278,8 +2278,8 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                         }
                     }
 
-                    // Because these expressions will never be expanded again, we 
-                    // can store the unescaped value. The only purpose of escaping is to 
+                    // Because these expressions will never be expanded again, we
+                    // can store the unescaped value. The only purpose of escaping is to
                     // avoid undesired splitting or expansion.
                     _importsSeen.Add(importFileUnescaped, importElement);
                 }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 7a1cb4db89b..e666b97f94e 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -462,7 +462,7 @@ public GlobFragment(string textFragment, string projectDirectory)
     /// on multiple metadata. If one item specifies NotTargetFramework to be net46 and TargetFramework to
     /// be netcoreapp3.1, we wouldn't want to match that to an item with TargetFramework 46 and
     /// NotTargetFramework netcoreapp3.1.
-    /// 
+    ///
     /// Implementing this as a list of sets where each metadatum key has its own set also would not work
     /// because different items could match on different metadata, and we want to check to see if any
     /// single item matches on all the metadata. As an example, consider this scenario:
@@ -474,10 +474,10 @@ public GlobFragment(string textFragment, string projectDirectory)
     /// should match none of them because Forgind doesn't match all three metadata of any of the items.
     /// With a list of sets, Forgind would match Baby on BadAt, Child on GoodAt, and Adolescent on OkAt,
     /// and Forgind would be erroneously removed.
-    /// 
+    ///
     /// With a Trie as below, Items specify paths in the tree, so going to any child node eliminates all
     /// items that don't share that metadatum. This ensures the match is proper.
-    /// 
+    ///
     /// Todo: Tries naturally can have different shapes depending on in what order the metadata are considered.
     /// Specifically, if all the items share a single metadata value for the one metadatum and have different
     /// values for a second metadatum, it will have only one node more than the number of items if the first
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 02b46c31efa..da8165d3369 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -168,7 +168,7 @@ private string[] GetFileList
 
                 if (returnEscaped)
                 {
-                    // We must now go back and make sure all special characters are escaped because we always 
+                    // We must now go back and make sure all special characters are escaped because we always
                     // store data in the engine in escaped form so it doesn't interfere with our parsing.
                     // Note that this means that characters that were not escaped in the original filespec
                     // may now be escaped, but that's not easy to avoid.
diff --git a/src/Deprecated/Engine.UnitTests/Project_Tests.cs b/src/Deprecated/Engine.UnitTests/Project_Tests.cs
index 38f2844b922..1144ce87b6f 100644
--- a/src/Deprecated/Engine.UnitTests/Project_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Project_Tests.cs
@@ -26,8 +26,8 @@ public class AddItem
     {
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
-        /// add a new item (Type="Compile" Include="c.cs") to the project.  Then 
-        /// it compares the final project XML to make sure the item was added in 
+        /// add a new item (Type="Compile" Include="c.cs") to the project.  Then
+        /// it compares the final project XML to make sure the item was added in
         /// the correct place.
         /// </summary>
         /// <param name="originalProjectContents"></param>
@@ -49,7 +49,7 @@ string newItemInclude
             // The project shouldn't be marked dirty yet.
             Assertion.Assert("Project shouldn't be dirty", !project.IsDirtyNeedToReevaluate);
 
-            // Add a new item (Type="Compile", Include="c.cs") to the project using 
+            // Add a new item (Type="Compile", Include="c.cs") to the project using
             // the object model.
             BuildItem newItem = project.AddNewItem(newItemType, newItemInclude);
 
@@ -143,7 +143,7 @@ public void AddNewItemToNewItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -151,7 +151,7 @@ public void AddNewItemToNewItemGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -170,7 +170,7 @@ public void AddNewItemToNewItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -179,7 +179,7 @@ public void AddNewItemToNewItemGroup()
         }
 
         /// <summary>
-        /// This loads an existing project that did not contain any items previously. 
+        /// This loads an existing project that did not contain any items previously.
         /// It then uses the MSBuild object model to
         /// add a new item to the project.  Then it compares the final project
         /// XML to make sure the item was added in the correct place.
@@ -267,9 +267,9 @@ public void AddNewItemAndQueryForNonExistentMetadata()
         }
 
         /// <summary>
-        /// Add a new item of the same name and include path of an item that already 
+        /// Add a new item of the same name and include path of an item that already
         /// exists in the project.  Current behavior is that we add the duplicated item,
-        /// although there's no great reason for this.  If we wanted, we could have 
+        /// although there's no great reason for this.  If we wanted, we could have
         /// made it so that adding a dup results in a no-op to the project file.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -701,7 +701,7 @@ public void AddNewItemThatMatchesWildcardWithMetadata()
 
         /// <summary>
         /// There's a wildcard in the project already, but it's part of a semicolon-separated
-        /// list of items.  Now the user tries to add an item that matches that wildcard.  
+        /// list of items.  Now the user tries to add an item that matches that wildcard.
         /// In this case, we don't touch the project at all.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -741,7 +741,7 @@ public void AddNewItemThatMatchesWildcardInSemicolonList()
 
         /// <summary>
         /// There's a wildcard in the project already, but it's part of a semicolon-separated
-        /// list of items, and it uses a property reference.  Now the user tries to add a new 
+        /// list of items, and it uses a property reference.  Now the user tries to add a new
         /// item that matches that wildcard.  In this case, we don't touch the project at all.
         /// We're so smart.
         /// </summary>
@@ -803,7 +803,7 @@ public void AddNewItemGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -818,7 +818,7 @@ public void AddNewItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -826,7 +826,7 @@ public void AddNewItemGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -843,7 +843,7 @@ public void AddNewItemGroup()
                     <ItemGroup />
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -865,17 +865,17 @@ public class RemoveItem
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
         /// remove an item of a particular item spec (e.g., "b.cs").  It then
-        /// compares the final project XML to make sure the item was added in 
+        /// compares the final project XML to make sure the item was added in
         /// the correct place.
         /// </summary>
         /// <param name="originalProjectContents"></param>
         /// <param name="newExpectedProjectContents"></param>
         /// <param name="itemSpecToRemove"></param>
         /// <owner>RGoel</owner>
-        private void RemoveItemHelper 
+        private void RemoveItemHelper
             (
-            string originalProjectContents, 
-            string newExpectedProjectContents, 
+            string originalProjectContents,
+            string newExpectedProjectContents,
             string itemSpecToRemove
             )
         {
@@ -889,7 +889,7 @@ string itemSpecToRemove
 
             // The VS IDE does a few re-evaluations with different sets of global properties
             // (i.e., Configuration=Debug, Configuration=Release, etc.).  This is to simulate
-            // that.  If there's a bug in the Project object, then re-evaluation can 
+            // that.  If there's a bug in the Project object, then re-evaluation can
             // potentially mess up the number of items hanging around.
             project.MarkProjectAsDirty ();
             BuildItemGroup evaluatedItems2 = project.EvaluatedItemsIgnoringCondition;
@@ -936,9 +936,9 @@ public void RemoveItemBySpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -957,12 +957,12 @@ public void RemoveItemBySpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "b.cs");
         }
 
@@ -978,7 +978,7 @@ public void RemoveItemBySpecFromMultiItemSpec()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -993,9 +993,9 @@ public void RemoveItemBySpecFromMultiItemSpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1003,7 +1003,7 @@ public void RemoveItemBySpecFromMultiItemSpec()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -1019,12 +1019,12 @@ public void RemoveItemBySpecFromMultiItemSpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "b.cs");
         }
 
@@ -1042,7 +1042,7 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1052,7 +1052,7 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1060,7 +1060,7 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1073,10 +1073,10 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "b.cs");
         }
 
@@ -1101,7 +1101,7 @@ public void RemoveItemBySpecWhenMultiItemSpecExists()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1119,10 +1119,10 @@ public void RemoveItemBySpecWhenMultiItemSpecExists()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "d.cs");
         }
 
@@ -1153,7 +1153,7 @@ public void RemoveSpecificItem()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1174,7 +1174,7 @@ public void RemoveSpecificItem()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1226,7 +1226,7 @@ public void RemoveItemsByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1246,7 +1246,7 @@ public void RemoveItemsByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1287,7 +1287,7 @@ public void RemoveItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1303,7 +1303,7 @@ public void RemoveItemGroup()
                     </PropertyGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1667,8 +1667,8 @@ public class ModifyItem
     {
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
-        /// modify the "Include" attribute of an item of a particular item spec (e.g., 
-        /// "b.cs").  It then compares the final project XML to make sure the item was 
+        /// modify the "Include" attribute of an item of a particular item spec (e.g.,
+        /// "b.cs").  It then compares the final project XML to make sure the item was
         /// modified correctly.
         /// </summary>
         /// <param name="originalProjectContents"></param>
@@ -1676,10 +1676,10 @@ public class ModifyItem
         /// <param name="oldItemSpec"></param>
         /// <param name="newIncludePath"></param>
         /// <owner>RGoel</owner>
-        internal static void ModifyItemIncludeHelper 
+        internal static void ModifyItemIncludeHelper
             (
-            string originalProjectContents, 
-            string newExpectedProjectContents, 
+            string originalProjectContents,
+            string newExpectedProjectContents,
             string oldItemSpec,
             string newIncludePath
             )
@@ -1694,7 +1694,7 @@ string newIncludePath
 
             // The VS IDE does a few re-evaluations with different sets of global properties
             // (i.e., Configuration=Debug, Configuration=Release, etc.).  This is to simulate
-            // that.  If there's a bug in the Project object, then re-evaluation can 
+            // that.  If there's a bug in the Project object, then re-evaluation can
             // potentially mess up the number of items hanging around.
             project.MarkProjectAsDirty ();
             BuildItemGroup evaluatedItems2 = project.EvaluatedItemsIgnoringCondition;
@@ -1729,7 +1729,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -1749,7 +1749,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1757,7 +1757,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -1777,7 +1777,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1796,7 +1796,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1809,7 +1809,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1817,7 +1817,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1836,7 +1836,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1888,17 +1888,17 @@ public void ModifyItemIncludeWithinNonMatchingWildcard()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1906,7 +1906,7 @@ public void ModifyItemIncludeWithinNonMatchingWildcard()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1914,7 +1914,7 @@ public void ModifyItemIncludeWithinNonMatchingWildcard()
                         <MyWildcard Include=`banana.cs` />
                         <MyWildcard Include=`c.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1940,13 +1940,13 @@ public void ModifyItemIncludeWithinMatchingWildcard()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1954,13 +1954,13 @@ public void ModifyItemIncludeWithinMatchingWildcard()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1988,13 +1988,13 @@ public void ModifyRawItemIncludeWithinMatchingWildcard()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -2002,13 +2002,13 @@ public void ModifyRawItemIncludeWithinMatchingWildcard()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`banana.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -2073,8 +2073,8 @@ string itemSpec
 
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
-        /// modify the Name of an item of a particular item spec (e.g., 
-        /// "b.cs").  It then compares the final project XML to make sure the item was 
+        /// modify the Name of an item of a particular item spec (e.g.,
+        /// "b.cs").  It then compares the final project XML to make sure the item was
         /// modified correctly.
         /// </summary>
         /// <param name="originalProjectContents"></param>
@@ -2100,7 +2100,7 @@ string newItemType
 
             // The VS IDE does a few re-evaluations with different sets of global properties
             // (i.e., Configuration=Debug, Configuration=Release, etc.).  This is to simulate
-            // that.  If there's a bug in the Project object, then re-evaluation can 
+            // that.  If there's a bug in the Project object, then re-evaluation can
             // potentially mess up the number of items hanging around.
             project.MarkProjectAsDirty();
             BuildItemGroup evaluatedItems2 = project.EvaluatedItemsIgnoringCondition;
@@ -2270,7 +2270,7 @@ public void ModifyItemMetadata()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2285,7 +2285,7 @@ public void ModifyItemMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2293,7 +2293,7 @@ public void ModifyItemMetadata()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2311,7 +2311,7 @@ public void ModifyItemMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2338,7 +2338,7 @@ public void ModifyItemMetadata()
     public class AddProperty
     {
         /// <summary>
-        /// Tests that the object model correctly adds a new property to the correct 
+        /// Tests that the object model correctly adds a new property to the correct
         /// existing PropertyGroup.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -2348,23 +2348,23 @@ public void SetPropertyOnNewPropertyInExistingPropertyGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup Condition=` '$(A)' == 'B' `>
                         <OutputPath>c:\blah</OutputPath>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <WarningLevel>1</WarningLevel>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <Optimize>true</Optimize>
                     </PropertyGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2372,24 +2372,24 @@ public void SetPropertyOnNewPropertyInExistingPropertyGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup Condition=` '$(A)' == 'B' `>
                         <OutputPath>c:\blah</OutputPath>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <WarningLevel>1</WarningLevel>
                         <MyNewProperty>woohoo</MyNewProperty>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <Optimize>true</Optimize>
                     </PropertyGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2398,7 +2398,7 @@ public void SetPropertyOnNewPropertyInExistingPropertyGroup()
             // The project shouldn't be marked dirty yet.
             Assertion.Assert("Project shouldn't be dirty", !project.IsDirtyNeedToReevaluate);
 
-            // Set the given new property in the project file using 
+            // Set the given new property in the project file using
             // the object model.
             project.SetProperty("MyNewProperty", "woohoo", "");
 
@@ -2419,7 +2419,7 @@ public void AddNewPropertyThroughPropertyGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2434,7 +2434,7 @@ public void AddNewPropertyThroughPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2442,7 +2442,7 @@ public void AddNewPropertyThroughPropertyGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2458,7 +2458,7 @@ public void AddNewPropertyThroughPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2484,7 +2484,7 @@ public void AddNewPropertyGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2499,7 +2499,7 @@ public void AddNewPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2507,7 +2507,7 @@ public void AddNewPropertyGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2524,7 +2524,7 @@ public void AddNewPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2640,7 +2640,7 @@ public void RemovePropertyByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2663,7 +2663,7 @@ public void RemovePropertyByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2914,7 +2914,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -2923,7 +2923,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -3112,7 +3112,7 @@ public void SetPropertyOnExistingProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -3135,7 +3135,7 @@ public void SetPropertyOnExistingProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -3446,7 +3446,7 @@ public void VerifyMsbuildProgramFiles32ReservedProperty()
                                 <PropertyGroup>
                                     <abcdef>$(MsBuildProgramFiles32)</abcdef>
                                 </PropertyGroup>
-                                
+
                                 <Target Name='t'>
                                     <Message Text='[$(abcdef)]' />
                                 </Target>
@@ -3513,7 +3513,7 @@ public void ModifyPropertyInImportedProjectFileAfterRename()
             Assertion.AssertEquals(@"c:\boobah", importedProj.EvaluatedProperties["ReferencePath"].FinalValueEscaped);
 
             importedProj.Save(Path.Combine(ObjectModelHelpers.TempProjectDir, "newimported.proj"));
-                
+
             // Now we add a new imported property to the main file, into an existing imported
             // property group.
             mainProj.SetImportedProperty("ReferencePath", @"c:\hoohah", null, importedProj);
@@ -3785,7 +3785,7 @@ public void RegistryProperties()
 
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <P>$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Foo)</P>
                         <Q Condition=""'$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Foo)' == 'FooValue'"">QValue</Q>
@@ -3812,7 +3812,7 @@ public void RegistryPropertiesWithEscapedCharactersInValue()
 
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <P>$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Foo)</P>
                         <Q Condition=""'$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Bar)' == '%24(Foo)'"">QValue</Q>
@@ -3834,7 +3834,7 @@ public class QueryProjectState
     {
         /// <summary>
         /// This tests the Project.EvaluatedItemsIgnoringCondition property.  This
-        /// property should return the list of evaluated items in the project, 
+        /// property should return the list of evaluated items in the project,
         /// pretending that all "Condition"s evaluated to true.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -3856,7 +3856,7 @@ public void GetEvaluatedItemsIgnoringCondition()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -4098,7 +4098,7 @@ public void ReplaceImport()
     public class Evaluation
     {
         /// <summary>
-        /// Relative paths in 'exists' on conditions should be evalauted relative to the 
+        /// Relative paths in 'exists' on conditions should be evalauted relative to the
         /// project directory.
         /// </summary>
         [Test]
@@ -4142,7 +4142,7 @@ public void ImportConditionsEvaluatedUsingProjectsDirectory()
         }
 
         /// <summary>
-        /// Relative paths in 'exists' on conditions should be evalauted relative to the 
+        /// Relative paths in 'exists' on conditions should be evalauted relative to the
         /// project directory.
         /// </summary>
         [Test]
@@ -4181,7 +4181,7 @@ public void PropertyConditionsEvaluatedUsingProjectsDirectory()
         }
 
         /// <summary>
-        /// Relative paths in 'exists' on conditions should be evalauted relative to the 
+        /// Relative paths in 'exists' on conditions should be evalauted relative to the
         /// project directory.
         /// </summary>
         [Test]
@@ -4387,7 +4387,7 @@ public void InvalidMetadataName()
                         <a Include=`x`>
                             <meta.data>foo</meta.data>
                         </a>
-                    </ItemGroup>        
+                    </ItemGroup>
                     <Target Name=`t` />
                 </Project>
                 ";
@@ -4432,7 +4432,7 @@ public void IllegalCharactersInUsingTaskAssemblyFile()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(original);
         }
-        
+
         /// <summary>
         /// Unknown attribute on UsingTask should throw
         /// </summary>
@@ -4449,7 +4449,7 @@ public void UnknownAttributeInUsingTask()
 
             // Should throw
             Project project = ObjectModelHelpers.CreateInMemoryProject(original);
-        }                  
+        }
 
         /// <summary>
         /// RequiredRuntime attribute on UsingTask should be ignored
@@ -4467,10 +4467,10 @@ public void RequiredRuntimeAttributeInUsingTask()
 
             // Should not throw
             Project project = ObjectModelHelpers.CreateInMemoryProject(original);
-        }        
+        }
 
         /// <summary>
-        /// Tests that putting invalid characters in the <Import> path results in a 
+        /// Tests that putting invalid characters in the <Import> path results in a
         /// InvalidProjectFileException.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -4589,7 +4589,7 @@ public void SetNewGlobalProperty()
         }
 
         /// <summary>
-        /// This tests that the project is NOT marked as dirty when we set a 
+        /// This tests that the project is NOT marked as dirty when we set a
         /// global property to the exact same value it had before.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -4649,7 +4649,7 @@ public void MSBuildExtensionsPathDefault()
             {
                 expectedValue = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
             }
-     
+
             Assertion.AssertEquals(expectedValue + @"\MSBuild",
                 (string)myProject.EvaluatedProperties[specialPropertyName]);
 
@@ -4664,7 +4664,7 @@ public void MSBuildExtensionsPathDefault()
         public void MSBuildExtensionsPathDefault_Legacy()
         {
             string specialPropertyName = "MSBuildExtensionsPath";
-            
+
             // Save the old copy of the MSBuildExtensionsPath, so we can restore it when the unit test is done.
             string backupMSBuildExtensionsPath = Environment.GetEnvironmentVariable(specialPropertyName);
             string backupMagicSwitch = Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH");
@@ -4753,7 +4753,7 @@ public void MSBuildExtensionsPathWithGlobalOverride()
         }
 
         /// <summary>
-        /// The default value for $(MSBuildExtensionsPath32) should point to "c:\program files (x86)\msbuild" on a 64 bit machine. 
+        /// The default value for $(MSBuildExtensionsPath32) should point to "c:\program files (x86)\msbuild" on a 64 bit machine.
         /// We can't test that directly since tests generally don't run on 64 bit boxes. However we can set the "ProgramFiles(x86)"
         /// environment variable and make sure that that's the value used.
         /// </summary>
@@ -5006,7 +5006,7 @@ public void MSBuildStartupDirectory()
     public class LoadAndSave
     {
         /// <summary>
-        /// Just load an MSBuild project by passing in a TextReader, and get back the contents to 
+        /// Just load an MSBuild project by passing in a TextReader, and get back the contents to
         /// make sure the project was read in correctly.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -5206,7 +5206,7 @@ public void RemoveMissingImportAndLoadNormally()
             // Save the modified project
             StringWriter writer = new StringWriter();
             project.Save(writer);
-            
+
             // Load the modified project into a new project object
             xmldoc = new XmlDocument();
             xmldoc.LoadXml(writer.ToString());
@@ -5258,7 +5258,7 @@ public void FailingTargetsDoNotHaveOutputs()
         }
 
         /// <summary>
-        /// Checks to make sure that passing in the DoNotResetPreviouslyBuiltTargets flag 
+        /// Checks to make sure that passing in the DoNotResetPreviouslyBuiltTargets flag
         /// works as expected.
         /// </summary>
         /// <owner>JomoF</owner>
@@ -5287,7 +5287,7 @@ public void CheckDoNotResetPreviouslyBuiltTargets()
             // At this point, the property $(FileExists) should be 'true'
             Assertion.AssertEquals("true", p.GetEvaluatedProperty("FileExists"));
 
-            // Delete the file 
+            // Delete the file
             File.Delete(tempFile);
 
             // Build again. The result should still be 'true' because the target won't be reevaluated.
@@ -5353,7 +5353,7 @@ public void RunInitialTargetsInMainProject()
 
             // Build the target.
             p.Build(null, null);
-        
+
             Assertion.Assert("Build target should have been run.", myLogger.FullLog.Contains("BuildTargetExecuted"));
             Assertion.Assert("CheckForErrors target should have been run.", myLogger.FullLog.Contains("CheckForErrorsTargetExecuted"));
         }
@@ -5457,14 +5457,14 @@ public void RunInitialTargetsInMainAndImportedProjects()
 
                     ", importedProject1, importedProject2));
 
-                Assertion.AssertEquals("Check all InitialTargets", "CheckForBadUser; CheckForBadProperties; CheckForBadConfigurations", 
+                Assertion.AssertEquals("Check all InitialTargets", "CheckForBadUser; CheckForBadProperties; CheckForBadConfigurations",
                     p.InitialTargets);
 
                 // Build the default target.
                 p.Build(null, null);
 
                 DumpBuildItemGroup(p.GetEvaluatedItemsByName("TargetOrder"));
-            
+
                 // The following method will ensure that the targets were executed in the correct order.
                 EngineHelpers.AssertItemsMatch(@"
                     CheckForBadUser_Executed
@@ -5479,14 +5479,14 @@ public void RunInitialTargetsInMainAndImportedProjects()
                 // Change the InitialTargets on the main project to be "NewChecks", but do it via an environment variable.
                 p.InitialTargets = "$(MyNewChecks)";
 
-                Assertion.AssertEquals("Check all InitialTargets", "NewChecks; CheckForBadProperties; CheckForBadConfigurations", 
+                Assertion.AssertEquals("Check all InitialTargets", "NewChecks; CheckForBadProperties; CheckForBadConfigurations",
                     p.InitialTargets);
 
                 // Build the default target.
                 p.Build(null, null);
 
                 DumpBuildItemGroup(p.GetEvaluatedItemsByName("TargetOrder"));
-            
+
                 // The following method will ensure that the targets were executed in the correct order.
                 EngineHelpers.AssertItemsMatch(@"
                     NewChecks_Executed
@@ -5555,7 +5555,7 @@ public void ModifyInitialTargetsInMainProject()
 
             // Build the default target.
             p.Build(null, null);
-        
+
             Assertion.Assert("Build target should have been run.", myLogger.FullLog.Contains("BuildTargetExecuted"));
             Assertion.Assert("CheckForErrors target should have been run.", myLogger.FullLog.Contains("CheckForErrorsTargetExecuted"));
         }
@@ -5680,7 +5680,7 @@ public void SetGetProjectExtensions()
         }
 
         /// <summary>
-        /// There is a certain error that the MSBuild engine fires when you try to do a build on 
+        /// There is a certain error that the MSBuild engine fires when you try to do a build on
         /// a project that has had its targets disabled because of security.  However, the project
         /// system doesn't want to show this error to the user because it's not actionable for
         /// the user.  So it looks for code MSB4112 to throw away this error.  Here we're just
@@ -5693,10 +5693,10 @@ public void VerifySecurityErrorHasCodeMSB4112()
         {
             ResourceManager resourceManager = new ResourceManager("Microsoft.Build.Engine.Resources.Strings", typeof(Project).Assembly);
             string securityMessage = resourceManager.GetString("SecurityProjectBuildDisabled", CultureInfo.CurrentUICulture);
-            
-            Assertion.Assert( 
+
+            Assertion.Assert(
                 "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp.",
-                securityMessage.Contains("MSB4112") 
+                securityMessage.Contains("MSB4112")
             );
         }
 
@@ -5790,12 +5790,12 @@ public void RegressVsWhidbey579075()
                     </Target>
                 </Project>
                 ", logger);
-            
+
             // Set a property and force project evaluation
             project.SetProperty("Configuration", "Release");
             BuildPropertyGroup evaluatedProperties = project.EvaluatedProperties;
 
-            // Set a different value of the property and build without forced reevaluation, 
+            // Set a different value of the property and build without forced reevaluation,
             // check if the new value is passed to the logger
             project.SetProperty("Configuration", "Debug");
             project.Build();
@@ -5815,7 +5815,7 @@ public void VersionBasedMSBuildBinPathDefault()
                     <Target Name=`Build`/>
                 </Project>", null);
 
-            Assertion.AssertEquals("Nonexistent ToolsVersion should evaluate to the default version", 
+            Assertion.AssertEquals("Nonexistent ToolsVersion should evaluate to the default version",
                 Constants.defaultToolsVersion, project.ToolsVersion);
 
             Assertion.AssertEquals("Nonexistent ToolsVersion should mean ToolsVersionAttribute is the default version",
@@ -5823,7 +5823,7 @@ public void VersionBasedMSBuildBinPathDefault()
 
             Assertion.AssertEquals("BinPath is the MSBuildBinPath for the default version",
                 "www.msbuild.org", project.EvaluatedProperties[ReservedPropertyNames.binPath].FinalValue);
-            
+
             Assertion.AssertEquals("BinPath is the MSBuildToolsPath for the default version",
                 "www.msbuild.org", project.EvaluatedProperties[ReservedPropertyNames.toolsPath].FinalValue);
         }
@@ -5839,7 +5839,7 @@ public void VersionBasedMSBuildBinPathExplicit()
                     <Target Name=`Build`/>
                 </Project>", null);
 
-            Assertion.AssertEquals("ToolsVersion should have been picked up from the project attribute", 
+            Assertion.AssertEquals("ToolsVersion should have been picked up from the project attribute",
                 "myValidToolsVersion", project.ToolsVersion);
 
             Assertion.AssertEquals("ToolsVersionAttribute should have been picked up from the project attribute",
@@ -6010,7 +6010,7 @@ public void MSBuildToolsVersionProperty()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(e, ObjectModelHelpers.CleanupFileContents(@"
                 <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
-                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
                     <Target Name=`Build`>
                         <Message Text=`##$(MSBuildToolsVersion)##`/>
                     </Target>
@@ -6031,7 +6031,7 @@ public void MSBuildToolsVersionProperty2()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(e, ObjectModelHelpers.CleanupFileContents(@"
                 <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
-                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
                     <Target Name=`Build`>
                         <Message Text=`##$(MSBuildToolsVersion)##`/>
                     </Target>
@@ -6054,7 +6054,7 @@ public void SetEffectiveToolsVersionAttribute()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(e, ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion=`myValidToolsVersion` DefaultTargets=`Build` xmlns=`msbuildnamespace`>
-                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
                     <PropertyGroup>
                        <TheToolsVersion>$(MSBuildToolsVersion)</TheToolsVersion>
                     </PropertyGroup>
@@ -6130,4 +6130,3 @@ public void PropertiesFromToolsetAppliedToProjectWhenToolsVersionOverridden()
         }
     }
 }
-
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index 5a5ff319324..da393b51c0c 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -435,7 +435,7 @@ internal void ReportUnhandledError(Exception originalException)
                 }
                 catch (Exception ex)
                 {
-                    // If an error occurred while trying to send the original exception to the parent 
+                    // If an error occurred while trying to send the original exception to the parent
                     // rethrow the original exception
                     string message = ResourceUtilities.FormatResourceString("FatalErrorOnChildNode", nodeId, ex.Message);
 
@@ -630,7 +630,7 @@ private void NodeLocalEngineLoop()
         private ManualResetEvent exitNodeEvent;
         // The engine being used to process build requests
         private Engine localEngine;
-        // The queue of build requests arriving from the parent. The queue is needed to buffer the requests while the local engine is 
+        // The queue of build requests arriving from the parent. The queue is needed to buffer the requests while the local engine is
         // being created and initialized
         private Queue<BuildRequest> buildRequests;
         // This flag is true if the thread that will be running the Engine.BuildLoop has been launched
diff --git a/src/Deprecated/Engine/Introspector/Introspector.cs b/src/Deprecated/Engine/Introspector/Introspector.cs
index a4c0f0cfc87..203896320f5 100644
--- a/src/Deprecated/Engine/Introspector/Introspector.cs
+++ b/src/Deprecated/Engine/Introspector/Introspector.cs
@@ -26,7 +26,7 @@ internal Introspector(Engine parentEngine, ProjectManager projectManager, NodeMa
         /// <summary>
         /// This method is called when the parent engine doesn't see activity for a preset time period to
         /// determine if the whole system is making forward progress. In order to that, status is collected
-        /// from every node in the system. If no node is making forward progress then the graph of all the 
+        /// from every node in the system. If no node is making forward progress then the graph of all the
         /// inprogress targets is analyzed for cycles. If a cycle is found the appropriate node is instructed
         /// to break it. If no cause for deadlock can be determined the system is shutdown.
         /// </summary>
@@ -90,7 +90,7 @@ internal int DetectDeadlock( int queueCounts, long lastLoopActivity, int current
                 }
                 else if (nodeStatus[i].HasExited)
                 {
-                    // A node has exited prematurely. The only option is to shutdown 
+                    // A node has exited prematurely. The only option is to shutdown
                     LogOrDumpError("ChildExitedPrematurely", i + 1);
 
                     SystemShutdown();
@@ -142,7 +142,7 @@ internal int DetectDeadlock( int queueCounts, long lastLoopActivity, int current
                                                   cycleDetector.CycleEdgeParent);
                 // Use the amount of time it took us to receive the NodeStatus and buffer it a little because node status is sent via a faster code path
                 ignoreTimeout = DateTime.Now.Ticks + requestDurationTime + (cycleBreakTimeout * TimeSpan.TicksPerMillisecond);
-                return currentTimeout; 
+                return currentTimeout;
             }
 
             // The system doesn't appear to be making progress. Switch to a largest sampling interval.
@@ -208,7 +208,7 @@ private void LogOrDumpError(string resourceName, params object[] args)
         }
 
         /// <summary>
-        /// Adds a set of nodeStatus's to the cycle graph 
+        /// Adds a set of nodeStatus's to the cycle graph
         /// </summary>
         private void AddTargetStatesToCycleDetector(NodeStatus[] nodeStatus, TargetCycleDetector cycleDetector)
         {
@@ -229,7 +229,7 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
             {
                 TimeSpan timeSinceLastNodeTaskActivity = new TimeSpan(nodeStatus[i].TimeSinceLastTaskActivity);
                 TimeSpan timeSinceLastNodeLoopActivity = new TimeSpan(nodeStatus[i].TimeSinceLastLoopActivity);
- 
+
                 Console.WriteLine("Status: " + i + " Task Activity " + timeSinceLastNodeTaskActivity.TotalMilliseconds +
                                   " Loop Activity " + timeSinceLastNodeLoopActivity.TotalMilliseconds + " Queue depth " +
                                   nodeStatus[i].QueueDepth);
@@ -262,11 +262,11 @@ internal void SystemShutdown()
 
 
         /// <summary>
-        /// This function is called to break the link between two targets that creates a cycle. The link could be 
+        /// This function is called to break the link between two targets that creates a cycle. The link could be
         /// due to depends/onerror relationship between parent and child. In that case both parent and child are
-        /// on the same node and within the same project. Or the link could be formed by an IBuildEngine callback 
-        /// (made such by tasks such as MSBuild or CallTarget) in which case there maybe multiple requests forming 
-        /// same link between parent and child. Also in that case parent and child maybe on different nodes and/or in 
+        /// on the same node and within the same project. Or the link could be formed by an IBuildEngine callback
+        /// (made such by tasks such as MSBuild or CallTarget) in which case there maybe multiple requests forming
+        /// same link between parent and child. Also in that case parent and child maybe on different nodes and/or in
         /// different projects. In either case the break is forced by finding the correct builds states and causing
         /// them to fail.
         /// </summary>
@@ -291,7 +291,7 @@ internal void BreakCycle(TargetInProgessState child, TargetInProgessState parent
             {
                 parentStates[i].CurrentBuildContextState = ProjectBuildState.BuildContextState.CycleDetected;
                 TaskExecutionContext taskExecutionContext =
-                    new TaskExecutionContext(parentProject, childTarget, null, parentStates[i], EngineCallback.invalidEngineHandle, 
+                    new TaskExecutionContext(parentProject, childTarget, null, parentStates[i], EngineCallback.invalidEngineHandle,
                                              EngineCallback.inProcNode, null);
 
                 parentEngine.PostTaskOutputUpdates(taskExecutionContext);
@@ -305,7 +305,7 @@ internal void BreakCycle(TargetInProgessState child, TargetInProgessState parent
         /// </summary>
         internal List<ProjectBuildState> FindConnectingContexts
         (
-            TargetInProgessState child, 
+            TargetInProgessState child,
             TargetInProgessState parent,
             Target childTarget,
             List<ProjectBuildState> waitingStates,
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index 07cc648695e..eb73adeb434 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -59,7 +59,7 @@ string startupDirectory
             }
 
             /* If we dont get a path passed in as a parameter, we can only assume that our path
-             is in the current appdomain basedirectory, this is the base directory 
+             is in the current appdomain basedirectory, this is the base directory
               that the assembly resolver uses to probe for assemblies
            */
             if (string.IsNullOrEmpty(this.locationOfMSBuildExe))
@@ -90,7 +90,7 @@ string startupDirectory
                 lastUsedNodeNumber = nodeData[i].NodeNumber + 1;
             }
 
-            // Set up the callback 
+            // Set up the callback
             this.engineCallback = parentEngineCallback;
             this.parentGlobalProperties = parentGlobalPropertyGroup;
             this.toolsetSearchLocations = toolSetSearchLocations;
@@ -228,7 +228,7 @@ public void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
             if (nodeData[nodeIndex].NodeState != NodeState.Launched)
             {
                 // Note that we have to check the node status again inside the mutex. This
-                // ensures that that after flipping the status to launched inside the mutex 
+                // ensures that that after flipping the status to launched inside the mutex
                 // there will be no more writes to the queue of targets waiting to be sent
                 lock (nodeStateLock)
                 {
@@ -319,7 +319,7 @@ public void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
                 }
             }
 
-            // Reset the shutdown response received properties incase the nodes are going 
+            // Reset the shutdown response received properties incase the nodes are going
             // to be used for another build on the same engine.
             foreach (LocalNodeInfo nodeInfo in nodeData)
             {
@@ -459,7 +459,7 @@ private void TerminateChildNode(int processId)
             }
             catch (System.ComponentModel.Win32Exception)
             {
-                // The exception indicates that the child process is no longer running or 
+                // The exception indicates that the child process is no longer running or
                 // the parent cannot access the child process information due to insufficent security permissions
             }
         }
@@ -697,7 +697,7 @@ private void InitializeNode(int nodeIndex)
                         nodeInUseEvent.Close();
 
                         // If the node is still active and has not replied to the initialization message it must
-                        // be in bad state - try to get that node to exit 
+                        // be in bad state - try to get that node to exit
                         if (!nodeConnected && checkIfNodeActive(nodeData[nodeIndex].NodeNumber))
                         {
                             EventWaitHandle nodeShutdownEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeErrorShutdownEventName(nodeData[nodeIndex].NodeNumber));
@@ -738,7 +738,7 @@ private static  bool checkIfNodeActive(int nodeNumber)
             }
             catch (WaitHandleCannotBeOpenedException)
             {
-                // Assume that the node is not running 
+                // Assume that the node is not running
             }
             finally
             {
diff --git a/src/Deprecated/Engine/Shared/ErrorUtilities.cs b/src/Deprecated/Engine/Shared/ErrorUtilities.cs
index 213310ce25e..1af0f4ceb05 100644
--- a/src/Deprecated/Engine/Shared/ErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ErrorUtilities.cs
@@ -32,7 +32,7 @@ internal static void LaunchMsBuildDebuggerOnFatalError()
         /// Puts up an assertion dialog in debug builds, and throws an exception in
         /// both debug and release builds. Since this is not a no-op in release builds,
         /// it should not be called repeatedly in performance-critical scenarios.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -48,7 +48,7 @@ private static void ThrowInternalError
             params object[] args
         )
         {
-            // We ignore showAssert:  we don't want to show the assert dialog no matter what. 
+            // We ignore showAssert:  we don't want to show the assert dialog no matter what.
             throw new InternalErrorException(ResourceUtilities.FormatString(unformattedMessage, args));
         }
 
@@ -243,7 +243,7 @@ object arg3
 
         /// <summary>
         /// Throws an InvalidOperationException.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -597,7 +597,7 @@ internal static void VerifyThrowArgumentNull(object parameter, string parameterN
         {
             if (parameter == null)
             {
-                // Most ArgumentNullException overloads append its own rather clunky multi-line message. 
+                // Most ArgumentNullException overloads append its own rather clunky multi-line message.
                 // So use the one overload that doesn't.
                 throw new ArgumentNullException(
                     ResourceUtilities.FormatResourceString(resourceName, parameterName),
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index fd30818c312..bf0b4845cec 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.BuildEngine.Shared
     internal static class FrameworkLocationHelper
     {
         #region Private and internal members
-        
+
         /// <summary>
         /// By default when a root path is not specified we would like to use the program files directory \ reference assemblies\framework as the root location
         /// to generate the reference assembly paths from.
@@ -48,9 +48,9 @@ internal static class FrameworkLocationHelper
         internal const string fullDotNetFrameworkSdkRegistryKeyV35 = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathV35;
         private const string dotNetFrameworkRegistryKeyV35 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
         internal const string dotNetFrameworkSdkInstallKeyValueV35 = "InstallationFolder";
-       
+
         internal const string dotNetFrameworkVersionFolderPrefixV35 = "v3.5"; // v3.5 is for Orcas.
-        
+
         private const string dotNetFrameworkAssemblyFoldersRegistryKeyV35 = dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
         private const string secondaryDotNetFrameworkSdkRegistryPathV35 = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows";
         internal const string secondaryDotNetFrameworkSdkInstallKeyValueV35 = "CurrentInstallFolder";
@@ -66,8 +66,7 @@ internal static class FrameworkLocationHelper
         internal const string secondaryDotNetFrameworkSdkInstallKeyValueV40 = "CurrentInstallFolder";
         private const string dotNetFrameworkRegistryKeyV40 = dotNetFrameworkSetupRegistryPath + "\\v4\\Full";
         private static readonly GetDirectories getDirectories = new GetDirectories(Directory.GetDirectories);
-        
-        
+
         private static string pathToDotNetFrameworkV11;
         internal static string PathToDotNetFrameworkV11
         {
@@ -249,13 +248,13 @@ internal static string PathToDotNetFrameworkSdkV35
                         dotNetFrameworkSdkInstallKeyValueV35);
 
                     // Because there is no longer a strong 1:1 mapping between FX versions and SDK
-                    // versions, if we're unable to locate the desired SDK version, we will try to 
+                    // versions, if we're unable to locate the desired SDK version, we will try to
                     // use whichever SDK version is installed by looking at the key pointing to the
                     // "latest" version.
                     //
-                    // This isn't ideal, but it will allow our tasks to function on any of several 
+                    // This isn't ideal, but it will allow our tasks to function on any of several
                     // related SDKs even if they don't have exactly the same versions.
-                    
+
                     if (String.IsNullOrEmpty(FrameworkLocationHelper.pathToDotNetFrameworkSdkV35))
                     {
                         FrameworkLocationHelper.pathToDotNetFrameworkSdkV35 = FindRegistryValueUnderKey(
@@ -281,11 +280,11 @@ internal static string PathToDotNetFrameworkSdkV40
                         dotNetFrameworkSdkInstallKeyValueV40);
 
                     // Because there is no longer a strong 1:1 mapping between FX versions and SDK
-                    // versions, if we're unable to locate the desired SDK version, we will try to 
+                    // versions, if we're unable to locate the desired SDK version, we will try to
                     // use whichever SDK version is installed by looking at the key pointing to the
                     // "latest" version. For example, instead of 6.0A, we might fall back to 6.0B.
                     //
-                    // This isn't ideal, but it will allow our tasks to function on any of several 
+                    // This isn't ideal, but it will allow our tasks to function on any of several
                     // related SDKs even if they don't have exactly the same versions.
 
                     if (String.IsNullOrEmpty(FrameworkLocationHelper.pathToDotNetFrameworkSdkV40))
@@ -506,7 +505,7 @@ GetDirectories getDirectories
             // The intention here is to choose the alphabetical maximum.
             string max = directories[0];
 
-            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.  
+            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.
             // This was removed in beta2
             // We should favor \v3.5 over \v3.5.xxxxx
             // versions previous to 2.0 have .xxxx version numbers.  3.0 and 3.5 do not.
@@ -530,7 +529,7 @@ GetDirectories getDirectories
         }
 
         #endregion
- 
+
         /// <summary>
         /// Determine the 32 bit program files directory, this is used for finding where the reference assemblies live.
         /// </summary>
@@ -549,7 +548,7 @@ internal static string GenerateProgramFiles32()
         }
 
         /// <summary>
-        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then 
+        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then
         /// using that path to generate the path to the reference assemblies location.
         /// </summary>
         internal static string GenerateProgramFilesReferenceAssemblyRoot()
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c5809755219..65784511483 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1937,7 +1937,7 @@ public void ProcessConsoleLoggerSwitches()
         {
             var loggers = new List<ILogger>();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
-            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); 
+            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
             string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
 
             MSBuildApp.ProcessConsoleLoggerSwitch
@@ -1991,7 +1991,7 @@ public void RestoreFirstReevaluatesImportGraph()
   <PropertyGroup>
     <RestoreFirstProps>{Guid.NewGuid():N}.props</RestoreFirstProps>
   </PropertyGroup>
-  
+
   <Import Project=""$(RestoreFirstProps)"" Condition=""Exists($(RestoreFirstProps))""/>
 
   <Target Name=""Build"">
@@ -2003,10 +2003,10 @@ public void RestoreFirstReevaluatesImportGraph()
     <ItemGroup>
       <Lines Include=""&lt;Project ToolsVersion=&quot;Current&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;&lt;PropertyGroup&gt;&lt;PropertyA&gt;{guid}&lt;/PropertyA&gt;&lt;/PropertyGroup&gt;&lt;/Project&gt;"" />
     </ItemGroup>
-    
+
     <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
   </Target>
-  
+
 </Project>");
 
             string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: "/restore");
@@ -2026,7 +2026,7 @@ public void RestoreFirstClearsProjectRootElementCache()
   <PropertyGroup>
     <RestoreFirstProps>{restoreFirstProps}</RestoreFirstProps>
   </PropertyGroup>
-  
+
   <Import Project=""$(RestoreFirstProps)"" Condition=""Exists($(RestoreFirstProps))""/>
 
   <Target Name=""Build"">
@@ -2039,10 +2039,10 @@ public void RestoreFirstClearsProjectRootElementCache()
     <ItemGroup>
       <Lines Include=""&lt;Project ToolsVersion=&quot;Current&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;&lt;PropertyGroup&gt;&lt;PropertyA&gt;{guid2}&lt;/PropertyA&gt;&lt;/PropertyGroup&gt;&lt;/Project&gt;"" />
     </ItemGroup>
-    
+
     <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
   </Target>
-  
+
 </Project>");
 
             IDictionary<string, string> preExistingProps = new Dictionary<string, string>
@@ -2073,7 +2073,7 @@ public void RestoreIgnoresMissingImports()
   <PropertyGroup>
     <RestoreFirstProps>{restoreFirstProps}</RestoreFirstProps>
   </PropertyGroup>
-  
+
   <Import Project=""$(RestoreFirstProps)"" />
 
   <Target Name=""Build"">
@@ -2086,10 +2086,10 @@ public void RestoreIgnoresMissingImports()
     <ItemGroup>
       <Lines Include=""&lt;Project ToolsVersion=&quot;Current&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;&lt;PropertyGroup&gt;&lt;PropertyA&gt;{guid2}&lt;/PropertyA&gt;&lt;/PropertyGroup&gt;&lt;/Project&gt;"" />
     </ItemGroup>
-    
+
     <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
   </Target>
-  
+
 </Project>");
 
             IDictionary<string, string> preExistingProps = new Dictionary<string, string>
@@ -2211,7 +2211,7 @@ public void InteractiveSetsBuiltInProperty(string arguments)
   <Target Name=""Build"">
     <Message Text=""MSBuildInteractive = [$(MSBuildInteractive)]"" />
   </Target>
-  
+
 </Project>");
 
             string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: arguments);
@@ -2233,7 +2233,7 @@ public void BinaryLogContainsImportedFiles()
 
                     <Target Name=""Build"">
                     </Target>
-  
+
                 </Project>"));
 
                 testEnvironment.CreateFile("TestProject.proj", @"
@@ -2269,7 +2269,7 @@ public void EndToEndWarnAsErrors()
   <Target Name=""IssueWarning"">
     <Warning Text=""Warning!"" />
   </Target>
-  
+
 </Project>");
 
             TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index e567fc1f64c..65dca4475bb 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -480,8 +480,8 @@ private static string FallbackDotNetFrameworkSdkInstallPath
 
                         if (EnvironmentUtilities.Is64BitProcess && s_fallbackDotNetFrameworkSdkInstallPath == null)
                         {
-                            // Since we're 64-bit, what we just checked was the 64-bit fallback key -- so now let's 
-                            // check the 32-bit one too, just in case. 
+                            // Since we're 64-bit, what we just checked was the 64-bit fallback key -- so now let's
+                            // check the 32-bit one too, just in case.
                             s_fallbackDotNetFrameworkSdkInstallPath =
                                 FindRegistryValueUnderKey(
                                     fallbackDotNetFrameworkSdkRegistryInstallPath,
@@ -751,7 +751,7 @@ DotNetFrameworkArchitecture architecture
                 return directoryExists(frameworkPath) ? frameworkPath : null;
             }
 
-            // If the COMPLUS variables are set, they override everything -- that's the directory we want.  
+            // If the COMPLUS variables are set, they override everything -- that's the directory we want.
             string complusInstallRoot = Environment.GetEnvironmentVariable("COMPLUS_INSTALLROOT");
             string complusVersion = Environment.GetEnvironmentVariable("COMPLUS_VERSION");
 
@@ -761,7 +761,7 @@ DotNetFrameworkArchitecture architecture
             }
 
             // If the current runtime starts with correct prefix, then this is the runtime we want to use.
-            // However, only if we're requesting current architecture -- otherwise, the base path may be different, so we'll need to look it up. 
+            // However, only if we're requesting current architecture -- otherwise, the base path may be different, so we'll need to look it up.
             string leaf = Path.GetFileName(currentRuntimePath);
             if (leaf.StartsWith(prefix, StringComparison.Ordinal) && architecture == DotNetFrameworkArchitecture.Current)
             {
@@ -777,19 +777,19 @@ DotNetFrameworkArchitecture architecture
 
             if (indexOfFramework64 != -1 && architecture == DotNetFrameworkArchitecture.Bitness32)
             {
-                // need to get rid of just the 64, but want to look up 'Framework64' rather than '64' to avoid the case where 
-                // the path is something like 'C:\MyPath\64\Framework64'.  9 = length of 'Framework', to make the index match 
-                // the location of the '64'. 
+                // need to get rid of just the 64, but want to look up 'Framework64' rather than '64' to avoid the case where
+                // the path is something like 'C:\MyPath\64\Framework64'.  9 = length of 'Framework', to make the index match
+                // the location of the '64'.
                 int indexOf64 = indexOfFramework64 + 9;
                 string tempLocation = baseLocation;
                 baseLocation = tempLocation.Substring(0, indexOf64) + tempLocation.Substring(indexOf64 + 2, tempLocation.Length - indexOf64 - 2);
             }
             else if (indexOfFramework64 == -1 && architecture == DotNetFrameworkArchitecture.Bitness64)
             {
-                // need to add 64 -- since this is a heuristic, we assume that we just need to append.  
+                // need to add 64 -- since this is a heuristic, we assume that we just need to append.
                 baseLocation += "64";
             }
-            // we don't need to do anything if it's DotNetFrameworkArchitecture.Current.  
+            // we don't need to do anything if it's DotNetFrameworkArchitecture.Current.
 
             string[] directories;
 
@@ -799,7 +799,7 @@ DotNetFrameworkArchitecture architecture
             }
             else
             {
-                // If we can't even find the base path, might as well give up now. 
+                // If we can't even find the base path, might as well give up now.
                 return null;
             }
 
@@ -813,7 +813,7 @@ DotNetFrameworkArchitecture architecture
             // The intention here is to choose the alphabetical maximum.
             string max = directories[0];
 
-            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.  
+            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.
             // This was removed in beta2
             // We should favor \v3.5 over \v3.5.xxxxx
             // versions previous to 2.0 have .xxxx version numbers.  3.0 and 3.5 do not.
@@ -874,15 +874,15 @@ internal static string GenerateProgramFiles64()
             string programFilesX64;
             if (string.Equals(programFiles, programFiles32))
             {
-                // either we're in a 32-bit window, or we're on a 32-bit machine.  
+                // either we're in a 32-bit window, or we're on a 32-bit machine.
                 // if we're on a 32-bit machine, ProgramW6432 won't exist
-                // if we're on a 64-bit machine, ProgramW6432 will point to the correct Program Files. 
+                // if we're on a 64-bit machine, ProgramW6432 will point to the correct Program Files.
                 programFilesX64 = Environment.GetEnvironmentVariable("ProgramW6432");
             }
             else
             {
-                // 64-bit window on a 64-bit machine; %ProgramFiles% points to the 64-bit 
-                // Program Files already. 
+                // 64-bit window on a 64-bit machine; %ProgramFiles% points to the 64-bit
+                // Program Files already.
                 programFilesX64 = programFiles;
             }
 
@@ -1141,8 +1141,8 @@ private static void RedirectVersionsIfNecessary(ref Version dotNetFrameworkVersi
 
             if (dotNetFrameworkVersion == dotNetFrameworkVersion35 && visualStudioVersion > visualStudioVersion110)
             {
-                // Fall back to Dev11 location -- 3.5 tools MSI was reshipped unchanged, so there 
-                // essentially are no 12-specific 3.5 tools. 
+                // Fall back to Dev11 location -- 3.5 tools MSI was reshipped unchanged, so there
+                // essentially are no 12-specific 3.5 tools.
                 visualStudioVersion = visualStudioVersion110;
                 return;
             }
@@ -1348,8 +1348,8 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 }
 
 #if FEATURE_WIN32_REGISTRY
-                // Otherwise, check to see if we're even installed.  If not, return null -- no point in setting the static 
-                // variables to null when that's what they are already.  
+                // Otherwise, check to see if we're even installed.  If not, return null -- no point in setting the static
+                // variables to null when that's what they are already.
                 if (NativeMethodsShared.IsWindows && !CheckForFrameworkInstallation(
                     this._dotNetFrameworkRegistryKey,
                     this._dotNetFrameworkSetupRegistryInstalledName
@@ -1422,7 +1422,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
 
                     // For the Dev10 SDK, we check the registry that corresponds to the current process' bitness, rather than
                     // always the 32-bit one the way we do for Dev11 and onward, since that's what we did in Dev10 as well.
-                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry. 
+                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry.
                     RegistryView registryView = visualStudioSpec.Version == visualStudioVersion100 ? RegistryView.Default : RegistryView.Registry32;
 
                     generatedPathToDotNetFrameworkSdkTools = FindRegistryValueUnderKey(
@@ -1537,7 +1537,7 @@ public virtual string GetPathToWindowsSdk()
 
                     string registryPath = string.Join(@"\", MicrosoftSDKsRegistryKey, "Windows", visualStudioSpec.WindowsSdkRegistryKey);
 
-                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry. 
+                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry.
                     this._pathToWindowsSdk = FindRegistryValueUnderKey(
                         registryPath,
                         visualStudioSpec.WindowsSdkRegistryInstallationFolderName,
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index feb3acb6a5c..ff7d9685aa7 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -19,7 +19,7 @@ internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Conf
         {
             ToolsetConfigurationSection configurationSection = null;
 
-            // This will be null if the application config file does not have the following section 
+            // This will be null if the application config file does not have the following section
             // definition for the msbuildToolsets section as the first child element.
             //   <configSections>
             //     <section name=""msbuildToolsets"" type=""Microsoft.Build.Evaluation.ToolsetConfigurationSection, Microsoft.Build"" />
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 09cca604107..72471dfa828 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -31,7 +31,7 @@ public Traits()
 
         public EscapeHatches EscapeHatches { get; }
 
-        internal readonly string MSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION"); 
+        internal readonly string MSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION");
 
         /// <summary>
         /// Do not expand wildcards that match a certain pattern
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index f8d902e2b5e..d263d56eab8 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -74,7 +74,7 @@ public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo
             foreach (string fullPath in GetFilesComplexGlobbingMatchingInfo.FilesToCreate.Select(i => Path.Combine(testFolder.Path, i.ToPlatformSlash())))
             {
                 Directory.CreateDirectory(Path.GetDirectoryName(fullPath));
-                
+
                 File.WriteAllBytes(fullPath, new byte[1]);
             }
 
@@ -293,7 +293,7 @@ public static IEnumerable<object[]> GetTestData()
                         ExpectNoMatches = NativeMethodsShared.IsLinux,
                     }
                 };
-                
+
 #if !MONO // https://github.com/mono/mono/issues/8441
                 yield return new object[]
                 {
@@ -2112,8 +2112,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                             int nextSlash = normalizedCandidate.IndexOfAny(FileMatcher.directorySeparatorCharacters, path.Length + 1);
                             if (nextSlash != -1)
                             {
-                                
-                                //UNC paths start with a \\ fragment. Match against \\ when path is empty (i.e., inside the current working directory)
+                                // UNC paths start with a \\ fragment. Match against \\ when path is empty (i.e., inside the current working directory)
                                 string match = normalizedCandidate.StartsWith(@"\\") && string.IsNullOrEmpty(path)
                                     ? @"\\"
                                     : normalizedCandidate.Substring(0, nextSlash);
@@ -2129,7 +2128,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                                     directories.Add(FileMatcher.Normalize(match));
                                 }
                                 else if    // Match patterns like ?emp
-                                    (
+                                (
                                     pattern.Substring(0, 1) == "?"
                                     && pattern.Length == baseMatch.Length
                                 )
@@ -2666,8 +2665,3 @@ public bool DirectoryEntryExists(string path)
         }
     }
 }
-
-
-
-
-
