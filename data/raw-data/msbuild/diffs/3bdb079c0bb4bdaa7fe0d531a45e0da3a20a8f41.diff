diff --git a/.editorconfig b/.editorconfig
index 01161a81aa6..edcf2233a98 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -156,7 +156,7 @@ csharp_space_between_method_declaration_parameter_list_parentheses = false
 csharp_space_between_parentheses = false
 csharp_space_between_square_brackets = false
 
-# Analyzers
+# Checks
 dotnet_code_quality.ca1802.api_surface = private, internal
 dotnet_code_quality.ca2208.api_surface = public
 
diff --git a/documentation/specs/BuildCheck/BuildCheck-Architecture.md b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
index d51504ad8f4..b3d921c443c 100644
--- a/documentation/specs/BuildCheck/BuildCheck-Architecture.md
+++ b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
@@ -11,8 +11,8 @@ This is an internal engineering document. For general overview and user point of
 | Advisory/Leadership | @rainersigwald |
 | Infrastructure      | @jankrivanek |
 | Configuration       | @f-alizada   |
-| Custom Analyzers    | @YuliiaKovalova |
-| Inbox Analyzers     | @ladipro |
+| Custom Checks       | @YuliiaKovalova |
+| Inbox Checks        | @ladipro |
 | Replay Mode         | @surayya-MS |
 | Tracing             | @maridematte |
 | Perf Advisory       | @AR-May |
@@ -47,29 +47,29 @@ In both cases the sink for the data is actualy a `LoggingContext` - this is to e
 
 #### Sample in-node data case - evaluated project
 
-One example of rich data that might be helpful for internal analyses is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
+One example of rich data that might be helpful for internal checks is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
 
 ## Execution Modes
 
-**Replay Mode** - so that users can choose to perform analyses post build, without impacting the performance of the build. And so that some level of analysis can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
+**Replay Mode** - so that users can choose to perform checks post build, without impacting the performance of the build. And so that some level of checking can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
 
-**Live mode** - this is what users are used to from compilation analyses. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
+**Live mode** - this is what users are used to from compilation checks. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
 
 ## Live Mode Hosting
 
 Prerequisites: [MSBuild Nodes Orchestration](../../wiki/Nodes-Orchestration.md#orchestration)
 
 The BuildCheck infrastructure will be prepared to be available concurrently within the `scheduler node` as well as in the additional `worker nodes`. There are 2 reasons for this:
-* BuildCheck will need to recognize custom analyzers packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
-* Presence in worker node (as part of the `RequestBuilder`), will allow inbox analyzers to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
+* BuildCheck will need to recognize custom check packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
+* Presence in worker node (as part of the `RequestBuilder`), will allow inbox checks to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
 
 ## Replay Mode
 
 Prerequisites: [MSBuild Replaying a Binary Log](../../wiki/Binary-Log.md#replaying-a-binary-log)
 
-When replaying a binary log, we can apply BuildCheck with help of `-analyze` switch:
+When replaying a binary log, we can apply BuildCheck with help of `-check` switch:
 ```
-> msbuild.exe msbuild.binlog -analyze
+> msbuild.exe msbuild.binlog -check
 ```
 
 If BuildCheck is enabled, then the events from `BinaryLogReplayEventSource` and new events from BuildCheck are merged into the `IEventSource`, from which the loggers get events.
@@ -89,36 +89,36 @@ flowchart TD
 
 ## Handling the Distributed Model
 
-We want to get some benefits (mostly inbox analyzers agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
+We want to get some benefits (mostly inbox checks agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
 
 How we'll internally handle the distributed model:
 * Each node will have just a single instance of infrastructure (`IBuildCheckManager`) available (registered via the MSBuild dependency injection container - `IBuildComponentHost`). This applies to a scheduler node with inproc worker node as well.
 * Scheduler node will have an MSBuild `ILogger` registered that will enable communicating information from worker nodes BuildCheck module to the scheduler node BuildCheck module - namely:
-    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular analyzer and that it should be loaded and instantiated in the main node.
+    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular check and that it should be loaded and instantiated in the main node.
     * Tracing module will be able to send perf stats from current worker node and aggregate all of those together in the main node.
-    * Theoretical execution-data-only sourcing inbox analyzer will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for analyzer that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
-* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox analyzers that should live in nodes; send the analyzers reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular analyzers).
-* The custom analyzers will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
+    * Theoretical execution-data-only sourcing inbox check will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for check that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
+* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox checks that should live in nodes; send the checks reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular checks).
+* The custom checks will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
 * Communication from main to worker node between BuildCheck infra modules is not planned (this might be revisited - even for the V1).
 
-## Analyzers Lifecycle
+## Check Lifecycle
 
 Planned model:
-* Analyzers factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
-    * For inbox analyzers - this happens on startup.
-    * For custom analyzers - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom analyzers only in the main node (as they will be only given data proxied from BuildEventArgs).
-    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom analyzer is registered.
+* Check factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
+    * For inbox checks - this happens on startup.
+    * For custom checks - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom checks only in the main node (as they will be only given data proxied from BuildEventArgs).
+    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom check is registered.
 * `BuildCheckManager` receives info about new project starting to be build
     * On scheduler node the information is sourced from `ProjectEvaluationStartedEventArgs`
     * On worker node this is received from `RequestBuilder.BuildProject`
-* `BuildCheckManager` calls Configuration module and gets information for all analyzers in it's registry
-    * Analyzers with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
+* `BuildCheckManager` calls Configuration module and gets information for all checks in it's registry
+    * Checks with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
     * Global configuration issue (communicated via `BuildCheckConfigurationException`) will issue an error and then entirely disable BuildCheck.
-* `BuildCheckManager` instantiates all newly enabled analyzers and updates configuration for all already instantiated analyzers.
-* At that point of time analyzers are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to analyzers.
-* Analyzers may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
-* Analysis result might hence be reported after project's final `ProjectFinishedEventArgs`
-* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all analyzers are done processing and their results are accounted for.
+* `BuildCheckManager` instantiates all newly enabled checks and updates configuration for all already instantiated checks.
+* At that point of time checks are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to checks.
+* Checks may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
+* Checks result might hence be reported after project's final `ProjectFinishedEventArgs`
+* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all checks are done processing and their results are accounted for.
 
 # Configuration
 
@@ -126,35 +126,35 @@ Planned model:
 
 ## High-level logic
 
-MSBuild engine always finds and parses relevant `.editorconfig` files to see which analyzers should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
+MSBuild engine always finds and parses relevant `.editorconfig` files to see which checks should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
 
-The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an analyzer should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of analyzers. Analyzers interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
+The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an checks should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of checks. Checks interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
 
-Once `TargetFramework` is known, we can combine the default analyzer config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing analyzer just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled analyzers, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of analyzers to use is finalized.
+Once `TargetFramework` is known, we can combine the default checks config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing check just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled checks, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of checks to use is finalized.
 
-Since we are unlikely to enable any analyzers by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
+Since we are unlikely to enable any checks by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
 
 # Acquisition
 
-BuildCheck employs two distinct types of analyzers: inbox and custom. As a result, the acquisition and distribution processes vary.
-Inbox rules are integrated into the MSBuild repository, while custom analyzers can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
+BuildCheck employs two distinct types of checks: inbox and custom. As a result, the acquisition and distribution processes vary.
+Inbox rules are integrated into the MSBuild repository, while custom checks can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
 
 To streamline the creation of custom rules, a special [template](https://learn.microsoft.com/dotnet/core/tools/custom-templates) has been introduced.
-To enable MSBuild to recognize a custom analyzer, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
-Additionally, the custom rule must use [`BuildAnalyzerRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
+To enable MSBuild to recognize a custom check, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
+Additionally, the custom rule must use [`BuildCheckRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
 
 Examples of custom rules can be found in the [end-to-end tests](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/BuildCheck.UnitTests/EndToEndTests.cs#L139), showcasing various scenarios:
 
 1. [`Single Custom Rule Packaged as a NuGet Package`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate): Demonstrates the implementation of a custom rule encapsulated within a NuGet package. It contains the process of creating, packaging, and integrating a single custom rule into a project.
-2. [`Project with Multiple Analyzers Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected): Illustrates a project setup where multiple custom analyzers are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
+2. [`Project with Multiple Checks Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleChecksInjected): Illustrates a project setup where multiple custom checks are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
 
 Important Notes: 
-- In these examples, pay attention to the presence of the `CustomAnalyzerName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
-- The examples do not include references to third-party assemblies that might be required in other custom analyzers. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
+- In these examples, pay attention to the presence of the `CustomCheckName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
+- The examples do not include references to third-party assemblies that might be required in other custom checks. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
 
 ### Future Enhancements
 As our library of custom rules expands, we plan to enrich this section with real-world production rule examples. These examples will showcase a diverse range of rules addressing common development challenges. Once these production rules are published and available on nuget.org, we will update this documentation accordingly.
 
-# Build OM for Analyzers Authoring
+# Build OM for Checks Authoring
 
-**TBD** - details for the initial inbox analyzers set to be amended by @ladipro
+**TBD** - details for the initial inbox checks set to be amended by @ladipro
diff --git a/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
index ec1944a8700..2bc17291362 100644
--- a/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
+++ b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
@@ -4,8 +4,8 @@
 ## BuildCheck Feature Description
 
 The infrastructure within MSBuild allowing pluggability and execution of
-Analyzers and their Rules previously known as "warning waves" and
-"MSBuild Analyzers".
+Checks and their Rules previously known as "warning waves" and
+"MSBuild Checks".
 
 The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
 
@@ -24,45 +24,45 @@ For this document, we do not address any threats that result from violating thes
 
 ## Acquisition
 
-### Threat: Supply chain attack on custom analyzer
+### Threat: Supply chain attack on custom check
 
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
 
 #### Mitigation
 
 Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
-Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
-Users is expected to implement process to detect and warn about known malicious custom analyzers.
+Custom checks are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
+Users is expected to implement process to detect and warn about known malicious custom checks.
 
 #### Important Notice:
-Users should not add untrusted build analyzers to their projects. The use of untrusted or unverified 3rd party analyzers can introduce security risks and vulnerabilities into the build process. Always ensure that any build analyzers integrated into your projects come from reputable sources and have been thoroughly vetted.
+Users should not add untrusted build checks to their projects. The use of untrusted or unverified 3rd party checks can introduce security risks and vulnerabilities into the build process. Always ensure that any build checks integrated into your projects come from reputable sources and have been thoroughly vetted.
 
 To ensure a secure and reliable build environment, the following steps should be taken:
 
 #### Use Dedicated Security Tools:
-Utilize specialized security tools and services to scan and monitor 3rd party analyzer packages and their dependencies. 
+Utilize specialized security tools and services to scan and monitor 3rd party check packages and their dependencies. 
 #### Regular Updates:
 Ensure that all 3rd party packages and dependencies are regularly updated to the latest versions, which often include security patches and vulnerability fixes.
 
 #### Vendor Documentation and Support:
-Refer to the official documentation and support channels provided by the developers of the 3rd party analyzer packages. They may offer guidance and tools for managing security and addressing vulnerabilities.
+Refer to the official documentation and support channels provided by the developers of the 3rd party check packages. They may offer guidance and tools for managing security and addressing vulnerabilities.
 
 #### Internal Security Policies:
 Implement internal policies and processes for the assessment and mitigation of security risks associated with using 3rd party packages. This can include regular security audits, dependency management protocols, and automated vulnerability scanning during the build process.
 
 ## Execution
 
-### Threat: Supply chain attack by custom analyzer
+### Threat: Supply chain attack by custom check
 
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
 
 #### Mitigation
 
 Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
 ### Threat: Third-Party Vulnerabilities
-Vulnerabilities in custom analyzer or its dependencies.
+Vulnerabilities in custom check or its dependencies.
 
 #### Mitigation
 
@@ -72,18 +72,18 @@ Detecting unsecure packages is not MSBuild responsibility and is currently out o
 
 ### Threat: Malicious configuration value
 
-Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an analyzer or cause build malfunction for any reason.
+Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an check or cause build malfunction for any reason.
 
 #### Mitigation
 
-This problem is identical to existing .editorconfig for Roslyn analyzers and since we share code for parsing it, we adopt same mitigation strategy, which is:
+This problem is identical to existing .editorconfig for Roslyn checks and since we share code for parsing it, we adopt same mitigation strategy, which is:
 
 - default template for editor config has `root = true` stopping parent config traversing
 - code is unit tested to verify and sanitize .editorconfig values
 
-### Threat: Intentional analyzer ID conflict or misleading ID
+### Threat: Intentional check ID conflict or misleading ID
 
-Malicious actors can define analyzer ID to be identical or like existing well known analyzer ID to increase probability of executing malicious analyzer code.
+Malicious actors can define check ID to be identical or like existing well known check ID to increase probability of executing malicious check code.
 
 #### Mitigation
 
@@ -91,9 +91,9 @@ Detecting unsecure packages is not MSBuild responsibility and is currently out o
 
 ## Declaration
 
-### Threat: Malicious analyzer registration property function
+### Threat: Malicious check registration property function
 
-Threat actor can write malicious analyzer registration property function in project files, with intent to run code from non-governed assemblies.
+Threat actor can write malicious check registration property function in project files, with intent to run code from non-governed assemblies.
 
 #### Mitigation
 
diff --git a/documentation/specs/BuildCheck/BuildCheck.md b/documentation/specs/BuildCheck/BuildCheck.md
index a4db495c6ae..d8df6956591 100644
--- a/documentation/specs/BuildCheck/BuildCheck.md
+++ b/documentation/specs/BuildCheck/BuildCheck.md
@@ -1,32 +1,32 @@
 
 # BuildCheck - Design Spec
 
-Previously known as "warning waves" and "MSBuild Analyzers"
+Previously known as "warning waves" and "MSBuild Checks"
 
 The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
 
 # Terminology
 
-* **Analyzer** – unit of execution (single implementing class), can host multiple rules. 
+* **Check** – unit of execution (single implementing class), can host multiple rules. 
 * **Rule** – Single violation type, with single unique code (`“BC1234: Redefining built-in target”`). 
-* **Report** – Output from Analyzer informing about violating particular rule.
+* **Report** – Output from check informing about violating particular rule.
 * **CodeFix** – Violation remedy suggestion. Not yet applicable for MSBuild.
-* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of Analyzers and their Rules
+* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of checks and their Rules
 
 
 # North Star / Longer-term vision
 
-MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static analysis rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build analysis will happen as part of the build or as a separate process.
+MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static check rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build check will happen as part of the build or as a separate process.
 
-Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# analyzers) leveraging `.editorconfig` files.
+Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# checks) leveraging `.editorconfig` files.
 
-Powerusers are able to develop, test and publish their custom analyzers easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
+Powerusers are able to develop, test and publish their custom checks easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
 
-A solid set of in-the-box analyzers is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box analyzers are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the analysis. This will be done either by configuring the analyzers with `.editorconfig` or auto-enabling the analysis based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in analyzers derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
+A solid set of in-the-box checks is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box checks are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the check. This will be done either by configuring the checks with `.editorconfig` or auto-enabling the check based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in checks derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
 
-Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildAnalysisLevel` to enable some base analyzers we believe will add value everywhere.
+Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildCheckLevel` to enable some base checks we believe will add value everywhere.
 
-The analysis has small impact on build duration with ability to disable analysis altogether which will remove all the performance costs associated with the analysis. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
+The check has small impact on build duration with ability to disable check altogether which will remove all the performance costs associated with the check. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
 
 
 # Scope of initial iteration
@@ -34,43 +34,43 @@ The analysis has small impact on build duration with ability to disable analysis
 Majority of following cases are included in appropriate context within the scenarios in [User Experience](#user-experience) section. Following is a quick overview.
 
 ## In scope
-* Inbox (built-in) analyzers that run during the build execution.
-* Inbox analyzers that run when replaying binlog.
-* Custom authored analyzers, delivered via nuget.
-* Analyzers reports (errors, warnings, messages) are in logger output, VS error window.
+* Inbox (built-in) checks that run during the build execution.
+* Inbox checks that run when replaying binlog.
+* Custom authored checks, delivered via nuget.
+* Checks reports (errors, warnings, messages) are in logger output, VS error window.
 * Codes will be distinguishable from standard build warnings/error (to prevent easy mixups and attempts to configure standard msbuild warnings/errors via editorconfig), but otherwise the outputs are very similar.
-* Default opt-ins and levels for inbox analyzers set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
-* Custom analyzers opted in via `PackageReference` of a particular nuget with the analyzer.
-* Explicit overrides of enablement and analysis levels via `.editorconfig` file (with up to a per-project scope).
+* Default opt-ins and levels for inbox checks set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
+* Custom checks opted in via `PackageReference` of a particular nuget with the check.
+* Explicit overrides of enablement and check levels via `.editorconfig` file (with up to a per-project scope).
 * [Specification of `.editorconfig`](https://spec.editorconfig.org/) will be observed. 
 * Simplified authoring experience via template and doc.
-* Single analyzer can produce reports for multiple rules. However those need to be declared upfront.
-* Opt-in reporting of time spent via specific analyzers and infra overall.
+* Single check can produce reports for multiple rules. However those need to be declared upfront.
+* Opt-in reporting of time spent via specific checks and infra overall.
 * Collect touched `.editorconfig`s into binlog embedded files.
-* Possibility to opt-out from analysis - the perf should not be impacted when done so.
-* Team collects performance impact numbers on a set of benchmark builds with the inbox analyzers enabled.
+* Possibility to opt-out from check - the perf should not be impacted when done so.
+* Team collects performance impact numbers on a set of benchmark builds with the inbox checks enabled.
 
 ## Non Goals, but subject for consideration
-* Custom analyzer in a local project (source codes) or a binary.
+* Custom check in a local project (source codes) or a binary.
 * Bulk configuration of multiple rules (based on prefixes).
-* Specifying scope of MSBuild imports that will be considered for analysis (so that e.g. data from sdk won't even be passed to analyzer, if not requested).
+* Specifying scope of MSBuild imports that will be considered for check (so that e.g. data from sdk won't even be passed to check, if not requested).
 * Attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* Configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs
-* Structured information in VS error window (similarly to the Roslyn analyzer reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
+* Configuring check levels when checking from binlog - beyond the collected editorconfigs
+* Structured information in VS error window (similarly to the Roslyn check reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
 
 
 ## Out of scope
 * Instrumentation for telemetry.
-* Design time build analysis.
+* Design time build check.
 * Localization support (for reports message formats, identifiers, etc.).
-* Custom analyzers have equal data access as the inbox analyzers. We'll aim to ship analyzers that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some analyzers using unexposed data.
-* All inbox analyzers reports have precise location(s) of issues (however for each individual analyzer not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
-* Opt-out of analysis on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
+* Custom checks have equal data access as the inbox checks. We'll aim to ship checks that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some checks using unexposed data.
+* All inbox checks reports have precise location(s) of issues (however for each individual check not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
+* Opt-out of check on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
 * Simplified authoring experience via dedicated reference assembly.
-* Restore phase analysis.
-* Turning analysis off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
-* Controlling/Configuring lifetime of analyzers - analyzers will currently be held alive, as single instance per analyzer, for the whole duration of the build. But future versions might prevent some of the analyzers to survive beyond a scope of a single project built (means for sharing data would be provided).
-* Event Tracing for Windows (ETW) for analyzers.
+* Restore phase check.
+* Turning check off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
+* Controlling/Configuring lifetime of checks - checks will currently be held alive, as single instance per check, for the whole duration of the build. But future versions might prevent some of the checks to survive beyond a scope of a single project built (means for sharing data would be provided).
+* Event Tracing for Windows (ETW) for checks.
 * Attributing `.editorconfig` configurations to .sln files. E.g.:
 ```ini
 # I expect this to apply to all projects within my solution, but not to projects which are not part of the solution
@@ -91,17 +91,17 @@ build_check.BC0101.Severity=warning
 
 ## Running / UX
 
-### Inbox Analyzers
+### Inbox Checks
 
-Suggested list of analyzers to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
+Suggested list of checks to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
 
-The proposed initial configuration for those is TBD (as well based on initial test runs of the analyzers of chosen public repositories).
+The proposed initial configuration for those is TBD (as well based on initial test runs of the checks of chosen public repositories).
 
 ### Live Build
 
-BuildCheck will run as part of the build and execute [inbox analyzers](#inbox-analyzers) and [custom analyzers](#acquisition-of-custom-analyzers) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
+BuildCheck will run as part of the build and execute [inbox checks](#inbox-checks) and [custom checks](#acquisition-of-custom-checks) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
 
-Findings - reports - of analyzers will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
+Findings - reports - of checks will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
 
 BuildCheck reports will have power to fail the build (via errors or warnings), that would otherwise succeed without the BuildCheck. This is actually the main benefit of the feature - as it helps enforcing new rules, that are easily user configurable individually or as a whole feature - to prevent unwanted breakages of legacy builds not ready for improvements.
 
@@ -110,36 +110,36 @@ BuildCheck reports will have power to fail the build (via errors or warnings), t
 Users will have option to explicitly opt-in to run BuildCheck during the binlog replay mode:
 
 ```bash
-> dotnet build msbuild.binlog /analyze
+> dotnet build msbuild.binlog /check
 ```
 
-Would there be any analyzers that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom analyzers authoring](#custom-analyzers-authoring)), replay mode will inform user about those via warnings.
+Would there be any checks that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom checks authoring](#custom-checks-authoring)), replay mode will inform user about those via warnings.
 
-Replay mode will by default consider `.editorconfig` files stored within the binlog and will run analyzers based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime analysis reports stored, plus the replay-time analysis reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
+Replay mode will by default consider `.editorconfig` files stored within the binlog and will run checks based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime check reports stored, plus the replay-time check reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
 
 For this reason we will consider following modes (all are non-goals):
 * All binlog stored reports are skipped by default. We add option to request not skipping them (but they might need to be prefixed or otherwise distinguished from the 'fresh' reports).
 * Ability to specify skipping of the stored .editorconfig files
 * Ability to specify single replay-time .editorconfig file and it’s precedence (only the specified, specified as most significant, specified as least significant)
 
-We might as well consider specifying custom analyzers on a command line (as a non-goal) - so that unreferenced custom analyzers can be run against the binlog.
+We might as well consider specifying custom checks on a command line (as a non-goal) - so that unreferenced custom checks can be run against the binlog.
 
 ## Configuration
 
-There will be 3 mechanisms of configuring the analyzers and rules:
-* The default configuration declared by the analyzers themselves ([more details on implementation](#rules-declaration))
-* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox analyzers
+There will be 3 mechanisms of configuring the checks and rules:
+* The default configuration declared by the checks themselves ([more details on implementation](#rules-declaration))
+* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox checks
 * `.editorconfig` file
 
 We will also consider respecting `SdkAnalysisLevel` to override the per-TFM defaults. Additionally, we may introduce a new "master switch" property, tentatively called `RunMSBuildChecks`, to make it possible to disable everything whole-sale. This would be used in scenarios like F5 in VS.
 ```
-Skipping analyzers to speed up the build. You can execute 'Build' or 'Rebuild' command to run analyzers.
+Skipping checks to speed up the build. You can execute 'Build' or 'Rebuild' command to run checks.
 ```
 
 Here's the proposed release schedule:
-- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No analyzers are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
-- **.NET 10** - based on feedback and testing, we choose a set of analyzers to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking analyzers just-in-time, we may want to omit such analyzers from the default set.
-- **.NET 11** and beyond - some more analyzers are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any analyzer. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
+- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No checks are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
+- **.NET 10** - based on feedback and testing, we choose a set of checks to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking checks just-in-time, we may want to omit such checks from the default set.
+- **.NET 11** and beyond - some more checks are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any check. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
 
 
 For the `.editorconfig` file configuration, following will apply:
@@ -148,16 +148,16 @@ For the `.editorconfig` file configuration, following will apply:
 * `.editorconfig` files packaged within nuget packages within local nuget cache won’t be considered.
 
 ### Non-Goals (but might be considered):
-* bulk configuration of multiple rules - based on analyzers/rules prefixes or/and categories.
+* bulk configuration of multiple rules - based on checks/rules prefixes or/and categories.
 * attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs.
-* Aliasing the analyzers/rules, allowing to create multiple instances with different custom configuration (e.g. single analyzer checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
+* configuring check levels when checking from binlog - beyond the collected editorconfigs.
+* Aliasing the checks/rules, allowing to create multiple instances with different custom configuration (e.g. single check checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
 
 ### Out of scope for configuration:
-* opt-out of analysis on code-level (analogy to C# pragmas, but within msbuild xml files).
+* opt-out of check on code-level (analogy to C# pragmas, but within msbuild xml files).
 * lower granularity of `.editorconfig` settings other than whole projects.
 * attributing configuration to a .sln file and expecting it will apply to all contained projects.
-* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the analyzer or analyzer instancing – each analyzer will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
+* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the check or check instancing – each check will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
 
 ### Sample configuration
 
@@ -172,7 +172,7 @@ build_check.COND0543.custom_switch=QWERTY
 
 ### User Configurable Options
 
-Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual analyzer rules.
+Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual check rules.
 
 **NOTE:** The actual naming of the configuration options is yet to be determined.
 
@@ -188,13 +188,13 @@ Option `Severity` with following values will be available:
 | Warning | `warning` |
 | Error | `error` |
 
-Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the analyzer (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
+Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the check (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
 
-Configuration will dictate transformation of the analyzer report to particular build output type (message, warning or error).
+Configuration will dictate transformation of the check report to particular build output type (message, warning or error).
 
-Each rule has a severity, even if multiple rules are defined in a single analyzer. The rule can have different severities for different projects within a single build session.
+Each rule has a severity, even if multiple rules are defined in a single check. The rule can have different severities for different projects within a single build session.
 
-If all the rules from a single analyzer have severity `None` - analyzer won't be given any data for such configured part of the build (specific project or a whole build). If analyzer have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
+If all the rules from a single check have severity `None` - check won't be given any data for such configured part of the build (specific project or a whole build). If check have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
 
 #### Configuring severity level
 
@@ -203,22 +203,22 @@ If all the rules from a single analyzer have severity `None` - analyzer won't be
 build_check.BC0101.severity=warning
 ```
 
-#### Scope of Analysis
+#### Scope of Check
 
-Option `EvaluationAnalysisScope` with following possible options will be available:
+Option `EvaluationCheckScope` with following possible options will be available:
 
-| EvaluationAnalysisScope (Solution Explorer)   | EditorConfig option      |  Behavior  | 
+| EvaluationCheckScope (Solution Explorer)   | EditorConfig option      |  Behavior  | 
 | ------------- | ------------- |   ------------- |
-| ProjectOnly | `project` | Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded. | 
-| ProjectWithImportsFromCurrentWorkTree | `current_imports` |  Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded. | 
-| ProjectWithImportsWithoutSdks | `without_sdks` | Imports from SDKs will not be sent to the analyzer. Other imports will be sent. | 
-| ProjectWithAllImports | `all` | All data will be sent to the analyzer. | 
+| ProjectOnly | `project` | Only the data from currently checked project will be sent to the check. Imports will be discarded. | 
+| ProjectWithImportsFromCurrentWorkTree | `current_imports` |  Only the data from currently checked project and imports from files under the entry project or solution will be sent to the check. Other imports will be discarded. | 
+| ProjectWithImportsWithoutSdks | `without_sdks` | Imports from SDKs will not be sent to the check. Other imports will be sent. | 
+| ProjectWithAllImports | `all` | All data will be sent to the check. | 
 
-All rules of a single analyzer must have the `EvaluationAnalysisScope` configured to a same value. If any rule from the analyzer have the value configured differently - a warning will be issued during the build and analyzer will be deregistered.
+All rules of a single check must have the `EvaluationCheckScope` configured to a same value. If any rule from the check have the value configured differently - a warning will be issued during the build and check will be deregistered.
 
-Same rule can have `EvaluationAnalysisScope` configured to different values for different projects.
+Same rule can have `EvaluationCheckScope` configured to different values for different projects.
 
-BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the analyzer code](#BuildAnalyzerConfiguration) or from `.editorconfig` file) for an analyzer that has a subscription to unfilterable data - a warning will be issued during the build and analyzer will be deregistered.
+BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the check code](#BuildExecutionCheckConfiguration) or from `.editorconfig` file) for an check that has a subscription to unfilterable data - a warning will be issued during the build and check will be deregistered.
 
 #### Configuring evalution scope
 
@@ -227,7 +227,7 @@ BuildCheck might not be able to guarantee to properly filter the data with this
 build_check.BC0101.scope=all
 ```
 
-## Analyzers and Rules Identification
+## Checks and Rules Identification
 
 **TBD**
 
@@ -237,36 +237,36 @@ build_check.BC0101.scope=all
 * Ability to use prefixes during configuration
 
 
-## Custom Analyzers Authoring
+## Custom Checks Authoring
 
 ### Implementation
 
-To author custom analyzer, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build analysis.
+To author custom check, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build check.
 
-#### Analyzer declaration
+#### Check declaration
 
 Simplified proposal:
 
 ```csharp
-public abstract class BuildAnalyzer : IDisposable
+public abstract class BuildExecutionCheck : IDisposable
 {
     /// <summary>
-    /// Friendly name of the analyzer.
+    /// Friendly name of the check.
     /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
     /// </summary>
     public abstract string FriendlyName { get; }
 
     /// <summary>
-    /// Single or multiple rules supported by the analyzer.
+    /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+    public abstract IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; }
 
     /// <summary>
-    /// Optional initialization of the analyzer.
+    /// Optional initialization of the check.
     /// </summary>
     /// <param name="configurationContext">
     /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
     /// </param>
     public abstract void Initialize(ConfigurationContext configurationContext);
 
@@ -288,26 +288,26 @@ Sample of how registrations might look like:
 ```csharp
 public interface IBuildCheckRegistrationContext
 {
-    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction);
 
-    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction);
 
     // ...
 }
 ```
 
-The data provided in callbacks for registered actions will allow the analyzer to submit reports for its rules. A single callback can lead to multiple reports being generated.
+The data provided in callbacks for registered actions will allow the check to submit reports for its rules. A single callback can lead to multiple reports being generated.
 
-Any analyzer will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
+Any check will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
 
 #### Rules declaration
 
-A single analyzer can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
+A single check can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
 
 Simplified proposal of definition of a single rule:
 
 ```csharp
-public class BuildAnalyzerRule
+public class BuildExecutionCheckRule
 {
     // Identification/Description fields
     // (To be defined more precisely by https://github.com/dotnet/msbuild/issues/9823)
@@ -316,11 +316,11 @@ public class BuildAnalyzerRule
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+    public BuildExecutionCheckConfiguration DefaultConfiguration { get; }
 }
 ```
 
-<a name="BuildAnalyzerConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
+<a name="BuildExecutionCheckConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
 
 #### Standardized configuration declaration
 
@@ -328,37 +328,37 @@ Proposal of configuration specification:
 
 ```csharp
 /// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
+/// Configuration for a build check.
+/// Default values can be specified by the check in code.
 /// Users can overwrite the defaults by explicit settings in the .editorconfig file.
 /// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
 /// </summary>
-public class BuildAnalyzerConfiguration
+public class BuildExecutionCheckConfiguration
 {
     /// <summary>
     /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
 
     /// <summary>
     /// The default severity of the result for the rule. May be overridden by user configuration.
     ///
-    /// If all rules within the analyzer are `none`, the whole analyzer will not be run.
-    /// If some rules are `none` and some are not, the analyzer will be run and reports will be post-filtered.
+    /// If all rules within the check are `none`, the whole check will not be run.
+    /// If some rules are `none` and some are not, the check will be run and reports will be post-filtered.
     /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+    public BuildExecutionCheckResultSeverity? Severity { get; internal init; }
 }
 ```
 
-Values for this recognized contract, that are explicitly specified via .editorconfig files are passed both to the BuildCheck infrastructure as well as individual analyzers.
+Values for this recognized contract, that are explicitly specified via .editorconfig files are passed both to the BuildCheck infrastructure as well as individual checks.
 
 #### Custom configuration declaration
 
-However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular analyzer configuration – those values will be extracted as key-value pairs and passed to the analyzer initialization call (`Initialize`) via `ConfigurationContext`:
+However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular check configuration – those values will be extracted as key-value pairs and passed to the check initialization call (`Initialize`) via `ConfigurationContext`:
 
 ```csharp
 /// <summary>
@@ -374,7 +374,7 @@ public class ConfigurationContext
     /// <summary>
     /// Configuration data from standard declarations
     /// </summary>
-    public IReadOnlyList<BuildAnalyzerConfiguration> BuildAnalyzerConfig { get; init; }
+    public IReadOnlyList<BuildExecutionCheckConfiguration> BuildExecutionCheckConfig { get; init; }
 }
 ```
 
@@ -391,35 +391,35 @@ All the publicly exposed contracts will be available within `Microsoft.Build.Exp
 var availability = Features.CheckFeatureAvailability("BuildCheck.Beta");
 ```
 
-This way the analyzers authors will be equipped to write highly-compatible analyzers even in a possibility of changing API.
+This way the checks authors will be equipped to write highly-compatible checks even in a possibility of changing API.
 
 
 ### Testing and Debugging
 
 **TBD**
 
-We aim to provide ability to locally test analyzers from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
+We aim to provide ability to locally test checks from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
 
 At the same time we aim to provide mocks providing the BuildCheck context data – this work is however a non-goal.
 
 ### Packaging
 
-Several requirements are mandated for analyzer packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the analyzer package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the analyzer type).
+Several requirements are mandated for check packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the check package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the check type).
 
-Also custom analyzer package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
+Also custom check package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
 
 In order to simplify the packaging process (and meeting above mentioned requirements) a dotnet template will be provided producing proper package on pack action.
 
 **TBD** - dotnet new sample on initiating the development.
 
-## Acquisition of custom analyzers
+## Acquisition of custom checks
 
-Apart from [inbox analyzers](#inbox-analyzers) (shipped together with msbuild), users will be able to plug-in packaged analyzers shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official analyzers).
+Apart from [inbox checks](#inbox-checks) (shipped together with msbuild), users will be able to plug-in packaged checks shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official checks).
 
-In order to use an analyzer package users just need to reference them via `<PackageReference>` element as standard package reference. 
+In order to use an check package users just need to reference them via `<PackageReference>` element as standard package reference. 
 
 ```xml
-<PackageReference Include="Contoso.Analyzers" Version="1.2.3" />
+<PackageReference Include="Contoso.checks" Version="1.2.3" />
 ```
 
-Only projects referencing the package will be able to run its analyzers. Enabling the rules from package on other projects won’t take any effect.
+Only projects referencing the package will be able to run its checks. Enabling the rules from package on other projects won’t take any effect.
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 6698d20a2dc..4ffcca8427c 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -14,7 +14,7 @@ To enable verbose logging in order to troubleshoot issue(s), enable [binary logg
 
 _Cmd:_
 ```cmd
-dotnet build -bl -analyze
+dotnet build -bl -check
 ```
 
 ## <a name="BC0101"></a>BC0101 - Shared output path.
diff --git a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
index b92a45f36a4..cc19390f06a 100644
--- a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
+++ b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
@@ -4,21 +4,21 @@ This is an internal engineering document. For general overview and user-oriented
 
 # Challenge
 
-Let's recall some details of BuildCheck analyzers acquisition. There might be two types of the build analyzer: build-in and custom. 
-The build-in analyzers are configured in the `.editorconfig` file. The custom analyzers are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
-Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the analyzer is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the analyzer that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
+Let's recall some details of BuildCheck checks acquisition. There might be two types of the build check: build-in and custom. 
+The build-in checks are configured in the `.editorconfig` file. The custom checks are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
+Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the check is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the check that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
 
-![analyzers-acquisition](analyzers-acquisition.png)
+![checks-acquisition](checks-acquisition.png)
 
 There are two issues that arise from such a design:
-1. The configuration of the logging system should be ideally dependent on the set of the applied build analyzers. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the analyzers to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
+1. The configuration of the logging system should be ideally dependent on the set of the applied build checks. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the checks to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
 2. There is no synchronization between build manager and logging service. When the build check acquisition events get to the main node, most of the build might have been already finished on worker nodes.
 
 # Solution ideas
 
-- When analyzers are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
-- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom analysers we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
+- When checks are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
+- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom checks we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
 - Change the initial confuguration of the logging system (in particular, forwardning loggers) during the build. 
-    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom analyzers in the worker node in order to find which events are needed for the custom analyzers. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
-    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the analyzers.  
+    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom checks in the worker node in order to find which events are needed for the custom checks. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
+    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the checks.  
 - As an addition the previous ideas, we may initialize the loggers from cache (either in-process cache or cache file in file system). We might have a strict mode which in case of cache miss invalidates and restarts a corresponding build.
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 5266d458905..3447cb8f875 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -181,7 +181,7 @@ private void RunRegisteredActions<T>(
                 }
             }
 
-            // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
+            // Here we might want to check the configPerRule[0].EvaluationsCheckScope - if the input data supports that
             // The decision and implementation depends on the outcome of the investigation tracked in:
             // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
 
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
index e19b61c2c40..163fd84f1ff 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -7,7 +7,7 @@ To track the request on sharing the code: https://github.com/dotnet/roslyn/issue
 In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
 
 Configuration divided into two categories: 
-- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Infra related configuration. IsEnabled, Severity, EvaluationCheckScope
 - Custom configuration, any other config specified by user for this particular rule
 
 ### Example
@@ -38,7 +38,7 @@ list<editorConfig>{
 }
 ```
 Reverse the order and collect all matching section key-value pairs into new dictionary
-Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+Remove non-msbuild-check related key-values (keys not starting with msbuild_check.RULEID)
 
 The implementation differs depending on category: 
  - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
@@ -67,12 +67,12 @@ Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/m
 
 
 #### Custom configuration data
-CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
-during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+CustomConfigurationData is propogated to the BuildCheck Check instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildExecutionCheck](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildExecutionCheck.cs#L36).
 
 
 #### Example of consuming the CustomConfigurationData
-The `Initialize` method of BuildCheck Analyzer:
+The `Initialize` method of BuildCheck Check:
 ```C#
 public override void Initialize(ConfigurationContext configurationContext)
 {
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index 8f35441485b..4231e12b24f 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -3,7 +3,7 @@
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Info</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
@@ -17,14 +17,14 @@
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.CheckData.#ctor(System.String)</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Info</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
@@ -38,14 +38,14 @@
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.CheckData.#ctor(System.String)</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Info</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
@@ -59,14 +59,14 @@
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.CheckData.#ctor(System.String)</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Info</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
@@ -80,63 +80,63 @@
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.CheckData.#ctor(System.String)</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Error</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Warning</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Error</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Warning</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Error</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Warning</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Error</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheckResultSeverity.Warning</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index d9de22f294e..bf4e56457fe 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -703,7 +703,7 @@ public static bool RegisterBuildCheck(string pathToAssembly, LoggingContext logg
                 return true;
             }
 
-            loggingContext.LogComment(MessageImportance.Low, "CustomAnalyzerAssemblyNotExist", pathToAssembly);
+            loggingContext.LogComment(MessageImportance.Low, "CustomCheckAssemblyNotExist", pathToAssembly);
 
             return false;
         }
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index e36e05d757b..48221d39ea7 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -41,7 +41,7 @@ public void SampleCheckIntegrationTest_CheckOnBuild(bool buildInOutOfProcessNode
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
-            (checkRequested ? " -analyze" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+            (checkRequested ? " -check" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
         _env.Output.WriteLine(output);
 
         success.ShouldBeTrue();
@@ -77,7 +77,7 @@ public void SampleCheckIntegrationTest_ReplayBinaryLogOfCheckedBuild(bool buildI
         string logFile = _env.ExpectFile(".binlog").Path;
 
         _ = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(checkRequested ? "-analyze" : string.Empty)} -bl:{logFile}",
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(checkRequested ? "-check" : string.Empty)} -bl:{logFile}",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
         success.ShouldBeTrue();
@@ -116,7 +116,7 @@ public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string
         PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, BC0101Severity);
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze",
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
         success.ShouldBeTrue();
@@ -150,7 +150,7 @@ public void SampleCheckIntegrationTest_CheckOnBinaryLogReplay(bool buildInOutOfP
         success.ShouldBeTrue();
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic {(checkRequested ? "-analyze" : string.Empty)}",
+         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic {(checkRequested ? "-check" : string.Empty)}",
          out success, false, _env.Output, timeoutMilliseconds: 120_000);
 
         _env.Output.WriteLine(output);
@@ -183,7 +183,7 @@ public void CustomCheckTest(string checkCandidate, string[] expectedRegisteredRu
             AddCustomDataSourceToNugetConfig(checkCandidatePath);
 
             string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
-                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -analyze -verbosity:n",
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -check -verbosity:n",
                 out bool successBuild);
             successBuild.ShouldBeTrue(projectCheckBuildLog);
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 6851120de48..0ef451ba979 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2622,11 +2622,11 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
 
-        [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
-        [InlineData("/v:detailed /analyze", MessageImportance.Low)]
-        [InlineData("/v:normal /analyze", MessageImportance.Normal)]
-        [InlineData("/v:minimal /analyze", MessageImportance.High)]
-        [InlineData("/v:quiet /analyze", MessageImportance.High)]
+        [InlineData("/v:diagnostic /check", MessageImportance.Low)]
+        [InlineData("/v:detailed /check", MessageImportance.Low)]
+        [InlineData("/v:normal /check", MessageImportance.Normal)]
+        [InlineData("/v:minimal /check", MessageImportance.High)]
+        [InlineData("/v:quiet /check", MessageImportance.High)]
 
         [InlineData("/v:diagnostic /tl", MessageImportance.Low)]
         [InlineData("/v:detailed /tl", MessageImportance.Low)]
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 8f9d947b310..ae5646ca7d1 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -100,7 +100,7 @@ internal enum ParameterizedSwitch
             WarningsNotAsErrors,
             WarningsAsMessages,
             BinaryLogger,
-            Analyze,
+            Check,
             Restore,
             ProfileEvaluation,
             RestoreProperty,
@@ -277,7 +277,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "analyze", },                          ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  new string[] { "check", },                            ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   null),
             new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
@@ -467,7 +467,7 @@ internal CommandLineSwitches()
                 Debug.Assert(i == (int)(s_parameterizedSwitchesMap[i].parameterizedSwitch),
                     "The map of parameterized switches must be ordered the same way as the ParameterizedSwitch enumeration.");
                 if (s_parameterizedSwitchesMap[i].parameterizedSwitch is not ParameterizedSwitch.Project and
-                    not ParameterizedSwitch.NodeMode and not ParameterizedSwitch.Analyze)
+                    not ParameterizedSwitch.NodeMode and not ParameterizedSwitch.Check)
                 {
                     Debug.Assert(!string.IsNullOrEmpty(s_parameterizedSwitchesMap[i].resourceId), "All parameterized switches should be cross-checked against the help message strings except from project switch");
                 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 282ce14f354..017237c35d8 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2784,7 +2784,7 @@ private static bool ProcessCommandLineSwitches(
         private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
         {
             // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
-            bool isBuildCheckEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
+            bool isBuildCheckEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Check);
             return isBuildCheckEnabled;
         }
 
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
similarity index 71%
rename from template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
rename to template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
index 8bd2d1853e3..ebf080d5afa 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -5,27 +5,27 @@
       "Common",
       "Library"
     ],
-    "name": "MSBuild custom analyzer skeleton project.",
+    "name": "MSBuild custom check skeleton project.",
     "generatorVersions": "[1.0.0.0-*)",
-    "description": "A project for creating a MSBuild analyzer library that targets .NET Standard",
-    "groupIdentity": "Microsoft.AnalyzerTemplate",
-    "identity": "Microsoft.AnalyzerTemplate",
-    "shortName": "msbuildanalyzer",
+    "description": "A project for creating a MSBuild check library that targets .NET Standard",
+    "groupIdentity": "Microsoft.CheckTemplate",
+    "identity": "Microsoft.CheckTemplate",
+    "shortName": "msbuildcheck",
     "tags": {
       "language": "C#",
       "type": "project"
     },
-    "sourceName": "Company.AnalyzerTemplate",
+    "sourceName": "Company.CheckTemplate",
     "preferNameDirectory": true,
     "primaryOutputs": [
       {
-        "path": "Company.AnalyzerTemplate.csproj"
+        "path": "Company.CheckTemplate.csproj"
       }
    ],
    "symbols": {
     "MicrosoftBuildVersion": {
       "type": "parameter",
-      "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
+      "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
       "datatype": "text",
       "defaultValue": "17.11.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
similarity index 100%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
rename to template_feed/content/Microsoft.CheckTemplate/Check1.cs
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
similarity index 100%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
rename to template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
similarity index 83%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
rename to template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
index 8de608f1023..050b67fb18a 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
   <PropertyGroup>
-	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.AnalyzerTemplate.dll))</MSBuildCheck>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.CheckTemplate.dll))</MSBuildCheck>
   </PropertyGroup>
   <ItemGroup>
     <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/README.md b/template_feed/content/Microsoft.CheckTemplate/README.md
similarity index 100%
rename from template_feed/content/Microsoft.AnalyzerTemplate/README.md
rename to template_feed/content/Microsoft.CheckTemplate/README.md
