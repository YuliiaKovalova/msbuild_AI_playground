diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 656f0ca7733..500594ee332 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -33,10 +33,10 @@ internal ProjectChooseElement() { }
     public sealed partial class ProjectConfigurationInSolution
     {
         internal ProjectConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public bool IncludeInBuild { get { throw null; } }
-        public string PlatformName { get { throw null; } }
+        public string ConfigurationName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string FullName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public bool IncludeInBuild { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string PlatformName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     public abstract partial class ProjectElement : Microsoft.Build.Framework.IProjectElement
     {
@@ -65,7 +65,7 @@ internal ProjectElementContainer() { }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> AllChildren { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> Children { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> ChildrenReversed { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
-        public int Count { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
+        public int Count { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ProjectElement FirstChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ProjectElement LastChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public void AppendChild(Microsoft.Build.Construction.ProjectElement child) { }
@@ -114,11 +114,11 @@ public sealed partial class ProjectInSolution
         internal ProjectInSolution() { }
         public string AbsolutePath { get { throw null; } }
         public System.Collections.Generic.IReadOnlyList<string> Dependencies { get { throw null; } }
-        public string ParentProjectGuid { get { throw null; } }
+        public string ParentProjectGuid { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution> ProjectConfigurations { get { throw null; } }
-        public string ProjectGuid { get { throw null; } }
-        public string ProjectName { get { throw null; } }
-        public Microsoft.Build.Construction.SolutionProjectType ProjectType { get { throw null; } set { } }
+        public string ProjectGuid { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string ProjectName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.SolutionProjectType ProjectType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string RelativePath { get { throw null; } }
     }
     [System.Diagnostics.DebuggerDisplayAttribute("{ItemType} #Metadata={Count} Condition={Condition}")]
@@ -275,7 +275,7 @@ internal ProjectRootElement() { }
         public string TreatAsLocalProperty { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } [System.Diagnostics.DebuggerStepThroughAttribute]set { } }
         public Microsoft.Build.Construction.ElementLocation TreatAsLocalPropertyLocation { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement> UsingTasks { get { throw null; } }
-        public int Version { get { throw null; } }
+        public int Version { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ProjectImportElement AddImport(string project) { throw null; }
         public Microsoft.Build.Construction.ProjectImportGroupElement AddImportGroup() { throw null; }
         public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include) { throw null; }
@@ -463,9 +463,9 @@ internal ProjectWhenElement() { }
     public sealed partial class SolutionConfigurationInSolution
     {
         internal SolutionConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public string PlatformName { get { throw null; } }
+        public string ConfigurationName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string FullName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string PlatformName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     public sealed partial class SolutionFile
     {
@@ -706,7 +706,7 @@ public void UnregisterAllLoggers() { }
         public partial class ProjectAddedToProjectCollectionEventArgs : System.EventArgs
         {
             public ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) { }
-            public Microsoft.Build.Construction.ProjectRootElement ProjectRootElement { get { throw null; } }
+            public Microsoft.Build.Construction.ProjectRootElement ProjectRootElement { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         }
     }
     public partial class ProjectCollectionChangedEventArgs : System.EventArgs
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 82647d6c236..c803bc549c9 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -33,10 +33,10 @@ internal ProjectChooseElement() { }
     public sealed partial class ProjectConfigurationInSolution
     {
         internal ProjectConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public bool IncludeInBuild { get { throw null; } }
-        public string PlatformName { get { throw null; } }
+        public string ConfigurationName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string FullName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public bool IncludeInBuild { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string PlatformName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     public abstract partial class ProjectElement : Microsoft.Build.Framework.IProjectElement
     {
@@ -65,7 +65,7 @@ internal ProjectElementContainer() { }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> AllChildren { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> Children { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> ChildrenReversed { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
-        public int Count { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
+        public int Count { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ProjectElement FirstChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ProjectElement LastChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public void AppendChild(Microsoft.Build.Construction.ProjectElement child) { }
@@ -114,11 +114,11 @@ public sealed partial class ProjectInSolution
         internal ProjectInSolution() { }
         public string AbsolutePath { get { throw null; } }
         public System.Collections.Generic.IReadOnlyList<string> Dependencies { get { throw null; } }
-        public string ParentProjectGuid { get { throw null; } }
+        public string ParentProjectGuid { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution> ProjectConfigurations { get { throw null; } }
-        public string ProjectGuid { get { throw null; } }
-        public string ProjectName { get { throw null; } }
-        public Microsoft.Build.Construction.SolutionProjectType ProjectType { get { throw null; } set { } }
+        public string ProjectGuid { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string ProjectName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.SolutionProjectType ProjectType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string RelativePath { get { throw null; } }
     }
     [System.Diagnostics.DebuggerDisplayAttribute("{ItemType} #Metadata={Count} Condition={Condition}")]
@@ -275,7 +275,7 @@ internal ProjectRootElement() { }
         public string TreatAsLocalProperty { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } [System.Diagnostics.DebuggerStepThroughAttribute]set { } }
         public Microsoft.Build.Construction.ElementLocation TreatAsLocalPropertyLocation { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement> UsingTasks { get { throw null; } }
-        public int Version { get { throw null; } }
+        public int Version { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ProjectImportElement AddImport(string project) { throw null; }
         public Microsoft.Build.Construction.ProjectImportGroupElement AddImportGroup() { throw null; }
         public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include) { throw null; }
@@ -463,9 +463,9 @@ internal ProjectWhenElement() { }
     public sealed partial class SolutionConfigurationInSolution
     {
         internal SolutionConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public string PlatformName { get { throw null; } }
+        public string ConfigurationName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string FullName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public string PlatformName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     public sealed partial class SolutionFile
     {
@@ -706,7 +706,7 @@ public void UnregisterAllLoggers() { }
         public partial class ProjectAddedToProjectCollectionEventArgs : System.EventArgs
         {
             public ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) { }
-            public Microsoft.Build.Construction.ProjectRootElement ProjectRootElement { get { throw null; } }
+            public Microsoft.Build.Construction.ProjectRootElement ProjectRootElement { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         }
     }
     public partial class ProjectCollectionChangedEventArgs : System.EventArgs
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index 9795378db55..e3e0489cf1f 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -33,8 +33,7 @@ public class ProjectCollection_Tests : IDisposable
 
         public ProjectCollection_Tests(ITestOutputHelper outputHelper)
         {
-            this.TestOutput = outputHelper;
-
+            TestOutput = outputHelper;
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
         }
 
@@ -72,11 +71,14 @@ public void AddProjectFromDisk()
                 Project project = new Project(path);
 
                 Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject(path);
-                Assert.Equal(true, Object.ReferenceEquals(project, project2));
+                Assert.Equal(true, ReferenceEquals(project, project2));
             }
             finally
             {
-                File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -98,11 +100,14 @@ public void AddProjectOnSave()
                 project.Save(path);
 
                 Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject(path);
-                Assert.Equal(true, object.ReferenceEquals(project, project2));
+                Assert.Equal(true, ReferenceEquals(project, project2));
             }
             finally
             {
-                File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -124,11 +129,11 @@ public void AddProjectOnSave_SpecifiedProjectCollection()
                 project.Save(path);
 
                 Project project2 = collection.LoadProject(path);
-                Assert.Equal(true, object.ReferenceEquals(project, project2));
+                Assert.Equal(true, ReferenceEquals(project, project2));
             }
             finally
             {
-                File.Delete(path);
+                if (path != null) File.Delete(path);
             }
         }
 
@@ -139,11 +144,9 @@ public void AddProjectOnSave_SpecifiedProjectCollection()
         [Fact]
         public void AddProjectOnSetName()
         {
-            Project project = new Project();
-            project.FullPath = "c:\\x";
-
+            var project = new Project { FullPath = "c:\\x" };
             Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject("c:\\x");
-            Assert.Equal(true, object.ReferenceEquals(project, project2));
+            Assert.Equal(true, ReferenceEquals(project, project2));
         }
 
         /// <summary>
@@ -158,7 +161,7 @@ public void GlobalPropertyInheritLoadFromFile()
             {
                 path = CreateProjectFile();
 
-                ProjectCollection collection = new ProjectCollection();
+                var collection = new ProjectCollection();
                 collection.SetGlobalProperty("p", "v");
                 Project project = collection.LoadProject(path);
 
@@ -166,7 +169,10 @@ public void GlobalPropertyInheritLoadFromFile()
             }
             finally
             {
-                File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -194,7 +200,10 @@ public void GlobalPropertyInheritLoadFromFile2()
             }
             finally
             {
-                File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -222,7 +231,10 @@ public void GlobalPropertyInheritLoadFromFile3()
             }
             finally
             {
-                File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -234,7 +246,7 @@ public void GlobalPropertyInheritLoadFromXml1()
         {
             XmlReader reader = CreateProjectXmlReader();
 
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.SetGlobalProperty("p", "v");
 
             Project project = collection.LoadProject(reader);
@@ -250,7 +262,7 @@ public void GlobalPropertyInheritLoadFromXml2()
         {
             XmlReader reader = CreateProjectXmlReader();
 
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.SetGlobalProperty("p", "v");
 
             Project project = collection.LoadProject(reader, ObjectModelHelpers.MSBuildDefaultToolsVersion);
@@ -264,10 +276,10 @@ public void GlobalPropertyInheritLoadFromXml2()
         [Fact]
         public void GlobalPropertyInheritProjectConstructor()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.SetGlobalProperty("p", "v");
 
-            Project project = new Project(collection);
+            var project = new Project(collection);
 
             Assert.Equal("v", project.GlobalProperties["p"]);
         }
@@ -287,13 +299,16 @@ public void GetLoadedProjectNonExistent()
                 xml.Save(path);
                 Assert.Equal(0, ProjectCollection.GlobalProjectCollection.Count);
 
-                Project result = ProjectCollection.GlobalProjectCollection.LoadProject(path);
+                ProjectCollection.GlobalProjectCollection.LoadProject(path);
 
                 Assert.Equal(1, ProjectCollection.GlobalProjectCollection.Count);
             }
             finally
             {
-                File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -303,15 +318,13 @@ public void GetLoadedProjectNonExistent()
         [Fact]
         public void GetLoadedProjectWrongCollection()
         {
-            Project project1 = new Project();
-            project1.FullPath = "c:\\1";
+            var project1 = new Project { FullPath = "c:\\1" };
 
-            ProjectCollection collection = new ProjectCollection();
-            Project project2 = new Project(collection);
-            project2.FullPath = "c:\\1";
+            var collection = new ProjectCollection();
+            var project2 = new Project(collection) { FullPath = "c:\\1" };
 
-            Assert.Equal(true, object.ReferenceEquals(project2, collection.LoadProject("c:\\1")));
-            Assert.Equal(false, object.ReferenceEquals(project1, collection.LoadProject("c:\\1")));
+            Assert.Equal(true, ReferenceEquals(project2, collection.LoadProject("c:\\1")));
+            Assert.Equal(false, ReferenceEquals(project1, collection.LoadProject("c:\\1")));
         }
 
         /// <summary>
@@ -332,16 +345,19 @@ public void GetLoadedProjectRootElementWrongCollection()
                 Project project1 = collection1.LoadProject(path);
                 Project project1b = collection1.LoadProject(path);
 
-                Assert.Equal(true, object.ReferenceEquals(project1.Xml, project1b.Xml));
+                Assert.Equal(true, ReferenceEquals(project1.Xml, project1b.Xml));
 
                 ProjectCollection collection2 = new ProjectCollection();
                 Project project2 = collection2.LoadProject(path);
 
-                Assert.Equal(false, object.ReferenceEquals(project1.Xml, project2.Xml));
+                Assert.Equal(false, ReferenceEquals(project1.Xml, project2.Xml));
             }
             finally
             {
-                File.Delete(path);
+                if (path != null)
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -353,14 +369,11 @@ public void ErrorTwoProjectsEquivalentOneCollection()
         {
             Assert.Throws<InvalidOperationException>(() =>
             {
-                Project project = new Project();
-                project.FullPath = "c:\\x";
-
-                Project project2 = new Project();
-                project2.FullPath = "c:\\x";
-            }
-           );
+                _ = new Project { FullPath = "c:\\x" };
+                _ = new Project { FullPath = "c:\\x" };
+            });
         }
+
         /// <summary>
         /// Validates that when loading two projects with nominally different global properties, but that match when we take 
         /// into account the ProjectCollection's global properties, we get the pre-existing project if one exists. 
@@ -368,8 +381,7 @@ public void ErrorTwoProjectsEquivalentOneCollection()
         [Fact]
         public void TwoProjectsEquivalentWhenOneInheritsFromProjectCollection()
         {
-            Project project = new Project();
-            project.FullPath = "c:\\1";
+            var project = new Project { FullPath = "c:\\1" };
 
             // Set a global property on the project collection -- this should be passed on to all 
             // loaded projects. 
@@ -378,10 +390,9 @@ public void TwoProjectsEquivalentWhenOneInheritsFromProjectCollection()
             Assert.Equal("Debug", project.GlobalProperties["Configuration"]);
 
             // now create a global properties dictionary to pass to a new project 
-            Dictionary<string, string> globals = new Dictionary<string, string>();
+            var globals = new Dictionary<string, string> { { "Configuration", "Debug" } };
 
-            globals.Add("Configuration", "Debug");
-            Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject("c:\\1", globals, null);
+            ProjectCollection.GlobalProjectCollection.LoadProject("c:\\1", globals, null);
 
             Assert.Equal(1, ProjectCollection.GlobalProjectCollection.Count);
         }
@@ -395,18 +406,22 @@ public void TwoProjectsDistinguishedByGlobalPropertiesOnly()
             ProjectRootElement xml = ProjectRootElement.Create();
             string projectDirectory = NativeMethodsShared.IsWindows ? "c:\\1" : "/l";
 
-            Dictionary<string, string> globalProperties1 = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            globalProperties1.Add("p", "v1");
-            Project project1 = new Project(xml, globalProperties1, ObjectModelHelpers.MSBuildDefaultToolsVersion);
-            project1.FullPath = projectDirectory;
+            var globalProperties1 = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { { "p", "v1" } };
+            var project1 =
+                new Project(xml, globalProperties1, ObjectModelHelpers.MSBuildDefaultToolsVersion)
+                {
+                    FullPath = projectDirectory
+                };
 
-            Dictionary<string, string> globalProperties2 = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            globalProperties2.Add("p", "v2");
-            Project project2 = new Project(xml, globalProperties2, ObjectModelHelpers.MSBuildDefaultToolsVersion);
-            project2.FullPath = projectDirectory;
+            var globalProperties2 = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { { "p", "v2" } };
+            var project2 =
+                new Project(xml, globalProperties2, ObjectModelHelpers.MSBuildDefaultToolsVersion)
+                {
+                    FullPath = projectDirectory
+                };
 
-            Assert.Equal(true, object.ReferenceEquals(project1, ProjectCollection.GlobalProjectCollection.LoadProject(projectDirectory, globalProperties1, ObjectModelHelpers.MSBuildDefaultToolsVersion)));
-            Assert.Equal(true, object.ReferenceEquals(project2, ProjectCollection.GlobalProjectCollection.LoadProject(projectDirectory, globalProperties2, ObjectModelHelpers.MSBuildDefaultToolsVersion)));
+            Assert.Equal(true, ReferenceEquals(project1, ProjectCollection.GlobalProjectCollection.LoadProject(projectDirectory, globalProperties1, ObjectModelHelpers.MSBuildDefaultToolsVersion)));
+            Assert.Equal(true, ReferenceEquals(project2, ProjectCollection.GlobalProjectCollection.LoadProject(projectDirectory, globalProperties2, ObjectModelHelpers.MSBuildDefaultToolsVersion)));
 
             List<Project> projects = Helpers.MakeList(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
@@ -423,8 +438,7 @@ public void TwoProjectsDistinguishedByGlobalPropertiesOnly()
         [Fact]
         public void TwoProjectsDistinguishedByGlobalPropertiesOnly_ProjectOverridesProjectCollection()
         {
-            Project project = new Project();
-            project.FullPath = "c:\\1";
+            var project = new Project { FullPath = "c:\\1" };
 
             // Set a global property on the project collection -- this should be passed on to all 
             // loaded projects. 
@@ -436,10 +450,9 @@ public void TwoProjectsDistinguishedByGlobalPropertiesOnly_ProjectOverridesProje
             project.SetGlobalProperty("MyProperty", "MyValue");
 
             // now create a global properties dictionary to pass to a new project 
-            Dictionary<string, string> project2Globals = new Dictionary<string, string>();
+            var project2Globals =
+                new Dictionary<string, string> { { "Configuration", "Release" }, { "Platform", "Win32" } };
 
-            project2Globals.Add("Configuration", "Release");
-            project2Globals.Add("Platform", "Win32");
             Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject("c:\\1", project2Globals, null);
 
             Assert.Equal("Release", project2.GlobalProperties["Configuration"]);
@@ -492,13 +505,11 @@ public void TwoProjectsDistinguishedByToolsVersionOnly()
 
             ProjectRootElement xml = ProjectRootElement.Create();
 
-            Project project1 = new Project(xml, null, "2.0");
-            project1.FullPath = "c:\\1";
+            var project1 = new Project(xml, null, "2.0") { FullPath = "c:\\1" };
 
-            Project project2 = new Project(xml, null, ObjectModelHelpers.MSBuildDefaultToolsVersion);
-            project2.FullPath = "c:\\1";
-            Assert.Equal(true, object.ReferenceEquals(project1, ProjectCollection.GlobalProjectCollection.LoadProject("c:\\1", null, "2.0")));
-            Assert.Equal(true, object.ReferenceEquals(project2, ProjectCollection.GlobalProjectCollection.LoadProject("c:\\1", null, ObjectModelHelpers.MSBuildDefaultToolsVersion)));
+            var project2 = new Project(xml, null, ObjectModelHelpers.MSBuildDefaultToolsVersion) { FullPath = "c:\\1" };
+            Assert.Equal(true, ReferenceEquals(project1, ProjectCollection.GlobalProjectCollection.LoadProject("c:\\1", null, "2.0")));
+            Assert.Equal(true, ReferenceEquals(project2, ProjectCollection.GlobalProjectCollection.LoadProject("c:\\1", null, ObjectModelHelpers.MSBuildDefaultToolsVersion)));
         }
 
         /// <summary>
@@ -508,18 +519,17 @@ public void TwoProjectsDistinguishedByToolsVersionOnly()
         [Fact]
         public void ReloadProjectWithInvalidToolsVersionInFile()
         {
-            string content = @"
+            const string content = @"
                     <Project ToolsVersion='bogus' xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
                         <Target Name='t'/>
                     </Project>
                 ";
 
-            Project project = new Project(XmlReader.Create(new StringReader(content)));
-            project.FullPath = "c:\\123.proj";
+            var project = new Project(XmlReader.Create(new StringReader(content))) { FullPath = "c:\\123.proj" };
 
             Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject("c:\\123.proj", null, null);
 
-            Assert.True(object.ReferenceEquals(project, project2));
+            Assert.True(ReferenceEquals(project, project2));
         }
 
         /// <summary>
@@ -529,18 +539,17 @@ public void ReloadProjectWithInvalidToolsVersionInFile()
         [Fact]
         public void ReloadProjectWithProjectToolsVersionDifferentFromEffectiveToolsVersion()
         {
-            string content = @"
+            const string content = @"
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
                         <Target Name='t'/>
                     </Project>
                 ";
 
-            Project project = new Project(XmlReader.Create(new StringReader(content)));
-            project.FullPath = "c:\\123.proj";
+            var project = new Project(XmlReader.Create(new StringReader(content))) { FullPath = "c:\\123.proj" };
 
             Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject("c:\\123.proj", null, null);
 
-            Assert.True(object.ReferenceEquals(project, project2));
+            Assert.True(ReferenceEquals(project, project2));
         }
 
         /// <summary>
@@ -551,15 +560,13 @@ public void ReloadProjectWithProjectToolsVersionDifferentFromEffectiveToolsVersi
         public void ChangingGlobalPropertiesUpdatesCollection()
         {
             ProjectCollection collection = new ProjectCollection();
-            Project project = new Project(collection);
-            project.FullPath = "c:\\x"; // load into collection
+            var project = new Project(collection) { FullPath = "c:\\x" };
             project.SetGlobalProperty("p", "v1"); // should update collection
 
-            Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            globalProperties.Add("p", "v1");
+            var globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { { "p", "v1" } };
             Project newProject = collection.LoadProject("c:\\x", globalProperties, null);
 
-            Assert.Equal(true, object.ReferenceEquals(project, newProject));
+            Assert.Equal(true, ReferenceEquals(project, newProject));
         }
 
         /// <summary>
@@ -569,9 +576,9 @@ public void ChangingGlobalPropertiesUpdatesCollection()
         [Fact]
         public void SettingGlobalPropertiesOnCollectionUpdatesProjects()
         {
-            ProjectCollection collection = new ProjectCollection();
-            Project project1 = new Project(collection);
-            project1.FullPath = "c:\\y"; // load into collection
+            var collection = new ProjectCollection();
+            var project1 = new Project(collection) { FullPath = "c:\\y" };
+            // load into collection
             Assert.Equal(0, project1.GlobalProperties.Count);
 
             collection.SetGlobalProperty("g1", "v1");
@@ -581,8 +588,7 @@ public void SettingGlobalPropertiesOnCollectionUpdatesProjects()
             Assert.Equal(2, project1.GlobalProperties.Count);
 
             collection.RemoveGlobalProperty("g2");
-            Project project2 = new Project(collection);
-            project2.FullPath = "c:\\x"; // load into collection
+            var project2 = new Project(collection) { FullPath = "c:\\x" };
 
             Assert.Equal(1, project1.GlobalProperties.Count);
             Assert.Equal("v1", project2.GlobalProperties["g1"]);
@@ -598,9 +604,9 @@ public void SettingGlobalPropertiesOnCollectionUpdatesProjects()
         [Fact]
         public void SettingGlobalPropertiesOnCollectionUpdatesProjects2()
         {
-            ProjectCollection collection = new ProjectCollection();
-            Project project1 = new Project(collection);
-            project1.FullPath = "c:\\y"; // load into collection
+            var collection = new ProjectCollection();
+            var project1 = new Project(collection) { FullPath = "c:\\y" };
+            // load into collection
             project1.SetGlobalProperty("g1", "v0");
             Helpers.ClearDirtyFlag(project1.Xml);
 
@@ -620,9 +626,8 @@ public void SettingGlobalPropertiesOnCollectionUpdatesProjects2()
         [Fact]
         public void RemovingGlobalPropertiesOnCollectionUpdatesProjects()
         {
-            ProjectCollection collection = new ProjectCollection();
-            Project project1 = new Project(collection);
-            project1.FullPath = "c:\\y"; // load into collection
+            var collection = new ProjectCollection();
+            var project1 = new Project(collection) { FullPath = "c:\\y" };
             Assert.Equal(0, project1.GlobalProperties.Count);
 
             Helpers.ClearDirtyFlag(project1.Xml);
@@ -632,8 +637,7 @@ public void RemovingGlobalPropertiesOnCollectionUpdatesProjects()
 
             Assert.Equal(true, project1.IsDirty);
 
-            Project project2 = new Project(collection);
-            project2.FullPath = "c:\\x"; // load into collection
+            var project2 = new Project(collection) { FullPath = "c:\\x" };
 
             Assert.Equal(true, project2.IsDirty);
 
@@ -667,11 +671,10 @@ public void RemovingGlobalPropertiesOnCollectionUpdatesProjects()
         [Fact]
         public void RemovingGlobalPropertiesOnCollectionUpdatesProjects2()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.SetGlobalProperty("g1", "v1");
 
-            Project project1 = new Project(collection);
-            project1.FullPath = "c:\\y"; // load into collection
+            var project1 = new Project(collection) { FullPath = "c:\\y" };
             project1.SetGlobalProperty("g1", "v0"); // mask collection property
             Helpers.ClearDirtyFlag(project1.Xml);
 
@@ -687,8 +690,7 @@ public void RemovingGlobalPropertiesOnCollectionUpdatesProjects2()
         [Fact]
         public void UnloadProject()
         {
-            Project project = new Project();
-            project.FullPath = "c:\\x"; // load into collection
+            var project = new Project { FullPath = "c:\\x" };
 
             Assert.Equal(1, ProjectCollection.GlobalProjectCollection.Count);
 
@@ -704,8 +706,7 @@ public void UnloadProject()
         [Fact]
         public void UnloadProjectXml()
         {
-            Project project = new Project();
-            project.FullPath = "c:\\x"; // load into collection
+            var project = new Project { FullPath = "c:\\x" };
             ProjectRootElement xml = project.Xml;
 
             // Unload the evaluation project, and then the XML.
@@ -733,14 +734,13 @@ public void UnloadProjectXmlWhileInDirectUse()
         {
             Assert.Throws<InvalidOperationException>(() =>
             {
-                Project project = new Project();
-                project.FullPath = "c:\\x"; // load into collection
+                var project = new Project { FullPath = "c:\\x" };
 
                 // Attempt to unload the xml before unloading the project evaluation.
                 ProjectCollection.GlobalProjectCollection.UnloadProject(project.Xml);
-            }
-           );
+            });
         }
+
         /// <summary>
         /// Unloading project XML while it is in use should result in an exception.
         /// </summary>
@@ -749,11 +749,9 @@ public void UnloadProjectXmlWhileInImportUse()
         {
             Assert.Throws<InvalidOperationException>(() =>
             {
-                Project mainProject = new Project();
-                mainProject.FullPath = "c:\\main"; // load into collection
+                var mainProject = new Project { FullPath = "c:\\main" };
 
-                Project importProject = new Project();
-                importProject.FullPath = "c:\\import"; // load into collection
+                var importProject = new Project { FullPath = "c:\\import" };
                 ProjectRootElement importedXml = importProject.Xml;
 
                 // Import into main project
@@ -776,20 +774,20 @@ public void UnloadProjectXmlWhileInImportUse()
             }
            );
         }
+
         /// <summary>
         /// Renaming a project should correctly update the project collection's set of loaded projects.
         /// </summary>
         [Fact]
         public void RenameProject()
         {
-            Project project = new Project();
-            project.FullPath = "c:\\x"; // load into collection
+            var project = new Project { FullPath = "c:\\x" };
 
             project.FullPath = "c:\\y";
 
             Assert.Equal(1, ProjectCollection.GlobalProjectCollection.Count);
 
-            Assert.Equal(true, object.ReferenceEquals(project, Helpers.MakeList(ProjectCollection.GlobalProjectCollection.LoadedProjects)[0]));
+            Assert.Equal(true, ReferenceEquals(project, Helpers.MakeList(ProjectCollection.GlobalProjectCollection.LoadedProjects)[0]));
 
             ProjectCollection.GlobalProjectCollection.UnloadProject(project); // should not throw
 
@@ -802,8 +800,7 @@ public void RenameProject()
         [Fact]
         public void RenameProjectAndVerifyStillContainsProjectCollectionGlobalProperties()
         {
-            Project project = new Project();
-            project.FullPath = "c:\\1";
+            var project = new Project { FullPath = "c:\\1" };
 
             // Set a global property on the project collection -- this should be passed on to all 
             // loaded projects. 
@@ -843,8 +840,8 @@ public void SaveToNewNameAndUnload()
             }
             finally
             {
-                File.Delete(file1);
-                File.Delete(file2);
+                if (file1 != null) File.Delete(file1);
+                if (file2 != null) File.Delete(file2);
             }
         }
 
@@ -863,11 +860,11 @@ public void LoadUnloadReloadSaveToNewName()
                 file1 = FileUtilities.GetTemporaryFile();
                 file2 = FileUtilities.GetTemporaryFile();
 
-                Project project = new Project();
+                var project = new Project();
                 project.Save(file1);
                 project.ProjectCollection.UnloadProject(project);
 
-                ProjectCollection collection = new ProjectCollection();
+                var collection = new ProjectCollection();
 
                 Project project2 = collection.LoadProject(file1);
                 collection.UnloadProject(project2);
@@ -879,8 +876,8 @@ public void LoadUnloadReloadSaveToNewName()
             }
             finally
             {
-                File.Delete(file1);
-                File.Delete(file2);
+                if (file1 != null) File.Delete(file1);
+                if (file2 != null) File.Delete(file2);
             }
         }
 
@@ -899,13 +896,13 @@ public void LoadUnloadAllReloadSaveToNewName()
                 file1 = FileUtilities.GetTemporaryFile();
                 file2 = FileUtilities.GetTemporaryFile();
 
-                Project project = new Project();
+                var project = new Project();
                 project.Save(file1);
                 project.ProjectCollection.UnloadProject(project);
 
-                ProjectCollection collection = new ProjectCollection();
+                var collection = new ProjectCollection();
 
-                Project project2 = collection.LoadProject(file1);
+                collection.LoadProject(file1);
                 collection.UnloadAllProjects();
 
                 Project project3 = collection.LoadProject(file1);
@@ -915,8 +912,8 @@ public void LoadUnloadAllReloadSaveToNewName()
             }
             finally
             {
-                File.Delete(file1);
-                File.Delete(file2);
+                if (file1 != null) File.Delete(file1);
+                if (file2 != null) File.Delete(file2);
             }
         }
 
@@ -926,10 +923,10 @@ public void LoadUnloadAllReloadSaveToNewName()
         [Fact]
         public void AddToolset()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.RemoveAllToolsets();
 
-            Toolset toolset = new Toolset("x", "c:\\y", collection, null);
+            var toolset = new Toolset("x", "c:\\y", collection, null);
             collection.AddToolset(toolset);
 
             Assert.Equal(toolset, collection.GetToolset("x"));
@@ -946,11 +943,11 @@ public void AddToolset()
         [Fact]
         public void AddTwoToolsets()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.RemoveAllToolsets();
 
-            Toolset toolset1 = new Toolset("x", "c:\\y", collection, null);
-            Toolset toolset2 = new Toolset("y", "c:\\z", collection, null);
+            var toolset1 = new Toolset("x", "c:\\y", collection, null);
+            var toolset2 = new Toolset("y", "c:\\z", collection, null);
 
             collection.AddToolset(toolset1);
             collection.AddToolset(toolset2);
@@ -970,11 +967,11 @@ public void AddTwoToolsets()
         [Fact]
         public void ReplaceToolset()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.RemoveAllToolsets();
 
-            Toolset toolset1 = new Toolset("x", "c:\\y", collection, null);
-            Toolset toolset2 = new Toolset("x", "c:\\z", collection, null);
+            var toolset1 = new Toolset("x", "c:\\y", collection, null);
+            var toolset2 = new Toolset("x", "c:\\z", collection, null);
 
             collection.AddToolset(toolset1);
             collection.AddToolset(toolset2);
@@ -995,21 +992,21 @@ public void AddNullToolset()
             Assert.Throws<ArgumentNullException>(() =>
             {
                 ProjectCollection.GlobalProjectCollection.AddToolset(null);
-            }
-           );
+            });
         }
+
         /// <summary>
         /// Remove a toolset
         /// </summary>
         [Fact]
         public void RemoveToolset()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
 
-            Toolset toolset1 = new Toolset("x", "c:\\y", collection, null);
-            Toolset toolset2 = new Toolset("y", "c:\\z", collection, null);
+            var toolset1 = new Toolset("x", "c:\\y", collection, null);
+            var toolset2 = new Toolset("y", "c:\\z", collection, null);
 
-            int initial = Helpers.MakeList<Toolset>(collection.Toolsets).Count;
+            int initial = Helpers.MakeList(collection.Toolsets).Count;
 
             collection.AddToolset(toolset1);
             collection.AddToolset(toolset2);
@@ -1017,7 +1014,7 @@ public void RemoveToolset()
             Assert.Equal(true, collection.RemoveToolset("x"));
             Assert.Equal(false, collection.ContainsToolset("x"));
 
-            Assert.Equal(1, Helpers.MakeList<Toolset>(collection.Toolsets).Count - initial);
+            Assert.Equal(1, Helpers.MakeList(collection.Toolsets).Count - initial);
         }
 
         /// <summary>
@@ -1026,7 +1023,7 @@ public void RemoveToolset()
         [Fact]
         public void RemoveNonexistentToolset()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             Assert.Equal(false, collection.RemoveToolset("nonexistent"));
         }
 
@@ -1039,9 +1036,9 @@ public void RemoveNullToolsVersion()
             Assert.Throws<ArgumentNullException>(() =>
             {
                 ProjectCollection.GlobalProjectCollection.RemoveToolset(null);
-            }
-           );
+            });
         }
+
         /// <summary>
         /// Attempt to remove an empty string toolsversion
         /// </summary>
@@ -1051,9 +1048,9 @@ public void RemoveEmptyToolsVersion()
             Assert.Throws<ArgumentException>(() =>
             {
                 ProjectCollection.GlobalProjectCollection.RemoveToolset(String.Empty);
-            }
-           );
+            });
         }
+
         /// <summary>
         /// Current default from registry is 2.0 if 2.0 is installed
         /// </summary>
@@ -1066,7 +1063,7 @@ public void DefaultToolsVersion()
                 return;
             }
 
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
 #if STANDALONEBUILD
             Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, collection.DefaultToolsVersion);
 #else
@@ -1091,7 +1088,7 @@ public void DefaultToolsVersion2()
                 return;
             }
 
-            ProjectCollection collection = new ProjectCollection(null, null, ToolsetDefinitionLocations.Registry);
+            var collection = new ProjectCollection(null, null, ToolsetDefinitionLocations.Registry);
             Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, collection.DefaultToolsVersion);
         }
 
@@ -1104,9 +1101,9 @@ public void SetDefaultToolsVersionEmpty()
             Assert.Throws<ArgumentException>(() =>
             {
                 ProjectCollection.GlobalProjectCollection.DefaultToolsVersion = String.Empty;
-            }
-           );
+            });
         }
+
         /// <summary>
         /// Error setting default tools version to a toolset that does not exist
         /// </summary>
@@ -1116,16 +1113,16 @@ public void SetDefaultToolsVersionNonexistentToolset()
             Assert.Throws<InvalidOperationException>(() =>
             {
                 ProjectCollection.GlobalProjectCollection.DefaultToolsVersion = "nonexistent";
-            }
-           );
+            });
         }
+
         /// <summary>
         /// Set default tools version; subsequent projects should use it 
         /// </summary>
         [Fact]
         public void SetDefaultToolsVersion()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             collection.AddToolset(new Toolset("x", @"c:\y", collection, null));
 
             collection.DefaultToolsVersion = "x";
@@ -1138,7 +1135,7 @@ public void SetDefaultToolsVersion()
                     </Project>
                 ");
 
-            Project project = new Project(XmlReader.Create(new StringReader(content)), null, null, collection);
+            var project = new Project(XmlReader.Create(new StringReader(content)), null, null, collection);
 
             // ... and after all that, we end up defaulting to the current ToolsVersion instead.  There's a way 
             // to turn this behavior (new in Dev12) off, but it requires setting an environment variable and 
@@ -1153,7 +1150,7 @@ public void SetDefaultToolsVersion()
         [Fact]
         public void ProjectCollectionChangedEvent()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             bool dirtyRaised = false;
             ProjectCollectionChangedState expectedChange = ProjectCollectionChangedState.Loggers;
             collection.ProjectCollectionChanged +=
@@ -1198,7 +1195,7 @@ public void ProjectCollectionChangedEvent()
             // Verify HostServices changes raise the event.
             expectedChange = ProjectCollectionChangedState.HostServices;
             dirtyRaised = false;
-            collection.HostServices = new Execution.HostServices();
+            collection.HostServices = new HostServices();
             Assert.True(dirtyRaised);
 
             expectedChange = ProjectCollectionChangedState.Loggers;
@@ -1208,7 +1205,7 @@ public void ProjectCollectionChangedEvent()
 
             expectedChange = ProjectCollectionChangedState.Loggers;
             dirtyRaised = false;
-            collection.RegisterLoggers(new Microsoft.Build.Framework.ILogger[] { new MockLogger(), new MockLogger() });
+            collection.RegisterLoggers(new Build.Framework.ILogger[] { new MockLogger(), new MockLogger() });
             Assert.True(dirtyRaised);
 
             expectedChange = ProjectCollectionChangedState.Loggers;
@@ -1245,7 +1242,7 @@ public void ProjectCollectionChangedEvent2()
         {
             // Verify if the project, project collection and the value we are setting in the project collection are all the same
             // then the projects value for the property should not change and no event should be fired.
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             XmlReader reader = CreateProjectXmlReader();
             Project project = collection.LoadProject(reader, ObjectModelHelpers.MSBuildDefaultToolsVersion);
             project.SetProperty("a", "1");
@@ -1269,7 +1266,7 @@ public void ProjectCollectionChangedEvent2()
             project.SetProperty("a", "1");
             collection.SetGlobalProperty("a", "1");
             VerifyProjectCollectionEvents(collection, true, "2");
-            project.GetPropertyValue("a").Equals("2", StringComparison.OrdinalIgnoreCase);
+            Assert.True(project.GetPropertyValue("a").Equals("2", StringComparison.OrdinalIgnoreCase));
 
             // Verify if the project, project collection have the same value but a new value is set in the project collection
             // then the projects value for the property should be change and an event should be fired.
@@ -1279,7 +1276,7 @@ public void ProjectCollectionChangedEvent2()
             project.SetProperty("a", "1");
             collection.SetGlobalProperty("a", "(x86)");
             VerifyProjectCollectionEvents(collection, true, "%28x86%29");
-            project.GetPropertyValue("a").Equals("%28x86%29", StringComparison.OrdinalIgnoreCase);
+            Assert.True(project.GetPropertyValue("a").Equals("%28x86%29", StringComparison.OrdinalIgnoreCase));
 
             // Verify if the project has one value and project collection and the property we are setting on the project collection have the same value
             // then the projects value for the property should be change but no event should be fired
@@ -1290,7 +1287,7 @@ public void ProjectCollectionChangedEvent2()
             collection.SetGlobalProperty("a", "1");
 
             VerifyProjectCollectionEvents(collection, false, "1");
-            project.GetPropertyValue("a").Equals("1", StringComparison.OrdinalIgnoreCase);
+            Assert.True(project.GetPropertyValue("a").Equals("1", StringComparison.OrdinalIgnoreCase));
 
             // Verify if the project and the property being set have one value but the project collection has another
             // then the projects value for the property should not change and event should be fired
@@ -1300,7 +1297,7 @@ public void ProjectCollectionChangedEvent2()
             project.SetProperty("a", "1");
             collection.SetGlobalProperty("a", "2");
             VerifyProjectCollectionEvents(collection, true, "1");
-            project.GetPropertyValue("a").Equals("1", StringComparison.OrdinalIgnoreCase);
+            Assert.True(project.GetPropertyValue("a").Equals("1", StringComparison.OrdinalIgnoreCase));
 
             // item is added to project collection for the first time. Make sure it is added to the project and an event is fired.
             collection = new ProjectCollection();
@@ -1308,7 +1305,7 @@ public void ProjectCollectionChangedEvent2()
             project = collection.LoadProject(reader, ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             VerifyProjectCollectionEvents(collection, true, "1");
-            project.GetPropertyValue("a").Equals("1", StringComparison.OrdinalIgnoreCase);
+            Assert.True(project.GetPropertyValue("a").Equals("1", StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -1317,7 +1314,7 @@ public void ProjectCollectionChangedEvent2()
         [Fact]
         public void ProjectXmlChangedEvent()
         {
-            ProjectCollection collection = new ProjectCollection();
+            var collection = new ProjectCollection();
             ProjectRootElement pre = null;
             bool dirtyRaised = false;
             collection.ProjectXmlChanged +=
@@ -1325,7 +1322,7 @@ public void ProjectXmlChangedEvent()
                 {
                     Assert.Same(collection, sender);
                     Assert.Same(pre, e.ProjectXml);
-                    this.TestOutput.WriteLine(e.Reason ?? String.Empty);
+                    TestOutput.WriteLine(e.Reason ?? String.Empty);
                     dirtyRaised = true;
                 };
             Assert.False(dirtyRaised);
@@ -1376,8 +1373,7 @@ public void ProjectXmlChangedEvent()
         [Fact]
         public void ProjectChangedEvent()
         {
-            ProjectCollection collection = new ProjectCollection();
-            ProjectRootElement pre = null;
+            var collection = new ProjectCollection();
             Project project = null;
             bool dirtyRaised = false;
             collection.ProjectChanged +=
@@ -1389,7 +1385,7 @@ public void ProjectChangedEvent()
                 };
             Assert.False(dirtyRaised);
 
-            pre = ProjectRootElement.Create(collection);
+            ProjectRootElement pre = ProjectRootElement.Create(collection);
             project = new Project(pre, null, null, collection);
 
             // all these should still pass with disableMarkDirty set
@@ -1457,7 +1453,7 @@ private static string CreateProjectFile()
         /// <summary>
         /// Create an XmlReader around an empty project file content
         /// </summary>
-        private XmlReader CreateProjectXmlReader()
+        private static XmlReader CreateProjectXmlReader()
         {
             ProjectRootElement xml = ProjectRootElement.Create();
             XmlReader reader = XmlReader.Create(new StringReader(xml.RawXml));
@@ -1467,7 +1463,7 @@ private XmlReader CreateProjectXmlReader()
         /// <summary>
         /// Verify that when a property is set on the project collection that the correct events are fired.
         /// </summary>
-        private void VerifyProjectCollectionEvents(ProjectCollection collection, bool expectEventRaised, string propertyValue)
+        private static void VerifyProjectCollectionEvents(ProjectCollection collection, bool expectEventRaised, string propertyValue)
         {
             bool raisedEvent = false;
             ProjectCollectionChangedState expectedChange = ProjectCollectionChangedState.Loggers;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index e2c1bd4a2d9..eac4bf5351c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -2,11 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
 using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
-using System.Text.RegularExpressions;
 
 using Microsoft.Build.Collections;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
@@ -79,7 +75,7 @@ internal static class BatchingEngine
         /// Determines how many times the batchable object needs to be executed (each execution is termed a "batch"), and prepares
         /// buckets of items to pass to the object in each batch.
         /// </summary>
-        /// <returns>ArrayList containing ItemBucket objects, each one representing an execution batch.</returns>
+        /// <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
         internal static List<ItemBucket> PrepareBatchingBuckets
         (
             List<string> batchableObjectParameters,
@@ -99,7 +95,7 @@ ElementLocation elementLocation
         /// <param name="lookup"></param>
         /// <param name="implicitBatchableItemType">Any item type that can be considered an implicit input to this batchable object.
         /// This is useful for items inside targets, where the item name is plainly an item type that's an "input" to the object.</param>
-        /// <returns>ArrayList containing ItemBucket objects, each one representing an execution batch.</returns>
+        /// <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
         internal static List<ItemBucket> PrepareBatchingBuckets
         (
             List<string> batchableObjectParameters,
@@ -213,7 +209,7 @@ ElementLocation elementLocation
         {
             // The keys in this hashtable are the names of the items that we will batch on.
             // The values are always String.Empty (not used).
-            Dictionary<string, ICollection<ProjectItemInstance>> itemListsToBeBatched = new Dictionary<string, ICollection<ProjectItemInstance>>(MSBuildNameIgnoreCaseComparer.Default);
+            var itemListsToBeBatched = new Dictionary<string, ICollection<ProjectItemInstance>>(MSBuildNameIgnoreCaseComparer.Default);
 
             // Loop through all the metadata references and find the ones that are qualified
             // with an item name.
@@ -297,7 +293,7 @@ ElementLocation elementLocation
         /// from the array and metadata operations that are performed. However, those operations are extremely cheap compared
         /// to the comparison operations, which dominate the time spent in this method.
         /// </remarks>
-        /// <returns>ArrayList containing ItemBucket objects (can be empty), each one representing an execution batch.</returns>
+        /// <returns>List containing ItemBucket objects (can be empty), each one representing an execution batch.</returns>
         private static List<ItemBucket> BucketConsumedItems
         (
             Lookup lookup,
@@ -309,19 +305,15 @@ ElementLocation elementLocation
             ErrorUtilities.VerifyThrow(itemListsToBeBatched.Count > 0, "Need item types consumed by the batchable object.");
             ErrorUtilities.VerifyThrow(consumedMetadataReferences.Count > 0, "Need item metadata consumed by the batchable object.");
 
-            List<ItemBucket> buckets = new List<ItemBucket>();
+            var buckets = new List<ItemBucket>();
 
             // Get and iterate through the list of item names that we're supposed to batch on.
             foreach (KeyValuePair<string, ICollection<ProjectItemInstance>> entry in itemListsToBeBatched)
             {
-                string itemName = (string)entry.Key;
+                string itemName = entry.Key;
 
                 // Use the previously-fetched items, if possible
-                ICollection<ProjectItemInstance> items = entry.Value;
-                if (items == null)
-                {
-                    items = lookup.GetItems(itemName);
-                }
+                ICollection<ProjectItemInstance> items = entry.Value ?? lookup.GetItems(itemName);
 
                 if (items != null)
                 {
@@ -338,7 +330,7 @@ ElementLocation elementLocation
                         int matchingBucketIndex = buckets.BinarySearch(dummyBucket);
 
                         ItemBucket matchingBucket = (matchingBucketIndex >= 0)
-                            ? (ItemBucket)buckets[matchingBucketIndex]
+                            ? buckets[matchingBucketIndex]
                             : null;
 
                         // If we didn't find a bucket that matches this item, create a new one, adding
@@ -351,7 +343,7 @@ ElementLocation elementLocation
                             // in the sorted list as indicated by the binary search
                             // NOTE: observe the ~ operator (bitwise complement) in front of
                             // the index -- see MSDN for more information on the return value
-                            // from the ArrayList.BinarySearch() method
+                            // from the List.BinarySearch() method
                             buckets.Insert(~matchingBucketIndex, matchingBucket);
                         }
 
@@ -364,7 +356,7 @@ ElementLocation elementLocation
 
             // Put the buckets back in the order in which they were discovered, so that the first
             // item declared in the project file ends up in the first batch passed into the target/task.
-            List<ItemBucket> orderedBuckets = new List<ItemBucket>(buckets.Count);
+            var orderedBuckets = new List<ItemBucket>(buckets.Count);
             for (int i = 0; i < buckets.Count; ++i)
             {
                 orderedBuckets.Add(null);
@@ -393,7 +385,7 @@ private static Dictionary<string, string> GetItemMetadataValues
             ElementLocation elementLocation
         )
         {
-            Dictionary<string, string> itemMetadataValues = new Dictionary<string, string>(consumedMetadataReferences.Count, MSBuildNameIgnoreCaseComparer.Default);
+            var itemMetadataValues = new Dictionary<string, string>(consumedMetadataReferences.Count, MSBuildNameIgnoreCaseComparer.Default);
 
             foreach (KeyValuePair<string, MetadataReference> consumedMetadataReference in consumedMetadataReferences)
             {
diff --git a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
index 0ae715f2007..919da543bea 100644
--- a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
@@ -59,10 +59,7 @@ ProjectInstance ProjectInstance
         /// <summary>
         /// Flag to determine whether or not to log task inputs.
         /// </summary>
-        bool LogTaskInputs
-        {
-            get;
-        }
+        bool LogTaskInputs { get; }
 
         /// <summary>
         /// Initialize the host with the objects required to communicate with the host process.
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 8c12af6fb83..f9e41462901 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -8,8 +8,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Diagnostics;
 using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
@@ -48,12 +46,6 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         /// </summary>
         private const int CancelWarningWaitInterval = 15000;
 
-        /// <summary>
-        /// Whether to log task input parameters.  Can either be set through an environment variable 
-        /// or by the BuildParameters.
-        /// </summary>
-        private bool _logTaskInputs;
-
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// Resolver to assist in resolving types when a new appdomain is created
@@ -110,23 +102,6 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         /// </summary>
         private ItemBucket _batchBucket;
 
-        // Items used to execute the task
-
-        /// <summary>
-        /// The task type retrieved from the assembly.
-        /// </summary>
-        private TaskFactoryWrapper _taskFactoryWrapper;
-
-        /// <summary>
-        /// The instantiated task class.
-        /// </summary>
-        private ITask _taskInstance;
-
-        /// <summary>
-        /// The continueOnError flag
-        /// </summary>
-        private bool _continueOnError;
-
         /// <summary>
         /// Set to true if the execution has been cancelled.
         /// </summary>
@@ -135,7 +110,7 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         /// <summary>
         /// Event which is signalled when a task is not executing.  Used for cancellation.
         /// </summary>
-        private ManualResetEvent _taskExecutionIdle = new ManualResetEvent(true);
+        private readonly ManualResetEvent _taskExecutionIdle = new ManualResetEvent(true);
 
         /// <summary>
         /// The task items that we remoted across the appdomain boundary
@@ -147,12 +122,12 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         /// We need access to the build component host so that we can get at the 
         /// task host node provider when running a task wrapped by TaskHostTask
         /// </summary>
-        private IBuildComponentHost _buildComponentHost;
+        private readonly IBuildComponentHost _buildComponentHost;
 
         /// <summary>
         /// The set of intrinsic tasks mapped for this process.
         /// </summary>
-        private Dictionary<string, TaskFactoryWrapper> _intrinsicTasks = new Dictionary<string, TaskFactoryWrapper>(StringComparer.OrdinalIgnoreCase);
+        private readonly Dictionary<string, TaskFactoryWrapper> _intrinsicTasks = new Dictionary<string, TaskFactoryWrapper>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Constructor
@@ -160,15 +135,15 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         internal TaskExecutionHost(IBuildComponentHost host)
         {
             _buildComponentHost = host;
-            if (host != null && host.BuildParameters != null)
+            if (host?.BuildParameters != null)
             {
-                _logTaskInputs = host.BuildParameters.LogTaskInputs;
+                LogTaskInputs = host.BuildParameters.LogTaskInputs;
             }
 
             // If this is false, check the environment variable to see if it's there:
-            if (!_logTaskInputs)
+            if (!LogTaskInputs)
             {
-                _logTaskInputs = (Environment.GetEnvironmentVariable("MSBUILDLOGTASKINPUTS") == "1");
+                LogTaskInputs = (Environment.GetEnvironmentVariable("MSBUILDLOGTASKINPUTS") == "1");
             }
         }
 
@@ -192,71 +167,34 @@ internal TaskExecutionHost()
         /// <summary>
         /// Flag to determine whether or not to log task inputs.
         /// </summary>
-        public bool LogTaskInputs
-        {
-            get
-            {
-                return _logTaskInputs;
-            }
-        }
+        public bool LogTaskInputs { get; }
 
         /// <summary>
         /// The associated project.
         /// </summary>
-        ProjectInstance ITaskExecutionHost.ProjectInstance
-        {
-            get
-            {
-                return _projectInstance;
-            }
-        }
+        ProjectInstance ITaskExecutionHost.ProjectInstance => _projectInstance;
 
         /// <summary>
         /// Gets the task instance
         /// </summary>
-        internal ITask TaskInstance
-        {
-            get
-            {
-                return _taskInstance;
-            }
-        }
+        internal ITask TaskInstance { get; private set; }
 
         /// <summary>
         /// FOR UNIT TESTING ONLY
         /// </summary>
-        internal TaskFactoryWrapper _UNITTESTONLY_TaskFactoryWrapper
-        {
-            get
-            {
-                return _taskFactoryWrapper;
-            }
-
-            set
-            {
-                _taskFactoryWrapper = value;
-            }
-        }
+        internal TaskFactoryWrapper _UNITTESTONLY_TaskFactoryWrapper { get; set; }
 
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// App domain configuration.
         /// </summary>
-        internal AppDomainSetup AppDomainSetup
-        {
-            get;
-            set;
-        }
+        internal AppDomainSetup AppDomainSetup { get; set; }
 #endif
 
         /// <summary>
         /// Whether or not this is out-of-proc.
         /// </summary>
-        internal bool IsOutOfProc
-        {
-            get;
-            set;
-        }
+        internal bool IsOutOfProc { get; set; }
 
         /// <summary>
         /// Implementation of IDisposable
@@ -283,14 +221,13 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
             _targetLoggingContext = loggingContext;
             _taskName = taskName;
             _taskLocation = taskLocation;
-            _cancellationTokenRegistration = cancellationToken.Register(this.Cancel);
+            _cancellationTokenRegistration = cancellationToken.Register(Cancel);
             _taskHost = taskHost;
-            _continueOnError = continueOnError;
             _taskExecutionIdle.Set();
 #if FEATURE_APPDOMAIN
-            this.AppDomainSetup = appDomainSetup;
+            AppDomainSetup = appDomainSetup;
 #endif
-            this.IsOutOfProc = isOutOfProc;
+            IsOutOfProc = isOutOfProc;
         }
 
         /// <summary>
@@ -299,24 +236,24 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
         /// <returns>True if the task is found in the task registry false if otherwise.</returns>
         TaskRequirements? ITaskExecutionHost.FindTask(IDictionary<string, string> taskIdentityParameters)
         {
-            if (_taskFactoryWrapper == null)
+            if (_UNITTESTONLY_TaskFactoryWrapper == null)
             {
-                _taskFactoryWrapper = FindTaskInRegistry(taskIdentityParameters);
+                _UNITTESTONLY_TaskFactoryWrapper = FindTaskInRegistry(taskIdentityParameters);
             }
 
-            if (_taskFactoryWrapper == null)
+            if (_UNITTESTONLY_TaskFactoryWrapper == null)
             {
                 return null;
             }
 
             TaskRequirements requirements = TaskRequirements.None;
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
+            if (_UNITTESTONLY_TaskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
             {
                 requirements = requirements | TaskRequirements.RequireSTAThread;
             }
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
+            if (_UNITTESTONLY_TaskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
             {
                 requirements = requirements | TaskRequirements.RequireSeparateAppDomain;
 
@@ -333,13 +270,13 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
         /// </summary>
         bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary<string, string> taskIdentityParameters)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "loggingContext");
-            ErrorUtilities.VerifyThrowArgumentNull(batchBucket, "batchBucket");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowArgumentNull(batchBucket, nameof(batchBucket));
 
             _taskLoggingContext = loggingContext;
             _batchBucket = batchBucket;
 
-            if (_taskFactoryWrapper == null)
+            if (_UNITTESTONLY_TaskFactoryWrapper == null)
             {
                 return false;
             }
@@ -353,21 +290,21 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
             if (null == _resolver)
             {
                 _resolver = new TaskEngineAssemblyResolver();
-                _resolver.Initialize(_taskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
+                _resolver.Initialize(_UNITTESTONLY_TaskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
                 _resolver.InstallHandler();
             }
 #endif
 
             // We instantiate a new task object for each batch
-            _taskInstance = InstantiateTask(taskIdentityParameters);
+            TaskInstance = InstantiateTask(taskIdentityParameters);
 
-            if (_taskInstance == null)
+            if (TaskInstance == null)
             {
                 return false;
             }
 
-            _taskInstance.BuildEngine = _buildEngine;
-            _taskInstance.HostObject = _taskHost;
+            TaskInstance.BuildEngine = _buildEngine;
+            TaskInstance.HostObject = _taskHost;
 
             return true;
         }
@@ -379,20 +316,20 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
         /// <returns>True if the parameters were set correctly, false otherwise.</returns>
         bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, Tuple<string, ElementLocation>> parameters)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameters, "parameters");
+            ErrorUtilities.VerifyThrowArgumentNull(parameters, nameof(parameters));
 
             bool taskInitialized = true;
 
             // Get the properties that exist on this task.  We need to gather all of the ones that are marked
             // "required" so that we can keep track of whether or not they all get set.
-            Dictionary<string, string> setParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            var setParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
             IDictionary<string, string> requiredParameters = GetNamesOfPropertiesWithRequiredAttribute();
 
             // look through all the attributes of the task element
             foreach (KeyValuePair<string, Tuple<string, ElementLocation>> parameter in parameters)
             {
                 bool taskParameterSet = false;  // Did we actually call the setter on this task parameter?
-                bool success = false;
+                bool success;
 
                 try
                 {
@@ -452,13 +389,13 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, Tuple<string, Elem
         /// <returns>True of the outputs were gathered successfully, false otherwise.</returns>
         bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName)
         {
-            ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Need a taskFactoryWrapper to retrieve outputs from.");
+            ErrorUtilities.VerifyThrow(_UNITTESTONLY_TaskFactoryWrapper != null, "Need a taskFactoryWrapper to retrieve outputs from.");
 
             bool gatheredGeneratedOutputsSuccessfully = true;
 
             try
             {
-                TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                TaskPropertyInfo parameter = _UNITTESTONLY_TaskFactoryWrapper.GetProperty(parameterName);
 
                 // flag an error if we find a parameter that has no .NET property equivalent
                 ProjectErrorUtilities.VerifyThrowInvalidProject
@@ -473,7 +410,7 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                 // output parameters must have their corresponding .NET properties marked with the Output attribute
                 ProjectErrorUtilities.VerifyThrowInvalidProject
                 (
-                    _taskFactoryWrapper.GetNamesOfPropertiesWithOutputAttribute.ContainsKey(parameterName),
+                    _UNITTESTONLY_TaskFactoryWrapper.GetNamesOfPropertiesWithOutputAttribute.ContainsKey(parameterName),
                     parameterLocation,
                     "UnmarkedOutputTaskParameter",
                     parameter.Name,
@@ -485,13 +422,13 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
 
                 if (TaskParameterTypeVerifier.IsAssignableToITask(type))
                 {
-                    ITaskItem[] outputs = GetItemOutputs(parameter, parameterLocation);
+                    ITaskItem[] outputs = GetItemOutputs(parameter);
                     GatherTaskItemOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation);
                 }
                 else if (TaskParameterTypeVerifier.IsValueTypeOutputParameter(type))
                 {
-                    string[] outputs = GetValueOutputs(parameter, parameterLocation);
-                    GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, parameter, outputs, parameterLocation);
+                    string[] outputs = GetValueOutputs(parameter);
+                    GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation);
                 }
                 else
                 {
@@ -542,7 +479,7 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                     "FailedToRetrieveTaskOutputs",
                     _taskName,
                     parameterName,
-                    e.InnerException.Message
+                    e.InnerException?.Message
                 );
             }
             catch (Exception e)
@@ -574,14 +511,14 @@ void ITaskExecutionHost.CleanupForBatch()
         {
             try
             {
-                if (_taskFactoryWrapper != null && _taskInstance != null)
+                if (_UNITTESTONLY_TaskFactoryWrapper != null && TaskInstance != null)
                 {
-                    _taskFactoryWrapper.TaskFactory.CleanupTask(_taskInstance);
+                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.CleanupTask(TaskInstance);
                 }
             }
             finally
             {
-                _taskInstance = null;
+                TaskInstance = null;
             }
         }
 
@@ -598,14 +535,14 @@ void ITaskExecutionHost.CleanupForTask()
             }
 #endif
 
-            _taskFactoryWrapper = null;
+            _UNITTESTONLY_TaskFactoryWrapper = null;
 
             // We must null this out because it could be a COM object (or any other ref-counted object) which needs to
             // be released.
             _taskHost = null;
             CleanupCancellationToken();
 
-            ErrorUtilities.VerifyThrow(_taskInstance == null, "Task Instance should be null");
+            ErrorUtilities.VerifyThrow(TaskInstance == null, "Task Instance should be null");
         }
 
         /// <summary>
@@ -628,7 +565,7 @@ bool ITaskExecutionHost.Execute()
 
             try
             {
-                taskReturnValue = _taskInstance.Execute();
+                taskReturnValue = TaskInstance.Execute();
             }
             finally
             {
@@ -684,7 +621,7 @@ private void Cancel()
             // This will prevent the current and any future tasks from running on this TaskExecutionHost, because we don't reset the cancelled flag.
             _cancelled = true;
 
-            ITask currentInstance = _taskInstance;
+            ITask currentInstance = TaskInstance;
             ICancelableTask cancellableTask = null;
             if (currentInstance != null)
             {
@@ -750,7 +687,7 @@ private void Cancel()
         /// <summary>
         /// Called on the local side.
         /// </summary>
-        private bool SetTaskItemParameter(TaskPropertyInfo parameter, ITaskItem item, ElementLocation parameterLocation)
+        private bool SetTaskItemParameter(TaskPropertyInfo parameter, ITaskItem item)
         {
             return InternalSetTaskParameter(parameter, item);
         }
@@ -758,7 +695,7 @@ private bool SetTaskItemParameter(TaskPropertyInfo parameter, ITaskItem item, El
         /// <summary>
         /// Called on the local side.
         /// </summary>
-        private bool SetValueParameter(TaskPropertyInfo parameter, Type parameterType, string expandedParameterValue, ElementLocation parameterLocation)
+        private bool SetValueParameter(TaskPropertyInfo parameter, Type parameterType, string expandedParameterValue)
         {
             if (parameterType == typeof(bool))
             {
@@ -849,24 +786,20 @@ ex is FormatException || // bad string representation of a type
         /// </summary>
         private void RecordItemForDisconnectIfNecessary(TaskItem item)
         {
-            if (_remotedTaskItems != null)
-            {
-                // remember that we need to disconnect this item
-                _remotedTaskItems.Add(item);
-            }
+            // remember that we need to disconnect this item
+            _remotedTaskItems?.Add(item);
         }
 
         /// <summary>
         /// Gets the outputs (as an array of ITaskItem) from the specified output parameter.
         /// </summary>
-        private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter, ElementLocation parameterLocation)
+        private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter)
         {
-            object outputs = _taskFactoryWrapper.GetPropertyValue(_taskInstance, parameter);
+            object outputs = _UNITTESTONLY_TaskFactoryWrapper.GetPropertyValue(TaskInstance, parameter);
 
-            ITaskItem[] taskItemOutputs = outputs as ITaskItem[];
-            if (null == taskItemOutputs)
+            if (!(outputs is ITaskItem[] taskItemOutputs))
             {
-                taskItemOutputs = new ITaskItem[] { (ITaskItem)outputs };
+                taskItemOutputs = new[] { (ITaskItem)outputs };
             }
 
             return taskItemOutputs;
@@ -875,18 +808,18 @@ private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter, ElementLocation p
         /// <summary>
         /// Gets the outputs (as an array of string values) from the specified output parameter.
         /// </summary>
-        private string[] GetValueOutputs(TaskPropertyInfo parameter, ElementLocation parameterLocation)
+        private string[] GetValueOutputs(TaskPropertyInfo parameter)
         {
-            object outputs = _taskFactoryWrapper.GetPropertyValue(_taskInstance, parameter);
+            object outputs = _UNITTESTONLY_TaskFactoryWrapper.GetPropertyValue(TaskInstance, parameter);
 
-            Array convertibleOutputs = parameter.PropertyType.IsArray ? (Array)outputs : new object[] { outputs };
+            Array convertibleOutputs = parameter.PropertyType.IsArray ? (Array)outputs : new[] { outputs };
 
             if (convertibleOutputs == null)
             {
                 return null;
             }
 
-            string[] stringOutputs = new string[convertibleOutputs.Length];
+            var stringOutputs = new string[convertibleOutputs.Length];
             for (int i = 0; i < convertibleOutputs.Length; i++)
             {
                 object output = convertibleOutputs.GetValue(i);
@@ -920,8 +853,7 @@ private string[] GetValueOutputs(TaskPropertyInfo parameter, ElementLocation par
         /// <returns>The Type of the task, or null if it was not found.</returns>
         private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskIdentityParameters)
         {
-            TaskFactoryWrapper returnClass;
-            if (!_intrinsicTasks.TryGetValue(_taskName, out returnClass))
+            if (!_intrinsicTasks.TryGetValue(_taskName, out TaskFactoryWrapper returnClass))
             {
                 returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, taskIdentityParameters, true /* exact match */, _targetLoggingContext, _taskLocation);
                 if (null == returnClass)
@@ -946,14 +878,12 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
                                         _projectInstance.TaskRegistry.Toolset.ToolsPath
                                     );
 
-                                return returnClass;
+                                return null;
                             }
                         }
 
                         string usingTaskRuntime = null;
                         string usingTaskArchitecture = null;
-                        string taskRuntime = null;
-                        string taskArchitecture = null;
 
                         if (returnClass.FactoryIdentityParameters != null)
                         {
@@ -961,8 +891,8 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
                             returnClass.FactoryIdentityParameters.TryGetValue(XMakeAttributes.architecture, out usingTaskArchitecture);
                         }
 
-                        taskIdentityParameters.TryGetValue(XMakeAttributes.runtime, out taskRuntime);
-                        taskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out taskArchitecture);
+                        taskIdentityParameters.TryGetValue(XMakeAttributes.runtime, out string taskRuntime);
+                        taskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out string taskArchitecture);
 
                         _targetLoggingContext.LogError
                             (
@@ -1005,25 +935,23 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
 
             try
             {
-                AssemblyTaskFactory assemblyTaskFactory = _taskFactoryWrapper.TaskFactory as AssemblyTaskFactory;
-                if (assemblyTaskFactory != null)
+                if (_UNITTESTONLY_TaskFactoryWrapper.TaskFactory is AssemblyTaskFactory assemblyTaskFactory)
                 {
                     task = assemblyTaskFactory.CreateTaskInstance(_taskLocation, _taskLoggingContext, _buildComponentHost, taskIdentityParameters,
 #if FEATURE_APPDOMAIN
-                        this.AppDomainSetup,
+                        AppDomainSetup,
 #endif
-                        this.IsOutOfProc);
+                        IsOutOfProc);
                 }
                 else
                 {
                     TaskFactoryLoggingHost loggingHost = new TaskFactoryLoggingHost(_buildEngine.IsRunningMultipleNodes, _taskLocation, _taskLoggingContext);
+                    ITaskFactory2 taskFactory2 = _UNITTESTONLY_TaskFactoryWrapper.TaskFactory as ITaskFactory2;
                     try
                     {
-                        ITaskFactory2 taskFactory2 = _taskFactoryWrapper.TaskFactory as ITaskFactory2;
-
                         if (taskFactory2 == null)
                         {
-                            task = _taskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
+                            task = _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
                         }
                         else
                         {
@@ -1045,7 +973,7 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                     new BuildEventFileInfo(_taskLocation),
                     "TaskInstantiationFailureErrorInvalidCast",
                     _taskName,
-                    _taskFactoryWrapper.TaskFactory.FactoryName,
+                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.FactoryName,
                     e.Message
                 );
             }
@@ -1058,8 +986,8 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                     new BuildEventFileInfo(_taskLocation),
                     "TaskInstantiationFailureError",
                     _taskName,
-                    _taskFactoryWrapper.TaskFactory.FactoryName,
-                    Environment.NewLine + e.InnerException.ToString()
+                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.FactoryName,
+                    Environment.NewLine + e.InnerException
                 );
             }
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
@@ -1075,7 +1003,7 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                     new BuildEventFileInfo(_taskLocation),
                     "TaskInstantiationFailureError",
                     _taskName,
-                    _taskFactoryWrapper.TaskFactory.FactoryName,
+                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.FactoryName,
                     e.Message
                 );
             }
@@ -1101,7 +1029,7 @@ out bool parameterSet
             try
             {
                 // check if the task has a .NET property corresponding to the parameter
-                TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                TaskPropertyInfo parameter = _UNITTESTONLY_TaskFactoryWrapper.GetProperty(parameterName);
 
                 if (parameter != null)
                 {
@@ -1206,7 +1134,7 @@ out bool taskParameterSet
         {
             taskParameterSet = false;
 
-            bool success = false;
+            bool success;
 
             try
             {
@@ -1242,7 +1170,7 @@ out bool taskParameterSet
 
                         RecordItemForDisconnectIfNecessary(finalTaskItems[0]);
 
-                        success = SetTaskItemParameter(parameter, finalTaskItems[0], parameterLocation);
+                        success = SetTaskItemParameter(parameter, finalTaskItems[0]);
 
                         taskParameterSet = true;
                     }
@@ -1258,7 +1186,7 @@ out bool taskParameterSet
                     }
                     else
                     {
-                        success = SetValueParameter(parameter, parameterType, expandedParameterValue, parameterLocation);
+                        success = SetValueParameter(parameter, parameterType, expandedParameterValue);
                         taskParameterSet = true;
                     }
                 }
@@ -1317,7 +1245,7 @@ out bool taskParameterSet
             ErrorUtilities.VerifyThrow(parameterValue != null, "Didn't expect null parameterValue in InitializeTaskVectorParameter");
 
             taskParameterSet = false;
-            bool success = false;
+            bool success;
             IList<TaskItem> finalTaskItems = _batchBucket.Expander.ExpandIntoTaskItemsLeaveEscaped(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
             // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required 
@@ -1348,7 +1276,7 @@ out bool taskParameterSet
         /// </remarks>
         private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList parameterValue)
         {
-            if (_logTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && parameterValue.Count > 0)
+            if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && parameterValue.Count > 0)
             {
                 string parameterText = ResourceUtilities.GetResourceString("TaskParameterPrefix");
                 parameterText = ItemGroupLoggingHelper.GetParameterText(parameterText, parameter.Name, parameterValue);
@@ -1370,7 +1298,7 @@ object parameterValue
             bool success = false;
 
             // Logging currently enabled only by an env var.
-            if (_logTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
+            if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
             {
                 // If the type is a list, we already logged the parameters
                 if (!(parameterValue is IList))
@@ -1383,7 +1311,7 @@ object parameterValue
 
             try
             {
-                _taskFactoryWrapper.SetPropertyValue(_taskInstance, parameter, parameterValue);
+                _UNITTESTONLY_TaskFactoryWrapper.SetPropertyValue(TaskInstance, parameter, parameterValue);
                 success = true;
             }
             catch (LoggerException)
@@ -1447,7 +1375,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         {
                             ProjectItemInstance newItem;
 
-                            ProjectItemInstance.TaskItem outputAsProjectItem = output as ProjectItemInstance.TaskItem;
+                            TaskItem outputAsProjectItem = output as TaskItem;
                             string parameterLocationEscaped = EscapingUtilities.EscapeWithCaching(parameterLocation.File);
 
                             if (outputAsProjectItem != null)
@@ -1460,9 +1388,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                             }
                             else
                             {
-                                ITaskItem2 outputAsITaskItem2 = output as ITaskItem2;
-
-                                if (outputAsITaskItem2 != null)
+                                if (output is ITaskItem2 outputAsITaskItem2)
                                 {
                                     // Probably a Microsoft.Build.Utilities.TaskItem.  Not quite as good, but we can still preserve escaping. 
                                     newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsITaskItem2.EvaluatedIncludeEscaped, parameterLocationEscaped);
@@ -1490,7 +1416,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         }
                     }
 
-                    if (_logTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
+                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
                     {
                         string parameterText = ItemGroupLoggingHelper.GetParameterText(
                             ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix"),
@@ -1520,9 +1446,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                                 joinedOutputs.Append(';');
                             }
 
-                            ITaskItem2 outputAsITaskItem2 = output as ITaskItem2;
-
-                            if (outputAsITaskItem2 != null)
+                            if (output is ITaskItem2 outputAsITaskItem2)
                             {
                                 joinedOutputs.Append(outputAsITaskItem2.EvaluatedIncludeEscaped);
                             }
@@ -1536,7 +1460,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                     if (joinedOutputs != null)
                     {
                         var outputString = joinedOutputs.ToString();
-                        if (_logTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
+                        if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
                             _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
                         }
@@ -1550,7 +1474,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
         /// <summary>
         /// Gather task outputs in array form
         /// </summary>
-        private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, TaskPropertyInfo parameter, string[] outputs, ElementLocation parameterLocation)
+        private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, string[] outputs, ElementLocation parameterLocation)
         {
             // if the task has generated outputs (if it didn't, don't do anything)            
             if (outputs != null)
@@ -1561,17 +1485,14 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                     foreach (string output in outputs)
                     {
                         // if individual outputs in the array are null, ignore them
-                        if (output != null)
+                        // attempting to put an empty string into an item is a no-op.
+                        if (output?.Length > 0)
                         {
-                            // attempting to put an empty string into an item is a no-op.
-                            if (output.Length > 0)
-                            {
-                                _batchBucket.Lookup.AddNewItem(new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output), EscapingUtilities.Escape(parameterLocation.File)));
-                            }
+                            _batchBucket.Lookup.AddNewItem(new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output), EscapingUtilities.Escape(parameterLocation.File)));
                         }
                     }
 
-                    if (_logTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
+                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0)
                     {
                         string parameterText = ItemGroupLoggingHelper.GetParameterText(ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix"), outputTargetName, outputs);
                         _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
@@ -1604,7 +1525,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                     if (joinedOutputs != null)
                     {
                         var outputString = joinedOutputs.ToString();
-                        if (_logTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
+                        if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
                             _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
                         }
@@ -1622,12 +1543,12 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
         /// <returns>Gets a list of properties which are required.</returns>
         private IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
         {
-            ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Expected taskFactoryWrapper to not be null");
+            ErrorUtilities.VerifyThrow(_UNITTESTONLY_TaskFactoryWrapper != null, "Expected taskFactoryWrapper to not be null");
             IDictionary<string, string> requiredParameters = null;
 
             try
             {
-                requiredParameters = _taskFactoryWrapper.GetNamesOfPropertiesWithRequiredAttribute;
+                requiredParameters = _UNITTESTONLY_TaskFactoryWrapper.GetNamesOfPropertiesWithRequiredAttribute;
             }
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
@@ -1650,9 +1571,7 @@ private IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
         /// </summary>
         private void DisplayCancelWaitMessage()
         {
-            string warningCode;
-            string helpKeyword;
-            string message = ResourceUtilities.FormatResourceString(out warningCode, out helpKeyword, "UnableToCancelTask", _taskName);
+            string message = ResourceUtilities.FormatResourceString(out string warningCode, out string helpKeyword, "UnableToCancelTask", _taskName);
             try
             {
                 _taskLoggingContext.LogWarningFromText(null, warningCode, helpKeyword, new BuildEventFileInfo(_taskLocation), message);
diff --git a/src/Build/Collections/ConcurrentQueueExtensions.cs b/src/Build/Collections/ConcurrentQueueExtensions.cs
index 3738c064367..4d5eae6d724 100644
--- a/src/Build/Collections/ConcurrentQueueExtensions.cs
+++ b/src/Build/Collections/ConcurrentQueueExtensions.cs
@@ -5,7 +5,6 @@
 // <summary>Extension methods for the ConcurrentQueue.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Concurrent;
 using Microsoft.Build.Shared;
 
@@ -20,11 +19,10 @@ internal static class ConcurrentQueueExtensions
         /// The dequeue method.
         /// </summary>
         /// <typeparam name="T">The type contained within the queue</typeparam>
-        static public T Dequeue<T>(this ConcurrentQueue<T> stack) where T : class
+        public static T Dequeue<T>(this ConcurrentQueue<T> stack) where T : class
         {
-            T result = null;
-            ErrorUtilities.VerifyThrow(stack.TryDequeue(out result), "Unable to dequeue from queue");
+            ErrorUtilities.VerifyThrow(stack.TryDequeue(out T result), "Unable to dequeue from queue");
             return result;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Collections/ConcurrentStackExtensions.cs b/src/Build/Collections/ConcurrentStackExtensions.cs
index de5842219f8..40c687107e4 100644
--- a/src/Build/Collections/ConcurrentStackExtensions.cs
+++ b/src/Build/Collections/ConcurrentStackExtensions.cs
@@ -5,7 +5,6 @@
 // <summary>Extension methods for the ConcurrentStack.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Concurrent;
 using Microsoft.Build.Shared;
 
@@ -20,10 +19,9 @@ internal static class ConcurrentStackExtensions
         /// The peek method.
         /// </summary>
         /// <typeparam name="T">The type contained within the stack.</typeparam>
-        static public T Peek<T>(this ConcurrentStack<T> stack) where T : class
+        public static T Peek<T>(this ConcurrentStack<T> stack) where T : class
         {
-            T result = null;
-            ErrorUtilities.VerifyThrow(stack.TryPeek(out result), "Unable to peek from stack");
+            ErrorUtilities.VerifyThrow(stack.TryPeek(out T result), "Unable to peek from stack");
             return result;
         }
 
@@ -31,10 +29,9 @@ static public T Peek<T>(this ConcurrentStack<T> stack) where T : class
         /// The pop method.
         /// </summary>
         /// <typeparam name="T">The type contained within the stack.</typeparam>
-        static public T Pop<T>(this ConcurrentStack<T> stack) where T : class
+        public static T Pop<T>(this ConcurrentStack<T> stack) where T : class
         {
-            T result = null;
-            ErrorUtilities.VerifyThrow(stack.TryPop(out result), "Unable to pop from stack");
+            ErrorUtilities.VerifyThrow(stack.TryPop(out T result), "Unable to pop from stack");
             return result;
         }
     }
diff --git a/src/Build/Collections/ConvertingEnumerable.cs b/src/Build/Collections/ConvertingEnumerable.cs
index 2333e2efa6e..10334963659 100644
--- a/src/Build/Collections/ConvertingEnumerable.cs
+++ b/src/Build/Collections/ConvertingEnumerable.cs
@@ -22,12 +22,12 @@ internal class ConvertingEnumerable<TFrom, TTo> : IEnumerable<TTo>
         /// <summary>
         /// Enumerable behind this one
         /// </summary>
-        private IEnumerable<TFrom> _backingEnumerable;
+        private readonly IEnumerable<TFrom> _backingEnumerable;
 
         /// <summary>
         /// Converter delegate used on each item in the backing enumerable as it is returned
         /// </summary>
-        private Func<TFrom, TTo> _converter;
+        private readonly Func<TFrom, TTo> _converter;
 
         /// <summary>
         /// Constructor
@@ -65,12 +65,12 @@ private struct ConvertingEnumerator<TFrom2, TTo2> : IEnumerator<TTo2>
             /// <summary>
             /// Enumerator behind this one
             /// </summary>
-            private IEnumerator<TFrom2> _backingEnumerator;
+            private readonly IEnumerator<TFrom2> _backingEnumerator;
 
             /// <summary>
             /// Converter delegate used on each item in the backing enumerator as it is returned
             /// </summary>
-            private Func<TFrom2, TTo2> _converter;
+            private readonly Func<TFrom2, TTo2> _converter;
 
             /// <summary>
             /// Constructor
@@ -97,13 +97,7 @@ public TTo2 Current
             /// <summary>
             /// Get the current element, converted
             /// </summary>
-            Object IEnumerator.Current
-            {
-                get
-                {
-                    return Current;
-                }
-            }
+            Object IEnumerator.Current => Current;
 
             /// <summary>
             /// Move to the next element
diff --git a/src/Build/Collections/CopyOnReadEnumerable.cs b/src/Build/Collections/CopyOnReadEnumerable.cs
index 498d0828305..393422ee8e4 100644
--- a/src/Build/Collections/CopyOnReadEnumerable.cs
+++ b/src/Build/Collections/CopyOnReadEnumerable.cs
@@ -25,12 +25,12 @@ internal class CopyOnReadEnumerable<T> : IEnumerable<T>
         /// <summary>
         /// The backing collection.
         /// </summary>
-        private IEnumerable<T> _backingEnumerable;
+        private readonly IEnumerable<T> _backingEnumerable;
 
         /// <summary>
         /// The object used to synchronize access for copying.
         /// </summary>
-        private object _syncRoot;
+        private readonly object _syncRoot;
 
         /// <summary>
         /// Constructor.
@@ -39,8 +39,8 @@ internal class CopyOnReadEnumerable<T> : IEnumerable<T>
         /// <param name="syncRoot">The object used to synchronize access for copying.</param>
         public CopyOnReadEnumerable(IEnumerable<T> backingEnumerable, object syncRoot)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(backingEnumerable, "backingCollection");
-            ErrorUtilities.VerifyThrowArgumentNull(syncRoot, "syncRoot");
+            ErrorUtilities.VerifyThrowArgumentNull(backingEnumerable, nameof(backingEnumerable));
+            ErrorUtilities.VerifyThrowArgumentNull(syncRoot, nameof(syncRoot));
 
             _backingEnumerable = backingEnumerable;
             _syncRoot = syncRoot;
@@ -55,8 +55,7 @@ public CopyOnReadEnumerable(IEnumerable<T> backingEnumerable, object syncRoot)
         public IEnumerator<T> GetEnumerator()
         {
             List<T> list;
-            ICollection backingCollection = _backingEnumerable as ICollection;
-            if (backingCollection != null)
+            if (_backingEnumerable is ICollection backingCollection)
             {
                 list = new List<T>(backingCollection.Count);
             }
@@ -97,7 +96,7 @@ public IEnumerator<T> GetEnumerator()
         /// Returns an numerator over the collection.
         /// </summary>
         /// <returns>The enumerator.</returns>
-        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+        IEnumerator IEnumerable.GetEnumerator()
         {
             return ((IEnumerable<T>)this).GetEnumerator();
         }
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 4d8519d5bf4..ad023f03269 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -8,12 +8,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Threading;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Collections
 {
@@ -86,13 +82,7 @@ private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         /// <summary>
         /// Accessor for the list of property names
         /// </summary>
-        ICollection<string> IDictionary<string, T>.Keys
-        {
-            get
-            {
-                return PropertyNames;
-            }
-        }
+        ICollection<string> IDictionary<string, T>.Keys => PropertyNames;
 
         /// <summary>
         /// Accessor for the list of properties
@@ -125,13 +115,7 @@ int ICollection<KeyValuePair<string, T>>.Count
         /// <summary>
         /// Whether the collection is read-only.
         /// </summary>
-        bool ICollection<KeyValuePair<string, T>>.IsReadOnly
-        {
-            get
-            {
-                return false;
-            }
-        }
+        bool ICollection<KeyValuePair<string, T>>.IsReadOnly => false;
 
         /// <summary>
         /// Returns the number of property in the collection.
@@ -173,15 +157,8 @@ internal ICollection<string> PropertyNames
         T IDictionary<string, T>.this[string name]
         {
             // The backing properties dictionary is locked in the indexor
-            get
-            {
-                return this[name];
-            }
-
-            set
-            {
-                this[name] = value;
-            }
+            get => this[name];
+            set => this[name] = value;
         }
 
         /// <summary>
@@ -283,7 +260,7 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
                 return false;
             }
 
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
@@ -373,10 +350,9 @@ void ICollection<KeyValuePair<string, T>>.Clear()
         /// </summary>
         bool ICollection<KeyValuePair<string, T>>.Contains(KeyValuePair<string, T> item)
         {
-            T value;
             lock (_properties)
             {
-                if (_properties.TryGetValue(item.Key, out value))
+                if (_properties.TryGetValue(item.Key, out T value))
                 {
                     return EqualityComparer<T>.Default.Equals(value, item.Value);
                 }
@@ -434,7 +410,7 @@ internal bool Remove(string name)
         /// </summary>
         internal bool Remove(string name, bool clearIfEmpty)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             lock (_properties)
             {
@@ -454,7 +430,7 @@ internal bool Remove(string name, bool clearIfEmpty)
         /// </summary>
         internal void Set(T projectProperty)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectProperty, "projectProperty");
+            ErrorUtilities.VerifyThrowArgumentNull(projectProperty, nameof(projectProperty));
 
             lock (_properties)
             {
@@ -493,7 +469,7 @@ internal void RemoveProperties(IEnumerable<T> other)
         /// </summary>
         internal IDictionary<string, string> ToDictionary()
         {
-            Dictionary<string, string> dictionary = null;
+            Dictionary<string, string> dictionary;
 
             lock (_properties)
             {
diff --git a/src/Build/Collections/HashTableUtility.cs b/src/Build/Collections/HashTableUtility.cs
index cafd2ab2eb1..7807b336c45 100644
--- a/src/Build/Collections/HashTableUtility.cs
+++ b/src/Build/Collections/HashTableUtility.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 
 namespace Microsoft.Build.Collections
 {
diff --git a/src/Build/Collections/IDeepCloneable.cs b/src/Build/Collections/IDeepCloneable.cs
index 8522b1f3a91..b60fd43a45e 100644
--- a/src/Build/Collections/IDeepCloneable.cs
+++ b/src/Build/Collections/IDeepCloneable.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Collections
     /// An interface representing an item which can clone itself.
     /// </summary>
     /// <typeparam name="T">The type returned by the clone operation.</typeparam>
-    internal interface IDeepCloneable<T>
+    internal interface IDeepCloneable<out T>
     {
         /// <summary>
         /// Creates a clone of the item where no data references are shared.  Changes made to the clone
diff --git a/src/Build/Collections/IValued.cs b/src/Build/Collections/IValued.cs
index ca1b8385710..7d25af0bf14 100644
--- a/src/Build/Collections/IValued.cs
+++ b/src/Build/Collections/IValued.cs
@@ -18,9 +18,6 @@ internal interface IValued
         /// <summary>
         /// Returns some value of a thing
         /// </summary>
-        string EscapedValue
-        {
-            get;
-        }
+        string EscapedValue { get; }
     }
 }
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index f395ea83f53..f385aee96ed 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -9,10 +9,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using ObjectModel = System.Collections.ObjectModel;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Collections
 {
@@ -86,10 +84,7 @@ internal ItemDictionary(IEnumerable<T> items)
         /// <summary>
         /// Number of items in total, for debugging purposes.
         /// </summary>
-        internal int Count
-        {
-            get { return _nodes.Count; }
-        }
+        internal int Count => _nodes.Count;
 
         /// <summary>
         /// Get the item types that have at least one item in this collection
@@ -165,7 +160,7 @@ public IEnumerable<T> GetCopyOnReadEnumerable()
         /// </summary>
         public IEnumerator<T> GetEnumerator()
         {
-            return new ItemDictionary<T>.Enumerator(_itemLists.Values);
+            return new Enumerator(_itemLists.Values);
         }
 
         /// <summary>
@@ -213,8 +208,7 @@ internal void Add(T projectItem)
         {
             lock (_itemLists)
             {
-                LinkedList<T> list;
-                if (!_itemLists.TryGetValue(projectItem.Key, out list))
+                if (!_itemLists.TryGetValue(projectItem.Key, out LinkedList<T> list))
                 {
                     list = new LinkedList<T>();
                     _itemLists[projectItem.Key] = list;
@@ -237,8 +231,7 @@ internal bool Remove(T projectItem)
         {
             lock (_itemLists)
             {
-                LinkedListNode<T> node;
-                if (!_nodes.TryGetValue(projectItem, out node))
+                if (!_nodes.TryGetValue(projectItem, out LinkedListNode<T> node))
                 {
                     return false;
                 }
@@ -269,8 +262,7 @@ internal void Replace(T existingItem, T newItem)
             ErrorUtilities.VerifyThrow(existingItem.Key == newItem.Key, "Cannot replace an item {0} with an item {1} with a different name.", existingItem.Key, newItem.Key);
             lock (_itemLists)
             {
-                LinkedListNode<T> node;
-                if (_nodes.TryGetValue(existingItem, out node))
+                if (_nodes.TryGetValue(existingItem, out LinkedListNode<T> node))
                 {
                     node.Value = newItem;
                     _nodes.Remove(existingItem);
@@ -301,8 +293,7 @@ internal void ImportItemsOfType(string itemType, IEnumerable<T> items)
         {
             lock (_itemLists)
             {
-                LinkedList<T> list;
-                if (!_itemLists.TryGetValue(itemType, out list))
+                if (!_itemLists.TryGetValue(itemType, out LinkedList<T> list))
                 {
                     list = new LinkedList<T>();
                     _itemLists[itemType] = list;
@@ -357,9 +348,7 @@ internal bool HasEmptyMarker(string itemType)
         {
             lock (_itemLists)
             {
-                LinkedList<T> list;
-
-                if (_itemLists.TryGetValue(itemType, out list) && list.Count == 0)
+                if (_itemLists.TryGetValue(itemType, out LinkedList<T> list) && list.Count == 0)
                 {
                     return true;
                 }
@@ -374,7 +363,7 @@ internal bool HasEmptyMarker(string itemType)
         /// All items of a type are returned consecutively in their correct order.
         /// However the order in which item types are returned is not defined.
         /// </summary>
-        private class Enumerator : IEnumerator<T>, IDisposable
+        private sealed class Enumerator : IEnumerator<T>, IDisposable
         {
             /// <summary>
             /// Enumerator over lists
@@ -407,32 +396,14 @@ internal Enumerator(IEnumerable<ICollection<T>> listEnumerable)
             /// <summary>
             /// Get the current item
             /// </summary>
-            public T Current
-            {
-                get
-                {
-                    // Undefined if enumerator is before or after collection: we return null
-                    return _itemEnumerator != null ? _itemEnumerator.Current : null;
-                }
-            }
+            public T Current => _itemEnumerator?.Current;
 
             /// <summary>
             /// Implementation of IEnumerator.Current, which unlike IEnumerator&gt;T&lt;.Current throws
             /// if there is no current object
             /// </summary>
-            object IEnumerator.Current
-            {
-                get
-                {
-                    if (_itemEnumerator != null)
-                    {
-                        return _itemEnumerator.Current;
-                    }
-
-                    // will throw InvalidOperationException, per IEnumerator contract
-                    return ((IEnumerator)_listEnumerator).Current;
-                }
-            }
+            // will throw InvalidOperationException, per IEnumerator contract
+            object IEnumerator.Current => _itemEnumerator != null ? _itemEnumerator.Current : ((IEnumerator)_listEnumerator).Current;
 
             /// <summary>
             /// Move to the next object if any,
@@ -463,11 +434,7 @@ public bool MoveNext()
             /// </summary>
             public void Reset()
             {
-                if (_itemEnumerator != null)
-                {
-                    _itemEnumerator.Reset();
-                }
-
+                _itemEnumerator?.Reset();
                 _listEnumerator.Reset();
             }
 
@@ -483,7 +450,7 @@ public void Dispose()
             /// <summary>
             /// The real disposer.
             /// </summary>
-            protected virtual void Dispose(bool disposing)
+            private void Dispose(bool disposing)
             {
                 if (disposing)
                 {
diff --git a/src/Build/Collections/LookasideStringInterner.cs b/src/Build/Collections/LookasideStringInterner.cs
index d78858f32ce..08864342152 100644
--- a/src/Build/Collections/LookasideStringInterner.cs
+++ b/src/Build/Collections/LookasideStringInterner.cs
@@ -7,10 +7,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Collections
 {
@@ -39,7 +36,7 @@ internal class LookasideStringInterner : INodePacketTranslatable
         /// The map used to intern strings for serialization.  This map doesn't exist when the strings
         /// are deserialized (it is not needed.)
         /// </summary>
-        private Dictionary<string, int> _stringToIdsMap;
+        private readonly Dictionary<string, int> _stringToIdsMap;
 
         /// <summary>
         /// The list of strings by ID.
@@ -64,7 +61,7 @@ public LookasideStringInterner(StringComparer comparer, int defaultCollectionSiz
         /// </remarks>
         public LookasideStringInterner(INodePacketTranslator translator)
         {
-            this.Translate(translator);
+            Translate(translator);
         }
 
         /// <summary>
@@ -84,12 +81,10 @@ public int Intern(string str)
             }
             else
             {
-                int index = -1;
-
                 // If stringToIdsMap is null here, it means we probably tried to intern a string to an interner which came from
                 // deserialization (and thus doesn't support further interning for efficiency reasons.)  No VerifyThrow here
                 // because this function is called a lot.
-                if (!_stringToIdsMap.TryGetValue(str, out index))
+                if (!_stringToIdsMap.TryGetValue(str, out int index))
                 {
                     index = _strings.Count; // This will be the index of the string we are about to add.
                     _stringToIdsMap.Add(str, index);
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index 4d4d6eeec25..14b08135aa6 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -7,8 +7,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
-using System.Collections.ObjectModel;
 using System.Collections;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
@@ -69,32 +67,23 @@ internal class MultiDictionary<K, V>
         /// </summary>
         internal MultiDictionary(IEqualityComparer<K> keyComparer)
         {
-            _backing = new Dictionary<K, MultiDictionary<K, V>.SmallList<V>>(keyComparer);
+            _backing = new Dictionary<K, SmallList<V>>(keyComparer);
         }
 
         /// <summary>
         /// Number of keys
         /// </summary>
-        internal int KeyCount
-        {
-            get { return _backing.Count; }
-        }
+        internal int KeyCount => _backing.Count;
 
         /// <summary>
         /// Number of values over all keys
         /// </summary>
-        internal int ValueCount
-        {
-            get { return _valueCount; }
-        }
+        internal int ValueCount => _valueCount;
 
         /// <summary>
         /// return keys in the dictionary
         /// </summary>
-        internal IEnumerable<K> Keys
-        {
-            get { return _backing.Keys; }
-        }
+        internal IEnumerable<K> Keys => _backing.Keys;
 
         /// <summary>
         /// Enumerator over values that have the specified key.
@@ -103,8 +92,7 @@ internal IEnumerable<V> this[K key]
         {
             get
             {
-                SmallList<V> entry;
-                if (!_backing.TryGetValue(key, out entry))
+                if (!_backing.TryGetValue(key, out SmallList<V> entry))
                 {
                     yield break;
                 }
@@ -124,10 +112,9 @@ internal void Add(K key, V value)
         {
             ErrorUtilities.VerifyThrow(value != null, "Null value not allowed");
 
-            SmallList<V> entry;
-            if (!_backing.TryGetValue(key, out entry))
+            if (!_backing.TryGetValue(key, out SmallList<V> entry))
             {
-                _backing.Add(key, new MultiDictionary<K, V>.SmallList<V>(value));
+                _backing.Add(key, new SmallList<V>(value));
             }
             else
             {
@@ -145,8 +132,7 @@ internal bool Remove(K key, V value)
         {
             ErrorUtilities.VerifyThrow(value != null, "Null value not allowed");
 
-            SmallList<V> entry;
-            if (!_backing.TryGetValue(key, out entry))
+            if (!_backing.TryGetValue(key, out SmallList<V> entry))
             {
                 return false;
             }
@@ -171,7 +157,7 @@ internal bool Remove(K key, V value)
         /// </summary>
         internal void Clear()
         {
-            _backing = new Dictionary<K, MultiDictionary<K, V>.SmallList<V>>();
+            _backing = new Dictionary<K, SmallList<V>>();
             _valueCount = 0;
         }
 
@@ -208,9 +194,7 @@ internal int Count
                         return 0;
                     }
 
-                    List<TT> list = _entry as List<TT>;
-
-                    if (list == null)
+                    if (!(_entry is List<TT> list))
                     {
                         return 1;
                     }
@@ -234,7 +218,7 @@ public IEnumerator<TT> GetEnumerator()
                 }
                 else
                 {
-                    List<TT> list = _entry as List<TT>;
+                    var list = _entry as List<TT>;
 
                     foreach (TT item in list)
                     {
@@ -263,14 +247,12 @@ public void Add(TT value)
                 }
                 else if (_entry is TT)
                 {
-                    List<TT> list = new List<TT>();
-                    list.Add((TT)_entry);
-                    list.Add(value);
+                    var list = new List<TT> { (TT) _entry, value };
                     _entry = list;
                 }
                 else
                 {
-                    List<TT> list = _entry as List<TT>;
+                    var list = _entry as List<TT>;
                     list.Add(value);
                 }
             }
@@ -287,7 +269,7 @@ public bool Remove(TT value)
                 }
                 else if (_entry is TT)
                 {
-                    if (Object.ReferenceEquals((TT)_entry, value))
+                    if (ReferenceEquals((TT)_entry, value))
                     {
                         _entry = null;
                         return true;
@@ -296,11 +278,11 @@ public bool Remove(TT value)
                     return false;
                 }
 
-                List<TT> list = _entry as List<TT>;
+                var list = _entry as List<TT>;
 
                 for (int i = 0; i < list.Count; i++)
                 {
-                    if (Object.ReferenceEquals(value, list[i]))
+                    if (ReferenceEquals(value, list[i]))
                     {
                         if (list.Count == 2)
                         {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index bd934455a1f..ab477b9fd20 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -8,11 +8,9 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Threading;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Collections
 {
@@ -46,14 +44,13 @@ internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<Propert
         /// Backing dictionary
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private RetrievableEntryHashSet<T> _properties;
+        private readonly RetrievableEntryHashSet<T> _properties = new RetrievableEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
         /// Creates empty dictionary
         /// </summary>
         public PropertyDictionary()
         {
-            _properties = new RetrievableEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -145,13 +142,7 @@ int ICollection<KeyValuePair<string, T>>.Count
         /// Whether the collection is read-only.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        bool ICollection<KeyValuePair<string, T>>.IsReadOnly
-        {
-            get
-            {
-                return false;
-            }
-        }
+        bool ICollection<KeyValuePair<string, T>>.IsReadOnly => false;
 
         /// <summary>
         /// Returns the number of property in the collection.
@@ -178,15 +169,8 @@ internal int Count
         /// </remarks>
         T IDictionary<string, T>.this[string name]
         {
-            get
-            {
-                return this[name];
-            }
-
-            set
-            {
-                this[name] = value;
-            }
+            get => this[name];
+            set => this[name] = value;
         }
 
         /// <summary>
@@ -288,7 +272,7 @@ public bool Equals(PropertyDictionary<T> other)
                 return false;
             }
 
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
@@ -405,10 +389,9 @@ bool ICollection<KeyValuePair<string, T>>.Contains(KeyValuePair<string, T> item)
         {
             lock (_properties)
             {
-                T value;
-                if (_properties.TryGetValue(item.Key, out value))
+                if (_properties.TryGetValue(item.Key, out T value))
                 {
-                    return Object.ReferenceEquals(value, item.Value);
+                    return ReferenceEquals(value, item.Value);
                 }
             }
 
@@ -460,7 +443,7 @@ IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnu
         /// </summary>
         internal bool Remove(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             lock (_properties)
             {
@@ -476,7 +459,7 @@ internal bool Remove(string name)
         /// </summary>
         internal void Set(T projectProperty)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectProperty, "projectProperty");
+            ErrorUtilities.VerifyThrowArgumentNull(projectProperty, nameof(projectProperty));
 
             lock (_properties)
             {
@@ -515,7 +498,7 @@ internal void RemoveProperties(IEnumerable<T> other)
         /// </summary>
         internal IDictionary<string, string> ToDictionary()
         {
-            Dictionary<string, string> dictionary = null;
+            Dictionary<string, string> dictionary;
 
             lock (_properties)
             {
diff --git a/src/Build/Collections/ReadOnlyConvertingDictionary.cs b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
index a267f28179f..f0671cbda69 100644
--- a/src/Build/Collections/ReadOnlyConvertingDictionary.cs
+++ b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
@@ -7,10 +7,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Collections
@@ -51,10 +48,7 @@ internal ReadOnlyConvertingDictionary(IDictionary<K, V> backing, Func<V, N> conv
         /// <summary>
         /// Returns the collection of keys in the dictionary.
         /// </summary>
-        public ICollection<K> Keys
-        {
-            get { return _backing.Keys; }
-        }
+        public ICollection<K> Keys => _backing.Keys;
 
         /// <summary>
         /// Returns the collection of values in the dictionary.
@@ -73,33 +67,20 @@ public ICollection<N> Values
         /// <summary>
         /// Returns the number of items in the collection.
         /// </summary>
-        public int Count
-        {
-            get { return _backing.Count; }
-        }
+        public int Count => _backing.Count;
 
         /// <summary>
         /// Returns true if the collection is read-only.
         /// </summary>
-        public bool IsReadOnly
-        {
-            get { return true; }
-        }
+        public bool IsReadOnly => true;
 
         /// <summary>
         /// Accesses the value for the specified key.
         /// </summary>
         public N this[K key]
         {
-            get
-            {
-                return _converter(_backing[key]);
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
-            }
+            get => _converter(_backing[key]);
+            set => ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
         }
 
         /// <summary>
@@ -132,8 +113,7 @@ public bool Remove(K key)
         /// </summary>
         public bool TryGetValue(K key, out N value)
         {
-            V originalValue;
-            if (_backing.TryGetValue(key, out originalValue))
+            if (_backing.TryGetValue(key, out V originalValue))
             {
                 value = _converter(originalValue);
                 return true;
diff --git a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
index 32e0df3a39d..5c1952b144a 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/BitHelper.cs
@@ -1,10 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
 using System.Security;
-using System.Text;
 
 namespace Microsoft.Build.Collections
 {
@@ -45,23 +42,23 @@ namespace Microsoft.Build.Collections
     /// on a bit array and then need to loop over it. In particular, if it avoided visiting 
     /// every bit, it would allow good perf improvements when the bit array is sparse.
     /// </summary>
-    unsafe internal class BitHelper
+    internal unsafe class BitHelper
     {   // should not be serialized
         private const byte MarkedBitFlag = 1;
         private const byte IntSize = 32;
 
         // m_length of underlying int array (not logical bit array)
-        private int _length;
+        private readonly int _length;
 
         // ptr to stack alloc'd array of ints
         [SecurityCritical]
-        private int* _arrayPtr;
+        private readonly int* _arrayPtr;
 
         // array of ints
-        private int[] _array;
+        private readonly int[] _array;
 
         // whether to operate on stack alloc'd or heap alloc'd array 
-        private bool _useStackAlloc;
+        private readonly bool _useStackAlloc;
 
         /// <summary>
         /// Instantiates a BitHelper with a heap alloc'd array of ints
@@ -91,8 +88,7 @@ internal BitHelper(int[] bitArray, int length)
         /// <summary>
         /// Mark bit at specified position
         /// </summary>
-        /// <param name="bitPosition"></param>
-        internal unsafe void MarkBit(int bitPosition)
+        internal void MarkBit(int bitPosition)
         {
             if (_useStackAlloc)
             {
@@ -115,9 +111,7 @@ internal unsafe void MarkBit(int bitPosition)
         /// <summary>
         /// Is bit at specified position marked?
         /// </summary>
-        /// <param name="bitPosition"></param>
-        /// <returns></returns>
-        internal unsafe bool IsMarked(int bitPosition)
+        internal bool IsMarked(int bitPosition)
         {
             if (_useStackAlloc)
             {
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
index e02fdd3f602..9a035b9570c 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
@@ -2,15 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
 using System.Diagnostics;
 #if !SILVERLIGHT
 #if FEATURE_CONSTRAINED_EXECUTION
 using System.Runtime.ConstrainedExecution;
 #endif
 #endif
-using System.Text;
 
 namespace Microsoft.Build.Collections
 {
@@ -93,8 +90,10 @@ internal static int ExpandPrime(int oldSize)
 
             // Allow the hashtables to grow to maximum possible size (~2G elements) before encoutering capacity overflow.
             // Note that this check works even when _items.Length overflowed thanks to the (uint) cast
-            if ((uint)newSize > MaxPrimeArrayLength)
+            if ((uint) newSize > MaxPrimeArrayLength)
+            {
                 return MaxPrimeArrayLength;
+            }
 
             return GetPrime(newSize);
         }
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 5bbb855ee75..97b9ce38dd4 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -10,7 +10,6 @@
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
-using System.Text;
 using System.Diagnostics.CodeAnalysis;
 using System.Security;
 using Microsoft.Build.Shared;
@@ -78,12 +77,12 @@ namespace Microsoft.Build.Collections
     /// the same time. 
     /// </summary>
     /// <typeparam name="T"></typeparam>
-    [DebuggerTypeProxy(typeof(Microsoft.Build.Collections.HashSetDebugView<>))]
+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
     [DebuggerDisplay("Count = {Count}")]
     [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Justification = "By design")]
-    [Serializable()]
+    [Serializable]
 #if FEATURE_SECURITY_PERMISSIONS
-    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
+    [HostProtection(MayLeakOnAbort = true)]
 #endif
     internal class RetrievableEntryHashSet<T> : ICollection<T>,
         ISerializable, IDeserializationCallback,
@@ -92,8 +91,6 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
     {
         // store lower 31 bits of hash code
         private const int Lower31BitMask = 0x7FFFFFFF;
-        // cutoff point, above which we won't do stackallocs. This corresponds to 100 integers.
-        private const int StackAllocThreshold = 100;
         // when constructing a hashset from an existing collection, it may contain duplicates, 
         // so this is used as the max acceptable excess ratio of capacity to count. Note that
         // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
@@ -115,7 +112,6 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
         private IEqualityComparer<string> _comparer;
         private IConstrainedEqualityComparer<string> _constrainedComparer;
         private int _version;
-        private bool _readOnly;
 
         // temporary variable needed during deserialization
         private SerializationInfo _siInfo;
@@ -140,13 +136,13 @@ public RetrievableEntryHashSet(IEqualityComparer<string> comparer)
         public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<string> comparer, bool readOnly = false)
             : this(collection, comparer)
         {
-            _readOnly = true; // Set after possible initialization from another collection
+            IsReadOnly = true; // Set after possible initialization from another collection
         }
 
         public RetrievableEntryHashSet(IEnumerable<KeyValuePair<string, T>> collection, IEqualityComparer<string> comparer, bool readOnly = false)
             : this(collection.Values(), comparer, readOnly)
         {
-            _readOnly = true; // Set after possible initialization from another collection
+            IsReadOnly = true; // Set after possible initialization from another collection
         }
 
         /// <summary>
@@ -170,7 +166,7 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
         {
             if (collection == null)
             {
-                throw new ArgumentNullException("collection");
+                throw new ArgumentNullException(nameof(collection));
             }
 
             Contract.EndContractBlock();
@@ -179,14 +175,13 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
             // may contain duplicates, so call TrimExcess if resulting hashset is larger than
             // threshold
             int suggestedCapacity = 0;
-            ICollection<T> coll = collection as ICollection<T>;
-            if (coll != null)
+            if (collection is ICollection<T> coll)
             {
                 suggestedCapacity = coll.Count;
             }
             Initialize(suggestedCapacity);
 
-            this.UnionWith(collection);
+            UnionWith(collection);
             if ((_count == 0 && _slots.Length > HashHelpers.GetMinPrime()) ||
                 (_count > 0 && _slots.Length / _count > ShrinkThreshold))
             {
@@ -224,20 +219,14 @@ public ICollection<string> Keys
         }
 
         // Convenience to minimise change to callers used to dictionaries
-        public ICollection<T> Values
-        {
-            get { return this; }
-        }
+        public ICollection<T> Values => this;
 
         #region ICollection<T> methods
 
         // Convenience to minimise change to callers used to dictionaries
         internal T this[string name]
         {
-            get
-            {
-                return Get(name);
-            }
+            get => Get(name);
 
             set
             {
@@ -262,7 +251,7 @@ void ICollection<T>.Add(T item)
         /// </summary>
         public void Clear()
         {
-            if (_readOnly)
+            if (IsReadOnly)
             {
                 ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
             }
@@ -301,8 +290,8 @@ public bool ContainsKey(string key)
 
         T IDictionary<string, T>.this[string name]
         {
-            get { return Get(name); }
-            set { Add(value); }
+            get => Get(name);
+            set => Add(value);
         }
 
         /// <summary>
@@ -342,13 +331,19 @@ public T Get(string key)
         public T Get(string key, int index, int length)
         {
             if (length < 0)
-                throw new ArgumentOutOfRangeException("length");
+            {
+                throw new ArgumentOutOfRangeException(nameof(length));
+            }
 
-            if (index < 0 || index > (key == null ? 0 : key.Length) - length)
-                throw new ArgumentOutOfRangeException("index");
+            if (index < 0 || index > (key?.Length ?? 0) - length)
+            {
+                throw new ArgumentOutOfRangeException(nameof(index));
+            }
 
             if (_constrainedComparer == null)
+            {
                 throw new InvalidOperationException("Cannot do a constrained lookup on this collection.");
+            }
         
             return GetCore(key, index, length);
         }
@@ -409,7 +404,7 @@ bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> entry)
         /// <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
         public bool Remove(string item)
         {
-            if (_readOnly)
+            if (IsReadOnly)
             {
                 ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
             }
@@ -459,25 +454,19 @@ public bool Remove(string item)
         /// <summary>
         /// Number of elements in this hashset
         /// </summary>
-        public int Count
-        {
-            get { return _count; }
-        }
+        public int Count => _count;
 
         /// <summary>
         /// Whether this is readonly
         /// </summary>
-        public bool IsReadOnly
-        {
-            get { return _readOnly; }
-        }
+        public bool IsReadOnly { get; private set; }
 
         /// <summary>
         /// Permanently prevent changes to the set.
         /// </summary>
         internal void MakeReadOnly()
         {
-            _readOnly = true;
+            IsReadOnly = true;
         }
 
         #endregion
@@ -491,7 +480,7 @@ public Enumerator GetEnumerator()
 
         IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator()
         {
-            foreach (var entry in this)
+            foreach (T entry in this)
             {
                 yield return new KeyValuePair<string, T>(entry.Key, entry);
             }
@@ -517,16 +506,16 @@ public virtual void GetObjectData(SerializationInfo info, StreamingContext conte
         {
             if (info == null)
             {
-                throw new ArgumentNullException("info");
+                throw new ArgumentNullException(nameof(info));
             }
 
             // need to serialize version to avoid problems with serializing while enumerating
             info.AddValue(VersionName, _version);
             info.AddValue(ComparerName, _comparer, typeof(IEqualityComparer<string>));
-            info.AddValue(CapacityName, _buckets == null ? 0 : _buckets.Length);
+            info.AddValue(CapacityName, _buckets?.Length ?? 0);
             if (_buckets != null)
             {
-                T[] array = new T[_count];
+                var array = new T[_count];
                 CopyTo(array);
                 info.AddValue(ElementsName, array, typeof(T[]));
             }
@@ -557,7 +546,7 @@ public virtual void OnDeserialization(Object sender)
                 _buckets = new int[capacity];
                 _slots = new Slot[capacity];
 
-                T[] array = (T[])_siInfo.GetValue(ElementsName, typeof(T[]));
+                var array = (T[])_siInfo.GetValue(ElementsName, typeof(T[]));
 
                 if (array == null)
                 {
@@ -595,7 +584,9 @@ public void Add(T item)
         void IDictionary<string, T>.Add(string key, T item)
         {
             if (key != item.Key)
+            {
                 throw new InvalidOperationException();
+            }
 
             AddEvenIfPresent(item);
         }
@@ -619,7 +610,7 @@ public void UnionWith(IEnumerable<T> other)
         {
             if (other == null)
             {
-                throw new ArgumentNullException("other");
+                throw new ArgumentNullException(nameof(other));
             }
             Contract.EndContractBlock();
 
@@ -988,10 +979,12 @@ public bool SetEquals(IEnumerable<T> other) {
         void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array, int index)
         {
             if (index < 0 || Count > array.Length - index)
-                throw new ArgumentException("index");
+            {
+                throw new ArgumentException(nameof(index));
+            }
 
             int i = index;
-            foreach (var entry in this)
+            foreach (T entry in this)
             {
                 array[i] = new KeyValuePair<string, T>(entry.Key, entry);
                 i++;
@@ -1005,20 +998,20 @@ public void CopyTo(T[] array, int arrayIndex, int count)
         {
             if (array == null)
             {
-                throw new ArgumentNullException("array");
+                throw new ArgumentNullException(nameof(array));
             }
             Contract.EndContractBlock();
 
             // check array index valid index into array
             if (arrayIndex < 0)
             {
-                throw new ArgumentOutOfRangeException("arrayIndex");
+                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
             }
 
             // also throw if count less than 0
             if (count < 0)
             {
-                throw new ArgumentOutOfRangeException("count");
+                throw new ArgumentOutOfRangeException(nameof(count));
             }
 
             // will array, starting at arrayIndex, be able to hold elements? Note: not
@@ -1026,7 +1019,7 @@ public void CopyTo(T[] array, int arrayIndex, int count)
             // count of 0; subsequent check takes care of the rest)
             if (arrayIndex > array.Length || count > array.Length - arrayIndex)
             {
-                throw new ArgumentException("arrayIndex");
+                throw new ArgumentException(nameof(arrayIndex));
             }
 
             int numCopied = 0;
@@ -1109,8 +1102,8 @@ public void TrimExcess()
                 // similar to IncreaseCapacity but moves down elements in case add/remove/etc
                 // caused fragmentation
                 int newSize = HashHelpers.GetPrime(_count);
-                Slot[] newSlots = new Slot[newSize];
-                int[] newBuckets = new int[newSize];
+                var newSlots = new Slot[newSize];
+                var newBuckets = new int[newSize];
 
                 // move down slots and rehash at the same time. newIndex keeps track of current 
                 // position in newSlots array
@@ -1187,13 +1180,13 @@ private void IncreaseCapacity()
             }
 
             // Able to increase capacity; copy elements to larger array and rehash
-            Slot[] newSlots = new Slot[newSize];
+            var newSlots = new Slot[newSize];
             if (_slots != null)
             {
                 Array.Copy(_slots, 0, newSlots, 0, _lastIndex);
             }
 
-            int[] newBuckets = new int[newSize];
+            var newBuckets = new int[newSize];
             for (int i = 0; i < _lastIndex; i++)
             {
                 int bucket = newSlots[i].hashCode % newSize;
@@ -1210,10 +1203,9 @@ private void IncreaseCapacity()
         /// ** MSBUILD: Modified so that it DOES add even if present. It will return false in that case, though.**
         /// </summary>
         /// <param name="value">value to find</param>
-        /// <returns></returns>
-        private bool AddEvenIfPresent(T value)
+        private void AddEvenIfPresent(T value)
         {
-            if (_readOnly)
+            if (IsReadOnly)
             {
                 ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
             }
@@ -1235,7 +1227,6 @@ private bool AddEvenIfPresent(T value)
                     // and we want "last wins" semantics
                     _slots[i].hashCode = hashCode;
                     _slots[i].value = value;
-                    return false;
                 }
             }
             int index;
@@ -1261,7 +1252,6 @@ private bool AddEvenIfPresent(T value)
             _buckets[bucket] = index + 1;
             _count++;
             _version++;
-            return true;
         }
 
         /// <summary>
@@ -1270,20 +1260,19 @@ private bool AddEvenIfPresent(T value)
         /// </summary>
         internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
         {
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
 
-            if (this.Count != other.Count)
+            if (Count != other.Count)
             {
                 return false;
             }
 
-            T ours;
             foreach (T element in other)
             {
-                if (!TryGetValue(element.Key, out ours) || !Object.ReferenceEquals(element, ours))
+                if (!TryGetValue(element.Key, out T ours) || !ReferenceEquals(element, ours))
                 {
                     return false;
                 }
@@ -1627,10 +1616,9 @@ private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other,
         /// <summary>
         /// Copies this to an array. Used for DebugView
         /// </summary>
-        /// <returns></returns>
         internal T[] ToArray()
         {
-            T[] newArray = new T[Count];
+            var newArray = new T[Count];
             CopyTo(newArray);
             return newArray;
         }
@@ -1704,7 +1692,9 @@ private int InternalGetHashCode(string item, int index, int length)
         {
             // No need to check for null 'item' as we own all comparers
             if (_constrainedComparer != null)
+            {
                 return _constrainedComparer.GetHashCode(item, index, length) & Lower31BitMask;
+            }
 
             return InternalGetHashCode(item);
         }
@@ -1742,22 +1732,21 @@ internal struct Slot
 #if !SILVERLIGHT
         [Serializable()]
 #if FEATURE_SECURITY_PERMISSIONS
-        [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
+        [HostProtection(MayLeakOnAbort = true)]
 #endif
 #endif
-        public struct Enumerator : IEnumerator<T>, System.Collections.IEnumerator
+        public struct Enumerator : IEnumerator<T>, IEnumerator
         {
-            private RetrievableEntryHashSet<T> _set;
+            private readonly RetrievableEntryHashSet<T> _set;
             private int _index;
-            private int _version;
-            private T _current;
+            private readonly int _version;
 
             internal Enumerator(RetrievableEntryHashSet<T> set)
             {
                 _set = set;
                 _index = 0;
                 _version = set._version;
-                _current = default(T);
+                Current = default(T);
             }
 
             public void Dispose()
@@ -1775,26 +1764,20 @@ public bool MoveNext()
                 {
                     if (_set._slots[_index].hashCode >= 0)
                     {
-                        _current = _set._slots[_index].value;
+                        Current = _set._slots[_index].value;
                         _index++;
                         return true;
                     }
                     _index++;
                 }
                 _index = _set._lastIndex + 1;
-                _current = default(T);
+                Current = default(T);
                 return false;
             }
 
-            public T Current
-            {
-                get
-                {
-                    return _current;
-                }
-            }
+            public T Current { get; private set; }
 
-            Object System.Collections.IEnumerator.Current
+            Object IEnumerator.Current
             {
                 get
                 {
@@ -1806,7 +1789,7 @@ Object System.Collections.IEnumerator.Current
                 }
             }
 
-            void System.Collections.IEnumerator.Reset()
+            void IEnumerator.Reset()
             {
                 if (_version != _set._version)
                 {
@@ -1814,7 +1797,7 @@ void System.Collections.IEnumerator.Reset()
                 }
 
                 _index = 0;
-                _current = default(T);
+                Current = default(T);
             }
         }
     }
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSetDebugView.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSetDebugView.cs
index ce3ec5eb1bc..45e69ec57ac 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSetDebugView.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSetDebugView.cs
@@ -2,10 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.Text;
 
 namespace Microsoft.Build.Collections
 {
@@ -15,25 +12,14 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="T"></typeparam>
     internal class HashSetDebugView<T> where T : class, IKeyed
     {
-        private RetrievableEntryHashSet<T> _set;
+        private readonly RetrievableEntryHashSet<T> _set;
 
         public HashSetDebugView(RetrievableEntryHashSet<T> set)
         {
-            if (set == null)
-            {
-                throw new ArgumentNullException("set");
-            }
-
-            _set = set;
+            _set = set ?? throw new ArgumentNullException(nameof(set));
         }
 
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        public T[] Items
-        {
-            get
-            {
-                return _set.ToArray();
-            }
-        }
+        public T[] Items => _set.ToArray();
     }
 }
diff --git a/src/Build/Collections/Triple.cs b/src/Build/Collections/Triple.cs
index e30594a4080..e4a65ad7b16 100644
--- a/src/Build/Collections/Triple.cs
+++ b/src/Build/Collections/Triple.cs
@@ -5,9 +5,6 @@
 // <summary>A struct of three objects</summary>
 //-----------------------------------------------------------------------
 
-using System;
-using System.Collections.Generic;
-
 namespace Microsoft.Build.Collections
 {
     /// <summary>
@@ -18,53 +15,30 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="C">Type of third object</typeparam>
     internal struct Triple<A, B, C>
     {
-        /// <summary>
-        /// First 
-        /// </summary>
-        private A _first;
-
-        /// <summary>
-        /// Second
-        /// </summary>
-        private B _second;
-
-        /// <summary>
-        /// Third
-        /// </summary>
-        private C _third;
 
         /// <summary>
         /// Constructor
         /// </summary>
         public Triple(A first, B second, C third)
         {
-            _first = first;
-            _second = second;
-            _third = third;
+            First = first;
+            Second = second;
+            Third = third;
         }
 
         /// <summary>
         /// First
         /// </summary>
-        public A First
-        {
-            get { return _first; }
-        }
+        public A First { get; }
 
         /// <summary>
         /// Second
         /// </summary>
-        public B Second
-        {
-            get { return _second; }
-        }
+        public B Second { get; }
 
         /// <summary>
         /// Third
         /// </summary>
-        public C Third
-        {
-            get { return _third; }
-        }
+        public C Third { get; }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Collections/WeakReference.cs b/src/Build/Collections/WeakReference.cs
index dce9d21dcd2..01fd34cb632 100644
--- a/src/Build/Collections/WeakReference.cs
+++ b/src/Build/Collections/WeakReference.cs
@@ -6,12 +6,7 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Collections.ObjectModel;
-using System.Collections;
 using Microsoft.Build.Shared;
-using System.Diagnostics;
 
 namespace Microsoft.Build.Collections
 {
@@ -39,7 +34,7 @@ internal class WeakReference<T>
         /// </summary>
         internal WeakReference(T target)
         {
-            ErrorUtilities.VerifyThrowInternalNull(target, "target");
+            ErrorUtilities.VerifyThrowInternalNull(target, nameof(target));
 
             _weakReference = new WeakReference(target);
             _hashcode = target.GetHashCode();
@@ -50,10 +45,7 @@ internal WeakReference(T target)
         /// If it returns null, its value may have been collected, or it may actually "wrap" null.
         /// To distinguish these cases, compare the WeakReference object itself to WeakReference.Null.
         /// </summary>
-        internal T Target
-        {
-            get { return (T)_weakReference.Target; }
-        }
+        internal T Target => (T)_weakReference.Target;
 
         /// <summary>
         /// Returns the hashcode of the wrapped target.
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index 717970917c4..1808176b447 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -5,9 +5,7 @@
 // <summary>Dictionary that does not prevent values from being garbage collected.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 
@@ -25,7 +23,7 @@ internal class WeakValueDictionary<K, V>
         /// The dictionary used internally to store the keys and values.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private Dictionary<K, WeakReference<V>> _dictionary;
+        private readonly Dictionary<K, WeakReference<V>> _dictionary;
 
         /// <summary>
         /// Improvised capacity. See comment in item setter.
@@ -54,10 +52,7 @@ public WeakValueDictionary(IEqualityComparer<K> keyComparer)
         /// Some entries may represent keys or values that have already been garbage collected.
         /// To clean these out call <see cref="Scavenge"/>.
         /// </summary>
-        public int Count
-        {
-            get { return _dictionary.Count; }
-        }
+        public int Count => _dictionary.Count;
 
         /// <summary>
         /// Return keys
@@ -66,11 +61,11 @@ public IEnumerable<K> Keys
         {
             get
             {
-                List<K> keys = new List<K>();
+                var keys = new List<K>();
 
                 foreach (KeyValuePair<K, WeakReference<V>> pair in _dictionary)
                 {
-                    if (pair.Value != null && pair.Value.Target != null)
+                    if (pair.Value?.Target != null)
                     {
                         keys.Add(pair.Key);
                     }
@@ -150,8 +145,7 @@ public V this[K key]
         /// </remarks>
         public bool Contains(K key)
         {
-            V value;
-            bool contained = TryGetValue(key, out value);
+            bool contained = TryGetValue(key, out _);
             return contained;
         }
 
@@ -165,8 +159,7 @@ public bool Contains(K key)
         /// </remarks>
         public bool TryGetValue(K key, out V value)
         {
-            WeakReference<V> wrappedValue;
-            bool result = _dictionary.TryGetValue(key, out wrappedValue);
+            bool result = _dictionary.TryGetValue(key, out WeakReference<V> wrappedValue);
 
             if (!result)
             {
diff --git a/src/Build/Construction/ProjectChooseElement.cs b/src/Build/Construction/ProjectChooseElement.cs
index 55a253fef6b..a6d79b03dc2 100644
--- a/src/Build/Construction/ProjectChooseElement.cs
+++ b/src/Build/Construction/ProjectChooseElement.cs
@@ -5,12 +5,10 @@
 // <summary>Definition of ProjectChooseElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Generic;
 using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
@@ -29,7 +27,7 @@ public class ProjectChooseElement : ProjectElementContainer
         internal ProjectChooseElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -46,15 +44,8 @@ private ProjectChooseElement(XmlElement xmlElement, ProjectRootElement containin
         /// </summary>
         public override string Condition
         {
-            get
-            {
-                return null;
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
-            }
+            get => null;
+            set => ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
         }
 
         #region ChildEnumerators
@@ -62,13 +53,7 @@ public override string Condition
         /// Get the When children.
         /// Will contain at least one entry.
         /// </summary>
-        public ICollection<ProjectWhenElement> WhenElements
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectWhenElement>(Children.OfType<ProjectWhenElement>());
-            }
-        }
+        public ICollection<ProjectWhenElement> WhenElements => new ReadOnlyCollection<ProjectWhenElement>(Children.OfType<ProjectWhenElement>());
 
         /// <summary>
         /// Get any Otherwise child.
@@ -78,8 +63,7 @@ public ProjectOtherwiseElement OtherwiseElement
         {
             get
             {
-                ProjectOtherwiseElement otherwise = (LastChild == null) ? null : LastChild as ProjectOtherwiseElement;
-
+                ProjectOtherwiseElement otherwise = LastChild as ProjectOtherwiseElement;
                 return otherwise;
             }
         }
@@ -104,7 +88,6 @@ public override ElementLocation ConditionLocation
         internal static ProjectChooseElement CreateDisconnected(ProjectRootElement containingProject)
         {
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.choose);
-
             return new ProjectChooseElement(element, containingProject);
         }
 
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index 81fa8627cc7..f9893f0a3fe 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -6,18 +6,12 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Text;
 using System.Collections.Generic;
 using System.Xml;
 using System.Diagnostics;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Collections.ObjectModel;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Collections;
-
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-using System.Reflection;
 
 namespace Microsoft.Build.Construction
 {
@@ -55,12 +49,12 @@ internal ProjectElement()
         /// </summary>
         internal ProjectElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xmlElement, "xmlElement");
-            ErrorUtilities.VerifyThrowArgumentNull(containingProject, "containingProject");
+            ErrorUtilities.VerifyThrowArgumentNull(xmlElement, nameof(xmlElement));
+            ErrorUtilities.VerifyThrowArgumentNull(containingProject, nameof(containingProject));
 
-            this.XmlElement = (XmlElementWithLocation)xmlElement;
+            XmlElement = (XmlElementWithLocation)xmlElement;
             _parent = parent;
-            this.ContainingProject = containingProject;
+            ContainingProject = containingProject;
         }
 
         /// <summary>
@@ -72,7 +66,7 @@ internal ProjectElement(XmlElement xmlElement, ProjectElementContainer parent, P
         /// </remarks>
         internal virtual bool ExpressedAsAttribute
         {
-            get { return _expressedAsAttribute; }
+            get => _expressedAsAttribute;
             set
             {
                 if (value != _expressedAsAttribute)
@@ -101,12 +95,8 @@ public virtual string Condition
             get
             {
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
-                if (_condition == null)
-                {
-                    _condition = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.condition);
-                }
-
-                return _condition;
+                return _condition ??
+                       (_condition = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.condition));
             }
 
             [DebuggerStepThrough]
@@ -240,8 +230,7 @@ public ProjectRootElement ContainingProject
             get
             {
                 // If this element is unparented, we have hijacked the 'parent' field and stored the owning PRE in a special wrapper; get it from that.
-                var wrapper = _parent as WrapperForProjectRootElement;
-                if (wrapper != null)
+                if (_parent is WrapperForProjectRootElement wrapper)
                 {
                     return wrapper.ContainingProject;
                 }
@@ -268,19 +257,13 @@ internal set
         /// Location of the "Condition" attribute on this element, if any.
         /// If there is no such attribute, returns null.
         /// </summary>
-        public virtual ElementLocation ConditionLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.condition); }
-        }
+        public virtual ElementLocation ConditionLocation => XmlElement.GetAttributeLocation(XMakeAttributes.condition);
 
         /// <summary>
         /// Location of the "Label" attribute on this element, if any.
         /// If there is no such attribute, returns null;
         /// </summary>
-        public ElementLocation LabelLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.label); }
-        }
+        public ElementLocation LabelLocation => XmlElement.GetAttributeLocation(XMakeAttributes.label);
 
         /// <summary>
         /// Location of the corresponding Xml element.
@@ -289,16 +272,10 @@ public ElementLocation LabelLocation
         /// In the case of an unsaved edit, the location only
         /// contains the path to the file that the element originates from.
         /// </summary>
-        public ElementLocation Location
-        {
-            get { return XmlElement.Location; }
-        }
+        public ElementLocation Location => XmlElement.Location;
 
         /// <inheritdoc/>
-        public string ElementName
-        {
-            get { return XmlElement.Name; }
-        }
+        public string ElementName => XmlElement.Name;
 
         /// <summary>
         /// Gets the XmlElement associated with this project element.
@@ -309,11 +286,7 @@ public string ElementName
         /// This should be protected, but "protected internal" means "OR" not "AND",
         /// so this is not possible.
         /// </remarks>
-        internal XmlElementWithLocation XmlElement
-        {
-            get;
-            private set;
-        }
+        internal XmlElementWithLocation XmlElement { get; private set; }
 
         /// <summary>
         /// Gets the XmlDocument associated with this project element.
@@ -328,7 +301,7 @@ internal XmlDocumentWithLocation XmlDocument
             [DebuggerStepThrough]
             get
             {
-                return (XmlElement == null) ? null : (XmlDocumentWithLocation)XmlElement.OwnerDocument;
+                return (XmlDocumentWithLocation) XmlElement?.OwnerDocument;
             }
         }
 
@@ -338,7 +311,7 @@ internal XmlDocumentWithLocation XmlDocument
         /// <returns>The cloned element.</returns>
         public ProjectElement Clone()
         {
-            return this.Clone(this.ContainingProject);
+            return Clone(ContainingProject);
         }
 
         /// <summary>
@@ -347,8 +320,8 @@ public ProjectElement Clone()
         /// <param name="element">The element to act as a template to copy from.</param>
         public virtual void CopyFrom(ProjectElement element)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(element, "element");
-            ErrorUtilities.VerifyThrowArgument(this.GetType().IsEquivalentTo(element.GetType()), "element");
+            ErrorUtilities.VerifyThrowArgumentNull(element, nameof(element));
+            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), nameof(element));
 
             if (this == element)
             {
@@ -356,33 +329,33 @@ public virtual void CopyFrom(ProjectElement element)
             }
 
             // Remove all the current attributes and textual content.
-            this.XmlElement.RemoveAllAttributes();
-            if (this.XmlElement.ChildNodes.Count == 1 && this.XmlElement.FirstChild.NodeType == XmlNodeType.Text)
+            XmlElement.RemoveAllAttributes();
+            if (XmlElement.ChildNodes.Count == 1 && XmlElement.FirstChild.NodeType == XmlNodeType.Text)
             {
-                this.XmlElement.RemoveChild(this.XmlElement.FirstChild);
+                XmlElement.RemoveChild(XmlElement.FirstChild);
             }
 
             // Ensure the element name itself matches.
-            this.ReplaceElement(XmlUtilities.RenameXmlElement(this.XmlElement, element.XmlElement.Name, XmlElement.NamespaceURI));
+            ReplaceElement(XmlUtilities.RenameXmlElement(XmlElement, element.XmlElement.Name, XmlElement.NamespaceURI));
 
             // Copy over the attributes from the template element.
             foreach (XmlAttribute attribute in element.XmlElement.Attributes)
             {
                 if (ShouldCloneXmlAttribute(attribute))
                 {
-                    this.XmlElement.SetAttribute(attribute.LocalName, attribute.NamespaceURI, attribute.Value);
+                    XmlElement.SetAttribute(attribute.LocalName, attribute.NamespaceURI, attribute.Value);
                 }
             }
 
             // If this element has pure text content, copy that over.
             if (element.XmlElement.ChildNodes.Count == 1 && element.XmlElement.FirstChild.NodeType == XmlNodeType.Text)
             {
-                this.XmlElement.AppendChild(this.XmlElement.OwnerDocument.CreateTextNode(element.XmlElement.FirstChild.Value));
+                XmlElement.AppendChild(XmlElement.OwnerDocument.CreateTextNode(element.XmlElement.FirstChild.Value));
             }
 
-            this._expressedAsAttribute = element._expressedAsAttribute;
+            _expressedAsAttribute = element._expressedAsAttribute;
 
-            this.MarkDirty("CopyFrom", null);
+            MarkDirty("CopyFrom", null);
         }
 
         /// <summary>
@@ -399,8 +372,8 @@ protected virtual bool ShouldCloneXmlAttribute(XmlAttribute attribute)
         /// </summary>
         internal void SetProjectRootElementFromParser(XmlElementWithLocation xmlElement, ProjectRootElement projectRootElement)
         {
-            this.XmlElement = xmlElement;
-            this.ContainingProject = projectRootElement;
+            XmlElement = xmlElement;
+            ContainingProject = projectRootElement;
         }
 
         /// <summary>
@@ -428,7 +401,7 @@ internal void ClearParent()
         /// </remarks>
         internal void ReplaceElement(XmlElementWithLocation newElement)
         {
-            if (Object.ReferenceEquals(newElement, XmlElement))
+            if (ReferenceEquals(newElement, XmlElement))
             {
                 return;
             }
@@ -455,10 +428,7 @@ internal void ReplaceElement(XmlElementWithLocation newElement)
         /// </comment>
         internal virtual void MarkDirty(string reason, string param)
         {
-            if (Parent != null)
-            {
-                Parent.MarkDirty(reason, param);
-            }
+            Parent?.MarkDirty(reason, param);
         }
 
         /// <summary>
@@ -476,10 +446,10 @@ internal virtual void OnAfterParentChanged(ProjectElementContainer newParent)
         /// <returns>The cloned element.</returns>
         protected internal virtual ProjectElement Clone(ProjectRootElement factory)
         {
-            var clone = this.CreateNewInstance(factory);
-            if (!clone.GetType().IsEquivalentTo(this.GetType()))
+            var clone = CreateNewInstance(factory);
+            if (!clone.GetType().IsEquivalentTo(GetType()))
             {
-                ErrorUtilities.ThrowInternalError("{0}.Clone() returned an instance of type {1}.", this.GetType().Name, clone.GetType().Name);
+                ErrorUtilities.ThrowInternalError("{0}.Clone() returned an instance of type {1}.", GetType().Name, clone.GetType().Name);
             }
 
             clone.CopyFrom(this);
@@ -505,18 +475,14 @@ private class WrapperForProjectRootElement : ProjectElementContainer
             /// </summary>
             internal WrapperForProjectRootElement(ProjectRootElement containingProject)
             {
-                ErrorUtilities.VerifyThrowInternalNull(containingProject, "containingProject");
-                this.ContainingProject = containingProject;
+                ErrorUtilities.VerifyThrowInternalNull(containingProject, nameof(containingProject));
+                ContainingProject = containingProject;
             }
 
             /// <summary>
             /// Wrapped ProjectRootElement
             /// </summary>
-            internal new ProjectRootElement ContainingProject
-            {
-                get;
-                private set;
-            }
+            internal new ProjectRootElement ContainingProject { get; }
 
             /// <summary>
             /// Dummy required implementation
@@ -529,7 +495,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
             /// <inheritdoc />
             protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
             {
-                return new WrapperForProjectRootElement(this.ContainingProject);
+                return new WrapperForProjectRootElement(ContainingProject);
             }
         }
     }
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index baf9ffc8338..471e54f239c 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -6,18 +6,12 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Text;
 using System.Collections.Generic;
 using System.Linq;
 using System.Xml;
 using System.Diagnostics;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Collections.ObjectModel;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Internal;
-using System.Reflection;
 
 namespace Microsoft.Build.Construction
 {
@@ -26,12 +20,7 @@ namespace Microsoft.Build.Construction
     /// </summary>
     public abstract class ProjectElementContainer : ProjectElement
     {
-        const string DEFAULT_INDENT = "  ";
-
-        /// <summary>
-        /// Number of children of any kind
-        /// </summary>
-        private int _count;
+        private const string DEFAULT_INDENT = "  ";
 
         /// <summary>
         /// Constructor called by ProjectRootElement only.
@@ -41,7 +30,6 @@ public abstract class ProjectElementContainer : ProjectElement
         /// Should ideally be protected+internal.
         /// </comment> 
         internal ProjectElementContainer()
-            : base()
         {
         }
 
@@ -61,10 +49,7 @@ internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer
         /// Get an enumerator over all children, gotten recursively.
         /// Walks the children in a depth-first manner.
         /// </summary>
-        public IEnumerable<ProjectElement> AllChildren
-        {
-            get { return GetChildrenRecursively(); }
-        }
+        public IEnumerable<ProjectElement> AllChildren => GetChildrenRecursively();
 
         /// <summary>
         /// Get enumerable over all the children
@@ -74,7 +59,7 @@ public ICollection<ProjectElement> Children
             [DebuggerStepThrough]
             get
             {
-                return new Microsoft.Build.Collections.ReadOnlyCollection<ProjectElement>
+                return new Collections.ReadOnlyCollection<ProjectElement>
                     (
                         new ProjectElementSiblingEnumerable(FirstChild)
                     );
@@ -89,7 +74,7 @@ public ICollection<ProjectElement> ChildrenReversed
             [DebuggerStepThrough]
             get
             {
-                return new Microsoft.Build.Collections.ReadOnlyCollection<ProjectElement>
+                return new Collections.ReadOnlyCollection<ProjectElement>
                     (
                         new ProjectElementSiblingEnumerable(LastChild, false /* reverse */)
                     );
@@ -99,11 +84,8 @@ public ICollection<ProjectElement> ChildrenReversed
         /// <summary>
         /// Number of children of any kind
         /// </summary>
-        public int Count
-        {
-            [DebuggerStepThrough]
-            get
-            { return _count; }
+        public int Count { [DebuggerStepThrough]
+            get; private set;
         }
 
         /// <summary>
@@ -144,7 +126,7 @@ public ProjectElement LastChild
         /// </remarks>
         public void InsertAfterChild(ProjectElement child, ProjectElement reference)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(child, "child");
+            ErrorUtilities.VerifyThrowArgumentNull(child, nameof(child));
 
             if (reference == null)
             {
@@ -176,7 +158,7 @@ public void InsertAfterChild(ProjectElement child, ProjectElement reference)
 
             AddToXml(child);
 
-            _count++;
+            Count++;
             MarkDirty("Insert element {0}", child.ElementName);
         }
 
@@ -194,7 +176,7 @@ public void InsertAfterChild(ProjectElement child, ProjectElement reference)
         /// </remarks>
         public void InsertBeforeChild(ProjectElement child, ProjectElement reference)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(child, "child");
+            ErrorUtilities.VerifyThrowArgumentNull(child, nameof(child));
 
             if (reference == null)
             {
@@ -226,7 +208,7 @@ public void InsertBeforeChild(ProjectElement child, ProjectElement reference)
 
             AddToXml(child);
 
-            _count++;
+            Count++;
             MarkDirty("Insert element {0}", child.ElementName);
         }
 
@@ -265,7 +247,6 @@ public void PrependChild(ProjectElement child)
             {
                 ErrorUtilities.VerifyThrow(LastChild != null, "Invalid structure");
                 InsertBeforeChild(child, FirstChild);
-                return;
             }
         }
 
@@ -284,7 +265,7 @@ public void PrependChild(ProjectElement child)
         /// </remarks>
         public void RemoveChild(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(child, "child");
+            ErrorUtilities.VerifyThrowArgumentNull(child, nameof(child));
 
             ErrorUtilities.VerifyThrowArgument(child.Parent == this, "OM_NodeNotAlreadyParentedByThis");
 
@@ -300,19 +281,19 @@ public void RemoveChild(ProjectElement child)
                 child.NextSibling.PreviousSibling = child.PreviousSibling;
             }
 
-            if (Object.ReferenceEquals(child, FirstChild))
+            if (ReferenceEquals(child, FirstChild))
             {
                 FirstChild = child.NextSibling;
             }
 
-            if (Object.ReferenceEquals(child, LastChild))
+            if (ReferenceEquals(child, LastChild))
             {
                 LastChild = child.PreviousSibling;
             }
 
             RemoveFromXml(child);
 
-            _count--;
+            Count--;
             MarkDirty("Remove element {0}", child.ElementName);
         }
 
@@ -337,27 +318,26 @@ public void RemoveAllChildren()
         /// <param name="element">The element to act as a template to copy from.</param>
         public virtual void DeepCopyFrom(ProjectElementContainer element)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(element, "element");
-            ErrorUtilities.VerifyThrowArgument(this.GetType().IsEquivalentTo(element.GetType()), "element");
+            ErrorUtilities.VerifyThrowArgumentNull(element, nameof(element));
+            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), nameof(element));
 
             if (this == element)
             {
                 return;
             }
 
-            this.RemoveAllChildren();
-            this.CopyFrom(element);
+            RemoveAllChildren();
+            CopyFrom(element);
 
-            foreach (var child in element.Children)
+            foreach (ProjectElement child in element.Children)
             {
-                var childContainer = child as ProjectElementContainer;
-                if (childContainer != null)
+                if (child is ProjectElementContainer childContainer)
                 {
-                    childContainer.DeepClone(this.ContainingProject, this);
+                    childContainer.DeepClone(ContainingProject, this);
                 }
                 else
                 {
-                    this.AppendChild(child.Clone(this.ContainingProject));
+                    AppendChild(child.Clone(ContainingProject));
                 }
             }
         }
@@ -388,7 +368,7 @@ internal void AppendParentedChildNoChecks(ProjectElement child)
 
             LastChild = child;
 
-            _count++;
+            Count++;
         }
 
         /// <summary>
@@ -399,16 +379,12 @@ internal void AppendParentedChildNoChecks(ProjectElement child)
         /// <returns>The cloned element.</returns>
         protected internal virtual ProjectElementContainer DeepClone(ProjectRootElement factory, ProjectElementContainer parent)
         {
-            var clone = (ProjectElementContainer)this.Clone(factory);
-            if (parent != null)
-            {
-                parent.AppendChild(clone);
-            }
+            var clone = (ProjectElementContainer)Clone(factory);
+            parent?.AppendChild(clone);
 
-            foreach (var child in this.Children)
+            foreach (ProjectElement child in Children)
             {
-                var childContainer = child as ProjectElementContainer;
-                if (childContainer != null)
+                if (child is ProjectElementContainer childContainer)
                 {
                     childContainer.DeepClone(clone.ContainingProject, clone);
                 }
@@ -427,7 +403,7 @@ private void SetElementAsAttributeValue(ProjectElement child)
             Debug.Assert(child.ExpressedAsAttribute, nameof(SetElementAsAttributeValue) + " method requires that " +
                 nameof(child.ExpressedAsAttribute) + " property of child is true");
 
-            string value = Microsoft.Build.Internal.Utilities.GetXmlNodeInnerContents(child.XmlElement);
+            string value = Internal.Utilities.GetXmlNodeInnerContents(child.XmlElement);
             ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, child.XmlElement.Name, value);
         }
 
@@ -479,10 +455,9 @@ internal void AddToXml(ProjectElement child)
                 // Therefore, we need to traverse both directions to find the first sibling of the same type as the one being added.
                 // If none is found, then the node being added is inserted as the only node of its kind
 
-                ProjectElement referenceSibling;
-                Predicate<ProjectElement> siblingIsExplicitElement = _ => _.ExpressedAsAttribute == false;
+                bool SiblingIsExplicitElement(ProjectElement _) => _.ExpressedAsAttribute == false;
 
-                if (TrySearchLeftSiblings(child.PreviousSibling, siblingIsExplicitElement, out referenceSibling))
+                if (TrySearchLeftSiblings(child.PreviousSibling, SiblingIsExplicitElement, out ProjectElement referenceSibling))
                 {
                     //  Add after previous sibling
                     XmlElement.InsertAfter(child.XmlElement, referenceSibling.XmlElement);
@@ -498,7 +473,7 @@ internal void AddToXml(ProjectElement child)
                         }
                     }
                 }
-                else if (TrySearchRightSiblings(child.NextSibling, siblingIsExplicitElement, out referenceSibling))
+                else if (TrySearchRightSiblings(child.NextSibling, SiblingIsExplicitElement, out referenceSibling))
                 {
                     //  Add as first child
                     XmlElement.InsertBefore(child.XmlElement, referenceSibling.XmlElement);
@@ -540,7 +515,7 @@ internal void AddToXml(ProjectElement child)
             }
         }
 
-        private string GetElementIndentation(XmlElementWithLocation xmlElement)
+        private static string GetElementIndentation(XmlElementWithLocation xmlElement)
         {
             if (xmlElement.PreviousSibling?.NodeType != XmlNodeType.Whitespace)
             {
@@ -618,7 +593,7 @@ private void AddInitialChild(ProjectElement child)
 
             AddToXml(child);
 
-            _count++;
+            Count++;
 
             MarkDirty("Add child element named '{0}'", child.ElementName);
         }
@@ -629,10 +604,10 @@ private void AddInitialChild(ProjectElement child)
         /// </summary>
         private void VerifyForInsertBeforeAfterFirst(ProjectElement child, ProjectElement reference)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(this.Parent != null || this.ContainingProject == this, "OM_ParentNotParented");
+            ErrorUtilities.VerifyThrowInvalidOperation(Parent != null || ContainingProject == this, "OM_ParentNotParented");
             ErrorUtilities.VerifyThrowInvalidOperation(reference == null || reference.Parent == this, "OM_ReferenceDoesNotHaveThisParent");
             ErrorUtilities.VerifyThrowInvalidOperation(child.Parent == null, "OM_NodeAlreadyParented");
-            ErrorUtilities.VerifyThrowInvalidOperation(child.ContainingProject == this.ContainingProject, "OM_MustBeSameProject");
+            ErrorUtilities.VerifyThrowInvalidOperation(child.ContainingProject == ContainingProject, "OM_MustBeSameProject");
 
             // In RemoveChild() we do not update the victim's NextSibling (or PreviousSibling) to null, to allow RemoveChild to be
             // called within an enumeration. So we can't expect these to be null if the child was previously removed. However, we
@@ -670,9 +645,7 @@ private IEnumerable<ProjectElement> GetChildrenRecursively()
             {
                 yield return child;
 
-                ProjectElementContainer container = child as ProjectElementContainer;
-
-                if (container != null)
+                if (child is ProjectElementContainer container)
                 {
                     foreach (ProjectElement grandchild in container.AllChildren)
                     {
@@ -726,20 +699,12 @@ private struct ProjectElementSiblingEnumerable : IEnumerable<ProjectElement>
             /// <summary>
             /// The enumerator
             /// </summary>
-            private ProjectElementSiblingEnumerator _enumerator;
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            internal ProjectElementSiblingEnumerable(ProjectElement initial)
-                : this(initial, true)
-            {
-            }
+            private readonly ProjectElementSiblingEnumerator _enumerator;
 
             /// <summary>
             /// Constructor allowing reverse enumeration
             /// </summary>
-            internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards)
+            internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards = true)
             {
                 _enumerator = new ProjectElementSiblingEnumerator(initial, forwards);
             }
@@ -768,19 +733,14 @@ private struct ProjectElementSiblingEnumerator : IEnumerator<ProjectElement>
                 /// <summary>
                 /// First element
                 /// </summary>
-                private ProjectElement _initial;
-
-                /// <summary>
-                /// Current element
-                /// </summary>
-                private ProjectElement _current;
+                private readonly ProjectElement _initial;
 
                 /// <summary>
                 /// Whether enumeration should go forwards or backwards.
                 /// If backwards, the "initial" will be the first returned, then each previous
                 /// node in turn.
                 /// </summary>
-                private bool _forwards;
+                private readonly bool _forwards;
 
                 /// <summary>
                 /// Constructor taking the first element
@@ -788,7 +748,7 @@ private struct ProjectElementSiblingEnumerator : IEnumerator<ProjectElement>
                 internal ProjectElementSiblingEnumerator(ProjectElement initial, bool forwards)
                 {
                     _initial = initial;
-                    _current = null;
+                    Current = null;
                     _forwards = forwards;
                 }
 
@@ -796,10 +756,7 @@ internal ProjectElementSiblingEnumerator(ProjectElement initial, bool forwards)
                 /// Current element
                 /// Returns null if MoveNext() hasn't been called
                 /// </summary>
-                public ProjectElement Current
-                {
-                    get { return _current; }
-                }
+                public ProjectElement Current { get; private set; }
 
                 /// <summary>
                 /// Current element.
@@ -809,9 +766,9 @@ object System.Collections.IEnumerator.Current
                 {
                     get
                     {
-                        if (_current != null)
+                        if (Current != null)
                         {
-                            return _current;
+                            return Current;
                         }
 
                         throw new InvalidOperationException();
@@ -832,18 +789,18 @@ public bool MoveNext()
                 {
                     ProjectElement next;
 
-                    if (_current == null)
+                    if (Current == null)
                     {
                         next = _initial;
                     }
                     else
                     {
-                        next = _forwards ? _current.NextSibling : _current.PreviousSibling;
+                        next = _forwards ? Current.NextSibling : Current.PreviousSibling;
                     }
 
                     if (next != null)
                     {
-                        _current = next;
+                        Current = next;
                         return true;
                     }
 
@@ -855,7 +812,7 @@ public bool MoveNext()
                 /// </summary>
                 public void Reset()
                 {
-                    _current = null;
+                    Current = null;
                 }
             }
         }
diff --git a/src/Build/Construction/ProjectExtensionsElement.cs b/src/Build/Construction/ProjectExtensionsElement.cs
index dc5e281e724..4d47c46da2e 100644
--- a/src/Build/Construction/ProjectExtensionsElement.cs
+++ b/src/Build/Construction/ProjectExtensionsElement.cs
@@ -6,15 +6,10 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Collections.Generic;
 using System.Xml;
-using System.Reflection;
 using System.Diagnostics;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-using Utilities = Microsoft.Build.Internal.Utilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -31,7 +26,7 @@ public class ProjectExtensionsElement : ProjectElement
         internal ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement project)
             : base(xmlElement, parent, project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -48,15 +43,8 @@ private ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement proje
         /// </summary>
         public override string Condition
         {
-            get
-            {
-                return null;
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
-            }
+            get => null;
+            set => ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
         }
 
         /// <summary>
@@ -72,7 +60,7 @@ public string Content
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "Content");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(Content));
                 XmlElement.InnerXml = value;
                 MarkDirty("Set ProjectExtensions raw {0}", value);
             }
@@ -98,17 +86,12 @@ public string this[string name]
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
                 XmlElement idElement = XmlElement[name];
 
-                if (idElement == null)
-                {
-                    return String.Empty;
-                }
-
                 // remove the xmlns attribute, because the IDE's not expecting that
-                return Microsoft.Build.Internal.Utilities.RemoveXmlNamespace(idElement.InnerXml);
+                return idElement == null ? String.Empty : Internal.Utilities.RemoveXmlNamespace(idElement.InnerXml);
             }
 
             set
@@ -148,20 +131,20 @@ public string this[string name]
         /// <inheritdoc/>
         public override void CopyFrom(ProjectElement element)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(element, "element");
-            ErrorUtilities.VerifyThrowArgument(this.GetType().IsEquivalentTo(element.GetType()), "element");
+            ErrorUtilities.VerifyThrowArgumentNull(element, nameof(element));
+            ErrorUtilities.VerifyThrowArgument(GetType().IsEquivalentTo(element.GetType()), nameof(element));
 
             if (this == element)
             {
                 return;
             }
 
-            this.Label = element.Label;
+            Label = element.Label;
 
             var other = (ProjectExtensionsElement)element;
-            this.Content = other.Content;
+            Content = other.Content;
 
-            this.MarkDirty("CopyFrom", null);
+            MarkDirty("CopyFrom", null);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/ProjectImportElement.cs b/src/Build/Construction/ProjectImportElement.cs
index 9805cd53dd3..5bac88c30f6 100644
--- a/src/Build/Construction/ProjectImportElement.cs
+++ b/src/Build/Construction/ProjectImportElement.cs
@@ -25,7 +25,7 @@ public class ProjectImportElement : ProjectElement
         internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject, SdkReference sdkReference = null)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
             ParsedSdkReference = sdkReference;
         }
 
@@ -169,7 +169,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateImportElement(this.Project);
+            return owner.CreateImportElement(Project);
         }
 
         /// <summary>
@@ -179,8 +179,7 @@ protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         /// <returns>True if the ParsedSdkReference was updated, otherwise false (no update necessary).</returns>
         private bool CheckUpdatedSdk()
         {
-
-            SdkReference sdk = new SdkReference(
+            var sdk = new SdkReference(
                 ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdk, true),
                 ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkVersion, true),
                 ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkMinimumVersion, true));
diff --git a/src/Build/Construction/ProjectImportGroupElement.cs b/src/Build/Construction/ProjectImportGroupElement.cs
index ada3bcc7ace..f72b94f69ba 100644
--- a/src/Build/Construction/ProjectImportGroupElement.cs
+++ b/src/Build/Construction/ProjectImportGroupElement.cs
@@ -5,17 +5,12 @@
 // <summary>Definition of ProjectImportGroupElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -32,7 +27,7 @@ public class ProjectImportGroupElement : ProjectElementContainer
         internal ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -50,13 +45,8 @@ private ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectRoot
         /// <summary>
         /// Get any contained properties.
         /// </summary>
-        public ICollection<ProjectImportElement> Imports
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectImportElement>(Children.OfType<ProjectImportElement>());
-            }
-        }
+        public ICollection<ProjectImportElement> Imports => new ReadOnlyCollection<ProjectImportElement>(Children.OfType<ProjectImportElement>());
+
         #endregion // Properties
 
         #region Methods
@@ -67,7 +57,7 @@ public ICollection<ProjectImportElement> Imports
         /// </summary>
         public ProjectImportElement AddImport(string project)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(project, "project");
+            ErrorUtilities.VerifyThrowArgumentLength(project, nameof(project));
 
             ProjectImportElement newImport = ContainingProject.CreateImportElement(project);
             AppendChild(newImport);
diff --git a/src/Build/Construction/ProjectItemDefinitionElement.cs b/src/Build/Construction/ProjectItemDefinitionElement.cs
index 14b1036e637..75e35b6525f 100644
--- a/src/Build/Construction/ProjectItemDefinitionElement.cs
+++ b/src/Build/Construction/ProjectItemDefinitionElement.cs
@@ -5,17 +5,13 @@
 // <summary>Definition of ProjectItemDefinitionElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Generic;
 using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -30,7 +26,7 @@ public class ProjectItemDefinitionElement : ProjectElementContainer
         internal ProjectItemDefinitionElement(XmlElement xmlElement, ProjectItemDefinitionGroupElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -44,21 +40,12 @@ private ProjectItemDefinitionElement(XmlElement xmlElement, ProjectRootElement c
         /// <summary>
         /// Gets the definition's type.
         /// </summary>
-        public string ItemType
-        {
-            get { return XmlElement.Name; }
-        }
+        public string ItemType => XmlElement.Name;
 
         /// <summary>
         /// Get any child metadata definitions.
         /// </summary>
-        public ICollection<ProjectMetadataElement> Metadata
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectMetadataElement>(Children.OfType<ProjectMetadataElement>());
-            }
-        }
+        public ICollection<ProjectMetadataElement> Metadata => new ReadOnlyCollection<ProjectMetadataElement>(Children.OfType<ProjectMetadataElement>());
 
         /// <summary>
         /// Convenience method to add a piece of metadata to this item definition.
@@ -66,8 +53,8 @@ public ICollection<ProjectMetadataElement> Metadata
         /// </summary>
         public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, "unevaluatedValue");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, nameof(unevaluatedValue));
 
             ProjectMetadataElement metadata = ContainingProject.CreateMetadataElement(name);
             metadata.Value = unevaluatedValue;
@@ -106,7 +93,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateItemDefinitionElement(this.ItemType);
+            return owner.CreateItemDefinitionElement(ItemType);
         }
     }
 }
diff --git a/src/Build/Construction/ProjectItemDefinitionGroupElement.cs b/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
index 69c0d69ae63..84dbff89fb0 100644
--- a/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
+++ b/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
@@ -5,17 +5,13 @@
 // <summary>Definition of ProjectItemDefinitionGroupElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Generic;
 using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -30,7 +26,7 @@ public class ProjectItemDefinitionGroupElement : ProjectElementContainer
         internal ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -44,13 +40,7 @@ private ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElem
         /// <summary>
         /// Get a list of child item definitions.
         /// </summary>
-        public ICollection<ProjectItemDefinitionElement> ItemDefinitions
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectItemDefinitionElement>(Children.OfType<ProjectItemDefinitionElement>());
-            }
-        }
+        public ICollection<ProjectItemDefinitionElement> ItemDefinitions => new ReadOnlyCollection<ProjectItemDefinitionElement>(Children.OfType<ProjectItemDefinitionElement>());
 
         /// <summary>
         /// Convenience method that picks a location based on a heuristic:
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index df4bf655619..941b6ce3c37 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -10,9 +10,7 @@
 using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Collections;
 
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
@@ -49,7 +47,7 @@ public class ProjectItemElement : ProjectElementContainer
         /// Whether the include value has wildcards, 
         /// cached for performance.
         /// </summary>
-        private bool? _includeHasWildcards = null;
+        private bool? _includeHasWildcards;
 
         /// <summary>
         /// Initialize a parented ProjectItemElement instance
@@ -57,7 +55,7 @@ public class ProjectItemElement : ProjectElementContainer
         internal ProjectItemElement(XmlElementWithLocation xmlElement, ProjectItemGroupElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -74,9 +72,8 @@ private ProjectItemElement(XmlElementWithLocation xmlElement, ProjectRootElement
         public string ItemType
         {
             [DebuggerStepThrough]
-            get
-            { return XmlElement.Name; }
-            set { ChangeItemType(value); }
+            get => XmlElement.Name;
+            set => ChangeItemType(value);
         }
 
         /// <summary>
@@ -90,12 +87,9 @@ public string Include
             get
             {
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
-                if (_include == null)
-                {
-                    _include = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.include);
-                }
-
-                return _include;
+                return _include ?? (_include = ProjectXmlUtilities.GetAttributeValue(
+                           XmlElement,
+                           XMakeAttributes.include));
             }
 
             set
@@ -119,12 +113,9 @@ public string Exclude
             get
             {
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
-                if (_exclude == null)
-                {
-                    _exclude = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.exclude);
-                }
-
-                return _exclude;
+                return _exclude ?? (_exclude = ProjectXmlUtilities.GetAttributeValue(
+                           XmlElement,
+                           XMakeAttributes.exclude));
             }
 
             set
@@ -148,12 +139,7 @@ public string Remove
             get
             {
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
-                if (_remove == null)
-                {
-                    _remove = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.remove);
-                }
-
-                return _remove;
+                return _remove ?? (_remove = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.remove));
             }
 
             set
@@ -174,12 +160,7 @@ public string Update
             get
             {
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
-                if (_update == null)
-                {
-                    _update = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.update);
-                }
-
-                return _update;
+                return _update ?? (_update = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.update));
             }
 
             set
@@ -312,7 +293,7 @@ internal bool IncludeHasWildcards
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
                 if (!_includeHasWildcards.HasValue)
                 {
-                    _includeHasWildcards = (Include == null) ? false : FileMatcher.HasWildcards(_include);
+                    _includeHasWildcards = (Include != null) && FileMatcher.HasWildcards(_include);
                 }
 
                 return _includeHasWildcards.Value;
@@ -360,12 +341,12 @@ public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue)
         /// </param>
         public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, "unevaluatedValue");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, nameof(unevaluatedValue));
 
             if (expressAsAttribute)
             {
-                ProjectMetadataElement.ValidateValidMetadataAsAttributeName(name, this.ElementName, this.Location);
+                ProjectMetadataElement.ValidateValidMetadataAsAttributeName(name, ElementName, Location);
             }
 
             ProjectMetadataElement metadata = ContainingProject.CreateMetadataElement(name);
@@ -413,13 +394,13 @@ internal static ProjectItemElement CreateDisconnected(string itemType, ProjectRo
         /// </remarks>
         internal void ChangeItemType(string newItemType)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(newItemType, "itemType");
+            ErrorUtilities.VerifyThrowArgumentLength(newItemType, nameof(newItemType));
             XmlUtilities.VerifyThrowArgumentValidElementName(newItemType);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(newItemType), "CannotModifyReservedItem", newItemType);
 
             // Because the element was created from our special XmlDocument, we know it's
             // an XmlElementWithLocation.
-            XmlElementWithLocation newElement = (XmlElementWithLocation)XmlUtilities.RenameXmlElement(XmlElement, newItemType, XmlElement.NamespaceURI);
+            XmlElementWithLocation newElement = XmlUtilities.RenameXmlElement(XmlElement, newItemType, XmlElement.NamespaceURI);
 
             ReplaceElement(newElement);
         }
@@ -445,8 +426,7 @@ internal override void OnAfterParentChanged(ProjectElementContainer parent)
             {
                 // This is our indication that we just got attached to a parent
                 // Update its children-with-wildcards flag
-                ProjectItemGroupElement groupParent = parent as ProjectItemGroupElement;
-                if (groupParent != null && groupParent.DefinitelyAreNoChildrenWithWildcards && IncludeHasWildcards)
+                if (parent is ProjectItemGroupElement groupParent && groupParent.DefinitelyAreNoChildrenWithWildcards && IncludeHasWildcards)
                 {
                     groupParent.DefinitelyAreNoChildrenWithWildcards = false;
                 }
@@ -456,7 +436,7 @@ internal override void OnAfterParentChanged(ProjectElementContainer parent)
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateItemElement(this.ItemType, this.Include);
+            return owner.CreateItemElement(ItemType, Include);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/ProjectItemGroupElement.cs b/src/Build/Construction/ProjectItemGroupElement.cs
index f347ff0bf22..64459eff711 100644
--- a/src/Build/Construction/ProjectItemGroupElement.cs
+++ b/src/Build/Construction/ProjectItemGroupElement.cs
@@ -7,15 +7,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -37,7 +33,7 @@ public class ProjectItemGroupElement : ProjectElementContainer
         internal ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -52,13 +48,7 @@ private ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectRootEl
         /// Get any child items.
         /// This is a live collection.
         /// </summary>
-        public ICollection<ProjectItemElement> Items
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectItemElement>(Children.OfType<ProjectItemElement>());
-            }
-        }
+        public ICollection<ProjectItemElement> Items => new ReadOnlyCollection<ProjectItemElement>(Children.OfType<ProjectItemElement>());
 
         /// <summary>
         /// True if it is known that no child items have wildcards in their
@@ -79,10 +69,7 @@ internal bool DefinitelyAreNoChildrenWithWildcards
                 return _definitelyAreNoChildrenWithWildcards;
             }
 
-            set
-            {
-                _definitelyAreNoChildrenWithWildcards = value;
-            }
+            set => _definitelyAreNoChildrenWithWildcards = value;
         }
 
         /// <summary>
@@ -101,8 +88,8 @@ public ProjectItemElement AddItem(string itemType, string include)
         /// </summary>
         public ProjectItemElement AddItem(string itemType, string include, IEnumerable<KeyValuePair<string, string>> metadata)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
-            ErrorUtilities.VerifyThrowArgumentLength(include, "include");
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowArgumentLength(include, nameof(include));
 
             // If there are no items, or it turns out that there are only items with 
             // item types that sort earlier, then we should go after the last child
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index 3924c32ae2f..81c57bfb32f 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -5,15 +5,9 @@
 // <summary>Definition of ProjectMetadataElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
-using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-using Utilities = Microsoft.Build.Internal.Utilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -28,7 +22,7 @@ public class ProjectMetadataElement : ProjectElement
         internal ProjectMetadataElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project)
             : base(xmlElement, parent, project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -44,8 +38,8 @@ private ProjectMetadataElement(XmlElementWithLocation xmlElement, ProjectRootEle
         /// </summary>
         public string Name
         {
-            get { return XmlElement.Name; }
-            set { ChangeName(value); }
+            get => XmlElement.Name;
+            set => ChangeName(value);
         }
 
         //  Add a new property with the same name here because this attribute should be public for ProjectMetadataElement,
@@ -59,12 +53,12 @@ public string Name
         /// </remarks>
         public new bool ExpressedAsAttribute
         {
-            get { return base.ExpressedAsAttribute; }
+            get => base.ExpressedAsAttribute;
             set
             {
                 if (value)
                 {
-                    ValidateValidMetadataAsAttributeName(this.Name, Parent?.ElementName ?? "null" , Parent?.Location);
+                    ValidateValidMetadataAsAttributeName(Name, Parent?.ElementName ?? "null" , Parent?.Location);
                 }
                 base.ExpressedAsAttribute = value;
             }
@@ -76,15 +70,12 @@ public string Name
         /// </summary>
         public string Value
         {
-            get
-            {
-                return Microsoft.Build.Internal.Utilities.GetXmlNodeInnerContents(XmlElement);
-            }
+            get => Internal.Utilities.GetXmlNodeInnerContents(XmlElement);
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "Value");
-                Microsoft.Build.Internal.Utilities.SetXmlNodeInnerContents(XmlElement, value);
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(Value));
+                Internal.Utilities.SetXmlNodeInnerContents(XmlElement, value);
                 Parent?.UpdateElementValue(this);
                 MarkDirty("Set metadata Value {0}", value);
             }
@@ -113,7 +104,7 @@ internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRo
         /// </remarks>
         internal void ChangeName(string newName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(newName, "newName");
+            ErrorUtilities.VerifyThrowArgumentLength(newName, nameof(newName));
             XmlUtilities.VerifyThrowArgumentValidElementName(newName);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(newName), "CannotModifyReservedItemMetadata", newName);
 
@@ -124,7 +115,7 @@ internal void ChangeName(string newName)
 
             // Because the element was created from our special XmlDocument, we know it's
             // an XmlElementWithLocation.
-            XmlElementWithLocation newElement = (XmlElementWithLocation)XmlUtilities.RenameXmlElement(XmlElement, newName, XmlElement.NamespaceURI);
+            XmlElementWithLocation newElement = XmlUtilities.RenameXmlElement(XmlElement, newName, XmlElement.NamespaceURI);
 
             ReplaceElement(newElement);
         }
@@ -139,10 +130,7 @@ internal static void ValidateValidMetadataAsAttributeName(string name, string pa
 
         internal static bool AttributeNameIsValidMetadataName(string name)
         {
-            bool isReservedAttributeName;
-            bool isValidMetadataNameInAttribute;
-
-            ProjectParser.CheckMetadataAsAttributeName(name, out isReservedAttributeName, out isValidMetadataNameInAttribute);
+            ProjectParser.CheckMetadataAsAttributeName(name, out bool isReservedAttributeName, out bool isValidMetadataNameInAttribute);
 
             return !isReservedAttributeName && isValidMetadataNameInAttribute;
         }
@@ -159,7 +147,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateMetadataElement(this.Name);
+            return owner.CreateMetadataElement(Name);
         }
     }
 }
diff --git a/src/Build/Construction/ProjectOnErrorElement.cs b/src/Build/Construction/ProjectOnErrorElement.cs
index a9dbe647eaa..7225ee89e66 100644
--- a/src/Build/Construction/ProjectOnErrorElement.cs
+++ b/src/Build/Construction/ProjectOnErrorElement.cs
@@ -5,12 +5,7 @@
 // <summary>Definition of ProjectOnErrorElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
-using System.Collections.Generic;
-using System.Xml;
-using System.Reflection;
 using System.Diagnostics;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
@@ -29,7 +24,7 @@ public class ProjectOnErrorElement : ProjectElement
         internal ProjectOnErrorElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement project)
             : base(xmlElement, parent, project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -66,10 +61,7 @@ public string ExecuteTargetsAttribute
         /// Location of the "ExecuteTargets" attribute on this element, if any.
         /// If there is no such attribute, returns null;
         /// </summary>
-        public ElementLocation ExecuteTargetsLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.executeTargets); }
-        }
+        public ElementLocation ExecuteTargetsLocation => XmlElement.GetAttributeLocation(XMakeAttributes.executeTargets);
 
         /// <summary>
         /// Creates an unparented ProjectOnErrorElement, wrapping an unparented XmlElement.
@@ -79,10 +71,8 @@ internal static ProjectOnErrorElement CreateDisconnected(string executeTargets,
         {
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.onError);
 
-            ProjectOnErrorElement onError = new ProjectOnErrorElement(element, containingProject);
-
-            onError.ExecuteTargetsAttribute = executeTargets;
-
+            var onError = new ProjectOnErrorElement(element, containingProject) { ExecuteTargetsAttribute = executeTargets };
+            
             return onError;
         }
 
@@ -98,7 +88,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateOnErrorElement(this.ExecuteTargetsAttribute);
+            return owner.CreateOnErrorElement(ExecuteTargetsAttribute);
         }
     }
 }
diff --git a/src/Build/Construction/ProjectOtherwiseElement.cs b/src/Build/Construction/ProjectOtherwiseElement.cs
index 9d75eb1537f..706e08b4a40 100644
--- a/src/Build/Construction/ProjectOtherwiseElement.cs
+++ b/src/Build/Construction/ProjectOtherwiseElement.cs
@@ -5,12 +5,9 @@
 // <summary>Definition of ProjectOtherwiseElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
@@ -28,7 +25,7 @@ public class ProjectOtherwiseElement : ProjectElementContainer
         internal ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project)
             : base(xmlElement, parent, project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -45,50 +42,26 @@ private ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectRootEl
         /// </summary>
         public override string Condition
         {
-            get
-            {
-                return null;
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
-            }
+            get => null;
+            set => ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
         }
 
         #region ChildEnumerators
         /// <summary>
         /// Get an enumerator over any child item groups
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroups
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
-            }
-        }
+        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
 
         /// <summary>
         /// Get an enumerator over any child property groups
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroups
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
-            }
-        }
+        public ICollection<ProjectPropertyGroupElement> PropertyGroups => new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
 
         /// <summary>
         /// Get an enumerator over any child chooses
         /// </summary>
-        public ICollection<ProjectChooseElement> ChooseElements
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());
-            }
-        }
+        public ICollection<ProjectChooseElement> ChooseElements => new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());
+
         #endregion
 
         /// <summary>
diff --git a/src/Build/Construction/ProjectOutputElement.cs b/src/Build/Construction/ProjectOutputElement.cs
index 74b118ff773..e46498958e3 100644
--- a/src/Build/Construction/ProjectOutputElement.cs
+++ b/src/Build/Construction/ProjectOutputElement.cs
@@ -6,10 +6,8 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Collections.Generic;
 using System.Xml;
 using System.Diagnostics;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
@@ -28,7 +26,7 @@ public class ProjectOutputElement : ProjectElement
         internal ProjectOutputElement(XmlElement xmlElement, ProjectTaskElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -54,7 +52,7 @@ public string TaskParameter
             [DebuggerStepThrough]
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(value, "value");
+                ErrorUtilities.VerifyThrowArgumentLength(value, nameof(value));
                 ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.taskParameter, value);
                 MarkDirty("Set Output TaskParameter {0}", value);
             }
@@ -63,18 +61,12 @@ public string TaskParameter
         /// <summary>
         /// Whether this represents an output item (as opposed to an output property)
         /// </summary>
-        public bool IsOutputItem
-        {
-            get { return ItemType.Length > 0; }
-        }
+        public bool IsOutputItem => ItemType.Length > 0;
 
         /// <summary>
         /// Whether this represents an output property (as opposed to an output item)
         /// </summary>
-        public bool IsOutputProperty
-        {
-            get { return PropertyName.Length > 0; }
-        }
+        public bool IsOutputProperty => PropertyName.Length > 0;
 
         /// <summary>
         /// Gets or sets the ItemType value. 
@@ -124,26 +116,17 @@ public string PropertyName
         /// <summary>
         /// Location of the task parameter attribute
         /// </summary>
-        public ElementLocation TaskParameterLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.taskParameter); }
-        }
+        public ElementLocation TaskParameterLocation => XmlElement.GetAttributeLocation(XMakeAttributes.taskParameter);
 
         /// <summary>
         /// Location of the property name attribute, if any
         /// </summary>
-        public ElementLocation PropertyNameLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.propertyName); }
-        }
+        public ElementLocation PropertyNameLocation => XmlElement.GetAttributeLocation(XMakeAttributes.propertyName);
 
         /// <summary>
         /// Location of the item type attribute, if any
         /// </summary>
-        public ElementLocation ItemTypeLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.itemName); }
-        }
+        public ElementLocation ItemTypeLocation => XmlElement.GetAttributeLocation(XMakeAttributes.itemName);
 
         /// <summary>
         /// Creates an unparented ProjectOutputElement, wrapping an unparented XmlElement.
@@ -164,9 +147,7 @@ internal static ProjectOutputElement CreateDisconnected(string taskParameter, st
 
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.output);
 
-            ProjectOutputElement output = new ProjectOutputElement(element, containingProject);
-
-            output.TaskParameter = taskParameter;
+            var output = new ProjectOutputElement(element, containingProject) { TaskParameter = taskParameter };
 
             if (!String.IsNullOrEmpty(itemType))
             {
@@ -192,7 +173,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateOutputElement(this.TaskParameter, this.ItemType, this.PropertyName);
+            return owner.CreateOutputElement(TaskParameter, ItemType, PropertyName);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Construction/ProjectPropertyElement.cs b/src/Build/Construction/ProjectPropertyElement.cs
index 7a926de7fd8..ba6b131b497 100644
--- a/src/Build/Construction/ProjectPropertyElement.cs
+++ b/src/Build/Construction/ProjectPropertyElement.cs
@@ -5,9 +5,6 @@
 // <summary>Definition of ProjectPropertyElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
-using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Internal;
@@ -32,7 +29,7 @@ public class ProjectPropertyElement : ProjectElement
         internal ProjectPropertyElement(XmlElementWithLocation xmlElement, ProjectPropertyGroupElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -48,8 +45,8 @@ private ProjectPropertyElement(XmlElementWithLocation xmlElement, ProjectRootEle
         /// </summary>
         public string Name
         {
-            get { return XmlElement.Name; }
-            set { ChangeName(value); }
+            get => XmlElement.Name;
+            set => ChangeName(value);
         }
 
         /// <summary>
@@ -58,19 +55,16 @@ public string Name
         /// </summary>
         public string Value
         {
-            get
-            {
-                return Microsoft.Build.Internal.Utilities.GetXmlNodeInnerContents(XmlElement);
-            }
+            get => Internal.Utilities.GetXmlNodeInnerContents(XmlElement);
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "Value");
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(Value));
 
                 // Visual Studio has a tendency to set properties to their existing value.
                 if (Value != value)
                 {
-                    Microsoft.Build.Internal.Utilities.SetXmlNodeInnerContents(XmlElement, value);
+                    Internal.Utilities.SetXmlNodeInnerContents(XmlElement, value);
                     MarkDirty("Set property Value {0}", value);
                 }
             }
@@ -100,13 +94,13 @@ internal static ProjectPropertyElement CreateDisconnected(string name, ProjectRo
         /// </remarks>
         internal void ChangeName(string newName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(newName, "newName");
+            ErrorUtilities.VerifyThrowArgumentLength(newName, nameof(newName));
             XmlUtilities.VerifyThrowArgumentValidElementName(newName);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(newName), "CannotModifyReservedProperty", newName);
 
             // Because the element was created from our special XmlDocument, we know it's
             // an XmlElementWithLocation.
-            XmlElementWithLocation newElement = (XmlElementWithLocation)XmlUtilities.RenameXmlElement(XmlElement, newName, XmlElement.NamespaceURI);
+            XmlElementWithLocation newElement = XmlUtilities.RenameXmlElement(XmlElement, newName, XmlElement.NamespaceURI);
 
             ReplaceElement(newElement);
         }
@@ -123,7 +117,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreatePropertyElement(this.Name);
+            return owner.CreatePropertyElement(Name);
         }
     }
 }
diff --git a/src/Build/Construction/ProjectPropertyGroupElement.cs b/src/Build/Construction/ProjectPropertyGroupElement.cs
index cd1164e0b64..c77aa3666f3 100644
--- a/src/Build/Construction/ProjectPropertyGroupElement.cs
+++ b/src/Build/Construction/ProjectPropertyGroupElement.cs
@@ -7,15 +7,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -30,7 +26,7 @@ public class ProjectPropertyGroupElement : ProjectElementContainer
         internal ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -44,24 +40,12 @@ private ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectRo
         /// <summary>
         /// Get any contained properties.
         /// </summary>
-        public ICollection<ProjectPropertyElement> Properties
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectPropertyElement>(Children.OfType<ProjectPropertyElement>());
-            }
-        }
+        public ICollection<ProjectPropertyElement> Properties => new ReadOnlyCollection<ProjectPropertyElement>(Children.OfType<ProjectPropertyElement>());
 
         /// <summary>
         /// Get any contained properties.
         /// </summary>
-        public ICollection<ProjectPropertyElement> PropertiesReversed
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectPropertyElement>(ChildrenReversed.OfType<ProjectPropertyElement>());
-            }
-        }
+        public ICollection<ProjectPropertyElement> PropertiesReversed => new ReadOnlyCollection<ProjectPropertyElement>(ChildrenReversed.OfType<ProjectPropertyElement>());
 
         /// <summary>
         /// Convenience method that picks a location based on a heuristic:
@@ -69,8 +53,8 @@ public ICollection<ProjectPropertyElement> PropertiesReversed
         /// </summary>
         public ProjectPropertyElement AddProperty(string name, string unevaluatedValue)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, "unevaluatedValue");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, nameof(unevaluatedValue));
 
             ProjectPropertyElement newProperty = ContainingProject.CreatePropertyElement(name);
             newProperty.Value = unevaluatedValue;
@@ -86,8 +70,8 @@ public ProjectPropertyElement AddProperty(string name, string unevaluatedValue)
         /// </summary>
         public ProjectPropertyElement SetProperty(string name, string unevaluatedValue)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, "unevaluatedValue");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, nameof(unevaluatedValue));
 
             foreach (ProjectPropertyElement property in Properties)
             {
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index fe5fad467a9..6cf94025b8d 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -16,7 +16,6 @@
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Xml;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
@@ -28,7 +27,6 @@
 using Microsoft.VisualStudio.Profiler;
 #endif
 #endif
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
@@ -91,22 +89,10 @@ public class ProjectRootElement : ProjectElementContainer
         /// Saving to or loading from a provided stream reader does not modify this value, only saving to or loading from disk.
         /// The actual value is meaningless (since the counter is shared with all projects) --
         /// it should only be compared to a stored value.
-        /// Immediately after loading from disk, this has the same value as <see cref="_version">version</see>.
+        /// Immediately after loading from disk, this has the same value as <see cref="Version">version</see>.
         /// </summary>
         private int _versionOnDisk;
 
-        /// <summary>
-        /// Current version number of this object.
-        /// Used to figure whether this object is dirty for saving, or projects evaluated from
-        /// this object need to be re-evaluated.
-        /// The actual value is meaningless (since the counter is shared with all projects) --
-        /// it should only be compared to a stored value.
-        /// </summary>
-        /// <remarks>
-        /// Set this only through <see cref="MarkDirty(string, string)"/>.
-        /// </remarks>
-        private int _version;
-
         /// <summary>
         /// The encoding of the project that was (if applicable) loaded off disk, and that will be used to save the project.
         /// </summary>
@@ -146,11 +132,6 @@ public class ProjectRootElement : ProjectElementContainer
         /// </summary>
         private DateTime _lastWriteTimeWhenRead;
 
-        /// <summary>
-        /// The cache in which this project root element is stored.
-        /// </summary>
-        private readonly ProjectRootElementCache _projectRootElementCache;
-
         /// <summary>
         /// Reason it was last marked dirty; unlocalized, for debugging
         /// </summary>
@@ -169,13 +150,12 @@ public class ProjectRootElement : ProjectElementContainer
         /// </summary>
         internal ProjectRootElement(XmlReader xmlReader, ProjectRootElementCache projectRootElementCache, bool isExplicitlyLoaded,
             bool preserveFormatting)
-            : base()
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xmlReader, "xmlReader");
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, "projectRootElementCache");
+            ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, nameof(projectRootElementCache));
 
-            this.IsExplicitlyLoaded = isExplicitlyLoaded;
-            _projectRootElementCache = projectRootElementCache;
+            IsExplicitlyLoaded = isExplicitlyLoaded;
+            ProjectRootElementCache = projectRootElementCache;
             _directory = NativeMethodsShared.GetCurrentDirectory();
             IncrementVersion();
 
@@ -190,16 +170,14 @@ internal ProjectRootElement(XmlReader xmlReader, ProjectRootElementCache project
         /// </summary>
         private ProjectRootElement(ProjectRootElementCache projectRootElementCache, NewProjectFileOptions projectFileOptions)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, "projectRootElementCache");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, nameof(projectRootElementCache));
 
-            _projectRootElementCache = projectRootElementCache;
+            ProjectRootElementCache = projectRootElementCache;
             _directory = NativeMethodsShared.GetCurrentDirectory();
             IncrementVersion();
 
-            XmlDocumentWithLocation document = new XmlDocumentWithLocation();
-
-            XmlReaderSettings xrs = new XmlReaderSettings();
-            xrs.DtdProcessing = DtdProcessing.Ignore;
+            var document = new XmlDocumentWithLocation();
+            var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
 
             var emptyProjectFile = string.Format(EmptyProjectFileContent,
                 (projectFileOptions & NewProjectFileOptions.IncludeXmlDeclaration) != 0 ? EmptyProjectFileXmlDeclaration : string.Empty,
@@ -221,15 +199,14 @@ private ProjectRootElement(ProjectRootElementCache projectRootElementCache, NewP
         /// </summary>
         private ProjectRootElement(string path, ProjectRootElementCache projectRootElementCache,
             bool preserveFormatting)
-            : base()
         {
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
             ErrorUtilities.VerifyThrowInternalRooted(path);
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, "projectRootElementCache");
-            _projectRootElementCache = projectRootElementCache;
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, nameof(projectRootElementCache));
+            ProjectRootElementCache = projectRootElementCache;
 
             IncrementVersion();
-            _versionOnDisk = _version;
+            _versionOnDisk = Version;
             _timeLastChangedUtc = DateTime.UtcNow;
 
             XmlDocumentWithLocation document = LoadDocument(path, preserveFormatting);
@@ -248,12 +225,11 @@ private ProjectRootElement(string path, ProjectRootElementCache projectRootEleme
         /// Do not make public: we do not wish to expose particular XML API's.
         /// </remarks>
         private ProjectRootElement(XmlDocumentWithLocation document, ProjectRootElementCache projectRootElementCache)
-            : base()
         {
-            ErrorUtilities.VerifyThrowArgumentNull(document, "document");
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, "projectRootElementCache");
+            ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache, nameof(projectRootElementCache));
 
-            _projectRootElementCache = projectRootElementCache;
+            ProjectRootElementCache = projectRootElementCache;
             _directory = NativeMethodsShared.GetCurrentDirectory();
             IncrementVersion();
 
@@ -268,7 +244,6 @@ private ProjectRootElement(XmlDocumentWithLocation document, ProjectRootElementC
         /// Do not make public: we do not wish to expose particular XML API's.
         /// </remarks>
         private ProjectRootElement(XmlDocumentWithLocation document)
-            : base()
         {
             ProjectParser.Parse(document, this);
         }
@@ -289,15 +264,8 @@ private ProjectRootElement(XmlDocumentWithLocation document)
         /// </summary>
         public override string Condition
         {
-            get
-            {
-                return null;
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
-            }
+            get => null;
+            set => ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
         }
 
         #region ChildEnumerators
@@ -411,14 +379,11 @@ public string DirectoryPath
         /// </remarks>
         public string FullPath
         {
-            get
-            {
-                return _projectFileLocation?.File;
-            }
+            get => _projectFileLocation?.File;
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(value, "value");
+                ErrorUtilities.VerifyThrowArgumentLength(value, nameof(value));
 
                 string oldFullPath = _projectFileLocation?.File;
 
@@ -441,11 +406,11 @@ public string FullPath
 
                 if (oldFullPath == null)
                 {
-                    _projectRootElementCache.AddEntry(this);
+                    ProjectRootElementCache.AddEntry(this);
                 }
                 else
                 {
-                    _projectRootElementCache.RenameEntry(oldFullPath, this);
+                    ProjectRootElementCache.RenameEntry(oldFullPath, this);
                 }
 
                 OnAfterProjectRename?.Invoke(oldFullPath);
@@ -468,7 +433,7 @@ public Encoding Encoding
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
                 if (_encoding == null)
                 {
-                    XmlDeclaration declaration = XmlDocument.FirstChild as XmlDeclaration;
+                    var declaration = XmlDocument.FirstChild as XmlDeclaration;
 
                     if (declaration?.Encoding.Length > 0)
                     {
@@ -595,9 +560,9 @@ public string RawXml
         {
             get
             {
-                using (StringWriter stringWriter = new EncodingStringWriter(Encoding))
+                using (var stringWriter = new EncodingStringWriter(Encoding))
                 {
-                    using (ProjectWriter projectWriter = new ProjectWriter(stringWriter))
+                    using (var projectWriter = new ProjectWriter(stringWriter))
                     {
                         projectWriter.Initialize(XmlDocument);
                         XmlDocument.Save(projectWriter);
@@ -638,7 +603,7 @@ public string RawXml
         /// 
         /// We're assuming we don't have over 2 billion edits.
         /// </remarks>
-        public int Version => _version;
+        public int Version { get; private set; }
 
         /// <summary>
         /// The time that this object was last changed. If it hasn't
@@ -709,16 +674,12 @@ public ElementLocation TreatAsLocalPropertyLocation
         /// Internal code that wants to set this to true should call <see cref="MarkAsExplicitlyLoaded"/>.
         /// The setter is private to make it more difficult to downgrade an existing PRE to an implicitly loaded state, which should never happen.
         /// </remarks>
-        internal bool IsExplicitlyLoaded
-        {
-            get;
-            private set;
-        }
+        internal bool IsExplicitlyLoaded { get; private set; }
 
         /// <summary>
         /// Retrieves the root element cache with which this root element is associated.
         /// </summary>
-        internal ProjectRootElementCache ProjectRootElementCache => _projectRootElementCache;
+        internal ProjectRootElementCache ProjectRootElementCache { get; }
 
         /// <summary>
         /// Gets a value indicating whether this PRE is known by its containing collection.
@@ -732,11 +693,7 @@ internal bool IsExplicitlyLoaded
         /// for targets without Returns attributes changes from using the Outputs to 
         /// returning nothing by default. 
         /// </summary>
-        internal bool ContainsTargetsWithReturnsAttribute
-        {
-            get;
-            set;
-        }
+        internal bool ContainsTargetsWithReturnsAttribute { get; set; }
 
         /// <summary>
         /// Gets the ProjectExtensions child, if any, otherwise null.
@@ -787,7 +744,7 @@ public static ProjectRootElement Create(ProjectCollection projectCollection)
         /// </summary>
         public static ProjectRootElement Create(ProjectCollection projectCollection, NewProjectFileOptions projectFileOptions)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, "projectCollection");
+            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
             return Create(projectCollection.ProjectRootElementCache, projectFileOptions);
         }
@@ -826,11 +783,12 @@ public static ProjectRootElement Create(string path, ProjectCollection projectCo
         /// </summary>
         public static ProjectRootElement Create(string path, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
-            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, "projectCollection");
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
+            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
-            ProjectRootElement projectRootElement = new ProjectRootElement(projectCollection.ProjectRootElementCache, newProjectFileOptions);
-            projectRootElement.FullPath = path;
+            var projectRootElement = new ProjectRootElement(
+                projectCollection.ProjectRootElementCache,
+                newProjectFileOptions) { FullPath = path };
 
             return projectRootElement;
         }
@@ -862,7 +820,7 @@ public static ProjectRootElement Create(XmlReader xmlReader, ProjectCollection p
         /// </summary>
         public static ProjectRootElement Create(XmlReader xmlReader, ProjectCollection projectCollection, bool preserveFormatting)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, "projectCollection");
+            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
             return new ProjectRootElement(xmlReader, projectCollection.ProjectRootElementCache, true /*Explicitly loaded*/,
                 preserveFormatting);
@@ -895,8 +853,8 @@ public static ProjectRootElement Open(string path, ProjectCollection projectColl
         /// </summary>
         public static ProjectRootElement Open(string path, ProjectCollection projectCollection, bool? preserveFormatting)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
-            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, "projectCollection");
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
+            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
             path = FileUtilities.NormalizePath(path);
 
@@ -915,7 +873,7 @@ public static ProjectRootElement Open(string path, ProjectCollection projectColl
         /// </remarks>
         public static ProjectRootElement TryOpen(string path)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
             return TryOpen(path, ProjectCollection.GlobalProjectCollection);
         }
@@ -952,8 +910,8 @@ public static ProjectRootElement TryOpen(string path, ProjectCollection projectC
         /// </remarks>
         public static ProjectRootElement TryOpen(string path, ProjectCollection projectCollection, bool? preserveFormatting)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
-            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, "projectCollection");
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
+            ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
             path = FileUtilities.NormalizePath(path);
 
@@ -969,7 +927,7 @@ public static ProjectRootElement TryOpen(string path, ProjectCollection projectC
         /// </summary>
         public ProjectImportElement AddImport(string project)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(project, "project");
+            ErrorUtilities.VerifyThrowArgumentLength(project, nameof(project));
 
             ProjectImportGroupElement importGroupToAddTo =
                 ImportGroupsReversed.FirstOrDefault(importGroup => importGroup.Condition.Length <= 0);
@@ -1103,7 +1061,7 @@ public ProjectItemGroupElement AddItemGroup()
         /// </summary>
         public ProjectItemDefinitionElement AddItemDefinition(string itemType)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
 
             ProjectItemDefinitionGroupElement itemDefinitionGroupToAddTo = null;
 
@@ -1548,7 +1506,7 @@ public void Save(Encoding saveEncoding)
                 // to force a save if the Encoding changed from UTF8 with BOM to UTF8 w/o BOM (for example).
                 if (HasUnsavedChanges || !Equals(saveEncoding, Encoding))
                 {
-                    using (ProjectWriter projectWriter = new ProjectWriter(_projectFileLocation.File, saveEncoding))
+                    using (var projectWriter = new ProjectWriter(_projectFileLocation.File, saveEncoding))
                     {
                         projectWriter.Initialize(XmlDocument);
                         XmlDocument.Save(projectWriter);
@@ -1611,7 +1569,7 @@ public void Save(string path, Encoding encoding)
         /// </summary>
         public void Save(TextWriter writer)
         {
-            using (ProjectWriter projectWriter = new ProjectWriter(writer))
+            using (var projectWriter = new ProjectWriter(writer))
             {
                 projectWriter.Initialize(XmlDocument);
                 XmlDocument.Save(projectWriter);
@@ -1626,7 +1584,7 @@ public void Save(TextWriter writer)
         /// <returns>The cloned element.</returns>
         public ProjectRootElement DeepClone()
         {
-            return (ProjectRootElement)this.DeepClone(this, null);
+            return (ProjectRootElement)DeepClone(this, null);
         }
 
         /// <summary>
@@ -1652,8 +1610,8 @@ public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? pre
         {
             ErrorUtilities.VerifyThrowInvalidOperation(File.Exists(path), "FileToReloadFromDoesNotExist", path);
 
-            Func<bool, XmlDocumentWithLocation> documentProducer = shouldPreserveFormatting => LoadDocument(path, shouldPreserveFormatting);
-            ReloadFrom(documentProducer, throwIfUnsavedChanges, preserveFormatting);
+            XmlDocumentWithLocation DocumentProducer(bool shouldPreserveFormatting) => LoadDocument(path, shouldPreserveFormatting);
+            ReloadFrom(DocumentProducer, throwIfUnsavedChanges, preserveFormatting);
         }
 
         /// <summary>
@@ -1677,16 +1635,16 @@ public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? pre
         /// </param>
         public void ReloadFrom(XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
         {
-            Func<bool, XmlDocumentWithLocation> documentProducer = shouldPreserveFormatting =>
+            XmlDocumentWithLocation DocumentProducer(bool shouldPreserveFormatting)
             {
-                var document =  LoadDocument(reader, shouldPreserveFormatting);
+                var document = LoadDocument(reader, shouldPreserveFormatting);
 
-                document.FullPath = this.FullPath;
+                document.FullPath = FullPath;
 
                 return document;
-            };
+            }
 
-            ReloadFrom(documentProducer, throwIfUnsavedChanges, preserveFormatting);
+            ReloadFrom(DocumentProducer, throwIfUnsavedChanges, preserveFormatting);
         }
 
         private void ReloadFrom(Func<bool, XmlDocumentWithLocation> documentProducer, bool throwIfUnsavedChanges, bool? preserveFormatting)
@@ -1703,7 +1661,7 @@ private void ReloadFrom(Func<bool, XmlDocumentWithLocation> documentProducer, bo
             // and thus most strings would get reused
             //this.XmlDocument.ClearAnyCachedStrings();
 
-            this.RemoveAllChildren();
+            RemoveAllChildren();
 
             ProjectParser.Parse(document, this);
 
@@ -1776,8 +1734,7 @@ internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDicti
 
             ProjectRootElement projectRootElement = projectRootElementCache.Get(
                 fullPath,
-                (path, cache) => CreateProjectFromPath(path, globalProperties, toolsVersion, cache,
-                                    preserveFormatting: false),
+                (path, cache) => CreateProjectFromPath(path, cache, preserveFormatting: false),
                 isExplicitlyLoaded,
                 // don't care about formatting, reuse whatever is there
                 preserveFormatting: null);
@@ -1824,13 +1781,13 @@ internal sealed override void MarkDirty(string reason, string param)
             _timeLastChangedUtc = DateTime.UtcNow;
 
             var changedEventArgs = new ProjectXmlChangedEventArgs(this, reason, param);
-            var projectXmlChanged = OnProjectXmlChanged;
+            EventHandler<ProjectXmlChangedEventArgs> projectXmlChanged = OnProjectXmlChanged;
             projectXmlChanged?.Invoke(this, changedEventArgs);
 
             // Only bubble this event up if the cache knows about this PRE.
-            if (this.IsMemberOfProjectCollection)
+            if (IsMemberOfProjectCollection)
             {
-                _projectRootElementCache.OnProjectRootElementDirtied(this, changedEventArgs);
+                ProjectRootElementCache.OnProjectRootElementDirtied(this, changedEventArgs);
             }
         }
 
@@ -1840,13 +1797,13 @@ internal sealed override void MarkDirty(string reason, string param)
         /// <param name="project">The dirtied project.</param>
         internal void MarkProjectDirty(Project project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
 
             // Only bubble this event up if the cache knows about this PRE, which is equivalent to
             // whether this PRE has a path.
             if (_projectFileLocation != null)
             {
-                _projectRootElementCache.OnProjectDirtied(project, new ProjectChangedEventArgs(project));
+                ProjectRootElementCache.OnProjectDirtied(project, new ProjectChangedEventArgs(project));
             }
         }
 
@@ -1897,9 +1854,7 @@ private static IEnumerable<SdkReference> ParseSdks(string sdks, IElementLocation
         {
             foreach (string sdk in sdks.Split(';').Select(i => i.Trim()))
             {
-                SdkReference sdkReference;
-
-                if (!SdkReference.TryParse(sdk, out sdkReference))
+                if (!SdkReference.TryParse(sdk, out SdkReference sdkReference))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(sdkLocation, "InvalidSdkFormat", sdks);
                 }
@@ -1970,7 +1925,7 @@ internal static bool IsEmptyXmlFile(string path)
         /// <param name="owner">The factory to use for creating the new instance.</param>
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return ProjectRootElement.Create(owner._projectRootElementCache);
+            return Create(owner.ProjectRootElementCache);
         }
 
         /// <summary>
@@ -2006,8 +1961,6 @@ private static ProjectRootElement OpenLoader(string path, ProjectRootElementCach
         private static ProjectRootElement CreateProjectFromPath
             (
                 string projectFile,
-                IDictionary<string, string> globalProperties,
-                string toolsVersion,
                 ProjectRootElementCache projectRootElementCache,
                 bool preserveFormatting
             )
@@ -2063,7 +2016,7 @@ private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveForma
                     string beginProjectLoad = String.Format(CultureInfo.CurrentCulture, "Load Project {0} From File - Start", fullPath);
                     DataCollection.CommentMarkProfile(8806, beginProjectLoad);
 #endif
-                    using (var xtr = XmlReaderExtension.Create(fullPath))
+                    using (XmlReaderExtension xtr = XmlReaderExtension.Create(fullPath))
                     {
                         _encoding = xtr.Encoding;
                         document.Load(xtr.Reader);
@@ -2086,11 +2039,7 @@ private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveForma
                         throw;
                     }
 
-                    XmlException xmlException = ex as XmlException;
-
-                    BuildEventFileInfo fileInfo;
-
-                    fileInfo = xmlException != null
+                    BuildEventFileInfo fileInfo = ex is XmlException xmlException
                         ? new BuildEventFileInfo(fullPath, xmlException)
                         : new BuildEventFileInfo(fullPath);
 
@@ -2113,7 +2062,7 @@ private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveForma
         /// May throw InvalidProjectFileException.
         /// Never returns null.
         /// </summary>
-        private XmlDocumentWithLocation LoadDocument(XmlReader reader, bool preserveFormatting)
+        private static XmlDocumentWithLocation LoadDocument(XmlReader reader, bool preserveFormatting)
         {
             var document = new XmlDocumentWithLocation {PreserveWhitespace = preserveFormatting};
 
@@ -2137,7 +2086,7 @@ private XmlDocumentWithLocation LoadDocument(XmlReader reader, bool preserveForm
         /// </summary>
         private void IncrementVersion()
         {
-            _version = Interlocked.Increment(ref s_globalVersionCounter);
+            Version = Interlocked.Increment(ref s_globalVersionCounter);
         }
 
         private void ThrowIfUnsavedChanges(bool throwIfUnsavedChanges)
diff --git a/src/Build/Construction/ProjectSdkElement.cs b/src/Build/Construction/ProjectSdkElement.cs
index f67f18026f2..c645668b44d 100644
--- a/src/Build/Construction/ProjectSdkElement.cs
+++ b/src/Build/Construction/ProjectSdkElement.cs
@@ -1,4 +1,11 @@
-using Microsoft.Build.Internal;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+//-----------------------------------------------------------------------
+// </copyright>
+// <summary>Definition of ProjectSdkElement class.</summary>
+//-----------------------------------------------------------------------
+
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Construction
@@ -15,7 +22,7 @@ internal ProjectSdkElement(XmlElementWithLocation xmlElement, ProjectRootElement
             ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -30,7 +37,7 @@ private ProjectSdkElement(XmlElementWithLocation xmlElement, ProjectRootElement
         /// </summary>
         public string Name
         {
-            get { return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkName); }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkName);
             set
             {
                 ErrorUtilities.VerifyThrowArgumentLength(value, XMakeAttributes.sdkName);
@@ -44,7 +51,7 @@ public string Name
         /// </summary>
         public string Version
         {
-            get { return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkVersion); }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkVersion);
             set
             {
                 ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.sdkVersion, value);
@@ -57,7 +64,7 @@ public string Version
         /// </summary>
         public string MinimumVersion
         {
-            get { return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkMinimumVersion); }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdkMinimumVersion);
             set
             {
                 ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.sdkMinimumVersion, value);
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index 0961314c1d0..f18157e6834 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -7,10 +7,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
@@ -36,7 +34,7 @@ public class ProjectTargetElement : ProjectElementContainer
         internal ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -51,46 +49,23 @@ private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootEleme
         /// <summary>
         /// Get an enumerator over any child item groups
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroups
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
-            }
-        }
+        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
 
         /// <summary>
         /// Get an enumerator over any child property groups
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroups
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
-            }
-        }
+        public ICollection<ProjectPropertyGroupElement> PropertyGroups => new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
 
         /// <summary>
         /// Get an enumerator over any child tasks
         /// </summary>
-        public ICollection<ProjectTaskElement> Tasks
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectTaskElement>(Children.OfType<ProjectTaskElement>());
-            }
-        }
+        public ICollection<ProjectTaskElement> Tasks => new ReadOnlyCollection<ProjectTaskElement>(Children.OfType<ProjectTaskElement>());
 
         /// <summary>
         /// Get an enumerator over any child onerrors
         /// </summary>
-        public ICollection<ProjectOnErrorElement> OnErrors
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectOnErrorElement>(Children.OfType<ProjectOnErrorElement>());
-            }
-        }
+        public ICollection<ProjectOnErrorElement> OnErrors => new ReadOnlyCollection<ProjectOnErrorElement>(Children.OfType<ProjectOnErrorElement>());
+
         #endregion
 
         /// <summary>
@@ -102,17 +77,13 @@ public string Name
             get
             {
                 // No thread-safety lock required here because many reader threads would set the same value to the field.
-                if (_name == null)
-                {
-                    _name = EscapingUtilities.UnescapeAll(ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.name));
-                }
-
-                return _name;
+                return _name ?? (_name = EscapingUtilities.UnescapeAll(
+                           ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.name)));
             }
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(value, "value");
+                ErrorUtilities.VerifyThrowArgumentLength(value, nameof(value));
 
                 string unescapedValue = EscapingUtilities.UnescapeAll(value);
 
@@ -308,26 +279,17 @@ public string Returns
         /// <summary>
         /// Location of the Name attribute
         /// </summary>
-        public ElementLocation NameLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.name); }
-        }
+        public ElementLocation NameLocation => XmlElement.GetAttributeLocation(XMakeAttributes.name);
 
         /// <summary>
         /// Location of the Inputs attribute
         /// </summary>
-        public ElementLocation InputsLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.inputs); }
-        }
+        public ElementLocation InputsLocation => XmlElement.GetAttributeLocation(XMakeAttributes.inputs);
 
         /// <summary>
         /// Location of the Outputs attribute
         /// </summary>
-        public ElementLocation OutputsLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.outputs); }
-        }
+        public ElementLocation OutputsLocation => XmlElement.GetAttributeLocation(XMakeAttributes.outputs);
 
         /// <summary>
         /// Location of the TrimDuplicateOutputs attribute
@@ -351,43 +313,27 @@ public ElementLocation KeepDuplicateOutputsLocation
         /// <summary>
         /// Location of the DependsOnTargets attribute
         /// </summary>
-        public ElementLocation DependsOnTargetsLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.dependsOnTargets); }
-        }
+        public ElementLocation DependsOnTargetsLocation => XmlElement.GetAttributeLocation(XMakeAttributes.dependsOnTargets);
 
         /// <summary>
         /// Location of the BeforeTargets attribute
         /// </summary>
-        public ElementLocation BeforeTargetsLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.beforeTargets); }
-        }
+        public ElementLocation BeforeTargetsLocation => XmlElement.GetAttributeLocation(XMakeAttributes.beforeTargets);
 
         /// <summary>
         /// Location of the Returns attribute
         /// </summary>
-        public ElementLocation ReturnsLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.returns); }
-        }
+        public ElementLocation ReturnsLocation => XmlElement.GetAttributeLocation(XMakeAttributes.returns);
 
         /// <summary>
         /// Location of the AfterTargets attribute
         /// </summary>
-        public ElementLocation AfterTargetsLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.afterTargets); }
-        }
+        public ElementLocation AfterTargetsLocation => XmlElement.GetAttributeLocation(XMakeAttributes.afterTargets);
 
         /// <summary>
         /// A cache of the last instance which was created from this target.
         /// </summary>
-        internal ProjectTargetInstance TargetInstance
-        {
-            get;
-            set;
-        }
+        internal ProjectTargetInstance TargetInstance { get; set; }
 
         /// <summary>
         /// Convenience method that picks a location based on a heuristic:
@@ -421,7 +367,7 @@ public ProjectPropertyGroupElement AddPropertyGroup()
         /// </summary>
         public ProjectTaskElement AddTask(string taskName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
 
             ProjectTaskElement task = ContainingProject.CreateTaskElement(taskName);
 
@@ -448,11 +394,7 @@ internal static ProjectTargetElement CreateDisconnected(string name, ProjectRoot
         {
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.target);
 
-            ProjectTargetElement target = new ProjectTargetElement(element, containingProject);
-
-            target.Name = name;
-
-            return target;
+            return new ProjectTargetElement(element, containingProject) { Name = name };
         }
 
         /// <summary>
@@ -476,7 +418,7 @@ internal override void MarkDirty(string reason, string param)
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateTargetElement(this.Name);
+            return owner.CreateTargetElement(Name);
         }
     }
 }
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index af13d3e4ff2..6f3fe43fd4d 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -11,7 +11,6 @@
 using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
@@ -33,7 +32,7 @@ public class ProjectTaskElement : ProjectElementContainer
         /// <summary>
         /// Protection for the parameters cache
         /// </summary>
-        private Object _locker = new Object();
+        private readonly Object _locker = new Object();
 
         /// <summary>
         /// Initialize a parented ProjectTaskElement
@@ -118,21 +117,12 @@ public string MSBuildArchitecture
         /// <summary>
         /// Gets the task name
         /// </summary>
-        public string Name
-        {
-            get { return XmlElement.Name; }
-        }
+        public string Name => XmlElement.Name;
 
         /// <summary>
         /// Gets any output children.
         /// </summary>
-        public ICollection<ProjectOutputElement> Outputs
-        {
-            get
-            {
-                return new Microsoft.Build.Collections.ReadOnlyCollection<ProjectOutputElement>(Children.OfType<ProjectOutputElement>());
-            }
-        }
+        public ICollection<ProjectOutputElement> Outputs => new Collections.ReadOnlyCollection<ProjectOutputElement>(Children.OfType<ProjectOutputElement>());
 
         /// <summary>
         /// Enumerable over the unevaluated parameters on the task.
@@ -148,9 +138,9 @@ public IDictionary<string, string> Parameters
                 {
                     EnsureParametersInitialized();
 
-                    Dictionary<string, string> parametersClone = new Dictionary<string, string>(_parameters.Count, StringComparer.OrdinalIgnoreCase);
+                    var parametersClone = new Dictionary<string, string>(_parameters.Count, StringComparer.OrdinalIgnoreCase);
 
-                    foreach (var entry in _parameters)
+                    foreach (KeyValuePair<string, Tuple<string, ElementLocation>> entry in _parameters)
                     {
                         parametersClone[entry.Key] = entry.Value.Item1;
                     }
@@ -176,7 +166,7 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
 
                     var parameterLocations = new List<KeyValuePair<string, ElementLocation>>();
 
-                    foreach (var entry in _parameters)
+                    foreach (KeyValuePair<string, Tuple<string, ElementLocation>> entry in _parameters)
                     {
                         parameterLocations.Add(new KeyValuePair<string, ElementLocation>(entry.Key, entry.Value.Item2));
                     }
@@ -190,28 +180,19 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
         /// Location of the "ContinueOnError" attribute on this element, if any.
         /// If there is no such attribute, returns null;
         /// </summary>
-        public ElementLocation ContinueOnErrorLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.continueOnError); }
-        }
+        public ElementLocation ContinueOnErrorLocation => XmlElement.GetAttributeLocation(XMakeAttributes.continueOnError);
 
         /// <summary>
         /// Location of the "MSBuildRuntime" attribute on this element, if any.
         /// If there is no such attribute, returns null;
         /// </summary>
-        public ElementLocation MSBuildRuntimeLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.msbuildRuntime); }
-        }
+        public ElementLocation MSBuildRuntimeLocation => XmlElement.GetAttributeLocation(XMakeAttributes.msbuildRuntime);
 
         /// <summary>
         /// Location of the "MSBuildArchitecture" attribute on this element, if any.
         /// If there is no such attribute, returns null;
         /// </summary>
-        public ElementLocation MSBuildArchitectureLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.msbuildArchitecture); }
-        }
+        public ElementLocation MSBuildArchitectureLocation => XmlElement.GetAttributeLocation(XMakeAttributes.msbuildArchitecture);
 
         /// <summary>
         /// Retrieves a copy of the parameters as used during evaluation.
@@ -235,8 +216,8 @@ internal CopyOnWriteDictionary<string, Tuple<string, ElementLocation>> Parameter
         /// </summary>
         public ProjectOutputElement AddOutputItem(string taskParameter, string itemType)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
+            ErrorUtilities.VerifyThrowArgumentLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
 
             return AddOutputItem(taskParameter, itemType, null);
         }
@@ -265,8 +246,8 @@ public ProjectOutputElement AddOutputItem(string taskParameter, string itemType,
         /// </summary>
         public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowArgumentLength(propertyName, "propertyName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
 
             return AddOutputProperty(taskParameter, propertyName, null);
         }
@@ -297,12 +278,11 @@ public string GetParameter(string name)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
                 EnsureParametersInitialized();
 
-                Tuple<string, ElementLocation> parameter;
-                if (_parameters.TryGetValue(name, out parameter))
+                if (_parameters.TryGetValue(name, out Tuple<string, ElementLocation> parameter))
                 {
                     return parameter.Item1;
                 }
@@ -318,8 +298,8 @@ public void SetParameter(string name, string unevaluatedValue)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-                ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, "unevaluatedValue");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+                ErrorUtilities.VerifyThrowArgumentNull(unevaluatedValue, nameof(unevaluatedValue));
                 ErrorUtilities.VerifyThrowArgument(!XMakeAttributes.IsSpecialTaskAttribute(name), "CannotAccessKnownAttributes", name);
 
                 _parameters = null;
@@ -382,7 +362,7 @@ public override void CopyFrom(ProjectElement element)
         /// </remarks>
         internal static ProjectTaskElement CreateDisconnected(string name, ProjectRootElement containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             XmlElementWithLocation element = containingProject.CreateElement(name);
 
@@ -401,7 +381,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateTaskElement(this.Name);
+            return owner.CreateTaskElement(Name);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/ProjectUsingTaskBodyElement.cs b/src/Build/Construction/ProjectUsingTaskBodyElement.cs
index f54a859ba6d..0d65cf45647 100644
--- a/src/Build/Construction/ProjectUsingTaskBodyElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskBodyElement.cs
@@ -5,14 +5,10 @@
 // <summary>Definition of ProjectUsingTaskBodyElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
-using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-using Utilities = Microsoft.Build.Internal.Utilities;
 
 namespace Microsoft.Build.Construction
 {
@@ -28,7 +24,7 @@ public class ProjectUsingTaskBodyElement : ProjectElement
         internal ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectUsingTaskElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
             VerifyCorrectParent(parent);
         }
 
@@ -46,15 +42,8 @@ private ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectRo
         /// </summary>
         public override string Condition
         {
-            get
-            {
-                return null;
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
-            }
+            get => null;
+            set => ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
         }
 
         /// <summary>
@@ -63,15 +52,12 @@ public override string Condition
         /// </summary>
         public string TaskBody
         {
-            get
-            {
-                return Microsoft.Build.Internal.Utilities.GetXmlNodeInnerContents(XmlElement);
-            }
+            get => Internal.Utilities.GetXmlNodeInnerContents(XmlElement);
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentNull(value, "TaskBody");
-                Microsoft.Build.Internal.Utilities.SetXmlNodeInnerContents(XmlElement, value);
+                ErrorUtilities.VerifyThrowArgumentNull(value, nameof(TaskBody));
+                Internal.Utilities.SetXmlNodeInnerContents(XmlElement, value);
                 MarkDirty("Set usingtask body {0}", value);
             }
         }
@@ -118,10 +104,7 @@ public override ElementLocation ConditionLocation
         /// If there is no such attribute, returns the location of the element,
         /// in lieu of the default value it uses for the attribute.
         /// </summary>
-        public ElementLocation EvaluateLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.evaluate) ?? Location; }
-        }
+        public ElementLocation EvaluateLocation => XmlElement.GetAttributeLocation(XMakeAttributes.evaluate) ?? Location;
 
         /// <summary>
         /// Creates an unparented ProjectUsingTaskBodyElement, wrapping an unparented XmlElement.
@@ -131,9 +114,11 @@ public ElementLocation EvaluateLocation
         internal static ProjectUsingTaskBodyElement CreateDisconnected(string evaluate, string body, ProjectRootElement containingProject)
         {
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.usingTaskBody);
-            ProjectUsingTaskBodyElement taskElement = new ProjectUsingTaskBodyElement(element, containingProject);
-            taskElement.Evaluate = evaluate;
-            taskElement.TaskBody = body;
+            var taskElement = new ProjectUsingTaskBodyElement(element, containingProject)
+            {
+                Evaluate = evaluate,
+                TaskBody = body
+            };
             return taskElement;
         }
 
@@ -149,7 +134,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateUsingTaskBodyElement(this.Evaluate, this.TaskBody);
+            return owner.CreateUsingTaskBodyElement(Evaluate, TaskBody);
         }
 
         /// <summary>
@@ -157,7 +142,7 @@ protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         /// </summary>
         private static void VerifyCorrectParent(ProjectElementContainer parent)
         {
-            ProjectUsingTaskElement parentUsingTask = parent as ProjectUsingTaskElement;
+            var parentUsingTask = parent as ProjectUsingTaskElement;
             ErrorUtilities.VerifyThrowInvalidOperation(parentUsingTask != null, "OM_CannotAcceptParent");
 
             // Since there is not going to be a TaskElement on the using task we need to validate and make sure there is a TaskFactory attribute on the parent element and 
diff --git a/src/Build/Construction/ProjectUsingTaskElement.cs b/src/Build/Construction/ProjectUsingTaskElement.cs
index f1e356ad35b..ea9ac10e9b5 100644
--- a/src/Build/Construction/ProjectUsingTaskElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskElement.cs
@@ -26,7 +26,7 @@ public class ProjectUsingTaskElement : ProjectElementContainer
         internal ProjectUsingTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -43,12 +43,8 @@ private ProjectUsingTaskElement(XmlElementWithLocation xmlElement, ProjectRootEl
         /// </summary>
         public string AssemblyFile
         {
-            get
-            {
-                return
-                    FileUtilities.FixFilePath(
-                        ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.assemblyFile));
-            }
+            get => FileUtilities.FixFilePath(
+                ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.assemblyFile));
 
             set
             {
@@ -66,10 +62,7 @@ public string AssemblyFile
         /// </summary>
         public string AssemblyName
         {
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.assemblyName);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.assemblyName);
 
             set
             {
@@ -85,10 +78,7 @@ public string AssemblyName
         /// </summary>
         public string TaskName
         {
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.taskName);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.taskName);
 
             set
             {
@@ -103,10 +93,7 @@ public string TaskName
         /// </summary>
         public string TaskFactory
         {
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.taskFactory);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.taskFactory);
 
             set
             {
@@ -120,10 +107,7 @@ public string TaskFactory
         /// </summary>
         public string Runtime
         {
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.runtime);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.runtime);
 
             set
             {
@@ -137,10 +121,7 @@ public string Runtime
         /// </summary>
         public string Architecture
         {
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.architecture);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.architecture);
 
             set
             {
@@ -156,7 +137,7 @@ public ProjectUsingTaskBodyElement TaskBody
         {
             get
             {
-                ProjectUsingTaskBodyElement body = (LastChild == null) ? null : LastChild as ProjectUsingTaskBodyElement;
+                ProjectUsingTaskBodyElement body = LastChild as ProjectUsingTaskBodyElement;
                 return body;
             }
         }
@@ -168,7 +149,7 @@ public UsingTaskParameterGroupElement ParameterGroup
         {
             get
             {
-                UsingTaskParameterGroupElement parameterGroup = (FirstChild == null) ? null : FirstChild as UsingTaskParameterGroupElement;
+                UsingTaskParameterGroupElement parameterGroup = FirstChild as UsingTaskParameterGroupElement;
                 return parameterGroup;
             }
         }
@@ -176,50 +157,32 @@ public UsingTaskParameterGroupElement ParameterGroup
         /// <summary>
         /// Location of the task name attribute
         /// </summary>
-        public ElementLocation TaskNameLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.taskName); }
-        }
+        public ElementLocation TaskNameLocation => XmlElement.GetAttributeLocation(XMakeAttributes.taskName);
 
         /// <summary>
         /// Location of the assembly file attribute, if any
         /// </summary>
-        public ElementLocation AssemblyFileLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.assemblyFile); }
-        }
+        public ElementLocation AssemblyFileLocation => XmlElement.GetAttributeLocation(XMakeAttributes.assemblyFile);
 
         /// <summary>
         /// Location of the assembly name attribute, if any
         /// </summary>
-        public ElementLocation AssemblyNameLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.assemblyName); }
-        }
+        public ElementLocation AssemblyNameLocation => XmlElement.GetAttributeLocation(XMakeAttributes.assemblyName);
 
         /// <summary>
         /// Location of the Runtime attribute, if any
         /// </summary>
-        public ElementLocation RuntimeLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.runtime); }
-        }
+        public ElementLocation RuntimeLocation => XmlElement.GetAttributeLocation(XMakeAttributes.runtime);
 
         /// <summary>
         /// Location of the Architecture attribute, if any
         /// </summary>
-        public ElementLocation ArchitectureLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.architecture); }
-        }
+        public ElementLocation ArchitectureLocation => XmlElement.GetAttributeLocation(XMakeAttributes.architecture);
 
         /// <summary>
         /// Location of the TaskFactory attribute, if any
         /// </summary>
-        public ElementLocation TaskFactoryLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.taskFactory); }
-        }
+        public ElementLocation TaskFactoryLocation => XmlElement.GetAttributeLocation(XMakeAttributes.taskFactory);
 
         /// <summary>
         /// Convenience method that picks a location based on a heuristic:
@@ -251,22 +214,21 @@ public ProjectUsingTaskBodyElement AddUsingTaskBody(string evaluate, string task
         /// </summary>
         internal static ProjectUsingTaskElement CreateDisconnected(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture, ProjectRootElement containingProject)
         {
-            ErrorUtilities.VerifyThrowArgument
-            (
-            (String.IsNullOrEmpty(assemblyFile) ^ String.IsNullOrEmpty(assemblyName)),
-            "OM_EitherAttributeButNotBoth",
-            XMakeElements.usingTask,
-            XMakeAttributes.assemblyFile,
-            XMakeAttributes.assemblyName
-            );
+            ErrorUtilities.VerifyThrowArgument(
+                (String.IsNullOrEmpty(assemblyFile) ^ String.IsNullOrEmpty(assemblyName)),
+                "OM_EitherAttributeButNotBoth",
+                XMakeElements.usingTask,
+                XMakeAttributes.assemblyFile,
+                XMakeAttributes.assemblyName);
 
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.usingTask);
 
-            ProjectUsingTaskElement usingTask = new ProjectUsingTaskElement(element, containingProject);
-
-            usingTask.TaskName = taskName;
-            usingTask.Runtime = runtime;
-            usingTask.Architecture = architecture;
+            var usingTask = new ProjectUsingTaskElement(element, containingProject)
+            {
+                TaskName = taskName,
+                Runtime = runtime,
+                Architecture = architecture
+            };
 
             if (!String.IsNullOrEmpty(assemblyFile))
             {
@@ -292,7 +254,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateUsingTaskElement(this.TaskName, this.AssemblyFile, this.AssemblyName, this.Runtime, this.Architecture);
+            return owner.CreateUsingTaskElement(TaskName, AssemblyFile, AssemblyName, Runtime, Architecture);
         }
     }
 }
diff --git a/src/Build/Construction/ProjectUsingTaskParameterElement.cs b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
index a91f679f22a..6c032444d62 100644
--- a/src/Build/Construction/ProjectUsingTaskParameterElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
@@ -6,8 +6,6 @@
 //-----------------------------------------------------------------------
 
 using System;
-using System.Collections.Generic;
-using System.Xml;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 
@@ -27,7 +25,7 @@ public class ProjectUsingTaskParameterElement : ProjectElement
         internal ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, UsingTaskParameterGroupElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -44,15 +42,8 @@ private ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, Proj
         /// </summary>
         public override string Condition
         {
-            get
-            {
-                return null;
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
-            }
+            get => null;
+            set => ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
         }
 
         /// <summary>
@@ -68,7 +59,7 @@ public string Name
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(value, "Name");
+                ErrorUtilities.VerifyThrowArgumentLength(value, nameof(Name));
                 ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.name, value);
                 MarkDirty("Set usingtaskparameter {0}", value);
             }
@@ -83,13 +74,7 @@ public string ParameterType
             get
             {
                 string typeAttribute = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.parameterType);
-
-                if (String.IsNullOrEmpty(typeAttribute))
-                {
-                    return typeof(String).FullName;
-                }
-
-                return typeAttribute;
+                return String.IsNullOrEmpty(typeAttribute) ? typeof(String).FullName : typeAttribute;
             }
 
             set
@@ -108,17 +93,12 @@ public string Output
             get
             {
                 string outputAttribute = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.output);
-                if (String.IsNullOrEmpty(outputAttribute))
-                {
-                    return bool.FalseString;
-                }
-
-                return outputAttribute;
+                return String.IsNullOrEmpty(outputAttribute) ? bool.FalseString : outputAttribute;
             }
 
             set
             {
-                XmlAttribute typeAttribute = ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.output, value);
+                ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.output, value);
                 MarkDirty("Set usingtaskparameter Output {0}", value);
             }
         }
@@ -131,17 +111,12 @@ public string Required
             get
             {
                 string requiredAttribute = ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.required);
-                if (String.IsNullOrEmpty(requiredAttribute))
-                {
-                    return bool.FalseString;
-                }
-
-                return requiredAttribute;
+                return String.IsNullOrEmpty(requiredAttribute) ? bool.FalseString : requiredAttribute;
             }
 
             set
             {
-                XmlAttribute typeAttribute = ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.required, value);
+                ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, XMakeAttributes.required, value);
                 MarkDirty("Set usingtaskparameter Required {0}", value);
             }
         }
@@ -163,30 +138,21 @@ public override ElementLocation ConditionLocation
         /// If there is no such attribute, returns the location of the element,
         /// in lieu of the default value it uses for the attribute.
         /// </summary>
-        public ElementLocation ParameterTypeLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.parameterType) ?? Location; }
-        }
+        public ElementLocation ParameterTypeLocation => XmlElement.GetAttributeLocation(XMakeAttributes.parameterType) ?? Location;
 
         /// <summary>
         /// Location of the Output attribute.
         /// If there is no such attribute, returns the location of the element,
         /// in lieu of the default value it uses for the attribute.
         /// </summary>
-        public ElementLocation OutputLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.output) ?? Location; }
-        }
+        public ElementLocation OutputLocation => XmlElement.GetAttributeLocation(XMakeAttributes.output) ?? Location;
 
         /// <summary>
         /// Location of the Required attribute.
         /// If there is no such attribute, returns the location of the element,
         /// in lieu of the default value it uses for the attribute.
         /// </summary>
-        public ElementLocation RequiredLocation
-        {
-            get { return XmlElement.GetAttributeLocation(XMakeAttributes.required) ?? Location; }
-        }
+        public ElementLocation RequiredLocation => XmlElement.GetAttributeLocation(XMakeAttributes.required) ?? Location;
 
         /// <summary>
         /// Creates an unparented UsingTaskParameterElement, wrapping an unparented XmlElement.
@@ -196,10 +162,13 @@ internal static ProjectUsingTaskParameterElement CreateDisconnected(string param
         {
             XmlUtilities.VerifyThrowArgumentValidElementName(parameterName);
             XmlElementWithLocation element = containingProject.CreateElement(parameterName);
-            ProjectUsingTaskParameterElement parameter = new ProjectUsingTaskParameterElement(element, containingProject);
-            parameter.Output = output;
-            parameter.Required = required;
-            parameter.ParameterType = parameterType;
+            var parameter =
+                new ProjectUsingTaskParameterElement(element, containingProject)
+                {
+                    Output = output,
+                    Required = required,
+                    ParameterType = parameterType
+                };
 
             return parameter;
         }
@@ -216,7 +185,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateUsingTaskParameterElement(this.Name, this.Output, this.Required, this.ParameterType);
+            return owner.CreateUsingTaskParameterElement(Name, Output, Required, ParameterType);
         }
     }
 }
diff --git a/src/Build/Construction/ProjectWhenElement.cs b/src/Build/Construction/ProjectWhenElement.cs
index 0e120517682..514244a84d1 100644
--- a/src/Build/Construction/ProjectWhenElement.cs
+++ b/src/Build/Construction/ProjectWhenElement.cs
@@ -5,17 +5,13 @@
 // <summary>Definition of ProjectWhenElement class.</summary>
 //-----------------------------------------------------------------------
 
-using System;
 using System.Collections.Generic;
 using System.Xml;
 using System.Diagnostics;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -30,7 +26,7 @@ public class ProjectWhenElement : ProjectElementContainer
         internal ProjectWhenElement(XmlElement xmlElement, ProjectChooseElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -45,35 +41,18 @@ private ProjectWhenElement(XmlElement xmlElement, ProjectRootElement containingP
         /// <summary>
         /// Get an enumerator over any child chooses
         /// </summary>
-        public ICollection<ProjectChooseElement> ChooseElements
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());
-            }
-        }
+        public ICollection<ProjectChooseElement> ChooseElements => new ReadOnlyCollection<ProjectChooseElement>(Children.OfType<ProjectChooseElement>());
 
         /// <summary>
         /// Get an enumerator over any child item groups
         /// </summary>
-        public ICollection<ProjectItemGroupElement> ItemGroups
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
-            }
-        }
+        public ICollection<ProjectItemGroupElement> ItemGroups => new ReadOnlyCollection<ProjectItemGroupElement>(Children.OfType<ProjectItemGroupElement>());
 
         /// <summary>
         /// Get an enumerator over any child property groups
         /// </summary>
-        public ICollection<ProjectPropertyGroupElement> PropertyGroups
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
-            }
-        }
+        public ICollection<ProjectPropertyGroupElement> PropertyGroups => new ReadOnlyCollection<ProjectPropertyGroupElement>(Children.OfType<ProjectPropertyGroupElement>());
+
         #endregion
 
         /// <summary>
@@ -84,8 +63,7 @@ internal static ProjectWhenElement CreateDisconnected(string condition, ProjectR
         {
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.when);
 
-            ProjectWhenElement when = new ProjectWhenElement(element, containingProject);
-            when.Condition = condition;
+            var when = new ProjectWhenElement(element, containingProject) { Condition = condition };
 
             return when;
         }
@@ -103,7 +81,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// <inheritdoc />
         protected override ProjectElement CreateNewInstance(ProjectRootElement owner)
         {
-            return owner.CreateWhenElement(this.Condition);
+            return owner.CreateWhenElement(Condition);
         }
     }
 }
diff --git a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
index c48e409102a..b538d421531 100644
--- a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
@@ -14,68 +14,37 @@ namespace Microsoft.Build.Construction
     /// </summary>
     public sealed class ProjectConfigurationInSolution
     {
-        /// <summary>
-        /// The configuration part of this configuration - e.g. "Debug", "Release"
-        /// </summary>
-        private string _configurationName;
-
-        /// <summary>
-        /// The platform part of this configuration - e.g. "Any CPU", "Win32"
-        /// </summary>
-        private string _platformName;
-
-        /// <summary>
-        /// The full name of this configuration - e.g. "Debug|Any CPU"
-        /// </summary>
-        private string _fullName;
-
-        /// <summary>
-        /// True if this project configuration should be built as part of its parent solution configuration
-        /// </summary>
-        private bool _includeInBuild;
 
         /// <summary>
         /// Constructor
         /// </summary>
         internal ProjectConfigurationInSolution(string configurationName, string platformName, bool includeInBuild)
         {
-            _configurationName = configurationName;
-            _platformName = RemoveSpaceFromAnyCpuPlatform(platformName);
-            _includeInBuild = includeInBuild;
-            _fullName = SolutionConfigurationInSolution.ComputeFullName(_configurationName, _platformName);
+            ConfigurationName = configurationName;
+            PlatformName = RemoveSpaceFromAnyCpuPlatform(platformName);
+            IncludeInBuild = includeInBuild;
+            FullName = SolutionConfigurationInSolution.ComputeFullName(ConfigurationName, PlatformName);
         }
 
         /// <summary>
         /// The configuration part of this configuration - e.g. "Debug", "Release"
         /// </summary>
-        public string ConfigurationName
-        {
-            get { return _configurationName; }
-        }
+        public string ConfigurationName { get; }
 
         /// <summary>
         /// The platform part of this configuration - e.g. "Any CPU", "Win32"
         /// </summary>
-        public string PlatformName
-        {
-            get { return _platformName; }
-        }
+        public string PlatformName { get; }
 
         /// <summary>
         /// The full name of this configuration - e.g. "Debug|Any CPU"
         /// </summary>
-        public string FullName
-        {
-            get { return _fullName; }
-        }
+        public string FullName { get; }
 
         /// <summary>
         /// True if this project configuration should be built as part of its parent solution configuration
         /// </summary>
-        public bool IncludeInBuild
-        {
-            get { return _includeInBuild; }
-        }
+        public bool IncludeInBuild { get; }
 
         /// <summary>
         /// This is a hacky method to remove the space in the "Any CPU" platform in project configurations.
@@ -85,7 +54,7 @@ public bool IncludeInBuild
         /// they have no clue what we're talking about. We need to remove the space in project platforms so that
         /// the platform name matches the one used in projects.
         /// </summary>
-        static private string RemoveSpaceFromAnyCpuPlatform(string platformName)
+        private static string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
             if (string.Compare(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
             {
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 86017c0f461..3ea27d063cf 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -92,29 +92,17 @@ public sealed class ProjectInSolution
         private const char cleanCharacter = '_';
 
         #endregion
-
         #region Member data
-
-        private SolutionProjectType _projectType;      // For example, KnownToBeMSBuildFormat, VCProject, WebProject, etc.
-        private string _projectName;          // For example, "WindowsApplication1"
         private string _relativePath;         // Relative from .SLN file.  For example, "WindowsApplication1\WindowsApplication1.csproj"
-        private string _projectGuid;          // The unique Guid assigned to this project or SLN folder.
-        private List<string> _dependencies;     // A list of strings representing the Guids of the dependent projects.
-        private ArrayList _projectReferences; // A list of strings representing the guids of referenced projects.
-                                              // This is only used for VC/Venus projects
-        private string _parentProjectGuid;    // If this project (or SLN folder) is within a SLN folder, this is the Guid of the parent SLN folder.
+        private readonly List<string> _dependencies;     // A list of strings representing the Guids of the dependent projects.
         private string _uniqueProjectName;    // For example, "MySlnFolder\MySubSlnFolder\WindowsApplication1"
-        private Hashtable _aspNetConfigurations;    // Key is configuration name, value is [struct] AspNetCompilerParameters
-        private SolutionFile _parentSolution; // The parent solution for this project
-        private string _targetFrameworkMoniker; // used for website projects, since they don't have a project file in which the
-                                                // target framework is stored.  Defaults to .NETFX 3.5
 
         /// <summary>
         /// The project configuration in given solution configuration
         /// K: full solution configuration name (cfg + platform)
         /// V: project configuration 
         /// </summary>
-        private Dictionary<string, ProjectConfigurationInSolution> _projectConfigurations;
+        private readonly Dictionary<string, ProjectConfigurationInSolution> _projectConfigurations;
 
         #endregion
 
@@ -122,21 +110,21 @@ public sealed class ProjectInSolution
 
         internal ProjectInSolution(SolutionFile solution)
         {
-            _projectType = SolutionProjectType.Unknown;
-            _projectName = null;
+            ProjectType = SolutionProjectType.Unknown;
+            ProjectName = null;
             _relativePath = null;
-            _projectGuid = null;
+            ProjectGuid = null;
             _dependencies = new List<string>();
-            _projectReferences = new ArrayList();
-            _parentProjectGuid = null;
+            ProjectReferences = new ArrayList();
+            ParentProjectGuid = null;
             _uniqueProjectName = null;
-            _parentSolution = solution;
+            ParentSolution = solution;
 
             // default to .NET Framework 3.5 if this is an old solution that doesn't explicitly say.
-            _targetFrameworkMoniker = ".NETFramework,Version=v3.5";
+            TargetFrameworkMoniker = ".NETFramework,Version=v3.5";
 
             // This hashtable stores a AspNetCompilerParameters struct for each configuration name supported.
-            _aspNetConfigurations = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            AspNetConfigurations = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
             _projectConfigurations = new Dictionary<string, ProjectConfigurationInSolution>(StringComparer.OrdinalIgnoreCase);
         }
@@ -148,11 +136,7 @@ internal ProjectInSolution(SolutionFile solution)
         /// <summary>
         /// This project's name
         /// </summary>
-        public string ProjectName
-        {
-            get { return _projectName; }
-            internal set { _projectName = value; }
-        }
+        public string ProjectName { get; internal set; }
 
         /// <summary>
         /// The path to this project file, relative to the solution location
@@ -168,7 +152,7 @@ internal set
                 _relativePath = value;
 #else
                 _relativePath = FileUtilities.MaybeAdjustFilePath(value,
-                                                    baseDirectory:this.ParentSolution.SolutionFileDirectory ?? String.Empty);
+                                                    baseDirectory:ParentSolution.SolutionFileDirectory ?? String.Empty);
 #endif
             }
         }
@@ -176,103 +160,60 @@ internal set
         /// <summary>
         /// Returns the absolute path for this project
         /// </summary>
-        public string AbsolutePath
-        {
-            get
-            {
-                return Path.Combine(this.ParentSolution.SolutionFileDirectory, this.RelativePath);
-            }
-        }
+        public string AbsolutePath => Path.Combine(ParentSolution.SolutionFileDirectory, RelativePath);
 
         /// <summary>
         /// The unique guid associated with this project, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
         /// </summary>
-        public string ProjectGuid
-        {
-            get { return _projectGuid; }
-            internal set { _projectGuid = value; }
-        }
+        public string ProjectGuid { get; internal set; }
 
         /// <summary>
         /// The guid, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, of this project's 
         /// parent project, if any. 
         /// </summary>
-        public string ParentProjectGuid
-        {
-            get { return _parentProjectGuid; }
-            internal set { _parentProjectGuid = value; }
-        }
+        public string ParentProjectGuid { get; internal set; }
 
         /// <summary>
         /// List of guids, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, mapping to projects 
         /// that this project has a build order dependency on, as defined in the solution file. 
         /// </summary>
-        public IReadOnlyList<string> Dependencies
-        {
-            get { return _dependencies.AsReadOnly(); }
-        }
+        public IReadOnlyList<string> Dependencies => _dependencies.AsReadOnly();
 
         /// <summary>
         /// Configurations for this project, keyed off the configuration's full name, e.g. "Debug|x86"
         /// </summary>
-        public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfigurations
-        {
-            get { return new ReadOnlyDictionary<string, ProjectConfigurationInSolution>(_projectConfigurations); }
-        }
+        public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfigurations =>
+            new ReadOnlyDictionary<string, ProjectConfigurationInSolution>(_projectConfigurations);
 
         /// <summary>
         /// Extension of the project file, if any
         /// </summary>
-        internal string Extension
-        {
-            get
-            {
-                return Path.GetExtension(_relativePath);
-            }
-        }
+        internal string Extension => Path.GetExtension(_relativePath);
 
         /// <summary>
         /// This project's type.
         /// </summary>
-        public SolutionProjectType ProjectType
-        {
-            get { return _projectType; }
-            set { _projectType = value; }
-        }
+        public SolutionProjectType ProjectType { get; set; }
 
         /// <summary>
         /// Only applies to websites -- for other project types, references are 
         /// either specified as Dependencies above, or as ProjectReferences in the
         /// project file, which the solution doesn't have insight into. 
         /// </summary>
-        internal ArrayList ProjectReferences
-        {
-            get { return _projectReferences; }
-        }
+        internal ArrayList ProjectReferences { get; }
 
-        internal SolutionFile ParentSolution
-        {
-            get { return _parentSolution; }
-            set { _parentSolution = value; }
-        }
+        internal SolutionFile ParentSolution { get; set; }
 
-        internal Hashtable AspNetConfigurations
-        {
-            get { return _aspNetConfigurations; }
-            set { _aspNetConfigurations = value; }
-        }
+        // Key is configuration name, value is [struct] AspNetCompilerParameters
+        internal Hashtable AspNetConfigurations { get; set; }
 
-        internal string TargetFrameworkMoniker
-        {
-            get { return _targetFrameworkMoniker; }
-            set { _targetFrameworkMoniker = value; }
-        }
+        internal string TargetFrameworkMoniker { get; set; }
 
         #endregion
 
         #region Methods
 
-        private bool _checkedIfCanBeMSBuildProjectFile = false;
+        private bool _checkedIfCanBeMSBuildProjectFile;
         private bool _canBeMSBuildProjectFile;
         private string _canBeMSBuildProjectFileErrorMessage;
 
@@ -313,12 +254,10 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
             try
             {
                 // Read project thru a XmlReader with proper setting to avoid DTD processing
-                XmlReaderSettings xrSettings = new XmlReaderSettings();
-                xrSettings.DtdProcessing = DtdProcessing.Ignore;
-
-                XmlDocument projectDocument = new XmlDocument();
+                var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                var projectDocument = new XmlDocument();
 
-                using (XmlReader xmlReader = XmlReader.Create(this.AbsolutePath, xrSettings))
+                using (XmlReader xmlReader = XmlReader.Create(AbsolutePath, xrSettings))
                 {
                     // Load the project file and get the first node    
                     projectDocument.Load(xmlReader);
@@ -407,9 +346,9 @@ internal string GetUniqueProjectName()
             if (_uniqueProjectName == null)
             {
                 // EtpSubProject and Venus projects have names that are already unique.  No need to prepend the SLN folder.
-                if ((this.ProjectType == SolutionProjectType.WebProject) || (this.ProjectType == SolutionProjectType.EtpSubProject))
+                if ((ProjectType == SolutionProjectType.WebProject) || (ProjectType == SolutionProjectType.EtpSubProject))
                 {
-                    _uniqueProjectName = CleanseProjectName(this.ProjectName);
+                    _uniqueProjectName = CleanseProjectName(ProjectName);
                 }
                 else
                 {
@@ -419,20 +358,19 @@ internal string GetUniqueProjectName()
                     // and tack on trailing backslash.
                     string uniqueName = String.Empty;
 
-                    if (this.ParentProjectGuid != null)
+                    if (ParentProjectGuid != null)
                     {
-                        ProjectInSolution proj;
-                        if (!this.ParentSolution.ProjectsByGuid.TryGetValue(this.ParentProjectGuid, out proj))
+                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution proj))
                         {
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null, "SubCategoryForSolutionParsingErrors",
-                                new BuildEventFileInfo(_parentSolution.FullPath), "SolutionParseNestedProjectError");
+                                new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectError");
                         }
 
                         uniqueName = proj.GetUniqueProjectName() + "\\";
                     }
 
                     // Now tack on our own project name, and cache it in the ProjectInSolution object for future quick access.
-                    _uniqueProjectName = CleanseProjectName(uniqueName + this.ProjectName);
+                    _uniqueProjectName = CleanseProjectName(uniqueName + ProjectName);
                 }
             }
 
@@ -444,7 +382,7 @@ internal string GetUniqueProjectName()
         /// </summary>
         internal void UpdateUniqueProjectName(string newUniqueName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(newUniqueName, "newUniqueName");
+            ErrorUtilities.VerifyThrowArgumentLength(newUniqueName, nameof(newUniqueName));
 
             _uniqueProjectName = newUniqueName;
         }
@@ -454,7 +392,7 @@ internal void UpdateUniqueProjectName(string newUniqueName)
         /// </summary>
         /// <param name="projectName">The name to be cleansed</param>
         /// <returns>string</returns>
-        static private string CleanseProjectName(string projectName)
+        private static string CleanseProjectName(string projectName)
         {
             ErrorUtilities.VerifyThrow(projectName != null, "Null strings not allowed.");
 
@@ -467,7 +405,7 @@ static private string CleanseProjectName(string projectName)
             }
 
             // This is where we're going to work on the final string to return to the caller.
-            StringBuilder cleanProjectName = new StringBuilder(projectName);
+            var cleanProjectName = new StringBuilder(projectName);
 
             // Replace each unclean character with a clean one            
             foreach (char uncleanChar in s_charsToCleanse)
@@ -484,7 +422,7 @@ static private string CleanseProjectName(string projectName)
         /// </summary>
         /// <param name="uniqueProjectName">The unique name for the project</param>
         /// <returns>string</returns>
-        static internal string DisambiguateProjectTargetName(string uniqueProjectName)
+        internal static string DisambiguateProjectTargetName(string uniqueProjectName)
         {
             // Test our unique project name against those names that collide with Solution
             // entry point targets
diff --git a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
index edbecbfc148..243bbd48daf 100644
--- a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
@@ -5,9 +5,6 @@
 // <summary>Represents a solution configuration (e.g. "Debug|x86")</summary>
 //-----------------------------------------------------------------------
 
-using System;
-using System.Globalization;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -21,54 +18,30 @@ public sealed class SolutionConfigurationInSolution
         /// </summary>
         internal const char ConfigurationPlatformSeparator = '|';
 
-        /// <summary>
-        /// The configuration part of this configuration - e.g. "Debug", "Release"
-        /// </summary>
-        private string _configurationName;
-
-        /// <summary>
-        /// The platform part of this configuration - e.g. "Any CPU", "Win32"
-        /// </summary>
-        private string _platformName;
-
-        /// <summary>
-        /// The full name of this configuration - e.g. "Debug|Any CPU"
-        /// </summary>
-        private string _fullName;
-
         /// <summary>
         /// Constructor
         /// </summary>
         internal SolutionConfigurationInSolution(string configurationName, string platformName)
         {
-            _configurationName = configurationName;
-            _platformName = platformName;
-            _fullName = ComputeFullName(configurationName, platformName);
+            ConfigurationName = configurationName;
+            PlatformName = platformName;
+            FullName = ComputeFullName(configurationName, platformName);
         }
 
         /// <summary>
         /// The configuration part of this configuration - e.g. "Debug", "Release"
         /// </summary>
-        public string ConfigurationName
-        {
-            get { return _configurationName; }
-        }
+        public string ConfigurationName { get; }
 
         /// <summary>
         /// The platform part of this configuration - e.g. "Any CPU", "Win32"
         /// </summary>
-        public string PlatformName
-        {
-            get { return _platformName; }
-        }
+        public string PlatformName { get; }
 
         /// <summary>
         /// The full name of this configuration - e.g. "Debug|Any CPU"
         /// </summary>
-        public string FullName
-        {
-            get { return _fullName; }
-        }
+        public string FullName { get; }
 
         /// <summary>
         /// Given a configuration name and a platform name, compute the full name 
@@ -77,14 +50,11 @@ public string FullName
         internal static string ComputeFullName(string configurationName, string platformName)
         {
             // Some configurations don't have the platform part
-            if ((platformName != null) && (platformName.Length > 0))
-            {
-                return String.Format(CultureInfo.InvariantCulture, "{0}{1}{2}", configurationName, ConfigurationPlatformSeparator, platformName);
-            }
-            else
+            if (!string.IsNullOrEmpty(platformName))
             {
-                return configurationName;
+                return $"{configurationName}{ConfigurationPlatformSeparator}{platformName}";
             }
+            return configurationName;
         }
     }
 }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 7afbc2dccd5..16af6dbc6ab 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Xml;
 using System.IO;
@@ -83,22 +82,16 @@ public sealed class SolutionFile
         private const string sharedProjectGuid = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
 
         #endregion
-
         #region Member data
-
-        private int _slnFileActualVersion = 0;               // The major version number of the .SLN file we're reading.
-        private string _solutionFile = null;                 // Could be absolute or relative path to the .SLN file.
-        private string _solutionFileDirectory = null;        // Absolute path the solution file
-        private bool _solutionContainsWebProjects = false;    // Does this SLN contain any web projects?
-        private bool _solutionContainsWebDeploymentProjects = false; // Does this SLN contain .wdproj projects?
-        private bool _parsingForConversionOnly = false;      // Are we parsing this solution to get project reference data during
-                                                             // conversion, or in preparation for actually building the solution?
+        private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
+        private bool _parsingForConversionOnly;      // Are we parsing this solution to get project reference data during
+                                                     // conversion, or in preparation for actually building the solution?
 
         // The list of projects in this SLN, keyed by the project GUID.
-        private Dictionary<string, ProjectInSolution> _projects = null;
+        private Dictionary<string, ProjectInSolution> _projects;
 
         // The list of projects in the SLN, in order of their appearance in the SLN.
-        private List<ProjectInSolution> _projectsInOrder = null;
+        private List<ProjectInSolution> _projectsInOrder;
 
         // The list of solution configurations in the solution
         private List<SolutionConfigurationInSolution> _solutionConfigurations;
@@ -109,20 +102,9 @@ public sealed class SolutionFile
         // cached default platform name for GetDefaultPlatformName
         private string _defaultPlatformName;
 
-        //List of warnings that occured while parsing solution
-        private ArrayList _solutionParserWarnings = null;
-
-        //List of comments that occured while parsing solution
-        private ArrayList _solutionParserComments = null;
-
-        // unit-testing only
-        private ArrayList _solutionParserErrorCodes = null;
-
         // VisualStudionVersion specified in Dev12+ solutions
-        private Version _currentVisualStudioVersion = null;
-
-        private StreamReader _reader = null;
-        private int _currentLineNumber = 0;
+        private Version _currentVisualStudioVersion;
+        private int _currentLineNumber;
 
         #endregion
 
@@ -133,9 +115,6 @@ public sealed class SolutionFile
         /// </summary>
         internal SolutionFile()
         {
-            _solutionParserWarnings = new ArrayList();
-            _solutionParserErrorCodes = new ArrayList();
-            _solutionParserComments = new ArrayList();
         }
 
         #endregion
@@ -145,46 +124,22 @@ internal SolutionFile()
         /// <summary>
         /// This property returns the list of warnings that were generated during solution parsing
         /// </summary>
-        internal ArrayList SolutionParserWarnings
-        {
-            get
-            {
-                return _solutionParserWarnings;
-            }
-        }
+        internal List<string> SolutionParserWarnings { get; } = new List<string>();
 
         /// <summary>
         /// This property returns the list of comments that were generated during the solution parsing
         /// </summary>
-        internal ArrayList SolutionParserComments
-        {
-            get
-            {
-                return _solutionParserComments;
-            }
-        }
+        internal List<string> SolutionParserComments { get; } = new List<string>();
 
         /// <summary>
         /// This property returns the list of error codes for warnings/errors that were generated during solution parsing. 
         /// </summary>
-        internal ArrayList SolutionParserErrorCodes
-        {
-            get
-            {
-                return _solutionParserErrorCodes;
-            }
-        }
+        internal List<string> SolutionParserErrorCodes { get; } = new List<string>();
 
         /// <summary>
         /// Returns the actual major version of the parsed solution file
         /// </summary>
-        internal int Version
-        {
-            get
-            {
-                return _slnFileActualVersion;
-            }
-        }
+        internal int Version { get; private set; }
 
         /// <summary>
         /// Returns Visual Studio major version
@@ -199,7 +154,7 @@ internal int VisualStudioVersion
                 }
                 else
                 {
-                    return this.Version - 1;
+                    return Version - 1;
                 }
             }
         }
@@ -207,48 +162,24 @@ internal int VisualStudioVersion
         /// <summary>
         /// Returns true if the solution contains any web projects
         /// </summary>
-        internal bool ContainsWebProjects
-        {
-            get
-            {
-                return _solutionContainsWebProjects;
-            }
-        }
+        internal bool ContainsWebProjects { get; private set; }
 
         /// <summary>
         /// Returns true if the solution contains any .wdproj projects.  Used to determine
         /// whether we need to load up any projects to examine dependencies. 
         /// </summary>
-        internal bool ContainsWebDeploymentProjects
-        {
-            get
-            {
-                return _solutionContainsWebDeploymentProjects;
-            }
-        }
+        internal bool ContainsWebDeploymentProjects { get; private set; }
 
         /// <summary>
         /// All projects in this solution, in the order they appeared in the solution file
         /// </summary>
-        public IReadOnlyList<ProjectInSolution> ProjectsInOrder
-        {
-            get
-            {
-                return _projectsInOrder.AsReadOnly();
-            }
-        }
+        public IReadOnlyList<ProjectInSolution> ProjectsInOrder => _projectsInOrder.AsReadOnly();
 
         /// <summary>
         /// The collection of projects in this solution, accessible by their guids as a 
         /// string in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
         /// </summary>
-        public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid
-        {
-            get
-            {
-                return new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
-            }
-        }
+        public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
 
         /// <summary>
         /// This is the read/write accessor for the solution file which we will parse.  This
@@ -257,10 +188,7 @@ public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid
         /// <value></value>
         internal string FullPath
         {
-            get
-            {
-                return _solutionFile;
-            }
+            get => _solutionFile;
 
             set
             {
@@ -270,46 +198,20 @@ internal string FullPath
             }
         }
 
-        internal string SolutionFileDirectory
-        {
-            get
-            {
-                return _solutionFileDirectory;
-            }
+        internal string SolutionFileDirectory { get;
             // This setter is only used by the unit tests
-            set
-            {
-                _solutionFileDirectory = value;
-            }
-        }
+            set; }
 
         /// <summary>
         /// For unit-testing only.
         /// </summary>
         /// <value></value>
-        internal StreamReader SolutionReader
-        {
-            get
-            {
-                return _reader;
-            }
-
-            set
-            {
-                _reader = value;
-            }
-        }
+        internal StreamReader SolutionReader { get; set; }
 
         /// <summary>
         /// The list of all full solution configurations (configuration + platform) in this solution
         /// </summary>
-        public IReadOnlyList<SolutionConfigurationInSolution> SolutionConfigurations
-        {
-            get
-            {
-                return _solutionConfigurations.AsReadOnly();
-            }
-        }
+        public IReadOnlyList<SolutionConfigurationInSolution> SolutionConfigurations => _solutionConfigurations.AsReadOnly();
 
         #endregion
 
@@ -322,11 +224,8 @@ public IReadOnlyList<SolutionConfigurationInSolution> SolutionConfigurations
         /// </summary>
         public static SolutionFile Parse(string solutionFile)
         {
-            SolutionFile parser = new SolutionFile();
-            parser.FullPath = solutionFile;
-
+            var parser = new SolutionFile { FullPath = solutionFile };
             parser.ParseSolutionFile();
-
             return parser;
         }
 
@@ -384,8 +283,7 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                         // Found it.  Validate the version.
                         string fileVersionFromHeader = line.Substring(slnFileHeaderNoVersion.Length);
 
-                        Version version = null;
-                        if (!System.Version.TryParse(fileVersionFromHeader, out version))
+                        if (!System.Version.TryParse(fileVersionFromHeader, out Version version))
                         {
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                                 (
@@ -425,15 +323,8 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
             }
             finally
             {
-                if (fileStream != null)
-                {
-                    fileStream.Dispose();
-                }
-
-                if (reader != null)
-                {
-                    reader.Dispose();
-                }
+                fileStream?.Dispose();
+                reader?.Dispose();
             }
 
             if (validVersionFound)
@@ -449,8 +340,6 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                     new BuildEventFileInfo(solutionFile),
                     "SolutionParseNoHeaderError"
                  );
-
-            return; /* UNREACHABLE */
         }
 
         /// <summary>
@@ -467,16 +356,12 @@ internal void AddSolutionConfiguration(string configurationName, string platform
         /// <returns></returns>
         private string ReadLine()
         {
-            ErrorUtilities.VerifyThrow(_reader != null, "ParseFileHeader(): reader is null!");
+            ErrorUtilities.VerifyThrow(SolutionReader != null, "ParseFileHeader(): reader is null!");
 
-            string line = _reader.ReadLine();
+            string line = SolutionReader.ReadLine();
             _currentLineNumber++;
 
-            if (line != null)
-            {
-                line = line.Trim();
-            }
-
+            line = line?.Trim();
             return line;
         }
 
@@ -498,20 +383,20 @@ internal void ParseSolutionFileForConversion()
         /// </summary>
         internal void ParseSolutionFile()
         {
-            ErrorUtilities.VerifyThrow((_solutionFile != null) && (_solutionFile.Length != 0), "ParseSolutionFile() got a null solution file!");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), "ParseSolutionFile() got a null solution file!");
             ErrorUtilities.VerifyThrowInternalRooted(_solutionFile);
 
             FileStream fileStream = null;
-            _reader = null;
+            SolutionReader = null;
 
             try
             {
                 // Open the file
                 fileStream = File.OpenRead(_solutionFile);
                 // Store the directory of the file as the current directory may change while we are processes the file
-                _solutionFileDirectory = Path.GetDirectoryName(_solutionFile);
-                _reader = new StreamReader(fileStream, Encoding.GetEncoding(0)); // HIGHCHAR: If solution files have no byte-order marks, then assume ANSI rather than ASCII.
-                this.ParseSolution();
+                SolutionFileDirectory = Path.GetDirectoryName(_solutionFile);
+                SolutionReader = new StreamReader(fileStream, Encoding.GetEncoding(0)); // HIGHCHAR: If solution files have no byte-order marks, then assume ANSI rather than ASCII.
+                ParseSolution();
             }
             catch (Exception e)
             {
@@ -520,15 +405,8 @@ internal void ParseSolutionFile()
             }
             finally
             {
-                if (fileStream != null)
-                {
-                    fileStream.Dispose();
-                }
-
-                if (_reader != null)
-                {
-                    _reader.Dispose();
-                }
+                fileStream?.Dispose();
+                SolutionReader?.Dispose();
             }
         }
 
@@ -540,15 +418,15 @@ internal void ParseSolution()
         {
             _projects = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
             _projectsInOrder = new List<ProjectInSolution>();
-            _solutionContainsWebProjects = false;
-            _slnFileActualVersion = 0;
+            ContainsWebProjects = false;
+            Version = 0;
             _currentLineNumber = 0;
             _solutionConfigurations = new List<SolutionConfigurationInSolution>();
             _defaultConfigurationName = null;
             _defaultPlatformName = null;
 
             // the raw list of project configurations in solution configurations, to be processed after it's fully read in.
-            Hashtable rawProjectConfigurationsEntries = null;
+            Dictionary<string, string> rawProjectConfigurationsEntries = null;
 
             ParseFileHeader();
 
@@ -588,7 +466,7 @@ internal void ParseSolution()
             }
 
             // Cache the unique name of each project, and check that we don't have any duplicates.
-            Hashtable projectsByUniqueName = new Hashtable(StringComparer.OrdinalIgnoreCase);
+            var projectsByUniqueName = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (ProjectInSolution proj in _projectsInOrder)
             {
@@ -599,8 +477,7 @@ internal void ParseSolution()
                 if (proj.ProjectType == SolutionProjectType.WebProject)
                 {
                     // Examine port information and determine if we need to disambiguate similarly-named projects with different ports.
-                    Uri uri;
-                    if (Uri.TryCreate(proj.RelativePath, UriKind.Absolute, out uri))
+                    if (Uri.TryCreate(proj.RelativePath, UriKind.Absolute, out Uri uri))
                     {
                         if (!uri.IsDefaultPort)
                         {
@@ -608,14 +485,14 @@ internal void ParseSolution()
                             // we will create a new unique name with the port added.
                             foreach (ProjectInSolution otherProj in _projectsInOrder)
                             {
-                                if (Object.ReferenceEquals(proj, otherProj))
+                                if (ReferenceEquals(proj, otherProj))
                                 {
                                     continue;
                                 }
 
                                 if (String.Equals(otherProj.ProjectName, proj.ProjectName, StringComparison.OrdinalIgnoreCase))
                                 {
-                                    uniqueName = String.Format(CultureInfo.InvariantCulture, "{0}:{1}", uniqueName, uri.Port);
+                                    uniqueName = $"{uniqueName}:{uri.Port}";
                                     proj.UpdateUniqueProjectName(uniqueName);
                                     break;
                                 }
@@ -624,16 +501,15 @@ internal void ParseSolution()
                     }
                 }
 
-                // Throw an error if there are any duplicates
+                // Update the hash table with this unique name
+                bool didntAlreadyExist = projectsByUniqueName.Add(uniqueName);
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                    projectsByUniqueName[uniqueName] == null,
+                    didntAlreadyExist,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath),
                     "SolutionParseDuplicateProject",
                     uniqueName);
 
-                // Update the hash table with this unique name
-                projectsByUniqueName[uniqueName] = proj;
             }
         } // ParseSolutionFile()
 
@@ -648,7 +524,7 @@ internal void ParseSolution()
         /// </summary>
         private void ParseFileHeader()
         {
-            ErrorUtilities.VerifyThrow(_reader != null, "ParseFileHeader(): reader is null!");
+            ErrorUtilities.VerifyThrow(SolutionReader != null, "ParseFileHeader(): reader is null!");
 
             const string slnFileHeaderNoVersion = "Microsoft Visual Studio Solution File, Format Version ";
 
@@ -715,29 +591,27 @@ private void ValidateSolutionFileVersion(string versionString)
         {
             ErrorUtilities.VerifyThrow(versionString != null, "ValidateSolutionFileVersion() got a null line!");
 
-            Version version = null;
-
-            if (!System.Version.TryParse(versionString, out version))
+            if (!System.Version.TryParse(versionString, out Version version))
             {
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseVersionMismatchError",
                     slnFileMinUpgradableVersion, slnFileMaxVersion);
             }
 
-            _slnFileActualVersion = version.Major;
+            Version = version.Major;
 
             // Validate against our min & max
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                _slnFileActualVersion >= slnFileMinUpgradableVersion,
+                Version >= slnFileMinUpgradableVersion,
                 "SubCategoryForSolutionParsingErrors",
                 new BuildEventFileInfo(FullPath, _currentLineNumber, 0),
                 "SolutionParseVersionMismatchError",
                 slnFileMinUpgradableVersion, slnFileMaxVersion);
             // If the solution file version is greater than the maximum one we will create a comment rather than warn
             // as users such as blend opening a dev10 project cannot do anything about it.
-            if (_slnFileActualVersion > slnFileMaxVersion)
+            if (Version > slnFileMaxVersion)
             {
-                _solutionParserComments.Add(ResourceUtilities.FormatResourceString("UnrecognizedSolutionComment", _slnFileActualVersion));
+                SolutionParserComments.Add(ResourceUtilities.FormatResourceString("UnrecognizedSolutionComment", Version));
             }
         }
 
@@ -761,10 +635,10 @@ private void ValidateSolutionFileVersion(string versionString)
         /// <returns></returns>
         private void ParseProject(string firstLine)
         {
-            ErrorUtilities.VerifyThrow((firstLine != null) && (firstLine.Length != 0), "ParseProject() got a null firstLine!");
-            ErrorUtilities.VerifyThrow(_reader != null, "ParseProject() got a null reader!");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(firstLine), "ParseProject() got a null firstLine!");
+            ErrorUtilities.VerifyThrow(SolutionReader != null, "ParseProject() got a null reader!");
 
-            ProjectInSolution proj = new ProjectInSolution(this);
+            var proj = new ProjectInSolution(this);
 
             // Extract the important information from the first line.
             ParseFirstProjectLine(firstLine, proj);
@@ -841,9 +715,9 @@ private void ParseProject(string firstLine)
         /// <param name="etpProj">ETP Project</param>
         internal void ParseEtpProject(ProjectInSolution etpProj)
         {
-            XmlDocument etpProjectDocument = new XmlDocument();
+            var etpProjectDocument = new XmlDocument();
             // Get the full path to the .etp project file
-            string fullPathToEtpProj = Path.Combine(_solutionFileDirectory, etpProj.RelativePath);
+            string fullPathToEtpProj = Path.Combine(SolutionFileDirectory, etpProj.RelativePath);
             string etpProjectRelativeDir = Path.GetDirectoryName(etpProj.RelativePath);
             try
             {
@@ -869,8 +743,7 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                 *</EFPROJECT>
                 **********************************************************************************/
                 // Make sure the XML reader ignores DTD processing
-                XmlReaderSettings readerSettings = new XmlReaderSettings();
-                readerSettings.DtdProcessing = DtdProcessing.Ignore;
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
 
                 // Load the .etp project file thru the XML reader
                 using (XmlReader xmlReader = XmlReader.Create(fullPathToEtpProj, readerSettings))
@@ -895,28 +768,25 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
                     if (fileElementValue != null)
                     {
                         // Create and populate a ProjectInSolution for the project
-                        ProjectInSolution proj = new ProjectInSolution(this);
-                        proj.RelativePath = Path.Combine(etpProjectRelativeDir, fileElementValue);
+                        var proj = new ProjectInSolution(this)
+                        {
+                            RelativePath = Path.Combine(etpProjectRelativeDir, fileElementValue)
+                        };
 
                         // Verify the relative path specified in the .etp proj file
                         ValidateProjectRelativePath(proj);
                         proj.ProjectType = SolutionProjectType.EtpSubProject;
                         proj.ProjectName = proj.RelativePath;
                         XmlNode projGuidNode = referenceNode.SelectSingleNode("GUIDPROJECTID");
-                        if (projGuidNode != null)
-                        {
-                            proj.ProjectGuid = projGuidNode.InnerText;
-                        }
+
                         // It is ok for a project to not have a guid inside an etp project.
                         // If a solution file contains a project without a guid it fails to 
                         // load in Everett. But if an etp project contains a project without 
                         // a guid it loads well in Everett and p2p references to/from this project
                         // are preserved. So we should make sure that we dont error in this 
                         // situation while upgrading.
-                        else
-                        {
-                            proj.ProjectGuid = String.Empty;
-                        }
+                        proj.ProjectGuid = projGuidNode?.InnerText ?? String.Empty;
+
                         // Add the recently created proj to the collection of projects
                         AddProjectToSolution(proj);
                         // If the project is an etp project recurse
@@ -933,51 +803,46 @@ internal void ParseEtpProject(ProjectInSolution etpProj)
             catch (SecurityException e)
             {
                 // Log a warning 
-                string errorCode, ignoredKeyword;
-                string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
+                string warning = ResourceUtilities.FormatResourceString(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
-                _solutionParserWarnings.Add(warning);
-                _solutionParserErrorCodes.Add(errorCode);
+                SolutionParserWarnings.Add(warning);
+                SolutionParserErrorCodes.Add(errorCode);
             }
             // handle errors in path resolution
             catch (NotSupportedException e)
             {
                 // Log a warning 
-                string errorCode, ignoredKeyword;
-                string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
+                string warning = ResourceUtilities.FormatResourceString(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
-                _solutionParserWarnings.Add(warning);
-                _solutionParserErrorCodes.Add(errorCode);
+                SolutionParserWarnings.Add(warning);
+                SolutionParserErrorCodes.Add(errorCode);
             }
             // handle errors in loading project file
             catch (IOException e)
             {
                 // Log a warning 
-                string errorCode, ignoredKeyword;
-                string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
+                string warning = ResourceUtilities.FormatResourceString(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
-                _solutionParserWarnings.Add(warning);
-                _solutionParserErrorCodes.Add(errorCode);
+                SolutionParserWarnings.Add(warning);
+                SolutionParserErrorCodes.Add(errorCode);
             }
             // handle errors in loading project file
             catch (UnauthorizedAccessException e)
             {
                 // Log a warning 
-                string errorCode, ignoredKeyword;
-                string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.ProjectFileCouldNotBeLoaded",
+                string warning = ResourceUtilities.FormatResourceString(out string errorCode, out _, "Shared.ProjectFileCouldNotBeLoaded",
                     etpProj.RelativePath, e.Message);
-                _solutionParserWarnings.Add(warning);
-                _solutionParserErrorCodes.Add(errorCode);
+                SolutionParserWarnings.Add(warning);
+                SolutionParserErrorCodes.Add(errorCode);
             }
             // handle XML parsing errors 
             catch (XmlException e)
             {
                 // Log a warning 
-                string errorCode, ignoredKeyword;
-                string warning = ResourceUtilities.FormatResourceString(out errorCode, out ignoredKeyword, "Shared.InvalidProjectFile",
+                string warning = ResourceUtilities.FormatResourceString(out string errorCode, out _, "Shared.InvalidProjectFile",
                    etpProj.RelativePath, e.Message);
-                _solutionParserWarnings.Add(warning);
-                _solutionParserErrorCodes.Add(errorCode);
+                SolutionParserWarnings.Add(warning);
+                SolutionParserErrorCodes.Add(errorCode);
             }
         }
 
@@ -998,7 +863,7 @@ private void AddProjectToSolution(ProjectInSolution proj)
         /// Checks whether a given project has a .etp extension.
         /// </summary>
         /// <param name="projectFile"></param>
-        private bool IsEtpProjectFile(string projectFile)
+        private static bool IsEtpProjectFile(string projectFile)
         {
             return projectFile.EndsWith(".etp", StringComparison.OrdinalIgnoreCase);
         }
@@ -1031,10 +896,7 @@ private void ValidateProjectRelativePath(ProjectInSolution proj)
         /// Takes a property name / value that comes from the SLN file for a Venus project, and
         /// stores it appropriately in our data structures.
         /// </summary>
-        /// <param name="proj"></param>
-        /// <param name="propertyName"></param>
-        /// <param name="propertyValue"></param>
-        private void ParseAspNetCompilerProperty
+        private static void ParseAspNetCompilerProperty
             (
             ProjectInSolution proj,
             string propertyName,
@@ -1098,18 +960,20 @@ string propertyValue
                 if (aspNetCompilerParametersObject == null)
                 {
                     // If it didn't exist, create a new one.
-                    aspNetCompilerParameters = new AspNetCompilerParameters();
-                    aspNetCompilerParameters.aspNetVirtualPath = String.Empty;
-                    aspNetCompilerParameters.aspNetPhysicalPath = String.Empty;
-                    aspNetCompilerParameters.aspNetTargetPath = String.Empty;
-                    aspNetCompilerParameters.aspNetForce = String.Empty;
-                    aspNetCompilerParameters.aspNetUpdateable = String.Empty;
-                    aspNetCompilerParameters.aspNetDebug = String.Empty;
-                    aspNetCompilerParameters.aspNetKeyFile = String.Empty;
-                    aspNetCompilerParameters.aspNetKeyContainer = String.Empty;
-                    aspNetCompilerParameters.aspNetDelaySign = String.Empty;
-                    aspNetCompilerParameters.aspNetAPTCA = String.Empty;
-                    aspNetCompilerParameters.aspNetFixedNames = String.Empty;
+                    aspNetCompilerParameters = new AspNetCompilerParameters
+                    {
+                        aspNetVirtualPath = String.Empty,
+                        aspNetPhysicalPath = String.Empty,
+                        aspNetTargetPath = String.Empty,
+                        aspNetForce = String.Empty,
+                        aspNetUpdateable = String.Empty,
+                        aspNetDebug = String.Empty,
+                        aspNetKeyFile = String.Empty,
+                        aspNetKeyContainer = String.Empty,
+                        aspNetDelaySign = String.Empty,
+                        aspNetAPTCA = String.Empty,
+                        aspNetFixedNames = String.Empty
+                    };
                 }
                 else
                 {
@@ -1171,7 +1035,7 @@ string propertyValue
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
                 if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
                 {
-                    string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                    string[] projectReferenceEntries = propertyValue.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
 
                     foreach (string projectReferenceEntry in projectReferenceEntries)
                     {
@@ -1203,7 +1067,7 @@ string propertyValue
                     //However, 3.5 version of Solution parser can't handle a equal sign in the value.  
                     //The "=" in targetframeworkMoniker was escaped to "%3D" for Orcas
                     string targetFrameworkMoniker = TrimQuotes(propertyValue);
-                    proj.TargetFrameworkMoniker = Microsoft.Build.Shared.EscapingUtilities.UnescapeAll(targetFrameworkMoniker);
+                    proj.TargetFrameworkMoniker = Shared.EscapingUtilities.UnescapeAll(targetFrameworkMoniker);
                 }
             }
         }
@@ -1211,15 +1075,13 @@ string propertyValue
         /// <summary>
         /// Strips a single pair of leading/trailing double-quotes from a string.
         /// </summary>
-        /// <param name="property"></param>
-        /// <returns></returns>
-        private string TrimQuotes
+        private static string TrimQuotes
             (
             string property
             )
         {
             // If the incoming string starts and ends with a double-quote, strip the double-quotes.
-            if ((property != null) && (property.Length > 0) && (property[0] == '"') && (property[property.Length - 1] == '"'))
+            if (!string.IsNullOrEmpty(property) && (property[0] == '"') && (property[property.Length - 1] == '"'))
             {
                 return property.Substring(1, property.Length - 2);
             }
@@ -1303,12 +1165,12 @@ ProjectInSolution proj
             else if (String.Compare(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
             {
                 proj.ProjectType = SolutionProjectType.WebProject;
-                _solutionContainsWebProjects = true;
+                ContainsWebProjects = true;
             }
             else if (String.Compare(projectTypeGuid, wdProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
             {
                 proj.ProjectType = SolutionProjectType.WebDeploymentProject;
-                _solutionContainsWebDeploymentProjects = true;
+                ContainsWebDeploymentProjects = true;
             }
             else
             {
@@ -1322,11 +1184,9 @@ ProjectInSolution proj
         /// </summary>
         internal void ParseNestedProjects()
         {
-            string str;
-
             do
             {
-                str = ReadLine();
+                string str = ReadLine();
                 if ((str == null) || (str == "EndGlobalSection"))
                 {
                     break;
@@ -1344,8 +1204,7 @@ internal void ParseNestedProjects()
                 string projectGuid = match.Groups["PROPERTYNAME"].Value.Trim();
                 string parentProjectGuid = match.Groups["PROPERTYVALUE"].Value.Trim();
 
-                ProjectInSolution proj;
-                if (!_projects.TryGetValue(projectGuid, out proj))
+                if (!_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
                 {
                     ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null, "SubCategoryForSolutionParsingErrors",
                        new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseNestedProjectUndefinedError", projectGuid, parentProjectGuid);
@@ -1368,13 +1227,12 @@ internal void ParseNestedProjects()
         /// </remarks>
         internal void ParseSolutionConfigurations()
         {
-            string str;
-            char[] nameValueSeparators = new char[] { '=' };
-            char[] configPlatformSeparators = new char[] { SolutionConfigurationInSolution.ConfigurationPlatformSeparator };
+            var nameValueSeparators = new[] { '=' };
+            var configPlatformSeparators = new[] { SolutionConfigurationInSolution.ConfigurationPlatformSeparator };
 
             do
             {
-                str = ReadLine();
+                string str = ReadLine();
 
                 if ((str == null) || (str == "EndGlobalSection"))
                 {
@@ -1396,7 +1254,9 @@ internal void ParseSolutionConfigurations()
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
                 if (0 == String.Compare(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                {
                     continue;
+                }
 
                 // Both names must be identical
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(fullConfigurationName == configurationNames[1].Trim(), "SubCategoryForSolutionParsingErrors",
@@ -1431,14 +1291,13 @@ internal void ParseSolutionConfigurations()
         /// EndGlobalSection
         /// </remarks>
         /// <returns>An unprocessed hashtable of entries in this section</returns>
-        internal Hashtable ParseProjectConfigurations()
+        internal Dictionary<string, string> ParseProjectConfigurations()
         {
-            Hashtable rawProjectConfigurationsEntries = new Hashtable(StringComparer.OrdinalIgnoreCase);
-            string str;
+            var rawProjectConfigurationsEntries = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
             do
             {
-                str = ReadLine();
+                string str = ReadLine();
 
                 if ((str == null) || (str == "EndGlobalSection"))
                 {
@@ -1450,7 +1309,7 @@ internal Hashtable ParseProjectConfigurations()
                     continue;
                 }
 
-                string[] nameValue = str.Split(new char[] { '=' });
+                string[] nameValue = str.Split('=');
 
                 // There should be exactly one '=' character, separating the name and value. 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(nameValue.Length == 2, "SubCategoryForSolutionParsingErrors",
@@ -1467,7 +1326,7 @@ internal Hashtable ParseProjectConfigurations()
         /// solution section data. 
         /// </summary>
         /// <param name="rawProjectConfigurationsEntries">Cached data from the project configuration section</param>
-        internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurationsEntries)
+        internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawProjectConfigurationsEntries)
         {
             // Instead of parsing the data line by line, we parse it project by project, constructing the 
             // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its 
@@ -1476,7 +1335,7 @@ internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurati
             // parts of the entry name string. This could lead to ambiguous results if we tried to parse 
             // the entry name instead of constructing it and looking it up. Although it's pretty unlikely that
             // this would ever be a problem, it's safer to do it the same way VS IDE does it.
-            char[] configPlatformSeparators = new char[] { SolutionConfigurationInSolution.ConfigurationPlatformSeparator };
+            char[] configPlatformSeparators = { SolutionConfigurationInSolution.ConfigurationPlatformSeparator };
 
             foreach (ProjectInSolution project in _projectsInOrder)
             {
@@ -1498,16 +1357,16 @@ internal void ProcessProjectConfigurationSection(Hashtable rawProjectConfigurati
                         string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
                             project.ProjectGuid, solutionConfiguration.FullName);
 
-                        if (rawProjectConfigurationsEntries.ContainsKey(entryNameActiveConfig))
+                        if (rawProjectConfigurationsEntries.TryGetValue(entryNameActiveConfig, out string configurationPlatform))
                         {
-                            string[] configurationPlatformParts = ((string)(rawProjectConfigurationsEntries[entryNameActiveConfig])).Split(configPlatformSeparators);
+                            string[] configurationPlatformParts = configurationPlatform.Split(configPlatformSeparators);
 
                             // Project configuration may not necessarily contain the platform part. Some project support only the configuration part.
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(configurationPlatformParts.Length <= 2, "SubCategoryForSolutionParsingErrors",
                                 new BuildEventFileInfo(FullPath), "SolutionParseInvalidProjectSolutionConfigurationEntry",
-                                string.Format(CultureInfo.InvariantCulture, "{0} = {1}", entryNameActiveConfig, rawProjectConfigurationsEntries[entryNameActiveConfig]));
+                                $"{entryNameActiveConfig} = {configurationPlatform}");
 
-                            ProjectConfigurationInSolution projectConfiguration = new ProjectConfigurationInSolution(
+                            var projectConfiguration = new ProjectConfigurationInSolution(
                                 configurationPlatformParts[0],
                                 (configurationPlatformParts.Length > 1) ? configurationPlatformParts[1] : string.Empty,
                                 rawProjectConfigurationsEntries.ContainsKey(entryNameBuild)
@@ -1535,7 +1394,7 @@ public string GetDefaultConfigurationName()
             _defaultConfigurationName = string.Empty;
 
             // Pick the Debug configuration as default if present
-            foreach (SolutionConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
+            foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
                 if (string.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
                 {
@@ -1545,9 +1404,9 @@ public string GetDefaultConfigurationName()
             }
 
             // Failing that, just pick the first configuration name as default
-            if ((_defaultConfigurationName.Length == 0) && (this.SolutionConfigurations.Count > 0))
+            if ((_defaultConfigurationName.Length == 0) && (SolutionConfigurations.Count > 0))
             {
-                _defaultConfigurationName = this.SolutionConfigurations[0].ConfigurationName;
+                _defaultConfigurationName = SolutionConfigurations[0].ConfigurationName;
             }
 
             return _defaultConfigurationName;
@@ -1568,7 +1427,7 @@ public string GetDefaultPlatformName()
             _defaultPlatformName = string.Empty;
 
             // Pick the Mixed Platforms platform as default if present
-            foreach (SolutionConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
+            foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
                 if (string.Compare(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase) == 0)
                 {
@@ -1583,9 +1442,9 @@ public string GetDefaultPlatformName()
             }
 
             // Failing that, just pick the first platform name as default
-            if ((_defaultPlatformName.Length == 0) && (this.SolutionConfigurations.Count > 0))
+            if ((_defaultPlatformName.Length == 0) && (SolutionConfigurations.Count > 0))
             {
-                _defaultPlatformName = this.SolutionConfigurations[0].PlatformName;
+                _defaultPlatformName = SolutionConfigurations[0].PlatformName;
             }
 
             return _defaultPlatformName;
@@ -1599,8 +1458,7 @@ public string GetDefaultPlatformName()
         /// <returns></returns>
         internal string GetProjectUniqueNameByGuid(string projectGuid)
         {
-            ProjectInSolution proj;
-            if (_projects.TryGetValue(projectGuid, out proj))
+            if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
             {
                 return proj.GetUniqueProjectName();
             }
@@ -1616,8 +1474,7 @@ internal string GetProjectUniqueNameByGuid(string projectGuid)
         /// <returns></returns>
         internal string GetProjectRelativePathByGuid(string projectGuid)
         {
-            ProjectInSolution proj;
-            if (_projects.TryGetValue(projectGuid, out proj))
+            if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
             {
                 return proj.RelativePath;
             }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index fd0ce44ea2d..fd7870b9a8a 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -16,11 +16,9 @@
 using System.Text;
 using System.Xml;
 
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Collections;
 
 using Project = Microsoft.Build.Evaluation.Project;
 using ProjectCollection = Microsoft.Build.Evaluation.ProjectCollection;
@@ -65,7 +63,7 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// A known list of target names to create.  This is for backwards compatibility.
         /// </summary>
-        internal static readonly ISet<string> _defaultTargetNames = ImmutableHashSet.Create<string>(StringComparer.OrdinalIgnoreCase,
+        internal static readonly ISet<string> _defaultTargetNames = ImmutableHashSet.Create(StringComparer.OrdinalIgnoreCase,
             "Build",
             "Clean",
             "Rebuild",
@@ -85,7 +83,7 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// The list of global properties we set on each metaproject and which get passed to each project when building.
         /// </summary>
-        private Tuple<string, string>[] _metaprojectGlobalProperties = new Tuple<string, string>[]
+        private readonly Tuple<string, string>[] _metaprojectGlobalProperties =
         {
             new Tuple<string, string>("Configuration", null), // This is the solution configuration in a metaproject, and project configuration on an actual project
             new Tuple<string, string>("Platform", null), // This is the solution platform in a metaproject, and project platform on an actual project
@@ -101,27 +99,27 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// The SolutionFile containing information about the solution we're generating a wrapper for.
         /// </summary>
-        private SolutionFile _solutionFile;
+        private readonly SolutionFile _solutionFile;
 
         /// <summary>
         /// The global properties passed under which the project should be opened. 
         /// </summary>
-        private IDictionary<string, string> _globalProperties;
+        private readonly IDictionary<string, string> _globalProperties;
 
         /// <summary>
         /// The ToolsVersion passed on the commandline, if any.  May be null.
         /// </summary>
-        private string _toolsVersionOverride;
+        private readonly string _toolsVersionOverride;
 
         /// <summary>
         /// The context of this build (used for logging purposes). 
         /// </summary>
-        private BuildEventContext _projectBuildEventContext;
+        private readonly BuildEventContext _projectBuildEventContext;
 
         /// <summary>
         /// The LoggingService used to log messages.
         /// </summary>
-        private ILoggingService _loggingService;
+        private readonly ILoggingService _loggingService;
 
         /// <summary>
         /// The list of targets specified to use.
@@ -136,12 +134,12 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// The <see cref="ISdkResolverService"/> to use.
         /// </summary>
-        private ISdkResolverService _sdkResolverService;
+        private readonly ISdkResolverService _sdkResolverService;
 
         /// <summary>
         /// The current build submission ID.
         /// </summary>
-        private int _submissionId;
+        private readonly int _submissionId;
 
         #endregion // Private Fields
 
@@ -150,8 +148,8 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// Constructor.
         /// </summary>
-        private SolutionProjectGenerator
-        (SolutionFile solution,
+        private SolutionProjectGenerator(
+            SolutionFile solution,
             IDictionary<string, string> globalProperties,
             string toolsVersionOverride,
             BuildEventContext projectBuildEventContext,
@@ -227,10 +225,12 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
             msbuildProject.AppendChild(solutionConfigurationProperties);
             solutionConfigurationProperties.Condition = GetConditionStringForConfiguration(solutionConfiguration);
 
-            StringBuilder solutionConfigurationContents = new StringBuilder(1024);
-            XmlWriterSettings settings = new XmlWriterSettings();
-            settings.Indent = true;
-            settings.OmitXmlDeclaration = true;
+            var solutionConfigurationContents = new StringBuilder(1024);
+            var settings = new XmlWriterSettings
+            {
+                Indent = true,
+                OmitXmlDeclaration = true
+            };
             using (XmlWriter xw = XmlWriter.Create(solutionConfigurationContents, settings))
             {
                 xw.WriteStartElement("SolutionConfiguration");
@@ -238,9 +238,7 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
                 // add a project configuration entry for each project in the solution
                 foreach (ProjectInSolution project in solutionFile.ProjectsInOrder)
                 {
-                    ProjectConfigurationInSolution projectConfiguration = null;
-
-                    if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
+                    if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution projectConfiguration))
                     {
                         xw.WriteStartElement("ProjectConfiguration");
                         xw.WriteAttributeString("Project", project.ProjectGuid);
@@ -251,8 +249,7 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
                         foreach (string dependencyProjectGuid in project.Dependencies)
                         {
                             // This is a project that the current project depends *ON* (ie., it must build first)
-                            ProjectInSolution dependencyProject;
-                            if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out dependencyProject))
+                            if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                             {
                                 // If it's not itself part of the solution, that's an invalid solution
                                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(dependencyProject != null, "SubCategoryForSolutionParsingErrors", new BuildEventFileInfo(solutionFile.FullPath), "SolutionParseProjectDepNotFoundError", project.ProjectGuid, dependencyProjectGuid);
@@ -263,8 +260,7 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
                             // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise 
                             if (dependencyProject.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat)
                             {
-                                ProjectConfigurationInSolution dependencyProjectConfiguration = null;
-                                if (dependencyProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out dependencyProjectConfiguration) &&
+                                if (dependencyProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution dependencyProjectConfiguration) &&
                                     WouldProjectBuild(solutionFile, solutionConfiguration.FullName, dependencyProject, dependencyProjectConfiguration))
                                 {
                                     xw.WriteStartElement("ProjectDependency");
@@ -308,9 +304,7 @@ internal static ProjectTaskElement AddErrorWarningMessageElement
             params object[] args
             )
         {
-            string code = null;
-            string helpKeyword = null;
-            string text = ResourceUtilities.FormatResourceString(out code, out helpKeyword, textResourceName, args);
+            string text = ResourceUtilities.FormatResourceString(out string code, out string helpKeyword, textResourceName, args);
 
             if (treatAsLiteral)
             {
@@ -504,7 +498,7 @@ bool specifyProjectToolsVersion
             ProjectTaskInstance msbuildTask = target.AddTask("MSBuild", null, null);
             msbuildTask.SetParameter("Projects", EscapingUtilities.Escape(projectPath));
 
-            if (msbuildTargetName != null && msbuildTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(msbuildTargetName))
             {
                 msbuildTask.SetParameter("Targets", msbuildTargetName);
             }
@@ -546,7 +540,7 @@ string propertyName
         /// </summary>
         private static string MakeIntoSafeItemName(string name)
         {
-            StringBuilder builder = new StringBuilder(name);
+            var builder = new StringBuilder(name);
 
             if (name.Length > 0)
             {
@@ -580,9 +574,7 @@ private static ProjectTaskInstance AddErrorWarningMessageInstance
             params object[] args
             )
         {
-            string code = null;
-            string helpKeyword = null;
-            string text = ResourceUtilities.FormatResourceString(out code, out helpKeyword, textResourceName, args);
+            string text = ResourceUtilities.FormatResourceString(out string code, out string helpKeyword, textResourceName, args);
 
             if (treatAsLiteral)
             {
@@ -629,11 +621,8 @@ private static string GetConditionStringForConfiguration(SolutionConfigurationIn
         /// </summary>
         private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
         {
-            string activeSolutionConfiguration = null;
-            string activeSolutionPlatform = null;
-
-            globalProperties.TryGetValue("Configuration", out activeSolutionConfiguration);
-            globalProperties.TryGetValue("Platform", out activeSolutionPlatform);
+            globalProperties.TryGetValue("Configuration", out string activeSolutionConfiguration);
+            globalProperties.TryGetValue("Platform", out string activeSolutionPlatform);
 
             if (String.IsNullOrEmpty(activeSolutionConfiguration))
             {
@@ -645,7 +634,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile so
                 activeSolutionPlatform = solutionFile.GetDefaultPlatformName();
             }
 
-            SolutionConfigurationInSolution configurationInSolution = new SolutionConfigurationInSolution(activeSolutionConfiguration, activeSolutionPlatform);
+            var configurationInSolution = new SolutionConfigurationInSolution(activeSolutionConfiguration, activeSolutionPlatform);
 
             return configurationInSolution.FullName;
         }
@@ -704,8 +693,7 @@ private ProjectInstance[] Generate()
             // scanning child projects for dependency information.
             // The knowledge of whether it was explicitly specified is required because otherwise we 
             // don't know whether we need to pass the ToolsVersion on to the child projects or not.  
-            bool explicitToolsVersionSpecified = false;
-            string wrapperProjectToolsVersion = DetermineWrapperProjectToolsVersion(_toolsVersionOverride, out explicitToolsVersionSpecified);
+            string wrapperProjectToolsVersion = DetermineWrapperProjectToolsVersion(_toolsVersionOverride, out bool explicitToolsVersionSpecified);
 
             return CreateSolutionProject(wrapperProjectToolsVersion, explicitToolsVersionSpecified);
         }
@@ -732,7 +720,7 @@ private ProjectInstance[] CreateSolutionProject(string wrapperProjectToolsVersio
             }
 
             // Get a list of all actual projects in the solution
-            List<ProjectInSolution> projectsInOrder = new List<ProjectInSolution>(_solutionFile.ProjectsInOrder.Count);
+            var projectsInOrder = new List<ProjectInSolution>(_solutionFile.ProjectsInOrder.Count);
             foreach (ProjectInSolution project in _solutionFile.ProjectsInOrder)
             {
                 if (SolutionFile.IsBuildableProject(project))
@@ -742,7 +730,7 @@ private ProjectInstance[] CreateSolutionProject(string wrapperProjectToolsVersio
             }
 
             // Create the list of our generated projects.
-            List<ProjectInstance> projectInstances = new List<ProjectInstance>(projectsInOrder.Count + 1);
+            var projectInstances = new List<ProjectInstance>(projectsInOrder.Count + 1);
 
             // Create the project instance for the traversal project.
             ProjectInstance traversalInstance = CreateTraversalInstance(wrapperProjectToolsVersion, explicitToolsVersionSpecified, projectsInOrder);
@@ -775,8 +763,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
             // Now add all of the per-project items, targets and metaprojects.
             foreach (ProjectInSolution project in projectsInOrder)
             {
-                ProjectConfigurationInSolution projectConfiguration;
-                project.ProjectConfigurations.TryGetValue(selectedSolutionConfiguration, out projectConfiguration);
+                project.ProjectConfigurations.TryGetValue(selectedSolutionConfiguration, out ProjectConfigurationInSolution projectConfiguration);
                 if (!WouldProjectBuild(_solutionFile, selectedSolutionConfiguration, project, projectConfiguration))
                 {
                     // Project wouldn't build, so omit it from further processing.
@@ -796,7 +783,6 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
                 AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, "Rebuild", "BuildOutput", canBuildDirectly);
                 AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, "Publish", null, canBuildDirectly);
 
-
                 // Add any other targets specified by the user that were not already added
                 foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
                 {
@@ -846,9 +832,6 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             traversalProject.InitialTargets = "ValidateSolutionConfiguration;ValidateToolsVersions;ValidateProjects";
             traversalProject.FullPath = _solutionFile.FullPath + ".metaproj";
 
-            // We don't use dependency levels any more - however this will find circular dependencies and throw for us.
-            Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel = new Dictionary<int, List<ProjectInSolution>>();
-
             // Add default solution configuration/platform names in case the user doesn't specify them on the command line
             AddConfigurationPlatformDefaults(traversalProject);
 
@@ -911,7 +894,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             }
 
             // Create the instance.  From this point forward we can evaluate conditions against the traversal project directly.
-            ProjectInstance traversalInstance = new ProjectInstance
+            var traversalInstance = new ProjectInstance
                 (
                 traversalProject,
                 _globalProperties,
@@ -970,7 +953,7 @@ private void AddProjectReference(ProjectInstance traversalProject, ProjectInstan
         /// <summary>
         /// The value to be passed to the ToolsVersion attribute of the MSBuild task used to directly build a project.
         /// </summary>
-        private string GetToolsVersionMetadataForDirectMSBuildTask(ProjectInstance traversalProject)
+        private static string GetToolsVersionMetadataForDirectMSBuildTask(ProjectInstance traversalProject)
         {
             string directProjectToolsVersion = traversalProject.GetPropertyValue("ProjectToolsVersion");
             return directProjectToolsVersion;
@@ -979,7 +962,7 @@ private string GetToolsVersionMetadataForDirectMSBuildTask(ProjectInstance trave
         /// <summary>
         /// The value to be passed to the ToolsVersion attribute of the MSBuild task used to directly build a project.
         /// </summary>
-        private string GetToolsVersionAttributeForDirectMSBuildTask(ProjectInstance traversalProject)
+        private static string GetToolsVersionAttributeForDirectMSBuildTask()
         {
             return "$(ProjectToolsVersion)";
         }
@@ -987,7 +970,7 @@ private string GetToolsVersionAttributeForDirectMSBuildTask(ProjectInstance trav
         /// <summary>
         /// The value to be assigned to the metadata for a particular project reference.  Contains only configuration and platform specified in the project configuration, evaluated.
         /// </summary>
-        private string GetPropertiesMetadataForProjectReference(ProjectInstance traversalProject, string configurationAndPlatformProperties)
+        private static string GetPropertiesMetadataForProjectReference(ProjectInstance traversalProject, string configurationAndPlatformProperties)
         {
             string directProjectProperties = traversalProject.ExpandString(configurationAndPlatformProperties);
 
@@ -1007,7 +990,7 @@ private string GetPropertiesMetadataForProjectReference(ProjectInstance traversa
         /// <summary>
         /// Gets the project configuration and platform values as an attribute string for an MSBuild task used to build the project.
         /// </summary>
-        private string GetConfigurationAndPlatformPropertiesString(ProjectConfigurationInSolution projectConfiguration)
+        private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigurationInSolution projectConfiguration)
         {
             string directProjectProperties = String.Format(CultureInfo.InvariantCulture, "Configuration={0}; Platform={1}", projectConfiguration.ConfigurationName, projectConfiguration.PlatformName);
             return directProjectProperties;
@@ -1017,7 +1000,7 @@ private string GetConfigurationAndPlatformPropertiesString(ProjectConfigurationI
         /// The value to be passed to the Properties attribute of the MSBuild task to build a specific project.  Contains reference to project configuration and
         /// platform as well as the solution configuration bits.
         /// </summary>
-        private string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)
+        private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration)
         {
             string directProjectProperties = OpportunisticIntern.InternStringIfPossible(String.Join(";", GetConfigurationAndPlatformPropertiesString(projectConfiguration), SolutionProperties));
             return directProjectProperties;
@@ -1030,15 +1013,13 @@ private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolutio
         {
             // Can we build this project directly, without a metaproject?  We can if it's MSBuild-able and has no references building in this configuration.
             bool canBuildDirectly = false;
-            string unknownProjectTypeErrorMessage;
             if ((projectToAdd.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat) ||
-                (projectToAdd.CanBeMSBuildProjectFile(out unknownProjectTypeErrorMessage)))
+                (projectToAdd.CanBeMSBuildProjectFile(out _)))
             {
                 canBuildDirectly = true;
                 foreach (string dependencyProjectGuid in projectToAdd.Dependencies)
                 {
-                    ProjectInSolution dependencyProject;
-                    if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out dependencyProject))
+                    if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                     {
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                             (
@@ -1106,10 +1087,6 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
             // Add the project references which must build before this one.
             AddMetaprojectReferenceItems(traversalProject, metaprojectInstance, project);
 
-            // This string holds the error message generated when we try to determine if a project is an MSBuild format
-            // project but it is not.
-            string unknownProjectTypeErrorMessage;
-
             if (project.ProjectType == SolutionProjectType.WebProject)
             {
                 AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, null);
@@ -1123,8 +1100,11 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 }
             }
             else if ((project.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat) ||
-                     (project.CanBeMSBuildProjectFile(out unknownProjectTypeErrorMessage)))
+                     (project.CanBeMSBuildProjectFile(out string unknownProjectTypeErrorMessage)))
             {
+                // unknownProjectTypeErrorMessage holds the error message generated when we try to determine if a project is an MSBuild format
+                // project but it is not.
+
                 string safeItemNameFromProjectName = MakeIntoSafeItemName(project.ProjectName);
                 string targetOutputItemName = string.Format(CultureInfo.InvariantCulture, "{0}BuildOutput", safeItemNameFromProjectName);
 
@@ -1176,7 +1156,7 @@ private string GetMetaprojectName(ProjectInSolution project)
 
             baseName = FileUtilities.EnsureNoTrailingSlash(baseName);
 
-            return SolutionProjectGenerator.GetMetaprojectName(baseName);
+            return GetMetaprojectName(baseName);
         }
 
         /// <summary>
@@ -1186,8 +1166,7 @@ private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, Proj
         {
             foreach (string dependencyProjectGuid in project.Dependencies)
             {
-                ProjectInSolution dependencyProject;
-                if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out dependencyProject))
+                if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                 {
                     ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                         (
@@ -1201,8 +1180,7 @@ private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, Proj
                 }
                 else
                 {
-                    ProjectConfigurationInSolution dependencyProjectConfiguration = null;
-                    if (dependencyProject.ProjectConfigurations.TryGetValue(_selectedSolutionConfiguration, out dependencyProjectConfiguration) &&
+                    if (dependencyProject.ProjectConfigurations.TryGetValue(_selectedSolutionConfiguration, out ProjectConfigurationInSolution dependencyProjectConfiguration) &&
                         WouldProjectBuild(_solutionFile, _selectedSolutionConfiguration, dependencyProject, dependencyProjectConfiguration))
                     {
                         bool canBuildDirectly = CanBuildDirectly(traversalProject, dependencyProject, dependencyProjectConfiguration);
@@ -1215,7 +1193,7 @@ private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, Proj
         /// <summary>
         /// Adds the targets which build the dependencies and actual project for a metaproject.
         /// </summary>
-        private void AddMetaprojectTargetForManagedProject(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration, string targetName, string outputItem)
+        private static void AddMetaprojectTargetForManagedProject(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration, string targetName, string outputItem)
         {
             string outputItemAsItem = null;
             if (!String.IsNullOrEmpty(outputItem))
@@ -1225,16 +1203,16 @@ private void AddMetaprojectTargetForManagedProject(ProjectInstance traversalProj
 
             ProjectTargetInstance target = metaprojectInstance.AddTarget(targetName ?? "Build", String.Empty, String.Empty, outputItemAsItem, null, String.Empty, String.Empty, false /* legacy target returns behaviour */);
 
-            AddReferencesBuildTask(metaprojectInstance, target, targetName, null /* No need to capture output */);
+            AddReferencesBuildTask(target, targetName, null /* No need to capture output */);
 
             // Add the task to build the actual project.
-            AddProjectBuildTask(traversalProject, project, projectConfiguration, target, targetName, EscapingUtilities.Escape(project.AbsolutePath), String.Empty, outputItem);
+            AddProjectBuildTask(traversalProject, projectConfiguration, target, targetName, EscapingUtilities.Escape(project.AbsolutePath), String.Empty, outputItem);
         }
 
         /// <summary>
         /// Adds an MSBuild task to a real project.
         /// </summary>
-        private void AddProjectBuildTask(ProjectInstance traversalProject, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration, ProjectTargetInstance target, string targetToBuild, string sourceItems, string condition, string outputItem)
+        private static void AddProjectBuildTask(ProjectInstance traversalProject, ProjectConfigurationInSolution projectConfiguration, ProjectTargetInstance target, string targetToBuild, string sourceItems, string condition, string outputItem)
         {
             ProjectTaskInstance task = target.AddTask("MSBuild", condition, String.Empty);
             task.SetParameter("Projects", sourceItems);
@@ -1245,7 +1223,7 @@ private void AddProjectBuildTask(ProjectInstance traversalProject, ProjectInSolu
 
             task.SetParameter("BuildInParallel", "True");
 
-            task.SetParameter("ToolsVersion", GetToolsVersionAttributeForDirectMSBuildTask(traversalProject));
+            task.SetParameter("ToolsVersion", GetToolsVersionAttributeForDirectMSBuildTask());
             task.SetParameter("Properties", GetPropertiesAttributeForDirectMSBuildTask(projectConfiguration));
 
             if (outputItem != null)
@@ -1257,7 +1235,7 @@ private void AddProjectBuildTask(ProjectInstance traversalProject, ProjectInSolu
         /// <summary>
         /// Adds an MSBuild task to a single metaproject.  This is used in the traversal project.
         /// </summary>
-        private void AddMetaprojectBuildTask(ProjectInstance traversalProject, ProjectInSolution project, ProjectTargetInstance target, string targetToBuild, string outputItem)
+        private void AddMetaprojectBuildTask(ProjectInSolution project, ProjectTargetInstance target, string targetToBuild, string outputItem)
         {
             ProjectTaskInstance task = target.AddTask("MSBuild", OpportunisticIntern.InternStringIfPossible("'%(ProjectReference.Identity)' == '" + GetMetaprojectName(project) + "'"), String.Empty);
             task.SetParameter("Projects", "@(ProjectReference)");
@@ -1290,7 +1268,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
             ProjectTargetInstance newTarget = metaprojectInstance.AddTarget(targetName ?? "Build", ComputeTargetConditionForWebProject(project), null, null, null, null, "GetFrameworkPathAndRedistList", false /* legacy target returns behaviour */);
 
             // Build the references
-            AddReferencesBuildTask(metaprojectInstance, newTarget, targetName, null /* No need to capture output */);
+            AddReferencesBuildTask(newTarget, targetName, null /* No need to capture output */);
 
             if (targetName == "Clean")
             {
@@ -1317,13 +1295,13 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
                 // with a valid configuration name.  We init our condition string to "false", so we can easily 
                 // OR together more stuff as we go, and also easily take the negation of the condition by putting
                 // a ! around the whole thing.
-                StringBuilder conditionDescribingValidConfigurations = new StringBuilder("(false)");
+                var conditionDescribingValidConfigurations = new StringBuilder("(false)");
 
                 // Loop through all the valid configurations and add a PropertyGroup for each one.
                 foreach (DictionaryEntry aspNetConfiguration in project.AspNetConfigurations)
                 {
                     string configurationName = (string)aspNetConfiguration.Key;
-                    AspNetCompilerParameters aspNetCompilerParameters = (AspNetCompilerParameters)aspNetConfiguration.Value;
+                    var aspNetCompilerParameters = (AspNetCompilerParameters)aspNetConfiguration.Value;
 
                     // We only add the PropertyGroup once per Venus project.  Without the following "if", we would add
                     // the same identical PropertyGroup twice, once when AddTargetForWebProject is called with 
@@ -1353,8 +1331,6 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
                     // of referenced projects.
                     foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionFile.SolutionConfigurations)
                     {
-                        string referenceProjectGuids = null;
-
                         AddResolveProjectReferenceTasks
                             (
                             traversalProject,
@@ -1362,8 +1338,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
                             project,
                             solutionConfiguration,
                             referenceItemName.ToString(),
-                            null /* don't care about native references */,
-                            out referenceProjectGuids
+                            out _
                             );
                     }
                 }
@@ -1381,10 +1356,10 @@ out referenceProjectGuids
                 // Add a call to the <Message> task, conditioned on having an *invalid* Configuration.  The
                 // message says that we're skipping the Venus project because it's either not enabled
                 // for precompilation, or doesn't support the given configuration.
-                ProjectTaskInstance skippingVenusProjectMessageTask = AddErrorWarningMessageInstance
+                AddErrorWarningMessageInstance
                     (
                     newTarget,
-                    "!(" + conditionDescribingValidConfigurations.ToString() + ")",
+                    "!(" + conditionDescribingValidConfigurations + ")",
                     XMakeElements.message,
                     false,
                     "SolutionVenusProjectSkipped"
@@ -1421,7 +1396,7 @@ string conditionDescribingValidConfigurations
             // generate the target .NET Framework version based on the passed in TargetFrameworkMoniker.
             try
             {
-                FrameworkName targetFramework = new FrameworkName(project.TargetFrameworkMoniker);
+                var targetFramework = new FrameworkName(project.TargetFrameworkMoniker);
 
                 if (String.Equals(targetFramework.Identifier, ".NETFramework", StringComparison.OrdinalIgnoreCase))
                 {
@@ -1498,13 +1473,10 @@ private void AddResolveProjectReferenceTasks
             ProjectInSolution project,
             SolutionConfigurationInSolution solutionConfiguration,
             string outputReferenceItemName,
-            string outputImportLibraryItemName,
             out string addedReferenceGuids
         )
         {
-            StringBuilder referenceGuids = new StringBuilder();
-
-            string message = null;
+            var referenceGuids = new StringBuilder();
 
             // Suffix for the reference item name. Since we need to attach additional (different) metadata to every
             // reference item, we need to have helper item lists each with only one item
@@ -1513,23 +1485,22 @@ out string addedReferenceGuids
             // Pre-resolve the MSBuild project references
             foreach (string projectReferenceGuid in project.ProjectReferences)
             {
-                ProjectInSolution referencedProject = (ProjectInSolution)_solutionFile.ProjectsByGuid[projectReferenceGuid];
-                ProjectConfigurationInSolution referencedProjectConfiguration = null;
+                ProjectInSolution referencedProject = _solutionFile.ProjectsByGuid[projectReferenceGuid];
 
                 if ((referencedProject != null) &&
-                    (referencedProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out referencedProjectConfiguration)) &&
+                    (referencedProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution referencedProjectConfiguration)) &&
                     (referencedProjectConfiguration != null))
                 {
                     string outputReferenceItemNameWithSuffix = string.Format(CultureInfo.InvariantCulture, "{0}_{1}", outputReferenceItemName, outputReferenceItemNameSuffix);
 
                     if ((referencedProject.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat) ||
-                        ((referencedProject.ProjectType == SolutionProjectType.Unknown) && (referencedProject.CanBeMSBuildProjectFile(out message))))
+                        ((referencedProject.ProjectType == SolutionProjectType.Unknown) && (referencedProject.CanBeMSBuildProjectFile(out _))))
                     {
                         string condition = GetConditionStringForConfiguration(solutionConfiguration);
                         if (traversalProject.EvaluateCondition(condition))
                         {
                             bool specifyProjectToolsVersion =
-                                String.Equals(traversalProject.ToolsVersion, "2.0", StringComparison.OrdinalIgnoreCase) ? false : true;
+                                !String.Equals(traversalProject.ToolsVersion, "2.0", StringComparison.OrdinalIgnoreCase);
 
                             ProjectTaskInstance msbuildTask = AddMSBuildTaskInstance
                                 (
@@ -1568,7 +1539,7 @@ out string addedReferenceGuids
         /// Add a PropertyGroup to the project for a particular Asp.Net configuration.  This PropertyGroup
         /// will have the correct values for all the Asp.Net properties for this project and this configuration.
         /// </summary>
-        private void AddPropertyGroupForAspNetConfiguration
+        private static void AddPropertyGroupForAspNetConfiguration
             (
             ProjectInstance traversalProject,
             ProjectInstance metaprojectInstance,
@@ -1666,7 +1637,7 @@ string solutionFile
         /// </summary>
         private string ComputeTargetConditionForWebProject(ProjectInSolution project)
         {
-            StringBuilder condition = new StringBuilder(" ('$(CurrentSolutionConfigurationContents)' != '') and (false");
+            var condition = new StringBuilder(" ('$(CurrentSolutionConfigurationContents)' != '') and (false");
 
             // Loop through all the solution configurations.
             foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionFile.SolutionConfigurations)
@@ -1674,8 +1645,7 @@ private string ComputeTargetConditionForWebProject(ProjectInSolution project)
                 // Find out if the web project has a project configuration for this solution configuration.
                 // (Actually, web projects only have one project configuration, so the TryGetValue should
                 // pretty much always return "true".
-                ProjectConfigurationInSolution projectConfiguration = null;
-                if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
+                if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution projectConfiguration))
                 {
                     // See if the web project is marked as active for this solution configuration.  If so,
                     // we'll build the target.  Otherwise not.
@@ -1708,7 +1678,7 @@ private string ComputeTargetConditionForWebProject(ProjectInSolution project)
         /// @(InstalledAssemblyTables), so that we can pass these into the ResolveAssemblyReference task
         /// when building web projects.
         /// </summary>
-        private void AddTargetForGetFrameworkPathAndRedistList(ProjectInstance metaprojectInstance)
+        private static void AddTargetForGetFrameworkPathAndRedistList(ProjectInstance metaprojectInstance)
         {
             if (metaprojectInstance.Targets.ContainsKey("GetFrameworkPathAndRedistList"))
             {
@@ -1764,10 +1734,7 @@ private void AddMetaprojectTargetForUnknownProjectType(ProjectInstance traversal
 
             foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionFile.SolutionConfigurations)
             {
-                ProjectConfigurationInSolution projectConfiguration = null;
-                ProjectTaskInstance newTask = null;
-
-                if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
+                if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution projectConfiguration))
                 {
                     if (projectConfiguration.IncludeInBuild)
                     {
@@ -1781,21 +1748,21 @@ private void AddMetaprojectTargetForUnknownProjectType(ProjectInstance traversal
                         {
                             // we haven't encountered any problems accessing the project file in the past, but do not support
                             // building this project type
-                            newTask = AddErrorWarningMessageInstance
-                                (
+                            AddErrorWarningMessageInstance
+                            (
                                 newTarget,
                                 null,
                                 XMakeElements.warning,
                                 true,
                                 "SolutionParseUnknownProjectType",
                                 project.RelativePath
-                                );
+                            );
                         }
                         else
                         {
                             // this project file may be of supported type, but we have encountered problems accessing it
-                            newTask = AddErrorWarningMessageInstance
-                                (
+                            AddErrorWarningMessageInstance
+                            (
                                 newTarget,
                                 null,
                                 XMakeElements.warning,
@@ -1803,13 +1770,13 @@ private void AddMetaprojectTargetForUnknownProjectType(ProjectInstance traversal
                                 "SolutionParseErrorReadingProject",
                                 project.RelativePath,
                                 unknownProjectTypeErrorMessage
-                                );
+                            );
                         }
                     }
                     else
                     {
-                        newTask = AddErrorWarningMessageInstance
-                            (
+                        AddErrorWarningMessageInstance
+                        (
                             newTarget,
                             null,
                             XMakeElements.message,
@@ -1817,13 +1784,13 @@ private void AddMetaprojectTargetForUnknownProjectType(ProjectInstance traversal
                             "SolutionProjectSkippedForBuilding",
                             project.ProjectName,
                             solutionConfiguration.FullName
-                            );
+                        );
                     }
                 }
                 else
                 {
-                    newTask = AddErrorWarningMessageInstance
-                        (
+                    AddErrorWarningMessageInstance
+                    (
                         newTarget,
                         null,
                         XMakeElements.warning,
@@ -1831,7 +1798,7 @@ private void AddMetaprojectTargetForUnknownProjectType(ProjectInstance traversal
                         "SolutionProjectConfigurationMissing",
                         project.ProjectName,
                         solutionConfiguration.FullName
-                        );
+                    );
                 }
             }
         }
@@ -1847,14 +1814,13 @@ private void AddValidateProjectsTarget(ProjectInstance traversalProject, List<Pr
             {
                 foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionFile.SolutionConfigurations)
                 {
-                    ProjectConfigurationInSolution projectConfiguration = null;
                     string condition = GetConditionStringForConfiguration(solutionConfiguration);
 
-                    if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
+                    if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out ProjectConfigurationInSolution projectConfiguration))
                     {
                         if (!projectConfiguration.IncludeInBuild)
                         {
-                            ProjectTaskInstance messageTask = AddErrorWarningMessageInstance
+                            AddErrorWarningMessageInstance
                                 (
                                 newTarget,
                                 condition,
@@ -1868,7 +1834,7 @@ private void AddValidateProjectsTarget(ProjectInstance traversalProject, List<Pr
                     }
                     else
                     {
-                        ProjectTaskInstance warningTask = AddErrorWarningMessageInstance
+                        AddErrorWarningMessageInstance
                             (
                             newTarget,
                             condition,
@@ -1886,7 +1852,7 @@ private void AddValidateProjectsTarget(ProjectInstance traversalProject, List<Pr
         ///<summary>
         /// Creates the target used to build all of the references in the traversal project.
         ///</summary>
-        private void AddTraversalReferencesTarget(ProjectInstance traversalProject, string targetName, string outputItem)
+        private static void AddTraversalReferencesTarget(ProjectInstance traversalProject, string targetName, string outputItem)
         {
             string outputItemAsItem = null;
             if (!String.IsNullOrEmpty(outputItem))
@@ -1895,13 +1861,13 @@ private void AddTraversalReferencesTarget(ProjectInstance traversalProject, stri
             }
 
             ProjectTargetInstance target = traversalProject.AddTarget(targetName ?? "Build", String.Empty, String.Empty, outputItemAsItem, null, String.Empty, String.Empty, false /* legacy target returns behaviour */);
-            AddReferencesBuildTask(traversalProject, target, targetName, outputItem);
+            AddReferencesBuildTask(target, targetName, outputItem);
         }
 
         /// <summary>
         /// Adds a task which builds the @(ProjectReference) items.
         /// </summary>
-        private void AddReferencesBuildTask(ProjectInstance projectInstance, ProjectTargetInstance target, string targetToBuild, string outputItem)
+        private static void AddReferencesBuildTask(ProjectTargetInstance target, string targetToBuild, string outputItem)
         {
             ProjectTaskInstance task = target.AddTask("MSBuild", String.Empty, String.Empty);
             if (String.Equals(targetToBuild, "Clean", StringComparison.OrdinalIgnoreCase))
@@ -1966,11 +1932,11 @@ private void AddTraversalTargetForProject(ProjectInstance traversalProject, Proj
             ProjectTargetInstance targetElement = traversalProject.AddTarget(actualTargetName, null, null, outputItemAsItem, null, null, null, false /* legacy target returns behaviour */);
             if (canBuildDirectly)
             {
-                AddProjectBuildTask(traversalProject, project, projectConfiguration, targetElement, targetToBuild, "@(ProjectReference)", "'%(ProjectReference.Identity)' == '" + EscapingUtilities.Escape(project.AbsolutePath) + "'", outputItemName);
+                AddProjectBuildTask(traversalProject, projectConfiguration, targetElement, targetToBuild, "@(ProjectReference)", "'%(ProjectReference.Identity)' == '" + EscapingUtilities.Escape(project.AbsolutePath) + "'", outputItemName);
             }
             else
             {
-                AddMetaprojectBuildTask(traversalProject, project, targetElement, targetToBuild, outputItemName);
+                AddMetaprojectBuildTask(project, targetElement, targetToBuild, outputItemName);
             }
         }
 
@@ -1981,7 +1947,7 @@ private void AddTraversalTargetForProject(ProjectInstance traversalProject, Proj
         /// <returns>A dictionary of global properties.</returns>
         private IDictionary<string, string> GetMetaprojectGlobalProperties(ProjectInstance traversalProject)
         {
-            Dictionary<string, string> properties = new Dictionary<string, string>(_metaprojectGlobalProperties.Length, StringComparer.OrdinalIgnoreCase);
+            var properties = new Dictionary<string, string>(_metaprojectGlobalProperties.Length, StringComparer.OrdinalIgnoreCase);
             foreach (Tuple<string, string> property in _metaprojectGlobalProperties)
             {
                 if (property.Item2 == null)
@@ -2019,16 +1985,9 @@ private IDictionary<string, string> GetMetaprojectGlobalProperties(ProjectInstan
         /// </summary>
         private string DetermineChildProjectToolsVersion(string wrapperProjectToolsVersion)
         {
-            string childProjectToolsVersion = null;
-
-            _globalProperties.TryGetValue("ProjectToolsVersion", out childProjectToolsVersion);
-
-            if (childProjectToolsVersion == null)
-            {
-                childProjectToolsVersion = wrapperProjectToolsVersion;
-            }
+            _globalProperties.TryGetValue("ProjectToolsVersion", out string childProjectToolsVersion);
 
-            return childProjectToolsVersion;
+            return childProjectToolsVersion ?? wrapperProjectToolsVersion;
         }
 
         /// <summary>
@@ -2192,7 +2151,7 @@ private void AddPropertyGroupForSolutionConfiguration(ProjectRootElement travers
         /// configuration. The property is also settable from the command line, in which case it takes 
         /// precedence over this algorithm.
         /// </summary>
-        private void AddVenusConfigurationDefaults(ProjectRootElement traversalProject)
+        private static void AddVenusConfigurationDefaults(ProjectRootElement traversalProject)
         {
             ProjectPropertyGroupElement venusConfiguration = traversalProject.CreatePropertyGroupElement();
             traversalProject.AppendChild(venusConfiguration);
@@ -2286,7 +2245,7 @@ private void AddValidateSolutionConfigurationTarget(ProjectInstance traversalPro
 
             if (_solutionFile.SolutionConfigurations.Count > 0)
             {
-                ProjectTaskInstance errorTask = AddErrorWarningMessageInstance
+                AddErrorWarningMessageInstance
                     (
                     initialTarget,
                     "('$(CurrentSolutionConfigurationContents)' == '') and ('$(SkipInvalidConfigurations)' != 'true')",
@@ -2296,7 +2255,7 @@ private void AddValidateSolutionConfigurationTarget(ProjectInstance traversalPro
                     "$(Configuration)|$(Platform)"
                     );
 
-                ProjectTaskInstance warningTask = AddErrorWarningMessageInstance
+                AddErrorWarningMessageInstance
                     (
                     initialTarget,
                     "('$(CurrentSolutionConfigurationContents)' == '') and ('$(SkipInvalidConfigurations)' == 'true')",
@@ -2306,7 +2265,7 @@ private void AddValidateSolutionConfigurationTarget(ProjectInstance traversalPro
                     "$(Configuration)|$(Platform)"
                     );
 
-                ProjectTaskInstance messageTask = AddErrorWarningMessageInstance
+                AddErrorWarningMessageInstance
                     (
                     initialTarget,
                     "'$(CurrentSolutionConfigurationContents)' != ''",
@@ -2321,7 +2280,7 @@ private void AddValidateSolutionConfigurationTarget(ProjectInstance traversalPro
         /// <summary>
         /// Adds the target which validates that the tools version is supported.
         /// </summary>
-        private void AddValidateToolsVersionsTarget(ProjectInstance traversalProject)
+        private static void AddValidateToolsVersionsTarget(ProjectInstance traversalProject)
         {
             ProjectTargetInstance validateToolsVersionsTarget = traversalProject.AddTarget("ValidateToolsVersions", null, null, null, null, null, null, false /* legacy target returns behaviour */);
             ProjectTaskInstance toolsVersionErrorTask = AddErrorWarningMessageInstance
@@ -2336,7 +2295,7 @@ private void AddValidateToolsVersionsTarget(ProjectInstance traversalProject)
         }
 
         /// <summary> Adds the target to fetch solution configuration contents for given configuration|platform combo. </summary>
-        private void AddGetSolutionConfigurationContentsTarget(ProjectInstance traversalProject)
+        private static void AddGetSolutionConfigurationContentsTarget(ProjectInstance traversalProject)
         {
             var initialTarget = traversalProject.AddTarget(
                 targetName: "GetSolutionConfigurationContents",
diff --git a/src/Build/Construction/UsingTaskParameterGroupElement.cs b/src/Build/Construction/UsingTaskParameterGroupElement.cs
index 4f737b21041..967caceee71 100644
--- a/src/Build/Construction/UsingTaskParameterGroupElement.cs
+++ b/src/Build/Construction/UsingTaskParameterGroupElement.cs
@@ -9,7 +9,6 @@
 using System.Diagnostics;
 using System.Collections.Generic;
 using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
@@ -29,7 +28,7 @@ public class UsingTaskParameterGroupElement : ProjectElementContainer
         internal UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
             VerifyCorrectParent(parent);
         }
 
@@ -47,27 +46,14 @@ private UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, Projec
         /// </summary>
         public override string Condition
         {
-            get
-            {
-                return null;
-            }
-
-            set
-            {
-                ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
-            }
+            get => null;
+            set => ErrorUtilities.ThrowInvalidOperation("OM_CannotGetSetCondition");
         }
 
         /// <summary>
         /// Get any contained parameters.
         /// </summary>
-        public ICollection<ProjectUsingTaskParameterElement> Parameters
-        {
-            get
-            {
-                return new ReadOnlyCollection<ProjectUsingTaskParameterElement>(Children.OfType<ProjectUsingTaskParameterElement>());
-            }
-        }
+        public ICollection<ProjectUsingTaskParameterElement> Parameters => new ReadOnlyCollection<ProjectUsingTaskParameterElement>(Children.OfType<ProjectUsingTaskParameterElement>());
 
         /// <summary>
         /// This does not allow conditions, so it should not be called.
@@ -87,7 +73,7 @@ public override ElementLocation ConditionLocation
         /// </summary>
         public ProjectUsingTaskParameterElement AddParameter(string name, string output, string required, string parameterType)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             ProjectUsingTaskParameterElement newParameter = ContainingProject.CreateUsingTaskParameterElement(name, output, required, parameterType);
             AppendChild(newParameter);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 36c05b7d116..9965d5b98df 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -31,7 +31,7 @@
 
 namespace Microsoft.Build.Evaluation
 {
-    using Utilities = Microsoft.Build.Internal.Utilities;
+    using Utilities = Internal.Utilities;
 
     /// <summary>
     /// Flags for controlling the toolset initialization.
@@ -142,11 +142,6 @@ public void Dispose()
         /// </summary>
         private readonly LoadedProjectCollection _loadedProjects;
 
-        /// <summary>
-        /// The component host for this collection.
-        /// </summary>
-        private IBuildComponentHost _host;
-
         /// <summary>
         /// Single logging service used for all builds of projects in this project collection
         /// </summary>
@@ -222,16 +217,6 @@ public void Dispose()
         /// </summary>
         private int _maxNodeCount;
 
-        /// <summary>
-        /// The cache of project root elements associated with this project collection.
-        /// Each is associated with a specific project collection for two reasons:
-        /// - To help protect one project collection from any XML edits through another one:
-        /// until a reload from disk - when it's ready to accept changes - it won't see the edits;
-        /// - So that the owner of this project collection can force the XML to be loaded again
-        /// from disk, by doing <see cref="UnloadAllProjects"/>.
-        /// </summary>
-        private ProjectRootElementCache _projectRootElementCache;
-
         /// <summary>
         /// Hook up last minute dumping of any exceptions bringing down the process
         /// </summary>
@@ -247,7 +232,7 @@ static ProjectCollection()
         /// information from the configuration file and registry.
         /// </summary>
         public ProjectCollection()
-            : this((IDictionary<string, string>)null)
+            : this(null)
         {
         }
 
@@ -508,7 +493,7 @@ public IDictionary<string, string> GlobalProperties
                         return ReadOnlyEmptyDictionary<string, string>.Instance;
                     }
 
-                    Dictionary<string, string> dictionary = new Dictionary<string, string>(_globalProperties.Count, MSBuildNameIgnoreCaseComparer.Default);
+                    var dictionary = new Dictionary<string, string>(_globalProperties.Count, MSBuildNameIgnoreCaseComparer.Default);
 
                     foreach (ProjectPropertyInstance property in _globalProperties)
                     {
@@ -678,12 +663,7 @@ public HostServices HostServices
             {
                 using (_locker.EnterWriteLock())
                 {
-                    if (_hostServices == null)
-                    {
-                        _hostServices = new HostServices();
-                    }
-
-                    return _hostServices;
+                    return _hostServices ?? (_hostServices = new HostServices());
                 }
             }
 
@@ -881,20 +861,8 @@ internal int MaxNodeCount
         /// - So that the owner of this project collection can force the XML to be loaded again
         /// from disk, by doing <see cref="UnloadAllProjects"/>.
         /// </summary>
-        internal ProjectRootElementCache ProjectRootElementCache
-        {
-            get
-            {
-                // no locks required because this field is only set in the constructor.
-                return _projectRootElementCache;
-            }
-
-            private set
-            {
-                // no locks required because this field is only set in the constructor.
-                _projectRootElementCache = value;
-            }
-        }
+        // No locks required because this field is only set in the constructor.
+        internal ProjectRootElementCache ProjectRootElementCache { get; }
 
         /// <summary>
         /// Escape a string using MSBuild escaping format. For example, "%3b" for ";".
@@ -932,7 +900,7 @@ public void AddToolset(Toolset toolset)
         {
             using (_locker.EnterWriteLock())
             {
-                ErrorUtilities.VerifyThrowArgumentNull(toolset, "toolset");
+                ErrorUtilities.VerifyThrowArgumentNull(toolset, nameof(toolset));
 
                 _toolsets[toolset.ToolsVersion] = toolset;
 
@@ -970,7 +938,7 @@ public void RemoveAllToolsets()
             bool changed = false;
             using (_locker.EnterWriteLock())
             {
-                List<Toolset> toolsets = new List<Toolset>(Toolsets);
+                var toolsets = new List<Toolset>(Toolsets);
 
                 foreach (Toolset toolset in toolsets)
                 {
@@ -992,7 +960,7 @@ public Toolset GetToolset(string toolsVersion)
         {
             using (_locker.EnterWriteLock())
             {
-                ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
+                ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
 
                 _toolsets.TryGetValue(toolsVersion, out var toolset);
 
@@ -1358,7 +1326,7 @@ public void SetGlobalProperty(string name, string value)
                 }
 
                 // Copy LoadedProjectCollection as modifying a project's global properties will cause it to re-add
-                List<Project> projects = new List<Project>(_loadedProjects);
+                var projects = new List<Project>(_loadedProjects);
                 foreach (Project project in projects)
                 {
                     project.SetGlobalProperty(name, value);
@@ -1381,7 +1349,7 @@ public bool RemoveGlobalProperty(string name)
                 set = _globalProperties.Remove(name);
 
                 // Copy LoadedProjectCollection as modifying a project's global properties will cause it to re-add
-                List<Project> projects = new List<Project>(_loadedProjects);
+                var projects = new List<Project>(_loadedProjects);
                 foreach (Project project in projects)
                 {
                     project.RemoveGlobalProperty(name);
@@ -1413,7 +1381,6 @@ public void Dispose()
         /// <param name="host">The component host.</param>
         void IBuildComponent.InitializeComponent(IBuildComponentHost host)
         {
-            _host = host;
         }
 
         /// <summary>
@@ -1421,7 +1388,6 @@ void IBuildComponent.InitializeComponent(IBuildComponentHost host)
         /// </summary>
         void IBuildComponent.ShutdownComponent()
         {
-            _host = null;
         }
 
 #endregion
@@ -1729,23 +1695,18 @@ private void InitializeToolsetCollection(
         [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible", Justification = "This has been API reviewed")]
         public class ProjectAddedToProjectCollectionEventArgs : EventArgs
         {
-            /// <summary>
-            /// Root element which was added to the project collection.
-            /// </summary>
-            private readonly ProjectRootElement _rootElement;
-
             /// <summary>
             /// The root element which was added to the project collection.
             /// </summary>
             public ProjectAddedToProjectCollectionEventArgs(ProjectRootElement element)
             {
-                _rootElement = element;
+                ProjectRootElement = element;
             }
 
             /// <summary>
             /// Root element which was added to the project collection.
             /// </summary>
-            public ProjectRootElement ProjectRootElement => _rootElement;
+            public ProjectRootElement ProjectRootElement { get; }
         }
 
         /// <summary>
@@ -1979,7 +1940,6 @@ public void IncludeTaskInputs()
             public LoggerVerbosity Verbosity
             {
                 get => _originalLogger.Verbosity;
-
                 set => _originalLogger.Verbosity = value;
             }
 
@@ -2300,13 +2260,6 @@ private class LoadedProjectCollection : IEnumerable<Project>
             /// </summary>
             private int _count;
 
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            internal LoadedProjectCollection()
-            {
-            }
-
             /// <summary>
             /// Returns the number of projects currently loaded
             /// </summary>
@@ -2358,7 +2311,7 @@ internal IList<Project> GetMatchingProjectsIfAny(string fullPath)
             {
                 lock (_loadedProjects)
                 {
-                    _loadedProjects.TryGetValue(fullPath, out var candidates);
+                    _loadedProjects.TryGetValue(fullPath, out List<Project> candidates);
 
                     return candidates ?? (IList<Project>)Enumerable.Empty<Project>();
                 }
@@ -2373,7 +2326,7 @@ internal Project GetMatchingProjectIfAny(string fullPath, IDictionary<string, st
             {
                 lock (_loadedProjects)
                 {
-                    if (_loadedProjects.TryGetValue(fullPath, out var candidates))
+                    if (_loadedProjects.TryGetValue(fullPath, out List<Project> candidates))
                     {
                         foreach (Project candidate in candidates)
                         {
@@ -2396,7 +2349,7 @@ internal void AddProject(Project project)
             {
                 lock (_loadedProjects)
                 {
-                    if (!_loadedProjects.TryGetValue(project.FullPath, out var projectList))
+                    if (!_loadedProjects.TryGetValue(project.FullPath, out List<Project> projectList))
                     {
                         projectList = new List<Project>();
                         _loadedProjects.Add(project.FullPath, projectList);
@@ -2432,7 +2385,7 @@ internal bool RemoveProject(string projectFullPath, Project project)
             {
                 lock (_loadedProjects)
                 {
-                    if (!_loadedProjects.TryGetValue(projectFullPath, out var projectList))
+                    if (!_loadedProjects.TryGetValue(projectFullPath, out List<Project> projectList))
                     {
                         return false;
                     }
@@ -2469,7 +2422,7 @@ internal void RemoveAllProjects()
             /// Returns true if the global properties and tools version provided are equivalent to
             /// those in the provided project, otherwise false.
             /// </summary>
-            private bool HasEquivalentGlobalPropertiesAndToolsVersion(Project project, IDictionary<string, string> globalProperties, string toolsVersion)
+            private static bool HasEquivalentGlobalPropertiesAndToolsVersion(Project project, IDictionary<string, string> globalProperties, string toolsVersion)
             {
                 if (!String.Equals(project.ToolsVersion, toolsVersion, StringComparison.OrdinalIgnoreCase))
                 {
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index be14a066222..65ccf6137c6 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -11,7 +11,6 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Runtime.Serialization;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Collections
 {
@@ -47,21 +46,12 @@ internal class CopyOnWriteDictionary<K, V> : IDictionary<K, V>, IDictionary wher
         /// </summary>
         private static readonly bool s_forceWrite = (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDFORCECOWCOPY")));
 #endif
-        /// <summary>
-        /// The equality comparer to use when the dictionary is created.
-        /// </summary>
-        private readonly IEqualityComparer<K> keyComparer;
 
         /// <summary>
         /// The default capacity.
         /// </summary>
         private readonly int capacity;
 
-        /// <summary>
-        /// A special single dummy instance that always appears empty.
-        /// </summary>
-        private static CopyOnWriteDictionary<K, V> s_dummy = new CopyOnWriteDictionary<K, V>();
-
         /// <summary>
         /// The backing dictionary.
         /// Lazily created.
@@ -97,7 +87,7 @@ internal CopyOnWriteDictionary(IEqualityComparer<K> keyComparer)
         internal CopyOnWriteDictionary(int capacity, IEqualityComparer<K> keyComparer)
         {
             this.capacity = capacity;
-            this.keyComparer = keyComparer;
+            Comparer = keyComparer;
         }
 
         /// <summary>
@@ -114,7 +104,7 @@ protected CopyOnWriteDictionary(SerializationInfo info, StreamingContext context
         /// </summary>
         private CopyOnWriteDictionary(CopyOnWriteDictionary<K, V> that)
         {
-            keyComparer = that.keyComparer;
+            Comparer = that.Comparer;
             backing = that.backing;
             if (backing != null)
             {
@@ -127,7 +117,7 @@ private CopyOnWriteDictionary(CopyOnWriteDictionary<K, V> that)
 
         public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
         {
-            foreach (var pair in dictionary)
+            foreach (KeyValuePair<K, V> pair in dictionary)
             {
                 this[pair.Key] = pair.Value;
             }
@@ -136,101 +126,62 @@ public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
         /// <summary>
         /// Returns the collection of keys in the dictionary.
         /// </summary>
-        public ICollection<K> Keys
-        {
-            get
-            {
-                return ReadOperation.Keys;
-            }
-        }
+        public ICollection<K> Keys => ReadOperation.Keys;
 
         /// <summary>
         /// Returns the collection of values in the dictionary.
         /// </summary>
-        public ICollection<V> Values
-        {
-            get { return ReadOperation.Values; }
-        }
+        public ICollection<V> Values => ReadOperation.Values;
 
         /// <summary>
         /// Returns the number of items in the collection.
         /// </summary>
-        public int Count
-        {
-            get { return ReadOperation.Count; }
-        }
+        public int Count => ReadOperation.Count;
 
         /// <summary>
         /// Returns true if the collection is read-only.
         /// </summary>
-        public bool IsReadOnly
-        {
-            get { return ((IDictionary<K, V>)ReadOperation).IsReadOnly; }
-        }
+        public bool IsReadOnly => ((IDictionary<K, V>)ReadOperation).IsReadOnly;
 
         /// <summary>
         /// IDictionary implementation
         /// </summary>
-        bool IDictionary.IsFixedSize
-        {
-            get { return false; }
-        }
+        bool IDictionary.IsFixedSize => false;
 
         /// <summary>
         /// IDictionary implementation
         /// </summary>
-        bool IDictionary.IsReadOnly
-        {
-            get { return IsReadOnly; }
-        }
+        bool IDictionary.IsReadOnly => IsReadOnly;
 
         /// <summary>
         /// IDictionary implementation
         /// </summary>
-        ICollection IDictionary.Keys
-        {
-            get { return (ICollection)Keys; }
-        }
+        ICollection IDictionary.Keys => (ICollection)Keys;
 
         /// <summary>
         /// IDictionary implementation
         /// </summary>
-        ICollection IDictionary.Values
-        {
-            get { return (ICollection)Values; }
-        }
+        ICollection IDictionary.Values => (ICollection)Values;
 
         /// <summary>
         /// IDictionary implementation
         /// </summary>
-        int ICollection.Count
-        {
-            get { return Count; }
-        }
+        int ICollection.Count => Count;
 
         /// <summary>
         /// IDictionary implementation
         /// </summary>
-        bool ICollection.IsSynchronized
-        {
-            get { return false; }
-        }
+        bool ICollection.IsSynchronized => false;
 
         /// <summary>
         /// IDictionary implementation
         /// </summary>
-        object ICollection.SyncRoot
-        {
-            get { return this; }
-        }
+        object ICollection.SyncRoot => this;
 
         /// <summary>
         /// A special single dummy instance that always appears empty.
         /// </summary>
-        internal static CopyOnWriteDictionary<K, V> Dummy
-        {
-            get { return s_dummy; }
-        }
+        internal static CopyOnWriteDictionary<K, V> Dummy { get; } = new CopyOnWriteDictionary<K, V>();
 
         /// <summary>
         /// Whether this is a dummy instance that always appears empty.
@@ -239,7 +190,7 @@ internal bool IsDummy
         {
             get
             {
-                if (Object.ReferenceEquals(this, Dummy))
+                if (ReferenceEquals(this, Dummy))
                 {
                     ErrorUtilities.VerifyThrow(backing == null || backing.Count == 0, "count"); // check count without recursion
                     return true;
@@ -252,10 +203,7 @@ internal bool IsDummy
         /// <summary>
         /// Comparer used for keys
         /// </summary>
-        internal IEqualityComparer<K> Comparer
-        {
-            get { return keyComparer; }
-        }
+        internal IEqualityComparer<K> Comparer { get; private set; }
 
         /// <summary>
         /// Gets the backing dictionary for reading.
@@ -294,7 +242,7 @@ private CopyOnWriteBackingDictionary<K, V> WriteOperation
 
                 if (backing == null)
                 {
-                    backing = new CopyOnWriteBackingDictionary<K, V>(capacity, keyComparer);
+                    backing = new CopyOnWriteBackingDictionary<K, V>(capacity, Comparer);
                 }
                 else
                 {
@@ -313,10 +261,7 @@ private CopyOnWriteBackingDictionary<K, V> WriteOperation
         /// </summary>
         public V this[K key]
         {
-            get
-            {
-                return ReadOperation[key];
-            }
+            get => ReadOperation[key];
 
             set
             {
@@ -329,8 +274,7 @@ public V this[K key]
                     else
                     {
                         // Try to avoid a clone if it already is present with the same value
-                        V existingValue = default(V);
-                        if (!ReadOperation.TryGetValue(key, out existingValue) || !EqualityComparer<V>.Default.Equals(existingValue, value))
+                        if (!ReadOperation.TryGetValue(key, out V existingValue) || !EqualityComparer<V>.Default.Equals(existingValue, value))
                         {
                             WriteOperation[key] = value;
                         }
@@ -346,18 +290,11 @@ object IDictionary.this[object key]
         {
             get
             {
-                if (!ContainsKey((K)key))
-                {
-                    return null;
-                }
-
-                return this[(K)key];
+                TryGetValue((K) key, out V val);
+                return val;
             }
 
-            set
-            {
-                this[(K)key] = (V)value;
-            }
+            set => this[(K)key] = (V)value;
         }
 
         /// <summary>
@@ -473,7 +410,7 @@ public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
         /// <summary>
         /// Implementation of IEnumerable.GetEnumerator()
         /// </summary>
-        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+        IEnumerator IEnumerable.GetEnumerator()
         {
             return ((IEnumerable<KeyValuePair<K, V>>)this).GetEnumerator();
         }
@@ -544,7 +481,7 @@ internal CopyOnWriteDictionary<K, V> Clone()
         /// </summary>
         internal bool HasSameBacking(CopyOnWriteDictionary<K, V> other)
         {
-            return Object.ReferenceEquals(other.backing, backing);
+            return ReferenceEquals(other.backing, backing);
         }
 
         /// <summary>
@@ -590,7 +527,6 @@ protected CopyOnWriteBackingDictionary(SerializationInfo info, StreamingContext
             /// Empty constructor.
             /// </summary>
             private CopyOnWriteBackingDictionary()
-                : base()
             {
             }
 
@@ -606,13 +542,7 @@ private CopyOnWriteBackingDictionary(CopyOnWriteBackingDictionary<K1, V1> that)
             /// <summary>
             /// Returns a read-only empty instance.
             /// </summary>
-            public static CopyOnWriteBackingDictionary<K1, V1> ReadOnlyEmptyInstance
-            {
-                get
-                {
-                    return s_readOnlyEmptyDictionary;
-                }
-            }
+            public static CopyOnWriteBackingDictionary<K1, V1> ReadOnlyEmptyInstance => s_readOnlyEmptyDictionary;
 
             /// <summary>
             /// Returns true if this collection has no clones.
