diff --git a/.editorconfig b/.editorconfig
index b8e856dc62d..5311eb964aa 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -157,6 +157,11 @@ csharp_space_between_square_brackets = false
 dotnet_code_quality.ca1802.api_surface = private, internal
 dotnet_code_quality.ca2208.api_surface = public
 
+# RS0037: Enable tracking of nullability of reference types in the declared API
+# Our API is not annotated but new classes get nullable enabled so disable this.
+# We'd be happy if everything was annotated and this could be removed.
+dotnet_diagnostic.RS0037.severity = none
+
 # License header
 file_header_template = Licensed to the .NET Foundation under one or more agreements.\nThe .NET Foundation licenses this file to you under the MIT license.\n
 
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
new file mode 100644
index 00000000000..fff37c62621
--- /dev/null
+++ b/.github/dependabot.yml
@@ -0,0 +1,7 @@
+version: 2
+updates:
+  - package-ecosystem: "nuget"
+    directory: "/eng/dependabot"
+    open-pull-requests-limit: 3
+    schedule:
+      interval: "weekly"
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 00000000000..2909e3ff6cd
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,80 @@
+{
+    // See https://go.microsoft.com/fwlink/?LinkId=733558
+    // for the documentation about the tasks.json format
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "label": "dotnet msbuild MSBuild.Dev.slnf",
+            "command": "dotnet",
+            "type": "process",
+            "args": [
+                "msbuild",
+                // Ask MSBuild to generate full paths for file names.
+                "/property:GenerateFullPaths=true",
+                // Do not generate summary otherwise it leads to duplicate errors in Problems panel
+                "/consoleloggerparameters:NoSummary",
+                "${workspaceFolder}/MSBuild.Dev.slnf"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "full build",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-bl",
+                "/property:CreateBootstrap=true",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "build -test",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-test",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": {
+                "kind": "test",
+                "isDefault": true
+            },
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        }
+    ]
+}
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index bbbf0897830..83ea156bfaf 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -7,7 +7,7 @@ jobs:
 - job: BootstrapMSBuildOnFullFrameworkWindows
   displayName: "Windows Full"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -53,7 +53,7 @@ jobs:
 - job: BootstrapMSBuildOnCoreWindows
   displayName: "Windows Core"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -100,7 +100,7 @@ jobs:
 - job: FullReleaseOnWindows
   displayName: "Windows Full Release (no bootstrap)"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild.cmd
@@ -147,7 +147,7 @@ jobs:
 - job: RichCodeNavIndex
   displayName: "Windows Code Indexing"
   pool:
-    vmImage: 'windows-latest'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: build.cmd
@@ -197,7 +197,7 @@ jobs:
 - job: CoreOnMac
   displayName: "macOS Core"
   pool:
-    vmImage: 'macOS-10.14'
+    vmImage: 'macOS-latest'
   steps:
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh'
     displayName: CI Build
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 415fa36b412..c6ed508dfc8 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -52,7 +52,7 @@ stages:
 
   - job: Windows_NT
     pool:
-      name: VSEngSS-MicroBuild2019-1ES
+      name: VSEngSS-MicroBuild2022-1ES
       demands:
       - agent.os -equals Windows_NT
 
@@ -90,14 +90,14 @@ stages:
         signType: $(SignType)
         zipSources: false
       condition: and(succeeded(), in(variables['SignType'], 'test', 'real'))
-      
+
     - task: MicroBuildOptProfPlugin@6
       inputs:
         ProfilingInputsDropName: '$(VisualStudio.DropName)'
         ShouldSkipOptimize: true
         AccessToken: '$(System.AccessToken)'
         feedSource: 'https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/MicroBuildToolset/nuget/v3/index.json'
-      displayName: 'Install OptProf Plugin'      
+      displayName: 'Install OptProf Plugin'
 
     # Required by MicroBuildBuildVSBootstrapper
     - task: ms-vseng.MicroBuildTasks.32f78468-e895-4f47-962c-58a699361df8.MicroBuildSwixPlugin@1
diff --git a/documentation/Built-in-Propeties.md b/documentation/Built-in-Propeties.md
new file mode 100644
index 00000000000..01c880aeb56
--- /dev/null
+++ b/documentation/Built-in-Propeties.md
@@ -0,0 +1,21 @@
+# MSBuild's reserved and built-in properties
+
+The MSBuild engine itself sets some properties for all projects. There is normal documentation for the [reserved properties and their meanings](https://docs.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties). This document describes the implementation of these properties in MSBuild itself.
+
+There are actually two different implementations of this functionality in MSBuild.
+
+## Built-in properties
+
+When evaluating an individual project, Pass 0 of the evaluation calls [`AddBuiltInProperties()`][addbuiltinproperties] which in turn calls [`SetBuiltInProperty()`][setbuiltinproperty] which sets the property basically as normal.
+
+However, properties set there are not available at all parts of execution, and specifically they're not available when evaluating the `.tasks` file that makes MSBuild's built-in tasks available by default to all projects.
+
+## Reserved properties
+
+Reserved properties are [set by the toolset][toolset_reservedproperties] and are available _only_ in the `.tasks` and `.overridetasks` cases. Properties set there are not available in normal project evaluation.
+
+[addbuiltinproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L609-L612
+
+[setbuiltinproperty]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L1257
+
+[toolset_reservedproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Definition/Toolset.cs#L914-L921
diff --git a/documentation/Changelog.md b/documentation/Changelog.md
index 19f97e2e2e7..be02ae3e952 100644
--- a/documentation/Changelog.md
+++ b/documentation/Changelog.md
@@ -1,5 +1,104 @@
 # MSBuild Changelog
 
+## MSBuild 17.0.0
+
+This version of MSBuild shipped with Visual Studio 2022 version 17.0.0 and .NET SDK 6.0.100.
+
+### What's new
+
+* MSBuild now reports its version as `17` and uses Visual Studio 2022 versions of tasks where appropriate.
+* MSBuild now targets .NET Framework 4.7.2 and .NET 6.0.
+* 64-bit MSBuild is now used for builds from Visual Studio.
+* Binary logs are smaller and have more information.
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds.
+* The method `GetType()` can no longer be called in property functions.
+
+### Detailed release notes
+
+#### Added
+
+* Intrinsic tasks now log their location (#6397). Thanks, @KirillOsenkov!
+* `TargetSkippedEventArgs` now has `TargetSkipReason` and `OriginalBuildEventContext` (#6402, #6577). Thanks, @KirillOsenkov!
+* `TaskStarted` events now log line and column (#6399). Thanks, @KirillOsenkov!
+* ETW trace events for PerformDependencyAnalysis (#6658), WriteLinesToFile (#6670), CopyUpToDate (#6661).
+* If the environment variable `MSBuildDebugEngine` is set, MSBuild will create binary logs for all operations to `MSBUILDDEBUGPATH` regardless of how it is called (#6639, #6792).
+* `ProjectReference`s can now negotiate `Platform` (#6655, #6724, #6889).
+* Tasks can now call `TaskLoggingHelper.LogsMessagesOfImportance` to determine if any attached logger would preserve a log message before constructing it (to save time in the not-being-logged case) (#6381, #6737).
+* Support referencing assemblies with generic attributes (#6735). Thanks, @davidwrighton!
+* XSD-based MSBuild IntelliSense now supports `ImplicitUsings` and `Using` items (#6755), `InternalsVisibleTo` (#6778), Windows Forms properties (#6860), `DebugType` (#6849), and `SatelliteResourceLanguages` (#6861). Thanks, @pranavkm, @DamianEdwards, @RussKie, and @drewnoakes!
+* Tasks can now call `TaskLoggingHelper.IsTaskInputLoggingEnabled` and avoid redundant logging of inputs (#6803).
+* Support extracting resource namespace from C# source that uses file-scoped namespaces (#6881).
+
+#### Changed
+
+* The on-disk format of serialized caches has changed (#6350, #6324, #6490, #6674).
+* MSBuild is now [signed with a new certificate](https://github.com/dotnet/announcements/issues/184) (#6448).
+* `BuildParameters.DisableInprocNode` now applies to more processes (#6400).
+* `VCTargetsPath` now defaults to `v170` (#6550).
+* MSBuild no longer logs `Building with tools version "Current"` (#6627). Thanks, @KirillOsenkov!
+* Text loggers now log properties and items at the end of evaluation (#6535).
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds (#6622, #6703).
+* MSBuild on .NET 6 has improved task-assembly-reference fallback behavior (#6558).
+* MSBuild features gated on the 16.8 changewave are now nonconfigurable (#6634).
+* The deprecated import of `$(CoreCrossTargetingTargetsPath)` was removed (#6668). Thanks, @Nirmal4G!
+* Improved error message for `MSB4213` (#6640).
+* The method `GetType()` can no longer be called in property functions (#6769).
+* MSBuild is now fully NGENed by Visual Studio setup (#6764).
+* MSBuild (and Visual Studio) now reference `System.Text.Json` 5.0.2 (#6784). Thanks, @JakeRadMSFT!
+* Default to SHA2 digest for ClickOnce manifest when certificate signing algorithm is sha256/384/512 (#6882).
+
+#### Fixed
+
+* Solution builds should work when using the secret environment variable `MSBUILDNOINPROCNODE` (#6385).
+* Solution extensions can now use `BeforeTargets="ValidateSolutionConfiguration"` (#6454).
+* Performance improvements (#6529, #6556, #6598, #6632, #6669, #6671, #6666, #6678, #6680, #6705, #6595, #6716, #6786, #6816, #6832, #6845).
+* Single-file ClickOnce publish includes file association icons (#6578).
+* Improved robustness in error handling of libraries without resources (#6546).
+* Fixed missing information in `Project`'s `DebuggerDisplay` (#6650).
+* `ResolveAssemblyReferences` output paths are now output in normalized form (#6533).
+* Improved handling of satellite assemblies in ClickOnce (#6665).
+* Roslyn code analyzers are no longer run during XAML precompilation (#6676). Thanks, @jlaanstra!
+* 64-bit API callers no longer need to set `MSBUILD_EXE_PATH` (#6683, #6746).
+* `EvaluateStop` ETW events are now automatically correlated with `EvaluateStart` (#6725).
+* Evaluation time is included in text performance traces (#6725).
+* Add PackageDescription to `Microsoft.NET.StringTools` (#6740).
+* Fixed deadlock between `ExecuteSubmission` and `LoggingService` (#6717).
+* Narrowed conditions where MSBuild would blame NuGet for SDK resolution problems (#6742).
+* `CombineTargetFrameworkInfoProperties` no longer fails on portable framework names (#6699).
+* Avoid needless builds of `GenerateBindingRedirects` (#6726).
+* The solution configuration is now passed to experimental cache plugins (#6738).
+* Clearer errors when SDK resolvers throw exceptions (#6763).
+* Improved errors from `InternableString.ExpensiveConvertToString` (#6798).
+* Binding redirects for all `System.*` assemblies updated (#6830).
+* Fixed deadlock between `BuildManager` and `LoggingService` (#6837).
+* Log message arguments for warnings and errors (#6804). Thanks, @KirillOsenkov!
+* Use static CoreClrAssemblyLoader for SDK resolvers (#6864). Thanks, @marcin-krystianc!
+* Avoid break caused by fix and workaround for AL path colliding (#6884).
+* Support private-use area Unicode characters in paths passed to `XslTransformation` (#6863, #6946). Thanks, @lanfeust69!
+* Use the correct .NET host when called from a .NET 6.0 application (#6890).
+
+#### Infrastructure
+
+* This repo now builds with Arcade 6.0 (#6143).
+* Use newer Ubuntu versions for Linux CI builds (#6488).
+* MSBuild now uses [Arcade-powered source build](https://github.com/dotnet/source-build/tree/ba0b33e9f96354b8d07317c3cdf406ce666921f8/Documentation/planning/arcade-powered-source-build) (#6387).
+* Improved repo issue templates and automation (#6557).
+* Whitespace cleanup (#6565).
+* This repo no longer needs to double-specify the SDK version (#6596).
+* Simplify references to `TargetFramework` using new intrinsics (#5799).
+* Reference the `Microsoft.DotNet.XUnitExtensions` package from Arcade instead of our fork (#6638).
+* Use [`BannedApiAnalyzers`](https://www.nuget.org/packages/Microsoft.CodeAnalysis.BannedApiAnalyzers/) (#6675).
+* Enable analyzers for the MSBuild repo with rules similar to `dotnet/runtime` (#5656). Thanks, @elachlan!
+* Improved internal OptProf training scenarios (#6758).
+* Delete Unreachable code (#6805). Thanks, @KirillOsenkov!
+* Upgrade System.Net.Http package version used in tests (#6879).
+
+#### Documentation
+
+* Use GitHub-generated Markdown tables of contents (#6760).
+* Fixed validation issues in docs build (#6744).
+* Descriptions of labels in use in this repo (#6873).
+
 ## MSBuild 16.11.0
 
 This version of MSBuild shipped with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index 5e2a138e3d5..9dc2f404fa2 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -22,7 +22,7 @@ Importing `Microsoft.Common.targets` includes logic that consumes these items an
 
 ## Who this document is for
 
-This document describes that process, including what is required of a project to be referenceable through a `ProjectReference`. It is intended for for MSBuild SDK maintainers, and those who have created a completely custom project type that needs to interoperate with other projects. It may also be of interest if you'd like to see the implementation details of references. Understanding the details should not be necessary to _use_ `ProjectReferences` in your project.
+This document describes that process, including what is required of a project to be referenceable through a `ProjectReference`. It is intended for MSBuild SDK maintainers, and those who have created a completely custom project type that needs to interoperate with other projects. It may also be of interest if you'd like to see the implementation details of references. Understanding the details should not be necessary to _use_ `ProjectReferences` in your project.
 
 ## Targets related to consuming a reference
 
@@ -51,7 +51,7 @@ These targets should exist in a project to be compatible with the common targets
 
 These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
 
-If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworkProperties` is required in the “outer” build. The other targets listed can be “inner” build only.
+If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworks` is required in the “outer” build. The other targets listed can be “inner” build only.
 
 * `GetTargetFrameworks` tells referencing projects what options are available to the build.
   * It returns an item with the following metadata:
@@ -106,7 +106,7 @@ As of MSBuild 16.10, it is possible to gather additional properties from referen
 
 These properties will then be gathered via the `GetTargetFrameworks` call.  They will be available to the referencing project via the `AdditionalPropertiesFromProject` metadata on the `_MSBuildProjectReferenceExistent` item.  The `AdditionalPropertiesFromProject` value will be an XML string which contains the values of the properties for each `TargetFramework` in the referenced project.  For example:
 
-> :warning: This format is being changed. Soon, the schema will replace <net5.0> with <TargetFramework Name="net5.0">. You can opt into that behavior early by setting the _UseAttributeForTargetFrameworkInfoPropertyNames property to true. This property will have no effect after the transition is complete.
+> :warning: This format is being changed. Soon, the schema will replace `<net5.0>` with `<TargetFramework Name="net5.0">`. You can opt into that behavior early by setting the `_UseAttributeForTargetFrameworkInfoPropertyNames` property to true. This property will have no effect after the transition is complete.
 
 ```xml
 <AdditionalProjectProperties>
@@ -176,7 +176,7 @@ Project B: Unmanaged, has `$(Platforms)` constructed from its `Platform` metadat
 Because `AnyCPU` does not map to anything architecture-specific, a custom mapping must be defined. Project A can either:
 1. Define `PlatformLookupTable` in its project or a Directory.Build.props as `AnyCPU=x64` or `AnyCPU=Win32`.
 2. Define `PlatformLookupTable` as metadata on the `ProjectReference` item, which would take priority over a lookup table defined elsewhere.
-     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo` (for unmanaged) or `PlatformTarget=bar` (for managed). This would skip over most negotiation logic.
+     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo`. This would skip over most negotiation logic.
 
 Example of project A defining a lookup table directly on the `ProjectReference`:
 ```xml
diff --git a/documentation/consuming-nuget-package.md b/documentation/consuming-nuget-package.md
index e4e42f5c187..e611e2194d6 100644
--- a/documentation/consuming-nuget-package.md
+++ b/documentation/consuming-nuget-package.md
@@ -30,7 +30,7 @@ The items in this namespace are MSBuild tasks that have been developed by the MS
 [Csc](https://msdn.microsoft.com/en-us/library/microsoft.build.tasks.csc.aspx), and [Exec](https://msdn.microsoft.com/en-us/library/microsoft.build.tasks.exec.aspx).
 
 Most developers do not need to reference this package unless they want to extend a stock MSBuild task with custom functionality.  Alternatively, we recommend that MSBuild task developers reference the 
-`Microsoft.Build.Utilites.Core` package and implement the abstract class [Task](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.task.aspx) or
+`Microsoft.Build.Utilities.Core` package and implement the abstract class [Task](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.task.aspx) or
 [ToolTask](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.tooltask.aspx).
 
 ## Microsoft.Build
diff --git a/documentation/release.md b/documentation/release.md
new file mode 100644
index 00000000000..7ef016408f5
--- /dev/null
+++ b/documentation/release.md
@@ -0,0 +1,19 @@
+# MSBuild release process
+
+This is a description of the steps required to release MSBuild. It is **incomplete**; when something not present here is discovered to be required it should be added.
+
+## Final branding/versioning
+
+To produce packages without a `-prerelease` suffix, we need to specify `<DotNetFinalVersionKind>release</DotNetFinalVersionKind>` (see the [Arcade versioning docs]). This is ideally done on the same line as the version specification so that it causes a Git merge conflict when merging to the next release's branch. See [#6902](https://github.com/dotnet/msbuild/pull/6902) for an example.
+
+[Arcade versioning docs]: https://github.com/dotnet/arcade/blob/31cecde14e1512ecf60d2d8afb71fd240919f4a8/Documentation/CorePackages/Versioning.md
+
+## Public API
+
+As of [#7018](https://github.com/dotnet/msbuild/pull/7018), MSBuild uses a Roslyn analyzer to ensure compatibility with assemblies compiled against older versions of MSBuild. The workflow of the analyzer is:
+
+1. The analyzer keeps the `PublicAPI.Unshipped.txt` files updated.
+2. New API surface goes into `PublicAPI.Unshipped.txt`.
+3. At release time, we must manually promote the `Unshipped` public API to `Shipped`.
+
+That is a new step in our release process for each formal release (including patch releases if they change API surface).
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
index f269670e0ef..7df20c12b5f 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
@@ -45,3 +45,5 @@ To build projects using the MSBuild binaries from the repository, you first need
 Now, just point `dotnet ./artifacts/bin/bootstrap/netcoreapp2.1/MSBuild/MSBuild.dll` at a project file.
 
 Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the just-built MSBuild . You might have to kill existing `dotnet` processes before doing this. You can use [`Deploy-MSBuild.ps1 -runtime Core`](../Deploy-MSBuild.md#.NET-(Core)-SDK) to do the copy. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
+
+See other debugging options [here](./Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#Debugging-MSBuild).
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index 114bc177306..b4421d10d25 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -35,11 +35,6 @@ Please see [Contributing Code](https://github.com/Microsoft/msbuild/blob/master/
 
 ## Walkthroughs
 
-### Debugging MSBuild
-
-- Breaking into the main method of MSBuild.exe: set the environment variable `MSBUILDDEBUGONSTART` to 1 or 2: https://github.com/Microsoft/msbuild/blob/master/src/MSBuild/XMake.cs#L488-L501
-- Dumping scheduler state: set `MSBUILDDEBUGSCHEDULER` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
-
 ### Using the repository binaries to perform builds
 
 To build projects using the MSBuild binaries from the repository, you first need to do a build which produces
@@ -49,6 +44,34 @@ from Visual Studio). To produce a bootstrap build, run `.\build.cmd /p:CreateBoo
 
 Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe` at a project file.
 
-### Patching Visual Studio
+### Patching Visual Studio with repository binaries
+
+Sometimes it's useful to patch your copy of Visual Studio in order to test or debug your local MSBuild changes from Visual Studio. You can use the [Deploy-MSBuild script](../Deploy-MSBuild.md) for copying your locally built MSBuild binaries over the MSBuild binaries shipping with Visual Studio. Example usage:
+```
+# bootstrap build
+.\build.cmd /p:CreateBootstrap=true
+
+# copy the bootstrap build output over the MSBuild binaries in Visual Studio
+.\scripts\Deploy-MSBuild.ps1 -destination "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin"
+```
+
+### Debugging MSBuild
+
+#### Breakpoints
+To break into the [main method](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/MSBuild/XMake.cs#L493-L506) of MSBuild.exe: set the environment variable `MSBUILDDEBUGONSTART` to 1 (uses `Debugger.Launch()`) or 2 (waits until debugger is attached).
+
+To break into MSBuild's [BuildManager.BeginBuild](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/BuildManager/BuildManager.cs#L414) set the environment variable `MSBuildDebugBuildManagerOnStart` to 1 (uses `Debugger.Launch()`) or 2 (waits until debugger is attached).
+This is useful for debugging MSBuild when it is called from other apps that use its APIs instead of its executable (for example Visual Studio). You can also filter which processes trigger the breakpoint by setting `MSBuildDebugProcessName` to a substring of the process name. For example, to trigger the breakpoint only under Visual Studio's top level process you would set `MSBuildDebugProcessName` to the value `devenv`.
+
+#### Logs
+You can set the environment variable `MSBuildDebugEngine` to 1 to have MSBuild dump all of its possible debugging logs (for example, scheduler state, node communication).
+
+It also injects a binary log during [BuildManager.BeginBuild](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/BuildManager/BuildManager.cs#L491), which is incredibly useful when MSBuild is being called through its APIs from other apps that inhibit or filter MSBuild's event messages. For example, Visual Studio heavily filters build event messages when doing normal builds and inhibits build events when it's performing [design time builds](https://github.com/dotnet/project-system/blob/04474df00ebd742e05d31f8e487d6ed4ac83763e/docs/design-time-builds.md). `MSBuildDebugEngine` allows retrieving a full binary log for both real builds and all design time builds.
+
+By default these logs get saved into an `MSBuild_Logs` directory under the current working directory. You can override this default by setting `MSBUILDDEBUGPATH`.
+
+Like with breakpoints, you can filter which processes emit the logs by setting `MSBuildDebugProcessName` to a substring of the desired process name.
 
-Sometimes it's useful to patch your copy of Visual Studio. You can use the [Deploy-MSBuild script](../Deploy-MSBuild.md) for that.
+##### Dumping specific logs:
+- scheduler state: set `MSBUILDDEBUGSCHEDULER` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
+- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
\ No newline at end of file
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
index 590cfc2f100..859cf202824 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
@@ -26,3 +26,7 @@ If you encounter errors, see [Something's wrong in my build](Something's-wrong-i
 The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](http://www.mono-project.com/download/#download-mac). After installing it, you can run `msbuild`.
 <br/>
 For Linux, you can install mono and msbuild from [here](http://www.mono-project.com/download/#download-lin).
+
+## Debugging
+
+See debugging options [here](./Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#Debugging-MSBuild).
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 5b152e7c1a7..6c61626ec7b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -8,7 +8,7 @@ Opt-out is a better approach for us because we'd likely get limited feedback whe
 The opt-out comes in the form of setting the environment variable `MSBuildDisableFeaturesFromVersion` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
 
 ## When do they become permanent?
-A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionalty when wave 17.0 is introduced.
+A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionality when wave 17.0 is introduced.
 
 ## MSBuildDisableFeaturesFromVersion Values & Outcomes
 | `MSBuildDisableFeaturesFromVersion` Value                         | Result        | Receive Warning? |
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 16a7bd65ad2..6ab17741640 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -145,6 +145,21 @@ There were recent fixes made to RAR to alleviate the situation. You can control
     DoNotCopyLocalIfInGac="$(DoNotCopyLocalIfInGac)"
 ```
 
+## AssemblySearchPaths
+There are two ways to customize the list of paths RAR will search in attempting to locate an assembly. To fully customize the list, the property `AssemblySearchPaths` can be set ahead of time. Note that the order matters; if an assembly is in two locations, RAR will stop after it finds it at the first location.
+
+By default, there are ten locations RAR will search (four if using the .NET SDK), and each can be disabled by setting the relevant flag to false:
+1. Searching files from the current project is disabled by setting the `AssemblySearchPathUseCandidateAssemblyFiles` property to false.
+2. Searching the reference path property (from a .user file) is disabled by setting the `AssemblySearchPathUseReferencePath` property to false.
+3. Using the hint path from the item is disabled by setting the `AssemblySearchPathUseHintPathFromItem` property to false.
+4. Using the directory with MSBuild's target runtime is disabled by setting the `AssemblySearchPathUseTargetFrameworkDirectory` property to false.
+5. Searching assembly folders from AssemblyFolders.config is disabled by setting the `AssemblySearchPathUseAssemblyFoldersConfigFileSearchPath` property to false.
+6. Searching the registry is disabled by setting the `AssemblySearchPathUseRegistry` property to false.
+7. Searching legacy registered assembly folders is disabled by setting the `AssemblySearchPathUseAssemblyFolders` property to false.
+8. Looking in the GAC is disabled by setting the `AssemblySearchPathUseGAC` property to false.
+9. Treating the reference's Include as a real file name is disabled by setting the `AssemblySearchPathUseRawFileName` property to false.
+10. Checking the application's output folder is disabled by setting the `AssemblySearchPathUseOutDir` property to false.
+
 ## There was a conflict
 
 A common situation is MSBuild gives a warning about different versions of the same assembly being used by different references. The solution often involves adding a binding redirect to the app.config file. 
diff --git a/eng/Build.props b/eng/Build.props
index 6393db2a363..f2afe806410 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -2,6 +2,10 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
 
+  <PropertyGroup>
+    <RestoreUseStaticGraphEvaluation Condition="'$(DotNetBuildFromSource)' != 'true'">true</RestoreUseStaticGraphEvaluation>
+  </PropertyGroup>
+
   <ItemGroup>
 	<!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
 	Without this, arcade tries to build all three MSBuild solution at once, which leads to
diff --git a/eng/Packages.props b/eng/Packages.props
index eb0144f9b65..b6e51805983 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,28 +1,22 @@
 <Project>
+  <!-- Import references updated by Dependabot.
+       This file is for package references updated manually or by Darc/Maestro. -->
+  <Import Project="dependabot\Packages.props" />
+
   <!--
     Make sure to update the binding redirects (in src\MSBuild\app.config and src\MSBuild\app.amd64.config) for any changes to
     the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
      -->
   <ItemGroup>
-    <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
-    <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
-    <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.0.0-4.21379.20" />
-    <PackageReference Update="Microsoft.CodeQuality.Analyzers" Version="3.3.0" PrivateAssets="all" />
-    <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
+    <PackageReference Update="Microsoft.IO.Redist" Version="6.0.0" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" />
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="1.16.30" />
     <PackageReference Update="Microsoft.Win32.Registry" Version="4.3.0" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="PdbGit" Version="3.0.41" />
-    <PackageReference Update="Shouldly" Version="3.0.0" />
-    <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
-    <PackageReference Update="StyleCop.Analyzers" Version="1.2.0-beta.164" PrivateAssets="all" />
     <PackageReference Update="System.CodeDom" Version="4.4.0" />
     <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
     <PackageReference Update="System.Configuration.ConfigurationManager" Version="4.7.0" />
@@ -30,26 +24,16 @@
     <PackageReference Update="System.Memory" Version="4.5.4" />
     <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
-    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="5.0.0"/>
+    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="6.0.0" />
     <PackageReference Update="System.Security.Cryptography.Pkcs" Version="4.7.0" />
     <PackageReference Update="System.Security.Cryptography.Xml" Version="4.7.0" />
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
     <PackageReference Update="System.Security.Principal.Windows" Version="4.7.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
-    <PackageReference Update="System.Text.Json" Version="5.0.2" />
-    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="4.9.0" />
+    <PackageReference Update="System.Text.Json" Version="6.0.0" />
+    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="6.0.0" />
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
   </ItemGroup>
-
-  <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
-    <GlobalPackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.0" PrivateAssets="All"/>
-  </ItemGroup>
-
-  <ItemGroup>
-    <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="$(MicrosoftCodeAnalysisBannedApiAnalyzersVersion)" />
-  </ItemGroup>
-
 </Project>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index cc3eebb1a18..f7003f1bad9 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,26 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.2">
-      <Uri>https://github.com/dotnet/roslyn-analyzers</Uri>
-      <Sha />
-    </Dependency>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21460.7">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21566.8">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7324320f814152b72295946847ca72413507705a</Sha>
+      <Sha>958161a35309eed8a0ab8658573a07f6dd4dfbe0</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.4.243">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.1.0-preview.1.38">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>f82431ecc38a28f396d527446834c7de679a6722</Sha>
+      <Sha>a998efecd431ec8a41536b5ac0152c16f1e2e646</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-5.21469.2">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.1.0-2.21561.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>c1d8c6f043bc80425c6828455eb57f8a404759c6</Sha>
+      <Sha>b65e75b2a80d3418a3e32de32345ce250eb5d450</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21460.7">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21566.8">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7324320f814152b72295946847ca72413507705a</Sha>
+      <Sha>958161a35309eed8a0ab8658573a07f6dd4dfbe0</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index d01c3c803fc..d31192ca83a 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -32,11 +32,10 @@
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21460.7</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftCodeAnalysisBannedApiAnalyzersVersion>3.3.2</MicrosoftCodeAnalysisBannedApiAnalyzersVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21566.8</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.0.0-5.21469.2</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.0.0-preview.4.243</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.1.0-2.21561.5</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.1.0-preview.1.38</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/build.ps1 b/eng/build.ps1
index 9245a71a0f4..2762b71fb9f 100644
--- a/eng/build.ps1
+++ b/eng/build.ps1
@@ -158,9 +158,13 @@ function Check-EditedFiles() {
 
 function Check-RequiredVersionBumps() {
   # Log VSTS errors for missing required version bumps
-  if ($env:SYSTEM_PULLREQUEST_TARGETBRANCH) {
+  $targetBranch = $env:SYSTEM_PULLREQUEST_TARGETBRANCH
+  if ($targetBranch) {
+    # Some PRs specify the bare target branch (most commonly "main"), some prefix it with "refs/heads/".
+    # The following statement normalizes both to a revision spec that git understands.
+    $targetBranch = "refs/remotes/origin/" + ($targetBranch -replace "^refs/heads/", "")
     $versionLineChanged = $false
-    git --no-pager diff --unified --no-color --exit-code -w origin/$env:SYSTEM_PULLREQUEST_TARGETBRANCH HEAD src\Framework\EngineServices.cs `
+    git --no-pager diff --unified --no-color --exit-code -w $targetBranch HEAD src\Framework\EngineServices.cs `
       | Select-String -Pattern "int Version =" | ForEach-Object -process { $versionLineChanged = $true }
     if (($LASTEXITCODE -ne 0) -and (-not $versionLineChanged)) {
       throw "##vso[task.logissue type=error] Detected changes in Framework\EngineServices.cs without a version bump.  " +
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index 69eb67849d7..4882dd93134 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -62,7 +62,7 @@ jobs:
   pool:
     # To extract archives (.tar.gz, .zip), we need access to "tar", added in Windows 10/2019.
     ${{ if eq(parameters.extractArchiveArtifacts, 'false') }}:
-      name: Hosted VS2017
+      vmImage: windows-2019
     ${{ if ne(parameters.extractArchiveArtifacts, 'false') }}:
       vmImage: windows-2019
   steps:
diff --git a/eng/common/templates/job/onelocbuild.yml b/eng/common/templates/job/onelocbuild.yml
index e8bc77d2ebb..2b55a567f82 100644
--- a/eng/common/templates/job/onelocbuild.yml
+++ b/eng/common/templates/job/onelocbuild.yml
@@ -4,7 +4,7 @@ parameters:
 
   # Optional: A defined YAML pool - https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema#pool
   pool:
-    vmImage: vs2017-win2016
+    vmImage: windows-2019
 
   CeapexPat: $(dn-bot-ceapex-package-r) # PAT for the loc AzDO instance https://dev.azure.com/ceapex
   GithubPat: $(BotAccount-dotnet-bot-repo-PAT)
diff --git a/eng/common/templates/job/source-index-stage1.yml b/eng/common/templates/job/source-index-stage1.yml
index 1cc0c29e4fd..d8990549e80 100644
--- a/eng/common/templates/job/source-index-stage1.yml
+++ b/eng/common/templates/job/source-index-stage1.yml
@@ -6,7 +6,7 @@ parameters:
   preSteps: []
   binlogPath: artifacts/log/Debug/Build.binlog
   pool:
-    vmImage: vs2017-win2016
+    vmImage: windows-2019
   condition: ''
   dependsOn: ''
 
diff --git a/eng/common/templates/jobs/jobs.yml b/eng/common/templates/jobs/jobs.yml
index a1f8fce96ca..90015a7e5ae 100644
--- a/eng/common/templates/jobs/jobs.yml
+++ b/eng/common/templates/jobs/jobs.yml
@@ -83,7 +83,7 @@ jobs:
         - ${{ if eq(parameters.enableSourceBuild, true) }}:
           - Source_Build_Complete
         pool:
-          vmImage: vs2017-win2016
+          vmImage: windows-2019
         runAsPublic: ${{ parameters.runAsPublic }}
         publishUsingPipelines: ${{ parameters.enablePublishUsingPipelines }}
         enablePublishBuildArtifacts: ${{ parameters.enablePublishBuildArtifacts }}
@@ -96,4 +96,4 @@ jobs:
         dependsOn:
           - Asset_Registry_Publish
         pool:
-          vmImage: vs2017-win2016
+          vmImage: windows-2019
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index bf9f2eb4617..4f79cf0f337 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -166,11 +166,6 @@ stages:
           inputs:
             filePath: eng\common\enable-cross-org-publishing.ps1
             arguments: -token $(dn-bot-dnceng-artifact-feeds-rw)
-        
-        - task: DeleteFiles@1
-          inputs:
-            SourceFolder: $(Build.ArtifactStagingDirectory)/PackageArtifacts
-            Contents: Microsoft.SourceBuild.Intermediate*
 
         # Signing validation will optionally work with the buildmanifest file which is downloaded from
         # Azure DevOps above.
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 02347914f5d..6de418e9379 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -301,32 +301,45 @@ function InstallDotNet([string] $dotnetRoot,
   if ($skipNonVersionedFiles) { $installParameters.SkipNonVersionedFiles = $skipNonVersionedFiles }
   if ($noPath) { $installParameters.NoPath = $True }
 
-  try {
-    & $installScript @installParameters
-  }
-  catch {
-    if ($runtimeSourceFeed -or $runtimeSourceFeedKey) {
-      Write-Host "Failed to install dotnet from public location. Trying from '$runtimeSourceFeed'"
-      if ($runtimeSourceFeed) { $installParameters.AzureFeed = $runtimeSourceFeed }
+  $variations = @()
+  $variations += @($installParameters)
 
-      if ($runtimeSourceFeedKey) {
-        $decodedBytes = [System.Convert]::FromBase64String($runtimeSourceFeedKey)
-        $decodedString = [System.Text.Encoding]::UTF8.GetString($decodedBytes)
-        $installParameters.FeedCredential = $decodedString
-      }
+  $dotnetBuilds = $installParameters.Clone()
+  $dotnetbuilds.AzureFeed = "https://dotnetbuilds.azureedge.net/public"
+  $variations += @($dotnetBuilds)
 
-      try {
-        & $installScript @installParameters
-      }
-      catch {
-        Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install dotnet from custom location '$runtimeSourceFeed'."
-        ExitWithExitCode 1
-      }
+  if ($runtimeSourceFeed) {
+    $runtimeSource = $installParameters.Clone()
+    $runtimeSource.AzureFeed = $runtimeSourceFeed
+    if ($runtimeSourceFeedKey) {
+      $decodedBytes = [System.Convert]::FromBase64String($runtimeSourceFeedKey)
+      $decodedString = [System.Text.Encoding]::UTF8.GetString($decodedBytes)
+      $runtimeSource.FeedCredential = $decodedString
+    }
+    $variations += @($runtimeSource)
+  }
+
+  $installSuccess = $false
+  foreach ($variation in $variations) {
+    if ($variation | Get-Member AzureFeed) {
+      $location = $variation.AzureFeed
     } else {
-      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install dotnet from public location."
-      ExitWithExitCode 1
+      $location = "public location";
+    }
+    Write-Host "Attempting to install dotnet from $location."
+    try {
+      & $installScript @variation
+      $installSuccess = $true
+      break
+    }
+    catch {
+      Write-Host "Failed to install dotnet from $location."
     }
   }
+  if (-not $installSuccess) {
+    Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install dotnet from any of the specified locations."
+    ExitWithExitCode 1
+  }
 }
 
 #
@@ -709,14 +722,7 @@ function MSBuild() {
       Write-PipelineSetVariable -Name 'NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS' -Value '20'
     }
 
-    if ($ci) {
-      $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'
-      $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6
-      $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
-      Write-PipelineSetVariable -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY' -Value 'true'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT' -Value '6'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
-    }
+    Enable-Nuget-EnhancedRetry
 
     $toolsetBuildProject = InitializeToolset
     $basePath = Split-Path -parent $toolsetBuildProject
@@ -764,6 +770,8 @@ function MSBuild-Core() {
     }
   }
 
+  Enable-Nuget-EnhancedRetry
+
   $buildTool = InitializeBuildTool
 
   $cmdArgs = "$($buildTool.Command) /m /nologo /clp:Summary /v:$verbosity /nr:$nodeReuse /p:ContinuousIntegrationBuild=$ci"
@@ -904,3 +912,18 @@ function Try-LogClientIpAddress()
         Write-Host "Unable to get this machine's effective IP address for logging: $_"
     }
 }
+
+#
+# If $ci flag is set, turn on (and log that we did) special environment variables for improved Nuget client retry logic.
+#
+function Enable-Nuget-EnhancedRetry() {
+    if ($ci) {
+      Write-Host "Setting NUGET enhanced retry environment variables"
+      $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'
+      $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6
+      $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
+      Write-PipelineSetVariable -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY' -Value 'true'
+      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT' -Value '6'
+      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
+    }
+}
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index 6a4871ef72b..532ce42c1f5 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -188,28 +188,29 @@ function InstallDotNet {
   GetDotNetInstallScript "$root"
   local install_script=$_GetDotNetInstallScript
 
-  local archArg=''
+  local installParameters=(--version $version --install-dir "$root")
+
   if [[ -n "${3:-}" ]] && [ "$3" != 'unset' ]; then
-    archArg="--architecture $3"
+    installParameters+=(--architecture $3)
   fi
-  local runtimeArg=''
   if [[ -n "${4:-}" ]] && [ "$4" != 'sdk' ]; then
-    runtimeArg="--runtime $4"
+    installParameters+=(--runtime $4)
   fi
-  local skipNonVersionedFilesArg=""
   if [[ "$#" -ge "5" ]] && [[ "$5" != 'false' ]]; then
-    skipNonVersionedFilesArg="--skip-non-versioned-files"
+    installParameters+=(--skip-non-versioned-files)
   fi
-  bash "$install_script" --version $version --install-dir "$root" $archArg $runtimeArg $skipNonVersionedFilesArg || {
-    local exit_code=$?
-    echo "Failed to install dotnet SDK from public location (exit code '$exit_code')."
 
-    local runtimeSourceFeed=''
-    if [[ -n "${6:-}" ]]; then
-      runtimeSourceFeed="--azure-feed $6"
-    fi
+  local variations=() # list of variable names with parameter arrays in them
+
+  local public_location=("${installParameters[@]}")
+  variations+=(public_location)
+
+  local dotnetbuilds=("${installParameters[@]}" --azure-feed "https://dotnetbuilds.azureedge.net/public")
+  variations+=(dotnetbuilds)
 
-    local runtimeSourceFeedKey=''
+  if [[ -n "${6:-}" ]]; then
+    variations+=(private_feed)
+    local private_feed=("${installParameters[@]}" --azure-feed $6)
     if [[ -n "${7:-}" ]]; then
       # The 'base64' binary on alpine uses '-d' and doesn't support '--decode'
       # '-d'. To work around this, do a simple detection and switch the parameter
@@ -219,22 +220,27 @@ function InstallDotNet {
           decodeArg="-d"
       fi
       decodedFeedKey=`echo $7 | base64 $decodeArg`
-      runtimeSourceFeedKey="--feed-credential $decodedFeedKey"
+      private_feed+=(--feed-credential $decodedFeedKey)
     fi
+  fi
 
-    if [[ -n "$runtimeSourceFeed" || -n "$runtimeSourceFeedKey" ]]; then
-      bash "$install_script" --version $version --install-dir "$root" $archArg $runtimeArg $skipNonVersionedFilesArg $runtimeSourceFeed $runtimeSourceFeedKey || {
-        local exit_code=$?
-        Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from custom location '$runtimeSourceFeed' (exit code '$exit_code')."
-        ExitWithExitCode $exit_code
-      }
-    else
-      if [[ $exit_code != 0 ]]; then
-        Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from public location (exit code '$exit_code')."
-      fi
-      ExitWithExitCode $exit_code
+  local installSuccess=0
+  for variationName in "${variations[@]}"; do
+    local name="$variationName[@]"
+    local variation=("${!name}")
+    echo "Attempting to install dotnet from $variationName."
+    bash "$install_script" "${variation[@]}" && installSuccess=1
+    if [[ "$installSuccess" -eq 1 ]]; then
+      break
     fi
-  }
+
+    echo "Failed to install dotnet from $variationName."
+  done
+
+  if [[ "$installSuccess" -eq 0 ]]; then
+    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from any of the specified locations."
+    ExitWithExitCode 1
+  fi
 }
 
 function with_retries {
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
new file mode 100644
index 00000000000..2a6c9bf50ed
--- /dev/null
+++ b/eng/dependabot/Packages.props
@@ -0,0 +1,32 @@
+<Project>
+
+  <!-- Packages in this file have versions updated periodically by Dependabot.
+       Versions managed by Darc/Maestro should be in ..\Packages.props. -->
+
+  <!--
+    Make sure to update the binding redirects (in src\MSBuild\app.config and src\MSBuild\app.amd64.config) for any changes to
+    the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
+     -->
+  <ItemGroup>
+    <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
+    <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
+    <PackageReference Update="LargeAddressAware" Version="1.0.5" />
+    <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
+    <PackageReference Update="Microsoft.CodeQuality.Analyzers" Version="3.3.0" PrivateAssets="all" />
+    <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" />
+    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="1.16.30" />
+    <PackageReference Update="PdbGit" Version="3.0.41" />
+    <PackageReference Update="Shouldly" Version="3.0.0" />
+    <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
+    <PackageReference Update="StyleCop.Analyzers" Version="1.2.0-beta.164" PrivateAssets="all" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
+    <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.2" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+  </ItemGroup>
+
+</Project>
diff --git a/eng/dependabot/dependabot.csproj b/eng/dependabot/dependabot.csproj
new file mode 100644
index 00000000000..fdb8d223906
--- /dev/null
+++ b/eng/dependabot/dependabot.csproj
@@ -0,0 +1,4 @@
+<!-- This isn't a real project, but Dependabot requires a project. If one
+     exists, it'll update stuff in Packages.props as well, which is all we
+     really want here. -->
+<Project />
diff --git a/global.json b/global.json
index c0ab9c781c8..d7e28a0ce1c 100644
--- a/global.json
+++ b/global.json
@@ -3,18 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "6.0.100-rc.1.21458.32",
-    "runtimes": {
-      "dotnet/x64": [
-        "2.1.7"
-      ]
-    },
+    "dotnet": "6.0.100",
     "vs": {
       "version": "16.0"
     }
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21460.7"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21566.8"
   }
 }
diff --git a/ref/ExcludeAPIList.txt b/ref/ExcludeAPIList.txt
deleted file mode 100644
index 0a0ebd1d1e8..00000000000
--- a/ref/ExcludeAPIList.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿P:Microsoft.Build.Execution.BuildManager.WaitForDebugger
-T:Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances
-T:Microsoft.VisualStudio.Setup.Configuration.InstanceState
-T:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration
-T:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2
-T:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance
-T:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2
-T:Microsoft.VisualStudio.Setup.Configuration.SetupConfiguration
diff --git a/ref/ExcludeAttributeList.txt b/ref/ExcludeAttributeList.txt
deleted file mode 100644
index ebb68acf168..00000000000
--- a/ref/ExcludeAttributeList.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-T:System.Diagnostics.DebuggerBrowsableAttribute
-T:System.Diagnostics.DebuggerDisplayAttribute
-T:System.Diagnostics.DebuggerStepThroughAttribute
-T:System.Runtime.CompilerServices.CompilerGeneratedAttribute
-T:System.Runtime.CompilerServices.IsReadOnlyAttribute
diff --git a/ref/Microsoft.Build.Conversion.Core/net/Microsoft.Build.Conversion.Core.cs b/ref/Microsoft.Build.Conversion.Core/net/Microsoft.Build.Conversion.Core.cs
deleted file mode 100644
index 9fe951b1759..00000000000
--- a/ref/Microsoft.Build.Conversion.Core/net/Microsoft.Build.Conversion.Core.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.Conversion
-{
-    public sealed partial class ProjectFileConverter
-    {
-        public ProjectFileConverter() { }
-        public bool ConversionSkippedBecauseProjectAlreadyConverted { get { throw null; } }
-        public string[] ConversionWarnings { get { throw null; } }
-        public bool IsMinorUpgrade { get { throw null; } set { } }
-        public bool IsUserFile { get { throw null; } set { } }
-        public string NewProjectFile { get { throw null; } set { } }
-        public string OldProjectFile { get { throw null; } set { } }
-        public string SolutionFile { get { throw null; } set { } }
-        public void Convert() { }
-        [System.ObsoleteAttribute("Use parameterless overload instead")]
-        public void Convert(Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) { }
-        [System.ObsoleteAttribute("Use parameterless overload instead.")]
-        public void Convert(string msbuildBinPath) { }
-        public Microsoft.Build.Construction.ProjectRootElement ConvertInMemory() { throw null; }
-        [System.ObsoleteAttribute("Use parameterless ConvertInMemory() method instead")]
-        public Microsoft.Build.BuildEngine.Project ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine) { throw null; }
-        [System.ObsoleteAttribute("Use parameterless ConvertInMemory() method instead")]
-        public Microsoft.Build.BuildEngine.Project ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) { throw null; }
-        public bool FSharpSpecificConversions(bool actuallyMakeChanges) { throw null; }
-    }
-}
diff --git a/ref/Microsoft.Build.Engine/net/Microsoft.Build.Engine.cs b/ref/Microsoft.Build.Engine/net/Microsoft.Build.Engine.cs
deleted file mode 100644
index 0f848bbe337..00000000000
--- a/ref/Microsoft.Build.Engine/net/Microsoft.Build.Engine.cs
+++ /dev/null
@@ -1,470 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.BuildEngine
-{
-    public partial class BuildItem
-    {
-        public BuildItem(string itemName, Microsoft.Build.Framework.ITaskItem taskItem) { }
-        public BuildItem(string itemName, string itemInclude) { }
-        public string Condition { get { throw null; } set { } }
-        public int CustomMetadataCount { get { throw null; } }
-        public System.Collections.ICollection CustomMetadataNames { get { throw null; } }
-        public string Exclude { get { throw null; } set { } }
-        public string FinalItemSpec { get { throw null; } }
-        public string Include { get { throw null; } set { } }
-        public bool IsImported { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public System.Collections.ICollection MetadataNames { get { throw null; } }
-        public string Name { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.BuildItem Clone() { throw null; }
-        public void CopyCustomMetadataTo(Microsoft.Build.BuildEngine.BuildItem destinationItem) { }
-        public string GetEvaluatedMetadata(string metadataName) { throw null; }
-        public string GetMetadata(string metadataName) { throw null; }
-        public bool HasMetadata(string metadataName) { throw null; }
-        public void RemoveMetadata(string metadataName) { }
-        public void SetMetadata(string metadataName, string metadataValue) { }
-        public void SetMetadata(string metadataName, string metadataValue, bool treatMetadataValueAsLiteral) { }
-    }
-    public partial class BuildItemGroup : System.Collections.IEnumerable
-    {
-        public BuildItemGroup() { }
-        public string Condition { get { throw null; } set { } }
-        public int Count { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildItem this[int index] { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildItem AddNewItem(string itemName, string itemInclude) { throw null; }
-        public Microsoft.Build.BuildEngine.BuildItem AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) { throw null; }
-        public void Clear() { }
-        public Microsoft.Build.BuildEngine.BuildItemGroup Clone(bool deepClone) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) { }
-        public void RemoveItemAt(int index) { }
-        public Microsoft.Build.BuildEngine.BuildItem[] ToArray() { throw null; }
-    }
-    public partial class BuildItemGroupCollection : System.Collections.ICollection, System.Collections.IEnumerable
-    {
-        internal BuildItemGroupCollection() { }
-        public int Count { get { throw null; } }
-        public bool IsSynchronized { get { throw null; } }
-        public object SyncRoot { get { throw null; } }
-        public void CopyTo(System.Array array, int index) { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    public partial class BuildProperty
-    {
-        public BuildProperty(string propertyName, string propertyValue) { }
-        public string Condition { get { throw null; } set { } }
-        public string FinalValue { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Value { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.BuildProperty Clone(bool deepClone) { throw null; }
-        public static explicit operator string (Microsoft.Build.BuildEngine.BuildProperty propertyToCast) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public partial class BuildPropertyGroup : System.Collections.IEnumerable
-    {
-        public BuildPropertyGroup() { }
-        public BuildPropertyGroup(Microsoft.Build.BuildEngine.Project parentProject) { }
-        public string Condition { get { throw null; } set { } }
-        public int Count { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildProperty this[string propertyName] { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.BuildProperty AddNewProperty(string propertyName, string propertyValue) { throw null; }
-        public Microsoft.Build.BuildEngine.BuildProperty AddNewProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) { throw null; }
-        public void Clear() { }
-        public Microsoft.Build.BuildEngine.BuildPropertyGroup Clone(bool deepClone) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void RemoveProperty(Microsoft.Build.BuildEngine.BuildProperty property) { }
-        public void RemoveProperty(string propertyName) { }
-        public void SetImportedPropertyGroupCondition(string condition) { }
-        public void SetProperty(string propertyName, string propertyValue) { }
-        public void SetProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) { }
-    }
-    public partial class BuildPropertyGroupCollection : System.Collections.ICollection, System.Collections.IEnumerable
-    {
-        internal BuildPropertyGroupCollection() { }
-        public int Count { get { throw null; } }
-        public bool IsSynchronized { get { throw null; } }
-        public object SyncRoot { get { throw null; } }
-        public void CopyTo(System.Array array, int index) { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.FlagsAttribute]
-    public enum BuildSettings
-    {
-        None = 0,
-        DoNotResetPreviouslyBuiltTargets = 1,
-    }
-    public partial class BuildTask
-    {
-        internal BuildTask() { }
-        public string Condition { get { throw null; } set { } }
-        public bool ContinueOnError { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
-        public string Name { get { throw null; } }
-        public System.Type Type { get { throw null; } }
-        public void AddOutputItem(string taskParameter, string itemName) { }
-        public void AddOutputProperty(string taskParameter, string propertyName) { }
-        public bool Execute() { throw null; }
-        public string[] GetParameterNames() { throw null; }
-        public string GetParameterValue(string attributeName) { throw null; }
-        public void SetParameterValue(string parameterName, string parameterValue) { }
-        public void SetParameterValue(string parameterName, string parameterValue, bool treatParameterValueAsLiteral) { }
-    }
-    public delegate void ColorResetter();
-    public delegate void ColorSetter(System.ConsoleColor color);
-    public partial class ConfigurableForwardingLogger : Microsoft.Build.Framework.IForwardingLogger, Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public ConfigurableForwardingLogger() { }
-        public Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get { throw null; } set { } }
-        public int NodeId { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        protected virtual void ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public virtual void Shutdown() { }
-    }
-    public partial class ConsoleLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public ConsoleLogger() { }
-        public ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.BuildEngine.WriteHandler write, Microsoft.Build.BuildEngine.ColorSetter colorSet, Microsoft.Build.BuildEngine.ColorResetter colorReset) { }
-        public string Parameters { get { throw null; } set { } }
-        public bool ShowSummary { get { throw null; } set { } }
-        public bool SkipProjectStartedText { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        protected Microsoft.Build.BuildEngine.WriteHandler WriteHandler { get { throw null; } set { } }
-        public void ApplyParameter(string parameterName, string parameterValue) { }
-        public void BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) { }
-        public void BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) { }
-        public void CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) { }
-        public void ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public void MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) { }
-        public void ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) { }
-        public void ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) { }
-        public virtual void Shutdown() { }
-        public void TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) { }
-        public void TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) { }
-        public void TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) { }
-        public void TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) { }
-        public void WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) { }
-    }
-    public partial class DistributedFileLogger : Microsoft.Build.Framework.IForwardingLogger, Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public DistributedFileLogger() { }
-        public Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get { throw null; } set { } }
-        public int NodeId { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public void Shutdown() { }
-    }
-    [System.ObsoleteAttribute("This class has been deprecated. Please use Microsoft.Build.Evaluation.ProjectCollection from the Microsoft.Build assembly instead.")]
-    public partial class Engine
-    {
-        public Engine() { }
-        public Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) { }
-        public Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) { }
-        public Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations, int numberOfCpus, string localNodeProviderParameters) { }
-        public Engine(Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) { }
-        [System.ObsoleteAttribute("If you were simply passing in the .NET Framework location as the BinPath, just change to the parameterless Engine() constructor. Otherwise, you can define custom toolsets in the registry or config file, or by adding elements to the Engine's ToolsetCollection. Then use either the Engine() or Engine(ToolsetLocations) constructor instead.")]
-        public Engine(string binPath) { }
-        [System.ObsoleteAttribute("Avoid setting BinPath. If you were simply passing in the .NET Framework location as the BinPath, no other action is necessary. Otherwise, define Toolsets instead in the registry or config file, or by adding elements to the Engine's ToolsetCollection, in order to use a custom BinPath.")]
-        public string BinPath { get { throw null; } set { } }
-        public bool BuildEnabled { get { throw null; } set { } }
-        public string DefaultToolsVersion { get { throw null; } set { } }
-        public static Microsoft.Build.BuildEngine.Engine GlobalEngine { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildPropertyGroup GlobalProperties { get { throw null; } set { } }
-        public bool IsBuilding { get { throw null; } }
-        public bool OnlyLogCriticalEvents { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.ToolsetCollection Toolsets { get { throw null; } }
-        public static System.Version Version { get { throw null; } }
-        public bool BuildProject(Microsoft.Build.BuildEngine.Project project) { throw null; }
-        public bool BuildProject(Microsoft.Build.BuildEngine.Project project, string targetName) { throw null; }
-        public bool BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames) { throw null; }
-        public bool BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs) { throw null; }
-        public bool BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) { throw null; }
-        public bool BuildProjectFile(string projectFile) { throw null; }
-        public bool BuildProjectFile(string projectFile, string targetName) { throw null; }
-        public bool BuildProjectFile(string projectFile, string[] targetNames) { throw null; }
-        public bool BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) { throw null; }
-        public bool BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs) { throw null; }
-        public bool BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) { throw null; }
-        public bool BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string toolsVersion) { throw null; }
-        public bool BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject, Microsoft.Build.BuildEngine.BuildPropertyGroup[] globalPropertiesPerProject, System.Collections.IDictionary[] targetOutputsPerProject, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string[] toolsVersions) { throw null; }
-        public Microsoft.Build.BuildEngine.Project CreateNewProject() { throw null; }
-        public Microsoft.Build.BuildEngine.Project GetLoadedProject(string projectFullFileName) { throw null; }
-        public void RegisterDistributedLogger(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.BuildEngine.LoggerDescription forwardingLogger) { }
-        public void RegisterLogger(Microsoft.Build.Framework.ILogger logger) { }
-        public void Shutdown() { }
-        public void UnloadAllProjects() { }
-        public void UnloadProject(Microsoft.Build.BuildEngine.Project project) { }
-        public void UnregisterAllLoggers() { }
-    }
-    public partial class FileLogger : Microsoft.Build.BuildEngine.ConsoleLogger
-    {
-        public FileLogger() { }
-        public override void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public override void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public override void Shutdown() { }
-    }
-    public partial class Import
-    {
-        internal Import() { }
-        public string Condition { get { throw null; } set { } }
-        public string EvaluatedProjectPath { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public string ProjectPath { get { throw null; } set { } }
-    }
-    public partial class ImportCollection : System.Collections.ICollection, System.Collections.IEnumerable
-    {
-        internal ImportCollection() { }
-        public int Count { get { throw null; } }
-        public bool IsSynchronized { get { throw null; } }
-        public object SyncRoot { get { throw null; } }
-        public void AddNewImport(string projectFile, string condition) { }
-        public void CopyTo(Microsoft.Build.BuildEngine.Import[] array, int index) { }
-        public void CopyTo(System.Array array, int index) { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void RemoveImport(Microsoft.Build.BuildEngine.Import importToRemove) { }
-    }
-    public sealed partial class InternalLoggerException : System.Exception
-    {
-        public InternalLoggerException() { }
-        public InternalLoggerException(string message) { }
-        public InternalLoggerException(string message, System.Exception innerException) { }
-        public Microsoft.Build.Framework.BuildEventArgs BuildEventArgs { get { throw null; } }
-        public string ErrorCode { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public bool InitializationException { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public sealed partial class InvalidProjectFileException : System.Exception
-    {
-        public InvalidProjectFileException() { }
-        public InvalidProjectFileException(string message) { }
-        public InvalidProjectFileException(string message, System.Exception innerException) { }
-        public InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) { }
-        public InvalidProjectFileException(System.Xml.XmlNode xmlNode, string message, string errorSubcategory, string errorCode, string helpKeyword) { }
-        public string BaseMessage { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string ErrorCode { get { throw null; } }
-        public string ErrorSubcategory { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public partial class InvalidToolsetDefinitionException : System.Exception
-    {
-        public InvalidToolsetDefinitionException() { }
-        protected InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-        public InvalidToolsetDefinitionException(string message) { }
-        public InvalidToolsetDefinitionException(string message, System.Exception innerException) { }
-        public InvalidToolsetDefinitionException(string message, string errorCode) { }
-        public InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) { }
-        public string ErrorCode { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public partial class LocalNode
-    {
-        internal LocalNode() { }
-        public static void StartLocalNodeServer(int nodeNumber) { }
-    }
-    public partial class LoggerDescription
-    {
-        public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public string LoggerSwitchParameters { get { throw null; } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } }
-    }
-    [System.ObsoleteAttribute("This class has been deprecated. Please use Microsoft.Build.Evaluation.Project from the Microsoft.Build assembly instead.")]
-    public partial class Project
-    {
-        public Project() { }
-        public Project(Microsoft.Build.BuildEngine.Engine engine) { }
-        public Project(Microsoft.Build.BuildEngine.Engine engine, string toolsVersion) { }
-        public bool BuildEnabled { get { throw null; } set { } }
-        public string DefaultTargets { get { throw null; } set { } }
-        public string DefaultToolsVersion { get { throw null; } set { } }
-        public System.Text.Encoding Encoding { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildItemGroup EvaluatedItems { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildItemGroup EvaluatedItemsIgnoringCondition { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildPropertyGroup EvaluatedProperties { get { throw null; } }
-        public string FullFileName { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.BuildPropertyGroup GlobalProperties { get { throw null; } set { } }
-        public bool HasToolsVersionAttribute { get { throw null; } }
-        public Microsoft.Build.BuildEngine.ImportCollection Imports { get { throw null; } }
-        public string InitialTargets { get { throw null; } set { } }
-        public bool IsDirty { get { throw null; } }
-        public bool IsValidated { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.BuildItemGroupCollection ItemGroups { get { throw null; } }
-        public Microsoft.Build.BuildEngine.Engine ParentEngine { get { throw null; } }
-        public Microsoft.Build.BuildEngine.BuildPropertyGroupCollection PropertyGroups { get { throw null; } }
-        public string SchemaFile { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.TargetCollection Targets { get { throw null; } }
-        public System.DateTime TimeOfLastDirty { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-        public Microsoft.Build.BuildEngine.UsingTaskCollection UsingTasks { get { throw null; } }
-        public string Xml { get { throw null; } }
-        public void AddNewImport(string projectFile, string condition) { }
-        public Microsoft.Build.BuildEngine.BuildItem AddNewItem(string itemName, string itemInclude) { throw null; }
-        public Microsoft.Build.BuildEngine.BuildItem AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) { throw null; }
-        public Microsoft.Build.BuildEngine.BuildItemGroup AddNewItemGroup() { throw null; }
-        public Microsoft.Build.BuildEngine.BuildPropertyGroup AddNewPropertyGroup(bool insertAtEndOfProject) { throw null; }
-        public void AddNewUsingTaskFromAssemblyFile(string taskName, string assemblyFile) { }
-        public void AddNewUsingTaskFromAssemblyName(string taskName, string assemblyName) { }
-        public bool Build() { throw null; }
-        public bool Build(string targetName) { throw null; }
-        public bool Build(string[] targetNames) { throw null; }
-        public bool Build(string[] targetNames, System.Collections.IDictionary targetOutputs) { throw null; }
-        public bool Build(string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) { throw null; }
-        public string[] GetConditionedPropertyValues(string propertyName) { throw null; }
-        public Microsoft.Build.BuildEngine.BuildItemGroup GetEvaluatedItemsByName(string itemName) { throw null; }
-        public Microsoft.Build.BuildEngine.BuildItemGroup GetEvaluatedItemsByNameIgnoringCondition(string itemName) { throw null; }
-        public string GetEvaluatedProperty(string propertyName) { throw null; }
-        public string GetProjectExtensions(string id) { throw null; }
-        public void Load(System.IO.TextReader textReader) { }
-        public void Load(System.IO.TextReader textReader, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) { }
-        public void Load(string projectFileName) { }
-        public void Load(string projectFileName, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) { }
-        public void LoadXml(string projectXml) { }
-        public void LoadXml(string projectXml, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) { }
-        public void MarkProjectAsDirty() { }
-        public void RemoveAllItemGroups() { }
-        public void RemoveAllPropertyGroups() { }
-        public void RemoveImportedPropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) { }
-        public void RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) { }
-        public void RemoveItemGroup(Microsoft.Build.BuildEngine.BuildItemGroup itemGroupToRemove) { }
-        public void RemoveItemGroupsWithMatchingCondition(string matchCondition) { }
-        public void RemoveItemsByName(string itemName) { }
-        public void RemovePropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) { }
-        public void RemovePropertyGroupsWithMatchingCondition(string matchCondition) { }
-        public void RemovePropertyGroupsWithMatchingCondition(string matchCondition, bool includeImportedPropertyGroups) { }
-        public void ResetBuildStatus() { }
-        public void Save(System.IO.TextWriter textWriter) { }
-        public void Save(string projectFileName) { }
-        public void Save(string projectFileName, System.Text.Encoding encoding) { }
-        public void SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importProject) { }
-        public void SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position) { }
-        public void SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) { }
-        public void SetProjectExtensions(string id, string content) { }
-        public void SetProperty(string propertyName, string propertyValue) { }
-        public void SetProperty(string propertyName, string propertyValue, string condition) { }
-        public void SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position) { }
-        public void SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) { }
-    }
-    [System.FlagsAttribute]
-    public enum ProjectLoadSettings
-    {
-        None = 0,
-        IgnoreMissingImports = 1,
-    }
-    public enum PropertyPosition
-    {
-        UseExistingOrCreateAfterLastPropertyGroup = 0,
-        UseExistingOrCreateAfterLastImport = 1,
-    }
-    public sealed partial class RemoteErrorException : System.Exception
-    {
-        internal RemoteErrorException() { }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public static partial class SolutionWrapperProject
-    {
-        public static string Generate(string solutionPath, string toolsVersionOverride, Microsoft.Build.Framework.BuildEventContext projectBuildEventContext) { throw null; }
-    }
-    public partial class Target : System.Collections.IEnumerable
-    {
-        internal Target() { }
-        public string Condition { get { throw null; } set { } }
-        public string DependsOnTargets { get { throw null; } set { } }
-        public string Inputs { get { throw null; } set { } }
-        public bool IsImported { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Outputs { get { throw null; } set { } }
-        public Microsoft.Build.BuildEngine.BuildTask AddNewTask(string taskName) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void RemoveTask(Microsoft.Build.BuildEngine.BuildTask taskElement) { }
-    }
-    public partial class TargetCollection : System.Collections.ICollection, System.Collections.IEnumerable
-    {
-        internal TargetCollection() { }
-        public int Count { get { throw null; } }
-        public bool IsSynchronized { get { throw null; } }
-        public Microsoft.Build.BuildEngine.Target this[string index] { get { throw null; } }
-        public object SyncRoot { get { throw null; } }
-        public Microsoft.Build.BuildEngine.Target AddNewTarget(string targetName) { throw null; }
-        public void CopyTo(System.Array array, int index) { }
-        public bool Exists(string targetName) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void RemoveTarget(Microsoft.Build.BuildEngine.Target targetToRemove) { }
-    }
-    public partial class Toolset
-    {
-        public Toolset(string toolsVersion, string toolsPath) { }
-        public Toolset(string toolsVersion, string toolsPath, Microsoft.Build.BuildEngine.BuildPropertyGroup buildProperties) { }
-        public Microsoft.Build.BuildEngine.BuildPropertyGroup BuildProperties { get { throw null; } }
-        public string ToolsPath { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-        public Microsoft.Build.BuildEngine.Toolset Clone() { throw null; }
-    }
-    public partial class ToolsetCollection : System.Collections.Generic.ICollection<Microsoft.Build.BuildEngine.Toolset>, System.Collections.Generic.IEnumerable<Microsoft.Build.BuildEngine.Toolset>, System.Collections.IEnumerable
-    {
-        internal ToolsetCollection() { }
-        public int Count { get { throw null; } }
-        public bool IsReadOnly { get { throw null; } }
-        public Microsoft.Build.BuildEngine.Toolset this[string toolsVersion] { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<string> ToolsVersions { get { throw null; } }
-        public void Add(Microsoft.Build.BuildEngine.Toolset item) { }
-        public void Clear() { }
-        public bool Contains(Microsoft.Build.BuildEngine.Toolset item) { throw null; }
-        public bool Contains(string toolsVersion) { throw null; }
-        public void CopyTo(Microsoft.Build.BuildEngine.Toolset[] array, int arrayIndex) { }
-        public System.Collections.Generic.IEnumerator<Microsoft.Build.BuildEngine.Toolset> GetEnumerator() { throw null; }
-        public bool Remove(Microsoft.Build.BuildEngine.Toolset item) { throw null; }
-        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
-    }
-    [System.FlagsAttribute]
-    public enum ToolsetDefinitionLocations
-    {
-        None = 0,
-        ConfigurationFile = 1,
-        Registry = 2,
-    }
-    public partial class UsingTask
-    {
-        internal UsingTask() { }
-        public string AssemblyFile { get { throw null; } }
-        public string AssemblyName { get { throw null; } }
-        public string Condition { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public string TaskName { get { throw null; } }
-    }
-    public partial class UsingTaskCollection : System.Collections.ICollection, System.Collections.IEnumerable
-    {
-        internal UsingTaskCollection() { }
-        public int Count { get { throw null; } }
-        public bool IsSynchronized { get { throw null; } }
-        public object SyncRoot { get { throw null; } }
-        public void CopyTo(Microsoft.Build.BuildEngine.UsingTask[] array, int index) { }
-        public void CopyTo(System.Array array, int index) { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    public static partial class Utilities
-    {
-        public static string Escape(string unescapedExpression) { throw null; }
-    }
-    public delegate void WriteHandler(string message);
-}
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
deleted file mode 100644
index 0aaa25088a2..00000000000
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ /dev/null
@@ -1,1041 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.Framework
-{
-    public delegate void AnyEventHandler(object sender, Microsoft.Build.Framework.BuildEventArgs e);
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct BuildEngineResult
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) { throw null; }
-        public bool Result { get { throw null; } }
-        public System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> TargetOutputsPerProject { get { throw null; } }
-    }
-    public partial class BuildErrorEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildErrorEventArgs() { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public string Code { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string File { get { throw null; } }
-        public string HelpLink { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public string ProjectFile { get { throw null; } set { } }
-        public string Subcategory { get { throw null; } }
-    }
-    public delegate void BuildErrorEventHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e);
-    public abstract partial class BuildEventArgs : System.EventArgs
-    {
-        protected BuildEventArgs() { }
-        protected BuildEventArgs(string message, string helpKeyword, string senderName) { }
-        protected BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } }
-        public virtual string Message { get { throw null; } protected set { } }
-        protected internal string RawMessage { get { throw null; } set { } }
-        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
-        public string SenderName { get { throw null; } }
-        public int ThreadId { get { throw null; } }
-        public System.DateTime Timestamp { get { throw null; } }
-    }
-    public partial class BuildEventContext
-    {
-        public const int InvalidEvaluationId = -1;
-        public const int InvalidNodeId = -2;
-        public const int InvalidProjectContextId = -2;
-        public const int InvalidProjectInstanceId = -1;
-        public const int InvalidSubmissionId = -1;
-        public const int InvalidTargetId = -1;
-        public const int InvalidTaskId = -1;
-        public BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) { }
-        public BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) { }
-        public BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) { }
-        public BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) { }
-        public long BuildRequestId { get { throw null; } }
-        public int EvaluationId { get { throw null; } }
-        public static Microsoft.Build.Framework.BuildEventContext Invalid { get { throw null; } }
-        public int NodeId { get { throw null; } }
-        public int ProjectContextId { get { throw null; } }
-        public int ProjectInstanceId { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public int TargetId { get { throw null; } }
-        public int TaskId { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
-        public static bool operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public partial class BuildFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected BuildFinishedEventArgs() { }
-        public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) { }
-        public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) { }
-        public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public bool Succeeded { get { throw null; } }
-    }
-    public delegate void BuildFinishedEventHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e);
-    public partial class BuildMessageEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildMessageEventArgs() { }
-        public BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) { }
-        public BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) { }
-        public BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) { }
-        public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) { }
-        public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public string Code { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string File { get { throw null; } }
-        public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public string ProjectFile { get { throw null; } set { } }
-        public string Subcategory { get { throw null; } }
-    }
-    public delegate void BuildMessageEventHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e);
-    public partial class BuildStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected BuildStartedEventArgs() { }
-        public BuildStartedEventArgs(string message, string helpKeyword) { }
-        public BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) { }
-        public BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) { }
-        public BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public System.Collections.Generic.IDictionary<string, string> BuildEnvironment { get { throw null; } }
-    }
-    public delegate void BuildStartedEventHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e);
-    public abstract partial class BuildStatusEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildStatusEventArgs() { }
-        protected BuildStatusEventArgs(string message, string helpKeyword, string senderName) { }
-        protected BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        protected BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-    }
-    public delegate void BuildStatusEventHandler(object sender, Microsoft.Build.Framework.BuildStatusEventArgs e);
-    public partial class BuildWarningEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildWarningEventArgs() { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public string Code { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string File { get { throw null; } }
-        public string HelpLink { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public string ProjectFile { get { throw null; } set { } }
-        public string Subcategory { get { throw null; } }
-    }
-    public delegate void BuildWarningEventHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e);
-    public partial class CriticalBuildMessageEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        protected CriticalBuildMessageEventArgs() { }
-        public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
-        public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-    }
-    public abstract partial class CustomBuildEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected CustomBuildEventArgs() { }
-        protected CustomBuildEventArgs(string message, string helpKeyword, string senderName) { }
-        protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-    }
-    public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
-    public abstract partial class EngineServices
-    {
-        public const int Version1 = 1;
-        protected EngineServices() { }
-        public virtual bool IsTaskInputLoggingEnabled { get { throw null; } }
-        public virtual int Version { get { throw null; } }
-        public virtual bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
-    }
-    public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public EnvironmentVariableReadEventArgs() { }
-        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string EnvironmentVariableName { get { throw null; } set { } }
-    }
-    public partial class ExternalProjectFinishedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
-    {
-        protected ExternalProjectFinishedEventArgs() { }
-        public ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) { }
-        public ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) { }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-    }
-    public partial class ExternalProjectStartedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
-    {
-        protected ExternalProjectStartedEventArgs() { }
-        public ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) { }
-        public ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) { }
-        public string ProjectFile { get { throw null; } }
-        public string TargetNames { get { throw null; } }
-    }
-    public partial interface IBuildEngine
-    {
-        int ColumnNumberOfTaskNode { get; }
-        bool ContinueOnError { get; }
-        int LineNumberOfTaskNode { get; }
-        string ProjectFileOfTaskNode { get; }
-        bool BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs);
-        void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e);
-        void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e);
-        void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e);
-        void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e);
-    }
-    public partial interface IBuildEngine10 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8, Microsoft.Build.Framework.IBuildEngine9
-    {
-        Microsoft.Build.Framework.EngineServices EngineServices { get; }
-    }
-    public partial interface IBuildEngine2 : Microsoft.Build.Framework.IBuildEngine
-    {
-        bool IsRunningMultipleNodes { get; }
-        bool BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion);
-        bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion);
-    }
-    public partial interface IBuildEngine3 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2
-    {
-        Microsoft.Build.Framework.BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs);
-        void Reacquire();
-        void Yield();
-    }
-    public partial interface IBuildEngine4 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3
-    {
-        object GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime);
-        void RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
-        object UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime);
-    }
-    public partial interface IBuildEngine5 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4
-    {
-        void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties);
-    }
-    public partial interface IBuildEngine6 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5
-    {
-        System.Collections.Generic.IReadOnlyDictionary<string, string> GetGlobalProperties();
-    }
-    public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6
-    {
-        bool AllowFailureWithoutError { get; set; }
-    }
-    public partial interface IBuildEngine8 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7
-    {
-        bool ShouldTreatWarningAsError(string warningCode);
-    }
-    public partial interface IBuildEngine9 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8
-    {
-        void ReleaseCores(int coresToRelease);
-        int RequestCores(int requestedCores);
-    }
-    public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
-    {
-        void Cancel();
-    }
-    public partial interface IEventRedirector
-    {
-        void ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent);
-    }
-    public partial interface IEventSource
-    {
-        event Microsoft.Build.Framework.AnyEventHandler AnyEventRaised;
-        event Microsoft.Build.Framework.BuildFinishedEventHandler BuildFinished;
-        event Microsoft.Build.Framework.BuildStartedEventHandler BuildStarted;
-        event Microsoft.Build.Framework.CustomBuildEventHandler CustomEventRaised;
-        event Microsoft.Build.Framework.BuildErrorEventHandler ErrorRaised;
-        event Microsoft.Build.Framework.BuildMessageEventHandler MessageRaised;
-        event Microsoft.Build.Framework.ProjectFinishedEventHandler ProjectFinished;
-        event Microsoft.Build.Framework.ProjectStartedEventHandler ProjectStarted;
-        event Microsoft.Build.Framework.BuildStatusEventHandler StatusEventRaised;
-        event Microsoft.Build.Framework.TargetFinishedEventHandler TargetFinished;
-        event Microsoft.Build.Framework.TargetStartedEventHandler TargetStarted;
-        event Microsoft.Build.Framework.TaskFinishedEventHandler TaskFinished;
-        event Microsoft.Build.Framework.TaskStartedEventHandler TaskStarted;
-        event Microsoft.Build.Framework.BuildWarningEventHandler WarningRaised;
-    }
-    public partial interface IEventSource2 : Microsoft.Build.Framework.IEventSource
-    {
-        event Microsoft.Build.Framework.TelemetryEventHandler TelemetryLogged;
-    }
-    public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2
-    {
-        void IncludeEvaluationMetaprojects();
-        void IncludeEvaluationProfiles();
-        void IncludeTaskInputs();
-    }
-    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
-    {
-        void IncludeEvaluationPropertiesAndItems();
-    }
-    public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
-        int NodeId { get; set; }
-    }
-    public partial interface IGeneratedTask : Microsoft.Build.Framework.ITask
-    {
-        object GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property);
-        void SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    public partial interface ILogger
-    {
-        string Parameters { get; set; }
-        Microsoft.Build.Framework.LoggerVerbosity Verbosity { get; set; }
-        void Initialize(Microsoft.Build.Framework.IEventSource eventSource);
-        void Shutdown();
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    public partial interface INodeLogger : Microsoft.Build.Framework.ILogger
-    {
-        void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount);
-    }
-    public partial interface IProjectElement
-    {
-        string ElementName { get; }
-        string OuterElement { get; }
-    }
-    public partial interface ITask
-    {
-        Microsoft.Build.Framework.IBuildEngine BuildEngine { get; set; }
-        Microsoft.Build.Framework.ITaskHost HostObject { get; set; }
-        bool Execute();
-    }
-    public partial interface ITaskFactory
-    {
-        string FactoryName { get; }
-        System.Type TaskType { get; }
-        void CleanupTask(Microsoft.Build.Framework.ITask task);
-        Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost);
-        Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters();
-        bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost);
-    }
-    public partial interface ITaskFactory2 : Microsoft.Build.Framework.ITaskFactory
-    {
-        Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters);
-        bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("9049A481-D0E9-414f-8F92-D4F67A0359A6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ITaskHost
-    {
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("8661674F-2148-4F71-A92A-49875511C528")]
-    public partial interface ITaskItem
-    {
-        string ItemSpec { get; set; }
-        int MetadataCount { get; }
-        System.Collections.ICollection MetadataNames { get; }
-        System.Collections.IDictionary CloneCustomMetadata();
-        void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem);
-        string GetMetadata(string metadataName);
-        void RemoveMetadata(string metadataName);
-        void SetMetadata(string metadataName, string metadataValue);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("ac6d5a59-f877-461b-88e3-b2f06fce0cb9")]
-    public partial interface ITaskItem2 : Microsoft.Build.Framework.ITaskItem
-    {
-        string EvaluatedIncludeEscaped { get; set; }
-        System.Collections.IDictionary CloneCustomMetadataEscaped();
-        string GetMetadataValueEscaped(string metadataName);
-        void SetMetadataValueLiteral(string metadataName, string metadataValue);
-    }
-    public partial class LazyFormattedBuildEventArgs : Microsoft.Build.Framework.BuildEventArgs
-    {
-        [System.NonSerializedAttribute]
-        protected object locker;
-        protected LazyFormattedBuildEventArgs() { }
-        public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) { }
-        public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public override string Message { get { throw null; } }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
-    public sealed partial class LoadInSeparateAppDomainAttribute : System.Attribute
-    {
-        public LoadInSeparateAppDomainAttribute() { }
-    }
-    public partial class LoggerException : System.Exception
-    {
-        public LoggerException() { }
-        protected LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-        public LoggerException(string message) { }
-        public LoggerException(string message, System.Exception innerException) { }
-        public LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) { }
-        public string ErrorCode { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    public enum LoggerVerbosity
-    {
-        Quiet = 0,
-        Minimal = 1,
-        Normal = 2,
-        Detailed = 3,
-        Diagnostic = 4,
-    }
-    public enum MessageImportance
-    {
-        High = 0,
-        Normal = 1,
-        Low = 2,
-    }
-    public partial class MetaprojectGeneratedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public string metaprojectXml;
-        public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) { }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
-    public sealed partial class OutputAttribute : System.Attribute
-    {
-        public OutputAttribute() { }
-    }
-    public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        public ProjectEvaluationFinishedEventArgs() { }
-        public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
-        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
-        public System.Collections.IEnumerable Items { get { throw null; } set { } }
-        public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
-        public string ProjectFile { get { throw null; } set { } }
-        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
-    }
-    public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        public ProjectEvaluationStartedEventArgs() { }
-        public ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) { }
-        public string ProjectFile { get { throw null; } set { } }
-    }
-    public partial class ProjectFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected ProjectFinishedEventArgs() { }
-        public ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) { }
-        public ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) { }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-    }
-    public delegate void ProjectFinishedEventHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e);
-    public partial class ProjectImportedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public ProjectImportedEventArgs() { }
-        public ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) { }
-        public string ImportedProjectFile { get { throw null; } set { } }
-        public bool ImportIgnored { get { throw null; } set { } }
-        public string UnexpandedProject { get { throw null; } set { } }
-    }
-    public partial class ProjectStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        public const int InvalidProjectId = -1;
-        protected ProjectStartedEventArgs() { }
-        public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) { }
-        public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) { }
-        public ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) { }
-        public ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) { }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public System.Collections.IEnumerable Items { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public Microsoft.Build.Framework.BuildEventContext ParentProjectBuildEventContext { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public int ProjectId { get { throw null; } }
-        public System.Collections.IEnumerable Properties { get { throw null; } }
-        public string TargetNames { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-    }
-    public delegate void ProjectStartedEventHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e);
-    public partial class PropertyInitialValueSetEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public PropertyInitialValueSetEventArgs() { }
-        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string PropertyName { get { throw null; } set { } }
-        public string PropertySource { get { throw null; } set { } }
-        public string PropertyValue { get { throw null; } set { } }
-    }
-    public partial class PropertyReassignmentEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public PropertyReassignmentEventArgs() { }
-        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string Location { get { throw null; } set { } }
-        public override string Message { get { throw null; } }
-        public string NewValue { get { throw null; } set { } }
-        public string PreviousValue { get { throw null; } set { } }
-        public string PropertyName { get { throw null; } set { } }
-    }
-    public enum RegisteredTaskObjectLifetime
-    {
-        Build = 0,
-        AppDomain = 1,
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RequiredAttribute : System.Attribute
-    {
-        public RequiredAttribute() { }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RequiredRuntimeAttribute : System.Attribute
-    {
-        public RequiredRuntimeAttribute(string runtimeVersion) { }
-        public string RuntimeVersion { get { throw null; } }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RunInMTAAttribute : System.Attribute
-    {
-        public RunInMTAAttribute() { }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RunInSTAAttribute : System.Attribute
-    {
-        public RunInSTAAttribute() { }
-    }
-    public abstract partial class SdkLogger
-    {
-        protected SdkLogger() { }
-        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low);
-    }
-    public sealed partial class SdkReference : System.IEquatable<Microsoft.Build.Framework.SdkReference>
-    {
-        public SdkReference(string name, string version, string minimumVersion) { }
-        public string MinimumVersion { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Version { get { throw null; } }
-        public bool Equals(Microsoft.Build.Framework.SdkReference other) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-        public static bool TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) { throw null; }
-    }
-    public abstract partial class SdkResolver
-    {
-        protected SdkResolver() { }
-        public abstract string Name { get; }
-        public abstract int Priority { get; }
-        public abstract Microsoft.Build.Framework.SdkResult Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory);
-    }
-    public abstract partial class SdkResolverContext
-    {
-        protected SdkResolverContext() { }
-        public virtual bool Interactive { get { throw null; } protected set { } }
-        public virtual bool IsRunningInVisualStudio { get { throw null; } protected set { } }
-        public virtual Microsoft.Build.Framework.SdkLogger Logger { get { throw null; } protected set { } }
-        public virtual System.Version MSBuildVersion { get { throw null; } protected set { } }
-        public virtual string ProjectFilePath { get { throw null; } protected set { } }
-        public virtual string SolutionFilePath { get { throw null; } protected set { } }
-        public virtual object State { get { throw null; } set { } }
-    }
-    public abstract partial class SdkResult
-    {
-        protected SdkResult() { }
-        public virtual System.Collections.Generic.IList<string> AdditionalPaths { get { throw null; } set { } }
-        public virtual System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> ItemsToAdd { get { throw null; } protected set { } }
-        public virtual string Path { get { throw null; } protected set { } }
-        public virtual System.Collections.Generic.IDictionary<string, string> PropertiesToAdd { get { throw null; } protected set { } }
-        public virtual Microsoft.Build.Framework.SdkReference SdkReference { get { throw null; } protected set { } }
-        public virtual bool Success { get { throw null; } protected set { } }
-        public virtual string Version { get { throw null; } protected set { } }
-    }
-    public abstract partial class SdkResultFactory
-    {
-        protected SdkResultFactory() { }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null);
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null);
-    }
-    public partial class SdkResultItem
-    {
-        public SdkResultItem() { }
-        public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) { }
-        public string ItemSpec { get { throw null; } set { } }
-        public System.Collections.Generic.Dictionary<string, string> Metadata { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-    }
-    public enum TargetBuiltReason
-    {
-        None = 0,
-        BeforeTargets = 1,
-        DependsOn = 2,
-        AfterTargets = 3,
-    }
-    public partial class TargetFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TargetFinishedEventArgs() { }
-        public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) { }
-        public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) { }
-        public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) { }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-        public string TargetFile { get { throw null; } }
-        public string TargetName { get { throw null; } }
-        public System.Collections.IEnumerable TargetOutputs { get { throw null; } set { } }
-    }
-    public delegate void TargetFinishedEventHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e);
-    public partial class TargetSkippedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public TargetSkippedEventArgs() { }
-        public TargetSkippedEventArgs(string message, params object[] messageArgs) { }
-        public Microsoft.Build.Framework.TargetBuiltReason BuildReason { get { throw null; } set { } }
-        public string Condition { get { throw null; } set { } }
-        public string EvaluatedCondition { get { throw null; } set { } }
-        public override string Message { get { throw null; } }
-        public Microsoft.Build.Framework.BuildEventContext OriginalBuildEventContext { get { throw null; } set { } }
-        public bool OriginallySucceeded { get { throw null; } set { } }
-        public string ParentTarget { get { throw null; } set { } }
-        public Microsoft.Build.Framework.TargetSkipReason SkipReason { get { throw null; } set { } }
-        public string TargetFile { get { throw null; } set { } }
-        public string TargetName { get { throw null; } set { } }
-    }
-    public enum TargetSkipReason
-    {
-        None = 0,
-        PreviouslyBuiltSuccessfully = 1,
-        PreviouslyBuiltUnsuccessfully = 2,
-        OutputsUpToDate = 3,
-        ConditionWasFalse = 4,
-    }
-    public partial class TargetStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TargetStartedEventArgs() { }
-        public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) { }
-        public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) { }
-        public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) { }
-        public Microsoft.Build.Framework.TargetBuiltReason BuildReason { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public string ParentTarget { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public string TargetFile { get { throw null; } }
-        public string TargetName { get { throw null; } }
-    }
-    public delegate void TargetStartedEventHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e);
-    public partial class TaskCommandLineEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        protected TaskCommandLineEventArgs() { }
-        public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) { }
-        public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) { }
-        public string CommandLine { get { throw null; } }
-        public string TaskName { get { throw null; } }
-    }
-    public partial class TaskFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TaskFinishedEventArgs() { }
-        public TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) { }
-        public TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) { }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-        public string TaskFile { get { throw null; } }
-        public string TaskName { get { throw null; } }
-    }
-    public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
-    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
-        public System.Collections.IList Items { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
-        public bool LogItemMetadata { get { throw null; } }
-        public override string Message { get { throw null; } }
-    }
-    public enum TaskParameterMessageKind
-    {
-        TaskInput = 0,
-        TaskOutput = 1,
-        AddItem = 2,
-        RemoveItem = 3,
-        SkippedTargetInputs = 4,
-        SkippedTargetOutputs = 5,
-    }
-    public partial class TaskPropertyInfo
-    {
-        public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
-        public bool Log { get { throw null; } set { } }
-        public bool LogItemMetadata { get { throw null; } set { } }
-        public string Name { get { throw null; } }
-        public bool Output { get { throw null; } }
-        public System.Type PropertyType { get { throw null; } }
-        public bool Required { get { throw null; } }
-    }
-    public partial class TaskStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TaskStartedEventArgs() { }
-        public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) { }
-        public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) { }
-        public int ColumnNumber { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public string TaskFile { get { throw null; } }
-        public string TaskName { get { throw null; } }
-    }
-    public delegate void TaskStartedEventHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e);
-    public sealed partial class TelemetryEventArgs : Microsoft.Build.Framework.BuildEventArgs
-    {
-        public TelemetryEventArgs() { }
-        public string EventName { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> Properties { get { throw null; } set { } }
-    }
-    public delegate void TelemetryEventHandler(object sender, Microsoft.Build.Framework.TelemetryEventArgs e);
-    public partial class UninitializedPropertyReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public UninitializedPropertyReadEventArgs() { }
-        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string PropertyName { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Framework.Profiler
-{
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct EvaluationLocation
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
-        public EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
-        public EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
-        public string ElementDescription { get { throw null; } }
-        public string ElementName { get { throw null; } }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation EmptyLocation { get { throw null; } }
-        public Microsoft.Build.Framework.Profiler.EvaluationPass EvaluationPass { get { throw null; } }
-        public string EvaluationPassDescription { get { throw null; } }
-        public string File { get { throw null; } }
-        public long Id { get { throw null; } }
-        public bool IsEvaluationPass { get { throw null; } }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocationKind Kind { get { throw null; } }
-        public int? Line { get { throw null; } }
-        public long? ParentId { get { throw null; } }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForAggregatedGlob() { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFile(string file) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndCondition(string file, int? line, string condition) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithGlob(string globDescription) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithParentId(long? parentId) { throw null; }
-    }
-    public enum EvaluationLocationKind : byte
-    {
-        Element = (byte)0,
-        Condition = (byte)1,
-        Glob = (byte)2,
-    }
-    public enum EvaluationPass : byte
-    {
-        TotalEvaluation = (byte)0,
-        TotalGlobbing = (byte)1,
-        InitialProperties = (byte)2,
-        Properties = (byte)3,
-        ItemDefinitionGroups = (byte)4,
-        Items = (byte)5,
-        LazyItems = (byte)6,
-        UsingTasks = (byte)7,
-        Targets = (byte)8,
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ProfiledLocation
-    {
-        private int _dummyPrimitive;
-        public ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) { throw null; }
-        public System.TimeSpan ExclusiveTime { get { throw null; } }
-        public System.TimeSpan InclusiveTime { get { throw null; } }
-        public int NumberOfHits { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ProfilerResult
-    {
-        private object _dummy;
-        public ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) { throw null; }
-        public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> ProfiledLocations { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-    }
-}
-namespace Microsoft.Build.Framework.XamlTypes
-{
-    public sealed partial class Argument : System.ComponentModel.ISupportInitialize
-    {
-        public Argument() { }
-        public bool IsRequired { get { throw null; } set { } }
-        public string Property { get { throw null; } set { } }
-        public string Separator { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("Arguments")]
-    public abstract partial class BaseProperty : System.ComponentModel.ISupportInitialize
-    {
-        protected BaseProperty() { }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument> Arguments { get { throw null; } set { } }
-        public string Category { get { throw null; } set { } }
-        public Microsoft.Build.Framework.XamlTypes.Rule ContainingRule { get { throw null; } }
-        public Microsoft.Build.Framework.XamlTypes.DataSource DataSource { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string Default { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string Description { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string DisplayName { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(false)]
-        public string F1Keyword { get { throw null; } set { } }
-        public int HelpContext { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(false)]
-        public string HelpFile { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(false)]
-        public string HelpUrl { get { throw null; } set { } }
-        public bool IncludeInCommandLine { get { throw null; } set { } }
-        public bool IsRequired { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair> Metadata { get { throw null; } set { } }
-        public bool MultipleValuesAllowed { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public bool ReadOnly { get { throw null; } set { } }
-        public string Separator { get { throw null; } set { } }
-        public string Subcategory { get { throw null; } set { } }
-        public string Switch { get { throw null; } set { } }
-        public string SwitchPrefix { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.ValueEditor> ValueEditors { get { throw null; } set { } }
-        public bool Visible { get { throw null; } set { } }
-        public virtual void BeginInit() { }
-        public virtual void EndInit() { }
-    }
-    public sealed partial class BoolProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
-    {
-        public BoolProperty() { }
-        public string ReverseSwitch { get { throw null; } set { } }
-    }
-    public sealed partial class Category : Microsoft.Build.Framework.XamlTypes.CategorySchema, System.ComponentModel.ISupportInitialize
-    {
-        public Category() { }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string Description { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string DisplayName { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string HelpString { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public string Subtype { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-    }
-    public abstract partial class CategorySchema
-    {
-        protected CategorySchema() { }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("Metadata")]
-    public sealed partial class ContentType : Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode, System.ComponentModel.ISupportInitialize
-    {
-        public ContentType() { }
-        public bool DefaultContentTypeForItemType { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string DisplayName { get { throw null; } set { } }
-        [System.ObsoleteAttribute("Unused.  Use ItemType property instead.", true)]
-        public string ItemGroupName { get { throw null; } set { } }
-        public string ItemType { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair> Metadata { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-        public string GetMetadata(string metadataName) { throw null; }
-        public System.Collections.Generic.IEnumerable<object> GetSchemaObjects(System.Type type) { throw null; }
-        public System.Collections.Generic.IEnumerable<System.Type> GetSchemaObjectTypes() { throw null; }
-    }
-    public sealed partial class DataSource : System.ComponentModel.ISupportInitialize
-    {
-        public DataSource() { }
-        public bool HasConfigurationCondition { get { throw null; } set { } }
-        public string ItemType { get { throw null; } set { } }
-        public string Label { get { throw null; } set { } }
-        public string MSBuildTarget { get { throw null; } set { } }
-        public string PersistedName { get { throw null; } set { } }
-        public string Persistence { get { throw null; } set { } }
-        public string PersistenceStyle { get { throw null; } set { } }
-        public Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation SourceOfDefaultValue { get { throw null; } set { } }
-        public string SourceType { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-    }
-    public enum DefaultValueSourceLocation
-    {
-        BeforeContext = 0,
-        AfterContext = 1,
-    }
-    public sealed partial class DynamicEnumProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
-    {
-        public DynamicEnumProperty() { }
-        public string EnumProvider { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair> ProviderSettings { get { throw null; } set { } }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("AdmissibleValues")]
-    public sealed partial class EnumProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
-    {
-        public EnumProperty() { }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.EnumValue> AdmissibleValues { get { throw null; } set { } }
-        public override void EndInit() { }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("Arguments")]
-    public sealed partial class EnumValue
-    {
-        public EnumValue() { }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument> Arguments { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string Description { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string DisplayName { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string HelpString { get { throw null; } set { } }
-        public bool IsDefault { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair> Metadata { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public string Switch { get { throw null; } set { } }
-        public string SwitchPrefix { get { throw null; } set { } }
-    }
-    public sealed partial class FileExtension : Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode
-    {
-        public FileExtension() { }
-        public string ContentType { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public System.Collections.Generic.IEnumerable<object> GetSchemaObjects(System.Type type) { throw null; }
-        public System.Collections.Generic.IEnumerable<System.Type> GetSchemaObjectTypes() { throw null; }
-    }
-    public sealed partial class IntProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
-    {
-        public IntProperty() { }
-        public int? MaxValue { get { throw null; } set { } }
-        public int? MinValue { get { throw null; } set { } }
-        public override void EndInit() { }
-    }
-    public partial interface IProjectSchemaNode
-    {
-        System.Collections.Generic.IEnumerable<object> GetSchemaObjects(System.Type type);
-        System.Collections.Generic.IEnumerable<System.Type> GetSchemaObjectTypes();
-    }
-    public sealed partial class ItemType : Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode, System.ComponentModel.ISupportInitialize
-    {
-        public ItemType() { }
-        public string DefaultContentType { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string DisplayName { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public bool UpToDateCheckInput { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-        public System.Collections.Generic.IEnumerable<object> GetSchemaObjects(System.Type type) { throw null; }
-        public System.Collections.Generic.IEnumerable<System.Type> GetSchemaObjectTypes() { throw null; }
-    }
-    public partial class NameValuePair
-    {
-        public NameValuePair() { }
-        public string Name { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string Value { get { throw null; } set { } }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("Nodes")]
-    public sealed partial class ProjectSchemaDefinitions : Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode
-    {
-        public ProjectSchemaDefinitions() { }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode> Nodes { get { throw null; } set { } }
-        public System.Collections.Generic.IEnumerable<object> GetSchemaObjects(System.Type type) { throw null; }
-        public System.Collections.Generic.IEnumerable<System.Type> GetSchemaObjectTypes() { throw null; }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("Properties")]
-    public sealed partial class Rule : Microsoft.Build.Framework.XamlTypes.RuleSchema, Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode, System.ComponentModel.ISupportInitialize
-    {
-        public Rule() { }
-        public string AdditionalInputs { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category> Categories { get { throw null; } set { } }
-        public string CommandLine { get { throw null; } set { } }
-        public Microsoft.Build.Framework.XamlTypes.DataSource DataSource { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string Description { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string DisplayName { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category> EvaluatedCategories { get { throw null; } }
-        public string ExecutionDescription { get { throw null; } set { } }
-        public string FileExtension { get { throw null; } set { } }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string HelpString { get { throw null; } set { } }
-        public System.Collections.Generic.Dictionary<string, object> Metadata { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public int Order { get { throw null; } set { } }
-        public string Outputs { get { throw null; } set { } }
-        public Microsoft.Build.Framework.XamlTypes.RuleOverrideMode OverrideMode { get { throw null; } set { } }
-        public string PageTemplate { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.BaseProperty> Properties { get { throw null; } set { } }
-        public bool PropertyPagesHidden { get { throw null; } set { } }
-        public string Separator { get { throw null; } set { } }
-        public bool ShowOnlyRuleProperties { get { throw null; } set { } }
-        public bool SupportsFileBatching { get { throw null; } set { } }
-        public string SwitchPrefix { get { throw null; } set { } }
-        public string ToolName { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-        public System.Collections.Specialized.OrderedDictionary GetPropertiesByCategory() { throw null; }
-        public System.Collections.Generic.IList<Microsoft.Build.Framework.XamlTypes.BaseProperty> GetPropertiesInCategory(string categoryName) { throw null; }
-        public Microsoft.Build.Framework.XamlTypes.BaseProperty GetProperty(string propertyName) { throw null; }
-        public System.Collections.Generic.IEnumerable<object> GetSchemaObjects(System.Type type) { throw null; }
-        public System.Collections.Generic.IEnumerable<System.Type> GetSchemaObjectTypes() { throw null; }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("Rules")]
-    public sealed partial class RuleBag : Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode, System.ComponentModel.ISupportInitialize
-    {
-        public RuleBag() { }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Rule> Rules { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-        public System.Collections.Generic.IEnumerable<object> GetSchemaObjects(System.Type type) { throw null; }
-        public System.Collections.Generic.IEnumerable<System.Type> GetSchemaObjectTypes() { throw null; }
-    }
-    public enum RuleOverrideMode
-    {
-        Replace = 0,
-        Extend = 1,
-    }
-    public abstract partial class RuleSchema
-    {
-        protected RuleSchema() { }
-    }
-    public sealed partial class StringListProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
-    {
-        public StringListProperty() { }
-        public string CommandLineValueSeparator { get { throw null; } set { } }
-        public string RendererValueSeparator { get { throw null; } set { } }
-        public string Subtype { get { throw null; } set { } }
-    }
-    public sealed partial class StringProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
-    {
-        public StringProperty() { }
-        public string Subtype { get { throw null; } set { } }
-    }
-    [System.Windows.Markup.ContentPropertyAttribute("Metadata")]
-    public sealed partial class ValueEditor : System.ComponentModel.ISupportInitialize
-    {
-        public ValueEditor() { }
-        [System.ComponentModel.LocalizableAttribute(true)]
-        public string DisplayName { get { throw null; } set { } }
-        public string EditorType { get { throw null; } set { } }
-        public System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair> Metadata { get { throw null; } set { } }
-        public void BeginInit() { }
-        public void EndInit() { }
-    }
-}
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
deleted file mode 100644
index f4dc90e663c..00000000000
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ /dev/null
@@ -1,773 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.Framework
-{
-    public delegate void AnyEventHandler(object sender, Microsoft.Build.Framework.BuildEventArgs e);
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct BuildEngineResult
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) { throw null; }
-        public bool Result { get { throw null; } }
-        public System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> TargetOutputsPerProject { get { throw null; } }
-    }
-    public partial class BuildErrorEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildErrorEventArgs() { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public string Code { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string File { get { throw null; } }
-        public string HelpLink { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public string ProjectFile { get { throw null; } set { } }
-        public string Subcategory { get { throw null; } }
-    }
-    public delegate void BuildErrorEventHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e);
-    public abstract partial class BuildEventArgs : System.EventArgs
-    {
-        protected BuildEventArgs() { }
-        protected BuildEventArgs(string message, string helpKeyword, string senderName) { }
-        protected BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } }
-        public virtual string Message { get { throw null; } protected set { } }
-        protected internal string RawMessage { get { throw null; } set { } }
-        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
-        public string SenderName { get { throw null; } }
-        public int ThreadId { get { throw null; } }
-        public System.DateTime Timestamp { get { throw null; } }
-    }
-    public partial class BuildEventContext
-    {
-        public const int InvalidEvaluationId = -1;
-        public const int InvalidNodeId = -2;
-        public const int InvalidProjectContextId = -2;
-        public const int InvalidProjectInstanceId = -1;
-        public const int InvalidSubmissionId = -1;
-        public const int InvalidTargetId = -1;
-        public const int InvalidTaskId = -1;
-        public BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) { }
-        public BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) { }
-        public BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) { }
-        public BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) { }
-        public long BuildRequestId { get { throw null; } }
-        public int EvaluationId { get { throw null; } }
-        public static Microsoft.Build.Framework.BuildEventContext Invalid { get { throw null; } }
-        public int NodeId { get { throw null; } }
-        public int ProjectContextId { get { throw null; } }
-        public int ProjectInstanceId { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public int TargetId { get { throw null; } }
-        public int TaskId { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
-        public static bool operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public partial class BuildFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected BuildFinishedEventArgs() { }
-        public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) { }
-        public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) { }
-        public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public bool Succeeded { get { throw null; } }
-    }
-    public delegate void BuildFinishedEventHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e);
-    public partial class BuildMessageEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildMessageEventArgs() { }
-        public BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) { }
-        public BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) { }
-        public BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) { }
-        public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) { }
-        public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public string Code { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string File { get { throw null; } }
-        public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public string ProjectFile { get { throw null; } set { } }
-        public string Subcategory { get { throw null; } }
-    }
-    public delegate void BuildMessageEventHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e);
-    public partial class BuildStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected BuildStartedEventArgs() { }
-        public BuildStartedEventArgs(string message, string helpKeyword) { }
-        public BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) { }
-        public BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) { }
-        public BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public System.Collections.Generic.IDictionary<string, string> BuildEnvironment { get { throw null; } }
-    }
-    public delegate void BuildStartedEventHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e);
-    public abstract partial class BuildStatusEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildStatusEventArgs() { }
-        protected BuildStatusEventArgs(string message, string helpKeyword, string senderName) { }
-        protected BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        protected BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-    }
-    public delegate void BuildStatusEventHandler(object sender, Microsoft.Build.Framework.BuildStatusEventArgs e);
-    public partial class BuildWarningEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected BuildWarningEventArgs() { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public string Code { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string File { get { throw null; } }
-        public string HelpLink { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public string ProjectFile { get { throw null; } set { } }
-        public string Subcategory { get { throw null; } }
-    }
-    public delegate void BuildWarningEventHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e);
-    public partial class CriticalBuildMessageEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        protected CriticalBuildMessageEventArgs() { }
-        public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) { }
-        public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-    }
-    public abstract partial class CustomBuildEventArgs : Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-    {
-        protected CustomBuildEventArgs() { }
-        protected CustomBuildEventArgs(string message, string helpKeyword, string senderName) { }
-        protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) { }
-        protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-    }
-    public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
-    public abstract partial class EngineServices
-    {
-        public const int Version1 = 1;
-        protected EngineServices() { }
-        public virtual bool IsTaskInputLoggingEnabled { get { throw null; } }
-        public virtual int Version { get { throw null; } }
-        public virtual bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
-    }
-    public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public EnvironmentVariableReadEventArgs() { }
-        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string EnvironmentVariableName { get { throw null; } set { } }
-    }
-    public partial class ExternalProjectFinishedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
-    {
-        protected ExternalProjectFinishedEventArgs() { }
-        public ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) { }
-        public ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) { }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-    }
-    public partial class ExternalProjectStartedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
-    {
-        protected ExternalProjectStartedEventArgs() { }
-        public ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) { }
-        public ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) { }
-        public string ProjectFile { get { throw null; } }
-        public string TargetNames { get { throw null; } }
-    }
-    public partial interface IBuildEngine
-    {
-        int ColumnNumberOfTaskNode { get; }
-        bool ContinueOnError { get; }
-        int LineNumberOfTaskNode { get; }
-        string ProjectFileOfTaskNode { get; }
-        bool BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs);
-        void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e);
-        void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e);
-        void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e);
-        void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e);
-    }
-    public partial interface IBuildEngine10 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8, Microsoft.Build.Framework.IBuildEngine9
-    {
-        Microsoft.Build.Framework.EngineServices EngineServices { get; }
-    }
-    public partial interface IBuildEngine2 : Microsoft.Build.Framework.IBuildEngine
-    {
-        bool IsRunningMultipleNodes { get; }
-        bool BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion);
-        bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion);
-    }
-    public partial interface IBuildEngine3 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2
-    {
-        Microsoft.Build.Framework.BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs);
-        void Reacquire();
-        void Yield();
-    }
-    public partial interface IBuildEngine4 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3
-    {
-        object GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime);
-        void RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
-        object UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime);
-    }
-    public partial interface IBuildEngine5 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4
-    {
-        void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties);
-    }
-    public partial interface IBuildEngine6 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5
-    {
-        System.Collections.Generic.IReadOnlyDictionary<string, string> GetGlobalProperties();
-    }
-    public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6
-    {
-        bool AllowFailureWithoutError { get; set; }
-    }
-    public partial interface IBuildEngine8 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7
-    {
-        bool ShouldTreatWarningAsError(string warningCode);
-    }
-    public partial interface IBuildEngine9 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8
-    {
-        void ReleaseCores(int coresToRelease);
-        int RequestCores(int requestedCores);
-    }
-    public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
-    {
-        void Cancel();
-    }
-    public partial interface IEventRedirector
-    {
-        void ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent);
-    }
-    public partial interface IEventSource
-    {
-        event Microsoft.Build.Framework.AnyEventHandler AnyEventRaised;
-        event Microsoft.Build.Framework.BuildFinishedEventHandler BuildFinished;
-        event Microsoft.Build.Framework.BuildStartedEventHandler BuildStarted;
-        event Microsoft.Build.Framework.CustomBuildEventHandler CustomEventRaised;
-        event Microsoft.Build.Framework.BuildErrorEventHandler ErrorRaised;
-        event Microsoft.Build.Framework.BuildMessageEventHandler MessageRaised;
-        event Microsoft.Build.Framework.ProjectFinishedEventHandler ProjectFinished;
-        event Microsoft.Build.Framework.ProjectStartedEventHandler ProjectStarted;
-        event Microsoft.Build.Framework.BuildStatusEventHandler StatusEventRaised;
-        event Microsoft.Build.Framework.TargetFinishedEventHandler TargetFinished;
-        event Microsoft.Build.Framework.TargetStartedEventHandler TargetStarted;
-        event Microsoft.Build.Framework.TaskFinishedEventHandler TaskFinished;
-        event Microsoft.Build.Framework.TaskStartedEventHandler TaskStarted;
-        event Microsoft.Build.Framework.BuildWarningEventHandler WarningRaised;
-    }
-    public partial interface IEventSource2 : Microsoft.Build.Framework.IEventSource
-    {
-        event Microsoft.Build.Framework.TelemetryEventHandler TelemetryLogged;
-    }
-    public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2
-    {
-        void IncludeEvaluationMetaprojects();
-        void IncludeEvaluationProfiles();
-        void IncludeTaskInputs();
-    }
-    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
-    {
-        void IncludeEvaluationPropertiesAndItems();
-    }
-    public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
-        int NodeId { get; set; }
-    }
-    public partial interface IGeneratedTask : Microsoft.Build.Framework.ITask
-    {
-        object GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property);
-        void SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    public partial interface ILogger
-    {
-        string Parameters { get; set; }
-        Microsoft.Build.Framework.LoggerVerbosity Verbosity { get; set; }
-        void Initialize(Microsoft.Build.Framework.IEventSource eventSource);
-        void Shutdown();
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    public partial interface INodeLogger : Microsoft.Build.Framework.ILogger
-    {
-        void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount);
-    }
-    public partial interface IProjectElement
-    {
-        string ElementName { get; }
-        string OuterElement { get; }
-    }
-    public partial interface ITask
-    {
-        Microsoft.Build.Framework.IBuildEngine BuildEngine { get; set; }
-        Microsoft.Build.Framework.ITaskHost HostObject { get; set; }
-        bool Execute();
-    }
-    public partial interface ITaskFactory
-    {
-        string FactoryName { get; }
-        System.Type TaskType { get; }
-        void CleanupTask(Microsoft.Build.Framework.ITask task);
-        Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost);
-        Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters();
-        bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost);
-    }
-    public partial interface ITaskFactory2 : Microsoft.Build.Framework.ITaskFactory
-    {
-        Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters);
-        bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("9049A481-D0E9-414f-8F92-D4F67A0359A6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ITaskHost
-    {
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("8661674F-2148-4F71-A92A-49875511C528")]
-    public partial interface ITaskItem
-    {
-        string ItemSpec { get; set; }
-        int MetadataCount { get; }
-        System.Collections.ICollection MetadataNames { get; }
-        System.Collections.IDictionary CloneCustomMetadata();
-        void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem);
-        string GetMetadata(string metadataName);
-        void RemoveMetadata(string metadataName);
-        void SetMetadata(string metadataName, string metadataValue);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("ac6d5a59-f877-461b-88e3-b2f06fce0cb9")]
-    public partial interface ITaskItem2 : Microsoft.Build.Framework.ITaskItem
-    {
-        string EvaluatedIncludeEscaped { get; set; }
-        System.Collections.IDictionary CloneCustomMetadataEscaped();
-        string GetMetadataValueEscaped(string metadataName);
-        void SetMetadataValueLiteral(string metadataName, string metadataValue);
-    }
-    public partial class LazyFormattedBuildEventArgs : Microsoft.Build.Framework.BuildEventArgs
-    {
-        [System.NonSerializedAttribute]
-        protected object locker;
-        protected LazyFormattedBuildEventArgs() { }
-        public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) { }
-        public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
-        public override string Message { get { throw null; } }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
-    public sealed partial class LoadInSeparateAppDomainAttribute : System.Attribute
-    {
-        public LoadInSeparateAppDomainAttribute() { }
-    }
-    public partial class LoggerException : System.Exception
-    {
-        public LoggerException() { }
-        protected LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-        public LoggerException(string message) { }
-        public LoggerException(string message, System.Exception innerException) { }
-        public LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) { }
-        public string ErrorCode { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    public enum LoggerVerbosity
-    {
-        Quiet = 0,
-        Minimal = 1,
-        Normal = 2,
-        Detailed = 3,
-        Diagnostic = 4,
-    }
-    public enum MessageImportance
-    {
-        High = 0,
-        Normal = 1,
-        Low = 2,
-    }
-    public partial class MetaprojectGeneratedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public string metaprojectXml;
-        public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) { }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
-    public sealed partial class OutputAttribute : System.Attribute
-    {
-        public OutputAttribute() { }
-    }
-    public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        public ProjectEvaluationFinishedEventArgs() { }
-        public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
-        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
-        public System.Collections.IEnumerable Items { get { throw null; } set { } }
-        public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
-        public string ProjectFile { get { throw null; } set { } }
-        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
-    }
-    public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        public ProjectEvaluationStartedEventArgs() { }
-        public ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) { }
-        public string ProjectFile { get { throw null; } set { } }
-    }
-    public partial class ProjectFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected ProjectFinishedEventArgs() { }
-        public ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) { }
-        public ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) { }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-    }
-    public delegate void ProjectFinishedEventHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e);
-    public partial class ProjectImportedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public ProjectImportedEventArgs() { }
-        public ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) { }
-        public string ImportedProjectFile { get { throw null; } set { } }
-        public bool ImportIgnored { get { throw null; } set { } }
-        public string UnexpandedProject { get { throw null; } set { } }
-    }
-    public partial class ProjectStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        public const int InvalidProjectId = -1;
-        protected ProjectStartedEventArgs() { }
-        public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) { }
-        public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) { }
-        public ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) { }
-        public ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) { }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public System.Collections.IEnumerable Items { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public Microsoft.Build.Framework.BuildEventContext ParentProjectBuildEventContext { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public int ProjectId { get { throw null; } }
-        public System.Collections.IEnumerable Properties { get { throw null; } }
-        public string TargetNames { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-    }
-    public delegate void ProjectStartedEventHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e);
-    public partial class PropertyInitialValueSetEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public PropertyInitialValueSetEventArgs() { }
-        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string PropertyName { get { throw null; } set { } }
-        public string PropertySource { get { throw null; } set { } }
-        public string PropertyValue { get { throw null; } set { } }
-    }
-    public partial class PropertyReassignmentEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public PropertyReassignmentEventArgs() { }
-        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string Location { get { throw null; } set { } }
-        public override string Message { get { throw null; } }
-        public string NewValue { get { throw null; } set { } }
-        public string PreviousValue { get { throw null; } set { } }
-        public string PropertyName { get { throw null; } set { } }
-    }
-    public enum RegisteredTaskObjectLifetime
-    {
-        Build = 0,
-        AppDomain = 1,
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RequiredAttribute : System.Attribute
-    {
-        public RequiredAttribute() { }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RequiredRuntimeAttribute : System.Attribute
-    {
-        public RequiredRuntimeAttribute(string runtimeVersion) { }
-        public string RuntimeVersion { get { throw null; } }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RunInMTAAttribute : System.Attribute
-    {
-        public RunInMTAAttribute() { }
-    }
-    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
-    public sealed partial class RunInSTAAttribute : System.Attribute
-    {
-        public RunInSTAAttribute() { }
-    }
-    public abstract partial class SdkLogger
-    {
-        protected SdkLogger() { }
-        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low);
-    }
-    public sealed partial class SdkReference : System.IEquatable<Microsoft.Build.Framework.SdkReference>
-    {
-        public SdkReference(string name, string version, string minimumVersion) { }
-        public string MinimumVersion { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Version { get { throw null; } }
-        public bool Equals(Microsoft.Build.Framework.SdkReference other) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-        public static bool TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) { throw null; }
-    }
-    public abstract partial class SdkResolver
-    {
-        protected SdkResolver() { }
-        public abstract string Name { get; }
-        public abstract int Priority { get; }
-        public abstract Microsoft.Build.Framework.SdkResult Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory);
-    }
-    public abstract partial class SdkResolverContext
-    {
-        protected SdkResolverContext() { }
-        public virtual bool Interactive { get { throw null; } protected set { } }
-        public virtual bool IsRunningInVisualStudio { get { throw null; } protected set { } }
-        public virtual Microsoft.Build.Framework.SdkLogger Logger { get { throw null; } protected set { } }
-        public virtual System.Version MSBuildVersion { get { throw null; } protected set { } }
-        public virtual string ProjectFilePath { get { throw null; } protected set { } }
-        public virtual string SolutionFilePath { get { throw null; } protected set { } }
-        public virtual object State { get { throw null; } set { } }
-    }
-    public abstract partial class SdkResult
-    {
-        protected SdkResult() { }
-        public virtual System.Collections.Generic.IList<string> AdditionalPaths { get { throw null; } set { } }
-        public virtual System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> ItemsToAdd { get { throw null; } protected set { } }
-        public virtual string Path { get { throw null; } protected set { } }
-        public virtual System.Collections.Generic.IDictionary<string, string> PropertiesToAdd { get { throw null; } protected set { } }
-        public virtual Microsoft.Build.Framework.SdkReference SdkReference { get { throw null; } protected set { } }
-        public virtual bool Success { get { throw null; } protected set { } }
-        public virtual string Version { get { throw null; } protected set { } }
-    }
-    public abstract partial class SdkResultFactory
-    {
-        protected SdkResultFactory() { }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null);
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null);
-    }
-    public partial class SdkResultItem
-    {
-        public SdkResultItem() { }
-        public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) { }
-        public string ItemSpec { get { throw null; } set { } }
-        public System.Collections.Generic.Dictionary<string, string> Metadata { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-    }
-    public enum TargetBuiltReason
-    {
-        None = 0,
-        BeforeTargets = 1,
-        DependsOn = 2,
-        AfterTargets = 3,
-    }
-    public partial class TargetFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TargetFinishedEventArgs() { }
-        public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) { }
-        public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) { }
-        public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) { }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-        public string TargetFile { get { throw null; } }
-        public string TargetName { get { throw null; } }
-        public System.Collections.IEnumerable TargetOutputs { get { throw null; } set { } }
-    }
-    public delegate void TargetFinishedEventHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e);
-    public partial class TargetSkippedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public TargetSkippedEventArgs() { }
-        public TargetSkippedEventArgs(string message, params object[] messageArgs) { }
-        public Microsoft.Build.Framework.TargetBuiltReason BuildReason { get { throw null; } set { } }
-        public string Condition { get { throw null; } set { } }
-        public string EvaluatedCondition { get { throw null; } set { } }
-        public override string Message { get { throw null; } }
-        public Microsoft.Build.Framework.BuildEventContext OriginalBuildEventContext { get { throw null; } set { } }
-        public bool OriginallySucceeded { get { throw null; } set { } }
-        public string ParentTarget { get { throw null; } set { } }
-        public Microsoft.Build.Framework.TargetSkipReason SkipReason { get { throw null; } set { } }
-        public string TargetFile { get { throw null; } set { } }
-        public string TargetName { get { throw null; } set { } }
-    }
-    public enum TargetSkipReason
-    {
-        None = 0,
-        PreviouslyBuiltSuccessfully = 1,
-        PreviouslyBuiltUnsuccessfully = 2,
-        OutputsUpToDate = 3,
-        ConditionWasFalse = 4,
-    }
-    public partial class TargetStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TargetStartedEventArgs() { }
-        public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) { }
-        public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) { }
-        public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) { }
-        public Microsoft.Build.Framework.TargetBuiltReason BuildReason { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public string ParentTarget { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public string TargetFile { get { throw null; } }
-        public string TargetName { get { throw null; } }
-    }
-    public delegate void TargetStartedEventHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e);
-    public partial class TaskCommandLineEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        protected TaskCommandLineEventArgs() { }
-        public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) { }
-        public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) { }
-        public string CommandLine { get { throw null; } }
-        public string TaskName { get { throw null; } }
-    }
-    public partial class TaskFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TaskFinishedEventArgs() { }
-        public TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) { }
-        public TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) { }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-        public string TaskFile { get { throw null; } }
-        public string TaskName { get { throw null; } }
-    }
-    public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
-    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
-        public System.Collections.IList Items { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
-        public bool LogItemMetadata { get { throw null; } }
-        public override string Message { get { throw null; } }
-    }
-    public enum TaskParameterMessageKind
-    {
-        TaskInput = 0,
-        TaskOutput = 1,
-        AddItem = 2,
-        RemoveItem = 3,
-        SkippedTargetInputs = 4,
-        SkippedTargetOutputs = 5,
-    }
-    public partial class TaskPropertyInfo
-    {
-        public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
-        public bool Log { get { throw null; } set { } }
-        public bool LogItemMetadata { get { throw null; } set { } }
-        public string Name { get { throw null; } }
-        public bool Output { get { throw null; } }
-        public System.Type PropertyType { get { throw null; } }
-        public bool Required { get { throw null; } }
-    }
-    public partial class TaskStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
-    {
-        protected TaskStartedEventArgs() { }
-        public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) { }
-        public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) { }
-        public int ColumnNumber { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public string TaskFile { get { throw null; } }
-        public string TaskName { get { throw null; } }
-    }
-    public delegate void TaskStartedEventHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e);
-    public sealed partial class TelemetryEventArgs : Microsoft.Build.Framework.BuildEventArgs
-    {
-        public TelemetryEventArgs() { }
-        public string EventName { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> Properties { get { throw null; } set { } }
-    }
-    public delegate void TelemetryEventHandler(object sender, Microsoft.Build.Framework.TelemetryEventArgs e);
-    public partial class UninitializedPropertyReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
-    {
-        public UninitializedPropertyReadEventArgs() { }
-        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
-        public string PropertyName { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Framework.Profiler
-{
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct EvaluationLocation
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
-        public EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
-        public EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
-        public string ElementDescription { get { throw null; } }
-        public string ElementName { get { throw null; } }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation EmptyLocation { get { throw null; } }
-        public Microsoft.Build.Framework.Profiler.EvaluationPass EvaluationPass { get { throw null; } }
-        public string EvaluationPassDescription { get { throw null; } }
-        public string File { get { throw null; } }
-        public long Id { get { throw null; } }
-        public bool IsEvaluationPass { get { throw null; } }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocationKind Kind { get { throw null; } }
-        public int? Line { get { throw null; } }
-        public long? ParentId { get { throw null; } }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForAggregatedGlob() { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFile(string file) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndCondition(string file, int? line, string condition) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithGlob(string globDescription) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithParentId(long? parentId) { throw null; }
-    }
-    public enum EvaluationLocationKind : byte
-    {
-        Element = (byte)0,
-        Condition = (byte)1,
-        Glob = (byte)2,
-    }
-    public enum EvaluationPass : byte
-    {
-        TotalEvaluation = (byte)0,
-        TotalGlobbing = (byte)1,
-        InitialProperties = (byte)2,
-        Properties = (byte)3,
-        ItemDefinitionGroups = (byte)4,
-        Items = (byte)5,
-        LazyItems = (byte)6,
-        UsingTasks = (byte)7,
-        Targets = (byte)8,
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ProfiledLocation
-    {
-        private int _dummyPrimitive;
-        public ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) { throw null; }
-        public System.TimeSpan ExclusiveTime { get { throw null; } }
-        public System.TimeSpan InclusiveTime { get { throw null; } }
-        public int NumberOfHits { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ProfilerResult
-    {
-        private object _dummy;
-        public ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) { throw null; }
-        public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> ProfiledLocations { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-    }
-}
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
deleted file mode 100644
index 0c71f5d7390..00000000000
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ /dev/null
@@ -1,2710 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.Tasks
-{
-    public partial class AL : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public AL() { }
-        public string AlgorithmId { get { throw null; } set { } }
-        public string BaseAddress { get { throw null; } set { } }
-        public string CompanyName { get { throw null; } set { } }
-        public string Configuration { get { throw null; } set { } }
-        public string Copyright { get { throw null; } set { } }
-        public string Culture { get { throw null; } set { } }
-        public bool DelaySign { get { throw null; } set { } }
-        public string Description { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] EmbedResources { get { throw null; } set { } }
-        public string EvidenceFile { get { throw null; } set { } }
-        public string FileVersion { get { throw null; } set { } }
-        public string Flags { get { throw null; } set { } }
-        public bool GenerateFullPaths { get { throw null; } set { } }
-        public string KeyContainer { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] LinkResources { get { throw null; } set { } }
-        public string MainEntryPoint { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputAssembly { get { throw null; } set { } }
-        public string Platform { get { throw null; } set { } }
-        public bool Prefer32Bit { get { throw null; } set { } }
-        public string ProductName { get { throw null; } set { } }
-        public string ProductVersion { get { throw null; } set { } }
-        public string[] ResponseFiles { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] SourceModules { get { throw null; } set { } }
-        public string TargetType { get { throw null; } set { } }
-        public string TemplateFile { get { throw null; } set { } }
-        public string Title { get { throw null; } set { } }
-        protected override string ToolName { get { throw null; } }
-        public string Trademark { get { throw null; } set { } }
-        public string Version { get { throw null; } set { } }
-        public string Win32Icon { get { throw null; } set { } }
-        public string Win32Resource { get { throw null; } set { } }
-        protected internal override void AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        public override bool Execute() { throw null; }
-        protected override string GenerateFullPathToTool() { throw null; }
-    }
-    [Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute]
-    public abstract partial class AppDomainIsolatedTaskExtension : Microsoft.Build.Utilities.AppDomainIsolatedTask
-    {
-        internal AppDomainIsolatedTaskExtension() { }
-        public new Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-    }
-    public partial class AspNetCompiler : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public AspNetCompiler() { }
-        public bool AllowPartiallyTrustedCallers { get { throw null; } set { } }
-        public bool Clean { get { throw null; } set { } }
-        public bool Debug { get { throw null; } set { } }
-        public bool DelaySign { get { throw null; } set { } }
-        public bool FixedNames { get { throw null; } set { } }
-        public bool Force { get { throw null; } set { } }
-        public string KeyContainer { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        public string MetabasePath { get { throw null; } set { } }
-        public string PhysicalPath { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        public string TargetPath { get { throw null; } set { } }
-        protected override string ToolName { get { throw null; } }
-        public bool Updateable { get { throw null; } set { } }
-        public string VirtualPath { get { throw null; } set { } }
-        protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        public override bool Execute() { throw null; }
-        protected override string GenerateFullPathToTool() { throw null; }
-        protected override bool ValidateParameters() { throw null; }
-    }
-    public partial class AssignCulture : Microsoft.Build.Tasks.TaskExtension
-    {
-        public AssignCulture() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithCulture { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithNoCulture { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CultureNeutralAssignedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class AssignLinkMetadata : Microsoft.Build.Tasks.TaskExtension
-    {
-        public AssignLinkMetadata() { }
-        public Microsoft.Build.Framework.ITaskItem[] Items { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputItems { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class AssignProjectConfiguration : Microsoft.Build.Tasks.ResolveProjectBase
-    {
-        public AssignProjectConfiguration() { }
-        public bool AddSyntheticProjectReferencesForSolutionDependencies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedProjects { get { throw null; } set { } }
-        public string CurrentProject { get { throw null; } set { } }
-        public string CurrentProjectConfiguration { get { throw null; } set { } }
-        public string CurrentProjectPlatform { get { throw null; } set { } }
-        public string DefaultToVcxPlatformMapping { get { throw null; } set { } }
-        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get { throw null; } set { } }
-        public string OutputType { get { throw null; } set { } }
-        public bool ResolveConfigurationPlatformUsingMappings { get { throw null; } set { } }
-        public bool ShouldUnsetParentConfigurationAndPlatform { get { throw null; } set { } }
-        public string SolutionConfigurationContents { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnassignedProjects { get { throw null; } set { } }
-        public string VcxToDefaultPlatformMapping { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class AssignTargetPath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public AssignTargetPath() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string RootFolder { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    [Microsoft.Build.Framework.RunInMTAAttribute]
-    public partial class CallTarget : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CallTarget() { }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CodeTaskFactory : Microsoft.Build.Framework.ITaskFactory
-    {
-        public CodeTaskFactory() { }
-        public string FactoryName { get { throw null; } }
-        public System.Type TaskType { get { throw null; } }
-        public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
-        public Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine loggingHost) { throw null; }
-        public Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters() { throw null; }
-        public bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-    }
-    public partial class CombinePath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CombinePath() { }
-        public string BasePath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CombinedPaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CombineTargetFrameworkInfoProperties : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CombineTargetFrameworkInfoProperties() { }
-        public Microsoft.Build.Framework.ITaskItem[] PropertiesAndValues { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Result { get { throw null; } set { } }
-        public string RootElementName { get { throw null; } set { } }
-        public bool UseAttributeForTargetFrameworkInfoPropertyNames { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CombineXmlElements() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Result { get { throw null; } set { } }
-        public string RootElementName { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] XmlElements { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CommandLineBuilderExtension : Microsoft.Build.Utilities.CommandLineBuilder
-    {
-        public CommandLineBuilderExtension() { }
-        public CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) { }
-        protected string GetQuotedText(string unquotedText) { throw null; }
-    }
-    public partial class ConvertToAbsolutePath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ConvertToAbsolutePath() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AbsolutePaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Copy : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Copy() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CopiedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DestinationFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        public bool ErrorIfLinkFails { get { throw null; } set { } }
-        public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
-        public int Retries { get { throw null; } set { } }
-        public int RetryDelayMilliseconds { get { throw null; } set { } }
-        public bool SkipUnchangedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
-        public bool UseHardlinksIfPossible { get { throw null; } set { } }
-        public bool UseSymboliclinksIfPossible { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public bool WroteAtLeastOneFile { get { throw null; } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CreateCSharpManifestResourceName : Microsoft.Build.Tasks.CreateManifestResourceName
-    {
-        public CreateCSharpManifestResourceName() { }
-        protected override string SourceFileExtension { get { throw null; } }
-        protected override string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) { throw null; }
-        protected override bool IsSourceFile(string fileName) { throw null; }
-    }
-    public partial class CreateItem : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CreateItem() { }
-        public string[] AdditionalMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Exclude { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Include { get { throw null; } set { } }
-        public bool PreserveExistingMetadata { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class CreateManifestResourceName : Microsoft.Build.Tasks.TaskExtension
-    {
-        protected System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem> itemSpecToTaskitem;
-        protected CreateManifestResourceName() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ManifestResourceNames { get { throw null; } }
-        public bool PrependCultureAsDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResourceFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResourceFilesWithManifestResourceNames { get { throw null; } set { } }
-        public string RootNamespace { get { throw null; } set { } }
-        protected abstract string SourceFileExtension { get; }
-        public bool UseDependentUponConvention { get { throw null; } set { } }
-        protected abstract string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream);
-        public override bool Execute() { throw null; }
-        protected abstract bool IsSourceFile(string fileName);
-        public static string MakeValidEverettIdentifier(string name) { throw null; }
-    }
-    public partial class CreateProperty : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CreateProperty() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] Value { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] ValueSetByTask { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CreateVisualBasicManifestResourceName : Microsoft.Build.Tasks.CreateManifestResourceName
-    {
-        public CreateVisualBasicManifestResourceName() { }
-        protected override string SourceFileExtension { get { throw null; } }
-        protected override string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) { throw null; }
-        protected override bool IsSourceFile(string fileName) { throw null; }
-    }
-    public partial class Delete : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Delete() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DeletedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool TreatErrorsAsWarnings { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class DownloadFile : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public DownloadFile() { }
-        public Microsoft.Build.Framework.ITaskItem DestinationFileName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem DownloadedFile { get { throw null; } set { } }
-        public int Retries { get { throw null; } set { } }
-        public int RetryDelayMilliseconds { get { throw null; } set { } }
-        public bool SkipUnchangedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string SourceUrl { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Error : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Error() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string HelpLink { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ErrorFromResources : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ErrorFromResources() { }
-        public string[] Arguments { get { throw null; } set { } }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Resource { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Exec : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public Exec() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Command { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ConsoleOutput { get { throw null; } }
-        public bool ConsoleToMSBuild { get { throw null; } set { } }
-        public string CustomErrorRegularExpression { get { throw null; } set { } }
-        public string CustomWarningRegularExpression { get { throw null; } set { } }
-        public bool IgnoreExitCode { get { throw null; } set { } }
-        public bool IgnoreStandardErrorWarningFormat { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Outputs { get { throw null; } set { } }
-        protected override System.Text.Encoding StandardErrorEncoding { get { throw null; } }
-        protected override Microsoft.Build.Framework.MessageImportance StandardErrorLoggingImportance { get { throw null; } }
-        protected override System.Text.Encoding StandardOutputEncoding { get { throw null; } }
-        protected override Microsoft.Build.Framework.MessageImportance StandardOutputLoggingImportance { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StdErrEncoding { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StdOutEncoding { get { throw null; } set { } }
-        protected override string ToolName { get { throw null; } }
-        public string WorkingDirectory { get { throw null; } set { } }
-        protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
-        protected override string GenerateFullPathToTool() { throw null; }
-        protected override string GetWorkingDirectory() { throw null; }
-        protected override bool HandleTaskExecutionErrors() { throw null; }
-        protected override void LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) { }
-        protected override void LogPathToTool(string toolName, string pathToTool) { }
-        protected override void LogToolCommand(string message) { }
-        protected override bool ValidateParameters() { throw null; }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ExtractedClassName
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public bool IsInsideConditionalBlock { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-    }
-    public partial class FindAppConfigFile : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindAppConfigFile() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem AppConfigFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] PrimaryList { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SecondaryList { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class FindInList : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindInList() { }
-        public bool CaseSensitive { get { throw null; } set { } }
-        public bool FindLastMatch { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem ItemFound { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string ItemSpecToFind { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] List { get { throw null; } set { } }
-        public bool MatchFileNameOnly { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class FindInvalidProjectReferences : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindInvalidProjectReferences() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InvalidReferences { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] ProjectReferences { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformIdentifier { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class FindUnderPath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindUnderPath() { }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutOfPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem Path { get { throw null; } set { } }
-        public bool UpdateToAbsolutePaths { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class FormatUrl : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FormatUrl() { }
-        public string InputUrl { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputUrl { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class FormatVersion : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FormatVersion() { }
-        public string FormatType { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputVersion { get { throw null; } set { } }
-        public int Revision { get { throw null; } set { } }
-        public string Version { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GenerateApplicationManifest : Microsoft.Build.Tasks.GenerateManifestBase
-    {
-        public GenerateApplicationManifest() { }
-        public string ClrVersion { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem ConfigFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Dependencies { get { throw null; } set { } }
-        public string ErrorReportUrl { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] FileAssociations { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool HostInBrowser { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem IconFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] IsolatedComReferences { get { throw null; } set { } }
-        public string ManifestType { get { throw null; } set { } }
-        public string OSVersion { get { throw null; } set { } }
-        public string Product { get { throw null; } set { } }
-        public string Publisher { get { throw null; } set { } }
-        public bool RequiresMinimumFramework35SP1 { get { throw null; } set { } }
-        public string SuiteName { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
-        public string TargetFrameworkProfile { get { throw null; } set { } }
-        public string TargetFrameworkSubset { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { get { throw null; } set { } }
-        public bool UseApplicationTrust { get { throw null; } set { } }
-        protected override System.Type GetObjectType() { throw null; }
-        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected internal override bool ValidateInputs() { throw null; }
-    }
-    public partial class GenerateBindingRedirects : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateBindingRedirects() { }
-        public Microsoft.Build.Framework.ITaskItem AppConfigFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputAppConfigFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] SuggestedRedirects { get { throw null; } set { } }
-        public string TargetName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GenerateBootstrapper : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateBootstrapper() { }
-        public string ApplicationFile { get { throw null; } set { } }
-        public string ApplicationName { get { throw null; } set { } }
-        public bool ApplicationRequiresElevation { get { throw null; } set { } }
-        public string ApplicationUrl { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] BootstrapperComponentFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] BootstrapperItems { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string BootstrapperKeyFile { get { throw null; } set { } }
-        public string ComponentsLocation { get { throw null; } set { } }
-        public string ComponentsUrl { get { throw null; } set { } }
-        public bool CopyComponents { get { throw null; } set { } }
-        public string Culture { get { throw null; } set { } }
-        public string FallbackCulture { get { throw null; } set { } }
-        public string OutputPath { get { throw null; } set { } }
-        public string Path { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
-        public bool Validate { get { throw null; } set { } }
-        public string VisualStudioVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GenerateDeploymentManifest : Microsoft.Build.Tasks.GenerateManifestBase
-    {
-        public GenerateDeploymentManifest() { }
-        public bool CreateDesktopShortcut { get { throw null; } set { } }
-        public string DeploymentUrl { get { throw null; } set { } }
-        public bool DisallowUrlActivation { get { throw null; } set { } }
-        public string ErrorReportUrl { get { throw null; } set { } }
-        public bool Install { get { throw null; } set { } }
-        public bool MapFileExtensions { get { throw null; } set { } }
-        public string MinimumRequiredVersion { get { throw null; } set { } }
-        public string Product { get { throw null; } set { } }
-        public string Publisher { get { throw null; } set { } }
-        public string SuiteName { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
-        public bool TrustUrlParameters { get { throw null; } set { } }
-        public bool UpdateEnabled { get { throw null; } set { } }
-        public int UpdateInterval { get { throw null; } set { } }
-        public string UpdateMode { get { throw null; } set { } }
-        public string UpdateUnit { get { throw null; } set { } }
-        protected override System.Type GetObjectType() { throw null; }
-        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected internal override bool ValidateInputs() { throw null; }
-    }
-    public sealed partial class GenerateLauncher : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateLauncher() { }
-        public string AssemblyName { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public string LauncherPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
-        public string OutputPath { get { throw null; } set { } }
-        public string VisualStudioVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
-    {
-        protected GenerateManifestBase() { }
-        public string AssemblyName { get { throw null; } set { } }
-        public string AssemblyVersion { get { throw null; } set { } }
-        public string Description { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
-        public bool LauncherBasedDeployment { get { throw null; } set { } }
-        public int MaxTargetPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
-        public string Platform { get { throw null; } set { } }
-        public string TargetCulture { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
-        public override bool Execute() { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
-        protected abstract System.Type GetObjectType();
-        protected abstract bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
-        protected abstract bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
-        protected internal virtual bool ValidateInputs() { throw null; }
-        protected internal virtual bool ValidateOutput() { throw null; }
-    }
-    [Microsoft.Build.Framework.RequiredRuntimeAttribute("v2.0")]
-    public sealed partial class GenerateResource : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateResource() { }
-        public Microsoft.Build.Framework.ITaskItem[] AdditionalInputs { get { throw null; } set { } }
-        public string[] EnvironmentVariables { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ExcludedInputPaths { get { throw null; } set { } }
-        public bool ExecuteAsTool { get { throw null; } set { } }
-        public bool ExtractResWFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] FilesWritten { get { throw null; } }
-        public bool MinimalRebuildFromTracking { get { throw null; } set { } }
-        public bool NeverLockTypeAssemblies { get { throw null; } set { } }
-        public string OutputDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputResources { get { throw null; } set { } }
-        public bool PublicClass { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] References { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Sources { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem StateFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StronglyTypedClassName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StronglyTypedFileName { get { throw null; } set { } }
-        public string StronglyTypedLanguage { get { throw null; } set { } }
-        public string StronglyTypedManifestPrefix { get { throw null; } set { } }
-        public string StronglyTypedNamespace { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TLogReadFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] TLogWriteFiles { get { throw null; } }
-        public string ToolArchitecture { get { throw null; } set { } }
-        public string TrackerFrameworkPath { get { throw null; } set { } }
-        public string TrackerLogDirectory { get { throw null; } set { } }
-        public string TrackerSdkPath { get { throw null; } set { } }
-        public bool TrackFileAccess { get { throw null; } set { } }
-        public bool UsePreserializedResources { get { throw null; } set { } }
-        public bool UseSourcePath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GenerateTrustInfo : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateTrustInfo() { }
-        public Microsoft.Build.Framework.ITaskItem[] ApplicationDependencies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem BaseManifest { get { throw null; } set { } }
-        public string ExcludedPermissions { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        public string TargetZone { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetAssemblyIdentity : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetAssemblyIdentity() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetCompatiblePlatform : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetCompatiblePlatform() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AnnotatedProjects { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedProjectsWithPlatform { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string CurrentProjectPlatform { get { throw null; } set { } }
-        public string PlatformLookupTable { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GetFileHash : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetFileHash() { }
-        public string Algorithm { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Hash { get { throw null; } set { } }
-        public string HashEncoding { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Items { get { throw null; } set { } }
-        public string MetadataName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetFrameworkPath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetFrameworkPath() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion11Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion20Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion30Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion35Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion40Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion451Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion452Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion45Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion461Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion462Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion46Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion471Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion472Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion47Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion48Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Path { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetFrameworkSdkPath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetFrameworkSdkPath() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkSdkVersion20Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkSdkVersion35Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkSdkVersion40Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkSdkVersion451Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkSdkVersion45Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkSdkVersion461Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkSdkVersion46Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Path { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetInstalledSDKLocations : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetInstalledSDKLocations() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InstalledSDKs { get { throw null; } set { } }
-        public string[] SDKDirectoryRoots { get { throw null; } set { } }
-        public string[] SDKExtensionDirectoryRoots { get { throw null; } set { } }
-        public string SDKRegistryRoot { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformIdentifier { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformVersion { get { throw null; } set { } }
-        public bool WarnWhenNoSDKsFound { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetReferenceAssemblyPaths : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetReferenceAssemblyPaths() { }
-        public bool BypassFrameworkInstallChecks { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] FullFrameworkReferenceAssemblyPaths { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] ReferenceAssemblyPaths { get { throw null; } }
-        public string RootPath { get { throw null; } set { } }
-        public bool SuppressNotFoundError { get { throw null; } set { } }
-        public string TargetFrameworkFallbackSearchPaths { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetSDKReferenceFiles : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetSDKReferenceFiles() { }
-        public string CacheFileFolderPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
-        public bool LogCacheFileExceptions { get { throw null; } set { } }
-        public bool LogRedistConflictBetweenSDKsAsWarning { get { throw null; } set { } }
-        public bool LogRedistConflictWithinSDKAsWarning { get { throw null; } set { } }
-        public bool LogRedistFilesList { get { throw null; } set { } }
-        public bool LogReferenceConflictBetweenSDKsAsWarning { get { throw null; } set { } }
-        public bool LogReferenceConflictWithinSDKAsWarning { get { throw null; } set { } }
-        public bool LogReferencesList { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RedistFiles { get { throw null; } }
-        public string[] ReferenceExtensions { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] References { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-        public string TargetPlatformIdentifier { get { throw null; } set { } }
-        public string TargetPlatformVersion { get { throw null; } set { } }
-        public string TargetSDKIdentifier { get { throw null; } set { } }
-        public string TargetSDKVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Hash : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Hash() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string HashResult { get { throw null; } set { } }
-        public bool IgnoreCase { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ItemsToHash { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    [System.Runtime.InteropServices.GuidAttribute("00020401-0000-0000-C000-000000000046")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IFixedTypeInfo
-    {
-        void AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv);
-        void CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj);
-        void GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex);
-        void GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal);
-        void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
-        void GetFuncDesc(int index, out System.IntPtr ppFuncDesc);
-        void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
-        void GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags);
-        void GetMops(int memid, out string pBstrMops);
-        void GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames);
-        void GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI);
-        void GetRefTypeOfImplType(int index, out System.IntPtr href);
-        void GetTypeAttr(out System.IntPtr ppTypeAttr);
-        void GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp);
-        void GetVarDesc(int index, out System.IntPtr ppVarDesc);
-        void Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr);
-        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]void ReleaseFuncDesc(System.IntPtr pFuncDesc);
-        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]void ReleaseTypeAttr(System.IntPtr pTypeAttr);
-        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]void ReleaseVarDesc(System.IntPtr pVarDesc);
-    }
-    public partial class LC : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public LC() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem LicenseTarget { get { throw null; } set { } }
-        public bool NoLogo { get { throw null; } set { } }
-        public string OutputDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputLicense { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ReferencedAssemblies { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Sources { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        protected override string ToolName { get { throw null; } }
-        protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected internal override void AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected override string GenerateFullPathToTool() { throw null; }
-        protected override bool ValidateParameters() { throw null; }
-    }
-    public partial class MakeDir : Microsoft.Build.Tasks.TaskExtension
-    {
-        public MakeDir() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DirectoriesCreated { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Message : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Message() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string Importance { get { throw null; } set { } }
-        public bool IsCritical { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Move : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Move() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DestinationFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] MovedFiles { get { throw null; } }
-        public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    [Microsoft.Build.Framework.RunInMTAAttribute]
-    public partial class MSBuild : Microsoft.Build.Tasks.TaskExtension
-    {
-        public MSBuild() { }
-        public bool BuildInParallel { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Projects { get { throw null; } set { } }
-        public string[] Properties { get { throw null; } set { } }
-        public bool RebaseOutputs { get { throw null; } set { } }
-        public string RemoveProperties { get { throw null; } set { } }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
-        public string SkipNonexistentProjects { get { throw null; } set { } }
-        public bool StopOnFirstFailure { get { throw null; } set { } }
-        public string[] TargetAndPropertyListSeparators { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } set { } }
-        public bool UnloadProjectsOnCompletion { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ReadLinesFromFile : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ReadLinesFromFile() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class RegisterAssembly : Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension, System.Runtime.InteropServices.ITypeLibExporterNotifySink
-    {
-        public RegisterAssembly() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem AssemblyListFile { get { throw null; } set { } }
-        public bool CreateCodeBase { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-        public void ReportEvent(System.Runtime.InteropServices.ExporterEventKind kind, int code, string msg) { }
-        public object ResolveRef(System.Reflection.Assembly assemblyToResolve) { throw null; }
-    }
-    public partial class RemoveDir : Microsoft.Build.Tasks.TaskExtension
-    {
-        public RemoveDir() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RemovedDirectories { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class RemoveDuplicates : Microsoft.Build.Tasks.TaskExtension
-    {
-        public RemoveDuplicates() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Filtered { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public bool HadAnyDuplicates { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Inputs { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class RequiresFramework35SP1Assembly : Microsoft.Build.Tasks.TaskExtension
-    {
-        public RequiresFramework35SP1Assembly() { }
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        public bool CreateDesktopShortcut { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public string ErrorReportUrl { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ReferencedAssemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public bool RequiresMinimumFramework35SP1 { get { throw null; } set { } }
-        public bool SigningManifests { get { throw null; } set { } }
-        public string SuiteName { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ResolveAssemblyReference : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveAssemblyReference() { }
-        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
-        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
-        public string AppConfigFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
-        public string AssemblyInformationCacheOutputPath { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
-        public bool AutoUnify { get { throw null; } set { } }
-        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string DependsOnNETStandard { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string DependsOnSystemRuntime { get { throw null; } }
-        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] FilesWritten { get { throw null; } set { } }
-        public bool FindDependencies { get { throw null; } set { } }
-        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
-        public bool FindRelatedFiles { get { throw null; } set { } }
-        public bool FindSatellites { get { throw null; } set { } }
-        public bool FindSerializationAssemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
-        public string[] FullFrameworkFolders { get { throw null; } set { } }
-        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
-        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
-        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
-        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
-        public bool OutputUnresolvedAssemblyConflicts { get { throw null; } set { } }
-        public string ProfileName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedDependencyFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SatelliteFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ScatterFiles { get { throw null; } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string[] SearchPaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SerializationAssemblyFiles { get { throw null; } }
-        public bool Silent { get { throw null; } set { } }
-        public string StateFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SuggestedRedirects { get { throw null; } }
-        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
-        public string TargetedRuntimeVersion { get { throw null; } set { } }
-        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnresolvedAssemblyConflicts { get { throw null; } }
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
-        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ResolveCodeAnalysisRuleSet : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveCodeAnalysisRuleSet() { }
-        public string CodeAnalysisRuleSet { get { throw null; } set { } }
-        public string[] CodeAnalysisRuleSetDirectories { get { throw null; } set { } }
-        public string MSBuildProjectDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedCodeAnalysisRuleSet { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ResolveComReference : Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension
-    {
-        public ResolveComReference() { }
-        public bool DelaySign { get { throw null; } set { } }
-        public string[] EnvironmentVariables { get { throw null; } set { } }
-        public bool ExecuteAsTool { get { throw null; } set { } }
-        public bool IncludeVersionInInteropName { get { throw null; } set { } }
-        public string KeyContainer { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        public bool NoClassMembers { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedAssemblyReferences { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedModules { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        public bool Silent { get { throw null; } set { } }
-        public string StateFile { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibNames { get { throw null; } set { } }
-        public string WrapperOutputDirectory { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ResolveKeySource : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveKeySource() { }
-        public int AutoClosePasswordPromptShow { get { throw null; } set { } }
-        public int AutoClosePasswordPromptTimeout { get { throw null; } set { } }
-        public string CertificateFile { get { throw null; } set { } }
-        public string CertificateThumbprint { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyContainer { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedThumbprint { get { throw null; } set { } }
-        public bool ShowImportDialogDespitePreviousFailures { get { throw null; } set { } }
-        public bool SuppressAutoClosePasswordPrompt { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveManifestFiles() { }
-        public string AssemblyName { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool IsSelfContainedPublish { get { throw null; } set { } }
-        public bool IsSingleFilePublish { get { throw null; } set { } }
-        public bool LauncherBasedDeployment { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputAssemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputDeploymentManifestEntryPoint { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] PublishFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] RuntimePackAssets { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
-        public bool SigningManifests { get { throw null; } set { } }
-        public string TargetCulture { get { throw null; } set { } }
-        public string TargetFrameworkIdentifier { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ResolveNativeReference : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveNativeReference() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string[] AdditionalSearchPaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedComComponents { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedLooseEtcFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedLooseTlbFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedPrerequisiteAssemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainedTypeLibraries { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ContainingReferenceFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] NativeReferences { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ResolveNonMSBuildProjectOutput : Microsoft.Build.Tasks.ResolveProjectBase
-    {
-        public ResolveNonMSBuildProjectOutput() { }
-        public string PreresolvedProjectOutputs { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedOutputPaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnresolvedProjectReferences { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class ResolveProjectBase : Microsoft.Build.Tasks.TaskExtension
-    {
-        protected ResolveProjectBase() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ProjectReferences { get { throw null; } set { } }
-        protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath) { }
-        protected System.Xml.XmlElement GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) { throw null; }
-        protected string GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) { throw null; }
-    }
-    public partial class ResolveSDKReference : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveSDKReference() { }
-        public Microsoft.Build.Framework.ITaskItem[] DisallowedSDKDependencies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InstalledSDKs { get { throw null; } set { } }
-        public bool LogResolutionErrorsAsWarnings { get { throw null; } set { } }
-        public bool Prefer32Bit { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string ProjectName { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] References { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedSDKReferences { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] RuntimeReferenceOnlySDKDependencies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SDKReferences { get { throw null; } set { } }
-        public string TargetedSDKArchitecture { get { throw null; } set { } }
-        public string TargetedSDKConfiguration { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformIdentifier { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformVersion { get { throw null; } set { } }
-        public bool WarnOnMissingPlatformVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class RoslynCodeTaskFactory : Microsoft.Build.Framework.ITaskFactory
-    {
-        public RoslynCodeTaskFactory() { }
-        public string FactoryName { get { throw null; } }
-        public System.Type TaskType { get { throw null; } }
-        public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
-        public Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-        public Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters() { throw null; }
-        public bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-    }
-    public partial class SGen : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public SGen() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string BuildAssemblyName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string BuildAssemblyPath { get { throw null; } set { } }
-        public bool DelaySign { get { throw null; } set { } }
-        public string KeyContainer { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        public string Platform { get { throw null; } set { } }
-        public string[] References { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SerializationAssembly { get { throw null; } set { } }
-        public string SerializationAssemblyName { get { throw null; } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public bool ShouldGenerateSerializer { get { throw null; } set { } }
-        protected override string ToolName { get { throw null; } }
-        public string[] Types { get { throw null; } set { } }
-        public bool UseKeep { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public bool UseProxyTypes { get { throw null; } set { } }
-        protected override string GenerateCommandLineCommands() { throw null; }
-        protected override string GenerateFullPathToTool() { throw null; }
-        protected override bool SkipTaskExecution() { throw null; }
-        protected override bool ValidateParameters() { throw null; }
-    }
-    public sealed partial class SignFile : Microsoft.Build.Utilities.Task
-    {
-        public SignFile() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string CertificateThumbprint { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem SigningTarget { get { throw null; } set { } }
-        public string TargetFrameworkIdentifier { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public string TimestampUrl { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class TaskExtension : Microsoft.Build.Utilities.Task
-    {
-        internal TaskExtension() { }
-        public new Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-    }
-    public partial class TaskLoggingHelperExtension : Microsoft.Build.Utilities.TaskLoggingHelper
-    {
-        public TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) : base (default(Microsoft.Build.Framework.ITask)) { }
-        public System.Resources.ResourceManager TaskSharedResources { get { throw null; } set { } }
-        public override string FormatResourceString(string resourceName, params object[] args) { throw null; }
-    }
-    public sealed partial class Telemetry : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Telemetry() { }
-        public string EventData { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string EventName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class ToolTaskExtension : Microsoft.Build.Utilities.ToolTask
-    {
-        internal ToolTaskExtension() { }
-        protected internal System.Collections.Hashtable Bag { get { throw null; } }
-        protected override bool HasLoggedErrors { get { throw null; } }
-        public new Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-        protected virtual bool UseNewLineSeparatorInResponseFile { get { throw null; } }
-        protected internal virtual void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected internal virtual void AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected override string GenerateCommandLineCommands() { throw null; }
-        protected override string GenerateResponseFileCommands() { throw null; }
-        protected internal bool GetBoolParameterWithDefault(string parameterName, bool defaultValue) { throw null; }
-        protected internal int GetIntParameterWithDefault(string parameterName, int defaultValue) { throw null; }
-    }
-    public partial class Touch : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Touch() { }
-        public bool AlwaysCreate { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool ForceTouch { get { throw null; } set { } }
-        public string Time { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TouchedFiles { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class UnregisterAssembly : Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension
-    {
-        public UnregisterAssembly() { }
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem AssemblyListFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Unzip() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        public string Exclude { get { throw null; } set { } }
-        public string Include { get { throw null; } set { } }
-        public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
-        public bool SkipUnchangedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public partial class UpdateManifest : Microsoft.Build.Utilities.Task
-    {
-        public UpdateManifest() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem ApplicationManifest { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string ApplicationPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class VerifyFileHash : Microsoft.Build.Tasks.TaskExtension
-    {
-        public VerifyFileHash() { }
-        public string Algorithm { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string File { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Hash { get { throw null; } set { } }
-        public string HashEncoding { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Warning : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Warning() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string HelpLink { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class WinMDExp : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public WinMDExp() { }
-        public string AssemblyUnificationPolicy { get { throw null; } set { } }
-        public string DisabledWarnings { get { throw null; } set { } }
-        public string InputDocumentationFile { get { throw null; } set { } }
-        public string InputPDBFile { get { throw null; } set { } }
-        public string OutputDocumentationFile { get { throw null; } set { } }
-        public string OutputPDBFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputWindowsMetadataFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] References { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        protected override System.Text.Encoding StandardErrorEncoding { get { throw null; } }
-        protected override System.Text.Encoding StandardOutputEncoding { get { throw null; } }
-        protected override string ToolName { get { throw null; } }
-        public bool TreatWarningsAsErrors { get { throw null; } set { } }
-        protected override bool UseNewLineSeparatorInResponseFile { get { throw null; } }
-        public bool UTF8Output { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string WinMDModule { get { throw null; } set { } }
-        protected internal override void AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected override string GenerateFullPathToTool() { throw null; }
-        protected override bool SkipTaskExecution() { throw null; }
-        protected override bool ValidateParameters() { throw null; }
-    }
-    public partial class WriteCodeFragment : Microsoft.Build.Tasks.TaskExtension
-    {
-        public WriteCodeFragment() { }
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyAttributes { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Language { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem OutputDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputFile { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class WriteLinesToFile : Microsoft.Build.Tasks.TaskExtension
-    {
-        public WriteLinesToFile() { }
-        public string Encoding { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
-        public bool Overwrite { get { throw null; } set { } }
-        public bool WriteOnlyWhenDifferent { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class XamlTaskFactory : Microsoft.Build.Framework.ITaskFactory
-    {
-        public XamlTaskFactory() { }
-        public string FactoryName { get { throw null; } }
-        public string TaskElementContents { get { throw null; } }
-        public string TaskName { get { throw null; } }
-        public string TaskNamespace { get { throw null; } }
-        public System.Type TaskType { get { throw null; } }
-        public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
-        public Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-        public Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters() { throw null; }
-        public bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-    }
-    public partial class XmlPeek : Microsoft.Build.Tasks.TaskExtension
-    {
-        public XmlPeek() { }
-        public string Namespaces { get { throw null; } set { } }
-        public bool ProhibitDtd { get { throw null; } set { } }
-        public string Query { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Result { get { throw null; } }
-        public string XmlContent { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XmlInputPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class XmlPoke : Microsoft.Build.Tasks.TaskExtension
-    {
-        public XmlPoke() { }
-        public string Namespaces { get { throw null; } set { } }
-        public string Query { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem Value { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XmlInputPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class XslTransformation : Microsoft.Build.Tasks.TaskExtension
-    {
-        public XslTransformation() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputPaths { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public bool UseTrustedSettings { get { throw null; } set { } }
-        public string XmlContent { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] XmlInputPaths { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XslCompiledDllPath { get { throw null; } set { } }
-        public string XslContent { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XslInputPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ZipDirectory : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ZipDirectory() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem DestinationFile { get { throw null; } set { } }
-        public bool Overwrite { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem SourceDirectory { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-}
-namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
-{
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
-    public partial class BootstrapperBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
-    {
-        public BootstrapperBuilder() { }
-        public BootstrapperBuilder(string visualStudioVersion) { }
-        public string Path { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) { throw null; }
-        public string[] GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) { throw null; }
-        public static string XmlToConfigurationFile(System.Xml.XmlNode input) { throw null; }
-    }
-    public partial class BuildMessage : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
-    {
-        internal BuildMessage() { }
-        public int HelpId { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public string Message { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
-    public enum BuildMessageSeverity
-    {
-        Info = 0,
-        Warning = 1,
-        Error = 2,
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
-    public partial class BuildResults : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
-    {
-        internal BuildResults() { }
-        public string[] ComponentFiles { get { throw null; } }
-        public string KeyFile { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
-    public partial class BuildSettings : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
-    {
-        public BuildSettings() { }
-        public string ApplicationFile { get { throw null; } set { } }
-        public string ApplicationName { get { throw null; } set { } }
-        public bool ApplicationRequiresElevation { get { throw null; } set { } }
-        public string ApplicationUrl { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get { throw null; } set { } }
-        public string ComponentsUrl { get { throw null; } set { } }
-        public bool CopyComponents { get { throw null; } set { } }
-        public int FallbackLCID { get { throw null; } set { } }
-        public int LCID { get { throw null; } set { } }
-        public string OutputPath { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get { throw null; } }
-        public string SupportUrl { get { throw null; } set { } }
-        public bool Validate { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
-    public enum ComponentsLocation
-    {
-        HomeSite = 0,
-        Relative = 1,
-        Absolute = 2,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBootstrapperBuilder
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        string Path { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(5)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBuildMessage
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        int HelpId { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string HelpKeyword { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string Message { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBuildResults
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string[] ComponentFiles { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string KeyFile { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        bool Succeeded { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBuildSettings
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string ApplicationFile { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        string ApplicationName { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(13)]
-        bool ApplicationRequiresElevation { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string ApplicationUrl { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(11)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        string ComponentsUrl { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(5)]
-        bool CopyComponents { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(7)]
-        int FallbackLCID { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(6)]
-        int LCID { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(8)]
-        string OutputPath { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(9)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(12)]
-        string SupportUrl { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(10)]
-        bool Validate { get; set; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProduct
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string Name { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string ProductCode { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProductBuilder
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProductBuilderCollection
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProductCollection
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        int Count { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index);
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode);
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
-    public partial class Product : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
-    {
-        public Product() { }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get { throw null; } }
-        public string Name { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get { throw null; } }
-        public string ProductCode { get { throw null; } }
-    }
-    public partial class ProductBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
-    {
-        internal ProductBuilder() { }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
-    public partial class ProductBuilderCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection, System.Collections.IEnumerable
-    {
-        internal ProductBuilderCollection() { }
-        public void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
-    public partial class ProductCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection, System.Collections.IEnumerable
-    {
-        internal ProductCollection() { }
-        public int Count { get { throw null; } }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode) { throw null; }
-    }
-}
-namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
-{
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class ApplicationIdentity
-    {
-        public ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) { }
-        public ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) { }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("ApplicationManifest")]
-    public sealed partial class ApplicationManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
-    {
-        public ApplicationManifest() { }
-        public ApplicationManifest(string targetFrameworkVersion) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ConfigFile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ErrorReportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection FileAssociations { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool HostInBrowser { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string IconFile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsClickOnceManifest { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public int MaxTargetPath { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string OSDescription { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string OSSupportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string OSVersion { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Product { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Publisher { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SuiteName { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SupportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo TrustInfo { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool UseApplicationTrust { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ConfigFile")]
-        public string XmlConfigFile { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlElementAttribute("EntryPointIdentity")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlEntryPointIdentity { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointParameters")]
-        public string XmlEntryPointParameters { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointPath")]
-        public string XmlEntryPointPath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
-        public string XmlErrorReportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("FileAssociations")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[] XmlFileAssociations { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("HostInBrowser")]
-        public string XmlHostInBrowser { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IconFile")]
-        public string XmlIconFile { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsClickOnceManifest")]
-        public string XmlIsClickOnceManifest { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSBuild")]
-        public string XmlOSBuild { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSDescription")]
-        public string XmlOSDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSMajor")]
-        public string XmlOSMajor { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSMinor")]
-        public string XmlOSMinor { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSRevision")]
-        public string XmlOSRevision { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSSupportUrl")]
-        public string XmlOSSupportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
-        public string XmlProduct { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
-        public string XmlPublisher { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
-        public string XmlSuiteName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
-        public string XmlSupportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UseApplicationTrust")]
-        public string XmlUseApplicationTrust { get { throw null; } set { } }
-        public override void Validate() { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("AssemblyIdentity")]
-    public sealed partial class AssemblyIdentity
-    {
-        public AssemblyIdentity() { }
-        public AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { }
-        public AssemblyIdentity(string name) { }
-        public AssemblyIdentity(string name, string version) { }
-        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture) { }
-        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) { }
-        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Culture { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsFrameworkAssembly { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsNeutralPlatform { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsStrongName { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Name { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ProcessorArchitecture { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string PublicKeyToken { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Type { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Version { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Culture")]
-        public string XmlCulture { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
-        public string XmlName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ProcessorArchitecture")]
-        public string XmlProcessorArchitecture { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("PublicKeyToken")]
-        public string XmlPublicKeyToken { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Type")]
-        public string XmlType { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
-        public string XmlVersion { get { throw null; } set { } }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromAssemblyName(string assemblyName) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromFile(string path) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManagedAssembly(string path) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManifest(string path) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromNativeAssembly(string path) { throw null; }
-        public string GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) { throw null; }
-        public bool IsInFramework(string frameworkIdentifier, string frameworkVersion) { throw null; }
-        public override string ToString() { throw null; }
-        [System.FlagsAttribute]
-        public enum FullNameFlags
-        {
-            Default = 0,
-            ProcessorArchitecture = 1,
-            Type = 2,
-            All = 3,
-        }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("AssemblyManifest")]
-    public partial class AssemblyManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-    {
-        public AssemblyManifest() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ExternalProxyStubs { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("ExternalProxyStubs")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlExternalProxyStubs { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class AssemblyReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-    {
-        public AssemblyReference() { }
-        public AssemblyReference(string path) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsPrerequisite { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType ReferenceType { get { throw null; } set { } }
-        protected internal override string SortName { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsNative")]
-        public string XmlIsNative { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsPrerequisite")]
-        public string XmlIsPrerequisite { get { throw null; } set { } }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class AssemblyReferenceCollection : System.Collections.IEnumerable
-    {
-        internal AssemblyReferenceCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference this[int index] { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(string path) { throw null; }
-        public void Clear() { }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(string name) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference FindTargetPath(string targetPath) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) { }
-    }
-    public enum AssemblyReferenceType
-    {
-        Unspecified = 0,
-        ClickOnceManifest = 1,
-        ManagedAssembly = 2,
-        NativeAssembly = 3,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public abstract partial class BaseReference
-    {
-        protected internal BaseReference() { }
-        protected internal BaseReference(string path) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Group { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Hash { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsOptional { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ResolvedPath { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public long Size { get { throw null; } set { } }
-        protected internal abstract string SortName { get; }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SourcePath { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TargetPath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Group")]
-        public string XmlGroup { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Hash")]
-        public string XmlHash { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("HashAlg")]
-        public string XmlHashAlgorithm { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsOptional")]
-        public string XmlIsOptional { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Path")]
-        public string XmlPath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Size")]
-        public string XmlSize { get { throw null; } set { } }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class ComClass
-    {
-        public ComClass() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ClsId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Description { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ProgId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ThreadingModel { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TlbId { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Clsid")]
-        public string XmlClsId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
-        public string XmlDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
-        public string XmlProgId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ThreadingModel")]
-        public string XmlThreadingModel { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
-        public string XmlTlbId { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class CompatibleFramework
-    {
-        public CompatibleFramework() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Profile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SupportedRuntime { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Version { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Profile")]
-        public string XmlProfile { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SupportedRuntime")]
-        public string XmlSupportedRuntime { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
-        public string XmlVersion { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class CompatibleFrameworkCollection : System.Collections.IEnumerable
-    {
-        internal CompatibleFrameworkCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework this[int index] { get { throw null; } }
-        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) { }
-        public void Clear() { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("DeployManifest")]
-    public sealed partial class DeployManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-    {
-        public DeployManifest() { }
-        public DeployManifest(string targetFrameworkMoniker) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection CompatibleFrameworks { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool CreateDesktopShortcut { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string DeploymentUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool DisallowUrlActivation { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ErrorReportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool Install { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool MapFileExtensions { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string MinimumRequiredVersion { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Product { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Publisher { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SuiteName { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SupportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool TrustUrlParameters { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool UpdateEnabled { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public int UpdateInterval { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode UpdateMode { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit UpdateUnit { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("CompatibleFrameworks")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[] XmlCompatibleFrameworks { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("CreateDesktopShortcut")]
-        public string XmlCreateDesktopShortcut { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("DeploymentUrl")]
-        public string XmlDeploymentUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("DisallowUrlActivation")]
-        public string XmlDisallowUrlActivation { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
-        public string XmlErrorReportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Install")]
-        public string XmlInstall { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("MapFileExtensions")]
-        public string XmlMapFileExtensions { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("MinimumRequiredVersion")]
-        public string XmlMinimumRequiredVersion { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
-        public string XmlProduct { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
-        public string XmlPublisher { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
-        public string XmlSuiteName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
-        public string XmlSupportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("TrustUrlParameters")]
-        public string XmlTrustUrlParameters { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateEnabled")]
-        public string XmlUpdateEnabled { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateInterval")]
-        public string XmlUpdateInterval { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateMode")]
-        public string XmlUpdateMode { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateUnit")]
-        public string XmlUpdateUnit { get { throw null; } set { } }
-        public override void Validate() { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileAssociation
-    {
-        public FileAssociation() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string DefaultIcon { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Description { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Extension { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ProgId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("DefaultIcon")]
-        public string XmlDefaultIcon { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
-        public string XmlDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Extension")]
-        public string XmlExtension { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
-        public string XmlProgId { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileAssociationCollection : System.Collections.IEnumerable
-    {
-        internal FileAssociationCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation this[int index] { get { throw null; } }
-        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) { }
-        public void Clear() { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-    {
-        public FileReference() { }
-        public FileReference(string path) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] ComClasses { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsDataFile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ProxyStubs { get { throw null; } }
-        protected internal override string SortName { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] TypeLibs { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("ComClasses")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] XmlComClasses { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("ProxyStubs")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlProxyStubs { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("TypeLibs")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] XmlTypeLibs { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("WriteableType")]
-        public string XmlWriteableType { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileReferenceCollection : System.Collections.IEnumerable
-    {
-        internal FileReferenceCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference this[int index] { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(string path) { throw null; }
-        public void Clear() { }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindTargetPath(string targetPath) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
-    }
-    public partial class LauncherBuilder
-    {
-        public LauncherBuilder(string launcherPath) { }
-        public string LauncherPath { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(string filename, string outputPath) { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public abstract partial class Manifest
-    {
-        protected internal Manifest() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string AssemblyName { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Description { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection FileReferences { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public System.IO.Stream InputStream { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool LauncherBasedDeployment { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool ReadOnly { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SourcePath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("AssemblyReferences")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[] XmlAssemblyReferences { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
-        public string XmlDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("FileReferences")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[] XmlFileReferences { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Schema")]
-        public string XmlSchema { get { throw null; } set { } }
-        public void ResolveFiles() { }
-        public void ResolveFiles(string[] searchPaths) { }
-        public override string ToString() { throw null; }
-        public void UpdateFileInfo() { }
-        public void UpdateFileInfo(string targetFrameworkVersion) { }
-        public virtual void Validate() { }
-        protected void ValidatePlatform() { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public static partial class ManifestReader
-    {
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(System.IO.Stream input, bool preserveStream) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string path, bool preserveStream) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, string path, bool preserveStream) { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public static partial class ManifestWriter
-    {
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { }
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) { }
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) { }
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class OutputMessage
-    {
-        internal OutputMessage() { }
-        public string Name { get { throw null; } }
-        public string Text { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType Type { get { throw null; } }
-        public string[] GetArguments() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class OutputMessageCollection : System.Collections.IEnumerable
-    {
-        internal OutputMessageCollection() { }
-        public int ErrorCount { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage this[int index] { get { throw null; } }
-        public int WarningCount { get { throw null; } }
-        public void Clear() { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public enum OutputMessageType
-    {
-        Info = 0,
-        Warning = 1,
-        Error = 2,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class ProxyStub
-    {
-        public ProxyStub() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string BaseInterface { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string IID { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Name { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string NumMethods { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TlbId { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("BaseInterface")]
-        public string XmlBaseInterface { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Iid")]
-        public string XmlIID { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
-        public string XmlName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("NumMethods")]
-        public string XmlNumMethods { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
-        public string XmlTlbId { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public static partial class SecurityUtilities
-    {
-        public static System.Security.PermissionSet ComputeZonePermissionSet(string targetZone, System.Security.PermissionSet includedPermissionSet, string[] excludedPermissions) { throw null; }
-        public static System.Security.PermissionSet IdentityListToPermissionSet(string[] ids) { throw null; }
-        public static string[] PermissionSetToIdentityList(System.Security.PermissionSet permissionSet) { throw null; }
-        public static void SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) { }
-        public static void SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) { }
-        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path) { }
-        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) { }
-        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) { }
-        public static System.Security.PermissionSet XmlToPermissionSet(System.Xml.XmlElement element) { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class TrustInfo
-    {
-        public TrustInfo() { }
-        public bool HasUnmanagedCodePermission { get { throw null; } }
-        public bool IsFullTrust { get { throw null; } set { } }
-        public System.Security.PermissionSet PermissionSet { get { throw null; } set { } }
-        public bool PreserveFullTrustPermissionSet { get { throw null; } set { } }
-        public string SameSiteAccess { get { throw null; } set { } }
-        public void Clear() { }
-        public void Read(System.IO.Stream input) { }
-        public void Read(string path) { }
-        public void ReadManifest(System.IO.Stream input) { }
-        public void ReadManifest(string path) { }
-        public override string ToString() { throw null; }
-        public void Write(System.IO.Stream output) { }
-        public void Write(string path) { }
-        public void WriteManifest(System.IO.Stream output) { }
-        public void WriteManifest(System.IO.Stream input, System.IO.Stream output) { }
-        public void WriteManifest(string path) { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class TypeLib
-    {
-        public TypeLib() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Flags { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string HelpDirectory { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ResourceId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TlbId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Version { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Flags")]
-        public string XmlFlags { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("HelpDir")]
-        public string XmlHelpDirectory { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ResourceId")]
-        public string XmlResourceId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
-        public string XmlTlbId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
-        public string XmlVersion { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public enum UpdateMode
-    {
-        Background = 0,
-        Foreground = 1,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public enum UpdateUnit
-    {
-        Hours = 0,
-        Days = 1,
-        Weeks = 2,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class WindowClass
-    {
-        public WindowClass() { }
-        public WindowClass(string name, bool versioned) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Name { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool Versioned { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
-        public string XmlName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Versioned")]
-        public string XmlVersioned { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Tasks.Hosting
-{
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("B5A95716-2053-4B70-9FBF-E4148EBA96BC")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IAnalyzerHostObject
-    {
-        bool SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles);
-        bool SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers);
-        bool SetRuleSet(string ruleSetFile);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject : Microsoft.Build.Framework.ITaskHost
-    {
-        void BeginInitialization();
-        bool Compile();
-        bool EndInitialization(out string errorMessage, out int errorCode);
-        bool IsDesignTime();
-        bool IsUpToDate();
-        bool SetAdditionalLibPaths(string[] additionalLibPaths);
-        bool SetAddModules(string[] addModules);
-        bool SetAllowUnsafeBlocks(bool allowUnsafeBlocks);
-        bool SetBaseAddress(string baseAddress);
-        bool SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow);
-        bool SetCodePage(int codePage);
-        bool SetDebugType(string debugType);
-        bool SetDefineConstants(string defineConstants);
-        bool SetDelaySign(bool delaySignExplicitlySet, bool delaySign);
-        bool SetDisabledWarnings(string disabledWarnings);
-        bool SetDocumentationFile(string documentationFile);
-        bool SetEmitDebugInformation(bool emitDebugInformation);
-        bool SetErrorReport(string errorReport);
-        bool SetFileAlignment(int fileAlignment);
-        bool SetGenerateFullPaths(bool generateFullPaths);
-        bool SetKeyContainer(string keyContainer);
-        bool SetKeyFile(string keyFile);
-        bool SetLangVersion(string langVersion);
-        bool SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources);
-        bool SetMainEntryPoint(string targetType, string mainEntryPoint);
-        bool SetModuleAssemblyName(string moduleAssemblyName);
-        bool SetNoConfig(bool noConfig);
-        bool SetNoStandardLib(bool noStandardLib);
-        bool SetOptimize(bool optimize);
-        bool SetOutputAssembly(string outputAssembly);
-        bool SetPdbFile(string pdbFile);
-        bool SetPlatform(string platform);
-        bool SetReferences(Microsoft.Build.Framework.ITaskItem[] references);
-        bool SetResources(Microsoft.Build.Framework.ITaskItem[] resources);
-        bool SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles);
-        bool SetSources(Microsoft.Build.Framework.ITaskItem[] sources);
-        bool SetTargetType(string targetType);
-        bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
-        bool SetWarningLevel(int warningLevel);
-        bool SetWarningsAsErrors(string warningsAsErrors);
-        bool SetWarningsNotAsErrors(string warningsNotAsErrors);
-        bool SetWin32Icon(string win32Icon);
-        bool SetWin32Resource(string win32Resource);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("D6D4E228-259A-4076-B5D0-0627338BCC10")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject
-    {
-        bool SetWin32Manifest(string win32Manifest);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2
-    {
-        bool SetApplicationConfiguration(string applicationConfiguration);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2, Microsoft.Build.Tasks.Hosting.ICscHostObject3
-    {
-        bool SetHighEntropyVA(bool highEntropyVA);
-        bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
-        bool SetSubsystemVersion(string subsystemVersion);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("7D7AC3BE-253A-40e8-A3FF-357D0DA7C47A")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject : Microsoft.Build.Framework.ITaskHost
-    {
-        void BeginInitialization();
-        bool Compile();
-        void EndInitialization();
-        bool IsDesignTime();
-        bool IsUpToDate();
-        bool SetAdditionalLibPaths(string[] additionalLibPaths);
-        bool SetAddModules(string[] addModules);
-        bool SetBaseAddress(string targetType, string baseAddress);
-        bool SetCodePage(int codePage);
-        bool SetDebugType(bool emitDebugInformation, string debugType);
-        bool SetDefineConstants(string defineConstants);
-        bool SetDelaySign(bool delaySign);
-        bool SetDisabledWarnings(string disabledWarnings);
-        bool SetDocumentationFile(string documentationFile);
-        bool SetErrorReport(string errorReport);
-        bool SetFileAlignment(int fileAlignment);
-        bool SetGenerateDocumentation(bool generateDocumentation);
-        bool SetImports(Microsoft.Build.Framework.ITaskItem[] importsList);
-        bool SetKeyContainer(string keyContainer);
-        bool SetKeyFile(string keyFile);
-        bool SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources);
-        bool SetMainEntryPoint(string mainEntryPoint);
-        bool SetNoConfig(bool noConfig);
-        bool SetNoStandardLib(bool noStandardLib);
-        bool SetNoWarnings(bool noWarnings);
-        bool SetOptimize(bool optimize);
-        bool SetOptionCompare(string optionCompare);
-        bool SetOptionExplicit(bool optionExplicit);
-        bool SetOptionStrict(bool optionStrict);
-        bool SetOptionStrictType(string optionStrictType);
-        bool SetOutputAssembly(string outputAssembly);
-        bool SetPlatform(string platform);
-        bool SetReferences(Microsoft.Build.Framework.ITaskItem[] references);
-        bool SetRemoveIntegerChecks(bool removeIntegerChecks);
-        bool SetResources(Microsoft.Build.Framework.ITaskItem[] resources);
-        bool SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles);
-        bool SetRootNamespace(string rootNamespace);
-        bool SetSdkPath(string sdkPath);
-        bool SetSources(Microsoft.Build.Framework.ITaskItem[] sources);
-        bool SetTargetCompactFramework(bool targetCompactFramework);
-        bool SetTargetType(string targetType);
-        bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
-        bool SetWarningsAsErrors(string warningsAsErrors);
-        bool SetWarningsNotAsErrors(string warningsNotAsErrors);
-        bool SetWin32Icon(string win32Icon);
-        bool SetWin32Resource(string win32Resource);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("f59afc84-d102-48b1-a090-1b90c79d3e09")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject
-    {
-        bool SetModuleAssemblyName(string moduleAssemblyName);
-        bool SetOptionInfer(bool optionInfer);
-        bool SetWin32Manifest(string win32Manifest);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("1186fe8f-8aba-48d6-8ce3-32ca42f53728")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2
-    {
-        bool SetLanguageVersion(string languageVersion);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("2AE3233C-8AB3-48A0-9ED9-6E3545B3C566")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3
-    {
-        bool SetVBRuntime(string VBRuntime);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("5ACF41FF-6F2B-4623-8146-740C89212B21")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject5 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3, Microsoft.Build.Tasks.Hosting.IVbcHostObject4
-    {
-        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]int CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent);
-        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]int EndCompile(bool buildSuccess);
-        Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded GetFreeThreadedHostObject();
-        bool SetHighEntropyVA(bool highEntropyVA);
-        bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
-        bool SetSubsystemVersion(string subsystemVersion);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("ECCF972F-8C2D-4F51-9746-9288661DE2CB")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObjectFreeThreaded
-    {
-        bool Compile();
-    }
-}
-namespace Microsoft.Build.Tasks.Xaml
-{
-    public partial class CommandLineArgumentRelation : Microsoft.Build.Tasks.Xaml.PropertyRelation
-    {
-        public CommandLineArgumentRelation(string argument, string value, bool required, string separator) { }
-        public string Separator { get { throw null; } set { } }
-    }
-    public partial class CommandLineGenerator
-    {
-        public CommandLineGenerator(Microsoft.Build.Framework.XamlTypes.Rule rule, System.Collections.Generic.Dictionary<string, object> parameterValues) { }
-        public string AdditionalOptions { get { throw null; } set { } }
-        public string AlwaysAppend { get { throw null; } set { } }
-        public string CommandLineTemplate { get { throw null; } set { } }
-        public string GenerateCommandLine() { throw null; }
-    }
-    public partial class CommandLineToolSwitch
-    {
-        public CommandLineToolSwitch() { }
-        public CommandLineToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType toolType) { }
-        public bool AllowMultipleValues { get { throw null; } set { } }
-        public bool ArgumentRequired { get { throw null; } set { } }
-        public System.Collections.Generic.ICollection<System.Tuple<string, bool>> Arguments { get { throw null; } set { } }
-        public bool BooleanValue { get { throw null; } set { } }
-        public string Description { get { throw null; } set { } }
-        public string DisplayName { get { throw null; } set { } }
-        public string FallbackArgumentParameter { get { throw null; } set { } }
-        public string FalseSuffix { get { throw null; } set { } }
-        public bool IncludeInCommandLine { get { throw null; } set { } }
-        public bool IsValid { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public int Number { get { throw null; } set { } }
-        public System.Collections.Generic.LinkedList<System.Collections.Generic.KeyValuePair<string, string>> Overrides { get { throw null; } }
-        public System.Collections.Generic.LinkedList<string> Parents { get { throw null; } }
-        public bool Required { get { throw null; } set { } }
-        public string ReverseSwitchValue { get { throw null; } set { } }
-        public bool Reversible { get { throw null; } set { } }
-        public string Separator { get { throw null; } set { } }
-        public string[] StringList { get { throw null; } set { } }
-        public string SwitchValue { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TaskItemArray { get { throw null; } set { } }
-        public string TrueSuffix { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType Type { get { throw null; } set { } }
-        public string Value { get { throw null; } set { } }
-    }
-    public enum CommandLineToolSwitchType
-    {
-        Boolean = 0,
-        Integer = 1,
-        String = 2,
-        StringArray = 3,
-        ITaskItemArray = 4,
-    }
-    public partial class PropertyRelation
-    {
-        public PropertyRelation() { }
-        public PropertyRelation(string argument, string value, bool required) { }
-        public string Argument { get { throw null; } set { } }
-        public bool Required { get { throw null; } set { } }
-        public string Value { get { throw null; } set { } }
-    }
-    public abstract partial class XamlDataDrivenToolTask : Microsoft.Build.Utilities.ToolTask
-    {
-        protected XamlDataDrivenToolTask(string[] switchOrderList, System.Resources.ResourceManager taskResources) { }
-        public virtual string[] AcceptableNonZeroExitCodes { get { throw null; } set { } }
-        protected internal System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch> ActiveToolSwitches { get { throw null; } }
-        public System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch> ActiveToolSwitchesValues { get { throw null; } set { } }
-        public string AdditionalOptions { get { throw null; } set { } }
-        public string CommandLineTemplate { get { throw null; } set { } }
-        protected override System.Text.Encoding ResponseFileEncoding { get { throw null; } }
-        public void AddActiveSwitchToolValue(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) { }
-        public string CreateSwitchValue(string propertyName, string baseSwitch, string separator, System.Tuple<string, bool>[] arguments) { throw null; }
-        public override bool Execute() { throw null; }
-        protected override string GenerateCommandLineCommands() { throw null; }
-        protected override string GenerateFullPathToTool() { throw null; }
-        protected override string GenerateResponseFileCommands() { throw null; }
-        protected override bool HandleTaskExecutionErrors() { throw null; }
-        public bool IsPropertySet(string propertyName) { throw null; }
-        public string ReadSwitchMap(string propertyName, string[][] switchMap, string value) { throw null; }
-        public int ReadSwitchMap2(string propertyName, System.Tuple<string, string, System.Tuple<string, bool>[]>[] switchMap, string value) { throw null; }
-        public void ReplaceToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) { }
-        public bool ValidateInteger(string switchName, int min, int max, int value) { throw null; }
-        protected override bool ValidateParameters() { throw null; }
-    }
-}
-namespace System.Deployment.Internal.CodeSigning
-{
-    public sealed partial class RSAPKCS1SHA256SignatureDescription : System.Security.Cryptography.SignatureDescription
-    {
-        public RSAPKCS1SHA256SignatureDescription() { }
-        public override System.Security.Cryptography.AsymmetricSignatureDeformatter CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
-        public override System.Security.Cryptography.AsymmetricSignatureFormatter CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
-    }
-}
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
deleted file mode 100644
index 032e84fecf9..00000000000
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ /dev/null
@@ -1,2279 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.Tasks
-{
-    public partial class AssignCulture : Microsoft.Build.Tasks.TaskExtension
-    {
-        public AssignCulture() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithCulture { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFilesWithNoCulture { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CultureNeutralAssignedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class AssignLinkMetadata : Microsoft.Build.Tasks.TaskExtension
-    {
-        public AssignLinkMetadata() { }
-        public Microsoft.Build.Framework.ITaskItem[] Items { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputItems { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class AssignProjectConfiguration : Microsoft.Build.Tasks.ResolveProjectBase
-    {
-        public AssignProjectConfiguration() { }
-        public bool AddSyntheticProjectReferencesForSolutionDependencies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedProjects { get { throw null; } set { } }
-        public string CurrentProject { get { throw null; } set { } }
-        public string CurrentProjectConfiguration { get { throw null; } set { } }
-        public string CurrentProjectPlatform { get { throw null; } set { } }
-        public string DefaultToVcxPlatformMapping { get { throw null; } set { } }
-        public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get { throw null; } set { } }
-        public string OutputType { get { throw null; } set { } }
-        public bool ResolveConfigurationPlatformUsingMappings { get { throw null; } set { } }
-        public bool ShouldUnsetParentConfigurationAndPlatform { get { throw null; } set { } }
-        public string SolutionConfigurationContents { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnassignedProjects { get { throw null; } set { } }
-        public string VcxToDefaultPlatformMapping { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class AssignTargetPath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public AssignTargetPath() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string RootFolder { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    [Microsoft.Build.Framework.RunInMTAAttribute]
-    public partial class CallTarget : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CallTarget() { }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    [System.ObsoleteAttribute("The CodeTaskFactory is not supported on .NET Core.  This class is included so that users receive run-time errors and should not be used for any other purpose.", true)]
-    public sealed partial class CodeTaskFactory : Microsoft.Build.Framework.ITaskFactory
-    {
-        public CodeTaskFactory() { }
-        public string FactoryName { get { throw null; } }
-        public System.Type TaskType { get { throw null; } }
-        public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
-        public Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-        public Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters() { throw null; }
-        public bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-    }
-    public partial class CombinePath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CombinePath() { }
-        public string BasePath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CombinedPaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CombineTargetFrameworkInfoProperties : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CombineTargetFrameworkInfoProperties() { }
-        public Microsoft.Build.Framework.ITaskItem[] PropertiesAndValues { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Result { get { throw null; } set { } }
-        public string RootElementName { get { throw null; } set { } }
-        public bool UseAttributeForTargetFrameworkInfoPropertyNames { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CombineXmlElements() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Result { get { throw null; } set { } }
-        public string RootElementName { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] XmlElements { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CommandLineBuilderExtension : Microsoft.Build.Utilities.CommandLineBuilder
-    {
-        public CommandLineBuilderExtension() { }
-        public CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) { }
-        protected string GetQuotedText(string unquotedText) { throw null; }
-    }
-    public partial class ConvertToAbsolutePath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ConvertToAbsolutePath() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AbsolutePaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Copy : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Copy() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CopiedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DestinationFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        public bool ErrorIfLinkFails { get { throw null; } set { } }
-        public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
-        public int Retries { get { throw null; } set { } }
-        public int RetryDelayMilliseconds { get { throw null; } set { } }
-        public bool SkipUnchangedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
-        public bool UseHardlinksIfPossible { get { throw null; } set { } }
-        public bool UseSymboliclinksIfPossible { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public bool WroteAtLeastOneFile { get { throw null; } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CreateCSharpManifestResourceName : Microsoft.Build.Tasks.CreateManifestResourceName
-    {
-        public CreateCSharpManifestResourceName() { }
-        protected override string SourceFileExtension { get { throw null; } }
-        protected override string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) { throw null; }
-        protected override bool IsSourceFile(string fileName) { throw null; }
-    }
-    public partial class CreateItem : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CreateItem() { }
-        public string[] AdditionalMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Exclude { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Include { get { throw null; } set { } }
-        public bool PreserveExistingMetadata { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class CreateManifestResourceName : Microsoft.Build.Tasks.TaskExtension
-    {
-        protected System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem> itemSpecToTaskitem;
-        protected CreateManifestResourceName() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ManifestResourceNames { get { throw null; } }
-        public bool PrependCultureAsDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResourceFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResourceFilesWithManifestResourceNames { get { throw null; } set { } }
-        public string RootNamespace { get { throw null; } set { } }
-        protected abstract string SourceFileExtension { get; }
-        public bool UseDependentUponConvention { get { throw null; } set { } }
-        protected abstract string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream);
-        public override bool Execute() { throw null; }
-        protected abstract bool IsSourceFile(string fileName);
-        public static string MakeValidEverettIdentifier(string name) { throw null; }
-    }
-    public partial class CreateProperty : Microsoft.Build.Tasks.TaskExtension
-    {
-        public CreateProperty() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] Value { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] ValueSetByTask { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class CreateVisualBasicManifestResourceName : Microsoft.Build.Tasks.CreateManifestResourceName
-    {
-        public CreateVisualBasicManifestResourceName() { }
-        protected override string SourceFileExtension { get { throw null; } }
-        protected override string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) { throw null; }
-        protected override bool IsSourceFile(string fileName) { throw null; }
-    }
-    public partial class Delete : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Delete() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DeletedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool TreatErrorsAsWarnings { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class DownloadFile : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public DownloadFile() { }
-        public Microsoft.Build.Framework.ITaskItem DestinationFileName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem DownloadedFile { get { throw null; } set { } }
-        public int Retries { get { throw null; } set { } }
-        public int RetryDelayMilliseconds { get { throw null; } set { } }
-        public bool SkipUnchangedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string SourceUrl { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Error : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Error() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string HelpLink { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ErrorFromResources : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ErrorFromResources() { }
-        public string[] Arguments { get { throw null; } set { } }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Resource { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Exec : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public Exec() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Command { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ConsoleOutput { get { throw null; } }
-        public bool ConsoleToMSBuild { get { throw null; } set { } }
-        public string CustomErrorRegularExpression { get { throw null; } set { } }
-        public string CustomWarningRegularExpression { get { throw null; } set { } }
-        public bool IgnoreExitCode { get { throw null; } set { } }
-        public bool IgnoreStandardErrorWarningFormat { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Outputs { get { throw null; } set { } }
-        protected override System.Text.Encoding StandardErrorEncoding { get { throw null; } }
-        protected override Microsoft.Build.Framework.MessageImportance StandardErrorLoggingImportance { get { throw null; } }
-        protected override System.Text.Encoding StandardOutputEncoding { get { throw null; } }
-        protected override Microsoft.Build.Framework.MessageImportance StandardOutputLoggingImportance { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StdErrEncoding { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StdOutEncoding { get { throw null; } set { } }
-        protected override string ToolName { get { throw null; } }
-        public string WorkingDirectory { get { throw null; } set { } }
-        protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
-        protected override string GenerateFullPathToTool() { throw null; }
-        protected override string GetWorkingDirectory() { throw null; }
-        protected override bool HandleTaskExecutionErrors() { throw null; }
-        protected override void LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) { }
-        protected override void LogPathToTool(string toolName, string pathToTool) { }
-        protected override void LogToolCommand(string message) { }
-        protected override bool ValidateParameters() { throw null; }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ExtractedClassName
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public bool IsInsideConditionalBlock { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-    }
-    public partial class FindAppConfigFile : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindAppConfigFile() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem AppConfigFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] PrimaryList { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SecondaryList { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class FindInList : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindInList() { }
-        public bool CaseSensitive { get { throw null; } set { } }
-        public bool FindLastMatch { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem ItemFound { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string ItemSpecToFind { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] List { get { throw null; } set { } }
-        public bool MatchFileNameOnly { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class FindInvalidProjectReferences : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindInvalidProjectReferences() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InvalidReferences { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] ProjectReferences { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformIdentifier { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string TargetPlatformVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class FindUnderPath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FindUnderPath() { }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] InPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutOfPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem Path { get { throw null; } set { } }
-        public bool UpdateToAbsolutePaths { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class FormatUrl : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FormatUrl() { }
-        public string InputUrl { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputUrl { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class FormatVersion : Microsoft.Build.Tasks.TaskExtension
-    {
-        public FormatVersion() { }
-        public string FormatType { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string OutputVersion { get { throw null; } set { } }
-        public int Revision { get { throw null; } set { } }
-        public string Version { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GenerateApplicationManifest : Microsoft.Build.Tasks.GenerateManifestBase
-    {
-        public GenerateApplicationManifest() { }
-        public string ClrVersion { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem ConfigFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Dependencies { get { throw null; } set { } }
-        public string ErrorReportUrl { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] FileAssociations { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool HostInBrowser { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem IconFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] IsolatedComReferences { get { throw null; } set { } }
-        public string ManifestType { get { throw null; } set { } }
-        public string OSVersion { get { throw null; } set { } }
-        public string Product { get { throw null; } set { } }
-        public string Publisher { get { throw null; } set { } }
-        public bool RequiresMinimumFramework35SP1 { get { throw null; } set { } }
-        public string SuiteName { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
-        public string TargetFrameworkProfile { get { throw null; } set { } }
-        public string TargetFrameworkSubset { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { get { throw null; } set { } }
-        public bool UseApplicationTrust { get { throw null; } set { } }
-        protected override System.Type GetObjectType() { throw null; }
-        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected internal override bool ValidateInputs() { throw null; }
-    }
-    public partial class GenerateBindingRedirects : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateBindingRedirects() { }
-        public Microsoft.Build.Framework.ITaskItem AppConfigFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputAppConfigFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] SuggestedRedirects { get { throw null; } set { } }
-        public string TargetName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GenerateDeploymentManifest : Microsoft.Build.Tasks.GenerateManifestBase
-    {
-        public GenerateDeploymentManifest() { }
-        public bool CreateDesktopShortcut { get { throw null; } set { } }
-        public string DeploymentUrl { get { throw null; } set { } }
-        public bool DisallowUrlActivation { get { throw null; } set { } }
-        public string ErrorReportUrl { get { throw null; } set { } }
-        public bool Install { get { throw null; } set { } }
-        public bool MapFileExtensions { get { throw null; } set { } }
-        public string MinimumRequiredVersion { get { throw null; } set { } }
-        public string Product { get { throw null; } set { } }
-        public string Publisher { get { throw null; } set { } }
-        public string SuiteName { get { throw null; } set { } }
-        public string SupportUrl { get { throw null; } set { } }
-        public bool TrustUrlParameters { get { throw null; } set { } }
-        public bool UpdateEnabled { get { throw null; } set { } }
-        public int UpdateInterval { get { throw null; } set { } }
-        public string UpdateMode { get { throw null; } set { } }
-        public string UpdateUnit { get { throw null; } set { } }
-        protected override System.Type GetObjectType() { throw null; }
-        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
-        protected internal override bool ValidateInputs() { throw null; }
-    }
-    public sealed partial class GenerateLauncher : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateLauncher() { }
-        public string AssemblyName { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public string LauncherPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
-        public string OutputPath { get { throw null; } set { } }
-        public string VisualStudioVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
-    {
-        protected GenerateManifestBase() { }
-        public string AssemblyName { get { throw null; } set { } }
-        public string AssemblyVersion { get { throw null; } set { } }
-        public string Description { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
-        public bool LauncherBasedDeployment { get { throw null; } set { } }
-        public int MaxTargetPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
-        public string Platform { get { throw null; } set { } }
-        public string TargetCulture { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
-        public override bool Execute() { throw null; }
-        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
-        protected abstract System.Type GetObjectType();
-        protected abstract bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
-        protected abstract bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
-        protected internal virtual bool ValidateInputs() { throw null; }
-        protected internal virtual bool ValidateOutput() { throw null; }
-    }
-    [Microsoft.Build.Framework.RequiredRuntimeAttribute("v2.0")]
-    public sealed partial class GenerateResource : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GenerateResource() { }
-        public Microsoft.Build.Framework.ITaskItem[] AdditionalInputs { get { throw null; } set { } }
-        public string[] EnvironmentVariables { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ExcludedInputPaths { get { throw null; } set { } }
-        public bool ExecuteAsTool { get { throw null; } set { } }
-        public bool ExtractResWFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] FilesWritten { get { throw null; } }
-        public bool MinimalRebuildFromTracking { get { throw null; } set { } }
-        public bool NeverLockTypeAssemblies { get { throw null; } set { } }
-        public string OutputDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputResources { get { throw null; } set { } }
-        public bool PublicClass { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] References { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Sources { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem StateFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StronglyTypedClassName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string StronglyTypedFileName { get { throw null; } set { } }
-        public string StronglyTypedLanguage { get { throw null; } set { } }
-        public string StronglyTypedManifestPrefix { get { throw null; } set { } }
-        public string StronglyTypedNamespace { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TLogReadFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] TLogWriteFiles { get { throw null; } }
-        public string ToolArchitecture { get { throw null; } set { } }
-        public string TrackerFrameworkPath { get { throw null; } set { } }
-        public string TrackerLogDirectory { get { throw null; } set { } }
-        public string TrackerSdkPath { get { throw null; } set { } }
-        public bool TrackFileAccess { get { throw null; } set { } }
-        public bool UsePreserializedResources { get { throw null; } set { } }
-        public bool UseSourcePath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetAssemblyIdentity : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetAssemblyIdentity() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetCompatiblePlatform : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetCompatiblePlatform() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AnnotatedProjects { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] AssignedProjectsWithPlatform { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string CurrentProjectPlatform { get { throw null; } set { } }
-        public string PlatformLookupTable { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class GetFileHash : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetFileHash() { }
-        public string Algorithm { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Hash { get { throw null; } set { } }
-        public string HashEncoding { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Items { get { throw null; } set { } }
-        public string MetadataName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetFrameworkPath : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetFrameworkPath() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion11Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion20Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion30Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion35Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion40Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion451Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion452Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion45Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion461Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion462Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion46Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion471Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion472Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion47Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string FrameworkVersion48Path { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string Path { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class GetReferenceAssemblyPaths : Microsoft.Build.Tasks.TaskExtension
-    {
-        public GetReferenceAssemblyPaths() { }
-        public bool BypassFrameworkInstallChecks { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] FullFrameworkReferenceAssemblyPaths { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string[] ReferenceAssemblyPaths { get { throw null; } }
-        public string RootPath { get { throw null; } set { } }
-        public bool SuppressNotFoundError { get { throw null; } set { } }
-        public string TargetFrameworkFallbackSearchPaths { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Hash : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Hash() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string HashResult { get { throw null; } set { } }
-        public bool IgnoreCase { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ItemsToHash { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class MakeDir : Microsoft.Build.Tasks.TaskExtension
-    {
-        public MakeDir() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DirectoriesCreated { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Message : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Message() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string Importance { get { throw null; } set { } }
-        public bool IsCritical { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class Move : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Move() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] DestinationFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] MovedFiles { get { throw null; } }
-        public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    [Microsoft.Build.Framework.RunInMTAAttribute]
-    public partial class MSBuild : Microsoft.Build.Tasks.TaskExtension
-    {
-        public MSBuild() { }
-        public bool BuildInParallel { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Projects { get { throw null; } set { } }
-        public string[] Properties { get { throw null; } set { } }
-        public bool RebaseOutputs { get { throw null; } set { } }
-        public string RemoveProperties { get { throw null; } set { } }
-        public bool RunEachTargetSeparately { get { throw null; } set { } }
-        public string SkipNonexistentProjects { get { throw null; } set { } }
-        public bool StopOnFirstFailure { get { throw null; } set { } }
-        public string[] TargetAndPropertyListSeparators { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TargetOutputs { get { throw null; } }
-        public string[] Targets { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } set { } }
-        public bool UnloadProjectsOnCompletion { get { throw null; } set { } }
-        public bool UseResultsCache { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ReadLinesFromFile : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ReadLinesFromFile() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class RemoveDir : Microsoft.Build.Tasks.TaskExtension
-    {
-        public RemoveDir() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Directories { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RemovedDirectories { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class RemoveDuplicates : Microsoft.Build.Tasks.TaskExtension
-    {
-        public RemoveDuplicates() { }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Filtered { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public bool HadAnyDuplicates { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Inputs { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ResolveAssemblyReference : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveAssemblyReference() { }
-        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
-        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
-        public string AppConfigFile { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
-        public string AssemblyInformationCacheOutputPath { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
-        public bool AutoUnify { get { throw null; } set { } }
-        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string DependsOnNETStandard { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string DependsOnSystemRuntime { get { throw null; } }
-        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] FilesWritten { get { throw null; } set { } }
-        public bool FindDependencies { get { throw null; } set { } }
-        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
-        public bool FindRelatedFiles { get { throw null; } set { } }
-        public bool FindSatellites { get { throw null; } set { } }
-        public bool FindSerializationAssemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
-        public string[] FullFrameworkFolders { get { throw null; } set { } }
-        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
-        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
-        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
-        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
-        public bool OutputUnresolvedAssemblyConflicts { get { throw null; } set { } }
-        public string ProfileName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedDependencyFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SatelliteFiles { get { throw null; } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ScatterFiles { get { throw null; } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string[] SearchPaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SerializationAssemblyFiles { get { throw null; } }
-        public bool Silent { get { throw null; } set { } }
-        public string StateFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SuggestedRedirects { get { throw null; } }
-        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
-        public string TargetedRuntimeVersion { get { throw null; } set { } }
-        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnresolvedAssemblyConflicts { get { throw null; } }
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
-        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ResolveCodeAnalysisRuleSet : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveCodeAnalysisRuleSet() { }
-        public string CodeAnalysisRuleSet { get { throw null; } set { } }
-        public string[] CodeAnalysisRuleSetDirectories { get { throw null; } set { } }
-        public string MSBuildProjectDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedCodeAnalysisRuleSet { get { throw null; } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveComReference() { }
-        public bool DelaySign { get { throw null; } set { } }
-        public string[] EnvironmentVariables { get { throw null; } set { } }
-        public bool ExecuteAsTool { get { throw null; } set { } }
-        public bool IncludeVersionInInteropName { get { throw null; } set { } }
-        public string KeyContainer { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        public bool NoClassMembers { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedAssemblyReferences { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedModules { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        public bool Silent { get { throw null; } set { } }
-        public string StateFile { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TypeLibNames { get { throw null; } set { } }
-        public string WrapperOutputDirectory { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ResolveKeySource : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveKeySource() { }
-        public int AutoClosePasswordPromptShow { get { throw null; } set { } }
-        public int AutoClosePasswordPromptTimeout { get { throw null; } set { } }
-        public string CertificateFile { get { throw null; } set { } }
-        public string CertificateThumbprint { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyContainer { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedKeyFile { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public string ResolvedThumbprint { get { throw null; } set { } }
-        public bool ShowImportDialogDespitePreviousFailures { get { throw null; } set { } }
-        public bool SuppressAutoClosePasswordPrompt { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ResolveManifestFiles() { }
-        public string AssemblyName { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool IsSelfContainedPublish { get { throw null; } set { } }
-        public bool IsSingleFilePublish { get { throw null; } set { } }
-        public bool LauncherBasedDeployment { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputAssemblies { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputDeploymentManifestEntryPoint { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] PublishFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] RuntimePackAssets { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
-        public bool SigningManifests { get { throw null; } set { } }
-        public string TargetCulture { get { throw null; } set { } }
-        public string TargetFrameworkIdentifier { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class ResolveNonMSBuildProjectOutput : Microsoft.Build.Tasks.ResolveProjectBase
-    {
-        public ResolveNonMSBuildProjectOutput() { }
-        public string PreresolvedProjectOutputs { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ResolvedOutputPaths { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] UnresolvedProjectReferences { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class ResolveProjectBase : Microsoft.Build.Tasks.TaskExtension
-    {
-        protected ResolveProjectBase() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] ProjectReferences { get { throw null; } set { } }
-        protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath) { }
-        protected System.Xml.XmlElement GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) { throw null; }
-        protected string GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) { throw null; }
-    }
-    public sealed partial class RoslynCodeTaskFactory : Microsoft.Build.Framework.ITaskFactory
-    {
-        public RoslynCodeTaskFactory() { }
-        public string FactoryName { get { throw null; } }
-        public System.Type TaskType { get { throw null; } }
-        public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
-        public Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-        public Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters() { throw null; }
-        public bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-    }
-    public partial class SGen : Microsoft.Build.Tasks.ToolTaskExtension
-    {
-        public SGen() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string BuildAssemblyName { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string BuildAssemblyPath { get { throw null; } set { } }
-        public bool DelaySign { get { throw null; } set { } }
-        public string KeyContainer { get { throw null; } set { } }
-        public string KeyFile { get { throw null; } set { } }
-        public string Platform { get { throw null; } set { } }
-        public string[] References { get { throw null; } set { } }
-        public string SdkToolsPath { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SerializationAssembly { get { throw null; } set { } }
-        public string SerializationAssemblyName { get { throw null; } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public bool ShouldGenerateSerializer { get { throw null; } set { } }
-        protected override string ToolName { get { throw null; } }
-        public string[] Types { get { throw null; } set { } }
-        public bool UseKeep { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public bool UseProxyTypes { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-        protected override string GenerateFullPathToTool() { throw null; }
-    }
-    public sealed partial class SignFile : Microsoft.Build.Utilities.Task
-    {
-        public SignFile() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string CertificateThumbprint { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem SigningTarget { get { throw null; } set { } }
-        public string TargetFrameworkIdentifier { get { throw null; } set { } }
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        public string TimestampUrl { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class TaskExtension : Microsoft.Build.Utilities.Task
-    {
-        internal TaskExtension() { }
-        public new Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-    }
-    public partial class TaskLoggingHelperExtension : Microsoft.Build.Utilities.TaskLoggingHelper
-    {
-        public TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) : base (default(Microsoft.Build.Framework.ITask)) { }
-        public System.Resources.ResourceManager TaskSharedResources { get { throw null; } set { } }
-        public override string FormatResourceString(string resourceName, params object[] args) { throw null; }
-    }
-    public sealed partial class Telemetry : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Telemetry() { }
-        public string EventData { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string EventName { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public abstract partial class ToolTaskExtension : Microsoft.Build.Utilities.ToolTask
-    {
-        internal ToolTaskExtension() { }
-        protected internal System.Collections.Hashtable Bag { get { throw null; } }
-        protected override bool HasLoggedErrors { get { throw null; } }
-        public new Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-        protected virtual bool UseNewLineSeparatorInResponseFile { get { throw null; } }
-        protected internal virtual void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected internal virtual void AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
-        protected override string GenerateCommandLineCommands() { throw null; }
-        protected override string GenerateResponseFileCommands() { throw null; }
-        protected internal bool GetBoolParameterWithDefault(string parameterName, bool defaultValue) { throw null; }
-        protected internal int GetIntParameterWithDefault(string parameterName, int defaultValue) { throw null; }
-    }
-    public partial class Touch : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Touch() { }
-        public bool AlwaysCreate { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
-        public bool ForceTouch { get { throw null; } set { } }
-        public string Time { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] TouchedFiles { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        public Unzip() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
-        public string Exclude { get { throw null; } set { } }
-        public string Include { get { throw null; } set { } }
-        public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
-        public bool SkipUnchangedFiles { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
-        public void Cancel() { }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class VerifyFileHash : Microsoft.Build.Tasks.TaskExtension
-    {
-        public VerifyFileHash() { }
-        public string Algorithm { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string File { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Hash { get { throw null; } set { } }
-        public string HashEncoding { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class Warning : Microsoft.Build.Tasks.TaskExtension
-    {
-        public Warning() { }
-        public string Code { get { throw null; } set { } }
-        public string File { get { throw null; } set { } }
-        public string HelpKeyword { get { throw null; } set { } }
-        public string HelpLink { get { throw null; } set { } }
-        public string Text { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class WriteCodeFragment : Microsoft.Build.Tasks.TaskExtension
-    {
-        public WriteCodeFragment() { }
-        public Microsoft.Build.Framework.ITaskItem[] AssemblyAttributes { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public string Language { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem OutputDirectory { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem OutputFile { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class WriteLinesToFile : Microsoft.Build.Tasks.TaskExtension
-    {
-        public WriteLinesToFile() { }
-        public string Encoding { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem File { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] Lines { get { throw null; } set { } }
-        public bool Overwrite { get { throw null; } set { } }
-        public bool WriteOnlyWhenDifferent { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    [System.ObsoleteAttribute("The XamlTaskFactory is not supported on .NET Core.  This class is included so that users receive run-time errors and should not be used for any other purpose.", true)]
-    public sealed partial class XamlTaskFactory : Microsoft.Build.Framework.ITaskFactory
-    {
-        public XamlTaskFactory() { }
-        public string FactoryName { get { throw null; } }
-        public System.Type TaskType { get { throw null; } }
-        public void CleanupTask(Microsoft.Build.Framework.ITask task) { }
-        public Microsoft.Build.Framework.ITask CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-        public Microsoft.Build.Framework.TaskPropertyInfo[] GetTaskParameters() { throw null; }
-        public bool Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) { throw null; }
-    }
-    public partial class XmlPeek : Microsoft.Build.Tasks.TaskExtension
-    {
-        public XmlPeek() { }
-        public string Namespaces { get { throw null; } set { } }
-        public bool ProhibitDtd { get { throw null; } set { } }
-        public string Query { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] Result { get { throw null; } }
-        public string XmlContent { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XmlInputPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class XmlPoke : Microsoft.Build.Tasks.TaskExtension
-    {
-        public XmlPoke() { }
-        public string Namespaces { get { throw null; } set { } }
-        public string Query { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem Value { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XmlInputPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public partial class XslTransformation : Microsoft.Build.Tasks.TaskExtension
-    {
-        public XslTransformation() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem[] OutputPaths { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public bool UseTrustedSettings { get { throw null; } set { } }
-        public string XmlContent { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] XmlInputPaths { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XslCompiledDllPath { get { throw null; } set { } }
-        public string XslContent { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem XslInputPath { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-    public sealed partial class ZipDirectory : Microsoft.Build.Tasks.TaskExtension
-    {
-        public ZipDirectory() { }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem DestinationFile { get { throw null; } set { } }
-        public bool Overwrite { get { throw null; } set { } }
-        [Microsoft.Build.Framework.RequiredAttribute]
-        public Microsoft.Build.Framework.ITaskItem SourceDirectory { get { throw null; } set { } }
-        public override bool Execute() { throw null; }
-    }
-}
-namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
-{
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
-    public partial class BootstrapperBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
-    {
-        public BootstrapperBuilder() { }
-        public BootstrapperBuilder(string visualStudioVersion) { }
-        public string Path { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) { throw null; }
-        public string[] GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) { throw null; }
-        public static string XmlToConfigurationFile(System.Xml.XmlNode input) { throw null; }
-    }
-    public partial class BuildMessage : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
-    {
-        internal BuildMessage() { }
-        public int HelpId { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public string Message { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
-    public enum BuildMessageSeverity
-    {
-        Info = 0,
-        Warning = 1,
-        Error = 2,
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
-    public partial class BuildResults : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
-    {
-        internal BuildResults() { }
-        public string[] ComponentFiles { get { throw null; } }
-        public string KeyFile { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get { throw null; } }
-        public bool Succeeded { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
-    public partial class BuildSettings : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
-    {
-        public BuildSettings() { }
-        public string ApplicationFile { get { throw null; } set { } }
-        public string ApplicationName { get { throw null; } set { } }
-        public bool ApplicationRequiresElevation { get { throw null; } set { } }
-        public string ApplicationUrl { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get { throw null; } set { } }
-        public string ComponentsUrl { get { throw null; } set { } }
-        public bool CopyComponents { get { throw null; } set { } }
-        public int FallbackLCID { get { throw null; } set { } }
-        public int LCID { get { throw null; } set { } }
-        public string OutputPath { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get { throw null; } }
-        public string SupportUrl { get { throw null; } set { } }
-        public bool Validate { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
-    public enum ComponentsLocation
-    {
-        HomeSite = 0,
-        Relative = 1,
-        Absolute = 2,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBootstrapperBuilder
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        string Path { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(5)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBuildMessage
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        int HelpId { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string HelpKeyword { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string Message { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBuildResults
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string[] ComponentFiles { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string KeyFile { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        bool Succeeded { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IBuildSettings
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string ApplicationFile { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        string ApplicationName { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(13)]
-        bool ApplicationRequiresElevation { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string ApplicationUrl { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(11)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        string ComponentsUrl { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(5)]
-        bool CopyComponents { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(7)]
-        int FallbackLCID { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(6)]
-        int LCID { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(8)]
-        string OutputPath { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(9)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(12)]
-        string SupportUrl { get; set; }
-        [System.Runtime.InteropServices.DispIdAttribute(10)]
-        bool Validate { get; set; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProduct
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(4)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        string Name { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        string ProductCode { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProductBuilder
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProductBuilderCollection
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
-    public partial interface IProductCollection
-    {
-        [System.Runtime.InteropServices.DispIdAttribute(1)]
-        int Count { get; }
-        [System.Runtime.InteropServices.DispIdAttribute(2)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index);
-        [System.Runtime.InteropServices.DispIdAttribute(3)]
-        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode);
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
-    public partial class Product : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
-    {
-        public Product() { }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get { throw null; } }
-        public string Name { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get { throw null; } }
-        public string ProductCode { get { throw null; } }
-    }
-    public partial class ProductBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
-    {
-        internal ProductBuilder() { }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
-    public partial class ProductBuilderCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection, System.Collections.IEnumerable
-    {
-        internal ProductBuilderCollection() { }
-        public void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
-    public partial class ProductCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection, System.Collections.IEnumerable
-    {
-        internal ProductCollection() { }
-        public int Count { get { throw null; } }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode) { throw null; }
-    }
-}
-namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
-{
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class ApplicationIdentity
-    {
-        public ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) { }
-        public ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) { }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("ApplicationManifest")]
-    public sealed partial class ApplicationManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
-    {
-        public ApplicationManifest() { }
-        public ApplicationManifest(string targetFrameworkVersion) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ConfigFile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ErrorReportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection FileAssociations { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool HostInBrowser { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string IconFile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsClickOnceManifest { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public int MaxTargetPath { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string OSDescription { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string OSSupportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string OSVersion { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Product { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Publisher { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SuiteName { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SupportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo TrustInfo { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool UseApplicationTrust { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ConfigFile")]
-        public string XmlConfigFile { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlElementAttribute("EntryPointIdentity")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlEntryPointIdentity { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointParameters")]
-        public string XmlEntryPointParameters { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointPath")]
-        public string XmlEntryPointPath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
-        public string XmlErrorReportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("FileAssociations")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[] XmlFileAssociations { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("HostInBrowser")]
-        public string XmlHostInBrowser { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IconFile")]
-        public string XmlIconFile { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsClickOnceManifest")]
-        public string XmlIsClickOnceManifest { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSBuild")]
-        public string XmlOSBuild { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSDescription")]
-        public string XmlOSDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSMajor")]
-        public string XmlOSMajor { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSMinor")]
-        public string XmlOSMinor { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSRevision")]
-        public string XmlOSRevision { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("OSSupportUrl")]
-        public string XmlOSSupportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
-        public string XmlProduct { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
-        public string XmlPublisher { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
-        public string XmlSuiteName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
-        public string XmlSupportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UseApplicationTrust")]
-        public string XmlUseApplicationTrust { get { throw null; } set { } }
-        public override void Validate() { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("AssemblyIdentity")]
-    public sealed partial class AssemblyIdentity
-    {
-        public AssemblyIdentity() { }
-        public AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { }
-        public AssemblyIdentity(string name) { }
-        public AssemblyIdentity(string name, string version) { }
-        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture) { }
-        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) { }
-        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Culture { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsFrameworkAssembly { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsNeutralPlatform { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsStrongName { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Name { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ProcessorArchitecture { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string PublicKeyToken { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Type { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Version { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Culture")]
-        public string XmlCulture { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
-        public string XmlName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ProcessorArchitecture")]
-        public string XmlProcessorArchitecture { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("PublicKeyToken")]
-        public string XmlPublicKeyToken { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Type")]
-        public string XmlType { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
-        public string XmlVersion { get { throw null; } set { } }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromAssemblyName(string assemblyName) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromFile(string path) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManagedAssembly(string path) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManifest(string path) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromNativeAssembly(string path) { throw null; }
-        public string GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) { throw null; }
-        public bool IsInFramework(string frameworkIdentifier, string frameworkVersion) { throw null; }
-        public override string ToString() { throw null; }
-        [System.FlagsAttribute]
-        public enum FullNameFlags
-        {
-            Default = 0,
-            ProcessorArchitecture = 1,
-            Type = 2,
-            All = 3,
-        }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("AssemblyManifest")]
-    public partial class AssemblyManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-    {
-        public AssemblyManifest() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ExternalProxyStubs { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("ExternalProxyStubs")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlExternalProxyStubs { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class AssemblyReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-    {
-        public AssemblyReference() { }
-        public AssemblyReference(string path) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsPrerequisite { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType ReferenceType { get { throw null; } set { } }
-        protected internal override string SortName { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsNative")]
-        public string XmlIsNative { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsPrerequisite")]
-        public string XmlIsPrerequisite { get { throw null; } set { } }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class AssemblyReferenceCollection : System.Collections.IEnumerable
-    {
-        internal AssemblyReferenceCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference this[int index] { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(string path) { throw null; }
-        public void Clear() { }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(string name) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference FindTargetPath(string targetPath) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) { }
-    }
-    public enum AssemblyReferenceType
-    {
-        Unspecified = 0,
-        ClickOnceManifest = 1,
-        ManagedAssembly = 2,
-        NativeAssembly = 3,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public abstract partial class BaseReference
-    {
-        protected internal BaseReference() { }
-        protected internal BaseReference(string path) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Group { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Hash { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsOptional { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ResolvedPath { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public long Size { get { throw null; } set { } }
-        protected internal abstract string SortName { get; }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SourcePath { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TargetPath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Group")]
-        public string XmlGroup { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Hash")]
-        public string XmlHash { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("HashAlg")]
-        public string XmlHashAlgorithm { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("IsOptional")]
-        public string XmlIsOptional { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Path")]
-        public string XmlPath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Size")]
-        public string XmlSize { get { throw null; } set { } }
-        public override string ToString() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class ComClass
-    {
-        public ComClass() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ClsId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Description { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ProgId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ThreadingModel { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TlbId { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Clsid")]
-        public string XmlClsId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
-        public string XmlDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
-        public string XmlProgId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ThreadingModel")]
-        public string XmlThreadingModel { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
-        public string XmlTlbId { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class CompatibleFramework
-    {
-        public CompatibleFramework() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Profile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SupportedRuntime { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Version { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Profile")]
-        public string XmlProfile { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SupportedRuntime")]
-        public string XmlSupportedRuntime { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
-        public string XmlVersion { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class CompatibleFrameworkCollection : System.Collections.IEnumerable
-    {
-        internal CompatibleFrameworkCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework this[int index] { get { throw null; } }
-        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) { }
-        public void Clear() { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    [System.Xml.Serialization.XmlRootAttribute("DeployManifest")]
-    public sealed partial class DeployManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-    {
-        public DeployManifest() { }
-        public DeployManifest(string targetFrameworkMoniker) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection CompatibleFrameworks { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool CreateDesktopShortcut { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string DeploymentUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool DisallowUrlActivation { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ErrorReportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool Install { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool MapFileExtensions { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string MinimumRequiredVersion { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Product { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Publisher { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SuiteName { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SupportUrl { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool TrustUrlParameters { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool UpdateEnabled { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public int UpdateInterval { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode UpdateMode { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit UpdateUnit { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("CompatibleFrameworks")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[] XmlCompatibleFrameworks { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("CreateDesktopShortcut")]
-        public string XmlCreateDesktopShortcut { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("DeploymentUrl")]
-        public string XmlDeploymentUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("DisallowUrlActivation")]
-        public string XmlDisallowUrlActivation { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
-        public string XmlErrorReportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Install")]
-        public string XmlInstall { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("MapFileExtensions")]
-        public string XmlMapFileExtensions { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("MinimumRequiredVersion")]
-        public string XmlMinimumRequiredVersion { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
-        public string XmlProduct { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
-        public string XmlPublisher { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
-        public string XmlSuiteName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
-        public string XmlSupportUrl { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("TrustUrlParameters")]
-        public string XmlTrustUrlParameters { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateEnabled")]
-        public string XmlUpdateEnabled { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateInterval")]
-        public string XmlUpdateInterval { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateMode")]
-        public string XmlUpdateMode { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("UpdateUnit")]
-        public string XmlUpdateUnit { get { throw null; } set { } }
-        public override void Validate() { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileAssociation
-    {
-        public FileAssociation() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string DefaultIcon { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Description { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Extension { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ProgId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("DefaultIcon")]
-        public string XmlDefaultIcon { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
-        public string XmlDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Extension")]
-        public string XmlExtension { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
-        public string XmlProgId { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileAssociationCollection : System.Collections.IEnumerable
-    {
-        internal FileAssociationCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation this[int index] { get { throw null; } }
-        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) { }
-        public void Clear() { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-    {
-        public FileReference() { }
-        public FileReference(string path) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] ComClasses { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool IsDataFile { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ProxyStubs { get { throw null; } }
-        protected internal override string SortName { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] TypeLibs { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("ComClasses")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] XmlComClasses { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("ProxyStubs")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlProxyStubs { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("TypeLibs")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] XmlTypeLibs { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("WriteableType")]
-        public string XmlWriteableType { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class FileReferenceCollection : System.Collections.IEnumerable
-    {
-        internal FileReferenceCollection() { }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference this[int index] { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { throw null; }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(string path) { throw null; }
-        public void Clear() { }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindTargetPath(string targetPath) { throw null; }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
-    }
-    public partial class LauncherBuilder
-    {
-        public LauncherBuilder(string launcherPath) { }
-        public string LauncherPath { get { throw null; } set { } }
-        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(string filename, string outputPath) { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public abstract partial class Manifest
-    {
-        protected internal Manifest() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string AssemblyName { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Description { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection FileReferences { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public System.IO.Stream InputStream { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool LauncherBasedDeployment { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool ReadOnly { get { throw null; } set { } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string SourcePath { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("AssemblyReferences")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[] XmlAssemblyReferences { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
-        public string XmlDescription { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlArrayAttribute("FileReferences")]
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[] XmlFileReferences { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Schema")]
-        public string XmlSchema { get { throw null; } set { } }
-        public void ResolveFiles() { }
-        public void ResolveFiles(string[] searchPaths) { }
-        public override string ToString() { throw null; }
-        public void UpdateFileInfo() { }
-        public void UpdateFileInfo(string targetFrameworkVersion) { }
-        public virtual void Validate() { }
-        protected void ValidatePlatform() { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public static partial class ManifestReader
-    {
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(System.IO.Stream input, bool preserveStream) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string path, bool preserveStream) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) { throw null; }
-        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, string path, bool preserveStream) { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public static partial class ManifestWriter
-    {
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { }
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) { }
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) { }
-        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class OutputMessage
-    {
-        internal OutputMessage() { }
-        public string Name { get { throw null; } }
-        public string Text { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType Type { get { throw null; } }
-        public string[] GetArguments() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class OutputMessageCollection : System.Collections.IEnumerable
-    {
-        internal OutputMessageCollection() { }
-        public int ErrorCount { get { throw null; } }
-        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage this[int index] { get { throw null; } }
-        public int WarningCount { get { throw null; } }
-        public void Clear() { }
-        public System.Collections.IEnumerator GetEnumerator() { throw null; }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public enum OutputMessageType
-    {
-        Info = 0,
-        Warning = 1,
-        Error = 2,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class ProxyStub
-    {
-        public ProxyStub() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string BaseInterface { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string IID { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Name { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string NumMethods { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TlbId { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("BaseInterface")]
-        public string XmlBaseInterface { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Iid")]
-        public string XmlIID { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
-        public string XmlName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("NumMethods")]
-        public string XmlNumMethods { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
-        public string XmlTlbId { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public static partial class SecurityUtilities
-    {
-        public static void SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) { }
-        public static void SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) { }
-        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path) { }
-        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) { }
-        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public sealed partial class TrustInfo
-    {
-        public TrustInfo() { }
-        public bool HasUnmanagedCodePermission { get { throw null; } }
-        public bool IsFullTrust { get { throw null; } }
-        public bool PreserveFullTrustPermissionSet { get { throw null; } set { } }
-        public string SameSiteAccess { get { throw null; } set { } }
-        public void Clear() { }
-        public void Read(System.IO.Stream input) { }
-        public void Read(string path) { }
-        public void ReadManifest(System.IO.Stream input) { }
-        public void ReadManifest(string path) { }
-        public override string ToString() { throw null; }
-        public void Write(System.IO.Stream output) { }
-        public void Write(string path) { }
-        public void WriteManifest(System.IO.Stream output) { }
-        public void WriteManifest(System.IO.Stream input, System.IO.Stream output) { }
-        public void WriteManifest(string path) { }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class TypeLib
-    {
-        public TypeLib() { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Flags { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string HelpDirectory { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string ResourceId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string TlbId { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Version { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Flags")]
-        public string XmlFlags { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("HelpDir")]
-        public string XmlHelpDirectory { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("ResourceId")]
-        public string XmlResourceId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
-        public string XmlTlbId { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
-        public string XmlVersion { get { throw null; } set { } }
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public enum UpdateMode
-    {
-        Background = 0,
-        Foreground = 1,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public enum UpdateUnit
-    {
-        Hours = 0,
-        Days = 1,
-        Weeks = 2,
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
-    public partial class WindowClass
-    {
-        public WindowClass() { }
-        public WindowClass(string name, bool versioned) { }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public string Name { get { throw null; } }
-        [System.Xml.Serialization.XmlIgnoreAttribute]
-        public bool Versioned { get { throw null; } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
-        public string XmlName { get { throw null; } set { } }
-        [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
-        [System.Xml.Serialization.XmlAttributeAttribute("Versioned")]
-        public string XmlVersioned { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Tasks.Hosting
-{
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("B5A95716-2053-4B70-9FBF-E4148EBA96BC")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IAnalyzerHostObject
-    {
-        bool SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles);
-        bool SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers);
-        bool SetRuleSet(string ruleSetFile);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject : Microsoft.Build.Framework.ITaskHost
-    {
-        void BeginInitialization();
-        bool Compile();
-        bool EndInitialization(out string errorMessage, out int errorCode);
-        bool IsDesignTime();
-        bool IsUpToDate();
-        bool SetAdditionalLibPaths(string[] additionalLibPaths);
-        bool SetAddModules(string[] addModules);
-        bool SetAllowUnsafeBlocks(bool allowUnsafeBlocks);
-        bool SetBaseAddress(string baseAddress);
-        bool SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow);
-        bool SetCodePage(int codePage);
-        bool SetDebugType(string debugType);
-        bool SetDefineConstants(string defineConstants);
-        bool SetDelaySign(bool delaySignExplicitlySet, bool delaySign);
-        bool SetDisabledWarnings(string disabledWarnings);
-        bool SetDocumentationFile(string documentationFile);
-        bool SetEmitDebugInformation(bool emitDebugInformation);
-        bool SetErrorReport(string errorReport);
-        bool SetFileAlignment(int fileAlignment);
-        bool SetGenerateFullPaths(bool generateFullPaths);
-        bool SetKeyContainer(string keyContainer);
-        bool SetKeyFile(string keyFile);
-        bool SetLangVersion(string langVersion);
-        bool SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources);
-        bool SetMainEntryPoint(string targetType, string mainEntryPoint);
-        bool SetModuleAssemblyName(string moduleAssemblyName);
-        bool SetNoConfig(bool noConfig);
-        bool SetNoStandardLib(bool noStandardLib);
-        bool SetOptimize(bool optimize);
-        bool SetOutputAssembly(string outputAssembly);
-        bool SetPdbFile(string pdbFile);
-        bool SetPlatform(string platform);
-        bool SetReferences(Microsoft.Build.Framework.ITaskItem[] references);
-        bool SetResources(Microsoft.Build.Framework.ITaskItem[] resources);
-        bool SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles);
-        bool SetSources(Microsoft.Build.Framework.ITaskItem[] sources);
-        bool SetTargetType(string targetType);
-        bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
-        bool SetWarningLevel(int warningLevel);
-        bool SetWarningsAsErrors(string warningsAsErrors);
-        bool SetWarningsNotAsErrors(string warningsNotAsErrors);
-        bool SetWin32Icon(string win32Icon);
-        bool SetWin32Resource(string win32Resource);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("D6D4E228-259A-4076-B5D0-0627338BCC10")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject
-    {
-        bool SetWin32Manifest(string win32Manifest);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2
-    {
-        bool SetApplicationConfiguration(string applicationConfiguration);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface ICscHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2, Microsoft.Build.Tasks.Hosting.ICscHostObject3
-    {
-        bool SetHighEntropyVA(bool highEntropyVA);
-        bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
-        bool SetSubsystemVersion(string subsystemVersion);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("7D7AC3BE-253A-40e8-A3FF-357D0DA7C47A")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject : Microsoft.Build.Framework.ITaskHost
-    {
-        void BeginInitialization();
-        bool Compile();
-        void EndInitialization();
-        bool IsDesignTime();
-        bool IsUpToDate();
-        bool SetAdditionalLibPaths(string[] additionalLibPaths);
-        bool SetAddModules(string[] addModules);
-        bool SetBaseAddress(string targetType, string baseAddress);
-        bool SetCodePage(int codePage);
-        bool SetDebugType(bool emitDebugInformation, string debugType);
-        bool SetDefineConstants(string defineConstants);
-        bool SetDelaySign(bool delaySign);
-        bool SetDisabledWarnings(string disabledWarnings);
-        bool SetDocumentationFile(string documentationFile);
-        bool SetErrorReport(string errorReport);
-        bool SetFileAlignment(int fileAlignment);
-        bool SetGenerateDocumentation(bool generateDocumentation);
-        bool SetImports(Microsoft.Build.Framework.ITaskItem[] importsList);
-        bool SetKeyContainer(string keyContainer);
-        bool SetKeyFile(string keyFile);
-        bool SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources);
-        bool SetMainEntryPoint(string mainEntryPoint);
-        bool SetNoConfig(bool noConfig);
-        bool SetNoStandardLib(bool noStandardLib);
-        bool SetNoWarnings(bool noWarnings);
-        bool SetOptimize(bool optimize);
-        bool SetOptionCompare(string optionCompare);
-        bool SetOptionExplicit(bool optionExplicit);
-        bool SetOptionStrict(bool optionStrict);
-        bool SetOptionStrictType(string optionStrictType);
-        bool SetOutputAssembly(string outputAssembly);
-        bool SetPlatform(string platform);
-        bool SetReferences(Microsoft.Build.Framework.ITaskItem[] references);
-        bool SetRemoveIntegerChecks(bool removeIntegerChecks);
-        bool SetResources(Microsoft.Build.Framework.ITaskItem[] resources);
-        bool SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles);
-        bool SetRootNamespace(string rootNamespace);
-        bool SetSdkPath(string sdkPath);
-        bool SetSources(Microsoft.Build.Framework.ITaskItem[] sources);
-        bool SetTargetCompactFramework(bool targetCompactFramework);
-        bool SetTargetType(string targetType);
-        bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
-        bool SetWarningsAsErrors(string warningsAsErrors);
-        bool SetWarningsNotAsErrors(string warningsNotAsErrors);
-        bool SetWin32Icon(string win32Icon);
-        bool SetWin32Resource(string win32Resource);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("f59afc84-d102-48b1-a090-1b90c79d3e09")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject
-    {
-        bool SetModuleAssemblyName(string moduleAssemblyName);
-        bool SetOptionInfer(bool optionInfer);
-        bool SetWin32Manifest(string win32Manifest);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("1186fe8f-8aba-48d6-8ce3-32ca42f53728")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2
-    {
-        bool SetLanguageVersion(string languageVersion);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("2AE3233C-8AB3-48A0-9ED9-6E3545B3C566")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3
-    {
-        bool SetVBRuntime(string VBRuntime);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("5ACF41FF-6F2B-4623-8146-740C89212B21")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObject5 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3, Microsoft.Build.Tasks.Hosting.IVbcHostObject4
-    {
-        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]int CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent);
-        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]int EndCompile(bool buildSuccess);
-        Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded GetFreeThreadedHostObject();
-        bool SetHighEntropyVA(bool highEntropyVA);
-        bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
-        bool SetSubsystemVersion(string subsystemVersion);
-    }
-    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
-    [System.Runtime.InteropServices.GuidAttribute("ECCF972F-8C2D-4F51-9746-9288661DE2CB")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
-    public partial interface IVbcHostObjectFreeThreaded
-    {
-        bool Compile();
-    }
-}
-namespace System.Deployment.Internal.CodeSigning
-{
-    public sealed partial class RSAPKCS1SHA256SignatureDescription : System.Security.Cryptography.SignatureDescription
-    {
-        public RSAPKCS1SHA256SignatureDescription() { }
-        public override System.Security.Cryptography.AsymmetricSignatureDeformatter CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
-        public override System.Security.Cryptography.AsymmetricSignatureFormatter CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
-    }
-}
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
deleted file mode 100644
index 7c0a1e077c3..00000000000
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ /dev/null
@@ -1,608 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.Utilities
-{
-    [Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute]
-    public abstract partial class AppDomainIsolatedTask : System.MarshalByRefObject, Microsoft.Build.Framework.ITask
-    {
-        protected AppDomainIsolatedTask() { }
-        protected AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) { }
-        protected AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) { }
-        public Microsoft.Build.Framework.IBuildEngine BuildEngine { get { throw null; } set { } }
-        protected string HelpKeywordPrefix { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
-        public Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-        protected System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
-        public abstract bool Execute();
-        [System.Security.SecurityCriticalAttribute]
-        public override object InitializeLifetimeService() { throw null; }
-    }
-    public partial class AssemblyFoldersExInfo
-    {
-        public AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) { }
-        public string DirectoryPath { get { throw null; } }
-        public Microsoft.Win32.RegistryHive Hive { get { throw null; } }
-        public string Key { get { throw null; } }
-        public System.Version TargetFrameworkVersion { get { throw null; } }
-        public Microsoft.Win32.RegistryView View { get { throw null; } }
-    }
-    public partial class AssemblyFoldersFromConfigInfo
-    {
-        public AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) { }
-        public string DirectoryPath { get { throw null; } }
-        public System.Version TargetFrameworkVersion { get { throw null; } }
-    }
-    public partial class CanonicalTrackedInputFiles
-    {
-        public CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem sourceFile, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) { }
-        public CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Framework.ITaskItem[] outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) { }
-        public CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) { }
-        public CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) { }
-        public CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) { }
-        public System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, string>> DependencyTable { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] ComputeSourcesNeedingCompilation() { throw null; }
-        public Microsoft.Build.Framework.ITaskItem[] ComputeSourcesNeedingCompilation(bool searchForSubRootsInCompositeRootingMarkers) { throw null; }
-        public bool FileIsExcludedFromDependencyCheck(string fileName) { throw null; }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) { }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) { }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) { }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) { }
-        public void RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) { }
-        public void RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) { }
-        public void RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) { }
-        public void RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) { }
-        public void RemoveEntryForSourceRoot(string rootingMarker) { }
-        public void SaveTlog() { }
-        public void SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) { }
-    }
-    public partial class CanonicalTrackedOutputFiles
-    {
-        public CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles) { }
-        public CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool constructOutputsFromTLogs) { }
-        public CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles) { }
-        public System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, System.DateTime>> DependencyTable { get { throw null; } }
-        public void AddComputedOutputForSourceRoot(string sourceKey, string computedOutput) { }
-        public void AddComputedOutputsForSourceRoot(string sourceKey, Microsoft.Build.Framework.ITaskItem[] computedOutputs) { }
-        public void AddComputedOutputsForSourceRoot(string sourceKey, string[] computedOutputs) { }
-        public Microsoft.Build.Framework.ITaskItem[] OutputsForNonCompositeSource(params Microsoft.Build.Framework.ITaskItem[] sources) { throw null; }
-        public Microsoft.Build.Framework.ITaskItem[] OutputsForSource(params Microsoft.Build.Framework.ITaskItem[] sources) { throw null; }
-        public Microsoft.Build.Framework.ITaskItem[] OutputsForSource(Microsoft.Build.Framework.ITaskItem[] sources, bool searchForSubRootsInCompositeRootingMarkers) { throw null; }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) { }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) { }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) { }
-        public void RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) { }
-        public void RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) { }
-        public void RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) { }
-        public void RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) { }
-        public void RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) { }
-        public void RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) { }
-        public void RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) { }
-        public bool RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove) { throw null; }
-        public string[] RemoveRootsWithSharedOutputs(Microsoft.Build.Framework.ITaskItem[] sources) { throw null; }
-        public void SaveTlog() { }
-        public void SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) { }
-    }
-    public partial class CommandLineBuilder
-    {
-        public CommandLineBuilder() { }
-        public CommandLineBuilder(bool quoteHyphensOnCommandLine) { }
-        public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) { }
-        protected System.Text.StringBuilder CommandLine { get { throw null; } }
-        public int Length { get { throw null; } }
-        public void AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) { }
-        public void AppendFileNameIfNotNull(string fileName) { }
-        public void AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) { }
-        public void AppendFileNamesIfNotNull(string[] fileNames, string delimiter) { }
-        protected void AppendFileNameWithQuoting(string fileName) { }
-        protected void AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) { }
-        protected void AppendSpaceIfNotEmpty() { }
-        public void AppendSwitch(string switchName) { }
-        public void AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) { }
-        public void AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) { }
-        public void AppendSwitchIfNotNull(string switchName, string parameter) { }
-        public void AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, string parameter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) { }
-        public void AppendTextUnquoted(string textToAppend) { }
-        protected void AppendTextWithQuoting(string textToAppend) { }
-        protected virtual bool IsQuotingRequired(string parameter) { throw null; }
-        public override string ToString() { throw null; }
-        protected virtual void VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) { }
-    }
-    public delegate bool DependencyFilter(string fullPath);
-    public enum DotNetFrameworkArchitecture
-    {
-        Current = 0,
-        Bitness32 = 1,
-        Bitness64 = 2,
-    }
-    public enum ExecutableType
-    {
-        Native32Bit = 0,
-        Native64Bit = 1,
-        ManagedIL = 2,
-        Managed32Bit = 3,
-        Managed64Bit = 4,
-        SameAsCurrentProcess = 5,
-    }
-    public static partial class FileTracker
-    {
-        public static string CreateRootingMarkerResponseFile(Microsoft.Build.Framework.ITaskItem[] sources) { throw null; }
-        public static string CreateRootingMarkerResponseFile(string rootMarker) { throw null; }
-        public static void EndTrackingContext() { }
-        public static string EnsureFileTrackerOnPath() { throw null; }
-        public static string EnsureFileTrackerOnPath(string rootPath) { throw null; }
-        public static bool FileIsExcludedFromDependencies(string fileName) { throw null; }
-        public static bool FileIsUnderPath(string fileName, string path) { throw null; }
-        public static string FindTrackerOnPath() { throw null; }
-        public static bool ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType) { throw null; }
-        public static bool ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string cancelEventName) { throw null; }
-        public static string FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source) { throw null; }
-        public static string FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem output) { throw null; }
-        public static string FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources) { throw null; }
-        public static string FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem[] outputs) { throw null; }
-        public static string GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) { throw null; }
-        public static string GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) { throw null; }
-        public static string GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) { throw null; }
-        public static string GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) { throw null; }
-        public static void ResumeTracking() { }
-        public static void SetThreadCount(int threadCount) { }
-        public static System.Diagnostics.Process StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType) { throw null; }
-        public static System.Diagnostics.Process StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string rootFiles) { throw null; }
-        public static System.Diagnostics.Process StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string intermediateDirectory, string rootFiles) { throw null; }
-        public static System.Diagnostics.Process StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles) { throw null; }
-        public static System.Diagnostics.Process StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) { throw null; }
-        public static void StartTrackingContext(string intermediateDirectory, string taskName) { }
-        public static void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile) { }
-        public static void StopTrackingAndCleanup() { }
-        public static void SuspendTracking() { }
-        public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles) { throw null; }
-        public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) { throw null; }
-        public static string TrackerCommandArguments(string command, string arguments) { throw null; }
-        public static string TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles) { throw null; }
-        public static string TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) { throw null; }
-        public static void WriteAllTLogs(string intermediateDirectory, string taskName) { }
-        public static void WriteContextTLogs(string intermediateDirectory, string taskName) { }
-    }
-    public partial class FlatTrackingData
-    {
-        public FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) { }
-        public FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) { }
-        public FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc) { }
-        public FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache) { }
-        public FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache, bool treatRootMarkersAsEntries) { }
-        public FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) { }
-        public FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) { }
-        public System.Collections.Generic.List<string> MissingFiles { get { throw null; } set { } }
-        public string NewestFileName { get { throw null; } set { } }
-        public System.DateTime NewestFileTime { get { throw null; } set { } }
-        public System.DateTime NewestFileTimeUtc { get { throw null; } set { } }
-        public string NewestTLogFileName { get { throw null; } set { } }
-        public System.DateTime NewestTLogTime { get { throw null; } set { } }
-        public System.DateTime NewestTLogTimeUtc { get { throw null; } set { } }
-        public string OldestFileName { get { throw null; } set { } }
-        public System.DateTime OldestFileTime { get { throw null; } set { } }
-        public System.DateTime OldestFileTimeUtc { get { throw null; } set { } }
-        public bool SkipMissingFiles { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskItem[] TlogFiles { get { throw null; } set { } }
-        public bool TlogsAvailable { get { throw null; } set { } }
-        public bool TreatRootMarkersAsEntries { get { throw null; } set { } }
-        public bool FileIsExcludedFromDependencyCheck(string fileName) { throw null; }
-        public static void FinalizeTLogs(bool trackedOperationsSucceeded, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames, Microsoft.Build.Framework.ITaskItem[] trackedFilesToRemoveFromTLogs) { }
-        public System.DateTime GetLastWriteTimeUtc(string file) { throw null; }
-        public static bool IsUpToDate(Microsoft.Build.Utilities.Task hostTask, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames) { throw null; }
-        public static bool IsUpToDate(Microsoft.Build.Utilities.TaskLoggingHelper Log, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Utilities.FlatTrackingData inputs, Microsoft.Build.Utilities.FlatTrackingData outputs) { throw null; }
-        public void SaveTlog() { }
-        public void SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) { }
-        public void UpdateFileEntryDetails() { }
-    }
-    public enum HostObjectInitializationStatus
-    {
-        UseHostObjectToExecute = 0,
-        UseAlternateToolToExecute = 1,
-        NoActionReturnSuccess = 2,
-        NoActionReturnFailure = 3,
-    }
-    public abstract partial class Logger : Microsoft.Build.Framework.ILogger
-    {
-        protected Logger() { }
-        public virtual string Parameters { get { throw null; } set { } }
-        public virtual Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public virtual string FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) { throw null; }
-        public virtual string FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) { throw null; }
-        public abstract void Initialize(Microsoft.Build.Framework.IEventSource eventSource);
-        public bool IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) { throw null; }
-        public virtual void Shutdown() { }
-    }
-    public enum MultipleVersionSupport
-    {
-        Allow = 0,
-        Warning = 1,
-        Error = 2,
-    }
-    public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public MuxLogger() { }
-        public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
-        public bool IncludeEvaluationProfiles { get { throw null; } set { } }
-        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
-        public bool IncludeTaskInputs { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) { }
-        public void RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) { }
-        public void Shutdown() { }
-        public bool UnregisterLoggers(int submissionId) { throw null; }
-    }
-    public static partial class ProcessorArchitecture
-    {
-        public const string AMD64 = "AMD64";
-        public const string ARM = "ARM";
-        public const string ARM64 = "ARM64";
-        public const string IA64 = "IA64";
-        public const string MSIL = "MSIL";
-        public const string X86 = "x86";
-        public static string CurrentProcessArchitecture { get { throw null; } }
-    }
-    public partial class SDKManifest
-    {
-        public SDKManifest(string pathToSdk) { }
-        public System.Collections.Generic.IDictionary<string, string> AppxLocations { get { throw null; } }
-        public string CopyRedistToSubDirectory { get { throw null; } }
-        public string DependsOnSDK { get { throw null; } }
-        public string DisplayName { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> FrameworkIdentities { get { throw null; } }
-        public string FrameworkIdentity { get { throw null; } }
-        public string MaxOSVersionTested { get { throw null; } }
-        public string MaxPlatformVersion { get { throw null; } }
-        public string MinOSVersion { get { throw null; } }
-        public string MinVSVersion { get { throw null; } }
-        public string MoreInfo { get { throw null; } }
-        public string PlatformIdentity { get { throw null; } }
-        public string ProductFamilyName { get { throw null; } }
-        public bool ReadError { get { throw null; } }
-        public string ReadErrorMessage { get { throw null; } }
-        public Microsoft.Build.Utilities.SDKType SDKType { get { throw null; } }
-        public string SupportedArchitectures { get { throw null; } }
-        public string SupportPrefer32Bit { get { throw null; } }
-        public Microsoft.Build.Utilities.MultipleVersionSupport SupportsMultipleVersions { get { throw null; } }
-        public string TargetPlatform { get { throw null; } }
-        public string TargetPlatformMinVersion { get { throw null; } }
-        public string TargetPlatformVersion { get { throw null; } }
-        public static partial class Attributes
-        {
-            public const string APPX = "APPX";
-            public const string AppxLocation = "AppxLocation";
-            public const string CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies";
-            public const string CopyRedist = "CopyRedist";
-            public const string CopyRedistToSubDirectory = "CopyRedistToSubDirectory";
-            public const string DependsOnSDK = "DependsOn";
-            public const string DisplayName = "DisplayName";
-            public const string ExpandReferenceAssemblies = "ExpandReferenceAssemblies";
-            public const string FrameworkIdentity = "FrameworkIdentity";
-            public const string MaxOSVersionTested = "MaxOSVersionTested";
-            public const string MaxPlatformVersion = "MaxPlatformVersion";
-            public const string MinOSVersion = "MinOSVersion";
-            public const string MinVSVersion = "MinVSVersion";
-            public const string MoreInfo = "MoreInfo";
-            public const string PlatformIdentity = "PlatformIdentity";
-            public const string ProductFamilyName = "ProductFamilyName";
-            public const string SDKType = "SDKType";
-            public const string SupportedArchitectures = "SupportedArchitectures";
-            public const string SupportPrefer32Bit = "SupportPrefer32Bit";
-            public const string SupportsMultipleVersions = "SupportsMultipleVersions";
-            public const string TargetedSDK = "TargetedSDKArchitecture";
-            public const string TargetedSDKConfiguration = "TargetedSDKConfiguration";
-            public const string TargetPlatform = "TargetPlatform";
-            public const string TargetPlatformMinVersion = "TargetPlatformMinVersion";
-            public const string TargetPlatformVersion = "TargetPlatformVersion";
-        }
-    }
-    public enum SDKType
-    {
-        Unspecified = 0,
-        External = 1,
-        Platform = 2,
-        Framework = 3,
-    }
-    public enum TargetDotNetFrameworkVersion
-    {
-        Version11 = 0,
-        Version20 = 1,
-        Version30 = 2,
-        Version35 = 3,
-        Version40 = 4,
-        Version45 = 5,
-        Version451 = 6,
-        Version46 = 7,
-        Version461 = 8,
-        Version452 = 9,
-        Version462 = 10,
-        Version47 = 11,
-        Version471 = 12,
-        Version472 = 13,
-        Version48 = 14,
-        VersionLatest = 14,
-        Latest = 9999,
-    }
-    public partial class TargetPlatformSDK : System.IEquatable<Microsoft.Build.Utilities.TargetPlatformSDK>
-    {
-        public TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) { }
-        public string DisplayName { get { throw null; } }
-        public System.Version MinOSVersion { get { throw null; } }
-        public System.Version MinVSVersion { get { throw null; } }
-        public string Path { get { throw null; } set { } }
-        public string TargetPlatformIdentifier { get { throw null; } }
-        public System.Version TargetPlatformVersion { get { throw null; } }
-        public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public bool Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-    }
-    public abstract partial class Task : Microsoft.Build.Framework.ITask
-    {
-        protected Task() { }
-        protected Task(System.Resources.ResourceManager taskResources) { }
-        protected Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) { }
-        public Microsoft.Build.Framework.IBuildEngine BuildEngine { get { throw null; } set { } }
-        public Microsoft.Build.Framework.IBuildEngine2 BuildEngine2 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine3 BuildEngine3 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine4 BuildEngine4 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine5 BuildEngine5 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine6 BuildEngine6 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine7 BuildEngine7 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine8 BuildEngine8 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine9 BuildEngine9 { get { throw null; } }
-        protected string HelpKeywordPrefix { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
-        public Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-        protected System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
-        public abstract bool Execute();
-    }
-    public sealed partial class TaskItem : System.MarshalByRefObject, Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
-    {
-        public TaskItem() { }
-        public TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) { }
-        public TaskItem(string itemSpec) { }
-        public TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) { }
-        public string ItemSpec { get { throw null; } set { } }
-        public int MetadataCount { get { throw null; } }
-        public System.Collections.ICollection MetadataNames { get { throw null; } }
-        string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get { throw null; } set { } }
-        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }
-        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
-        public string GetMetadata(string metadataName) { throw null; }
-        [System.Security.SecurityCriticalAttribute]
-        public override object InitializeLifetimeService() { throw null; }
-        System.Collections.IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() { throw null; }
-        string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) { throw null; }
-        void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) { }
-        public static explicit operator string (Microsoft.Build.Utilities.TaskItem taskItemToCast) { throw null; }
-        public void RemoveMetadata(string metadataName) { }
-        public void SetMetadata(string metadataName, string metadataValue) { }
-        public override string ToString() { throw null; }
-    }
-    public partial class TaskLoggingHelper : System.MarshalByRefObject
-    {
-        public TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) { }
-        public TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) { }
-        protected Microsoft.Build.Framework.IBuildEngine BuildEngine { get { throw null; } }
-        public bool HasLoggedErrors { get { throw null; } }
-        public string HelpKeywordPrefix { get { throw null; } set { } }
-        public bool IsTaskInputLoggingEnabled { get { throw null; } }
-        protected string TaskName { get { throw null; } }
-        public System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
-        public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { throw null; }
-        public virtual string FormatResourceString(string resourceName, params object[] args) { throw null; }
-        public virtual string FormatString(string unformatted, params object[] args) { throw null; }
-        public virtual string GetResourceMessage(string resourceName) { throw null; }
-        public override object InitializeLifetimeService() { throw null; }
-        public void LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) { }
-        public void LogCommandLine(string commandLine) { }
-        public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogError(string message, params object[] messageArgs) { }
-        public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogErrorFromException(System.Exception exception) { }
-        public void LogErrorFromException(System.Exception exception, bool showStackTrace) { }
-        public void LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) { }
-        public void LogErrorFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-        public void LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-        public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) { }
-        public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) { }
-        public void LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) { }
-        public void LogMessage(string message, params object[] messageArgs) { }
-        public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) { }
-        public void LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) { }
-        public void LogMessageFromResources(string messageResourceName, params object[] messageArgs) { }
-        public bool LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
-        public bool LogMessagesFromFile(string fileName) { throw null; }
-        public bool LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
-        public bool LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
-        public bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
-        public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
-        public void LogWarning(string message, params object[] messageArgs) { }
-        public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogWarningFromException(System.Exception exception) { }
-        public void LogWarningFromException(System.Exception exception, bool showStackTrace) { }
-        public void LogWarningFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-        public void LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-        public void MarkAsInactive() { }
-    }
-    public static partial class ToolLocationHelper
-    {
-        public static string CurrentToolsVersion { get { throw null; } }
-        public static string PathToSystem { get { throw null; } }
-        public static void ClearSDKStaticCache() { }
-        public static System.Collections.Generic.IDictionary<string, string> FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) { throw null; }
-        public static string FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo> GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) { throw null; }
-        public static string GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static string GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) { throw null; }
-        public static string GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) { throw null; }
-        public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) { throw null; }
-        public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) { throw null; }
-        public static string GetPathToBuildTools(string toolsVersion) { throw null; }
-        public static string GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToBuildToolsFile(string fileName, string toolsVersion) { throw null; }
-        public static string GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkSdk() { throw null; }
-        public static string GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) { throw null; }
-        public static string GetPathToSystemFile(string fileName) { throw null; }
-        [System.ObsoleteAttribute("Consider using GetPlatformSDKLocation instead")]
-        public static string GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        [System.ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
-        public static string GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        [System.ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
-        public static string GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, string> GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, string> GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, string> GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, System.Tuple<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, System.Tuple<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, System.Tuple<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static string[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) { throw null; }
-        public static string[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) { throw null; }
-        public static string GetProgramFilesReferenceAssemblyRoot() { throw null; }
-        public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKRedistFolders(string sdkRoot) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKReferenceFolders(string sdkRoot) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSupportedTargetFrameworks() { throw null; }
-        public static string[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) { throw null; }
-        public static string[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> GetTargetPlatformSdks() { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> GetTargetPlatformSdks(string[] diskRoots, string registryRoot) { throw null; }
-        public static System.Runtime.Versioning.FrameworkName HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) { throw null; }
-    }
-    public abstract partial class ToolTask : Microsoft.Build.Utilities.Task, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        protected ToolTask() { }
-        protected ToolTask(System.Resources.ResourceManager taskResources) { }
-        protected ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) { }
-        public bool EchoOff { get { throw null; } set { } }
-        [System.ObsoleteAttribute("Use EnvironmentVariables property")]
-        protected virtual System.Collections.Generic.Dictionary<string, string> EnvironmentOverride { get { throw null; } }
-        public string[] EnvironmentVariables { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public int ExitCode { get { throw null; } }
-        protected virtual bool HasLoggedErrors { get { throw null; } }
-        public bool LogStandardErrorAsError { get { throw null; } set { } }
-        protected virtual System.Text.Encoding ResponseFileEncoding { get { throw null; } }
-        protected virtual System.Text.Encoding StandardErrorEncoding { get { throw null; } }
-        public string StandardErrorImportance { get { throw null; } set { } }
-        protected Microsoft.Build.Framework.MessageImportance StandardErrorImportanceToUse { get { throw null; } }
-        protected virtual Microsoft.Build.Framework.MessageImportance StandardErrorLoggingImportance { get { throw null; } }
-        protected virtual System.Text.Encoding StandardOutputEncoding { get { throw null; } }
-        public string StandardOutputImportance { get { throw null; } set { } }
-        protected Microsoft.Build.Framework.MessageImportance StandardOutputImportanceToUse { get { throw null; } }
-        protected virtual Microsoft.Build.Framework.MessageImportance StandardOutputLoggingImportance { get { throw null; } }
-        protected int TaskProcessTerminationTimeout { get { throw null; } set { } }
-        public virtual int Timeout { get { throw null; } set { } }
-        protected System.Threading.ManualResetEvent ToolCanceled { get { throw null; } }
-        public virtual string ToolExe { get { throw null; } set { } }
-        protected abstract string ToolName { get; }
-        public string ToolPath { get { throw null; } set { } }
-        public bool UseCommandProcessor { get { throw null; } set { } }
-        public string UseUtf8Encoding { get { throw null; } set { } }
-        public bool YieldDuringToolExecution { get { throw null; } set { } }
-        protected virtual string AdjustCommandsForOperatingSystem(string input) { throw null; }
-        protected virtual bool CallHostObjectToExecute() { throw null; }
-        public virtual void Cancel() { }
-        protected void DeleteTempFile(string fileName) { }
-        public override bool Execute() { throw null; }
-        protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
-        protected virtual string GenerateCommandLineCommands() { throw null; }
-        protected abstract string GenerateFullPathToTool();
-        protected virtual string GenerateResponseFileCommands() { throw null; }
-        protected virtual System.Diagnostics.ProcessStartInfo GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) { throw null; }
-        protected virtual string GetResponseFileSwitch(string responseFilePath) { throw null; }
-        protected virtual string GetWorkingDirectory() { throw null; }
-        protected virtual bool HandleTaskExecutionErrors() { throw null; }
-        protected virtual Microsoft.Build.Utilities.HostObjectInitializationStatus InitializeHostObject() { throw null; }
-        protected virtual void LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) { }
-        protected virtual void LogPathToTool(string toolName, string pathToTool) { }
-        protected virtual void LogToolCommand(string message) { }
-        protected virtual void ProcessStarted() { }
-        protected virtual string ResponseFileEscape(string responseString) { throw null; }
-        protected virtual bool SkipTaskExecution() { throw null; }
-        protected internal virtual bool ValidateParameters() { throw null; }
-    }
-    public static partial class TrackedDependencies
-    {
-        public static Microsoft.Build.Framework.ITaskItem[] ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) { throw null; }
-    }
-    public enum UpToDateCheckType
-    {
-        InputNewerThanOutput = 0,
-        InputOrOutputNewerThanTracking = 1,
-        InputNewerThanTracking = 2,
-    }
-    public enum VisualStudioVersion
-    {
-        Version100 = 0,
-        Version110 = 1,
-        Version120 = 2,
-        Version140 = 3,
-        Version150 = 4,
-        Version160 = 5,
-        Version170 = 6,
-        VersionLatest = 6,
-    }
-}
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
deleted file mode 100644
index 6cc7b96d758..00000000000
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ /dev/null
@@ -1,442 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.Utilities
-{
-    public partial class AssemblyFoldersFromConfigInfo
-    {
-        public AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) { }
-        public string DirectoryPath { get { throw null; } }
-        public System.Version TargetFrameworkVersion { get { throw null; } }
-    }
-    public partial class CommandLineBuilder
-    {
-        public CommandLineBuilder() { }
-        public CommandLineBuilder(bool quoteHyphensOnCommandLine) { }
-        public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) { }
-        protected System.Text.StringBuilder CommandLine { get { throw null; } }
-        public int Length { get { throw null; } }
-        public void AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) { }
-        public void AppendFileNameIfNotNull(string fileName) { }
-        public void AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) { }
-        public void AppendFileNamesIfNotNull(string[] fileNames, string delimiter) { }
-        protected void AppendFileNameWithQuoting(string fileName) { }
-        protected void AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) { }
-        protected void AppendSpaceIfNotEmpty() { }
-        public void AppendSwitch(string switchName) { }
-        public void AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) { }
-        public void AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) { }
-        public void AppendSwitchIfNotNull(string switchName, string parameter) { }
-        public void AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, string parameter) { }
-        public void AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) { }
-        public void AppendTextUnquoted(string textToAppend) { }
-        protected void AppendTextWithQuoting(string textToAppend) { }
-        protected virtual bool IsQuotingRequired(string parameter) { throw null; }
-        public override string ToString() { throw null; }
-        protected virtual void VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) { }
-    }
-    public enum DotNetFrameworkArchitecture
-    {
-        Current = 0,
-        Bitness32 = 1,
-        Bitness64 = 2,
-    }
-    public enum HostObjectInitializationStatus
-    {
-        UseHostObjectToExecute = 0,
-        UseAlternateToolToExecute = 1,
-        NoActionReturnSuccess = 2,
-        NoActionReturnFailure = 3,
-    }
-    public abstract partial class Logger : Microsoft.Build.Framework.ILogger
-    {
-        protected Logger() { }
-        public virtual string Parameters { get { throw null; } set { } }
-        public virtual Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public virtual string FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) { throw null; }
-        public virtual string FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) { throw null; }
-        public abstract void Initialize(Microsoft.Build.Framework.IEventSource eventSource);
-        public bool IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) { throw null; }
-        public virtual void Shutdown() { }
-    }
-    public enum MultipleVersionSupport
-    {
-        Allow = 0,
-        Warning = 1,
-        Error = 2,
-    }
-    public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public MuxLogger() { }
-        public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
-        public bool IncludeEvaluationProfiles { get { throw null; } set { } }
-        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
-        public bool IncludeTaskInputs { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) { }
-        public void RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) { }
-        public void Shutdown() { }
-        public bool UnregisterLoggers(int submissionId) { throw null; }
-    }
-    public static partial class ProcessorArchitecture
-    {
-        public const string AMD64 = "AMD64";
-        public const string ARM = "ARM";
-        public const string ARM64 = "ARM64";
-        public const string IA64 = "IA64";
-        public const string MSIL = "MSIL";
-        public const string X86 = "x86";
-        public static string CurrentProcessArchitecture { get { throw null; } }
-    }
-    public partial class SDKManifest
-    {
-        public SDKManifest(string pathToSdk) { }
-        public System.Collections.Generic.IDictionary<string, string> AppxLocations { get { throw null; } }
-        public string CopyRedistToSubDirectory { get { throw null; } }
-        public string DependsOnSDK { get { throw null; } }
-        public string DisplayName { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> FrameworkIdentities { get { throw null; } }
-        public string FrameworkIdentity { get { throw null; } }
-        public string MaxOSVersionTested { get { throw null; } }
-        public string MaxPlatformVersion { get { throw null; } }
-        public string MinOSVersion { get { throw null; } }
-        public string MinVSVersion { get { throw null; } }
-        public string MoreInfo { get { throw null; } }
-        public string PlatformIdentity { get { throw null; } }
-        public string ProductFamilyName { get { throw null; } }
-        public bool ReadError { get { throw null; } }
-        public string ReadErrorMessage { get { throw null; } }
-        public Microsoft.Build.Utilities.SDKType SDKType { get { throw null; } }
-        public string SupportedArchitectures { get { throw null; } }
-        public string SupportPrefer32Bit { get { throw null; } }
-        public Microsoft.Build.Utilities.MultipleVersionSupport SupportsMultipleVersions { get { throw null; } }
-        public string TargetPlatform { get { throw null; } }
-        public string TargetPlatformMinVersion { get { throw null; } }
-        public string TargetPlatformVersion { get { throw null; } }
-        public static partial class Attributes
-        {
-            public const string APPX = "APPX";
-            public const string AppxLocation = "AppxLocation";
-            public const string CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies";
-            public const string CopyRedist = "CopyRedist";
-            public const string CopyRedistToSubDirectory = "CopyRedistToSubDirectory";
-            public const string DependsOnSDK = "DependsOn";
-            public const string DisplayName = "DisplayName";
-            public const string ExpandReferenceAssemblies = "ExpandReferenceAssemblies";
-            public const string FrameworkIdentity = "FrameworkIdentity";
-            public const string MaxOSVersionTested = "MaxOSVersionTested";
-            public const string MaxPlatformVersion = "MaxPlatformVersion";
-            public const string MinOSVersion = "MinOSVersion";
-            public const string MinVSVersion = "MinVSVersion";
-            public const string MoreInfo = "MoreInfo";
-            public const string PlatformIdentity = "PlatformIdentity";
-            public const string ProductFamilyName = "ProductFamilyName";
-            public const string SDKType = "SDKType";
-            public const string SupportedArchitectures = "SupportedArchitectures";
-            public const string SupportPrefer32Bit = "SupportPrefer32Bit";
-            public const string SupportsMultipleVersions = "SupportsMultipleVersions";
-            public const string TargetedSDK = "TargetedSDKArchitecture";
-            public const string TargetedSDKConfiguration = "TargetedSDKConfiguration";
-            public const string TargetPlatform = "TargetPlatform";
-            public const string TargetPlatformMinVersion = "TargetPlatformMinVersion";
-            public const string TargetPlatformVersion = "TargetPlatformVersion";
-        }
-    }
-    public enum SDKType
-    {
-        Unspecified = 0,
-        External = 1,
-        Platform = 2,
-        Framework = 3,
-    }
-    public enum TargetDotNetFrameworkVersion
-    {
-        Version11 = 0,
-        Version20 = 1,
-        Version30 = 2,
-        Version35 = 3,
-        Version40 = 4,
-        Version45 = 5,
-        Version451 = 6,
-        Version46 = 7,
-        Version461 = 8,
-        Version452 = 9,
-        Version462 = 10,
-        Version47 = 11,
-        Version471 = 12,
-        Version472 = 13,
-        Version48 = 14,
-        VersionLatest = 14,
-        Latest = 9999,
-    }
-    public partial class TargetPlatformSDK : System.IEquatable<Microsoft.Build.Utilities.TargetPlatformSDK>
-    {
-        public TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) { }
-        public string DisplayName { get { throw null; } }
-        public System.Version MinOSVersion { get { throw null; } }
-        public System.Version MinVSVersion { get { throw null; } }
-        public string Path { get { throw null; } set { } }
-        public string TargetPlatformIdentifier { get { throw null; } }
-        public System.Version TargetPlatformVersion { get { throw null; } }
-        public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public bool Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-    }
-    public abstract partial class Task : Microsoft.Build.Framework.ITask
-    {
-        protected Task() { }
-        protected Task(System.Resources.ResourceManager taskResources) { }
-        protected Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) { }
-        public Microsoft.Build.Framework.IBuildEngine BuildEngine { get { throw null; } set { } }
-        public Microsoft.Build.Framework.IBuildEngine2 BuildEngine2 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine3 BuildEngine3 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine4 BuildEngine4 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine5 BuildEngine5 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine6 BuildEngine6 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine7 BuildEngine7 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine8 BuildEngine8 { get { throw null; } }
-        public Microsoft.Build.Framework.IBuildEngine9 BuildEngine9 { get { throw null; } }
-        protected string HelpKeywordPrefix { get { throw null; } set { } }
-        public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
-        public Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
-        protected System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
-        public abstract bool Execute();
-    }
-    public sealed partial class TaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
-    {
-        public TaskItem() { }
-        public TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) { }
-        public TaskItem(string itemSpec) { }
-        public TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) { }
-        public string ItemSpec { get { throw null; } set { } }
-        public int MetadataCount { get { throw null; } }
-        public System.Collections.ICollection MetadataNames { get { throw null; } }
-        string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get { throw null; } set { } }
-        public System.Collections.IDictionary CloneCustomMetadata() { throw null; }
-        public void CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
-        public string GetMetadata(string metadataName) { throw null; }
-        System.Collections.IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() { throw null; }
-        string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) { throw null; }
-        void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) { }
-        public static explicit operator string (Microsoft.Build.Utilities.TaskItem taskItemToCast) { throw null; }
-        public void RemoveMetadata(string metadataName) { }
-        public void SetMetadata(string metadataName, string metadataValue) { }
-        public override string ToString() { throw null; }
-    }
-    public partial class TaskLoggingHelper
-    {
-        public TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) { }
-        public TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) { }
-        protected Microsoft.Build.Framework.IBuildEngine BuildEngine { get { throw null; } }
-        public bool HasLoggedErrors { get { throw null; } }
-        public string HelpKeywordPrefix { get { throw null; } set { } }
-        public bool IsTaskInputLoggingEnabled { get { throw null; } }
-        protected string TaskName { get { throw null; } }
-        public System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
-        public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { throw null; }
-        public virtual string FormatResourceString(string resourceName, params object[] args) { throw null; }
-        public virtual string FormatString(string unformatted, params object[] args) { throw null; }
-        public virtual string GetResourceMessage(string resourceName) { throw null; }
-        public void LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) { }
-        public void LogCommandLine(string commandLine) { }
-        public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogError(string message, params object[] messageArgs) { }
-        public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogErrorFromException(System.Exception exception) { }
-        public void LogErrorFromException(System.Exception exception, bool showStackTrace) { }
-        public void LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) { }
-        public void LogErrorFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-        public void LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-        public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) { }
-        public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) { }
-        public void LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) { }
-        public void LogMessage(string message, params object[] messageArgs) { }
-        public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) { }
-        public void LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) { }
-        public void LogMessageFromResources(string messageResourceName, params object[] messageArgs) { }
-        public bool LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
-        public bool LogMessagesFromFile(string fileName) { throw null; }
-        public bool LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
-        public bool LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
-        public bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
-        public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
-        public void LogWarning(string message, params object[] messageArgs) { }
-        public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
-        public void LogWarningFromException(System.Exception exception) { }
-        public void LogWarningFromException(System.Exception exception, bool showStackTrace) { }
-        public void LogWarningFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-        public void LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) { }
-        public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) { }
-    }
-    public static partial class ToolLocationHelper
-    {
-        public static string CurrentToolsVersion { get { throw null; } }
-        public static string PathToSystem { get { throw null; } }
-        public static void ClearSDKStaticCache() { }
-        public static System.Collections.Generic.IDictionary<string, string> FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) { throw null; }
-        public static string FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo> GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) { throw null; }
-        public static string GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static string GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) { throw null; }
-        public static string GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) { throw null; }
-        public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) { throw null; }
-        public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) { throw null; }
-        public static string GetPathToBuildTools(string toolsVersion) { throw null; }
-        public static string GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToBuildToolsFile(string fileName, string toolsVersion) { throw null; }
-        public static string GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkSdk() { throw null; }
-        public static string GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) { throw null; }
-        public static System.Collections.Generic.IList<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) { throw null; }
-        public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) { throw null; }
-        public static string GetPathToSystemFile(string fileName) { throw null; }
-        [System.ObsoleteAttribute("Consider using GetPlatformSDKLocation instead")]
-        public static string GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        [System.ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
-        public static string GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
-        [System.ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
-        public static string GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, string> GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, string> GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, string> GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, System.Tuple<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, System.Tuple<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static System.Collections.Generic.IDictionary<string, System.Tuple<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static string[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) { throw null; }
-        public static string[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) { throw null; }
-        public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) { throw null; }
-        public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) { throw null; }
-        public static string GetProgramFilesReferenceAssemblyRoot() { throw null; }
-        public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKRedistFolders(string sdkRoot) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKReferenceFolders(string sdkRoot) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
-        public static System.Collections.Generic.IList<string> GetSupportedTargetFrameworks() { throw null; }
-        public static string[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) { throw null; }
-        public static string[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> GetTargetPlatformSdks() { throw null; }
-        public static System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> GetTargetPlatformSdks(string[] diskRoots, string registryRoot) { throw null; }
-        public static System.Runtime.Versioning.FrameworkName HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) { throw null; }
-    }
-    public abstract partial class ToolTask : Microsoft.Build.Utilities.Task, Microsoft.Build.Framework.ICancelableTask, Microsoft.Build.Framework.ITask
-    {
-        protected ToolTask() { }
-        protected ToolTask(System.Resources.ResourceManager taskResources) { }
-        protected ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) { }
-        public bool EchoOff { get { throw null; } set { } }
-        [System.ObsoleteAttribute("Use EnvironmentVariables property")]
-        protected virtual System.Collections.Generic.Dictionary<string, string> EnvironmentOverride { get { throw null; } }
-        public string[] EnvironmentVariables { get { throw null; } set { } }
-        [Microsoft.Build.Framework.OutputAttribute]
-        public int ExitCode { get { throw null; } }
-        protected virtual bool HasLoggedErrors { get { throw null; } }
-        public bool LogStandardErrorAsError { get { throw null; } set { } }
-        protected virtual System.Text.Encoding ResponseFileEncoding { get { throw null; } }
-        protected virtual System.Text.Encoding StandardErrorEncoding { get { throw null; } }
-        public string StandardErrorImportance { get { throw null; } set { } }
-        protected Microsoft.Build.Framework.MessageImportance StandardErrorImportanceToUse { get { throw null; } }
-        protected virtual Microsoft.Build.Framework.MessageImportance StandardErrorLoggingImportance { get { throw null; } }
-        protected virtual System.Text.Encoding StandardOutputEncoding { get { throw null; } }
-        public string StandardOutputImportance { get { throw null; } set { } }
-        protected Microsoft.Build.Framework.MessageImportance StandardOutputImportanceToUse { get { throw null; } }
-        protected virtual Microsoft.Build.Framework.MessageImportance StandardOutputLoggingImportance { get { throw null; } }
-        protected int TaskProcessTerminationTimeout { get { throw null; } set { } }
-        public virtual int Timeout { get { throw null; } set { } }
-        protected System.Threading.ManualResetEvent ToolCanceled { get { throw null; } }
-        public virtual string ToolExe { get { throw null; } set { } }
-        protected abstract string ToolName { get; }
-        public string ToolPath { get { throw null; } set { } }
-        public bool UseCommandProcessor { get { throw null; } set { } }
-        public string UseUtf8Encoding { get { throw null; } set { } }
-        public bool YieldDuringToolExecution { get { throw null; } set { } }
-        protected virtual string AdjustCommandsForOperatingSystem(string input) { throw null; }
-        protected virtual bool CallHostObjectToExecute() { throw null; }
-        public virtual void Cancel() { }
-        protected void DeleteTempFile(string fileName) { }
-        public override bool Execute() { throw null; }
-        protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
-        protected virtual string GenerateCommandLineCommands() { throw null; }
-        protected abstract string GenerateFullPathToTool();
-        protected virtual string GenerateResponseFileCommands() { throw null; }
-        protected virtual System.Diagnostics.ProcessStartInfo GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) { throw null; }
-        protected virtual string GetResponseFileSwitch(string responseFilePath) { throw null; }
-        protected virtual string GetWorkingDirectory() { throw null; }
-        protected virtual bool HandleTaskExecutionErrors() { throw null; }
-        protected virtual Microsoft.Build.Utilities.HostObjectInitializationStatus InitializeHostObject() { throw null; }
-        protected virtual void LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) { }
-        protected virtual void LogPathToTool(string toolName, string pathToTool) { }
-        protected virtual void LogToolCommand(string message) { }
-        protected virtual void ProcessStarted() { }
-        protected virtual string ResponseFileEscape(string responseString) { throw null; }
-        protected virtual bool SkipTaskExecution() { throw null; }
-        protected internal virtual bool ValidateParameters() { throw null; }
-    }
-    public static partial class TrackedDependencies
-    {
-        public static Microsoft.Build.Framework.ITaskItem[] ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) { throw null; }
-    }
-    public enum VisualStudioVersion
-    {
-        Version100 = 0,
-        Version110 = 1,
-        Version120 = 2,
-        Version140 = 3,
-        Version150 = 4,
-        Version160 = 5,
-        Version170 = 6,
-        VersionLatest = 6,
-    }
-}
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
deleted file mode 100644
index fb5b4b8da5e..00000000000
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ /dev/null
@@ -1,2172 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.BackEnd.SdkResolution
-{
-    public partial class SdkResolverException : System.Exception
-    {
-        public SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) { }
-        public Microsoft.Build.Framework.SdkResolver Resolver { get { throw null; } }
-        public Microsoft.Build.Framework.SdkReference Sdk { get { throw null; } }
-    }
-}
-namespace Microsoft.Build.Construction
-{
-    public abstract partial class ElementLocation
-    {
-        protected ElementLocation() { }
-        public abstract int Column { get; }
-        public abstract string File { get; }
-        public abstract int Line { get; }
-        public string LocationString { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public enum ImplicitImportLocation
-    {
-        None = 0,
-        Top = 1,
-        Bottom = 2,
-    }
-    public partial class ProjectChooseElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectChooseElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectOtherwiseElement OtherwiseElement { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement> WhenElements { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public sealed partial class ProjectConfigurationInSolution
-    {
-        internal ProjectConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public bool IncludeInBuild { get { throw null; } }
-        public string PlatformName { get { throw null; } }
-    }
-    public abstract partial class ProjectElement : Microsoft.Build.Framework.IProjectElement
-    {
-        internal ProjectElement() { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer> AllParents { get { throw null; } }
-        public virtual string Condition { get { throw null; } set { } }
-        public virtual Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectRootElement ContainingProject { get { throw null; } }
-        public string ElementName { get { throw null; } }
-        public string Label { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation LabelLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement NextSibling { get { throw null; } }
-        public string OuterElement { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElementContainer Parent { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement PreviousSibling { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement Clone() { throw null; }
-        protected internal virtual Microsoft.Build.Construction.ProjectElement Clone(Microsoft.Build.Construction.ProjectRootElement factory) { throw null; }
-        public virtual void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected abstract Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner);
-        protected virtual bool ShouldCloneXmlAttribute(System.Xml.XmlAttribute attribute) { throw null; }
-    }
-    public abstract partial class ProjectElementContainer : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectElementContainer() { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> AllChildren { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> Children { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> ChildrenReversed { get { throw null; } }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement FirstChild { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement LastChild { get { throw null; } }
-        public void AppendChild(Microsoft.Build.Construction.ProjectElement child) { }
-        protected internal virtual Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) { throw null; }
-        public virtual void DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) { }
-        public void InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) { }
-        public void InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) { }
-        public void PrependChild(Microsoft.Build.Construction.ProjectElement child) { }
-        public void RemoveAllChildren() { }
-        public void RemoveChild(Microsoft.Build.Construction.ProjectElement child) { }
-    }
-    public partial class ProjectExtensionsElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectExtensionsElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Content { get { throw null; } set { } }
-        public string this[string name] { get { throw null; } set { } }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectImportElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectImportElement() { }
-        public Microsoft.Build.Construction.ImplicitImportLocation ImplicitImportLocation { get { throw null; } }
-        public string MinimumVersion { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ProjectElement OriginalElement { get { throw null; } }
-        public string Project { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ProjectLocation { get { throw null; } }
-        public string Sdk { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation SdkLocation { get { throw null; } }
-        public string Version { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectImportGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectImportGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement> Imports { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectImportElement AddImport(string project) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public sealed partial class ProjectInSolution
-    {
-        internal ProjectInSolution() { }
-        public string AbsolutePath { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<string> Dependencies { get { throw null; } }
-        public string ParentProjectGuid { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution> ProjectConfigurations { get { throw null; } }
-        public string ProjectGuid { get { throw null; } }
-        public string ProjectName { get { throw null; } }
-        public Microsoft.Build.Construction.SolutionProjectType ProjectType { get { throw null; } set { } }
-        public string RelativePath { get { throw null; } }
-    }
-    public partial class ProjectItemDefinitionElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemDefinitionElement() { }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement> Metadata { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        protected override bool ShouldCloneXmlAttribute(System.Xml.XmlAttribute attribute) { throw null; }
-    }
-    public partial class ProjectItemDefinitionGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemDefinitionGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement> ItemDefinitions { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement AddItemDefinition(string itemType) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectItemElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemElement() { }
-        public string Exclude { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ExcludeLocation { get { throw null; } }
-        public bool HasMetadata { get { throw null; } }
-        public string Include { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation IncludeLocation { get { throw null; } }
-        public string ItemType { get { throw null; } set { } }
-        public string KeepDuplicates { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicatesLocation { get { throw null; } }
-        public string KeepMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation KeepMetadataLocation { get { throw null; } }
-        public string MatchOnMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataLocation { get { throw null; } }
-        public string MatchOnMetadataOptions { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataOptionsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement> Metadata { get { throw null; } }
-        public string Remove { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RemoveLocation { get { throw null; } }
-        public string RemoveMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RemoveMetadataLocation { get { throw null; } }
-        public string Update { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation UpdateLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        protected override bool ShouldCloneXmlAttribute(System.Xml.XmlAttribute attribute) { throw null; }
-    }
-    public partial class ProjectItemGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement> Items { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectMetadataElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectMetadataElement() { }
-        public bool ExpressedAsAttribute { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public string Value { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectOnErrorElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectOnErrorElement() { }
-        public string ExecuteTargetsAttribute { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ExecuteTargetsLocation { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectOtherwiseElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectOtherwiseElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement> ChooseElements { get { throw null; } }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectOutputElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectOutputElement() { }
-        public bool IsOutputItem { get { throw null; } }
-        public bool IsOutputProperty { get { throw null; } }
-        public string ItemType { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ItemTypeLocation { get { throw null; } }
-        public string PropertyName { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation PropertyNameLocation { get { throw null; } }
-        public string TaskParameter { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectPropertyElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectPropertyElement() { }
-        public string Name { get { throw null; } set { } }
-        public string Value { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectPropertyGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectPropertyGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement> Properties { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement> PropertiesReversed { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectPropertyElement AddProperty(string name, string unevaluatedValue) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement SetProperty(string name, string unevaluatedValue) { throw null; }
-    }
-    public partial class ProjectRootElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectRootElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement> ChooseElements { get { throw null; } }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string DefaultTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation DefaultTargetsLocation { get { throw null; } }
-        public string DirectoryPath { get { throw null; } }
-        public System.Text.Encoding Encoding { get { throw null; } }
-        public string EscapedFullPath { get { throw null; } }
-        public string FullPath { get { throw null; } set { } }
-        public bool HasUnsavedChanges { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement> ImportGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement> ImportGroupsReversed { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement> Imports { get { throw null; } }
-        public string InitialTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation InitialTargetsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement> ItemDefinitionGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement> ItemDefinitionGroupsReversed { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement> ItemDefinitions { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroupsReversed { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement> Items { get { throw null; } }
-        public System.DateTime LastWriteTimeWhenRead { get { throw null; } }
-        public bool PreserveFormatting { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement> Properties { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroupsReversed { get { throw null; } }
-        public string RawXml { get { throw null; } }
-        public string Sdk { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation SdkLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement> Targets { get { throw null; } }
-        public System.DateTime TimeLastChanged { get { throw null; } }
-        public string ToolsVersion { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ToolsVersionLocation { get { throw null; } }
-        public string TreatAsLocalProperty { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TreatAsLocalPropertyLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement> UsingTasks { get { throw null; } }
-        public int Version { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectImportElement AddImport(string project) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportGroupElement AddImportGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement AddItemDefinition(string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement AddItemDefinitionGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemGroupElement AddItemGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement AddProperty(string name, string value) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement AddPropertyGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectTargetElement AddTarget(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement AddUsingTask(string name, string assemblyFile, string assemblyName) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create() { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(System.Xml.XmlReader xmlReader) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) { throw null; }
-        public Microsoft.Build.Construction.ProjectChooseElement CreateChooseElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectImportElement CreateImportElement(string project) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportGroupElement CreateImportGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType, string include) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemGroupElement CreateItemGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public Microsoft.Build.Construction.ProjectOnErrorElement CreateOnErrorElement(string executeTargets) { throw null; }
-        public Microsoft.Build.Construction.ProjectOtherwiseElement CreateOtherwiseElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName) { throw null; }
-        public Microsoft.Build.Construction.ProjectExtensionsElement CreateProjectExtensionsElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement CreatePropertyElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement CreatePropertyGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectTargetElement CreateTargetElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectTaskElement CreateTaskElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) { throw null; }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectWhenElement CreateWhenElement(string condition) { throw null; }
-        public Microsoft.Build.Construction.ProjectRootElement DeepClone() { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
-        public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
-        public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
-        public void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
-        public void Save() { }
-        public void Save(System.IO.TextWriter writer) { }
-        public void Save(string path) { }
-        public void Save(string path, System.Text.Encoding encoding) { }
-        public void Save(System.Text.Encoding saveEncoding) { }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
-    }
-    public partial class ProjectSdkElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectSdkElement() { }
-        public string MinimumVersion { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public string Version { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectTargetElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectTargetElement() { }
-        public string AfterTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation AfterTargetsLocation { get { throw null; } }
-        public string BeforeTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation BeforeTargetsLocation { get { throw null; } }
-        public string DependsOnTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation DependsOnTargetsLocation { get { throw null; } }
-        public string Inputs { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation InputsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public string KeepDuplicateOutputs { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicateOutputsLocation { get { throw null; } }
-        public string Name { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation NameLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement> OnErrors { get { throw null; } }
-        public string Outputs { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation OutputsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        public string Returns { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ReturnsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement> Tasks { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemGroupElement AddItemGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement AddPropertyGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectTaskElement AddTask(string taskName) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectTaskElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectTaskElement() { }
-        public string ContinueOnError { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ContinueOnErrorLocation { get { throw null; } }
-        public string MSBuildArchitecture { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildArchitectureLocation { get { throw null; } }
-        public string MSBuildRuntime { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildRuntimeLocation { get { throw null; } }
-        public string Name { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement> Outputs { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>> ParameterLocations { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> Parameters { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputItem(string taskParameter, string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public string GetParameter(string name) { throw null; }
-        public void RemoveAllParameters() { }
-        public void RemoveParameter(string name) { }
-        public void SetParameter(string name, string unevaluatedValue) { }
-    }
-    public partial class ProjectUsingTaskBodyElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectUsingTaskBodyElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Evaluate { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation EvaluateLocation { get { throw null; } }
-        public string TaskBody { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectUsingTaskElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectUsingTaskElement() { }
-        public string Architecture { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ArchitectureLocation { get { throw null; } }
-        public string AssemblyFile { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation AssemblyFileLocation { get { throw null; } }
-        public string AssemblyName { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation AssemblyNameLocation { get { throw null; } }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement ParameterGroup { get { throw null; } }
-        public string Runtime { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RuntimeLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement TaskBody { get { throw null; } }
-        public string TaskFactory { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TaskFactoryLocation { get { throw null; } }
-        public string TaskName { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TaskNameLocation { get { throw null; } }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement AddParameterGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement AddUsingTaskBody(string evaluate, string taskBody) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectUsingTaskParameterElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectUsingTaskParameterElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Name { get { throw null; } set { } }
-        public string Output { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation OutputLocation { get { throw null; } }
-        public string ParameterType { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ParameterTypeLocation { get { throw null; } }
-        public string Required { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RequiredLocation { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectWhenElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectWhenElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement> ChooseElements { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public sealed partial class SolutionConfigurationInSolution
-    {
-        internal SolutionConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public string PlatformName { get { throw null; } }
-    }
-    public sealed partial class SolutionFile
-    {
-        internal SolutionFile() { }
-        public System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution> ProjectsByGuid { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution> ProjectsInOrder { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution> SolutionConfigurations { get { throw null; } }
-        public string GetDefaultConfigurationName() { throw null; }
-        public string GetDefaultPlatformName() { throw null; }
-        public static Microsoft.Build.Construction.SolutionFile Parse(string solutionFile) { throw null; }
-    }
-    public enum SolutionProjectType
-    {
-        Unknown = 0,
-        KnownToBeMSBuildFormat = 1,
-        SolutionFolder = 2,
-        WebProject = 3,
-        WebDeploymentProject = 4,
-        EtpSubProject = 5,
-        SharedProject = 6,
-    }
-    public partial class UsingTaskParameterGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal UsingTaskParameterGroupElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement> Parameters { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement AddParameter(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement AddParameter(string name, string output, string required, string parameterType) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-}
-namespace Microsoft.Build.Definition
-{
-    public partial class ProjectOptions
-    {
-        public ProjectOptions() { }
-        public Microsoft.Build.Evaluation.Context.EvaluationContext EvaluationContext { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ProjectLoadSettings LoadSettings { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get { throw null; } set { } }
-        public string SubToolsetVersion { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Evaluation
-{
-    public partial class GlobResult
-    {
-        public GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) { }
-        public System.Collections.Generic.IEnumerable<string> Excludes { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<string> IncludeGlobs { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemElement ItemElement { get { throw null; } }
-        public Microsoft.Build.Globbing.IMSBuildGlob MsBuildGlob { get { throw null; } set { } }
-        public System.Collections.Generic.IEnumerable<string> Removes { get { throw null; } set { } }
-    }
-    public static partial class MatchOnMetadataConstants
-    {
-        public const Microsoft.Build.Evaluation.MatchOnMetadataOptions MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive;
-    }
-    public enum MatchOnMetadataOptions
-    {
-        CaseSensitive = 0,
-        CaseInsensitive = 1,
-        PathLike = 2,
-    }
-    [System.FlagsAttribute]
-    public enum NewProjectFileOptions
-    {
-        IncludeAllOptions = -1,
-        None = 0,
-        IncludeXmlDeclaration = 1,
-        IncludeToolsVersion = 2,
-        IncludeXmlNamespace = 4,
-    }
-    public enum Operation
-    {
-        Include = 0,
-        Exclude = 1,
-        Update = 2,
-        Remove = 3,
-    }
-    public partial class Project
-    {
-        public Project() { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { }
-        public Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { }
-        public Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { }
-        public Project(string projectFile) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(System.Xml.XmlReader xmlReader) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> AllEvaluatedItems { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> AllEvaluatedProperties { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ConditionedProperties { get { throw null; } }
-        public string DirectoryPath { get { throw null; } }
-        public bool DisableMarkDirty { get { throw null; } set { } }
-        public int EvaluationCounter { get { throw null; } }
-        public string FullPath { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> Imports { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> ImportsIncludingDuplicates { get { throw null; } }
-        public bool IsBuildEnabled { get { throw null; } set { } }
-        public bool IsDirty { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition> ItemDefinitions { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> Items { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> ItemsIgnoringCondition { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> ItemTypes { get { throw null; } }
-        public int LastEvaluationId { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> Properties { get { throw null; } }
-        public bool SkipEvaluation { get { throw null; } set { } }
-        public string SubToolsetVersion { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { get { throw null; } }
-        public bool ThrowInsteadOfSplittingItemElement { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectRootElement Xml { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude) { throw null; }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude) { throw null; }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public bool Build() { throw null; }
-        public bool Build(Microsoft.Build.Framework.ILogger logger) { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string target) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance() { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public string ExpandString(string unexpandedValue) { throw null; }
-        public static Microsoft.Build.Evaluation.Project FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static Microsoft.Build.Evaluation.Project FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static Microsoft.Build.Evaluation.Project FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs() { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(string itemType) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItems(string itemType) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsIgnoringCondition(string itemType) { throw null; }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> GetLogicalProject() { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name) { throw null; }
-        public string GetPropertyValue(string name) { throw null; }
-        public static string GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) { throw null; }
-        public void MarkDirty() { }
-        public void ReevaluateIfNecessary() { }
-        public void ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { }
-        public bool RemoveGlobalProperty(string name) { throw null; }
-        public bool RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) { throw null; }
-        public void RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) { }
-        public bool RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) { throw null; }
-        public void Save() { }
-        public void Save(System.IO.TextWriter writer) { }
-        public void Save(string path) { }
-        public void Save(string path, System.Text.Encoding encoding) { }
-        public void Save(System.Text.Encoding encoding) { }
-        public void SaveLogicalProject(System.IO.TextWriter writer) { }
-        public bool SetGlobalProperty(string name, string escapedValue) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue) { throw null; }
-    }
-    public partial class ProjectChangedEventArgs : System.EventArgs
-    {
-        internal ProjectChangedEventArgs() { }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-    }
-    public partial class ProjectCollection : System.IDisposable
-    {
-        public ProjectCollection() { }
-        public ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) { }
-        public int Count { get { throw null; } }
-        public string DefaultToolsVersion { get { throw null; } set { } }
-        public bool DisableMarkDirty { get { throw null; } set { } }
-        public static string DisplayVersion { get { throw null; } }
-        public static Microsoft.Build.Evaluation.ProjectCollection GlobalProjectCollection { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } set { } }
-        public bool IsBuildEnabled { get { throw null; } set { } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project> LoadedProjects { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger> Loggers { get { throw null; } }
-        public bool OnlyLogCriticalEvents { get { throw null; } set { } }
-        public bool SkipEvaluation { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ToolsetDefinitionLocations ToolsetLocations { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset> Toolsets { get { throw null; } }
-        public static System.Version Version { get { throw null; } }
-        public event Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler ProjectAdded { add { } remove { } }
-        public event System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs> ProjectChanged { add { } remove { } }
-        public event System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs> ProjectCollectionChanged { add { } remove { } }
-        public event System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs> ProjectXmlChanged { add { } remove { } }
-        public void AddToolset(Microsoft.Build.Evaluation.Toolset toolset) { }
-        public bool ContainsToolset(string toolsVersion) { throw null; }
-        public void Dispose() { }
-        protected virtual void Dispose(bool disposing) { }
-        public static string Escape(string unescapedString) { throw null; }
-        public string GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance GetGlobalProperty(string name) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project> GetLoadedProjects(string fullPath) { throw null; }
-        public Microsoft.Build.Evaluation.Toolset GetToolset(string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(string fileName) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(string fileName, string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(System.Xml.XmlReader xmlReader) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) { throw null; }
-        public void RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { }
-        public void RegisterLogger(Microsoft.Build.Framework.ILogger logger) { }
-        public void RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { }
-        public void RemoveAllToolsets() { }
-        public bool RemoveGlobalProperty(string name) { throw null; }
-        public bool RemoveToolset(string toolsVersion) { throw null; }
-        public void SetGlobalProperty(string name, string value) { }
-        public bool TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) { throw null; }
-        public static string Unescape(string escapedString) { throw null; }
-        public void UnloadAllProjects() { }
-        public void UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) { }
-        public void UnloadProject(Microsoft.Build.Evaluation.Project project) { }
-        public void UnregisterAllLoggers() { }
-        public delegate void ProjectAddedEventHandler(object sender, Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs e);
-        public partial class ProjectAddedToProjectCollectionEventArgs : System.EventArgs
-        {
-            public ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) { }
-            public Microsoft.Build.Construction.ProjectRootElement ProjectRootElement { get { throw null; } }
-        }
-    }
-    public partial class ProjectCollectionChangedEventArgs : System.EventArgs
-    {
-        internal ProjectCollectionChangedEventArgs() { }
-        public Microsoft.Build.Evaluation.ProjectCollectionChangedState Changed { get { throw null; } }
-    }
-    public enum ProjectCollectionChangedState
-    {
-        DefaultToolsVersion = 0,
-        Toolsets = 1,
-        Loggers = 2,
-        GlobalProperties = 3,
-        IsBuildEnabled = 4,
-        OnlyLogCriticalEvents = 5,
-        HostServices = 6,
-        DisableMarkDirty = 7,
-        SkipEvaluation = 8,
-    }
-    public partial class ProjectItem
-    {
-        internal ProjectItem() { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata> DirectMetadata { get { throw null; } }
-        public int DirectMetadataCount { get { throw null; } }
-        public string EvaluatedInclude { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public string ItemType { get { throw null; } set { } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public string UnevaluatedInclude { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ProjectItemElement Xml { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name) { throw null; }
-        public string GetMetadataValue(string name) { throw null; }
-        public bool HasMetadata(string name) { throw null; }
-        public bool RemoveMetadata(string name) { throw null; }
-        public void Rename(string name) { }
-        public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) { throw null; }
-    }
-    public partial class ProjectItemDefinition
-    {
-        internal ProjectItemDefinition() { }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name) { throw null; }
-        public string GetMetadataValue(string name) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue) { throw null; }
-    }
-    [System.FlagsAttribute]
-    public enum ProjectLoadSettings
-    {
-        Default = 0,
-        IgnoreMissingImports = 1,
-        RecordDuplicateButNotCircularImports = 2,
-        RejectCircularImports = 4,
-        RecordEvaluatedItemElements = 8,
-        IgnoreEmptyImports = 16,
-        DoNotEvaluateElementsWithFalseCondition = 32,
-        IgnoreInvalidImports = 64,
-        ProfileEvaluation = 128,
-        FailOnUnresolvedSdk = 256,
-    }
-    public partial class ProjectMetadata : System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>
-    {
-        internal ProjectMetadata() { }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string EvaluatedValue { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectMetadata Predecessor { get { throw null; } }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public string UnevaluatedValue { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ProjectMetadataElement Xml { get { throw null; } }
-        bool System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>.Equals(Microsoft.Build.Evaluation.ProjectMetadata other) { throw null; }
-    }
-    public abstract partial class ProjectProperty : System.IEquatable<Microsoft.Build.Evaluation.ProjectProperty>
-    {
-        internal ProjectProperty() { }
-        public string EvaluatedValue { get { throw null; } }
-        public abstract bool IsEnvironmentProperty { get; }
-        public abstract bool IsGlobalProperty { get; }
-        public abstract bool IsImported { get; }
-        public abstract bool IsReservedProperty { get; }
-        public abstract string Name { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectProperty Predecessor { get; }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public abstract string UnevaluatedValue { get; set; }
-        public abstract Microsoft.Build.Construction.ProjectPropertyElement Xml { get; }
-        bool System.IEquatable<Microsoft.Build.Evaluation.ProjectProperty>.Equals(Microsoft.Build.Evaluation.ProjectProperty other) { throw null; }
-    }
-    public partial class ProjectXmlChangedEventArgs : System.EventArgs
-    {
-        internal ProjectXmlChangedEventArgs() { }
-        public Microsoft.Build.Construction.ProjectRootElement ProjectXml { get { throw null; } }
-        public string Reason { get { throw null; } }
-    }
-    [System.FlagsAttribute]
-    public enum Provenance
-    {
-        Undefined = 0,
-        StringLiteral = 1,
-        Glob = 2,
-        Inconclusive = 4,
-    }
-    public partial class ProvenanceResult
-    {
-        public ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) { }
-        public Microsoft.Build.Construction.ProjectItemElement ItemElement { get { throw null; } }
-        public int Occurrences { get { throw null; } }
-        public Microsoft.Build.Evaluation.Operation Operation { get { throw null; } }
-        public Microsoft.Build.Evaluation.Provenance Provenance { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ResolvedImport
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public Microsoft.Build.Construction.ProjectRootElement ImportedProject { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectImportElement ImportingElement { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public Microsoft.Build.Framework.SdkResult SdkResult { get { throw null; } }
-    }
-    public partial class SubToolset
-    {
-        internal SubToolset() { }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance> Properties { get { throw null; } }
-        public string SubToolsetVersion { get { throw null; } }
-    }
-    public partial class Toolset
-    {
-        public Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) { }
-        public Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) { }
-        public Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) { }
-        public string DefaultSubToolsetVersion { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance> Properties { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> SubToolsets { get { throw null; } }
-        public string ToolsPath { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-        public string GenerateSubToolsetVersion() { throw null; }
-        public string GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion) { throw null; }
-    }
-    [System.FlagsAttribute]
-    public enum ToolsetDefinitionLocations
-    {
-        None = 0,
-        ConfigurationFile = 1,
-        Registry = 2,
-        Default = 3,
-        Local = 4,
-    }
-}
-namespace Microsoft.Build.Evaluation.Context
-{
-    public partial class EvaluationContext
-    {
-        internal EvaluationContext() { }
-        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }
-        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
-        public enum SharingPolicy
-        {
-            Shared = 0,
-            Isolated = 1,
-        }
-    }
-}
-namespace Microsoft.Build.Exceptions
-{
-    public partial class BuildAbortedException : System.Exception
-    {
-        public BuildAbortedException() { }
-        protected BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-        public BuildAbortedException(string message) { }
-        public BuildAbortedException(string message, System.Exception innerException) { }
-        public string ErrorCode { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public partial class CircularDependencyException : System.Exception
-    {
-        protected CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public sealed partial class InternalLoggerException : System.Exception
-    {
-        public InternalLoggerException() { }
-        public InternalLoggerException(string message) { }
-        public InternalLoggerException(string message, System.Exception innerException) { }
-        public Microsoft.Build.Framework.BuildEventArgs BuildEventArgs { get { throw null; } }
-        public string ErrorCode { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public bool InitializationException { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public sealed partial class InvalidProjectFileException : System.Exception
-    {
-        public InvalidProjectFileException() { }
-        public InvalidProjectFileException(string message) { }
-        public InvalidProjectFileException(string message, System.Exception innerException) { }
-        public InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) { }
-        public string BaseMessage { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string ErrorCode { get { throw null; } }
-        public string ErrorSubcategory { get { throw null; } }
-        public bool HasBeenLogged { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public partial class InvalidToolsetDefinitionException : System.Exception
-    {
-        public InvalidToolsetDefinitionException() { }
-        protected InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-        public InvalidToolsetDefinitionException(string message) { }
-        public InvalidToolsetDefinitionException(string message, System.Exception innerException) { }
-        public InvalidToolsetDefinitionException(string message, string errorCode) { }
-        public InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) { }
-        public string ErrorCode { get { throw null; } }
-        [System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-}
-namespace Microsoft.Build.Execution
-{
-    public partial class BuildManager : System.IDisposable
-    {
-        public BuildManager() { }
-        public BuildManager(string hostName) { }
-        public static Microsoft.Build.Execution.BuildManager DefaultBuildManager { get { throw null; } }
-        public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) { }
-        public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) { }
-        public Microsoft.Build.Execution.BuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Graph.GraphBuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Execution.BuildResult BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Graph.GraphBuildResult BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
-        public void CancelAllSubmissions() { }
-        public void Dispose() { }
-        public void EndBuild() { }
-        ~BuildManager() { }
-        public Microsoft.Build.Execution.ProjectInstance GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) { throw null; }
-        public Microsoft.Build.Execution.BuildSubmission PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Graph.GraphBuildSubmission PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
-        public void ResetCaches() { }
-        public void ShutdownAllNodes() { }
-        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public readonly partial struct DeferredBuildMessage
-        {
-            private readonly object _dummy;
-            private readonly int _dummyPrimitive;
-            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null; }
-            public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
-            public string Text { get { throw null; } }
-        }
-    }
-    public partial class BuildParameters
-    {
-        public BuildParameters() { }
-        public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public bool AllowFailureWithoutError { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> BuildProcessEnvironment { get { throw null; } }
-        public System.Threading.ThreadPriority BuildThreadPriority { get { throw null; } set { } }
-        public System.Globalization.CultureInfo Culture { get { throw null; } set { } }
-        public string DefaultToolsVersion { get { throw null; } set { } }
-        public bool DetailedSummary { get { throw null; } set { } }
-        public bool DisableInProcNode { get { throw null; } set { } }
-        public bool DiscardBuildResults { get { throw null; } set { } }
-        public bool EnableNodeReuse { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> EnvironmentProperties { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> ForwardingLoggers { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } set { } }
-        public string[] InputResultsCacheFiles { get { throw null; } set { } }
-        public bool Interactive { get { throw null; } set { } }
-        public bool IsolateProjects { get { throw null; } set { } }
-        public bool LegacyThreadingSemantics { get { throw null; } set { } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> Loggers { get { throw null; } set { } }
-        public bool LogInitialPropertiesAndItems { get { throw null; } set { } }
-        public bool LogTaskInputs { get { throw null; } set { } }
-        public bool LowPriority { get { throw null; } set { } }
-        public int MaxNodeCount { get { throw null; } set { } }
-        public int MemoryUseLimit { get { throw null; } set { } }
-        public string NodeExeLocation { get { throw null; } set { } }
-        public bool OnlyLogCriticalEvents { get { throw null; } set { } }
-        public string OutputResultsCacheFile { get { throw null; } set { } }
-        public Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor ProjectCacheDescriptor { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ProjectLoadSettings ProjectLoadSettings { get { throw null; } set { } }
-        public bool ResetCaches { get { throw null; } set { } }
-        public bool SaveOperatingEnvironment { get { throw null; } set { } }
-        public bool ShutdownInProcNodeOnBuildFinish { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ToolsetDefinitionLocations ToolsetDefinitionLocations { get { throw null; } set { } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset> Toolsets { get { throw null; } }
-        public System.Globalization.CultureInfo UICulture { get { throw null; } set { } }
-        public bool UseSynchronousLogging { get { throw null; } set { } }
-        public System.Collections.Generic.ISet<string> WarningsAsErrors { get { throw null; } set { } }
-        public System.Collections.Generic.ISet<string> WarningsAsMessages { get { throw null; } set { } }
-        public Microsoft.Build.Execution.BuildParameters Clone() { throw null; }
-        public Microsoft.Build.Evaluation.Toolset GetToolset(string toolsVersion) { throw null; }
-    }
-    public partial class BuildRequestData
-    {
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
-        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
-        public string ExplicitlySpecifiedToolsVersion { get { throw null; } }
-        public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> GlobalProperties { get { throw null; } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
-        public string ProjectFullPath { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectInstance ProjectInstance { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<string> PropertiesToTransfer { get { throw null; } }
-        public Microsoft.Build.Execution.RequestedProjectState RequestedProjectState { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> TargetNames { get { throw null; } }
-    }
-    [System.FlagsAttribute]
-    public enum BuildRequestDataFlags
-    {
-        None = 0,
-        ReplaceExistingProjectInstance = 1,
-        ProvideProjectStateAfterBuild = 2,
-        IgnoreExistingProjectState = 4,
-        ClearCachesAfterBuild = 8,
-        SkipNonexistentTargets = 16,
-        ProvideSubsetOfStateAfterBuild = 32,
-        IgnoreMissingEmptyAndInvalidImports = 64,
-        FailOnUnresolvedSdk = 128,
-    }
-    public partial class BuildResult
-    {
-        public BuildResult() { }
-        public bool CircularDependency { get { throw null; } }
-        public int ConfigurationId { get { throw null; } }
-        public System.Exception Exception { get { throw null; } }
-        public int GlobalRequestId { get { throw null; } }
-        public Microsoft.Build.Execution.ITargetResult this[string target] { get { throw null; } }
-        public int NodeRequestId { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResultCode OverallResult { get { throw null; } }
-        public int ParentGlobalRequestId { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectInstance ProjectStateAfterBuild { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> ResultsByTarget { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public void AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) { }
-        public bool HasResultsForTarget(string target) { throw null; }
-        public void MergeResults(Microsoft.Build.Execution.BuildResult results) { }
-    }
-    public enum BuildResultCode
-    {
-        Success = 0,
-        Failure = 1,
-    }
-    public partial class BuildSubmission
-    {
-        internal BuildSubmission() { }
-        public object AsyncContext { get { throw null; } }
-        public Microsoft.Build.Execution.BuildManager BuildManager { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } set { } }
-        public bool IsCompleted { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public System.Threading.WaitHandle WaitHandle { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResult Execute() { throw null; }
-        public void ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) { }
-    }
-    public delegate void BuildSubmissionCompleteCallback(Microsoft.Build.Execution.BuildSubmission submission);
-    public partial class HostServices
-    {
-        public HostServices() { }
-        public Microsoft.Build.Framework.ITaskHost GetHostObject(string projectFile, string targetName, string taskName) { throw null; }
-        public Microsoft.Build.Execution.NodeAffinity GetNodeAffinity(string projectFile) { throw null; }
-        public void OnRenameProject(string oldFullPath, string newFullPath) { }
-        public void RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) { }
-        public void RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) { }
-        public void SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) { }
-        public void UnregisterProject(string projectFullPath) { }
-    }
-    public partial interface ITargetResult
-    {
-        System.Exception Exception { get; }
-        Microsoft.Build.Framework.ITaskItem[] Items { get; }
-        Microsoft.Build.Execution.TargetResultCode ResultCode { get; }
-    }
-    public enum NodeAffinity
-    {
-        InProc = 0,
-        OutOfProc = 1,
-        Any = 2,
-    }
-    public enum NodeEngineShutdownReason
-    {
-        BuildComplete = 0,
-        BuildCompleteReuse = 1,
-        ConnectionFailed = 2,
-        Error = 3,
-    }
-    public partial class OutOfProcNode
-    {
-        public OutOfProcNode() { }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { throw null; }
-    }
-    public partial class ProjectInstance
-    {
-        public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) { }
-        public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) { }
-        public ProjectInstance(string projectFile) { }
-        public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public System.Collections.Generic.List<string> DefaultTargets { get { throw null; } }
-        public string Directory { get { throw null; } }
-        public System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement> EvaluatedItemElements { get { throw null; } }
-        public int EvaluationId { get { throw null; } set { } }
-        public string FullPath { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<string> ImportPaths { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<string> ImportPathsIncludingDuplicates { get { throw null; } }
-        public System.Collections.Generic.List<string> InitialTargets { get { throw null; } }
-        public bool IsImmutable { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance> ItemDefinitions { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> Items { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> ItemTypes { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> Properties { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-        public bool TranslateEntireState { get { throw null; } set { } }
-        public Microsoft.Build.Execution.ProjectItemInstance AddItem(string itemType, string evaluatedInclude) { throw null; }
-        public Microsoft.Build.Execution.ProjectItemInstance AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public bool Build() { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance DeepCopy() { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
-        public bool EvaluateCondition(string condition) { throw null; }
-        public string ExpandString(string unexpandedValue) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
-        public static Microsoft.Build.Execution.ProjectInstance FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static Microsoft.Build.Execution.ProjectInstance FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance> GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance GetProperty(string name) { throw null; }
-        public string GetPropertyValue(string name) { throw null; }
-        public static string GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) { throw null; }
-        public bool RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
-        public bool RemoveProperty(string name) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance SetProperty(string name, string evaluatedValue) { throw null; }
-        public Microsoft.Build.Construction.ProjectRootElement ToProjectRootElement() { throw null; }
-        public void UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) { }
-    }
-    [System.FlagsAttribute]
-    public enum ProjectInstanceSettings
-    {
-        None = 0,
-        Immutable = 1,
-        ImmutableWithFastItemLookup = 3,
-    }
-    public partial class ProjectItemDefinitionInstance
-    {
-        internal ProjectItemDefinitionInstance() { }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<string> MetadataNames { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectMetadataInstance GetMetadata(string name) { throw null; }
-    }
-    public partial class ProjectItemGroupTaskInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectItemGroupTaskInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance> Items { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-    }
-    public partial class ProjectItemGroupTaskItemInstance
-    {
-        internal ProjectItemGroupTaskItemInstance() { }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Exclude { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ExcludeLocation { get { throw null; } }
-        public string Include { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation IncludeLocation { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public string KeepDuplicates { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicatesLocation { get { throw null; } }
-        public string KeepMetadata { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation KeepMetadataLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string MatchOnMetadata { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataLocation { get { throw null; } }
-        public string MatchOnMetadataOptions { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataOptionsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance> Metadata { get { throw null; } }
-        public string Remove { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation RemoveLocation { get { throw null; } }
-        public string RemoveMetadata { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation RemoveMetadataLocation { get { throw null; } }
-    }
-    public partial class ProjectItemGroupTaskMetadataInstance
-    {
-        internal ProjectItemGroupTaskMetadataInstance() { }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Value { get { throw null; } }
-    }
-    public partial class ProjectItemInstance : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
-    {
-        internal ProjectItemInstance() { }
-        public int DirectMetadataCount { get { throw null; } }
-        public string EvaluatedInclude { get { throw null; } set { } }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> MetadataNames { get { throw null; } }
-        string Microsoft.Build.Framework.ITaskItem.ItemSpec { get { throw null; } set { } }
-        System.Collections.ICollection Microsoft.Build.Framework.ITaskItem.MetadataNames { get { throw null; } }
-        string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get { throw null; } set { } }
-        public Microsoft.Build.Execution.ProjectInstance Project { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectMetadataInstance GetMetadata(string name) { throw null; }
-        public string GetMetadataValue(string name) { throw null; }
-        public bool HasMetadata(string name) { throw null; }
-        System.Collections.IDictionary Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() { throw null; }
-        void Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
-        string Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) { throw null; }
-        void Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) { }
-        System.Collections.IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() { throw null; }
-        string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string name) { throw null; }
-        void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) { }
-        public void RemoveMetadata(string metadataName) { }
-        public void SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) { }
-        public Microsoft.Build.Execution.ProjectMetadataInstance SetMetadata(string name, string evaluatedValue) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public partial class ProjectMetadataInstance : System.IEquatable<Microsoft.Build.Execution.ProjectMetadataInstance>
-    {
-        internal ProjectMetadataInstance() { }
-        public string EvaluatedValue { get { throw null; } }
-        public string Name { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectMetadataInstance DeepClone() { throw null; }
-        bool System.IEquatable<Microsoft.Build.Execution.ProjectMetadataInstance>.Equals(Microsoft.Build.Execution.ProjectMetadataInstance other) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public sealed partial class ProjectOnErrorInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectOnErrorInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string ExecuteTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ExecuteTargetsLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-    }
-    public partial class ProjectPropertyGroupTaskInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectPropertyGroupTaskInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance> Properties { get { throw null; } }
-    }
-    public partial class ProjectPropertyGroupTaskPropertyInstance
-    {
-        internal ProjectPropertyGroupTaskPropertyInstance() { }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Value { get { throw null; } }
-    }
-    public partial class ProjectPropertyInstance : System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>
-    {
-        internal ProjectPropertyInstance() { }
-        public string EvaluatedValue { get { throw null; } set { } }
-        public virtual bool IsImmutable { get { throw null; } }
-        public string Name { get { throw null; } }
-        bool System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>.Equals(Microsoft.Build.Execution.ProjectPropertyInstance other) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public sealed partial class ProjectTargetInstance
-    {
-        internal ProjectTargetInstance() { }
-        public string AfterTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation AfterTargetsLocation { get { throw null; } }
-        public string BeforeTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation BeforeTargetsLocation { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild> Children { get { throw null; } }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string DependsOnTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation DependsOnTargetsLocation { get { throw null; } }
-        public string FullPath { get { throw null; } }
-        public string Inputs { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation InputsLocation { get { throw null; } }
-        public string KeepDuplicateOutputs { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicateOutputsLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance> OnErrorChildren { get { throw null; } }
-        public string Outputs { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation OutputsLocation { get { throw null; } }
-        public string Returns { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ReturnsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance> Tasks { get { throw null; } }
-    }
-    public abstract partial class ProjectTargetInstanceChild
-    {
-        protected ProjectTargetInstanceChild() { }
-        public abstract string Condition { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation ConditionLocation { get; }
-        public string FullPath { get { throw null; } }
-        public abstract Microsoft.Build.Construction.ElementLocation Location { get; }
-    }
-    public sealed partial class ProjectTaskInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectTaskInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string ContinueOnError { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ContinueOnErrorLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string MSBuildArchitecture { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildArchitectureLocation { get { throw null; } }
-        public string MSBuildRuntime { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildRuntimeLocation { get { throw null; } }
-        public string Name { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild> Outputs { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> Parameters { get { throw null; } }
-    }
-    public abstract partial class ProjectTaskInstanceChild
-    {
-        protected ProjectTaskInstanceChild() { }
-        public abstract string Condition { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation ConditionLocation { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation Location { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get; }
-    }
-    public sealed partial class ProjectTaskOutputItemInstance : Microsoft.Build.Execution.ProjectTaskInstanceChild
-    {
-        internal ProjectTaskOutputItemInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ItemTypeLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string TaskParameter { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
-    }
-    public sealed partial class ProjectTaskOutputPropertyInstance : Microsoft.Build.Execution.ProjectTaskInstanceChild
-    {
-        internal ProjectTaskOutputPropertyInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string PropertyName { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation PropertyNameLocation { get { throw null; } }
-        public string TaskParameter { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
-    }
-    public partial class RequestedProjectState
-    {
-        public RequestedProjectState() { }
-        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ItemFilters { get { throw null; } set { } }
-        public System.Collections.Generic.List<string> PropertyFilters { get { throw null; } set { } }
-    }
-    public partial class TargetResult : Microsoft.Build.Execution.ITargetResult
-    {
-        internal TargetResult() { }
-        public System.Exception Exception { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] Items { get { throw null; } }
-        public Microsoft.Build.Execution.TargetResultCode ResultCode { get { throw null; } }
-    }
-    public enum TargetResultCode : byte
-    {
-        Skipped = (byte)0,
-        Success = (byte)1,
-        Failure = (byte)2,
-    }
-}
-namespace Microsoft.Build.Experimental.ProjectCache
-{
-    public partial class CacheContext
-    {
-        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) { }
-        public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
-        public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
-        public string MSBuildExePath { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
-    }
-    public partial class CacheResult
-    {
-        internal CacheResult() { }
-        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } }
-        public Microsoft.Build.Experimental.ProjectCache.ProxyTargets ProxyTargets { get { throw null; } }
-        public Microsoft.Build.Experimental.ProjectCache.CacheResultType ResultType { get { throw null; } }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) { throw null; }
-    }
-    public enum CacheResultType
-    {
-        None = 0,
-        CacheHit = 1,
-        CacheMiss = 2,
-        CacheNotApplicable = 3,
-    }
-    public abstract partial class PluginLoggerBase
-    {
-        protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public abstract bool HasLoggedErrors { get; protected set; }
-        public abstract void LogError(string error);
-        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = default(Microsoft.Build.Framework.MessageImportance?));
-        public abstract void LogWarning(string warning);
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public readonly partial struct PluginTargetResult
-    {
-        private readonly object _dummy;
-        private readonly int _dummyPrimitive;
-        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null; }
-        public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
-        public string TargetName { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
-    }
-    public partial class ProjectCacheDescriptor
-    {
-        internal ProjectCacheDescriptor() { }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> EntryPoints { get { throw null; } }
-        public string PluginAssemblyPath { get { throw null; } }
-        public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
-        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
-        public string GetDetailedDescription() { throw null; }
-    }
-    public sealed partial class ProjectCacheException : System.Exception
-    {
-        internal ProjectCacheException() { }
-        public string ErrorCode { get { throw null; } }
-        public bool HasBeenLoggedByProjectCache { get { throw null; } }
-    }
-    public abstract partial class ProjectCachePluginBase
-    {
-        protected ProjectCachePluginBase() { }
-        public abstract System.Threading.Tasks.Task BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
-        public abstract System.Threading.Tasks.Task EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
-        public abstract System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult> GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
-    }
-    public partial class ProxyTargets
-    {
-        public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) { }
-        public System.Collections.Generic.IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap { get { throw null; } }
-    }
-}
-namespace Microsoft.Build.FileSystem
-{
-    public abstract partial class MSBuildFileSystemBase
-    {
-        protected MSBuildFileSystemBase() { }
-        public virtual bool DirectoryExists(string path) { throw null; }
-        public virtual System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
-        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
-        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
-        public virtual bool FileExists(string path) { throw null; }
-        public virtual bool FileOrDirectoryExists(string path) { throw null; }
-        public virtual System.IO.FileAttributes GetAttributes(string path) { throw null; }
-        public virtual System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) { throw null; }
-        public virtual System.DateTime GetLastWriteTimeUtc(string path) { throw null; }
-        public virtual System.IO.TextReader ReadFile(string path) { throw null; }
-        public virtual byte[] ReadFileAllBytes(string path) { throw null; }
-        public virtual string ReadFileAllText(string path) { throw null; }
-    }
-}
-namespace Microsoft.Build.Globbing
-{
-    public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
-    {
-        public CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) { }
-        public CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> Globs { get { throw null; } }
-        public bool IsMatch(string stringToMatch) { throw null; }
-    }
-    public partial interface IMSBuildGlob
-    {
-        bool IsMatch(string stringToMatch);
-    }
-    public partial class MSBuildGlob : Microsoft.Build.Globbing.IMSBuildGlob
-    {
-        internal MSBuildGlob() { }
-        public string FilenamePart { get { throw null; } }
-        public string FixedDirectoryPart { get { throw null; } }
-        public bool IsLegal { get { throw null; } }
-        public string WildcardDirectoryPart { get { throw null; } }
-        public bool IsMatch(string stringToMatch) { throw null; }
-        public Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult MatchInfo(string stringToMatch) { throw null; }
-        public static Microsoft.Build.Globbing.MSBuildGlob Parse(string fileSpec) { throw null; }
-        public static Microsoft.Build.Globbing.MSBuildGlob Parse(string globRoot, string fileSpec) { throw null; }
-        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct MatchInfoResult
-        {
-            private object _dummy;
-            private int _dummyPrimitive;
-            public string FilenamePartMatchGroup { get { throw null; } }
-            public string FixedDirectoryPartMatchGroup { get { throw null; } }
-            public bool IsMatch { get { throw null; } }
-            public string WildcardDirectoryPartMatchGroup { get { throw null; } }
-        }
-    }
-    public partial class MSBuildGlobWithGaps : Microsoft.Build.Globbing.IMSBuildGlob
-    {
-        public MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) { }
-        public MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) { }
-        public Microsoft.Build.Globbing.IMSBuildGlob Gaps { get { throw null; } }
-        public Microsoft.Build.Globbing.IMSBuildGlob MainGlob { get { throw null; } }
-        public bool IsMatch(string stringToMatch) { throw null; }
-    }
-}
-namespace Microsoft.Build.Globbing.Extensions
-{
-    public static partial class MSBuildGlobExtensions
-    {
-        public static System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob> GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) { throw null; }
-    }
-}
-namespace Microsoft.Build.Graph
-{
-    public partial class GraphBuildOptions : System.IEquatable<Microsoft.Build.Graph.GraphBuildOptions>
-    {
-        public GraphBuildOptions() { }
-        protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) { }
-        public bool Build { get { throw null; } set { } }
-        protected virtual System.Type EqualityContract { get { throw null; } }
-        public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
-        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
-        protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
-        public override string ToString() { throw null; }
-        public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
-    }
-    public sealed partial class GraphBuildRequestData
-    {
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) { }
-        public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
-        public Microsoft.Build.Graph.GraphBuildOptions GraphBuildOptions { get { throw null; } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
-        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> ProjectGraphEntryPoints { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> TargetNames { get { throw null; } }
-    }
-    public sealed partial class GraphBuildResult
-    {
-        internal GraphBuildResult() { }
-        public bool CircularDependency { get { throw null; } }
-        public System.Exception Exception { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResult this[Microsoft.Build.Graph.ProjectGraphNode node] { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResultCode OverallResult { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult> ResultsByNode { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-    }
-    public partial class GraphBuildSubmission
-    {
-        internal GraphBuildSubmission() { }
-        public object AsyncContext { get { throw null; } }
-        public Microsoft.Build.Execution.BuildManager BuildManager { get { throw null; } }
-        public Microsoft.Build.Graph.GraphBuildResult BuildResult { get { throw null; } }
-        public bool IsCompleted { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public System.Threading.WaitHandle WaitHandle { get { throw null; } }
-        public Microsoft.Build.Graph.GraphBuildResult Execute() { throw null; }
-        public void ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) { }
-    }
-    public delegate void GraphBuildSubmissionCompleteCallback(Microsoft.Build.Graph.GraphBuildSubmission submission);
-    public sealed partial class ProjectGraph
-    {
-        public ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) { }
-        public ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(string entryProjectFile) { }
-        public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) { }
-        public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { }
-        public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics ConstructionMetrics { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> EntryPointNodes { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> GraphRoots { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodes { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }
-        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public readonly partial struct GraphConstructionMetrics
-        {
-            private readonly int _dummyPrimitive;
-            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null; }
-            public System.TimeSpan ConstructionTime { get { throw null; } }
-            public int EdgeCount { get { throw null; } }
-            public int NodeCount { get { throw null; } }
-        }
-        public delegate Microsoft.Build.Execution.ProjectInstance ProjectInstanceFactoryFunc(string projectPath, System.Collections.Generic.Dictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection);
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ProjectGraphEntryPoint
-    {
-        private object _dummy;
-        public ProjectGraphEntryPoint(string projectFile) { throw null; }
-        public ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { throw null; }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-    }
-    public sealed partial class ProjectGraphNode
-    {
-        internal ProjectGraphNode() { }
-        public Microsoft.Build.Execution.ProjectInstance ProjectInstance { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectReferences { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ReferencingProjects { get { throw null; } }
-    }
-}
-namespace Microsoft.Build.Logging
-{
-    public sealed partial class BinaryLogger : Microsoft.Build.Framework.ILogger
-    {
-        public BinaryLogger() { }
-        public Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode CollectProjectImports { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Shutdown() { }
-        public enum ProjectImportsCollectionMode
-        {
-            None = 0,
-            Embed = 1,
-            ZipFile = 2,
-        }
-    }
-    public sealed partial class BinaryLogReplayEventSource : Microsoft.Build.Logging.EventArgsDispatcher
-    {
-        public BinaryLogReplayEventSource() { }
-        public void Replay(string sourceFilePath) { }
-        public void Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) { }
-    }
-    public partial class BuildEventArgsReader : System.IDisposable
-    {
-        public BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) { }
-        public void Dispose() { }
-        public Microsoft.Build.Framework.BuildEventArgs Read() { throw null; }
-    }
-    public delegate void ColorResetter();
-    public delegate void ColorSetter(System.ConsoleColor color);
-    public partial class ConfigurableForwardingLogger : Microsoft.Build.Framework.IForwardingLogger, Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public ConfigurableForwardingLogger() { }
-        public Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get { throw null; } set { } }
-        public int NodeId { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        protected virtual void ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public virtual void Shutdown() { }
-    }
-    public partial class ConsoleLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public ConsoleLogger() { }
-        public ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) { }
-        public string Parameters { get { throw null; } set { } }
-        public bool ShowSummary { get { throw null; } set { } }
-        public bool SkipProjectStartedText { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        protected Microsoft.Build.Logging.WriteHandler WriteHandler { get { throw null; } set { } }
-        public void ApplyParameter(string parameterName, string parameterValue) { }
-        public void BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) { }
-        public void BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) { }
-        public void CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) { }
-        public void ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public void MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) { }
-        public void ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) { }
-        public void ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) { }
-        public virtual void Shutdown() { }
-        public void TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) { }
-        public void TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) { }
-        public void TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) { }
-        public void TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) { }
-        public void WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) { }
-    }
-    public partial class DistributedFileLogger : Microsoft.Build.Framework.IForwardingLogger, Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public DistributedFileLogger() { }
-        public Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get { throw null; } set { } }
-        public int NodeId { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public void Shutdown() { }
-    }
-    public partial class EventArgsDispatcher : Microsoft.Build.Framework.IEventSource
-    {
-        public EventArgsDispatcher() { }
-        public event Microsoft.Build.Framework.AnyEventHandler AnyEventRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildFinishedEventHandler BuildFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildStartedEventHandler BuildStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.CustomBuildEventHandler CustomEventRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildErrorEventHandler ErrorRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildMessageEventHandler MessageRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.ProjectFinishedEventHandler ProjectFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.ProjectStartedEventHandler ProjectStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildStatusEventHandler StatusEventRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.TargetFinishedEventHandler TargetFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.TargetStartedEventHandler TargetStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.TaskFinishedEventHandler TaskFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.TaskStartedEventHandler TaskStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildWarningEventHandler WarningRaised { add { } remove { } }
-        public void Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) { }
-    }
-    public partial class FileLogger : Microsoft.Build.Logging.ConsoleLogger
-    {
-        public FileLogger() { }
-        public override void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public override void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public override void Shutdown() { }
-    }
-    public partial class ForwardingLoggerRecord
-    {
-        public ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) { }
-        public Microsoft.Build.Framework.ILogger CentralLogger { get { throw null; } }
-        public Microsoft.Build.Logging.LoggerDescription ForwardingLoggerDescription { get { throw null; } }
-    }
-    public partial class LoggerDescription
-    {
-        public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) { }
-        public bool IsOptional { get { throw null; } }
-        public string LoggerSwitchParameters { get { throw null; } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } }
-        public Microsoft.Build.Framework.ILogger CreateLogger() { throw null; }
-    }
-    public sealed partial class ProfilerLogger : Microsoft.Build.Framework.ILogger
-    {
-        public ProfilerLogger(string fileToLog) { }
-        public string FileToLog { get { throw null; } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Shutdown() { }
-    }
-    public delegate void WriteHandler(string message);
-}
-namespace Microsoft.Build.ObjectModelRemoting
-{
-    public abstract partial class ExternalProjectsProvider
-    {
-        protected ExternalProjectsProvider() { }
-        public virtual void Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) { }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project> GetLoadedProjects(string filePath);
-        public static void SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) { }
-    }
-    public partial class LinkedObjectsFactory
-    {
-        internal LinkedObjectsFactory() { }
-        public Microsoft.Build.Evaluation.ProjectCollection Collection { get { throw null; } }
-        public Microsoft.Build.Evaluation.ResolvedImport Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) { throw null; }
-        public Microsoft.Build.Construction.ProjectChooseElement Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectExtensionsElement Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportElement Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItemDefinition Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItem Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) { throw null; }
-        public Microsoft.Build.Evaluation.Project Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) { throw null; }
-        public Microsoft.Build.Construction.ProjectOnErrorElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectOtherwiseElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
-        public Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectSdkElement Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectTargetElement Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectTaskElement Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectWhenElement Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) { throw null; }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) { throw null; }
-        public static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory Get(Microsoft.Build.Evaluation.ProjectCollection collection) { throw null; }
-        public static object GetLink(object obj) { throw null; }
-        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project> GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) { throw null; }
-        public static bool IsLocal(object obj) { throw null; }
-    }
-    public abstract partial class ProjectChooseElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectChooseElementLink() { }
-    }
-    public abstract partial class ProjectElementContainerLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectElementContainerLink() { }
-        public abstract int Count { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement FirstChild { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement LastChild { get; }
-        public abstract void AddInitialChild(Microsoft.Build.Construction.ProjectElement child);
-        public static void AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) { }
-        public static Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) { throw null; }
-        public abstract Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent);
-        public abstract void InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference);
-        public abstract void InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference);
-        public abstract void RemoveChild(Microsoft.Build.Construction.ProjectElement child);
-    }
-    public abstract partial class ProjectElementLink
-    {
-        protected ProjectElementLink() { }
-        public abstract System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink> Attributes { get; }
-        public abstract Microsoft.Build.Construction.ProjectRootElement ContainingProject { get; }
-        public abstract string ElementName { get; }
-        public abstract bool ExpressedAsAttribute { get; set; }
-        public abstract Microsoft.Build.Construction.ElementLocation Location { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement NextSibling { get; }
-        public abstract string OuterElement { get; }
-        public abstract Microsoft.Build.Construction.ProjectElementContainer Parent { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement PreviousSibling { get; }
-        public abstract string PureText { get; }
-        public abstract void CopyFrom(Microsoft.Build.Construction.ProjectElement element);
-        public static Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public abstract Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner);
-        public static Microsoft.Build.Construction.ElementLocation GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) { throw null; }
-        public abstract Microsoft.Build.Construction.ElementLocation GetAttributeLocation(string attributeName);
-        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink> GetAttributes(Microsoft.Build.Construction.ProjectElement xml) { throw null; }
-        public static string GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) { throw null; }
-        public abstract string GetAttributeValue(string attributeName, bool nullIfNotExists);
-        public static bool GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) { throw null; }
-        public static string GetPureText(Microsoft.Build.Construction.ProjectElement xml) { throw null; }
-        public static void MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) { }
-        public static void SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) { }
-        public static void SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) { }
-        public abstract void SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param);
-    }
-    public abstract partial class ProjectExtensionsElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectExtensionsElementLink() { }
-        public abstract string Content { get; set; }
-        public abstract string GetSubElement(string name);
-        public abstract void SetSubElement(string name, string value);
-    }
-    public abstract partial class ProjectImportElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectImportElementLink() { }
-        public abstract Microsoft.Build.Construction.ImplicitImportLocation ImplicitImportLocation { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement OriginalElement { get; }
-    }
-    public abstract partial class ProjectImportGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectImportGroupElementLink() { }
-    }
-    public abstract partial class ProjectItemDefinitionElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemDefinitionElementLink() { }
-    }
-    public abstract partial class ProjectItemDefinitionGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemDefinitionGroupElementLink() { }
-    }
-    public abstract partial class ProjectItemDefinitionLink
-    {
-        protected ProjectItemDefinitionLink() { }
-        public abstract string ItemType { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> Metadata { get; }
-        public abstract Microsoft.Build.Evaluation.Project Project { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name);
-        public abstract string GetMetadataValue(string name);
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
-    }
-    public abstract partial class ProjectItemElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemElementLink() { }
-        public abstract void ChangeItemType(string newType);
-    }
-    public abstract partial class ProjectItemGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemGroupElementLink() { }
-    }
-    public abstract partial class ProjectItemLink
-    {
-        protected ProjectItemLink() { }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> DirectMetadata { get; }
-        public abstract string EvaluatedInclude { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> MetadataCollection { get; }
-        public abstract Microsoft.Build.Evaluation.Project Project { get; }
-        public abstract Microsoft.Build.Construction.ProjectItemElement Xml { get; }
-        public abstract void ChangeItemType(string newItemType);
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name);
-        public abstract string GetMetadataValue(string name);
-        public abstract bool HasMetadata(string name);
-        public abstract bool RemoveMetadata(string name);
-        public abstract void Rename(string name);
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);
-    }
-    public abstract partial class ProjectLink
-    {
-        protected ProjectLink() { }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> AllEvaluatedItems { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> AllEvaluatedProperties { get; }
-        public abstract System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ConditionedProperties { get; }
-        public abstract bool DisableMarkDirty { get; set; }
-        public abstract System.Collections.Generic.IDictionary<string, string> GlobalProperties { get; }
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> Imports { get; }
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> ImportsIncludingDuplicates { get; }
-        public abstract bool IsBuildEnabled { get; set; }
-        public abstract bool IsDirty { get; }
-        public abstract System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition> ItemDefinitions { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> Items { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> ItemsIgnoringCondition { get; }
-        public abstract System.Collections.Generic.ICollection<string> ItemTypes { get; }
-        public abstract int LastEvaluationId { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> Properties { get; }
-        public abstract bool SkipEvaluation { get; set; }
-        public abstract string SubToolsetVersion { get; }
-        public abstract System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { get; }
-        public abstract bool ThrowInsteadOfSplittingItemElement { get; set; }
-        public abstract string ToolsVersion { get; }
-        public abstract Microsoft.Build.Construction.ProjectRootElement Xml { get; }
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata);
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata);
-        public abstract bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract string ExpandString(string unexpandedValue);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItems(string itemType);
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude);
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsIgnoringCondition(string itemType);
-        public abstract System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> GetLogicalProject();
-        public abstract Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name);
-        public abstract string GetPropertyValue(string name);
-        public abstract void MarkDirty();
-        public abstract void ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract bool RemoveGlobalProperty(string name);
-        public abstract bool RemoveItem(Microsoft.Build.Evaluation.ProjectItem item);
-        public abstract void RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items);
-        public abstract bool RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property);
-        public abstract void SaveLogicalProject(System.IO.TextWriter writer);
-        public abstract bool SetGlobalProperty(string name, string escapedValue);
-        public abstract Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue);
-        public abstract void Unload();
-    }
-    public abstract partial class ProjectMetadataElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectMetadataElementLink() { }
-        public abstract string Value { get; set; }
-        public abstract void ChangeName(string newName);
-    }
-    public abstract partial class ProjectMetadataLink
-    {
-        protected ProjectMetadataLink() { }
-        public abstract string EvaluatedValueEscaped { get; }
-        public abstract object Parent { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata Predecessor { get; }
-        public abstract Microsoft.Build.Construction.ProjectMetadataElement Xml { get; }
-        public static string GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) { throw null; }
-        public static object GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) { throw null; }
-    }
-    public abstract partial class ProjectOnErrorElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectOnErrorElementLink() { }
-    }
-    public abstract partial class ProjectOtherwiseElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectOtherwiseElementLink() { }
-    }
-    public abstract partial class ProjectOutputElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectOutputElementLink() { }
-    }
-    public abstract partial class ProjectPropertyElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectPropertyElementLink() { }
-        public abstract string Value { get; set; }
-        public abstract void ChangeName(string newName);
-    }
-    public abstract partial class ProjectPropertyGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectPropertyGroupElementLink() { }
-    }
-    public abstract partial class ProjectPropertyLink
-    {
-        protected ProjectPropertyLink() { }
-        public abstract string EvaluatedIncludeEscaped { get; }
-        public abstract bool IsEnvironmentProperty { get; }
-        public abstract bool IsGlobalProperty { get; }
-        public abstract bool IsImported { get; }
-        public abstract bool IsReservedProperty { get; }
-        public abstract string Name { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectProperty Predecessor { get; }
-        public abstract Microsoft.Build.Evaluation.Project Project { get; }
-        public abstract string UnevaluatedValue { get; set; }
-        public abstract Microsoft.Build.Construction.ProjectPropertyElement Xml { get; }
-        public static string GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) { throw null; }
-    }
-    public abstract partial class ProjectRootElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectRootElementLink() { }
-        public abstract string DirectoryPath { get; }
-        public abstract System.Text.Encoding Encoding { get; }
-        public abstract string FullPath { get; set; }
-        public abstract bool HasUnsavedChanges { get; }
-        public abstract System.DateTime LastWriteTimeWhenRead { get; }
-        public abstract bool PreserveFormatting { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get; }
-        public abstract string RawXml { get; }
-        public abstract System.DateTime TimeLastChanged { get; }
-        public abstract int Version { get; }
-        public abstract Microsoft.Build.Construction.ProjectChooseElement CreateChooseElement();
-        public abstract Microsoft.Build.Construction.ProjectImportElement CreateImportElement(string project);
-        public abstract Microsoft.Build.Construction.ProjectImportGroupElement CreateImportGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType);
-        public abstract Microsoft.Build.Construction.ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType);
-        public abstract Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType, string include);
-        public abstract Microsoft.Build.Construction.ProjectItemGroupElement CreateItemGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue);
-        public abstract Microsoft.Build.Construction.ProjectOnErrorElement CreateOnErrorElement(string executeTargets);
-        public abstract Microsoft.Build.Construction.ProjectOtherwiseElement CreateOtherwiseElement();
-        public abstract Microsoft.Build.Construction.ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName);
-        public abstract Microsoft.Build.Construction.ProjectExtensionsElement CreateProjectExtensionsElement();
-        public abstract Microsoft.Build.Construction.ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion);
-        public abstract Microsoft.Build.Construction.ProjectPropertyElement CreatePropertyElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectPropertyGroupElement CreatePropertyGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectTargetElement CreateTargetElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectTaskElement CreateTaskElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body);
-        public abstract Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture);
-        public abstract Microsoft.Build.Construction.ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType);
-        public abstract Microsoft.Build.Construction.UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectWhenElement CreateWhenElement(string condition);
-        public abstract void MarkDirty(string reason, string param);
-        public abstract void ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting);
-        public abstract void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting);
-        public abstract void Save(System.IO.TextWriter writer);
-        public abstract void Save(System.Text.Encoding saveEncoding);
-    }
-    public abstract partial class ProjectSdkElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectSdkElementLink() { }
-    }
-    public abstract partial class ProjectTargetElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectTargetElementLink() { }
-        public abstract string Name { get; set; }
-        public abstract string Returns { set; }
-    }
-    public abstract partial class ProjectTaskElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectTaskElementLink() { }
-        public abstract System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>> ParameterLocations { get; }
-        public abstract System.Collections.Generic.IDictionary<string, string> Parameters { get; }
-        public abstract string GetParameter(string name);
-        public abstract void RemoveAllParameters();
-        public abstract void RemoveParameter(string name);
-        public abstract void SetParameter(string name, string unevaluatedValue);
-    }
-    public abstract partial class ProjectUsingTaskBodyElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectUsingTaskBodyElementLink() { }
-        public abstract string TaskBody { get; set; }
-    }
-    public abstract partial class ProjectUsingTaskElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectUsingTaskElementLink() { }
-    }
-    public abstract partial class ProjectUsingTaskParameterElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectUsingTaskParameterElementLink() { }
-        public abstract string Name { get; set; }
-    }
-    public abstract partial class ProjectWhenElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectWhenElementLink() { }
-    }
-    public abstract partial class UsingTaskParameterGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected UsingTaskParameterGroupElementLink() { }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct XmlAttributeLink
-    {
-        private object _dummy;
-        public XmlAttributeLink(string localName, string value, string namespaceUri) { throw null; }
-        public string LocalName { get { throw null; } }
-        public string NamespaceURI { get { throw null; } }
-        public string Value { get { throw null; } }
-    }
-}
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
deleted file mode 100644
index b387429467c..00000000000
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ /dev/null
@@ -1,2166 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-namespace Microsoft.Build.BackEnd.SdkResolution
-{
-    public partial class SdkResolverException : System.Exception
-    {
-        public SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) { }
-        public Microsoft.Build.Framework.SdkResolver Resolver { get { throw null; } }
-        public Microsoft.Build.Framework.SdkReference Sdk { get { throw null; } }
-    }
-}
-namespace Microsoft.Build.Construction
-{
-    public abstract partial class ElementLocation
-    {
-        protected ElementLocation() { }
-        public abstract int Column { get; }
-        public abstract string File { get; }
-        public abstract int Line { get; }
-        public string LocationString { get { throw null; } }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public enum ImplicitImportLocation
-    {
-        None = 0,
-        Top = 1,
-        Bottom = 2,
-    }
-    public partial class ProjectChooseElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectChooseElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectOtherwiseElement OtherwiseElement { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement> WhenElements { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public sealed partial class ProjectConfigurationInSolution
-    {
-        internal ProjectConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public bool IncludeInBuild { get { throw null; } }
-        public string PlatformName { get { throw null; } }
-    }
-    public abstract partial class ProjectElement : Microsoft.Build.Framework.IProjectElement
-    {
-        internal ProjectElement() { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer> AllParents { get { throw null; } }
-        public virtual string Condition { get { throw null; } set { } }
-        public virtual Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectRootElement ContainingProject { get { throw null; } }
-        public string ElementName { get { throw null; } }
-        public string Label { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation LabelLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement NextSibling { get { throw null; } }
-        public string OuterElement { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElementContainer Parent { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement PreviousSibling { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement Clone() { throw null; }
-        protected internal virtual Microsoft.Build.Construction.ProjectElement Clone(Microsoft.Build.Construction.ProjectRootElement factory) { throw null; }
-        public virtual void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected abstract Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner);
-        protected virtual bool ShouldCloneXmlAttribute(System.Xml.XmlAttribute attribute) { throw null; }
-    }
-    public abstract partial class ProjectElementContainer : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectElementContainer() { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> AllChildren { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> Children { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> ChildrenReversed { get { throw null; } }
-        public int Count { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement FirstChild { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement LastChild { get { throw null; } }
-        public void AppendChild(Microsoft.Build.Construction.ProjectElement child) { }
-        protected internal virtual Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) { throw null; }
-        public virtual void DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) { }
-        public void InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) { }
-        public void InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) { }
-        public void PrependChild(Microsoft.Build.Construction.ProjectElement child) { }
-        public void RemoveAllChildren() { }
-        public void RemoveChild(Microsoft.Build.Construction.ProjectElement child) { }
-    }
-    public partial class ProjectExtensionsElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectExtensionsElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Content { get { throw null; } set { } }
-        public string this[string name] { get { throw null; } set { } }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectImportElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectImportElement() { }
-        public Microsoft.Build.Construction.ImplicitImportLocation ImplicitImportLocation { get { throw null; } }
-        public string MinimumVersion { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ProjectElement OriginalElement { get { throw null; } }
-        public string Project { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ProjectLocation { get { throw null; } }
-        public string Sdk { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation SdkLocation { get { throw null; } }
-        public string Version { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectImportGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectImportGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement> Imports { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectImportElement AddImport(string project) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public sealed partial class ProjectInSolution
-    {
-        internal ProjectInSolution() { }
-        public string AbsolutePath { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<string> Dependencies { get { throw null; } }
-        public string ParentProjectGuid { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution> ProjectConfigurations { get { throw null; } }
-        public string ProjectGuid { get { throw null; } }
-        public string ProjectName { get { throw null; } }
-        public Microsoft.Build.Construction.SolutionProjectType ProjectType { get { throw null; } set { } }
-        public string RelativePath { get { throw null; } }
-    }
-    public partial class ProjectItemDefinitionElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemDefinitionElement() { }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement> Metadata { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        protected override bool ShouldCloneXmlAttribute(System.Xml.XmlAttribute attribute) { throw null; }
-    }
-    public partial class ProjectItemDefinitionGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemDefinitionGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement> ItemDefinitions { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement AddItemDefinition(string itemType) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectItemElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemElement() { }
-        public string Exclude { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ExcludeLocation { get { throw null; } }
-        public bool HasMetadata { get { throw null; } }
-        public string Include { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation IncludeLocation { get { throw null; } }
-        public string ItemType { get { throw null; } set { } }
-        public string KeepDuplicates { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicatesLocation { get { throw null; } }
-        public string KeepMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation KeepMetadataLocation { get { throw null; } }
-        public string MatchOnMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataLocation { get { throw null; } }
-        public string MatchOnMetadataOptions { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataOptionsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement> Metadata { get { throw null; } }
-        public string Remove { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RemoveLocation { get { throw null; } }
-        public string RemoveMetadata { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RemoveMetadataLocation { get { throw null; } }
-        public string Update { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation UpdateLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        protected override bool ShouldCloneXmlAttribute(System.Xml.XmlAttribute attribute) { throw null; }
-    }
-    public partial class ProjectItemGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectItemGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement> Items { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectMetadataElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectMetadataElement() { }
-        public bool ExpressedAsAttribute { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public string Value { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectOnErrorElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectOnErrorElement() { }
-        public string ExecuteTargetsAttribute { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ExecuteTargetsLocation { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectOtherwiseElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectOtherwiseElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement> ChooseElements { get { throw null; } }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectOutputElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectOutputElement() { }
-        public bool IsOutputItem { get { throw null; } }
-        public bool IsOutputProperty { get { throw null; } }
-        public string ItemType { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ItemTypeLocation { get { throw null; } }
-        public string PropertyName { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation PropertyNameLocation { get { throw null; } }
-        public string TaskParameter { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectPropertyElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectPropertyElement() { }
-        public string Name { get { throw null; } set { } }
-        public string Value { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectPropertyGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectPropertyGroupElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement> Properties { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement> PropertiesReversed { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectPropertyElement AddProperty(string name, string unevaluatedValue) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement SetProperty(string name, string unevaluatedValue) { throw null; }
-    }
-    public partial class ProjectRootElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectRootElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement> ChooseElements { get { throw null; } }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string DefaultTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation DefaultTargetsLocation { get { throw null; } }
-        public string DirectoryPath { get { throw null; } }
-        public System.Text.Encoding Encoding { get { throw null; } }
-        public string EscapedFullPath { get { throw null; } }
-        public string FullPath { get { throw null; } set { } }
-        public bool HasUnsavedChanges { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement> ImportGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement> ImportGroupsReversed { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement> Imports { get { throw null; } }
-        public string InitialTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation InitialTargetsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement> ItemDefinitionGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement> ItemDefinitionGroupsReversed { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement> ItemDefinitions { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroupsReversed { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement> Items { get { throw null; } }
-        public System.DateTime LastWriteTimeWhenRead { get { throw null; } }
-        public bool PreserveFormatting { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement> Properties { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroupsReversed { get { throw null; } }
-        public string RawXml { get { throw null; } }
-        public string Sdk { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation SdkLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement> Targets { get { throw null; } }
-        public System.DateTime TimeLastChanged { get { throw null; } }
-        public string ToolsVersion { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ToolsVersionLocation { get { throw null; } }
-        public string TreatAsLocalProperty { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TreatAsLocalPropertyLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement> UsingTasks { get { throw null; } }
-        public int Version { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectImportElement AddImport(string project) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportGroupElement AddImportGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement AddItemDefinition(string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement AddItemDefinitionGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemGroupElement AddItemGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement AddProperty(string name, string value) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement AddPropertyGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectTargetElement AddTarget(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement AddUsingTask(string name, string assemblyFile, string assemblyName) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create() { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(System.Xml.XmlReader xmlReader) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) { throw null; }
-        public Microsoft.Build.Construction.ProjectChooseElement CreateChooseElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectImportElement CreateImportElement(string project) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportGroupElement CreateImportGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType, string include) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemGroupElement CreateItemGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public Microsoft.Build.Construction.ProjectOnErrorElement CreateOnErrorElement(string executeTargets) { throw null; }
-        public Microsoft.Build.Construction.ProjectOtherwiseElement CreateOtherwiseElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName) { throw null; }
-        public Microsoft.Build.Construction.ProjectExtensionsElement CreateProjectExtensionsElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement CreatePropertyElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement CreatePropertyGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectTargetElement CreateTargetElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectTaskElement CreateTaskElement(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) { throw null; }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement() { throw null; }
-        public Microsoft.Build.Construction.ProjectWhenElement CreateWhenElement(string condition) { throw null; }
-        public Microsoft.Build.Construction.ProjectRootElement DeepClone() { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
-        public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
-        public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
-        public void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
-        public void Save() { }
-        public void Save(System.IO.TextWriter writer) { }
-        public void Save(string path) { }
-        public void Save(string path, System.Text.Encoding encoding) { }
-        public void Save(System.Text.Encoding saveEncoding) { }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
-    }
-    public partial class ProjectSdkElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectSdkElement() { }
-        public string MinimumVersion { get { throw null; } set { } }
-        public string Name { get { throw null; } set { } }
-        public string Version { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectTargetElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectTargetElement() { }
-        public string AfterTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation AfterTargetsLocation { get { throw null; } }
-        public string BeforeTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation BeforeTargetsLocation { get { throw null; } }
-        public string DependsOnTargets { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation DependsOnTargetsLocation { get { throw null; } }
-        public string Inputs { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation InputsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public string KeepDuplicateOutputs { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicateOutputsLocation { get { throw null; } }
-        public string Name { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation NameLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement> OnErrors { get { throw null; } }
-        public string Outputs { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation OutputsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        public string Returns { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ReturnsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement> Tasks { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemGroupElement AddItemGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement AddPropertyGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectTaskElement AddTask(string taskName) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectTaskElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectTaskElement() { }
-        public string ContinueOnError { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ContinueOnErrorLocation { get { throw null; } }
-        public string MSBuildArchitecture { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildArchitectureLocation { get { throw null; } }
-        public string MSBuildRuntime { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildRuntimeLocation { get { throw null; } }
-        public string Name { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement> Outputs { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>> ParameterLocations { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> Parameters { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputItem(string taskParameter, string itemType) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition) { throw null; }
-        public override void CopyFrom(Microsoft.Build.Construction.ProjectElement element) { }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public string GetParameter(string name) { throw null; }
-        public void RemoveAllParameters() { }
-        public void RemoveParameter(string name) { }
-        public void SetParameter(string name, string unevaluatedValue) { }
-    }
-    public partial class ProjectUsingTaskBodyElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectUsingTaskBodyElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Evaluate { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation EvaluateLocation { get { throw null; } }
-        public string TaskBody { get { throw null; } set { } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectUsingTaskElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectUsingTaskElement() { }
-        public string Architecture { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ArchitectureLocation { get { throw null; } }
-        public string AssemblyFile { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation AssemblyFileLocation { get { throw null; } }
-        public string AssemblyName { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation AssemblyNameLocation { get { throw null; } }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement ParameterGroup { get { throw null; } }
-        public string Runtime { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RuntimeLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement TaskBody { get { throw null; } }
-        public string TaskFactory { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TaskFactoryLocation { get { throw null; } }
-        public string TaskName { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation TaskNameLocation { get { throw null; } }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement AddParameterGroup() { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement AddUsingTaskBody(string evaluate, string taskBody) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectUsingTaskParameterElement : Microsoft.Build.Construction.ProjectElement
-    {
-        internal ProjectUsingTaskParameterElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Name { get { throw null; } set { } }
-        public string Output { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation OutputLocation { get { throw null; } }
-        public string ParameterType { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation ParameterTypeLocation { get { throw null; } }
-        public string Required { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ElementLocation RequiredLocation { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public partial class ProjectWhenElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal ProjectWhenElement() { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement> ChooseElements { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement> ItemGroups { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement> PropertyGroups { get { throw null; } }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-    public sealed partial class SolutionConfigurationInSolution
-    {
-        internal SolutionConfigurationInSolution() { }
-        public string ConfigurationName { get { throw null; } }
-        public string FullName { get { throw null; } }
-        public string PlatformName { get { throw null; } }
-    }
-    public sealed partial class SolutionFile
-    {
-        internal SolutionFile() { }
-        public System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution> ProjectsByGuid { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution> ProjectsInOrder { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution> SolutionConfigurations { get { throw null; } }
-        public string GetDefaultConfigurationName() { throw null; }
-        public string GetDefaultPlatformName() { throw null; }
-        public static Microsoft.Build.Construction.SolutionFile Parse(string solutionFile) { throw null; }
-    }
-    public enum SolutionProjectType
-    {
-        Unknown = 0,
-        KnownToBeMSBuildFormat = 1,
-        SolutionFolder = 2,
-        WebProject = 3,
-        WebDeploymentProject = 4,
-        EtpSubProject = 5,
-        SharedProject = 6,
-    }
-    public partial class UsingTaskParameterGroupElement : Microsoft.Build.Construction.ProjectElementContainer
-    {
-        internal UsingTaskParameterGroupElement() { }
-        public override string Condition { get { throw null; } set { } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement> Parameters { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement AddParameter(string name) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement AddParameter(string name, string output, string required, string parameterType) { throw null; }
-        protected override Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-    }
-}
-namespace Microsoft.Build.Definition
-{
-    public partial class ProjectOptions
-    {
-        public ProjectOptions() { }
-        public Microsoft.Build.Evaluation.Context.EvaluationContext EvaluationContext { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ProjectLoadSettings LoadSettings { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get { throw null; } set { } }
-        public string SubToolsetVersion { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Evaluation
-{
-    public partial class GlobResult
-    {
-        public GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) { }
-        public System.Collections.Generic.IEnumerable<string> Excludes { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<string> IncludeGlobs { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectItemElement ItemElement { get { throw null; } }
-        public Microsoft.Build.Globbing.IMSBuildGlob MsBuildGlob { get { throw null; } set { } }
-        public System.Collections.Generic.IEnumerable<string> Removes { get { throw null; } set { } }
-    }
-    public static partial class MatchOnMetadataConstants
-    {
-        public const Microsoft.Build.Evaluation.MatchOnMetadataOptions MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive;
-    }
-    public enum MatchOnMetadataOptions
-    {
-        CaseSensitive = 0,
-        CaseInsensitive = 1,
-        PathLike = 2,
-    }
-    [System.FlagsAttribute]
-    public enum NewProjectFileOptions
-    {
-        IncludeAllOptions = -1,
-        None = 0,
-        IncludeXmlDeclaration = 1,
-        IncludeToolsVersion = 2,
-        IncludeXmlNamespace = 4,
-    }
-    public enum Operation
-    {
-        Include = 0,
-        Exclude = 1,
-        Update = 2,
-        Remove = 3,
-    }
-    public partial class Project
-    {
-        public Project() { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { }
-        public Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { }
-        public Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) { }
-        public Project(string projectFile) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(System.Xml.XmlReader xmlReader) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) { }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> AllEvaluatedItems { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> AllEvaluatedProperties { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ConditionedProperties { get { throw null; } }
-        public string DirectoryPath { get { throw null; } }
-        public bool DisableMarkDirty { get { throw null; } set { } }
-        public int EvaluationCounter { get { throw null; } }
-        public string FullPath { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> Imports { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> ImportsIncludingDuplicates { get { throw null; } }
-        public bool IsBuildEnabled { get { throw null; } set { } }
-        public bool IsDirty { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition> ItemDefinitions { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> Items { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> ItemsIgnoringCondition { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> ItemTypes { get { throw null; } }
-        public int LastEvaluationId { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> Properties { get { throw null; } }
-        public bool SkipEvaluation { get { throw null; } set { } }
-        public string SubToolsetVersion { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { get { throw null; } }
-        public bool ThrowInsteadOfSplittingItemElement { get { throw null; } set { } }
-        public string ToolsVersion { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectRootElement Xml { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude) { throw null; }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude) { throw null; }
-        public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public bool Build() { throw null; }
-        public bool Build(Microsoft.Build.Framework.ILogger logger) { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string target) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance() { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public string ExpandString(string unexpandedValue) { throw null; }
-        public static Microsoft.Build.Evaluation.Project FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static Microsoft.Build.Evaluation.Project FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static Microsoft.Build.Evaluation.Project FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs() { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(string itemType) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType) { throw null; }
-        public System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItems(string itemType) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsIgnoringCondition(string itemType) { throw null; }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> GetLogicalProject() { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name) { throw null; }
-        public string GetPropertyValue(string name) { throw null; }
-        public static string GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) { throw null; }
-        public void MarkDirty() { }
-        public void ReevaluateIfNecessary() { }
-        public void ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) { }
-        public bool RemoveGlobalProperty(string name) { throw null; }
-        public bool RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) { throw null; }
-        public void RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) { }
-        public bool RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) { throw null; }
-        public void Save() { }
-        public void Save(System.IO.TextWriter writer) { }
-        public void Save(string path) { }
-        public void Save(string path, System.Text.Encoding encoding) { }
-        public void Save(System.Text.Encoding encoding) { }
-        public void SaveLogicalProject(System.IO.TextWriter writer) { }
-        public bool SetGlobalProperty(string name, string escapedValue) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue) { throw null; }
-    }
-    public partial class ProjectChangedEventArgs : System.EventArgs
-    {
-        internal ProjectChangedEventArgs() { }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-    }
-    public partial class ProjectCollection : System.IDisposable
-    {
-        public ProjectCollection() { }
-        public ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) { }
-        public ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) { }
-        public int Count { get { throw null; } }
-        public string DefaultToolsVersion { get { throw null; } set { } }
-        public bool DisableMarkDirty { get { throw null; } set { } }
-        public static string DisplayVersion { get { throw null; } }
-        public static Microsoft.Build.Evaluation.ProjectCollection GlobalProjectCollection { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } set { } }
-        public bool IsBuildEnabled { get { throw null; } set { } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project> LoadedProjects { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger> Loggers { get { throw null; } }
-        public bool OnlyLogCriticalEvents { get { throw null; } set { } }
-        public bool SkipEvaluation { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ToolsetDefinitionLocations ToolsetLocations { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset> Toolsets { get { throw null; } }
-        public static System.Version Version { get { throw null; } }
-        public event Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler ProjectAdded { add { } remove { } }
-        public event System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs> ProjectChanged { add { } remove { } }
-        public event System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs> ProjectCollectionChanged { add { } remove { } }
-        public event System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs> ProjectXmlChanged { add { } remove { } }
-        public void AddToolset(Microsoft.Build.Evaluation.Toolset toolset) { }
-        public bool ContainsToolset(string toolsVersion) { throw null; }
-        public void Dispose() { }
-        protected virtual void Dispose(bool disposing) { }
-        public static string Escape(string unescapedString) { throw null; }
-        public string GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance GetGlobalProperty(string name) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project> GetLoadedProjects(string fullPath) { throw null; }
-        public Microsoft.Build.Evaluation.Toolset GetToolset(string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(string fileName) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(string fileName, string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(System.Xml.XmlReader xmlReader) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { throw null; }
-        public Microsoft.Build.Evaluation.Project LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) { throw null; }
-        public void RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { }
-        public void RegisterLogger(Microsoft.Build.Framework.ILogger logger) { }
-        public void RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { }
-        public void RemoveAllToolsets() { }
-        public bool RemoveGlobalProperty(string name) { throw null; }
-        public bool RemoveToolset(string toolsVersion) { throw null; }
-        public void SetGlobalProperty(string name, string value) { }
-        public bool TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) { throw null; }
-        public static string Unescape(string escapedString) { throw null; }
-        public void UnloadAllProjects() { }
-        public void UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) { }
-        public void UnloadProject(Microsoft.Build.Evaluation.Project project) { }
-        public void UnregisterAllLoggers() { }
-        public delegate void ProjectAddedEventHandler(object sender, Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs e);
-        public partial class ProjectAddedToProjectCollectionEventArgs : System.EventArgs
-        {
-            public ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) { }
-            public Microsoft.Build.Construction.ProjectRootElement ProjectRootElement { get { throw null; } }
-        }
-    }
-    public partial class ProjectCollectionChangedEventArgs : System.EventArgs
-    {
-        internal ProjectCollectionChangedEventArgs() { }
-        public Microsoft.Build.Evaluation.ProjectCollectionChangedState Changed { get { throw null; } }
-    }
-    public enum ProjectCollectionChangedState
-    {
-        DefaultToolsVersion = 0,
-        Toolsets = 1,
-        Loggers = 2,
-        GlobalProperties = 3,
-        IsBuildEnabled = 4,
-        OnlyLogCriticalEvents = 5,
-        HostServices = 6,
-        DisableMarkDirty = 7,
-        SkipEvaluation = 8,
-    }
-    public partial class ProjectItem
-    {
-        internal ProjectItem() { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata> DirectMetadata { get { throw null; } }
-        public int DirectMetadataCount { get { throw null; } }
-        public string EvaluatedInclude { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public string ItemType { get { throw null; } set { } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public string UnevaluatedInclude { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ProjectItemElement Xml { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name) { throw null; }
-        public string GetMetadataValue(string name) { throw null; }
-        public bool HasMetadata(string name) { throw null; }
-        public bool RemoveMetadata(string name) { throw null; }
-        public void Rename(string name) { }
-        public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) { throw null; }
-    }
-    public partial class ProjectItemDefinition
-    {
-        internal ProjectItemDefinition() { }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name) { throw null; }
-        public string GetMetadataValue(string name) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue) { throw null; }
-    }
-    [System.FlagsAttribute]
-    public enum ProjectLoadSettings
-    {
-        Default = 0,
-        IgnoreMissingImports = 1,
-        RecordDuplicateButNotCircularImports = 2,
-        RejectCircularImports = 4,
-        RecordEvaluatedItemElements = 8,
-        IgnoreEmptyImports = 16,
-        DoNotEvaluateElementsWithFalseCondition = 32,
-        IgnoreInvalidImports = 64,
-        ProfileEvaluation = 128,
-        FailOnUnresolvedSdk = 256,
-    }
-    public partial class ProjectMetadata : System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>
-    {
-        internal ProjectMetadata() { }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string EvaluatedValue { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectMetadata Predecessor { get { throw null; } }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public string UnevaluatedValue { get { throw null; } set { } }
-        public Microsoft.Build.Construction.ProjectMetadataElement Xml { get { throw null; } }
-        bool System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>.Equals(Microsoft.Build.Evaluation.ProjectMetadata other) { throw null; }
-    }
-    public abstract partial class ProjectProperty : System.IEquatable<Microsoft.Build.Evaluation.ProjectProperty>
-    {
-        internal ProjectProperty() { }
-        public string EvaluatedValue { get { throw null; } }
-        public abstract bool IsEnvironmentProperty { get; }
-        public abstract bool IsGlobalProperty { get; }
-        public abstract bool IsImported { get; }
-        public abstract bool IsReservedProperty { get; }
-        public abstract string Name { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectProperty Predecessor { get; }
-        public Microsoft.Build.Evaluation.Project Project { get { throw null; } }
-        public abstract string UnevaluatedValue { get; set; }
-        public abstract Microsoft.Build.Construction.ProjectPropertyElement Xml { get; }
-        bool System.IEquatable<Microsoft.Build.Evaluation.ProjectProperty>.Equals(Microsoft.Build.Evaluation.ProjectProperty other) { throw null; }
-    }
-    public partial class ProjectXmlChangedEventArgs : System.EventArgs
-    {
-        internal ProjectXmlChangedEventArgs() { }
-        public Microsoft.Build.Construction.ProjectRootElement ProjectXml { get { throw null; } }
-        public string Reason { get { throw null; } }
-    }
-    [System.FlagsAttribute]
-    public enum Provenance
-    {
-        Undefined = 0,
-        StringLiteral = 1,
-        Glob = 2,
-        Inconclusive = 4,
-    }
-    public partial class ProvenanceResult
-    {
-        public ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) { }
-        public Microsoft.Build.Construction.ProjectItemElement ItemElement { get { throw null; } }
-        public int Occurrences { get { throw null; } }
-        public Microsoft.Build.Evaluation.Operation Operation { get { throw null; } }
-        public Microsoft.Build.Evaluation.Provenance Provenance { get { throw null; } }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ResolvedImport
-    {
-        private object _dummy;
-        private int _dummyPrimitive;
-        public Microsoft.Build.Construction.ProjectRootElement ImportedProject { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectImportElement ImportingElement { get { throw null; } }
-        public bool IsImported { get { throw null; } }
-        public Microsoft.Build.Framework.SdkResult SdkResult { get { throw null; } }
-    }
-    public partial class SubToolset
-    {
-        internal SubToolset() { }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance> Properties { get { throw null; } }
-        public string SubToolsetVersion { get { throw null; } }
-    }
-    public partial class Toolset
-    {
-        public Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) { }
-        public Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) { }
-        public Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) { }
-        public string DefaultSubToolsetVersion { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance> Properties { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> SubToolsets { get { throw null; } }
-        public string ToolsPath { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-        public string GenerateSubToolsetVersion() { throw null; }
-        public string GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion) { throw null; }
-    }
-    [System.FlagsAttribute]
-    public enum ToolsetDefinitionLocations
-    {
-        None = 0,
-        ConfigurationFile = 1,
-        Registry = 2,
-        Default = 4,
-        Local = 4,
-    }
-}
-namespace Microsoft.Build.Evaluation.Context
-{
-    public partial class EvaluationContext
-    {
-        internal EvaluationContext() { }
-        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }
-        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
-        public enum SharingPolicy
-        {
-            Shared = 0,
-            Isolated = 1,
-        }
-    }
-}
-namespace Microsoft.Build.Exceptions
-{
-    public partial class BuildAbortedException : System.Exception
-    {
-        public BuildAbortedException() { }
-        protected BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-        public BuildAbortedException(string message) { }
-        public BuildAbortedException(string message, System.Exception innerException) { }
-        public string ErrorCode { get { throw null; } }
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public partial class CircularDependencyException : System.Exception
-    {
-        protected CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public sealed partial class InternalLoggerException : System.Exception
-    {
-        public InternalLoggerException() { }
-        public InternalLoggerException(string message) { }
-        public InternalLoggerException(string message, System.Exception innerException) { }
-        public Microsoft.Build.Framework.BuildEventArgs BuildEventArgs { get { throw null; } }
-        public string ErrorCode { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public bool InitializationException { get { throw null; } }
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public sealed partial class InvalidProjectFileException : System.Exception
-    {
-        public InvalidProjectFileException() { }
-        public InvalidProjectFileException(string message) { }
-        public InvalidProjectFileException(string message, System.Exception innerException) { }
-        public InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) { }
-        public string BaseMessage { get { throw null; } }
-        public int ColumnNumber { get { throw null; } }
-        public int EndColumnNumber { get { throw null; } }
-        public int EndLineNumber { get { throw null; } }
-        public string ErrorCode { get { throw null; } }
-        public string ErrorSubcategory { get { throw null; } }
-        public bool HasBeenLogged { get { throw null; } }
-        public string HelpKeyword { get { throw null; } }
-        public int LineNumber { get { throw null; } }
-        public override string Message { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-    public partial class InvalidToolsetDefinitionException : System.Exception
-    {
-        public InvalidToolsetDefinitionException() { }
-        protected InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-        public InvalidToolsetDefinitionException(string message) { }
-        public InvalidToolsetDefinitionException(string message, System.Exception innerException) { }
-        public InvalidToolsetDefinitionException(string message, string errorCode) { }
-        public InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) { }
-        public string ErrorCode { get { throw null; } }
-        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
-    }
-}
-namespace Microsoft.Build.Execution
-{
-    public partial class BuildManager : System.IDisposable
-    {
-        public BuildManager() { }
-        public BuildManager(string hostName) { }
-        public static Microsoft.Build.Execution.BuildManager DefaultBuildManager { get { throw null; } }
-        public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) { }
-        public void BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) { }
-        public Microsoft.Build.Execution.BuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Graph.GraphBuildResult Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Execution.BuildResult BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Graph.GraphBuildResult BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
-        public void CancelAllSubmissions() { }
-        public void Dispose() { }
-        public void EndBuild() { }
-        ~BuildManager() { }
-        public Microsoft.Build.Execution.ProjectInstance GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) { throw null; }
-        public Microsoft.Build.Execution.BuildSubmission PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) { throw null; }
-        public Microsoft.Build.Graph.GraphBuildSubmission PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) { throw null; }
-        public void ResetCaches() { }
-        public void ShutdownAllNodes() { }
-        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public readonly partial struct DeferredBuildMessage
-        {
-            private readonly object _dummy;
-            private readonly int _dummyPrimitive;
-            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null; }
-            public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
-            public string Text { get { throw null; } }
-        }
-    }
-    public partial class BuildParameters
-    {
-        public BuildParameters() { }
-        public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public bool AllowFailureWithoutError { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> BuildProcessEnvironment { get { throw null; } }
-        public System.Globalization.CultureInfo Culture { get { throw null; } set { } }
-        public string DefaultToolsVersion { get { throw null; } set { } }
-        public bool DetailedSummary { get { throw null; } set { } }
-        public bool DisableInProcNode { get { throw null; } set { } }
-        public bool DiscardBuildResults { get { throw null; } set { } }
-        public bool EnableNodeReuse { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> EnvironmentProperties { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> ForwardingLoggers { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } set { } }
-        public string[] InputResultsCacheFiles { get { throw null; } set { } }
-        public bool Interactive { get { throw null; } set { } }
-        public bool IsolateProjects { get { throw null; } set { } }
-        public bool LegacyThreadingSemantics { get { throw null; } set { } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> Loggers { get { throw null; } set { } }
-        public bool LogInitialPropertiesAndItems { get { throw null; } set { } }
-        public bool LogTaskInputs { get { throw null; } set { } }
-        public bool LowPriority { get { throw null; } set { } }
-        public int MaxNodeCount { get { throw null; } set { } }
-        public int MemoryUseLimit { get { throw null; } set { } }
-        public string NodeExeLocation { get { throw null; } set { } }
-        public bool OnlyLogCriticalEvents { get { throw null; } set { } }
-        public string OutputResultsCacheFile { get { throw null; } set { } }
-        public Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor ProjectCacheDescriptor { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ProjectLoadSettings ProjectLoadSettings { get { throw null; } set { } }
-        public bool ResetCaches { get { throw null; } set { } }
-        public bool SaveOperatingEnvironment { get { throw null; } set { } }
-        public bool ShutdownInProcNodeOnBuildFinish { get { throw null; } set { } }
-        public Microsoft.Build.Evaluation.ToolsetDefinitionLocations ToolsetDefinitionLocations { get { throw null; } set { } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset> Toolsets { get { throw null; } }
-        public System.Globalization.CultureInfo UICulture { get { throw null; } set { } }
-        public bool UseSynchronousLogging { get { throw null; } set { } }
-        public System.Collections.Generic.ISet<string> WarningsAsErrors { get { throw null; } set { } }
-        public System.Collections.Generic.ISet<string> WarningsAsMessages { get { throw null; } set { } }
-        public Microsoft.Build.Execution.BuildParameters Clone() { throw null; }
-        public Microsoft.Build.Evaluation.Toolset GetToolset(string toolsVersion) { throw null; }
-    }
-    public partial class BuildRequestData
-    {
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) { }
-        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
-        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
-        public string ExplicitlySpecifiedToolsVersion { get { throw null; } }
-        public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> GlobalProperties { get { throw null; } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
-        public string ProjectFullPath { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectInstance ProjectInstance { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<string> PropertiesToTransfer { get { throw null; } }
-        public Microsoft.Build.Execution.RequestedProjectState RequestedProjectState { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> TargetNames { get { throw null; } }
-    }
-    [System.FlagsAttribute]
-    public enum BuildRequestDataFlags
-    {
-        None = 0,
-        ReplaceExistingProjectInstance = 1,
-        ProvideProjectStateAfterBuild = 2,
-        IgnoreExistingProjectState = 4,
-        ClearCachesAfterBuild = 8,
-        SkipNonexistentTargets = 16,
-        ProvideSubsetOfStateAfterBuild = 32,
-        IgnoreMissingEmptyAndInvalidImports = 64,
-        FailOnUnresolvedSdk = 128,
-    }
-    public partial class BuildResult
-    {
-        public BuildResult() { }
-        public bool CircularDependency { get { throw null; } }
-        public int ConfigurationId { get { throw null; } }
-        public System.Exception Exception { get { throw null; } }
-        public int GlobalRequestId { get { throw null; } }
-        public Microsoft.Build.Execution.ITargetResult this[string target] { get { throw null; } }
-        public int NodeRequestId { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResultCode OverallResult { get { throw null; } }
-        public int ParentGlobalRequestId { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectInstance ProjectStateAfterBuild { get { throw null; } set { } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> ResultsByTarget { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public void AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) { }
-        public bool HasResultsForTarget(string target) { throw null; }
-        public void MergeResults(Microsoft.Build.Execution.BuildResult results) { }
-    }
-    public enum BuildResultCode
-    {
-        Success = 0,
-        Failure = 1,
-    }
-    public partial class BuildSubmission
-    {
-        internal BuildSubmission() { }
-        public object AsyncContext { get { throw null; } }
-        public Microsoft.Build.Execution.BuildManager BuildManager { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } set { } }
-        public bool IsCompleted { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public System.Threading.WaitHandle WaitHandle { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResult Execute() { throw null; }
-        public void ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) { }
-    }
-    public delegate void BuildSubmissionCompleteCallback(Microsoft.Build.Execution.BuildSubmission submission);
-    public partial class HostServices
-    {
-        public HostServices() { }
-        public Microsoft.Build.Framework.ITaskHost GetHostObject(string projectFile, string targetName, string taskName) { throw null; }
-        public Microsoft.Build.Execution.NodeAffinity GetNodeAffinity(string projectFile) { throw null; }
-        public void OnRenameProject(string oldFullPath, string newFullPath) { }
-        public void RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) { }
-        public void SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) { }
-        public void UnregisterProject(string projectFullPath) { }
-    }
-    public partial interface ITargetResult
-    {
-        System.Exception Exception { get; }
-        Microsoft.Build.Framework.ITaskItem[] Items { get; }
-        Microsoft.Build.Execution.TargetResultCode ResultCode { get; }
-    }
-    public enum NodeAffinity
-    {
-        InProc = 0,
-        OutOfProc = 1,
-        Any = 2,
-    }
-    public enum NodeEngineShutdownReason
-    {
-        BuildComplete = 0,
-        BuildCompleteReuse = 1,
-        ConnectionFailed = 2,
-        Error = 3,
-    }
-    public partial class OutOfProcNode
-    {
-        public OutOfProcNode() { }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { throw null; }
-    }
-    public partial class ProjectInstance
-    {
-        public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) { }
-        public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) { }
-        public ProjectInstance(string projectFile) { }
-        public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
-        public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public System.Collections.Generic.List<string> DefaultTargets { get { throw null; } }
-        public string Directory { get { throw null; } }
-        public System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement> EvaluatedItemElements { get { throw null; } }
-        public int EvaluationId { get { throw null; } set { } }
-        public string FullPath { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<string> ImportPaths { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyList<string> ImportPathsIncludingDuplicates { get { throw null; } }
-        public System.Collections.Generic.List<string> InitialTargets { get { throw null; } }
-        public bool IsImmutable { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance> ItemDefinitions { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> Items { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> ItemTypes { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> Properties { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { get { throw null; } }
-        public string ToolsVersion { get { throw null; } }
-        public bool TranslateEntireState { get { throw null; } set { } }
-        public Microsoft.Build.Execution.ProjectItemInstance AddItem(string itemType, string evaluatedInclude) { throw null; }
-        public Microsoft.Build.Execution.ProjectItemInstance AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
-        public bool Build() { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance DeepCopy() { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
-        public bool EvaluateCondition(string condition) { throw null; }
-        public string ExpandString(string unexpandedValue) { throw null; }
-        public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
-        public static Microsoft.Build.Execution.ProjectInstance FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static Microsoft.Build.Execution.ProjectInstance FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
-        public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance> GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) { throw null; }
-        public static string GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance GetProperty(string name) { throw null; }
-        public string GetPropertyValue(string name) { throw null; }
-        public static string GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) { throw null; }
-        public bool RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
-        public bool RemoveProperty(string name) { throw null; }
-        public Microsoft.Build.Execution.ProjectPropertyInstance SetProperty(string name, string evaluatedValue) { throw null; }
-        public Microsoft.Build.Construction.ProjectRootElement ToProjectRootElement() { throw null; }
-        public void UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) { }
-    }
-    [System.FlagsAttribute]
-    public enum ProjectInstanceSettings
-    {
-        None = 0,
-        Immutable = 1,
-        ImmutableWithFastItemLookup = 3,
-    }
-    public partial class ProjectItemDefinitionInstance
-    {
-        internal ProjectItemDefinitionInstance() { }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<string> MetadataNames { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectMetadataInstance GetMetadata(string name) { throw null; }
-    }
-    public partial class ProjectItemGroupTaskInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectItemGroupTaskInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance> Items { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-    }
-    public partial class ProjectItemGroupTaskItemInstance
-    {
-        internal ProjectItemGroupTaskItemInstance() { }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Exclude { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ExcludeLocation { get { throw null; } }
-        public string Include { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation IncludeLocation { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public string KeepDuplicates { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicatesLocation { get { throw null; } }
-        public string KeepMetadata { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation KeepMetadataLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string MatchOnMetadata { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataLocation { get { throw null; } }
-        public string MatchOnMetadataOptions { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MatchOnMetadataOptionsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance> Metadata { get { throw null; } }
-        public string Remove { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation RemoveLocation { get { throw null; } }
-        public string RemoveMetadata { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation RemoveMetadataLocation { get { throw null; } }
-    }
-    public partial class ProjectItemGroupTaskMetadataInstance
-    {
-        internal ProjectItemGroupTaskMetadataInstance() { }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Value { get { throw null; } }
-    }
-    public partial class ProjectItemInstance : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
-    {
-        internal ProjectItemInstance() { }
-        public int DirectMetadataCount { get { throw null; } }
-        public string EvaluatedInclude { get { throw null; } set { } }
-        public string ItemType { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance> Metadata { get { throw null; } }
-        public int MetadataCount { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> MetadataNames { get { throw null; } }
-        string Microsoft.Build.Framework.ITaskItem.ItemSpec { get { throw null; } set { } }
-        System.Collections.ICollection Microsoft.Build.Framework.ITaskItem.MetadataNames { get { throw null; } }
-        string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get { throw null; } set { } }
-        public Microsoft.Build.Execution.ProjectInstance Project { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectMetadataInstance GetMetadata(string name) { throw null; }
-        public string GetMetadataValue(string name) { throw null; }
-        public bool HasMetadata(string name) { throw null; }
-        System.Collections.IDictionary Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() { throw null; }
-        void Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) { }
-        string Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) { throw null; }
-        void Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) { }
-        System.Collections.IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() { throw null; }
-        string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string name) { throw null; }
-        void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) { }
-        public void RemoveMetadata(string metadataName) { }
-        public void SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) { }
-        public Microsoft.Build.Execution.ProjectMetadataInstance SetMetadata(string name, string evaluatedValue) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public partial class ProjectMetadataInstance : System.IEquatable<Microsoft.Build.Execution.ProjectMetadataInstance>
-    {
-        internal ProjectMetadataInstance() { }
-        public string EvaluatedValue { get { throw null; } }
-        public string Name { get { throw null; } }
-        public Microsoft.Build.Execution.ProjectMetadataInstance DeepClone() { throw null; }
-        bool System.IEquatable<Microsoft.Build.Execution.ProjectMetadataInstance>.Equals(Microsoft.Build.Execution.ProjectMetadataInstance other) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public sealed partial class ProjectOnErrorInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectOnErrorInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string ExecuteTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ExecuteTargetsLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-    }
-    public partial class ProjectPropertyGroupTaskInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectPropertyGroupTaskInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance> Properties { get { throw null; } }
-    }
-    public partial class ProjectPropertyGroupTaskPropertyInstance
-    {
-        internal ProjectPropertyGroupTaskPropertyInstance() { }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public string Value { get { throw null; } }
-    }
-    public partial class ProjectPropertyInstance : System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>
-    {
-        internal ProjectPropertyInstance() { }
-        public string EvaluatedValue { get { throw null; } set { } }
-        public virtual bool IsImmutable { get { throw null; } }
-        public string Name { get { throw null; } }
-        bool System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>.Equals(Microsoft.Build.Execution.ProjectPropertyInstance other) { throw null; }
-        public override string ToString() { throw null; }
-    }
-    public sealed partial class ProjectTargetInstance
-    {
-        internal ProjectTargetInstance() { }
-        public string AfterTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation AfterTargetsLocation { get { throw null; } }
-        public string BeforeTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation BeforeTargetsLocation { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild> Children { get { throw null; } }
-        public string Condition { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string DependsOnTargets { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation DependsOnTargetsLocation { get { throw null; } }
-        public string FullPath { get { throw null; } }
-        public string Inputs { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation InputsLocation { get { throw null; } }
-        public string KeepDuplicateOutputs { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation KeepDuplicateOutputsLocation { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string Name { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance> OnErrorChildren { get { throw null; } }
-        public string Outputs { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation OutputsLocation { get { throw null; } }
-        public string Returns { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ReturnsLocation { get { throw null; } }
-        public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance> Tasks { get { throw null; } }
-    }
-    public abstract partial class ProjectTargetInstanceChild
-    {
-        protected ProjectTargetInstanceChild() { }
-        public abstract string Condition { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation ConditionLocation { get; }
-        public string FullPath { get { throw null; } }
-        public abstract Microsoft.Build.Construction.ElementLocation Location { get; }
-    }
-    public sealed partial class ProjectTaskInstance : Microsoft.Build.Execution.ProjectTargetInstanceChild
-    {
-        internal ProjectTaskInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string ContinueOnError { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ContinueOnErrorLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string MSBuildArchitecture { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildArchitectureLocation { get { throw null; } }
-        public string MSBuildRuntime { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation MSBuildRuntimeLocation { get { throw null; } }
-        public string Name { get { throw null; } }
-        public System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild> Outputs { get { throw null; } }
-        public System.Collections.Generic.IDictionary<string, string> Parameters { get { throw null; } }
-    }
-    public abstract partial class ProjectTaskInstanceChild
-    {
-        protected ProjectTaskInstanceChild() { }
-        public abstract string Condition { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation ConditionLocation { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation Location { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get; }
-    }
-    public sealed partial class ProjectTaskOutputItemInstance : Microsoft.Build.Execution.ProjectTaskInstanceChild
-    {
-        internal ProjectTaskOutputItemInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string ItemType { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation ItemTypeLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string TaskParameter { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
-    }
-    public sealed partial class ProjectTaskOutputPropertyInstance : Microsoft.Build.Execution.ProjectTaskInstanceChild
-    {
-        internal ProjectTaskOutputPropertyInstance() { }
-        public override string Condition { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation Location { get { throw null; } }
-        public string PropertyName { get { throw null; } }
-        public Microsoft.Build.Construction.ElementLocation PropertyNameLocation { get { throw null; } }
-        public string TaskParameter { get { throw null; } }
-        public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
-    }
-    public partial class RequestedProjectState
-    {
-        public RequestedProjectState() { }
-        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ItemFilters { get { throw null; } set { } }
-        public System.Collections.Generic.List<string> PropertyFilters { get { throw null; } set { } }
-    }
-    public partial class TargetResult : Microsoft.Build.Execution.ITargetResult
-    {
-        internal TargetResult() { }
-        public System.Exception Exception { get { throw null; } }
-        public Microsoft.Build.Framework.ITaskItem[] Items { get { throw null; } }
-        public Microsoft.Build.Execution.TargetResultCode ResultCode { get { throw null; } }
-    }
-    public enum TargetResultCode : byte
-    {
-        Skipped = (byte)0,
-        Success = (byte)1,
-        Failure = (byte)2,
-    }
-}
-namespace Microsoft.Build.Experimental.ProjectCache
-{
-    public partial class CacheContext
-    {
-        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) { }
-        public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
-        public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
-        public string MSBuildExePath { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
-    }
-    public partial class CacheResult
-    {
-        internal CacheResult() { }
-        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } }
-        public Microsoft.Build.Experimental.ProjectCache.ProxyTargets ProxyTargets { get { throw null; } }
-        public Microsoft.Build.Experimental.ProjectCache.CacheResultType ResultType { get { throw null; } }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) { throw null; }
-    }
-    public enum CacheResultType
-    {
-        None = 0,
-        CacheHit = 1,
-        CacheMiss = 2,
-        CacheNotApplicable = 3,
-    }
-    public abstract partial class PluginLoggerBase
-    {
-        protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public abstract bool HasLoggedErrors { get; protected set; }
-        public abstract void LogError(string error);
-        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = default(Microsoft.Build.Framework.MessageImportance?));
-        public abstract void LogWarning(string warning);
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public readonly partial struct PluginTargetResult
-    {
-        private readonly object _dummy;
-        private readonly int _dummyPrimitive;
-        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null; }
-        public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
-        public string TargetName { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
-    }
-    public partial class ProjectCacheDescriptor
-    {
-        internal ProjectCacheDescriptor() { }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> EntryPoints { get { throw null; } }
-        public string PluginAssemblyPath { get { throw null; } }
-        public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
-        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
-        public string GetDetailedDescription() { throw null; }
-    }
-    public sealed partial class ProjectCacheException : System.Exception
-    {
-        internal ProjectCacheException() { }
-        public string ErrorCode { get { throw null; } }
-        public bool HasBeenLoggedByProjectCache { get { throw null; } }
-    }
-    public abstract partial class ProjectCachePluginBase
-    {
-        protected ProjectCachePluginBase() { }
-        public abstract System.Threading.Tasks.Task BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
-        public abstract System.Threading.Tasks.Task EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
-        public abstract System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult> GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
-    }
-    public partial class ProxyTargets
-    {
-        public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) { }
-        public System.Collections.Generic.IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap { get { throw null; } }
-    }
-}
-namespace Microsoft.Build.FileSystem
-{
-    public abstract partial class MSBuildFileSystemBase
-    {
-        protected MSBuildFileSystemBase() { }
-        public virtual bool DirectoryExists(string path) { throw null; }
-        public virtual System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
-        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
-        public virtual System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) { throw null; }
-        public virtual bool FileExists(string path) { throw null; }
-        public virtual bool FileOrDirectoryExists(string path) { throw null; }
-        public virtual System.IO.FileAttributes GetAttributes(string path) { throw null; }
-        public virtual System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) { throw null; }
-        public virtual System.DateTime GetLastWriteTimeUtc(string path) { throw null; }
-        public virtual System.IO.TextReader ReadFile(string path) { throw null; }
-        public virtual byte[] ReadFileAllBytes(string path) { throw null; }
-        public virtual string ReadFileAllText(string path) { throw null; }
-    }
-}
-namespace Microsoft.Build.Globbing
-{
-    public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
-    {
-        public CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) { }
-        public CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) { }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> Globs { get { throw null; } }
-        public bool IsMatch(string stringToMatch) { throw null; }
-    }
-    public partial interface IMSBuildGlob
-    {
-        bool IsMatch(string stringToMatch);
-    }
-    public partial class MSBuildGlob : Microsoft.Build.Globbing.IMSBuildGlob
-    {
-        internal MSBuildGlob() { }
-        public string FilenamePart { get { throw null; } }
-        public string FixedDirectoryPart { get { throw null; } }
-        public bool IsLegal { get { throw null; } }
-        public string WildcardDirectoryPart { get { throw null; } }
-        public bool IsMatch(string stringToMatch) { throw null; }
-        public Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult MatchInfo(string stringToMatch) { throw null; }
-        public static Microsoft.Build.Globbing.MSBuildGlob Parse(string fileSpec) { throw null; }
-        public static Microsoft.Build.Globbing.MSBuildGlob Parse(string globRoot, string fileSpec) { throw null; }
-        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct MatchInfoResult
-        {
-            private object _dummy;
-            private int _dummyPrimitive;
-            public string FilenamePartMatchGroup { get { throw null; } }
-            public string FixedDirectoryPartMatchGroup { get { throw null; } }
-            public bool IsMatch { get { throw null; } }
-            public string WildcardDirectoryPartMatchGroup { get { throw null; } }
-        }
-    }
-    public partial class MSBuildGlobWithGaps : Microsoft.Build.Globbing.IMSBuildGlob
-    {
-        public MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) { }
-        public MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) { }
-        public Microsoft.Build.Globbing.IMSBuildGlob Gaps { get { throw null; } }
-        public Microsoft.Build.Globbing.IMSBuildGlob MainGlob { get { throw null; } }
-        public bool IsMatch(string stringToMatch) { throw null; }
-    }
-}
-namespace Microsoft.Build.Globbing.Extensions
-{
-    public static partial class MSBuildGlobExtensions
-    {
-        public static System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob> GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) { throw null; }
-    }
-}
-namespace Microsoft.Build.Graph
-{
-    public partial class GraphBuildOptions : System.IEquatable<Microsoft.Build.Graph.GraphBuildOptions>
-    {
-        public GraphBuildOptions() { }
-        protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) { }
-        public bool Build { get { throw null; } set { } }
-        protected virtual System.Type EqualityContract { get { throw null; } }
-        public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
-        public override bool Equals(object obj) { throw null; }
-        public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
-        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
-        protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
-        public override string ToString() { throw null; }
-        public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
-    }
-    public sealed partial class GraphBuildRequestData
-    {
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) { }
-        public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
-        public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
-        public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
-        public Microsoft.Build.Graph.GraphBuildOptions GraphBuildOptions { get { throw null; } }
-        public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
-        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
-        public System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> ProjectGraphEntryPoints { get { throw null; } }
-        public System.Collections.Generic.ICollection<string> TargetNames { get { throw null; } }
-    }
-    public sealed partial class GraphBuildResult
-    {
-        internal GraphBuildResult() { }
-        public bool CircularDependency { get { throw null; } }
-        public System.Exception Exception { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResult this[Microsoft.Build.Graph.ProjectGraphNode node] { get { throw null; } }
-        public Microsoft.Build.Execution.BuildResultCode OverallResult { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult> ResultsByNode { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-    }
-    public partial class GraphBuildSubmission
-    {
-        internal GraphBuildSubmission() { }
-        public object AsyncContext { get { throw null; } }
-        public Microsoft.Build.Execution.BuildManager BuildManager { get { throw null; } }
-        public Microsoft.Build.Graph.GraphBuildResult BuildResult { get { throw null; } }
-        public bool IsCompleted { get { throw null; } }
-        public int SubmissionId { get { throw null; } }
-        public System.Threading.WaitHandle WaitHandle { get { throw null; } }
-        public Microsoft.Build.Graph.GraphBuildResult Execute() { throw null; }
-        public void ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) { }
-    }
-    public delegate void GraphBuildSubmissionCompleteCallback(Microsoft.Build.Graph.GraphBuildSubmission submission);
-    public sealed partial class ProjectGraph
-    {
-        public ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) { }
-        public ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) { }
-        public ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(string entryProjectFile) { }
-        public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) { }
-        public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { }
-        public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
-        public Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics ConstructionMetrics { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> EntryPointNodes { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> GraphRoots { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodes { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }
-        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public readonly partial struct GraphConstructionMetrics
-        {
-            private readonly int _dummyPrimitive;
-            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null; }
-            public System.TimeSpan ConstructionTime { get { throw null; } }
-            public int EdgeCount { get { throw null; } }
-            public int NodeCount { get { throw null; } }
-        }
-        public delegate Microsoft.Build.Execution.ProjectInstance ProjectInstanceFactoryFunc(string projectPath, System.Collections.Generic.Dictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection);
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct ProjectGraphEntryPoint
-    {
-        private object _dummy;
-        public ProjectGraphEntryPoint(string projectFile) { throw null; }
-        public ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { throw null; }
-        public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
-        public string ProjectFile { get { throw null; } }
-    }
-    public sealed partial class ProjectGraphNode
-    {
-        internal ProjectGraphNode() { }
-        public Microsoft.Build.Execution.ProjectInstance ProjectInstance { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectReferences { get { throw null; } }
-        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ReferencingProjects { get { throw null; } }
-    }
-}
-namespace Microsoft.Build.Logging
-{
-    public sealed partial class BinaryLogger : Microsoft.Build.Framework.ILogger
-    {
-        public BinaryLogger() { }
-        public Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode CollectProjectImports { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Shutdown() { }
-        public enum ProjectImportsCollectionMode
-        {
-            None = 0,
-            Embed = 1,
-            ZipFile = 2,
-        }
-    }
-    public sealed partial class BinaryLogReplayEventSource : Microsoft.Build.Logging.EventArgsDispatcher
-    {
-        public BinaryLogReplayEventSource() { }
-        public void Replay(string sourceFilePath) { }
-        public void Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) { }
-    }
-    public partial class BuildEventArgsReader : System.IDisposable
-    {
-        public BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) { }
-        public void Dispose() { }
-        public Microsoft.Build.Framework.BuildEventArgs Read() { throw null; }
-    }
-    public delegate void ColorResetter();
-    public delegate void ColorSetter(System.ConsoleColor color);
-    public partial class ConfigurableForwardingLogger : Microsoft.Build.Framework.IForwardingLogger, Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public ConfigurableForwardingLogger() { }
-        public Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get { throw null; } set { } }
-        public int NodeId { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        protected virtual void ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public virtual void Shutdown() { }
-    }
-    public partial class ConsoleLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public ConsoleLogger() { }
-        public ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) { }
-        public string Parameters { get { throw null; } set { } }
-        public bool ShowSummary { get { throw null; } set { } }
-        public bool SkipProjectStartedText { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        protected Microsoft.Build.Logging.WriteHandler WriteHandler { get { throw null; } set { } }
-        public void ApplyParameter(string parameterName, string parameterValue) { }
-        public void BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) { }
-        public void BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) { }
-        public void CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) { }
-        public void ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public virtual void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public void MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) { }
-        public void ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) { }
-        public void ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) { }
-        public virtual void Shutdown() { }
-        public void TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) { }
-        public void TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) { }
-        public void TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) { }
-        public void TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) { }
-        public void WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) { }
-    }
-    public partial class DistributedFileLogger : Microsoft.Build.Framework.IForwardingLogger, Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
-    {
-        public DistributedFileLogger() { }
-        public Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get { throw null; } set { } }
-        public int NodeId { get { throw null; } set { } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public void Shutdown() { }
-    }
-    public partial class EventArgsDispatcher : Microsoft.Build.Framework.IEventSource
-    {
-        public EventArgsDispatcher() { }
-        public event Microsoft.Build.Framework.AnyEventHandler AnyEventRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildFinishedEventHandler BuildFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildStartedEventHandler BuildStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.CustomBuildEventHandler CustomEventRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildErrorEventHandler ErrorRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildMessageEventHandler MessageRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.ProjectFinishedEventHandler ProjectFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.ProjectStartedEventHandler ProjectStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildStatusEventHandler StatusEventRaised { add { } remove { } }
-        public event Microsoft.Build.Framework.TargetFinishedEventHandler TargetFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.TargetStartedEventHandler TargetStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.TaskFinishedEventHandler TaskFinished { add { } remove { } }
-        public event Microsoft.Build.Framework.TaskStartedEventHandler TaskStarted { add { } remove { } }
-        public event Microsoft.Build.Framework.BuildWarningEventHandler WarningRaised { add { } remove { } }
-        public void Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) { }
-    }
-    public partial class FileLogger : Microsoft.Build.Logging.ConsoleLogger
-    {
-        public FileLogger() { }
-        public override void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public override void Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) { }
-        public override void Shutdown() { }
-    }
-    public partial class ForwardingLoggerRecord
-    {
-        public ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) { }
-        public Microsoft.Build.Framework.ILogger CentralLogger { get { throw null; } }
-        public Microsoft.Build.Logging.LoggerDescription ForwardingLoggerDescription { get { throw null; } }
-    }
-    public partial class LoggerDescription
-    {
-        public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
-        public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) { }
-        public bool IsOptional { get { throw null; } }
-        public string LoggerSwitchParameters { get { throw null; } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } }
-        public Microsoft.Build.Framework.ILogger CreateLogger() { throw null; }
-    }
-    public sealed partial class ProfilerLogger : Microsoft.Build.Framework.ILogger
-    {
-        public ProfilerLogger(string fileToLog) { }
-        public string FileToLog { get { throw null; } }
-        public string Parameters { get { throw null; } set { } }
-        public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
-        public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
-        public void Shutdown() { }
-    }
-    public delegate void WriteHandler(string message);
-}
-namespace Microsoft.Build.ObjectModelRemoting
-{
-    public abstract partial class ExternalProjectsProvider
-    {
-        protected ExternalProjectsProvider() { }
-        public virtual void Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) { }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project> GetLoadedProjects(string filePath);
-        public static void SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) { }
-    }
-    public partial class LinkedObjectsFactory
-    {
-        internal LinkedObjectsFactory() { }
-        public Microsoft.Build.Evaluation.ProjectCollection Collection { get { throw null; } }
-        public Microsoft.Build.Evaluation.ResolvedImport Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) { throw null; }
-        public Microsoft.Build.Construction.ProjectChooseElement Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectExtensionsElement Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportElement Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectImportGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItemDefinition Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectItemGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItem Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) { throw null; }
-        public Microsoft.Build.Evaluation.Project Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectMetadataElement Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) { throw null; }
-        public Microsoft.Build.Construction.ProjectOnErrorElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectOtherwiseElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectOutputElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectPropertyGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
-        public Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectSdkElement Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectTargetElement Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectTaskElement Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskBodyElement Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskElement Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectUsingTaskParameterElement Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) { throw null; }
-        public Microsoft.Build.Construction.ProjectWhenElement Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) { throw null; }
-        public Microsoft.Build.Construction.UsingTaskParameterGroupElement Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) { throw null; }
-        public static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory Get(Microsoft.Build.Evaluation.ProjectCollection collection) { throw null; }
-        public static object GetLink(object obj) { throw null; }
-        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project> GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) { throw null; }
-        public static bool IsLocal(object obj) { throw null; }
-    }
-    public abstract partial class ProjectChooseElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectChooseElementLink() { }
-    }
-    public abstract partial class ProjectElementContainerLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectElementContainerLink() { }
-        public abstract int Count { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement FirstChild { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement LastChild { get; }
-        public abstract void AddInitialChild(Microsoft.Build.Construction.ProjectElement child);
-        public static void AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) { }
-        public static Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) { throw null; }
-        public abstract Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent);
-        public abstract void InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference);
-        public abstract void InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference);
-        public abstract void RemoveChild(Microsoft.Build.Construction.ProjectElement child);
-    }
-    public abstract partial class ProjectElementLink
-    {
-        protected ProjectElementLink() { }
-        public abstract System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink> Attributes { get; }
-        public abstract Microsoft.Build.Construction.ProjectRootElement ContainingProject { get; }
-        public abstract string ElementName { get; }
-        public abstract bool ExpressedAsAttribute { get; set; }
-        public abstract Microsoft.Build.Construction.ElementLocation Location { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement NextSibling { get; }
-        public abstract string OuterElement { get; }
-        public abstract Microsoft.Build.Construction.ProjectElementContainer Parent { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement PreviousSibling { get; }
-        public abstract string PureText { get; }
-        public abstract void CopyFrom(Microsoft.Build.Construction.ProjectElement element);
-        public static Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) { throw null; }
-        public abstract Microsoft.Build.Construction.ProjectElement CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner);
-        public static Microsoft.Build.Construction.ElementLocation GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) { throw null; }
-        public abstract Microsoft.Build.Construction.ElementLocation GetAttributeLocation(string attributeName);
-        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink> GetAttributes(Microsoft.Build.Construction.ProjectElement xml) { throw null; }
-        public static string GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) { throw null; }
-        public abstract string GetAttributeValue(string attributeName, bool nullIfNotExists);
-        public static bool GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) { throw null; }
-        public static string GetPureText(Microsoft.Build.Construction.ProjectElement xml) { throw null; }
-        public static void MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) { }
-        public static void SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) { }
-        public static void SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) { }
-        public abstract void SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param);
-    }
-    public abstract partial class ProjectExtensionsElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectExtensionsElementLink() { }
-        public abstract string Content { get; set; }
-        public abstract string GetSubElement(string name);
-        public abstract void SetSubElement(string name, string value);
-    }
-    public abstract partial class ProjectImportElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectImportElementLink() { }
-        public abstract Microsoft.Build.Construction.ImplicitImportLocation ImplicitImportLocation { get; }
-        public abstract Microsoft.Build.Construction.ProjectElement OriginalElement { get; }
-    }
-    public abstract partial class ProjectImportGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectImportGroupElementLink() { }
-    }
-    public abstract partial class ProjectItemDefinitionElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemDefinitionElementLink() { }
-    }
-    public abstract partial class ProjectItemDefinitionGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemDefinitionGroupElementLink() { }
-    }
-    public abstract partial class ProjectItemDefinitionLink
-    {
-        protected ProjectItemDefinitionLink() { }
-        public abstract string ItemType { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> Metadata { get; }
-        public abstract Microsoft.Build.Evaluation.Project Project { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name);
-        public abstract string GetMetadataValue(string name);
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
-    }
-    public abstract partial class ProjectItemElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemElementLink() { }
-        public abstract void ChangeItemType(string newType);
-    }
-    public abstract partial class ProjectItemGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectItemGroupElementLink() { }
-    }
-    public abstract partial class ProjectItemLink
-    {
-        protected ProjectItemLink() { }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> DirectMetadata { get; }
-        public abstract string EvaluatedInclude { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> MetadataCollection { get; }
-        public abstract Microsoft.Build.Evaluation.Project Project { get; }
-        public abstract Microsoft.Build.Construction.ProjectItemElement Xml { get; }
-        public abstract void ChangeItemType(string newItemType);
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name);
-        public abstract string GetMetadataValue(string name);
-        public abstract bool HasMetadata(string name);
-        public abstract bool RemoveMetadata(string name);
-        public abstract void Rename(string name);
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);
-    }
-    public abstract partial class ProjectLink
-    {
-        protected ProjectLink() { }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> AllEvaluatedItems { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> AllEvaluatedProperties { get; }
-        public abstract System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ConditionedProperties { get; }
-        public abstract bool DisableMarkDirty { get; set; }
-        public abstract System.Collections.Generic.IDictionary<string, string> GlobalProperties { get; }
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> Imports { get; }
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport> ImportsIncludingDuplicates { get; }
-        public abstract bool IsBuildEnabled { get; set; }
-        public abstract bool IsDirty { get; }
-        public abstract System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition> ItemDefinitions { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> Items { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> ItemsIgnoringCondition { get; }
-        public abstract System.Collections.Generic.ICollection<string> ItemTypes { get; }
-        public abstract int LastEvaluationId { get; }
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> Properties { get; }
-        public abstract bool SkipEvaluation { get; set; }
-        public abstract string SubToolsetVersion { get; }
-        public abstract System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { get; }
-        public abstract bool ThrowInsteadOfSplittingItemElement { get; set; }
-        public abstract string ToolsVersion { get; }
-        public abstract Microsoft.Build.Construction.ProjectRootElement Xml { get; }
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata);
-        public abstract System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata);
-        public abstract bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract string ExpandString(string unexpandedValue);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult> GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItems(string itemType);
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude);
-        public abstract System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> GetItemsIgnoringCondition(string itemType);
-        public abstract System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> GetLogicalProject();
-        public abstract Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name);
-        public abstract string GetPropertyValue(string name);
-        public abstract void MarkDirty();
-        public abstract void ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);
-        public abstract bool RemoveGlobalProperty(string name);
-        public abstract bool RemoveItem(Microsoft.Build.Evaluation.ProjectItem item);
-        public abstract void RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items);
-        public abstract bool RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property);
-        public abstract void SaveLogicalProject(System.IO.TextWriter writer);
-        public abstract bool SetGlobalProperty(string name, string escapedValue);
-        public abstract Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue);
-        public abstract void Unload();
-    }
-    public abstract partial class ProjectMetadataElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectMetadataElementLink() { }
-        public abstract string Value { get; set; }
-        public abstract void ChangeName(string newName);
-    }
-    public abstract partial class ProjectMetadataLink
-    {
-        protected ProjectMetadataLink() { }
-        public abstract string EvaluatedValueEscaped { get; }
-        public abstract object Parent { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectMetadata Predecessor { get; }
-        public abstract Microsoft.Build.Construction.ProjectMetadataElement Xml { get; }
-        public static string GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) { throw null; }
-        public static object GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) { throw null; }
-    }
-    public abstract partial class ProjectOnErrorElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectOnErrorElementLink() { }
-    }
-    public abstract partial class ProjectOtherwiseElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectOtherwiseElementLink() { }
-    }
-    public abstract partial class ProjectOutputElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectOutputElementLink() { }
-    }
-    public abstract partial class ProjectPropertyElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectPropertyElementLink() { }
-        public abstract string Value { get; set; }
-        public abstract void ChangeName(string newName);
-    }
-    public abstract partial class ProjectPropertyGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectPropertyGroupElementLink() { }
-    }
-    public abstract partial class ProjectPropertyLink
-    {
-        protected ProjectPropertyLink() { }
-        public abstract string EvaluatedIncludeEscaped { get; }
-        public abstract bool IsEnvironmentProperty { get; }
-        public abstract bool IsGlobalProperty { get; }
-        public abstract bool IsImported { get; }
-        public abstract bool IsReservedProperty { get; }
-        public abstract string Name { get; }
-        public abstract Microsoft.Build.Evaluation.ProjectProperty Predecessor { get; }
-        public abstract Microsoft.Build.Evaluation.Project Project { get; }
-        public abstract string UnevaluatedValue { get; set; }
-        public abstract Microsoft.Build.Construction.ProjectPropertyElement Xml { get; }
-        public static string GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) { throw null; }
-    }
-    public abstract partial class ProjectRootElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectRootElementLink() { }
-        public abstract string DirectoryPath { get; }
-        public abstract System.Text.Encoding Encoding { get; }
-        public abstract string FullPath { get; set; }
-        public abstract bool HasUnsavedChanges { get; }
-        public abstract System.DateTime LastWriteTimeWhenRead { get; }
-        public abstract bool PreserveFormatting { get; }
-        public abstract Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get; }
-        public abstract string RawXml { get; }
-        public abstract System.DateTime TimeLastChanged { get; }
-        public abstract int Version { get; }
-        public abstract Microsoft.Build.Construction.ProjectChooseElement CreateChooseElement();
-        public abstract Microsoft.Build.Construction.ProjectImportElement CreateImportElement(string project);
-        public abstract Microsoft.Build.Construction.ProjectImportGroupElement CreateImportGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType);
-        public abstract Microsoft.Build.Construction.ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType);
-        public abstract Microsoft.Build.Construction.ProjectItemElement CreateItemElement(string itemType, string include);
-        public abstract Microsoft.Build.Construction.ProjectItemGroupElement CreateItemGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue);
-        public abstract Microsoft.Build.Construction.ProjectOnErrorElement CreateOnErrorElement(string executeTargets);
-        public abstract Microsoft.Build.Construction.ProjectOtherwiseElement CreateOtherwiseElement();
-        public abstract Microsoft.Build.Construction.ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName);
-        public abstract Microsoft.Build.Construction.ProjectExtensionsElement CreateProjectExtensionsElement();
-        public abstract Microsoft.Build.Construction.ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion);
-        public abstract Microsoft.Build.Construction.ProjectPropertyElement CreatePropertyElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectPropertyGroupElement CreatePropertyGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectTargetElement CreateTargetElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectTaskElement CreateTaskElement(string name);
-        public abstract Microsoft.Build.Construction.ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body);
-        public abstract Microsoft.Build.Construction.ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture);
-        public abstract Microsoft.Build.Construction.ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType);
-        public abstract Microsoft.Build.Construction.UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement();
-        public abstract Microsoft.Build.Construction.ProjectWhenElement CreateWhenElement(string condition);
-        public abstract void MarkDirty(string reason, string param);
-        public abstract void ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting);
-        public abstract void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting);
-        public abstract void Save(System.IO.TextWriter writer);
-        public abstract void Save(System.Text.Encoding saveEncoding);
-    }
-    public abstract partial class ProjectSdkElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectSdkElementLink() { }
-    }
-    public abstract partial class ProjectTargetElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectTargetElementLink() { }
-        public abstract string Name { get; set; }
-        public abstract string Returns { set; }
-    }
-    public abstract partial class ProjectTaskElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectTaskElementLink() { }
-        public abstract System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>> ParameterLocations { get; }
-        public abstract System.Collections.Generic.IDictionary<string, string> Parameters { get; }
-        public abstract string GetParameter(string name);
-        public abstract void RemoveAllParameters();
-        public abstract void RemoveParameter(string name);
-        public abstract void SetParameter(string name, string unevaluatedValue);
-    }
-    public abstract partial class ProjectUsingTaskBodyElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectUsingTaskBodyElementLink() { }
-        public abstract string TaskBody { get; set; }
-    }
-    public abstract partial class ProjectUsingTaskElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectUsingTaskElementLink() { }
-    }
-    public abstract partial class ProjectUsingTaskParameterElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-    {
-        protected ProjectUsingTaskParameterElementLink() { }
-        public abstract string Name { get; set; }
-    }
-    public abstract partial class ProjectWhenElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected ProjectWhenElementLink() { }
-    }
-    public abstract partial class UsingTaskParameterGroupElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-    {
-        protected UsingTaskParameterGroupElementLink() { }
-    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct XmlAttributeLink
-    {
-        private object _dummy;
-        public XmlAttributeLink(string localName, string value, string namespaceUri) { throw null; }
-        public string LocalName { get { throw null; } }
-        public string NamespaceURI { get { throw null; } }
-        public string Value { get { throw null; } }
-    }
-}
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index f27baefae70..6bb58a189b1 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -93,6 +93,7 @@ if ($runtime -eq "Desktop") {
 
         FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.Data.Entity.targets"
+        FileToCopy "$bootstrapBinDirectory\Microsoft.IO.Redist.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.ServiceModel.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WinFx.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WorkflowBuildExtensions.targets"
diff --git a/ref/LicenseHeader.txt b/src/Build.OM.UnitTests/AssemblyInfo.cs
similarity index 66%
rename from ref/LicenseHeader.txt
rename to src/Build.OM.UnitTests/AssemblyInfo.cs
index 394202e1d0b..7f6f30fcef9 100644
--- a/ref/LicenseHeader.txt
+++ b/src/Build.OM.UnitTests/AssemblyInfo.cs
@@ -1,2 +1,4 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 5323c0fd85e..3abcf608f97 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -3733,7 +3733,7 @@ public void GetAllGlobsShouldProduceGlobThatMatches(string itemContents, string[
 
             var getAllGlobsResult = ObjectModelHelpers.CreateInMemoryProject(projectContents).GetAllGlobs();
 
-            var uberGlob = new CompositeGlob(getAllGlobsResult.Select(r => r.MsBuildGlob).ToImmutableArray());
+            var uberGlob = CompositeGlob.Create(getAllGlobsResult.Select(r => r.MsBuildGlob));
 
             foreach (var matchingString in stringsThatShouldMatch)
             {
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 7c478d2a782..36c8a20a7f0 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -6,13 +6,12 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Engine.OM.UnitTests</AssemblyName>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
 
-    <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS</DefineConstants>
+    <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS;NO_FRAMEWORK_IVT</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -20,6 +19,8 @@
 </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
     <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
@@ -36,18 +37,12 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\Constants.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
     </Compile>
     <Compile Include="..\Shared\EncodingUtilities.cs">
       <Link>EncodingUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -63,30 +58,15 @@
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\EngineTestEnvironment.cs">
       <Link>EngineTestEnvironment.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\TestEnvironment.cs">
       <Link>TestEnvironment.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
     <Compile Include="..\Shared\FileUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build.UnitTests/AssemblyInfo.cs b/src/Build.UnitTests/AssemblyInfo.cs
index 2ea5c6cf42b..7f6f30fcef9 100644
--- a/src/Build.UnitTests/AssemblyInfo.cs
+++ b/src/Build.UnitTests/AssemblyInfo.cs
@@ -1,6 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.CompilerServices;
-
-[assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index d49cc341887..106e03beaf3 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -184,8 +184,8 @@ public void CreatableByTaskFactoryMatchingIdentity()
             SetupTaskFactory(factoryIdentityParameters, false /* don't want task host */);
 
             IDictionary<string, string> taskIdentityParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
-            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.MSBuildArchitectureValues.any);
+            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
+            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
             Assert.True(_taskFactory.TaskNameCreatableByFactory("TaskToTestFactories", taskIdentityParameters, String.Empty, null, ElementLocation.Create(".", 1, 1)));
         }
@@ -309,7 +309,7 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
             try
             {
                 IDictionary<string, string> taskParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
                 taskParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
                 createdTask = _taskFactory.CreateTaskInstance(ElementLocation.Create("MSBUILD"), null, new MockHost(), taskParameters,
@@ -406,7 +406,7 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
             try
             {
                 IDictionary<string, string> factoryParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
 
                 SetupTaskFactory(factoryParameters, false /* don't want task host */);
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 1587123afc0..761597bd4e1 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1598,7 +1598,7 @@ public void CancelledBuildWithDelay20()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST && !NO_MSBUILDTASKHOST
+#if !NO_MSBUILDTASKHOST
         // Run this test only if we expect MSBuildTaskHost to have been produced, which requires that MSBuildTaskHost.csproj
         // be built with full-framework MSBuild (so that it can target .NET 3.5).
 
@@ -1672,7 +1672,6 @@ public void CancelledBuildWithDelay40()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should
         /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
@@ -1706,7 +1705,6 @@ public void CancelledBuildInTaskHostWithDelay40()
             // Task host should not have exited prematurely
             _logger.AssertLogDoesntContain("MSB4217");
         }
-#endif
 
         /// <summary>
         /// This test verifies that builds of the same project instance in sequence are permitted.
@@ -4360,10 +4358,8 @@ public override bool Execute()
         [Theory]
         [InlineData("", false)] // regular task host, input logging disabled
         [InlineData("", true)] // regular task host, input logging enabled
-#if NETFRAMEWORK // https://github.com/microsoft/msbuild/issues/5158
         [InlineData("TaskHostFactory", false)] // OOP task host, input logging disabled
         [InlineData("TaskHostFactory", true)] // OOP task host, input logging enabled
-#endif
         public void TaskInputLoggingIsExposedToTasks(string taskFactory, bool taskInputLoggingEnabled)
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index eb37f60b029..9ccf30da8e2 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index a0a2965cc3b..68439641529 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -10,7 +11,7 @@
 namespace Microsoft.Build.UnitTests.BackEnd
 {
     /// <summary>
-    /// Tests for logging contexts. 
+    /// Tests for logging contexts.
     /// </summary>
     public class LoggingContext_Tests
     {
@@ -22,7 +23,7 @@ public LoggingContext_Tests(ITestOutputHelper outputHelper)
         }
 
         /// <summary>
-        /// A few simple tests for NodeLoggingContexts. 
+        /// A few simple tests for NodeLoggingContexts.
         /// </summary>
         [Fact]
         public void CreateValidNodeLoggingContexts()
@@ -47,9 +48,9 @@ public void CreateValidNodeLoggingContexts()
         }
 
         /// <summary>
-        /// Verifies that if an invalid node ID is passed to the NodeLoggingContext, it throws 
-        /// an exception -- this is to guarantee that if we're passing around invalid node IDs, 
-        /// we'll know about it.  
+        /// Verifies that if an invalid node ID is passed to the NodeLoggingContext, it throws
+        /// an exception -- this is to guarantee that if we're passing around invalid node IDs,
+        /// we'll know about it.
         /// </summary>
         [Fact]
         public void InvalidNodeIdOnNodeLoggingContext()
diff --git a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
index 801c8bedb38..82720f575ba 100644
--- a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index b7d3098dd5c..2476d984cbf 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -372,12 +372,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", @"
+                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
                   </PropertyGroup>
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 4005633d981..6791d729dd8 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 using Xunit;
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 486352af3f2..87152257402 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -22,6 +22,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using System.Threading;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -107,6 +108,63 @@ public void TasksNotDiscoveredWhenTaskConditionFalse()
             logger.AssertLogContains("Made it");
         }
 
+        [Fact]
+        public void CanceledTasksDoNotLogMSB4181()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_testOutput))
+            {
+                BuildManager manager = new BuildManager();
+                ProjectCollection collection = new ProjectCollection();
+
+                string contents = @"
+                    <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' ToolsVersion ='Current'>
+                     <Target Name='test'>
+                        <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(10)) + @"'/>
+                     </Target>
+                    </Project>";
+
+                MockLogger logger = new MockLogger(_testOutput);
+
+                var project = new Project(XmlReader.Create(new StringReader(contents)), null, MSBuildConstants.CurrentToolsVersion, collection)
+                {
+                    FullPath = env.CreateFile().Path
+                };
+
+                var _parameters = new BuildParameters
+                {
+                    ShutdownInProcNodeOnBuildFinish = true,
+                    Loggers = new ILogger[] { logger },
+                    EnableNodeReuse = false
+                };
+                ;
+
+                BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new string[] { "test" }, collection.HostServices);
+                manager.BeginBuild(_parameters);
+                BuildSubmission asyncResult = manager.PendBuildRequest(data);
+                asyncResult.ExecuteAsync(null, null);
+                Thread.Sleep(500);
+                manager.CancelAllSubmissions();
+                asyncResult.WaitHandle.WaitOne();
+                BuildResult result = asyncResult.BuildResult;
+                manager.EndBuild();
+
+                // No errors from cancelling a build.
+                logger.ErrorCount.ShouldBe(0);
+                // Warn because the task is being cancelled.
+                // NOTE: This assertion will fail when debugging into it because "waiting on exec to cancel" warning will be logged.
+                logger.WarningCount.ShouldBe(1);
+                // Build failed because it was cancelled.
+                result.OverallResult.ShouldBe(BuildResultCode.Failure);
+                // Should log "Cmd being cancelled because build was cancelled" warning
+                logger.AssertLogContains("MSB5021");
+                // Should NOT log "exec failed without logging error"
+                logger.AssertLogDoesntContain("MSB4181");
+
+                collection.Dispose();
+                manager.Dispose();
+            }
+        }
+
         /// <summary>
         /// Verify when task outputs are overridden the override messages are correctly displayed
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 897b6a5751f..fa4146484e9 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -12,7 +12,6 @@ namespace Microsoft.Build.Engine.UnitTests.BackEnd
     public sealed class TaskHostFactory_Tests
     {
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/microsoft/msbuild/issues/5158")]
         [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
         {
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 1db0b3935b2..e45add12e09 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -120,20 +120,20 @@ public void TestLiveTargetOutputs()
         public void CustomBuildErrorEventIsPreserved()
         {
             // Create a custom build event args that derives from MSBuild's BuildErrorEventArgs.
-            // Set a custom field on this event (FXCopRule).
-            MyCustomBuildErrorEventArgs fxcopError = new MyCustomBuildErrorEventArgs("Your code failed.");
-            fxcopError.FXCopRule = "CodeViolation";
+            // Set a custom field on this event.
+            MyCustomBuildErrorEventArgs customBuildError = new MyCustomBuildErrorEventArgs("Your code failed.");
+            customBuildError.CustomData = "CodeViolation";
 
             // Log the custom event args.  (Pretend that the task actually did this.)
-            _taskHost.LogErrorEvent(fxcopError);
+            _taskHost.LogErrorEvent(customBuildError);
 
             // Make sure our custom logger received the actual custom event and not some fake.
             Assert.True(_customLogger.LastError is MyCustomBuildErrorEventArgs); // "Expected Custom Error Event"
 
             // Make sure the special fields in the custom event match what we originally logged.
-            fxcopError = _customLogger.LastError as MyCustomBuildErrorEventArgs;
-            Assert.Equal("Your code failed.", fxcopError.Message);
-            Assert.Equal("CodeViolation", fxcopError.FXCopRule);
+            customBuildError = _customLogger.LastError as MyCustomBuildErrorEventArgs;
+            Assert.Equal("Your code failed.", customBuildError.Message);
+            Assert.Equal("CodeViolation", customBuildError.CustomData);
         }
 
         /// <summary>
@@ -146,19 +146,19 @@ public void CustomBuildErrorEventIsPreserved()
         public void CustomBuildWarningEventIsPreserved()
         {
             // Create a custom build event args that derives from MSBuild's BuildWarningEventArgs.
-            // Set a custom field on this event (FXCopRule).
-            MyCustomBuildWarningEventArgs fxcopWarning = new MyCustomBuildWarningEventArgs("Your code failed.");
-            fxcopWarning.FXCopRule = "CodeViolation";
+            // Set a custom field on this event.
+            MyCustomBuildWarningEventArgs customBuildWarning = new MyCustomBuildWarningEventArgs("Your code failed.");
+            customBuildWarning.CustomData = "CodeViolation";
 
-            _taskHost.LogWarningEvent(fxcopWarning);
+            _taskHost.LogWarningEvent(customBuildWarning);
 
             // Make sure our custom logger received the actual custom event and not some fake.
             Assert.True(_customLogger.LastWarning is MyCustomBuildWarningEventArgs); // "Expected Custom Warning Event"
 
             // Make sure the special fields in the custom event match what we originally logged.
-            fxcopWarning = _customLogger.LastWarning as MyCustomBuildWarningEventArgs;
-            Assert.Equal("Your code failed.", fxcopWarning.Message);
-            Assert.Equal("CodeViolation", fxcopWarning.FXCopRule);
+            customBuildWarning = _customLogger.LastWarning as MyCustomBuildWarningEventArgs;
+            Assert.Equal("Your code failed.", customBuildWarning.Message);
+            Assert.Equal("CodeViolation", customBuildWarning.CustomData);
         }
 
         /// <summary>
@@ -171,7 +171,7 @@ public void CustomBuildWarningEventIsPreserved()
         public void CustomBuildMessageEventIsPreserved()
         {
             // Create a custom build event args that derives from MSBuild's BuildMessageEventArgs.
-            // Set a custom field on this event (FXCopRule).
+            // Set a custom field on this event.
             MyCustomMessageEvent customMessage = new MyCustomMessageEvent("I am a message");
             customMessage.CustomMessage = "CodeViolation";
 
@@ -861,7 +861,7 @@ internal class MyCustomBuildErrorEventArgs : BuildErrorEventArgs
             /// <summary>
             /// Some custom data for the custom event.
             /// </summary>
-            private string _fxcopRule;
+            private string _customData;
 
             /// <summary>
             /// Constructor
@@ -877,16 +877,16 @@ string message
             /// <summary>
             /// Some data which can be set on the custom error event to make sure it makes it to the logger.
             /// </summary>
-            internal string FXCopRule
+            internal string CustomData
             {
                 get
                 {
-                    return _fxcopRule;
+                    return _customData;
                 }
 
                 set
                 {
-                    _fxcopRule = value;
+                    _customData = value;
                 }
             }
         }
@@ -900,7 +900,7 @@ internal class MyCustomBuildWarningEventArgs : BuildWarningEventArgs
             /// <summary>
             /// Custom data for the custom event
             /// </summary>
-            private string _fxcopRule;
+            private string _customData;
 
             /// <summary>
             /// Constructor
@@ -916,16 +916,16 @@ string message
             /// <summary>
             /// Getter for the custom data in the custom event.
             /// </summary>
-            internal string FXCopRule
+            internal string CustomData
             {
                 get
                 {
-                    return _fxcopRule;
+                    return _customData;
                 }
 
                 set
                 {
-                    _fxcopRule = value;
+                    _customData = value;
                 }
             }
         }
@@ -998,7 +998,7 @@ internal class MyCustomBuildErrorEventArgsNotSerializable : BuildErrorEventArgs
             /// <summary>
             /// Custom data for the custom event
             /// </summary>
-            private string _fxcopRule;
+            private string _customData;
 
             /// <summary>
             /// Constructor
@@ -1014,16 +1014,16 @@ string message
             /// <summary>
             /// Getter and setter for the custom data
             /// </summary>
-            internal string FXCopRule
+            internal string CustomData
             {
                 get
                 {
-                    return _fxcopRule;
+                    return _customData;
                 }
 
                 set
                 {
-                    _fxcopRule = value;
+                    _customData = value;
                 }
             }
         }
@@ -1036,7 +1036,7 @@ internal class MyCustomBuildWarningEventArgsNotSerializable : BuildWarningEventA
             /// <summary>
             /// Custom data for the custom event
             /// </summary>
-            private string _fxcopRule;
+            private string _customData;
 
             /// <summary>
             /// Constructor
@@ -1052,16 +1052,16 @@ string message
             /// <summary>
             /// Getter and setter for the custom data
             /// </summary>
-            internal string FXCopRule
+            internal string CustomData
             {
                 get
                 {
-                    return _fxcopRule;
+                    return _customData;
                 }
 
                 set
                 {
-                    _fxcopRule = value;
+                    _customData = value;
                 }
             }
         }
diff --git a/src/Build.UnitTests/ChangeWaves_Tests.cs b/src/Build.UnitTests/ChangeWaves_Tests.cs
index d561fcaf9ef..9b151a10fc7 100644
--- a/src/Build.UnitTests/ChangeWaves_Tests.cs
+++ b/src/Build.UnitTests/ChangeWaves_Tests.cs
@@ -3,6 +3,7 @@
 
 using Xunit;
 using Shouldly;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.UnitTests;
diff --git a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
index 85ae11ffcdf..ca9c3f60b06 100644
--- a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
+++ b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
 using Xunit;
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index 4dfcbb75209..90a169b7a64 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.Collections;
 using System;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using System.Collections;
 using System.Linq;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 023d77e74b8..353fadb719c 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -1480,6 +1480,8 @@ public void DisplayPropertiesList()
 
             sc = new SimulatedConsole();
             ParallelConsoleLogger cl2 = new ParallelConsoleLogger(LoggerVerbosity.Diagnostic, sc.Write, null, null);
+            EventSourceSink es = new EventSourceSink();
+            cl2.Initialize(es);
 
             WriteAndValidateProperties(cl2, sc, true);
         }
@@ -1535,6 +1537,8 @@ public void DisplayEnvironmentInDetailed()
 
             sc = new SimulatedConsole();
             ParallelConsoleLogger cl2 = new ParallelConsoleLogger(LoggerVerbosity.Detailed, sc.Write, null, null);
+            EventSourceSink es = new EventSourceSink();
+            cl2.Initialize(es);
             cl2.Parameters = "ShowEnvironment";
             cl2.ParseParameters();
 
@@ -1553,6 +1557,8 @@ public void DisplayEnvironmentInDiagnostic()
 
             sc = new SimulatedConsole();
             ParallelConsoleLogger cl2 = new ParallelConsoleLogger(LoggerVerbosity.Diagnostic, sc.Write, null, null);
+            EventSourceSink es = new EventSourceSink();
+            cl2.Initialize(es);
             WriteEnvironment(cl2, sc, true);
         }
 
@@ -1589,6 +1595,8 @@ public void DisplayEnvironmentInMinimal()
 
             sc = new SimulatedConsole();
             ParallelConsoleLogger cl2 = new ParallelConsoleLogger(LoggerVerbosity.Minimal, sc.Write, null, null);
+            EventSourceSink es = new EventSourceSink();
+            cl2.Initialize(es);
             cl2.Parameters = "ShowEnvironment";
             cl2.ParseParameters();
 
@@ -1827,6 +1835,8 @@ public void DisplayItemsList()
 
             sc = new SimulatedConsole();
             ParallelConsoleLogger cl2 = new ParallelConsoleLogger(LoggerVerbosity.Diagnostic, sc.Write, null, null);
+            EventSourceSink es = new EventSourceSink();
+            cl2.Initialize(es);
 
             WriteAndValidateItems(cl2, sc, true);
         }
diff --git a/src/Build.UnitTests/ConsoleOutputAlignerTests.cs b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
new file mode 100644
index 00000000000..b0227c062a0
--- /dev/null
+++ b/src/Build.UnitTests/ConsoleOutputAlignerTests.cs
@@ -0,0 +1,377 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using Microsoft.Build.BackEnd.Logging;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class ConsoleOutputAlignerTests
+    {
+        [Theory]
+        [InlineData("a", true)]
+        [InlineData("a", false)]
+        [InlineData("12345", true)]
+        [InlineData("12345", false)]
+        public void IndentBiggerThanBuffer_IndentedAndNotAligned(string input, bool aligned)
+        {
+            string indent = "    ";
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: aligned);
+
+            string output = aligner.AlignConsoleOutput(message:input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
+
+            output.ShouldBe(indent + input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("a")]
+        [InlineData("12345")]
+        public void NoAlignNoIndent_NotAlignedEvenIfBiggerThanBuffer(string input)
+        {
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: false);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: 0);
+
+            output.ShouldBe(input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData(1)]
+        [InlineData(1000)]
+        public void NoBufferWidthNoIndent_NotAligned(int sizeOfMessage)
+        {
+            string input = new string('.', sizeOfMessage);
+            var aligner = new ConsoleOutputAligner(bufferWidth: -1, alignMessages: false);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: 0);
+
+            output.ShouldBe(input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("a")]
+        [InlineData("12345")]
+        public void WithoutBufferWidthWithoutIndentWithAlign_NotIndentedAndNotAligned(string input)
+        {
+            var aligner = new ConsoleOutputAligner(bufferWidth: -1, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: 0);
+
+            output.ShouldBe(input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("a")]
+        [InlineData("12345")]
+        public void NoAlignPrefixAlreadyWritten_NotChanged(string input)
+        {
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
+
+            output.ShouldBe(input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("",   "123")]
+        [InlineData(" ",  "12")]
+        [InlineData("  ", "1")]
+        public void SmallerThanBuffer_NotAligned(string indent, string input)
+        {
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
+
+            output.ShouldBe(indent + input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("", "1234", "123", "4")]
+        [InlineData(" ", "123", " 12", " 3")]
+        [InlineData("  ", "12", "  1", "  2")]
+        public void BiggerThanBuffer_AlignedWithIndent(string indent, string input, string expected1stLine, string expected2ndLine)
+        {
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
+
+            output.ShouldBe(expected1stLine + Environment.NewLine + expected2ndLine + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("", "12345678", "123\n" +
+                                    "456\n" +
+                                    "78\n")]
+        [InlineData(" ", "12345678", " 12\n" +
+                                     " 34\n" +
+                                     " 56\n" +
+                                     " 78\n" )]
+        [InlineData("  ", "1234", "  1\n" +
+                                  "  2\n" +
+                                  "  3\n" +
+                                  "  4\n")]
+        public void XTimesBiggerThanBuffer_AlignedToMultipleLines(string indent, string input, string expected)
+        {
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: indent.Length);
+
+            output.ShouldBe(expected.Replace("\n", Environment.NewLine));
+        }
+
+
+        [Theory]
+        [InlineData("", "1234", "123", "4")]
+        [InlineData(" ", "123", "12", " 3")]
+        [InlineData("  ", "12", "1", "  2")]
+        public void BiggerThanBufferWithPrefixAlreadyWritten_AlignedWithIndentFromSecondLine(string indent, string input, string expected1stLine, string expected2ndLine)
+        {
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: indent.Length);
+
+            output.ShouldBe(expected1stLine + Environment.NewLine + expected2ndLine + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("a\nb")]
+        [InlineData("12345\n54321")]
+        [InlineData("\t12345\n\t54321")]
+        public void MultiLineWithoutAlign_NotChanged(string input)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: false);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
+
+            output.ShouldBe(input + Environment.NewLine);
+        }
+
+        /// <summary>
+        /// Although consoles interprets \r as return carrier to the begging of the line, we treat \r as NewLine, as it is most consistent with how file viewers interpret it and
+        ///    because logs are rarely read directly from console but more often from log files.
+        /// Consequently \n\r shall be interpreted not as sequence but two control characters with equivalent of \n\n.
+        /// </summary>
+        [Theory]
+        [InlineData("a\n\rb", "a\n\n  b")]
+        [InlineData("a\rb", "a\n  b")]
+        [InlineData("\n\ra", "\n\n  a")]
+        [InlineData("\ra", "\n  a")]
+        [InlineData("a\nb\n\r", "a\n  b\n\n")]
+        [InlineData("a\nb\r", "a\n  b\n")]
+        public void NonStandardNewLines_AlignAsExpected(string input, string expected)
+        {
+            expected = expected.Replace("\n", Environment.NewLine) + Environment.NewLine;
+
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 2);
+
+            output.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData("a\nb")]
+        [InlineData("123456789\n987654321")]
+        [InlineData("\t1\n9\t1")]
+        public void ShortMultiLineWithAlign_NoChange(string input)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
+
+            output.ShouldBe(input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("a\nb")]
+        [InlineData("a\r\nb")]
+        [InlineData("a\nb\r\n")]
+        [InlineData("a\nb\n")]
+        [InlineData("a\n\nb")]
+        [InlineData("a\r\n\nb")]
+        [InlineData("a\n\r\nb")]
+        [InlineData("a\r\n\r\nb")]
+        [InlineData("\r\na\nb")]
+        [InlineData("\na\nb")]
+        [InlineData("\na\r\nb\nc")]
+        [InlineData("\r\na\nb\r\nc")]
+        public void ShortMultiLineWithMixedNewLines_NewLinesReplacedByActualEnvironmentNewLines(string input)
+        {
+            string expected = input.Replace("\r", "").Replace("\n", Environment.NewLine) + Environment.NewLine;
+            var aligner = new ConsoleOutputAligner(bufferWidth: 10, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
+
+            output.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData("", "a\n12345", "a\n123\n45\n")]
+        [InlineData("", "12345\na\n54321", "123\n45\na\n543\n21\n")]
+        [InlineData(" ", "12345\na\n54321", "12\n 34\n 5\n a\n 54\n 32\n 1\n")]
+        public void MultiLineWithPrefixAlreadyWritten(string prefix, string input, string expected)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            expected = expected.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: prefix.Length);
+
+            output.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(" ", "a\n12345", " a\n 12\n 34\n 5\n")]
+        [InlineData(" ", "12345\na\n54321", " 12\n 34\n 5\n a\n 54\n 32\n 1\n")]
+        public void MultiLineWithoutPrefixAlreadyWritten(string prefix, string input, string expected)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            expected = expected.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 4, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: false, prefixWidth: prefix.Length);
+
+            output.ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData("\t")]
+        [InlineData("a\nb\tc\nd")]
+        public void ShortTextWithTabs_NoChange(string input)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: 50, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: true, prefixWidth: 0);
+
+            output.ShouldBe(input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("", "\t", 7, false)]
+        [InlineData("", "12345678\t", 15, false)]
+        [InlineData(" ", "2345678\t", 15, false)]
+        [InlineData(" ", "2345678\t", 15, true)]
+        public void LastTabOverLimit_NoChange(string prefix, string input, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
+
+            output.ShouldBe((prefixAlreadyWritten ? string.Empty : prefix) + input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("", "\t", 8, false)]
+        [InlineData("", "12345678\t", 16, false)]
+        [InlineData(" ", "2345678\t", 16, false)]
+        [InlineData(" ", "2345678\t", 16, true)]
+        public void LastTabAtLimit_NoChange(string prefix, string input, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
+
+            output.ShouldBe((prefixAlreadyWritten ? string.Empty : prefix) + input + Environment.NewLine);
+        }
+
+        [Theory]
+        [InlineData("", "\t", 8, false)]
+        [InlineData("", "12345678\t", 16, false)]
+        [InlineData(" ", "2345678\t", 16, false)]
+        [InlineData(" ", "2345678\t", 16, true)]
+        public void TabsMakesItJustOverLimit_IndentAndAlign(string prefix, string input, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input + "x", prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
+
+            string expected = (prefixAlreadyWritten ? string.Empty : prefix) + input + Environment.NewLine +
+                              prefix + "x" + Environment.NewLine;
+
+            output.ShouldBe(expected);
+        }
+
+        [Theory]
+        //+----+----+---+---+---+---+---+---+
+        //| 1  | 2  | 3 | 4 | 5 | 6 | 7 | 8 |
+        //+----+----+---+---+---+---+---+---+
+        //| \t | .  | . | . | . | . | . | . |
+        //+----+----+---+---+---+---+---+---+
+        //| 1  |    |   |   |   |   |   |   |
+        //+----+----+---+---+---+---+---+---+
+        //| a  | \t | . | . | . | . | . | . |
+        //+----+----+---+---+---+---+---+---+
+        //| b  |    |   |   |   |   |   |   |
+        //+----+----+---+---+---+---+---+---+
+        [InlineData("", "\t1\na\tb", "\t\n1\na\t\nb\n",  8, false)]
+        //+---+---+---+----+---+---+---+---+----+
+        //| 1 | 2 | 3 | 4  | 5 | 6 | 7 | 8 | 9  |
+        //+---+---+---+----+---+---+---+---+----+
+        //| 1 | 2 | 3 | 4  | 5 | 6 | 7 | 8 | \t |
+        //+---+---+---+----+---+---+---+---+----+
+        //| a | b | c |    |   |   |   |   |    |
+        //+---+---+---+----+---+---+---+---+----+
+        //| d | e | f | \t | . | . | . | . | g  |
+        //+---+---+---+----+---+---+---+---+----+
+        [InlineData("", "12345678\tabc\ndef\tg", "12345678\t\nabc\ndef\tg\n", 9, false)]
+        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| 1  | 2 | 3 | 4  | 5 | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
+        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| \t | . | . | .  | . | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | a  |
+        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| b  | c |   |    |   |   |   |   |    |    |    |    |    |    |    |    |    |
+        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| d  | e | f | \t | . | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
+        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| h  | i |   |    |   |   |   |   |    |    |    |    |    |    |    |    |    |
+        //+----+---+---+----+---+---+---+---+----+----+----+----+----+----+----+----+----+
+        [InlineData("", "\t\tabc\ndef\t\tghi", "\t\ta\nbc\ndef\t\tg\nhi\n", 17, false)]
+        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| 1 | 2 | 3  | 4 | 5  | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
+        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | a | \t | . | .  | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | b  |
+        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | c |    |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | d | e  | f | \t | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
+        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | h | i  | 5 | 6  | 7 | 8 | 9  | 0 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |
+        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | 9 |    |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        //+---+---+----+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        [InlineData(" ", "a\t\tbc\ndef\t\tghi567890123456789", " a\t\tb\n c\n def\t\tg\n hi56789012345678\n 9\n", 17, false)]
+        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| 1 | 2  | 3 | 4 | 5  | 6 | 7 | 8 | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
+        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| a | \t | . | . | .  | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | b  |
+        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | c  |   |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | d  | e | f | \t | . | . | . | \t | .  | .  | .  | .  | .  | .  | .  | g  |
+        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | h  | i | 5 | 6  | 7 | 8 | 9 | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |
+        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        //| _ | 9  |   |   |    |   |   |   |    |    |    |    |    |    |    |    |    |
+        //+---+----+---+---+----+---+---+---+----+----+----+----+----+----+----+----+----+
+        [InlineData(" ", "a\t\tbc\ndef\t\tghi567890123456789", "a\t\tb\n c\n def\t\tg\n hi56789012345678\n 9\n", 17, true)]
+        public void MultiLinesOverLimit_IndentAndAlign(string prefix, string input, string expected, int bufferWidthWithoutNewLine, bool prefixAlreadyWritten)
+        {
+            input = input.Replace("\n", Environment.NewLine);
+            expected = expected.Replace("\n", Environment.NewLine);
+            var aligner = new ConsoleOutputAligner(bufferWidth: bufferWidthWithoutNewLine + 1, alignMessages: true);
+
+            string output = aligner.AlignConsoleOutput(message: input, prefixAlreadyWritten: prefixAlreadyWritten, prefixWidth: prefix.Length);
+
+            output.ShouldBe(expected);
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 505088d7f86..ae23198472c 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 232d22c62dd..49497a0e870 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -129,6 +129,41 @@ public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
             Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
         }
 
+        [Fact]
+        public void EvaluationShouldUseDirectoryCache()
+        {
+            var projectFile = _env.CreateFile("1.proj", @"<Project> <ItemGroup Condition=`Exists('1.file')`> <Compile Include='*.cs'/> </ItemGroup> </Project>".Cleanup()).Path;
+
+            var projectCollection = _env.CreateProjectCollection().Collection;
+            var directoryCacheFactory = new Helpers.LoggingDirectoryCacheFactory();
+
+            var project = Project.FromFile(
+                projectFile,
+                new ProjectOptions
+                {
+                    ProjectCollection = projectCollection,
+                    DirectoryCacheFactory = directoryCacheFactory,
+                }
+            );
+
+            directoryCacheFactory.DirectoryCaches.Count.ShouldBe(1);
+            var directoryCache = directoryCacheFactory.DirectoryCaches[0];
+
+            directoryCache.EvaluationId.ShouldBe(project.LastEvaluationId);
+
+            directoryCache.ExistenceChecks.OrderBy(kvp => kvp.Key).ShouldBe(
+                new Dictionary<string, int>
+                {
+                    { _env.DefaultTestDirectory.Path, 1},
+                    { Path.Combine(_env.DefaultTestDirectory.Path, "1.file"), 2 }
+                }.OrderBy(kvp => kvp.Key));
+            directoryCache.Enumerations.ShouldBe(
+                new Dictionary<string, int>
+                {
+                    { _env.DefaultTestDirectory.Path, 1 }
+                });
+        }
+
         [Theory]
         [InlineData(EvaluationContext.SharingPolicy.Shared)]
         [InlineData(EvaluationContext.SharingPolicy.Isolated)]
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index e1ad11a9be0..edd37ea0144 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -21,6 +21,7 @@
 using ResourceUtilities = Microsoft.Build.Shared.ResourceUtilities;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.UnitTests.EscapingInProjects_Tests
 {
@@ -94,7 +95,6 @@ public void SemicolonInPropertyPassedIntoStringParam()
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Make sure I can define a property with escaped characters and pass it into
         /// a string parameter of a task, in this case the Message task.
@@ -117,7 +117,6 @@ public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
-#endif
 
 #if FEATURE_ASSEMBLY_LOCATION
         /// <summary>
@@ -588,7 +587,6 @@ public void ItemTransformContainingSemicolon()
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Do an item transform, where the transform expression contains an unescaped semicolon as well
         /// as an escaped percent sign.
@@ -616,7 +614,6 @@ public void ItemTransformContainingSemicolon_InTaskHost()
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
-#endif
 
         /// <summary>
         /// Tests that when we add an item and are in a directory with characters in need of escaping, and the
@@ -710,7 +707,6 @@ public void EscapedWildcardsShouldNotBeExpanded()
             }
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// If %2A (escaped '*') or %3F (escaped '?') is in an item's Include, it should be treated
         /// literally, not as a wildcard
@@ -747,7 +743,6 @@ public void EscapedWildcardsShouldNotBeExpanded_InTaskHost()
                 ObjectModelHelpers.DeleteTempProjectDirectory();
             }
         }
-#endif
 
         /// <summary>
         /// Parity with Orcas: Target names are always unescaped, and in fact, if there are two targets,
@@ -954,12 +949,13 @@ public void SemicolonInConfiguration()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1002,7 +998,6 @@ public class Class1
             logger.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\a;b'c\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Escaping in conditionals is broken.
         /// </summary>
@@ -1019,12 +1014,13 @@ public void SemicolonInConfiguration_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1071,7 +1067,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
@@ -1084,12 +1079,13 @@ public void SemicolonInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1127,7 +1123,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class;Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
         /// </summary>
@@ -1144,12 +1139,13 @@ public void SemicolonInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1191,7 +1187,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
@@ -1204,12 +1199,13 @@ public void DollarSignInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1247,7 +1243,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class$(prop)Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
         /// </summary>
@@ -1264,12 +1259,13 @@ public void DollarSignInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1311,7 +1307,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
@@ -1324,12 +1319,13 @@ public void SemicolonInSourceCodeFilename()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1367,7 +1363,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
         /// </summary>
@@ -1384,12 +1379,13 @@ public void SemicolonInSourceCodeFilename_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1431,7 +1427,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
@@ -1599,7 +1594,6 @@ public class Class1
             Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); //                     @"Did not find expected file Console;!@(foo)'^(Application1.exe"
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
         /// have all sorts of crazy characters in their name. There
@@ -1775,7 +1769,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
     }
 #endif
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index b58a72d0843..c8c590e79cd 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1874,19 +1874,19 @@ public void TestItemSpecModiferEscaping()
         [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToReferenceAssembliesAsFunction()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) == null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) == null)
             {
                 // if there aren't any reference assemblies installed on the machine in the first place, of course
                 // we're not going to find them. :)
                 return;
             }
 
-            string content = @"
+            string content = $@"
                 <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
 
                     <PropertyGroup>
                         <TargetFrameworkIdentifier>.NETFramework</TargetFrameworkIdentifier>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <TargetFrameworkProfile></TargetFrameworkProfile>
                         <TargetFrameworkMoniker>$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
                     </PropertyGroup>
@@ -3979,6 +3979,12 @@ public void PropertyFunctionStringLastIndexOf()
             TestPropertyFunction("$(prop.LastIndexOf('y', 7))", "prop", "x-x-y-y-y-z", "6");
         }
 
+        [Fact]
+        public void PropertyFunctionStringLastIndexOfAny()
+        {
+            TestPropertyFunction("$(prop.LastIndexOfAny('xy'))", "prop", "x-x-y-y-y-z", "8");
+        }
+
         [Fact]
         public void PropertyFunctionStringCopy()
         {
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index 1291e457fef..dfab66d8dbd 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -6,6 +6,7 @@
 using System.IO;
 
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
@@ -99,7 +100,7 @@ public void AddEntryStrongReference()
             GC.Collect();
 
             Assert.Null(ProjectCollection.GlobalProjectCollection.ProjectRootElementCache.TryGet(projectPath));
-        }   
+        }
 
         /// <summary>
         /// Cache should not return a ProjectRootElement if the file it was loaded from has since changed -
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index ed3030d0aa9..a25dec785b1 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -19,7 +19,7 @@
 using SdkResolverContext = Microsoft.Build.Framework.SdkResolverContext;
 using SdkResult = Microsoft.Build.Framework.SdkResult;
 using SdkResultFactory = Microsoft.Build.Framework.SdkResultFactory;
-using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
 {
@@ -297,7 +297,7 @@ public void ProjectWithInvalidSdkName()
 
                 Project project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(content))));
             });
-            
+
             Assert.Equal("MSB4229", exception.ErrorCode);
         }
 
@@ -475,7 +475,7 @@ public void IgnoreMissingImportsSdkNotFoundDoesNotThrow()
                 loadSettings: ProjectLoadSettings.IgnoreMissingImports);
 
             project.GetPropertyValue("Success").ShouldBe("true");
-            
+
             ProjectImportedEventArgs[] events = logger.BuildMessageEvents.OfType<ProjectImportedEventArgs>().ToArray();
 
             // There are two implicit imports so there should be two logged ProjectImportedEventArgs
diff --git a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
index f38192ebbb3..28fd32be143 100644
--- a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
diff --git a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
index 6aec4235e18..ca0efc0d850 100644
--- a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
@@ -138,5 +138,37 @@ public void MSBuildGlobVisitorShouldFindAllLeaves()
                 Assert.Contains(expectedGlob, leafGlobs);
             }
         }
+
+        [Fact]
+        public void CreateShouldHandleZeroChildren()
+        {
+            IMSBuildGlob composite = CompositeGlob.Create(Enumerable.Empty<IMSBuildGlob>());
+
+            Assert.False(composite.IsMatch(""));
+        }
+
+        [Fact]
+        public void CreateShouldReturnSingleChildUnchanged()
+        {
+            var glob = MSBuildGlob.Parse("");
+
+            IMSBuildGlob composite = CompositeGlob.Create(new[] { glob });
+
+            Assert.Same(glob, composite);
+        }
+
+        [Fact]
+        public void CreateShouldReturnNewCompositeWhenMultipleProvided()
+        {
+            var glob1 = MSBuildGlob.Parse("");
+            var glob2 = MSBuildGlob.Parse("");
+
+            IMSBuildGlob result = CompositeGlob.Create(new[] { glob1, glob2 });
+
+            var composite = Assert.IsType<CompositeGlob>(result);
+            Assert.Same(glob1, composite.Globs.First());
+            Assert.Same(glob2, composite.Globs.Skip(1).First());
+            Assert.Equal(2, composite.Globs.Count());
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
index 9dc8a506fcf..fd742516500 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Engine.UnitTests.Globbing
     public class MSBuildGlobWithGaps_Tests
     {
         [Fact]
-        public void GlobWithGapsShoulWorkWithNoGaps()
+        public void GlobWithGapsShouldWorkWithNoGaps()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), Enumerable.Empty<IMSBuildGlob>());
 
@@ -19,7 +19,7 @@ public void GlobWithGapsShoulWorkWithNoGaps()
         }
 
         [Fact]
-        public void GlobWithGapsShoulMatchIfNoGapsMatch()
+        public void GlobWithGapsShouldMatchIfNoGapsMatch()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), MSBuildGlob.Parse("b*"));
 
@@ -27,7 +27,7 @@ public void GlobWithGapsShoulMatchIfNoGapsMatch()
         }
 
         [Fact]
-        public void GlobWithGapsShoulNotMatchIfGapsMatch()
+        public void GlobWithGapsShouldNotMatchIfGapsMatch()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), MSBuildGlob.Parse("*b"));
 
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index d357c472750..c550d10b888 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -90,7 +90,7 @@ public void GlobFromRootWithInvalidPathThrows()
             "../d/e/**",
             "a/b/d/e"
             )]
-        public void GlobWithRelativeFixedDirectoryPartShouldMissmatchTheGlobRoot(string globRoot, string filespec, string expectedFixedDirectoryPart)
+        public void GlobWithRelativeFixedDirectoryPartShouldMismatchTheGlobRoot(string globRoot, string filespec, string expectedFixedDirectoryPart)
         {
             var glob = MSBuildGlob.Parse(globRoot, filespec);
 
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 28af920a861..8846401318e 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
@@ -193,7 +194,7 @@ public void ConstructWithProjectInstanceFactory_FactoryReturnsNull_Throws()
                     (projectPath, globalProperties, projectCollection) => null));
             }
         }
-        
+
         /// <summary>
         ///   1
         ///  / \
@@ -763,7 +764,7 @@ public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()
                 var root1 = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: new Dictionary<string, string[]> {{"A", new[] {"B"}}}, defaultTargets: "A").Path;
                 var root2 = CreateProjectFile(env: env, projectNumber: 2, projectReferences: new[] {3}, projectReferenceTargets: new Dictionary<string, string[]> {{"B", new[] {"C"}}, {"X", new[] {"Y"}}}, defaultTargets: "X").Path;
                 CreateProjectFile(env: env, projectNumber: 3);
-                
+
 
                 var projectGraph = new ProjectGraph(new []{root1, root2});
                 projectGraph.ProjectNodes.Count.ShouldBe(3);
@@ -870,7 +871,7 @@ public void GetTargetListsUsesAllTargetsForNonMultitargetingNodes()
                     extraContent: ProjectReferenceTargetsWithMultitargeting)
                     .Path;
                 CreateProjectFile(env, 2);
-                
+
                 var projectGraph = new ProjectGraph(root1);
 
                 var dot = projectGraph.ToDot();
@@ -910,8 +911,8 @@ public void GetTargetsListInnerBuildToInnerBuild()
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: singleTargetedSpec);
-                
-                
+
+
                 var projectGraph = new ProjectGraph(root1);
 
                 var dot = projectGraph.ToDot();
@@ -945,7 +946,7 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
-                
+
                 var projectGraph = new ProjectGraph(root1);
 
                 var dot = projectGraph.ToDot();
@@ -1117,7 +1118,7 @@ public void GetTargetListsForComplexMultitargetingGraph()
                     projectReferenceTargets: null,
                     defaultTargets: null,
                     extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
-                
+
                 var projectGraph = new ProjectGraph(new[] {root1, root2});
 
                 var dot = projectGraph.ToDot();
@@ -1555,7 +1556,7 @@ public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
             var dot = graph.ToDot();
 
             graph.ProjectNodes.Count.ShouldBe(3);
-            
+
             var outerBuild = graph.GraphRoots.First();
 
             AssertOuterBuildAsRoot(outerBuild, graph);
@@ -2300,7 +2301,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             foreach (var inner1 in innerBuildsFor1)
             {
-                // Outer build targets are added to inner builds because 
+                // Outer build targets are added to inner builds because
                 targetLists[inner1].ShouldBe(new[] {"BuildForOuterBuild", "Build"});
             }
 
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index dc3a40ef3ce..cda8fa48311 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
     <AssemblyName>Microsoft.Build.Engine.UnitTests</AssemblyName>
 
@@ -49,10 +48,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-
     <Compile Include="..\Shared\UnitTests\BuildEventArgsExtension.cs">
       <!-- Extension methods -->
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index 869a90027cf..8fb33e821cd 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
@@ -39,9 +40,9 @@ public void ErrorPosition()
                 { " $(",                    "2",    "AllowAll"},              // Position of $
                 { " $",                     "2",    "AllowAll"},              // Position of $
                 { " @(foo)",                "2",    "AllowProperties"},       // Position of @
-                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @    
+                { " '@(foo)'",              "3",    "AllowProperties"},       // Position of @
                 /* test escaped chars: message shows them escaped so count should include them */
-                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote 
+                { "'%24%28x' == '%24(x''",   "21",  "AllowAll"}               // Position of extra quote
             };
 
             // Some errors are caught by the Parser, not merely by the Lexer/Scanner. So we have to do a full Parse,
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 3efd05703f6..4a7e4b27904 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -32,11 +32,12 @@ public void TargetARM()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>arm</PlatformTarget>
@@ -134,18 +135,18 @@ public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -186,7 +187,7 @@ public void AnyCPUWinMDObjProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -241,10 +242,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>winmdobj</OutputType>
                         <Configuration>Debug</Configuration>
@@ -253,10 +254,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -298,17 +299,17 @@ public void AnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -348,18 +349,18 @@ public void ExplicitAnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -400,7 +401,7 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -434,10 +435,10 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
         /// <summary>
         /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are 
-        /// targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default. 
+        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default. 
         /// </summary>
         [Fact]
-        public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
+        public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
         {
             string file = null;
             string outputPath = Path.GetTempPath() + "\\" + Guid.NewGuid().ToString("N");
@@ -449,18 +450,18 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -470,7 +471,7 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
 
                 project.Build();
 
-                logger.AssertLogContains(" /platform:AnyCPU ");
+                logger.AssertLogContains("Platform=AnyCPU");
             }
             finally
             {
@@ -500,21 +501,21 @@ public void AnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
                       </PropertyGroup>
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
-                           we need to be .NET 4.5 or greater -->
+                           we need to be .NET 4.5 or greater, but 4.8 is on the CI machine -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -556,10 +557,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
@@ -568,10 +569,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -613,19 +614,19 @@ public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`Current` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <Prefer32Bit>true</Prefer32Bit>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -665,17 +666,17 @@ public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -715,17 +716,17 @@ public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -867,20 +868,20 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + files[0] + @"` />
-                        <None Include=`" + files[1] + @"` />
-                        <Content Include=`" + files[2] + @"` />
+                        <Compile Include=`{files[0]}` />
+                        <None Include=`{files[1]}` />
+                        <Content Include=`{files[2]}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
@@ -952,17 +953,17 @@ public void SynthesizeLinkMetadataForItemsOnWhitelist()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
@@ -1030,17 +1031,17 @@ public void DontSynthesizeLinkMetadataIfPropertyNotSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>false</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
diff --git a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
index a8a88862e4f..a9ba7b26914 100644
--- a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
+++ b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
@@ -183,6 +183,12 @@ public bool Equals(ProjectItemGroupTaskItemInstance x, ProjectItemGroupTaskItemI
                 Assert.Equal(x.RemoveMetadataLocation, y.RemoveMetadataLocation, new Helpers.ElementLocationComparerIgnoringType());
                 Assert.Equal(x.ConditionLocation, y.ConditionLocation, new Helpers.ElementLocationComparerIgnoringType());
 
+                Assert.Equal(x.MatchOnMetadata, y.MatchOnMetadata);
+                Assert.Equal(x.MatchOnMetadataLocation, y.MatchOnMetadataLocation, new Helpers.ElementLocationComparerIgnoringType());
+
+                Assert.Equal(x.MatchOnMetadataOptions, y.MatchOnMetadataOptions);
+                Assert.Equal(x.MatchOnMetadataOptionsLocation, y.MatchOnMetadataOptionsLocation, new Helpers.ElementLocationComparerIgnoringType());
+
                 Assert.Equal(x.Metadata, y.Metadata, new TargetItemMetadataComparer());
 
                 return true;
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index d83d61361fa..e8ead4b2e98 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -417,6 +417,9 @@ public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
             }
         }
 
+        /// <summary>
+        /// Test that a task that returns false without logging anything reports MSB4181 as a warning.
+        /// </summary>
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
         {
@@ -439,6 +442,31 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue
             }
         }
 
+        /// <summary>
+        /// Test that a task that returns false after logging an error->warning does NOT also log MSB4181
+        /// </summary>
+        [Fact]
+        public void TaskReturnsFailureAndLogsError_ContinueOnError_WarnAndContinue()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Return=""false"" ErrorCode=""MSB1234"" ContinueOnError=""WarnAndContinue""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                // The only warning should be the error->warning logged by the task.
+                logger.WarningCount.ShouldBe(1);
+                logger.AssertLogContains("MSB1234");
+            }
+        }
+
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         {
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 21e9b159651..7462770fbd9 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 using System.Runtime.CompilerServices;
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ddabf21013b..673a0a520f0 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -20,7 +20,6 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -31,7 +30,6 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
@@ -251,6 +249,9 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// <code>true</code> to wait for a debugger to be attached, otherwise <code>false</code>.
         /// </summary>
+        [SuppressMessage("ApiDesign",
+            "RS0016:Add public types and members to the declared API",
+            Justification = "Only available in the Debug configuration.")]
         public static bool WaitForDebugger { get; set; }
 #endif
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 2dbcd31ea0e..7fe3d19fcf0 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -11,6 +11,7 @@
 using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Utilities;
@@ -202,7 +203,7 @@ public void InitializeForBuild(NodeLoggingContext loggingContext)
         /// Cleans up after a build but leaves the engine thread running.  Aborts
         /// any outstanding requests.  Blocks until the engine has cleaned up
         /// everything.  After this method is called, InitializeForBuild may be
-        /// called to start a new build, or the component may be shut down.        
+        /// called to start a new build, or the component may be shut down.
         /// </summary>
         /// <remarks>
         /// Called by the Node.  Non-overlapping with other calls from the Node.
@@ -347,13 +348,13 @@ public void SubmitBuildRequest(BuildRequest request)
 
                         TraceEngine("Request {0}({1}) (nr {2}) retrieved results for configuration {3} from node {4} for transfer.", request.GlobalRequestId, request.ConfigurationId, request.NodeRequestId, request.ConfigurationId, _componentHost.BuildParameters.NodeId);
 
-                        // If this is the inproc node, we've already set the configuration's ResultsNodeId to the correct value in 
-                        // HandleRequestBlockedOnResultsTransfer, and don't want to set it again, because we actually have less 
-                        // information available to us now.  
+                        // If this is the inproc node, we've already set the configuration's ResultsNodeId to the correct value in
+                        // HandleRequestBlockedOnResultsTransfer, and don't want to set it again, because we actually have less
+                        // information available to us now.
                         //
-                        // On the other hand, if this is not the inproc node, we want to make sure that our copy of this configuration 
-                        // knows that its results are no longer on this node.  Since we don't know enough here to know where the 
-                        // results are going, we satisfy ourselves with marking that they are simply "not here". 
+                        // On the other hand, if this is not the inproc node, we want to make sure that our copy of this configuration
+                        // knows that its results are no longer on this node.  Since we don't know enough here to know where the
+                        // results are going, we satisfy ourselves with marking that they are simply "not here".
                         if (_componentHost.BuildParameters.NodeId != Scheduler.InProcNodeId)
                         {
                             config.ResultsNodeId = Scheduler.ResultsTransferredId;
@@ -394,7 +395,7 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                     ErrorUtilities.VerifyThrow(_requestsByGlobalRequestId.ContainsKey(unblocker.BlockedRequestId), "Request {0} is not known to the engine.", unblocker.BlockedRequestId);
                     BuildRequestEntry entry = _requestsByGlobalRequestId[unblocker.BlockedRequestId];
 
-                    // Are we resuming execution or reporting results?  
+                    // Are we resuming execution or reporting results?
                     if (unblocker.Result == null)
                     {
                         // We are resuming execution.
@@ -414,7 +415,7 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                     }
                     else
                     {
-                        // We must be reporting results.                 
+                        // We must be reporting results.
                         BuildResult result = unblocker.Result;
 
                         if (result.NodeRequestId == BuildRequest.ResultsTransferNodeRequestId)
@@ -434,7 +435,7 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                             ((IBuildResults)result).SavedEnvironmentVariables = null;
                             ((IBuildResults)result).SavedCurrentDirectory = null;
 
-                            // Our results node is now this node, since we've just cached those results                        
+                            // Our results node is now this node, since we've just cached those results
                             resultsCache.AddResult(result);
                             config.ResultsNodeId = _componentHost.BuildParameters.NodeId;
 
@@ -763,7 +764,7 @@ private void EvaluateRequestStates()
                 _requestsByGlobalRequestId.Remove(completedEntry.Request.GlobalRequestId);
             }
 
-            // If we completed a request, that means we may be able to unload the configuration if there is memory pressure.  Further we 
+            // If we completed a request, that means we may be able to unload the configuration if there is memory pressure.  Further we
             // will also cache any result items we can find since they are rarely used.
             if (completedEntries.Count > 0)
             {
@@ -790,7 +791,7 @@ private void EvaluateRequestStates()
             }
 
             // Finally, raise the completed events so they occur AFTER the state of the engine has changed,
-            // otherwise the client might observe the engine as being active after having received 
+            // otherwise the client might observe the engine as being active after having received
             // completed notifications for all requests, which would be odd.
             foreach (BuildRequestEntry completedEntry in completedEntries)
             {
@@ -915,12 +916,12 @@ private void ActivateBuildRequest(BuildRequestEntry entry)
                 // Set the request builder.
                 entry.Builder = GetRequestBuilder();
 
-                // Now call into the request builder to do the building            
+                // Now call into the request builder to do the building
                 entry.Builder.BuildRequest(_nodeLoggingContext, entry);
             }
             else
             {
-                // We are resuming the build request                
+                // We are resuming the build request
                 entry.Builder.ContinueRequest();
             }
 
@@ -1022,7 +1023,7 @@ private void IssueUnsubmittedRequests()
         {
             // We will only submit as many items as were in the queue at the time this method was called.
             // This prevents us from a) having to lock the queue for the whole loop or b) getting into
-            // an endless loop where another thread pushes requests into the queue as fast as we can 
+            // an endless loop where another thread pushes requests into the queue as fast as we can
             // discharge them.
             int countToSubmit = _unsubmittedRequests.Count;
             while (countToSubmit != 0)
@@ -1092,12 +1093,12 @@ private void IssueUnsubmittedRequests()
         /// When we receive a build request, we first have to determine if we already have a configuration which matches the
         /// one used by the request.  We do this because everywhere we deal with requests and results beyond this function, we
         /// use configuration ids, which are assigned once by the Build Manager and are global to the system.  If we do
-        /// not have a global configuration id, we can't check to see if we already have build results for the request, so we 
+        /// not have a global configuration id, we can't check to see if we already have build results for the request, so we
         /// cannot send the request out.  Thus, first we determine the configuration id.
-        /// 
+        ///
         /// Assuming we don't have the global configuration id locally, we will send the configuration to the Build Manager.
         /// It will look up or assign the global configuration id and send it back to us.
-        /// 
+        ///
         /// Once we have the global configuration id, we can then look up results locally.  If we have enough results to fulfill
         /// the request, we give them back to the request, otherwise we have to forward the request to the Build Mangager
         /// for scheduling.
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 132cb665bb1..5f73ac08e8b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -29,12 +29,10 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         /// <param name="host">The component host.</param>
         /// <param name="enableReuse">Whether this node may be reused for a later build.</param>
         /// <param name="lowPriority">Whether this node is low priority.</param>
         internal NodeEndpointOutOfProc(
-            string pipeName, 
             IBuildComponentHost host,
             bool enableReuse,
             bool lowPriority)
@@ -44,7 +42,7 @@ internal NodeEndpointOutOfProc(
             _enableReuse = enableReuse;
             _lowPriority = lowPriority;
 
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 11ea72ba505..12237b65bec 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -6,6 +6,7 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Utilities;
 
@@ -76,7 +77,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
-            if (_nodeContexts.Count == ComponentHost.BuildParameters.MaxNodeCount)
+            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index ef21df23454..9d7adfb26a6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -355,7 +355,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(nodeProcessId);
 
             NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -590,7 +590,7 @@ private static string GetCurrentHost()
 #if RUNTIME_TYPE_NETCORE || MONO
             if (CurrentHost == null)
             {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, 2),
+                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
                     NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
                 if (File.Exists(dotnetExe))
                 {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 2a917d6eaee..5d6c5f8f2cc 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -372,7 +372,9 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
 
                     if (s_msbuildName == null)
                     {
-                        s_msbuildName = "MSBuild.exe";
+                        s_msbuildName = (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET
+                            ? "MSBuild.dll"
+                            : "MSBuild.exe";
                     }
                 }
 
@@ -498,7 +500,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
-            if (AvailableNodes == 0)
+            if (AvailableNodes <= 0)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
index 4e6e5be0145..57c0e51523e 100644
--- a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
@@ -121,7 +121,7 @@ public IDictionary<int, ISet<string>> WarningsAsMessagesByProject
         /// </summary>
         public void Consume(BuildEventArgs buildEvent)
         {
-            ErrorUtilities.VerifyThrow(false, "Do not use this method for the transport sink");
+            ErrorUtilities.ThrowInternalError("Do not use this method for the transport sink");
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 97b7512d14e..eb5e38969a2 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -201,8 +201,8 @@ void IEventSource4.IncludeEvaluationPropertiesAndItems()
         #region IEventSink Methods
 
         /// <summary>
-        /// Raises the given event to all registered loggers. This method up-cast the events
-        /// extracted from the queue.
+        /// Raises the given event to all registered loggers.
+        /// This method casts the events extracted from the queue to a more specific type.
         /// </summary>
         /// <param name="buildEvent">BuildEventArgs</param>
         /// <param name="sinkId">Note this is not used in the eventsource sink</param>
@@ -212,75 +212,60 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)
         }
 
         /// <summary>
-        /// Raises the given event to all registered loggers. This method up-cast the events
-        /// extracted from the queue.
+        /// Raises the given event to all registered loggers.
+        /// This method casts the events extracted from the queue to a more specific type.
         /// </summary>
         public void Consume(BuildEventArgs buildEvent)
         {
-            // FXCop may complain that there are unecessary casts here, and there are, but
-            // using "as" and allocating another variable for each event is extremely costly
-            // and is much slower then this approach even with the additional casts
-            if (buildEvent is BuildMessageEventArgs)
+            switch (buildEvent)
             {
-                this.RaiseMessageEvent(null, (BuildMessageEventArgs)buildEvent);
-            }
-            else if (buildEvent is TaskStartedEventArgs)
-            {
-                this.RaiseTaskStartedEvent(null, (TaskStartedEventArgs)buildEvent);
-            }
-            else if (buildEvent is TaskFinishedEventArgs)
-            {
-                this.RaiseTaskFinishedEvent(null, (TaskFinishedEventArgs)buildEvent);
-            }
-            else if (buildEvent is TargetStartedEventArgs)
-            {
-                this.RaiseTargetStartedEvent(null, (TargetStartedEventArgs)buildEvent);
-            }
-            else if (buildEvent is TargetFinishedEventArgs)
-            {
-                this.RaiseTargetFinishedEvent(null, (TargetFinishedEventArgs)buildEvent);
-            }
-            else if (buildEvent is ProjectStartedEventArgs)
-            {
-                this.RaiseProjectStartedEvent(null, (ProjectStartedEventArgs)buildEvent);
-            }
-            else if (buildEvent is ProjectFinishedEventArgs)
-            {
-                this.RaiseProjectFinishedEvent(null, (ProjectFinishedEventArgs)buildEvent);
-            }
-            else if (buildEvent is BuildStartedEventArgs)
-            {
-                HaveLoggedBuildStartedEvent = true;
-                this.RaiseBuildStartedEvent(null, (BuildStartedEventArgs)buildEvent);
-            }
-            else if (buildEvent is BuildFinishedEventArgs)
-            {
-                HaveLoggedBuildFinishedEvent = true;
-                this.RaiseBuildFinishedEvent(null, (BuildFinishedEventArgs)buildEvent);
-            }
-            else if (buildEvent is CustomBuildEventArgs)
-            {
-                this.RaiseCustomEvent(null, (CustomBuildEventArgs)buildEvent);
-            }
-            else if (buildEvent is BuildStatusEventArgs)
-            {
-                this.RaiseStatusEvent(null, (BuildStatusEventArgs)buildEvent);
-            }
-            else if (buildEvent is BuildWarningEventArgs)
-            {
-                this.RaiseWarningEvent(null, (BuildWarningEventArgs)buildEvent);
-            }
-            else if (buildEvent is BuildErrorEventArgs)
-            {
-                this.RaiseErrorEvent(null, (BuildErrorEventArgs)buildEvent);
-            }
-            else if (buildEvent is TelemetryEventArgs)
-            {
-                this.RaiseTelemetryEvent(null, (TelemetryEventArgs) buildEvent);
-            }
-            else
-            {
-                ErrorUtilities.VerifyThrow(false, "Unknown event args type.");
+                case BuildMessageEventArgs buildMessageEvent:
+                    RaiseMessageEvent(null, buildMessageEvent);
+                    break;
+                case TaskStartedEventArgs taskStartedEvent:
+                    RaiseTaskStartedEvent(null, taskStartedEvent);
+                    break;
+                case TaskFinishedEventArgs taskFinishedEvent:
+                    RaiseTaskFinishedEvent(null, taskFinishedEvent);
+                    break;
+                case TargetStartedEventArgs targetStartedEvent:
+                    RaiseTargetStartedEvent(null, targetStartedEvent);
+                    break;
+                case TargetFinishedEventArgs targetFinishedEvent:
+                    RaiseTargetFinishedEvent(null, targetFinishedEvent);
+                    break;
+                case ProjectStartedEventArgs projectStartedEvent:
+                    RaiseProjectStartedEvent(null, projectStartedEvent);
+                    break;
+                case ProjectFinishedEventArgs projectFinishedEvent:
+                    RaiseProjectFinishedEvent(null, projectFinishedEvent);
+                    break;
+                case BuildStartedEventArgs buildStartedEvent:
+                    HaveLoggedBuildStartedEvent = true;
+                    RaiseBuildStartedEvent(null, buildStartedEvent);
+                    break;
+                case BuildFinishedEventArgs buildFinishedEvent:
+                    HaveLoggedBuildFinishedEvent = true;
+                    RaiseBuildFinishedEvent(null, buildFinishedEvent);
+                    break;
+                case CustomBuildEventArgs customBuildEvent:
+                    RaiseCustomEvent(null, customBuildEvent);
+                    break;
+                case BuildStatusEventArgs buildStatusEvent:
+                    RaiseStatusEvent(null, buildStatusEvent);
+                    break;
+                case BuildWarningEventArgs buildWarningEvent:
+                    RaiseWarningEvent(null, buildWarningEvent);
+                    break;
+                case BuildErrorEventArgs buildErrorEvent:
+                    RaiseErrorEvent(null, buildErrorEvent);
+                    break;
+                case TelemetryEventArgs telemetryEvent:
+                    RaiseTelemetryEvent(null, telemetryEvent);
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalError("Unknown event args type.");
+                    break;
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 19ed313b922..117f5195448 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1417,7 +1417,7 @@ private void RouteBuildEvent(object loggingEvent)
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown logging item in queue:" + loggingEvent.GetType().FullName);
+                ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
             }
 
             if (buildEventArgs is BuildWarningEventArgs warningEvent)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 3e676950ea5..3fde04be279 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -156,8 +156,7 @@ ElementLocation elementLocation
                         // to really loop here... it's just that the foreach is the only way I can
                         // figure out how to get data out of the hashtable without knowing any of the
                         // keys!
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false,
-                            elementLocation, "CannotReferenceItemMetadataWithoutItemName", unqualifiedMetadataName);
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotReferenceItemMetadataWithoutItemName", unqualifiedMetadataName);
                     }
                 }
                 else
@@ -410,7 +409,7 @@ ElementLocation elementLocation
                     }
                     catch (InvalidOperationException e)
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation,
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation,
                             "CannotEvaluateItemMetadata", metadataName, e.Message);
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 109cb49b9bf..165b1f2b427 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -28,8 +28,6 @@ internal class ItemGroupIntrinsicTask : IntrinsicTask
         /// </summary>
         private ProjectItemGroupTaskInstance _taskInstance;
 
-        private EngineFileUtilities _engineFileUtilities;
-
         /// <summary>
         /// Instantiates an ItemGroup task
         /// </summary>
@@ -41,7 +39,6 @@ public ItemGroupIntrinsicTask(ProjectItemGroupTaskInstance taskInstance, TargetL
             : base(loggingContext, projectInstance, logTaskInputs)
         {
             _taskInstance = taskInstance;
-            _engineFileUtilities = EngineFileUtilities.Default;
         }
 
         /// <summary>
@@ -431,7 +428,7 @@ ISet<string> removeMetadata
                     // The expression is not of the form "@(X)". Treat as string
 
                     // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621
-                    string[] includeSplitFiles = _engineFileUtilities.GetFileListEscaped(
+                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
                         Project.Directory,
                         includeSplit,
                         excludes);
@@ -455,7 +452,7 @@ ISet<string> removeMetadata
 
             foreach (string excludeSplit in excludes)
             {
-                string[] excludeSplitFiles = _engineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
 
                 foreach (string excludeSplitFile in excludeSplitFiles)
                 {
@@ -540,7 +537,7 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
                 // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
                 // as literals. Everything else is safe to unescape at this point, since we're only matching
                 // against the file system.
-                string[] fileList = _engineFileUtilities.GetFileListEscaped(Project.Directory, piece);
+                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
 
                 foreach (string file in fileList)
                 {
@@ -586,7 +583,7 @@ private List<ProjectItemInstance> FindItemsMatchingMetadataSpecification(
             ItemSpec<ProjectPropertyInstance, ProjectItemInstance> itemSpec = new ItemSpec<ProjectPropertyInstance, ProjectItemInstance>(child.Remove, expander, child.RemoveLocation, Project.Directory, true);
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
                 itemSpec.Fragments.All(f => f is ItemSpec<ProjectPropertyInstance, ProjectItemInstance>.ItemExpressionFragment),
-                new BuildEventFileInfo(string.Empty),
+                BuildEventFileInfo.Empty,
                 "OM_MatchOnMetadataIsRestrictedToReferencedItems",
                 child.RemoveLocation,
                 child.Remove);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 5fdd1a3e145..efe47bf3381 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -709,7 +709,7 @@ private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost)
                 catch (ArgumentException e)
                 {
                     // handle errors in string-->bool conversion
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _taskNode.ContinueOnErrorLocation, "InvalidContinueOnErrorAttribute", _taskNode.Name, e.Message);
+                    ProjectErrorUtilities.ThrowInvalidProject(_taskNode.ContinueOnErrorLocation, "InvalidContinueOnErrorAttribute", _taskNode.Name, e.Message);
                 }
             }
 
@@ -740,7 +740,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
             if (!taskExecutionHost.SetTaskParameters(_taskNode.ParametersForBuild))
             {
                 // The task cannot be initialized.
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _targetChildInstance.Location, "TaskParametersError", _taskNode.Name, String.Empty);
+                ProjectErrorUtilities.ThrowInvalidProject(_targetChildInstance.Location, "TaskParametersError", _taskNode.Name, String.Empty);
             }
             else
             {
@@ -938,8 +938,14 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 // that is logged as an error. MSBuild tasks are an exception because
                 // errors are not logged directly from them, but the tasks spawned by them.
                 IBuildEngine be = host.TaskInstance.BuildEngine;
-                if (taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors && (be is TaskHost th ? th.BuildRequestsSucceeded : false) && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true))
+                if (taskReturned // if the task returned
+                    && !taskResult // and it returned false
+                    && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
+                    && (be is TaskHost th ? th.BuildRequestsSucceeded : false)
+                    && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true) // and it's not allowed to fail unless it logs an error
+                    && !(_cancellationToken.CanBeCanceled && _cancellationToken.IsCancellationRequested)) // and it wasn't cancelled
                 {
+                    // Then decide how to log MSB4181
                     if (_continueOnError == ContinueOnError.WarnAndContinue)
                     {
                         taskLoggingContext.LogWarning(null,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 154ace42f96..0c07dae6d6f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -455,8 +455,9 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                 {
                     e.BuildEventContext = _taskLoggingContext.BuildEventContext;
                     _taskLoggingContext.LoggingService.LogBuildEvent(e);
-                    _taskLoggingContext.HasLoggedErrors = true;
                 }
+                
+                 _taskLoggingContext.HasLoggedErrors = true;
             }
         }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 3f541b05568..23c505ff896 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -35,6 +36,8 @@ public override void ClearCaches()
 
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
+
             SdkResult result;
 
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
@@ -44,7 +47,9 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
             else
             {
                 // Get the dictionary for the specified submission if one is already added otherwise create a new dictionary for the submission.
-                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _cache.GetOrAdd(submissionId, new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
+                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _cache.GetOrAdd(
+                    submissionId,
+                    _ => new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
 
                 /*
                  * Get a Lazy<SdkResult> if available, otherwise create a Lazy<SdkResult> which will resolve the SDK with the SdkResolverService.Instance.  If multiple projects are attempting to resolve
@@ -66,6 +71,8 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
             }
 
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success);
+
             return result;
         }
     }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 6f90dacaeb4..ff98112817b 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -11,6 +11,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Reflection;
+using Microsoft.Build.Eventing;
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
@@ -115,7 +116,9 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
 
                 try
                 {
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStart();
                     result = (SdkResult)sdkResolver.Resolve(sdk, context, resultFactory);
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
                 }
                 catch (Exception e) when ((e is FileNotFoundException || e is FileLoadException) && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal))
                 {
@@ -232,8 +235,11 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)
                     return;
                 }
 
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
                 _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
             }
+
         }
 
         private void SetResolverState(int submissionId, SdkResolver resolver, object state)
@@ -241,7 +247,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
             // Do not set state for resolution requests that are not associated with a valid build submission ID
             if (submissionId != BuildEventContext.InvalidSubmissionId)
             {
-                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(submissionId, new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
+                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(
+                    submissionId,
+                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 9e500181510..ae59a7b50af 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -239,9 +239,8 @@ public NodeEngineShutdownReason Run(bool enableReuse, out Exception shutdownExce
         public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception shutdownException)
         {
             // Console.WriteLine("Run called at {0}", DateTime.Now);
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + Process.GetCurrentProcess().Id);
 
-            _nodeEndpoint = new NodeEndpointOutOfProc(pipeName, this, enableReuse, lowPriority);
+            _nodeEndpoint = new NodeEndpointOutOfProc(this, enableReuse, lowPriority);
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 2cc6ab1f7b4..6d55273c55c 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -768,7 +768,7 @@ Func<string, bool> GetReferenceFilter()
                     }
 
                     var fragments = items.SelectMany(i => ExpressionShredder.SplitSemiColonSeparatedList(i.EvaluatedInclude));
-                    var glob = new CompositeGlob(
+                    var glob = CompositeGlob.Create(
                         fragments
                             .Select(s => MSBuildGlob.Parse(Project.Directory, s)));
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index f6a291d929c..77497354b7b 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -12,7 +12,6 @@
 #endif
 using System.Text;
 using System.Threading;
-using System.Threading.Tasks;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
@@ -442,9 +441,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                 }
                 else
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject
+                    ProjectErrorUtilities.ThrowInvalidProject
                     (
-                        false,
                         parameterLocation,
                         "UnsupportedTaskParameterTypeError",
                         parameter.PropertyType.FullName,
@@ -482,9 +480,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
 
                 // We do not recover from a task exception while getting outputs,
                 // so do not merely set gatheredGeneratedOutputsSuccessfully = false; here
-                ProjectErrorUtilities.VerifyThrowInvalidProject
+                ProjectErrorUtilities.ThrowInvalidProject
                 (
-                    false,
                     parameterLocation,
                     "FailedToRetrieveTaskOutputs",
                     _taskName,
@@ -500,9 +497,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                     throw;
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject
+                ProjectErrorUtilities.ThrowInvalidProject
                 (
-                    false,
                     parameterLocation,
                     "FailedToRetrieveTaskOutputs",
                     _taskName,
@@ -1183,11 +1179,9 @@ out bool taskParameterSet
                         {
                             // We only allow a single item to be passed into a parameter of ITaskItem.
 
-                            // Some of the computation (expansion) here is expensive, so don't make the above
-                            // "if" statement directly part of the first param to VerifyThrowInvalidProject.
-                            ProjectErrorUtilities.VerifyThrowInvalidProject
+                            // Some of the computation (expansion) here is expensive, so don't switch to VerifyThrowInvalidProject.
+                            ProjectErrorUtilities.ThrowInvalidProject
                                 (
-                                false,
                                 parameterLocation,
                                 "CannotPassMultipleItemsIntoScalarParameter",
                                 _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation),
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 389f1f3cf6e..cb08aee7b3e 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1810,7 +1810,7 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// </summary>
         /// <remarks>
         /// This is sealed because it is virtual and called in a constructor; by sealing it we
-        /// satisfy FXCop that nobody will override it to do something that would rely on
+        /// satisfy the rule that nobody will override it to do something that would rely on
         /// unconstructed state.
         /// Should be protected+internal.
         /// </remarks>
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 80d7bdaad22..c1e3f8efe62 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -8,7 +8,9 @@
 using System.Security;
 using System.Text;
 using System.Xml;
+#if !NETFRAMEWORK || MONO
 using Microsoft.Build.Shared;
+#endif
 
 using XMakeAttributes = Microsoft.Build.Shared.XMakeAttributes;
 using ProjectFileErrorUtilities = Microsoft.Build.Shared.ProjectFileErrorUtilities;
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index f3e2c331c50..e0e9059c984 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Text;
 using System.Globalization;
+using System.Runtime.InteropServices;
 using System.Security;
 using System.Text.Json;
 using System.Text.RegularExpressions;
@@ -114,6 +115,12 @@ public sealed class SolutionFile
         private Version _currentVisualStudioVersion;
         private int _currentLineNumber;
 
+        // TODO: Unify to NativeMethodsShared.OSUsesCaseSensitive paths
+        // when possible.
+        private static StringComparer _pathComparer = RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
+            ? StringComparer.Ordinal
+            : StringComparer.OrdinalIgnoreCase;
+
         #endregion
 
         #region Constructors
@@ -202,7 +209,12 @@ internal string FullPath
             {
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
-                if (FileUtilities.IsSolutionFilterFilename(value))
+                // To reduce code duplication, this should be
+                //   if (FileUtilities.IsSolutionFilterFilename(value))
+                // But that's in Microsoft.Build.Framework and this codepath
+                // is called from old versions of NuGet that can't resolve
+                // Framework (see https://github.com/dotnet/msbuild/issues/5313).
+                if (value.EndsWith(".slnf", StringComparison.OrdinalIgnoreCase))
                 {
                     ParseSolutionFilter(value);
                 }
@@ -386,7 +398,7 @@ private void ParseSolutionFilter(string solutionFilterFile)
 
                 SolutionFileDirectory = Path.GetDirectoryName(_solutionFile);
 
-                _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                _solutionFilter = new HashSet<string>(_pathComparer);
                 foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
                 {
                     _solutionFilter.Add(FileUtilities.FixFilePath(project.GetString()));
@@ -549,7 +561,7 @@ internal void ParseSolution()
 
             if (_solutionFilter != null)
             {
-                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, _pathComparer);
                 foreach (ProjectInSolution project in _projectsInOrder)
                 {
                     projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 625352ba374..43318152844 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -1133,9 +1133,8 @@ private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolutio
                 {
                     if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                     {
-                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        ProjectFileErrorUtilities.ThrowInvalidProjectFile
                             (
-                            false,
                             "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(traversalProject.FullPath),
                             "SolutionParseProjectDepNotFoundError",
@@ -1206,9 +1205,8 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
             if (project.ProjectType == SolutionProjectType.WebProject)
             {
 #if !FEATURE_ASPNET_COMPILER
-                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile
                     (
-                    false,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(_solutionFile.FullPath),
                     "AspNetCompiler.UnsupportedMSBuildVersion",
@@ -1295,9 +1293,8 @@ private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, Proj
             {
                 if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                 {
-                    ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile
                         (
-                        false,
                         "SubCategoryForSolutionParsingErrors",
                         new BuildEventFileInfo(traversalProject.FullPath),
                         "SolutionParseProjectDepNotFoundError",
@@ -1557,9 +1554,8 @@ private void ValidateTargetFrameworkForWebProject(ProjectInSolution project)
             }
             if (!isDotNetFramework)
             {
-                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile
                     (
-                    false,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(_solutionFile.FullPath),
                     "AspNetCompiler.InvalidTargetFrameworkMonikerNotDotNET",
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index d842373c86c..df1d8ed8eb4 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -32,6 +32,7 @@
 using EvaluationItemSpec = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
 using EvaluationItemExpressionFragment = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>.ItemExpressionFragment;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using Microsoft.Build.FileSystem;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -68,6 +69,11 @@ public class Project : ILinkableObject
         internal ProjectLink Link => implementation;
         object ILinkableObject.Link => IsLinked ? Link : null;
 
+        /// <summary>
+        /// Host-provided factory for <see cref="IDirectoryCache"/> interfaces to be used during evaluation.
+        /// </summary>
+        private readonly IDirectoryCacheFactory _directoryCacheFactory;
+
         /// <summary>
         /// Default project template options (include all features).
         /// </summary>
@@ -250,20 +256,22 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
             ProjectCollection = projectCollection;
-            var defaultImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            var defaultImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings);
             implementationInternal = (IProjectLinkInternal)defaultImplementation;
             implementation = defaultImplementation;
 
+            _directoryCacheFactory = directoryCacheFactory;
             defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
         }
 
@@ -342,21 +350,23 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
             ProjectCollection = projectCollection;
-            var defailtImplementation = new ProjectImpl(this, xmlReader, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
-            implementationInternal = (IProjectLinkInternal)defailtImplementation;
-            implementation = defailtImplementation;
+            var defaultImplementation = new ProjectImpl(this, xmlReader, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            implementationInternal = (IProjectLinkInternal)defaultImplementation;
+            implementation = defaultImplementation;
 
-            defailtImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            _directoryCacheFactory = directoryCacheFactory;
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
         }
 
         /// <summary>
@@ -436,26 +446,29 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
             ProjectCollection = projectCollection;
-            var defailtImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
-            implementationInternal = (IProjectLinkInternal)defailtImplementation;
-            implementation = defailtImplementation;
+            var defaultImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            implementationInternal = (IProjectLinkInternal)defaultImplementation;
+            implementation = defaultImplementation;
+
+            _directoryCacheFactory = directoryCacheFactory;
 
             // Note: not sure why only this ctor flavor do TryUnloadProject
             // seems the XmlReader based one should also clean the same way.
             try
             {
-                defailtImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
             }
             catch (Exception ex)
             {
@@ -488,7 +501,8 @@ public static Project FromFile(string file, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -505,7 +519,8 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -522,7 +537,8 @@ public static Project FromXmlReader(XmlReader reader, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -1767,6 +1783,18 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
+        /// <summary>
+        /// Returns <see cref="IDirectoryCache"/> as provided by the <see cref="IDirectoryCacheFactory"/> passed when creating the
+        /// project, specific for a given evaluation ID.
+        /// </summary>
+        /// <param name="evaluationId">The evaluation ID for which the cache is requested.</param>
+        /// <returns>An <see cref="IDirectoryCache"/> implementation, or null if this project has no <see cref="IDirectoryCacheFactory"/>
+        /// associated with it or it returned null.</returns>
+        internal IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
+        {
+            return _directoryCacheFactory?.GetDirectoryCacheForEvaluation(evaluationId);
+        }
+
         /// <summary>
         /// Internal project evaluation implementation.
         /// </summary>
@@ -1829,8 +1857,7 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
-            public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+            public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
                 ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -2548,7 +2575,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 }
 
                 ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.TextFragment).ToImmutableArray();
-                var includeGlob = new CompositeGlob(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
+                var includeGlob = CompositeGlob.Create(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
 
                 IEnumerable<string> excludeFragmentStrings = Enumerable.Empty<string>();
                 IMSBuildGlob excludeGlob = null;
@@ -2567,7 +2594,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
                 {
                     removeFragmentStrings = removeItemElement.FragmentStrings;
-                    removeGlob = new CompositeGlob(removeItemElement.Globs);
+                    removeGlob = CompositeGlob.Create(removeItemElement.Globs);
                 }
 
                 var includeGlobWithGaps = CreateIncludeGlobWithGaps(includeGlob, excludeGlob, removeGlob);
@@ -2577,17 +2604,13 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
 
             private static IMSBuildGlob CreateIncludeGlobWithGaps(IMSBuildGlob includeGlob, IMSBuildGlob excludeGlob, IMSBuildGlob removeGlob)
             {
-                if (excludeGlob == null)
+                return (excludeGlob, removeGlob) switch
                 {
-                    return removeGlob == null ? includeGlob :
-                        new MSBuildGlobWithGaps(includeGlob, removeGlob);
-                }
-                else
-                {
-                    return new MSBuildGlobWithGaps(includeGlob,
-                        removeGlob == null ? excludeGlob :
-                        new CompositeGlob(excludeGlob, removeGlob));
-                }
+                    (null,     null)     => includeGlob,
+                    (not null, null)     => new MSBuildGlobWithGaps(includeGlob, excludeGlob),
+                    (null,     not null) => new MSBuildGlobWithGaps(includeGlob, removeGlob),
+                    (not null, not null) => new MSBuildGlobWithGaps(includeGlob, new CompositeGlob(excludeGlob, removeGlob))
+                };
             }
 
             private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dictionary<string, CumulativeRemoveElementData> removeElementCache)
@@ -3623,6 +3646,7 @@ private void Reevaluate(
 
                 Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.Evaluate(
                     _data,
+                    Owner,
                     Xml,
                     loadSettings,
                     ProjectCollection.MaxNodeCount,
@@ -4164,7 +4188,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Prepares the data object for evaluation.
             /// </summary>
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
             {
                 DefaultTargets = null;
                 Properties = new PropertyDictionary<ProjectProperty>();
@@ -4172,7 +4196,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSyste
                 Items = new ItemDictionary<ProjectItem>();
                 ItemsIgnoringCondition = new ItemDictionary<ProjectItem>();
                 ItemsByEvaluatedIncludeCache = new MultiDictionary<string, ProjectItem>(StringComparer.OrdinalIgnoreCase);
-                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, fileSystem);
+                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext);
                 ItemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinition>(MSBuildNameIgnoreCaseComparer.Default);
                 Targets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
                 ImportClosure = new List<ResolvedImport>();
diff --git a/src/Build/Definition/ProjectOptions.cs b/src/Build/Definition/ProjectOptions.cs
index 44d2ecccfd6..fadfe73a6e3 100644
--- a/src/Build/Definition/ProjectOptions.cs
+++ b/src/Build/Definition/ProjectOptions.cs
@@ -1,6 +1,7 @@
 ﻿using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.FileSystem;
 
 namespace Microsoft.Build.Definition
 {
@@ -38,5 +39,10 @@ public class ProjectOptions
         /// The <see cref="EvaluationContext"/> to use for evaluation.
         /// </summary>
         public EvaluationContext EvaluationContext { get; set; }
+
+        /// <summary>
+        /// Provides <see cref="IDirectoryCache"/> to be used for evaluation.
+        /// </summary>
+        public IDirectoryCacheFactory DirectoryCacheFactory { get; set; }
     }
 }
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 77d32963bf6..b623fed7040 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -920,6 +920,17 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
 
+                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
+#if RUNTIME_TYPE_NETCORE
+                        "Core",
+#elif MONO
+                        NativeMethodsShared.IsMono ? "Mono" : "Full");
+#else
+                        "Full",
+#endif
+                        mayBeReserved: true));
+
+
                     // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
                     // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
                     int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
@@ -1087,7 +1098,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                 catch (XmlException e)
                 {
                     // handle XML errors in the default tasks file
-                    ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false, new BuildEventFileInfo(defaultTasksFile, e), taskFileError, e.Message);
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(defaultTasksFile, e), taskFileError, e.Message);
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 990a8b686cb..e2df26e70dd 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -135,8 +136,8 @@ private ToolsetConfigurationSection ConfigurationSection
                     }
                     catch (ConfigurationException ex)
                     {
-                        // ConfigurationException is obsolete, but we catch it rather than 
-                        // ConfigurationErrorsException (which is what we throw below) because it is more 
+                        // ConfigurationException is obsolete, but we catch it rather than
+                        // ConfigurationErrorsException (which is what we throw below) because it is more
                         // general and we don't want to miss catching some other derived exception.
                         InvalidToolsetDefinitionException.Throw(ex, "ConfigFileReadError", ElementLocation.Create(ex.Source, ex.Line, 0).LocationString, ex.BareMessage);
                     }
diff --git a/src/Build/ElementLocation/XmlAttributeWithLocation.cs b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
index 25820d1d1bb..2a8ad231e60 100644
--- a/src/Build/ElementLocation/XmlAttributeWithLocation.cs
+++ b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
@@ -72,7 +72,7 @@ internal ElementLocation Location
             {
                 // Caching the element location object saves significant memory
                 XmlDocumentWithLocation ownerDocumentWithLocation = (XmlDocumentWithLocation)OwnerDocument;
-                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath ?? String.Empty, StringComparison.OrdinalIgnoreCase))
                 {
                     _elementLocation = ElementLocation.Create(ownerDocumentWithLocation.FullPath, _elementLocation.Line, _elementLocation.Column);
                 }
@@ -90,4 +90,4 @@ public bool HasLineInfo()
             return Location.Line != 0;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 15c91a6f68e..1b3de4bb5e0 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -352,24 +352,17 @@ private void DetermineWhetherToLoadReadOnly(string fullPath)
                     // Only files from Microsoft
                     if (Path.GetFileName(fullPath).StartsWith("Microsoft.", StringComparison.OrdinalIgnoreCase))
                     {
-                        // If we are loading devdiv targets, we're in razzle
-                        if (Path.GetFileName(fullPath).StartsWith("Microsoft.DevDiv", StringComparison.OrdinalIgnoreCase))
-                        {
-                            _loadAsReadOnly = true;
-                        }
-                        else // Else, only load if they're in program files or windows directories
-                        {
-                            ErrorUtilities.VerifyThrow(Path.IsPathRooted(fullPath), "should be full path");
-                            string directory = Path.GetDirectoryName(fullPath);
+                        // Load read-only if they're in program files or windows directories
+                        ErrorUtilities.VerifyThrow(Path.IsPathRooted(fullPath), "should be full path");
+                        string directory = Path.GetDirectoryName(fullPath);
 
-                            string windowsFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
+                        string windowsFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
 
-                            if ((!String.IsNullOrEmpty(windowsFolder) && directory.StartsWith(windowsFolder, StringComparison.OrdinalIgnoreCase)) ||
-                                (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles32) && directory.StartsWith(FrameworkLocationHelper.programFiles32, StringComparison.OrdinalIgnoreCase)) ||
-                                (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles64) && directory.StartsWith(FrameworkLocationHelper.programFiles64, StringComparison.OrdinalIgnoreCase)))
-                            {
-                                _loadAsReadOnly = true;
-                            }
+                        if ((!String.IsNullOrEmpty(windowsFolder) && directory.StartsWith(windowsFolder, StringComparison.OrdinalIgnoreCase)) ||
+                            (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles32) && directory.StartsWith(FrameworkLocationHelper.programFiles32, StringComparison.OrdinalIgnoreCase)) ||
+                            (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles64) && directory.StartsWith(FrameworkLocationHelper.programFiles64, StringComparison.OrdinalIgnoreCase)))
+                        {
+                            _loadAsReadOnly = true;
                         }
                     }
                 }
diff --git a/src/Build/ElementLocation/XmlElementWithLocation.cs b/src/Build/ElementLocation/XmlElementWithLocation.cs
index 7da601d28b2..47446943860 100644
--- a/src/Build/ElementLocation/XmlElementWithLocation.cs
+++ b/src/Build/ElementLocation/XmlElementWithLocation.cs
@@ -92,7 +92,7 @@ internal ElementLocation Location
             {
                 // Caching the element location object saves significant memory
                 XmlDocumentWithLocation ownerDocumentWithLocation = (XmlDocumentWithLocation)OwnerDocument;
-                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath ?? String.Empty, StringComparison.OrdinalIgnoreCase))
                 {
                     _elementLocation = ElementLocation.Create(ownerDocumentWithLocation.FullPath, _elementLocation.Line, _elementLocation.Column);
                 }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 7a1e0aa25ad..56016a76d82 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -33,7 +33,7 @@ public sealed class InternalLoggerException : Exception
         /// <exception cref="InvalidOperationException"></exception>
         public InternalLoggerException()
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         /// <summary>
@@ -47,7 +47,7 @@ public InternalLoggerException()
         public InternalLoggerException(string message)
             : base(message)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         /// <summary>
@@ -62,7 +62,7 @@ public InternalLoggerException(string message)
         public InternalLoggerException(string message, Exception innerException)
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         #endregion
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 7b3e099fb4c..69df786fb83 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -18,30 +18,34 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (LeftChild.CanBoolEvaluate(state),
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
                      "ExpressionDoesNotEvaluateToBoolean",
                      LeftChild.GetUnexpandedValue(state),
                      LeftChild.GetExpandedValue(state),
                      state.Condition);
+            }
 
-            if (!LeftChild.BoolEvaluate(state))
+            if (!leftBool)
             {
                 // Short circuit
                 return false;
             }
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (RightChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     RightChild.GetUnexpandedValue(state),
-                     RightChild.GetExpandedValue(state),
-                     state.Condition);
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                {
+                    ProjectErrorUtilities.ThrowInvalidProject(
+                         state.ElementLocation,
+                         "ExpressionDoesNotEvaluateToBoolean",
+                         RightChild.GetUnexpandedValue(state),
+                         RightChild.GetExpandedValue(state),
+                         state.Condition);
+                }
 
-                return RightChild.BoolEvaluate(state);
+                return rightBool;
             }
         }
 
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 12547eaa3ae..d1ffa2a8248 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -90,8 +90,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // We haven't implemented any other "functions"
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject(
-                    false,
+                ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "UndefinedFunctionCall",
                     state.Condition,
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index d4862fec251..c85b95e088d 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -12,12 +12,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -56,14 +53,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// <returns></returns>
         internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject(
-                CanBoolEvaluate(state),
-                state.ElementLocation,
-                "ConditionNotBooleanDetail",
-                state.Condition,
-                GetExpandedValue(state));
-
-            return BoolEvaluate(state);
+            if (!TryBoolEvaluate(state, out bool boolValue))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ConditionNotBooleanDetail",
+                    state.Condition,
+                    GetExpandedValue(state));
+            }
+
+            return boolValue;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 6a457794da3..18e1caad924 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -48,36 +48,41 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            if (LeftChild.EvaluatesToEmpty(state) || RightChild.EvaluatesToEmpty(state))
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
+            if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
 
-                return Compare(LeftChild.EvaluatesToEmpty(state), RightChild.EvaluatesToEmpty(state));
+                return Compare(leftEmpty, rightEmpty);
             }
-
-            if (LeftChild.CanNumericEvaluate(state) && RightChild.CanNumericEvaluate(state))
+            else if (LeftChild.TryNumericEvaluate(state, out double leftNumericValue) && RightChild.TryNumericEvaluate(state, out double rightNumericValue))
             {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.NumericEvaluate(state));
+                // The left child evaluating to a number and the right child not evaluating to a number
+                // is insufficient to say they are not equal because $(MSBuildToolsVersion) evaluates to
+                // the string "Current" most of the time but when doing numeric comparisons, is treated
+                // as a version and returns "17.0" (or whatever the current tools version is). This means
+                // that if '$(MSBuildToolsVersion)' is "equal" to BOTH '17.0' and 'Current' (if 'Current'
+                // is 17.0).
+                return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.CanBoolEvaluate(state) && RightChild.CanBoolEvaluate(state))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
-                return Compare(LeftChild.BoolEvaluate(state), RightChild.BoolEvaluate(state));
+                return Compare(leftBoolValue, rightBoolValue);
             }
-            else // string comparison
-            {
-                string leftExpandedValue = LeftChild.GetExpandedValue(state);
-                string rightExpandedValue = RightChild.GetExpandedValue(state);
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (leftExpandedValue != null && rightExpandedValue != null,
-                     state.ElementLocation,
-                     "IllFormedCondition",
-                     state.Condition);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
-                UpdateConditionedProperties(state);
+            ProjectErrorUtilities.VerifyThrowInvalidProject
+                (leftExpandedValue != null && rightExpandedValue != null,
+                    state.ElementLocation,
+                    "IllFormedCondition",
+                    state.Condition);
 
-                return Compare(leftExpandedValue, rightExpandedValue);
-            }
+            UpdateConditionedProperties(state);
+
+            return Compare(leftExpandedValue, rightExpandedValue);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 0a2521feda7..2f5dd07d112 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Shared;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Evaluation
@@ -17,12 +18,17 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return !LeftChild.BoolEvaluate(state);
-        }
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ExpressionDoesNotEvaluateToBoolean",
+                    LeftChild.GetUnexpandedValue(state),
+                    LeftChild.GetExpandedValue(state),
+                    state.Condition);
+            }
 
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return LeftChild.CanBoolEvaluate(state);
+            return !boolValue;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index 0bd30600cbf..a86a3031bb3 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -38,46 +38,31 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            bool isLeftNum = LeftChild.CanNumericEvaluate(state);
-            bool isLeftVersion = LeftChild.CanVersionEvaluate(state);
-            bool isRightNum = RightChild.CanNumericEvaluate(state);
-            bool isRightVersion = RightChild.CanVersionEvaluate(state);
-            bool isNumeric = isLeftNum && isRightNum;
-            bool isVersion = isLeftVersion && isRightVersion;
-            bool isValidComparison = isNumeric || isVersion || (isLeftNum && isRightVersion) || (isLeftVersion && isRightNum);
+            bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
+            bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
+            bool isRightNum = RightChild.TryNumericEvaluate(state, out double rightNum);
+            bool isRightVersion = RightChild.TryVersionEvaluate(state, out Version rightVersion);
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                (isValidComparison,
-                 state.ElementLocation,
-                "ComparisonOnNonNumericExpression",
-                 state.Condition,
-                 /* helpfully display unexpanded token and expanded result in error message */
-                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
-
-            // If the values identify as numeric, make that comparison instead of the Version comparison since numeric has a stricter definition
-            if (isNumeric)
-            {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.NumericEvaluate(state));
-            }
-            else if (isVersion)
+            if ((!isLeftNum && !isLeftVersion) || (!isRightNum && !isRightVersion))
             {
-                return Compare(LeftChild.VersionEvaluate(state), RightChild.VersionEvaluate(state));
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ComparisonOnNonNumericExpression",
+                    state.Condition,
+                    /* helpfully display unexpanded token and expanded result in error message */
+                    isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
-            // If the numbers are of a mixed type, call that specific Compare method
-            if (isLeftNum && isRightVersion)
+            return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
             {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.VersionEvaluate(state));
-            }
-            else if (isLeftVersion && isRightNum)
-            {
-                return Compare(LeftChild.VersionEvaluate(state), RightChild.NumericEvaluate(state));
-            }
+                (true, _, true, _) => Compare(leftNum, rightNum),
+                (_, true, _, true) => Compare(leftVersion, rightVersion),
+                (true, _, _, true) => Compare(leftNum, rightVersion),
+                (_, true, true, _) => Compare(leftVersion, rightNum),
 
-            // Throw error here as this code should be unreachable
-            ErrorUtilities.ThrowInternalErrorUnreachable();
-            return false;
+                _ => false
+            };
         }
     }
 }
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 306db6d802b..fe21a15a1ad 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -21,60 +21,20 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        /// <summary>
-        /// Evaluate as boolean
-        /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Should be unreachable: all calls check CanBoolEvaluate() first
-            ErrorUtilities.VerifyThrow(false, "Can't evaluate a numeric expression as boolean.");
-            return false;
-        }
-
-        /// <summary>
-        /// Evaluate as numeric
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return ConversionUtilities.ConvertDecimalOrHexToDouble(_value);
-        }
-
-        /// <summary>
-        /// Evaluate as a Version
-        /// </summary>
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return Version.Parse(_value);
-        }
-
-        /// <summary>
-        /// Whether it can be evaluated as a boolean: never allowed for numerics
-        /// </summary>
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Numeric expressions are never allowed to be treated as booleans.
+            result = default;
             return false;
         }
 
-        /// <summary>
-        /// Whether it can be evaluated as numeric
-        /// </summary>
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            // It is not always possible to numerically evaluate even a numerical expression -
-            // for example, it may overflow a double. So check here.
-            return ConversionUtilities.ValidDecimalOrHexNumber(_value);
+            return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        /// <summary>
-        /// Whether it can be evaluated as a Version
-        /// </summary>
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            // Check if the value can be formatted as a Version number
-            // This is needed for nodes that identify as Numeric but can't be parsed as numbers (e.g. 8.1.1.0 vs 8.1)
-            Version unused;
-            return Version.TryParse(_value, out unused);
+            return Version.TryParse(_value, out result);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 918e188ff85..92609fd763e 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -11,48 +10,23 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        /// <summary>
-        /// Numeric evaluation is never allowed for operators
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Should be unreachable: all calls check CanNumericEvaluate() first
-            ErrorUtilities.VerifyThrow(false, "Cannot numeric evaluate an operator");
-            return 0.0D;
-        }
-
-        /// <summary>
-        /// Version evaluation is never allowed for operators
-        /// </summary>
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            ErrorUtilities.VerifyThrow(false, "Cannot version evaluate an operator");
-            return null;
-        }
-
-        /// <summary>
-        /// Whether boolean evaluation is allowed: always allowed for operators
-        /// </summary>
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
+            result = BoolEvaluate(state);
             return true;
         }
 
-        /// <summary>
-        /// Whether the node can be evaluated as a numeric: by default,
-        /// this is not allowed
-        /// </summary>
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
+            result = default;
             return false;
         }
 
-        /// <summary>
-        /// Whether the node can be evaluated as a version: by default,
-        /// this is not allowed
-        /// </summary>
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
+            result = default;
             return false;
         }
 
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index e9469f07aca..1ac1713a5aa 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -18,30 +18,34 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (LeftChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     LeftChild.GetUnexpandedValue(state),
-                     LeftChild.GetExpandedValue(state),
-                     state.Condition);
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ExpressionDoesNotEvaluateToBoolean",
+                    LeftChild.GetUnexpandedValue(state),
+                    LeftChild.GetExpandedValue(state),
+                    state.Condition);
+            }
 
-            if (LeftChild.BoolEvaluate(state))
+            if (leftBool)
             {
                 // Short circuit
                 return true;
             }
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (RightChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     RightChild.GetUnexpandedValue(state),
-                     RightChild.GetExpandedValue(state),
-                     state.Condition);
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                {
+                    ProjectErrorUtilities.ThrowInvalidProject(
+                        state.ElementLocation,
+                        "ExpressionDoesNotEvaluateToBoolean",
+                        RightChild.GetUnexpandedValue(state),
+                        RightChild.GetExpandedValue(state),
+                        state.Condition);
+                }
 
-                return RightChild.BoolEvaluate(state);
+                return rightBool;
             }
         }
 
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index ac231b18964..292226a5ed8 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -107,13 +107,13 @@ internal GenericExpressionNode Parse(string expression, ParserOptions optionSett
             if (!_lexer.Advance())
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
             }
             GenericExpressionNode node = Expr(expression);
             if (!_lexer.IsNext(Token.TokenType.EndOfInput))
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
             return node;
         }
@@ -177,7 +177,7 @@ private GenericExpressionNode BooleanTerm(string expression)
             if (node == null)
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
 
             if (!_lexer.IsNext(Token.TokenType.EndOfInput))
@@ -199,7 +199,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
                 if (rhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
 
                 OperatorExpressionNode andNode = new AndExpressionNode();
@@ -221,7 +221,7 @@ private GenericExpressionNode RelationalExpr(string expression)
                 if (lhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
 
                 OperatorExpressionNode node = RelationalOperation(expression);
@@ -284,7 +284,7 @@ private GenericExpressionNode Factor(string expression)
                 if (!Same(expression, Token.TokenType.LeftParenthesis))
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", _lexer.IsNextString(), errorPosition);
                     return null;
                 }
                 var arglist = new List<GenericExpressionNode>();
@@ -292,7 +292,7 @@ private GenericExpressionNode Factor(string expression)
                 if (!Same(expression, Token.TokenType.RightParenthesis))
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                     return null;
                 }
                 return new FunctionCallExpressionNode(current.String, arglist);
@@ -305,7 +305,7 @@ private GenericExpressionNode Factor(string expression)
                 else
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
             }
             else if (Same(expression, Token.TokenType.Not))
@@ -315,7 +315,7 @@ private GenericExpressionNode Factor(string expression)
                 if (expr == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
                 notNode.LeftChild = expr;
                 return notNode;
@@ -323,7 +323,7 @@ private GenericExpressionNode Factor(string expression)
             else
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
             return null;
         }
@@ -384,11 +384,11 @@ private bool Same(string expression, Token.TokenType token)
                     errorPosition = _lexer.GetErrorPosition();
                     if (_lexer.UnexpectedlyFound != null)
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
+                        ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
                     }
                     else
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition);
+                        ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, _lexer.GetErrorResource(), expression, errorPosition);
                     }
                 }
                 return true;
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 5d24ea0949b..04af6a1a016 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -5,6 +5,7 @@
 using System;
 using System.Diagnostics;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
@@ -18,7 +19,7 @@ namespace Microsoft.Build.Evaluation
     ///    do {
     ///      s.Advance();
     ///    while (s.IsNext(Token.EndOfInput));
-    /// 
+    ///
     ///  After Advance() is called, you can get the current token (s.CurrentToken),
     ///  check it's type (s.IsNext()), get the string for it (s.NextString()).
     /// </summary>
@@ -112,7 +113,7 @@ internal int GetErrorPosition()
             return _errorPosition;
         }
 
-        // The string (usually a single character) we found unexpectedly. 
+        // The string (usually a single character) we found unexpectedly.
         // We might want to show it in the error message, to help the user spot the error.
         internal string UnexpectedlyFound
         {
@@ -265,7 +266,7 @@ internal bool Advance()
         }
 
         /// <summary>
-        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax, 
+        /// Parses either the $(propertyname) syntax or the %(metadataname) syntax,
         /// and returns the parsed string beginning with the '$' or '%', and ending with the
         /// closing parenthesis.
         /// </summary>
@@ -552,7 +553,7 @@ private bool ParseItemList()
         }
 
         /// <summary>
-        /// Parse any part of the conditional expression that is quoted. It may contain a property, item, or 
+        /// Parse any part of the conditional expression that is quoted. It may contain a property, item, or
         /// metadata element that needs expansion during evaluation.
         /// </summary>
         private bool ParseQuotedString()
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 61eabd438fd..54afb1dc6b8 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Diagnostics;
-
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
@@ -29,60 +28,35 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        /// <summary>
-        /// Evaluate as boolean
-        /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.ConvertStringToBool(GetExpandedValue(state));
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        /// <summary>
-        /// Evaluate as numeric
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
-                return ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
+                result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
+                return true;
             }
-
-            return ConversionUtilities.ConvertDecimalOrHexToDouble(GetExpandedValue(state));
-        }
-
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            else
             {
-                return Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
-
-            return Version.Parse(GetExpandedValue(state));
         }
 
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return ConversionUtilities.CanConvertStringToBool(GetExpandedValue(state));
-        }
-
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
+                result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
-
-            return ConversionUtilities.ValidDecimalOrHexNumber(GetExpandedValue(state));
-        }
-
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            else
             {
-                return true;
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
-
-            return Version.TryParse(GetExpandedValue(state), out _);
         }
 
         /// <summary>
@@ -98,6 +72,25 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
             {
                 if (_expandable)
                 {
+                    switch (_value.Length)
+                    {
+                        case 0:
+                            _cachedExpandedValue = String.Empty;
+                            return true;
+                        // If the length is 1 or 2, it can't possibly be a property, item, or metadata, and it isn't empty.
+                        case 1:
+                        case 2:
+                            _cachedExpandedValue = _value;
+                            return false;
+                        default:
+                            if (_value[1] != '(' || (_value[0] != '$' && _value[0] != '%' && _value[0] != '@') || _value[_value.Length - 1] != ')')
+                            {
+                                // This isn't just a property, item, or metadata value, and it isn't empty.
+                                return false;
+                            }
+                            break;
+                    }
+
                     string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 827d9465d75..19510f6d663 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -7,7 +7,6 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.FileSystem;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -43,27 +42,22 @@ public enum SharingPolicy
 
         internal ISdkResolverService SdkResolverService { get; }
         internal IFileSystem FileSystem { get; }
-        internal EngineFileUtilities EngineFileUtilities { get; }
+        internal FileMatcher FileMatcher { get; }
 
         /// <summary>
         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
         /// </summary>
         private ConcurrentDictionary<string, IReadOnlyList<string>> FileEntryExpansionCache { get; }
 
-        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
+        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem, ISdkResolverService sdkResolverService = null,
+            ConcurrentDictionary<string, IReadOnlyList<string>> fileEntryExpansionCache = null)
         {
-            // Unsupported case: isolated context with non null file system.
-            // Isolated means caches aren't reused, but the given file system might cache.
-            ErrorUtilities.VerifyThrowArgument(
-                policy == SharingPolicy.Shared || fileSystem == null,
-                "IsolatedContextDoesNotSupportFileSystem");
-
             Policy = policy;
 
-            SdkResolverService = new CachingSdkResolverService();
-            FileEntryExpansionCache = new ConcurrentDictionary<string, IReadOnlyList<string>>();
+            SdkResolverService = sdkResolverService ?? new CachingSdkResolverService();
+            FileEntryExpansionCache = fileEntryExpansionCache ?? new ConcurrentDictionary<string, IReadOnlyList<string>>();
             FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
-            EngineFileUtilities = new EngineFileUtilities(new FileMatcher(FileSystem, FileEntryExpansionCache));
+            FileMatcher = new FileMatcher(FileSystem, FileEntryExpansionCache);
         }
 
         /// <summary>
@@ -89,6 +83,12 @@ public static EvaluationContext Create(SharingPolicy policy)
         /// </param>
         public static EvaluationContext Create(SharingPolicy policy, MSBuildFileSystemBase fileSystem)
         {
+            // Unsupported case: isolated context with non null file system.
+            // Isolated means caches aren't reused, but the given file system might cache.
+            ErrorUtilities.VerifyThrowArgument(
+                policy == SharingPolicy.Shared || fileSystem == null,
+                "IsolatedContextDoesNotSupportFileSystem");
+
             var context = new EvaluationContext(
                 policy,
                 fileSystem);
@@ -124,5 +124,19 @@ internal EvaluationContext ContextForNewProject()
                     return null;
             }
         }
+
+        /// <summary>
+        /// Creates a copy of this <see cref="EvaluationContext"/> with a given <see cref="IFileSystem"/> swapped in.
+        /// </summary>
+        /// <param name="fileSystem">The file system to use by the new evaluation context.</param>
+        /// <returns>The new evaluation context.</returns>
+        internal EvaluationContext ContextWithFileSystem(IFileSystem fileSystem)
+        {
+            var newContext = new EvaluationContext(this.Policy, fileSystem, this.SdkResolverService, this.FileEntryExpansionCache)
+            {
+                _used = 1
+            };
+            return newContext;
+        }
     }
 }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 712307191f4..895624f438e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
@@ -20,6 +19,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
@@ -32,7 +32,7 @@
 using Constants = Microsoft.Build.Internal.Constants;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
-using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -144,6 +144,9 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private readonly int _submissionId;
 
+        /// <summary>
+        /// The evaluation context to use.
+        /// </summary>
         private readonly EvaluationContext _evaluationContext;
 
         /// <summary>
@@ -189,6 +192,7 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private Evaluator(
             IEvaluatorData<P, I, M, D> data,
+            Project project,
             ProjectRootElement projectRootElement,
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
@@ -206,6 +210,7 @@ private Evaluator(
         {
             ErrorUtilities.VerifyThrowInternalNull(data, nameof(data));
             ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
+            ErrorUtilities.VerifyThrowInternalNull(evaluationContext, nameof(evaluationContext));
             ErrorUtilities.VerifyThrowInternalNull(loggingService, nameof(loggingService));
             ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
 
@@ -220,12 +225,20 @@ private Evaluator(
                 // Wrap the IEvaluatorData<> object passed in.
                 data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
             }
-            _evaluationContext = evaluationContext ?? EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
+
+            // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
+            _evaluationContext = evaluationContext;
+            IDirectoryCache directoryCache = project?.GetDirectoryCacheForEvaluation(_evaluationLoggingContext.BuildEventContext.EvaluationId);
+            if (directoryCache is not null)
+            {
+                IFileSystem fileSystem = new DirectoryCacheFileSystemWrapper(evaluationContext.FileSystem, directoryCache);
+                _evaluationContext = evaluationContext.ContextWithFileSystem(fileSystem);
+            }
 
             // Create containers for the evaluation results
-            data.InitializeForEvaluation(toolsetProvider, _evaluationContext.FileSystem);
+            data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
 
-            _expander = new Expander<P, I>(data, data, _evaluationContext.FileSystem);
+            _expander = new Expander<P, I>(data, data, _evaluationContext);
 
             // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
             _expander.WarnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
@@ -284,6 +297,7 @@ private Evaluator(
         /// </remarks>
         internal static void Evaluate(
             IEvaluatorData<P, I, M, D> data,
+            Project project,
             ProjectRootElement root,
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
@@ -295,13 +309,14 @@ internal static void Evaluate(
             BuildEventContext buildEventContext,
             ISdkResolverService sdkResolverService,
             int submissionId,
-            EvaluationContext evaluationContext = null,
+            EvaluationContext evaluationContext,
             bool interactive = false)
         {
             MSBuildEventSource.Log.EvaluateStart(root.ProjectFileLocation.File);
             var profileEvaluation = (loadSettings & ProjectLoadSettings.ProfileEvaluation) != 0 || loggingService.IncludeEvaluationProfile;
             var evaluator = new Evaluator<P, I, M, D>(
                 data,
+                project,
                 root,
                 loadSettings,
                 maxNodeCount,
@@ -357,7 +372,7 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem
                     else
                     {
                         // The expression is not of the form "@(X)". Treat as string
-                        string[] includeSplitFilesEscaped = EngineFileUtilities.Default.GetFileListEscaped(rootDirectory, includeSplitEscaped);
+                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
 
                         if (includeSplitFilesEscaped.Length > 0)
                         {
@@ -2009,7 +2024,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     }
 
                     // Expand the wildcards and provide an alphabetical order list of import statements.
-                    importFilesEscaped = _evaluationContext.EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true);
+                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);
                 }
                 catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
                 {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index fe397e4469a..1e88d32aa72 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1,4 +1,4 @@
-// Copyright (c) Microsoft. All rights reserved.
+﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -13,7 +13,9 @@
 using System.Runtime.CompilerServices;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -111,9 +113,9 @@ internal enum ExpanderOptions
     /// Encapsulates the data necessary for expansion.
     /// </summary>
     /// <remarks>
-    /// Requires the caller to explicitly state what they wish to expand at the point of expansion (explicitly does not have a field for ExpanderOptions). 
+    /// Requires the caller to explicitly state what they wish to expand at the point of expansion (explicitly does not have a field for ExpanderOptions).
     /// Callers typically use a single expander in many locations, and this forces the caller to make explicit what they wish to expand at the point of expansion.
-    /// 
+    ///
     /// Requires the caller to have previously provided the necessary material for the expansion requested.
     /// For example, if the caller requests ExpanderOptions.ExpandItems, the Expander will throw if it was not given items.
     /// </remarks>
@@ -301,6 +303,11 @@ private void FlushFirstValueIfNeeded()
 
         private readonly IFileSystem _fileSystem;
 
+        /// <summary>
+        /// Non-null if the expander was constructed for evaluation.
+        /// </summary>
+        internal EvaluationContext EvaluationContext { get; }
+
         /// <summary>
         /// Creates an expander passing it some properties to use.
         /// Properties may be null.
@@ -312,6 +319,18 @@ internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
             _fileSystem = fileSystem;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties to use and the evaluation context.
+        /// Properties may be null.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext)
+        {
+            _properties = properties;
+            _usedUninitializedProperties = new UsedUninitializedProperties();
+            _fileSystem = evaluationContext.FileSystem;
+            EvaluationContext = evaluationContext;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties and items to use.
         /// Either or both may be null.
@@ -322,6 +341,16 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
             _items = items;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties and items to use, and the evaluation context.
+        /// Either or both may be null.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext)
+            : this(properties, evaluationContext)
+        {
+            _items = items;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
@@ -385,8 +414,8 @@ internal static bool ExpressionContainsItemVector(string expression)
         /// <summary>
         /// Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options.
         /// This is the standard form. Before using the expanded value, it must be unescaped, and this does that for you.
-        /// 
-        /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.        
+        ///
+        /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
         internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
@@ -399,7 +428,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         /// Expands embedded item metadata, properties, and embedded item lists (in that order) as specified in the provided options.
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
-        /// 
+        ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
         internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
@@ -465,7 +494,7 @@ internal IList<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, Expa
         /// and produces a list of items of the type for which it was specialized.
         /// If the expression is empty, returns an empty list.
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
-        /// 
+        ///
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
@@ -521,25 +550,25 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
 
         /// <summary>
         /// This is a specialized method for the use of TargetUpToDateChecker and Evaluator.EvaluateItemXml only.
-        /// 
+        ///
         /// Extracts the items in the given SINGLE item vector.
         /// For example, expands @(Compile->'%(foo)') to a set of items derived from the items in the "Compile" list.
         ///
         /// If there is in fact more than one vector in the expression, throws InvalidProjectFileException.
-        /// 
+        ///
         /// If there are no item expressions in the expression (for example a literal "foo.cpp"), returns null.
         /// If expression expands to no items, returns an empty list.
         /// If item expansion is not allowed by the provided options, returns null.
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
-        /// 
+        ///
         /// If the expression is a transform, any transformations to an expression that evaluates to nothing (i.e., because
-        /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means 
+        /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means
         /// that the length of the returned list is always the same as the length of the referenced item list in the input string.
         /// That's important for any correlation the caller wants to do.
-        /// 
+        ///
         /// If expression was a transform, 'isTransformExpression' is true, otherwise false.
         ///
-        /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
+        /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not
         /// have an item type set on it, it will be given the item type of the item vector to use.
         /// </summary>
         /// <typeparam name="T">Type of the items that should be returned.</typeparam>
@@ -1112,7 +1141,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 // where we've essentially read up to and copied into the target string.
                 int sourceIndex = 0;
 
-                // Search for "$(" in the expression.  Loop until we don't find it 
+                // Search for "$(" in the expression.  Loop until we don't find it
                 // any more.
                 while (propertyStartIndex != -1)
                 {
@@ -1142,9 +1171,9 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                     {
                         // Aha, we found the closing parenthesis.  All the stuff in
                         // between the "$(" and the ")" constitutes the property body.
-                        // Note: Current propertyStartIndex points to the "$", and 
+                        // Note: Current propertyStartIndex points to the "$", and
                         // propertyEndIndex points to the ")".  That's why we have to
-                        // add 2 for the start of the substring, and subtract 2 for 
+                        // add 2 for the start of the substring, and subtract 2 for
                         // the length.
                         string propertyBody;
 
@@ -1174,7 +1203,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
 
                         // Compat hack: WebProjects may have an import with a condition like:
-                        //       Condition=" '$(Solutions.VSVersion)' == '8.0'" 
+                        //       Condition=" '$(Solutions.VSVersion)' == '8.0'"
                         // These would have been '' in prior versions of msbuild but would be treated as a possible string function in current versions.
                         // Be compatible by returning an empty string here.
                         else if ((propertyEndIndex - (propertyStartIndex + 2)) == 19 && String.Equals(expression, "$(Solutions.VSVersion)", StringComparison.Ordinal))
@@ -1323,7 +1352,7 @@ internal static object ExpandPropertyBody(
                     }
                 }
 
-                // Find the property value in our property collection.  This 
+                // Find the property value in our property collection.  This
                 // will automatically return "" (empty string) if the property
                 // doesn't exist in the collection, and we're not executing a static function
                 if (!String.IsNullOrEmpty(propertyName))
@@ -1457,11 +1486,11 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 else if (property == null)
                 {
                     // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
-                    // 
-                    // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently 
+                    //
+                    // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
                     // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
-                    // 
-                    // Another pattern used is where a property concatonates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of 
+                    //
+                    // Another pattern used is where a property concatonates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
                     // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
                     if (usedUninitializedProperties.Warn && usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName != null)
                     {
@@ -1643,13 +1672,13 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         /// Expands item expressions, like @(Compile), possibly with transforms and/or separators.
         ///
         /// Item vectors are composed of a name, an optional transform, and an optional separator i.e.
-        /// 
+        ///
         ///     @(&lt;name&gt;->'&lt;transform&gt;','&lt;separator&gt;')
-        ///     
+        ///
         /// If a separator is not specified it defaults to a semi-colon. The transform expression is also optional, but if
         /// specified, it allows each item in the vector to have its item-spec converted to a different form. The transform
         /// expression can reference any custom metadata defined on the item, as well as the pre-defined item-spec modifiers.
-        /// 
+        ///
         /// NOTE:
         /// 1) white space between &lt;name&gt;, &lt;transform&gt; and &lt;separator&gt; is ignored
         ///    i.e. @(&lt;name&gt;, '&lt;separator&gt;') is valid
@@ -1659,19 +1688,19 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         ///    to empty strings
         ///
         /// if @(files) is a vector for the files a.txt and b.txt, then:
-        /// 
+        ///
         ///     "my list: @(files)"                                 expands to string     "my list: a.txt;b.txt"
-        /// 
+        ///
         ///     "my list: @(files,' ')"                             expands to string      "my list: a.txt b.txt"
-        /// 
+        ///
         ///     "my list: @(files, '')"                             expands to string      "my list: a.txtb.txt"
-        /// 
+        ///
         ///     "my list: @(files, '; ')"                           expands to string      "my list: a.txt; b.txt"
-        /// 
+        ///
         ///     "my list: @(files->'%(Filename)')"                  expands to string      "my list: a;b"
-        /// 
+        ///
         ///     "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to string      "my list: temp\a.xml temp\b.xml"
-        /// 
+        ///
         ///     "my list: @(files->'')                              expands to string      "my list: ;".
         /// </summary>
         /// <remarks>
@@ -1711,23 +1740,23 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
 
             /// <summary>
             /// Expands any item vector in the expression into items.
-            /// 
+            ///
             /// For example, expands @(Compile->'%(foo)') to a set of items derived from the items in the "Compile" list.
-            /// 
+            ///
             /// If there is no item vector in the expression (for example a literal "foo.cpp"), returns null.
             /// If the item vector expression expands to no items, returns an empty list.
             /// If item expansion is not allowed by the provided options, returns null.
             /// If there is an item vector but concatenated with something else, throws InvalidProjectFileException.
             /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
-            /// 
+            ///
             /// If the expression is a transform, any transformations to an expression that evaluates to nothing (i.e., because
-            /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means 
+            /// an item has no value for a piece of metadata) are optionally indicated with a null entry in the list. This means
             /// that the length of the returned list is always the same as the length of the referenced item list in the input string.
             /// That's important for any correlation the caller wants to do.
-            /// 
+            ///
             /// If expression was a transform, 'isTransformExpression' is true, otherwise false.
             ///
-            /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
+            /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not
             /// have an item type set on it, it will be given the item type of the item vector to use.
             /// </summary>
             /// <typeparam name="S">Type of the items provided by the item source used for expansion.</typeparam>
@@ -1795,7 +1824,7 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                 isTransformExpression = false;
                 bool brokeEarlyNonEmpty;
 
-                // If the incoming factory doesn't have an item type that it can use to 
+                // If the incoming factory doesn't have an item type that it can use to
                 // create items, it's our indication that the caller wants its items to have the type of the
                 // expression being expanded. For example, items from expanding "@(Compile") should
                 // have the item type "Compile".
@@ -1809,7 +1838,7 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                 if (expressionCapture.Separator != null)
                 {
                     // Reference contains a separator, for example @(Compile, ';').
-                    // We need to flatten the list into 
+                    // We need to flatten the list into
                     // a scalar and then create a single item. Basically we need this
                     // to be able to convert item lists with user specified separators into properties.
                     string expandedItemVector;
@@ -1874,18 +1903,18 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
             /// <summary>
             /// Expands an expression capture into a list of items
             /// If the capture uses a separator, then all the items are concatenated into one string using that separator.
-            /// 
+            ///
             /// Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
             /// </summary>
             /// <param name="isTransformExpression"></param>
             /// <param name="itemsFromCapture">
             /// List of items.
-            /// 
+            ///
             /// Item1 represents the item string, escaped
             /// Item2 represents the original item.
-            /// 
+            ///
             /// Item1 differs from Item2's string when it is coming from a transform.
-            /// 
+            ///
             /// </param>
             /// <param name="expander">The expander whose state will be used to expand any transforms.</param>
             /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression.</param>
@@ -2124,7 +2153,7 @@ ExpanderOptions options
                         builder.Append(";");
                     }
                 }
-                
+
                 return false;
             }
 
@@ -2216,7 +2245,7 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                         {
                             foreach (
                                 var resultantItem in
-                                EngineFileUtilities.Default.GetFileListEscaped(
+                                EngineFileUtilities.GetFileListEscaped(
                                     item.ProjectDirectory,
                                     item.EvaluatedIncludeEscaped,
                                     forceEvaluate: true))
@@ -2270,8 +2299,8 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                         }
                         catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
                         {
-                            // InvalidOperationException is how GetItemSpecModifier communicates invalid conditions upwards, so 
-                            // we do not want to rethrow in that case.  
+                            // InvalidOperationException is how GetItemSpecModifier communicates invalid conditions upwards, so
+                            // we do not want to rethrow in that case.
                             if (ExceptionHandling.NotExpectedException(e) && !(e is InvalidOperationException))
                             {
                                 throw;
@@ -2839,7 +2868,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
             }
 
             /// <summary>
-            /// Represents all the components of a transform function, including the ability to execute it. 
+            /// Represents all the components of a transform function, including the ability to execute it.
             /// </summary>
             /// <typeparam name="S">class, IItem.</typeparam>
             internal class TransformFunction<S>
@@ -2986,7 +3015,7 @@ private static class RegularExpressions
             /// <summary>
             /// Regular expression used to match item metadata references embedded in strings.
             /// For example, %(Compile.DependsOn) or %(DependsOn).
-            /// </summary> 
+            /// </summary>
             internal static readonly Lazy<Regex> ItemMetadataPattern = new Lazy<Regex>(
                 () => new Regex(ItemMetadataSpecification,
                     RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
@@ -3024,17 +3053,17 @@ private static class RegularExpressions
             /// <summary>
             /// Complete description of an item metadata reference, including the optional qualifying item type.
             /// For example, %(Compile.DependsOn) or %(DependsOn).
-            /// </summary> 
+            /// </summary>
             private const string ItemMetadataSpecification = @"%\(\s* (?<ITEM_SPECIFICATION>(?<ITEM_TYPE>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @")\s*\.\s*)? (?<NAME>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @") \s*\)";
 
             /// <summary>
-            /// description of an item vector with a transform, left hand side. 
-            /// </summary> 
+            /// description of an item vector with a transform, left hand side.
+            /// </summary>
             private const string ItemVectorWithTransformLHS = @"@\(\s*" + ProjectWriter.itemTypeOrMetadataNameSpecification + @"\s*->\s*'[^']*";
 
             /// <summary>
-            /// description of an item vector with a transform, right hand side. 
-            /// </summary> 
+            /// description of an item vector with a transform, right hand side.
+            /// </summary>
             private const string ItemVectorWithTransformRHS = @"[^']*'(\s*,\s*'[^']*')?\s*\)";
 
             /**************************************************************************************************************************
@@ -3402,10 +3431,10 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     }
 
                     // Handle special cases where the object type needs to affect the choice of method
-                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and 
+                    // The default binder and method invoke, often chooses the incorrect Equals and CompareTo and
                     // fails the comparison, because what we have on the right is generally a string.
                     // This special casing is to realize that its a comparison that is taking place and handle the
-                    // argument type coercion accordingly; effectively pre-preparing the argument type so 
+                    // argument type coercion accordingly; effectively pre-preparing the argument type so
                     // that it matches the left hand side ready for the default binder’s method invoke.
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", _methodMethodName, StringComparison.OrdinalIgnoreCase)))
                     {
@@ -3482,7 +3511,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                                 if ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                                 {
                                     // The standard binder failed, so do our best to coerce types into the arguments for the function
-                                    // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true. 
+                                    // This may happen if the types need coercion, but it may also happen if the object represents a type that contains open type parameters, that is, ContainsGenericParameters returns true.
                                     functionResult = LateBindExecute(ex, _bindingFlags, objectInstance, args, false /* is not constructor */);
                                 }
                                 else
@@ -3668,6 +3697,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(string.LastIndexOfAny), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = text.LastIndexOfAny(arg0.ToCharArray());
+                            return true;
+                        }
+                    }
                     else if (string.Equals(_methodMethodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
                     {
                         if (args.Length == 0)
@@ -4553,7 +4590,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
                 Type receiverType;
                 Tuple<string, Type> cachedTypeInformation;
 
-                // If we don't have a type name, we already know that we won't be able to find a type.  
+                // If we don't have a type name, we already know that we won't be able to find a type.
                 // Go ahead and return here -- otherwise the Type.GetType() calls below will throw.
                 if (string.IsNullOrWhiteSpace(typeName))
                 {
@@ -4775,7 +4812,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                 BindingFlags defaultBindingFlags = BindingFlags.IgnoreCase | BindingFlags.Public;
 
                 ReadOnlySpan<char> expressionFunctionAsSpan = expressionFunction.AsSpan();
-                
+
                 ReadOnlySpan<char> expressionSubstringAsSpan = argumentStartIndex > -1 ? expressionFunctionAsSpan.Slice(methodStartIndex, argumentStartIndex - methodStartIndex) : ReadOnlySpan<char>.Empty;
 
                 // There are arguments that need to be passed to the function
@@ -4903,7 +4940,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                             // We'll also allow the user to specify the leaf or full type name on the enum
                             string argument = args[n].ToString().Replace('|', ',').Replace(typeFullName, "").Replace(typeLeafName, "");
 
-                            // Parse the string representation of the argument into the destination enum                                
+                            // Parse the string representation of the argument into the destination enum
                             coercedArguments[n] = Enum.Parse(enumType, argument);
                         }
                         else
@@ -5133,7 +5170,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
     /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized. 
+    /// This class wraps information about properties which have been used before they are initialized.
     /// </summary>
     internal class UsedUninitializedProperties
     {
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index ffa04158d9d..1ea8786cf67 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -110,12 +110,14 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
         {
             List<ItemExpressionCapture> subExpressions = null;
 
-            if (expression.IndexOf('@') < 0)
+            int startIndex = expression.IndexOf('@', start, end - start);
+
+            if (startIndex < 0)
             {
                 return null;
             }
 
-            for (int i = start; i < end; i++)
+            for (int i = startIndex; i < end; i++)
             {
                 int restartPoint;
                 int startPoint;
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index af0265b01d3..7e2c9c5c85c 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -8,7 +8,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Evaluation.Context;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -210,7 +210,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
-        void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem);
+        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
 
         /// <summary>
         /// Indicates to the data block that evaluation has completed,
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index aa1cdeaa90b..479d5578559 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -7,6 +7,7 @@
 using System.Runtime.InteropServices;
 using System.Text.RegularExpressions;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index fbc0b6f6b1a..b2f33e70f30 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -97,7 +97,13 @@ public override IMSBuildGlob ToMSBuildGlob()
 
             protected override IMSBuildGlob CreateMsBuildGlob()
             {
-                return new CompositeGlob(ReferencedItems.Select(i => i.ItemAsValueFragment.ToMSBuildGlob()));
+                if (ReferencedItems.Count == 1)
+                {
+                    // Optimize the common case, avoiding allocation of enumerable/enumerator.
+                    return ReferencedItems[0].ItemAsValueFragment.ToMSBuildGlob();
+                }
+
+                return CompositeGlob.Create(ReferencedItems.Select(i => i.ItemAsValueFragment.ToMSBuildGlob()));
             }
 
             private bool InitReferencedItemsIfNecessary()
@@ -368,7 +374,13 @@ public IList<string> IntersectsWith(IReadOnlyDictionary<string, ItemDataCollecti
         /// </summary>
         public IMSBuildGlob ToMSBuildGlob()
         {
-            return new CompositeGlob(Fragments.Select(f => f.ToMSBuildGlob()));
+            if (Fragments.Count == 1)
+            {
+                // Optimize the common case, avoiding allocation of enumerable/enumerator.
+                return Fragments[0].ToMSBuildGlob();
+            }
+
+            return CompositeGlob.Create(Fragments.Select(f => f.ToMSBuildGlob()));
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 4c88a6d976f..c493969feb5 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -7,8 +7,8 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -285,9 +285,9 @@ public ProjectTargetInstance GetTarget(string targetName)
                 return _wrappedData.GetTarget(targetName);
             }
 
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
             {
-                _wrappedData.InitializeForEvaluation(toolsetProvider, fileSystem);
+                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext);
             }
 
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index da5f61449b6..c67b057ae9e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -3,6 +3,7 @@
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -19,7 +20,7 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         class IncludeOperation : LazyItemOperation
         {
             readonly int _elementOrder;
-            
+
             readonly string _rootDirectory;
 
             readonly ImmutableSegmentedList<string> _excludes;
@@ -113,7 +114,8 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
-                                    excludePatternsForGlobs
+                                    excludePatternsForGlobs,
+                                    fileMatcher: FileMatcher
                                 );
                             }
                             if (MSBuildEventSource.Log.IsEnabled())
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 288d11ce9b9..20706932be6 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -44,12 +44,12 @@ protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M,
 
                 _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, itemType => GetReferencedItems(itemType, ImmutableHashSet<string>.Empty));
                 _itemFactory = new ItemFactoryWrapper(_itemElement, _lazyEvaluator._itemFactory);
-                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.FileSystem);
+                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.EvaluationContext);
 
                 _itemSpec.Expander = _expander;
             }
 
-            protected EngineFileUtilities EngineFileUtilities => _lazyEvaluator.EngineFileUtilities;
+            protected FileMatcher FileMatcher => _lazyEvaluator.FileMatcher;
 
             public void Apply(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index 1db3ddfd3ce..1669c835072 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using System.Collections.Generic;
@@ -23,7 +24,7 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
                 _matchOnMetadata = builder.MatchOnMetadata.ToImmutable();
 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment),
+                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<P, I>.ItemExpressionFragment),
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToReferencedItems");
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 35b2ffa899f..349a561c231 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using System.Collections.Immutable;
 using System.Linq;
 using Microsoft.Build.Utilities;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 9fd3eec87e7..f0a16524b5a 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -6,7 +6,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Eventing;
-using Microsoft.Build.Internal;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -40,22 +40,22 @@ internal partial class LazyItemEvaluator<P, I, M, D>
             new Dictionary<string, LazyItemList>() :
             new Dictionary<string, LazyItemList>(StringComparer.OrdinalIgnoreCase);
 
-        protected IFileSystem FileSystem { get; }
+        protected EvaluationContext EvaluationContext { get; }
 
-        protected EngineFileUtilities EngineFileUtilities { get; }
+        protected IFileSystem FileSystem => EvaluationContext.FileSystem;
+        protected FileMatcher FileMatcher => EvaluationContext.FileMatcher;
 
         public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> itemFactory, LoggingContext loggingContext, EvaluationProfiler evaluationProfiler, EvaluationContext evaluationContext)
         {
             _outerEvaluatorData = data;
-            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext.FileSystem);
+            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, itemType => GetItems(itemType));
-            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext.FileSystem);
+            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
             _evaluationProfiler = evaluationProfiler;
 
-            FileSystem = evaluationContext.FileSystem;
-            EngineFileUtilities = evaluationContext.EngineFileUtilities;
+            EvaluationContext = evaluationContext;
         }
 
         private ImmutableList<I> GetItems(string itemType)
@@ -278,13 +278,13 @@ public OrderedItemDataCollection.Builder GetItemData(ImmutableHashSet<string> gl
                 // Cache results only on the LazyItemOperations whose results are required by an external caller (via GetItems). This means:
                 //   - Callers of GetItems who have announced ahead of time that they would reference an operation (via MarkAsReferenced())
                 // This includes: item references (Include="@(foo)") and metadata conditions (Condition="@(foo->Count()) == 0")
-                // Without ahead of time notifications more computation is done than needed when the results of a future operation are requested 
+                // Without ahead of time notifications more computation is done than needed when the results of a future operation are requested
                 // The future operation is part of another item list referencing this one (making this operation part of the tail).
                 // The future operation will compute this list but since no ahead of time notifications have been made by callers, it won't cache the
                 // intermediary operations that would be requested by those callers.
                 //   - Callers of GetItems that cannot announce ahead of time. This includes item referencing conditions on
                 // Item Groups and Item Elements. However, those conditions are performed eagerly outside of the LazyItemEvaluator, so they will run before
-                // any item referencing operations from inside the LazyItemEvaluator. This 
+                // any item referencing operations from inside the LazyItemEvaluator. This
                 //
                 // If the head of this LazyItemList is uncached, then the tail may contain cached and un-cached nodes.
                 // In this case we have to compute the head plus the part of the tail up to the first cached operation.
@@ -303,7 +303,7 @@ public OrderedItemDataCollection.Builder GetItemData(ImmutableHashSet<string> gl
                 else
                 {
                     // tell the cache that this operation's result is needed by an external caller
-                    // this is required for callers that cannot tell the item list ahead of time that 
+                    // this is required for callers that cannot tell the item list ahead of time that
                     // they would be using an operation
                     MarkAsReferenced();
 
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 761ef477d6f..186ed1ddf4c 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -127,7 +127,10 @@ private void Parse()
             // XML guarantees exactly one root element
             XmlElementWithLocation element = _document.DocumentElement as XmlElementWithLocation;
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject(element != null, ElementLocation.Create(_document.FullPath), "NoRootProjectElement", XMakeElements.project);
+            if (element is null)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(ElementLocation.Create(_document.FullPath), "NoRootProjectElement", XMakeElements.project);
+            }
             ProjectErrorUtilities.VerifyThrowInvalidProject(element.Name != XMakeElements.visualStudioProject, element.Location, "ProjectUpgradeNeeded", _project.FullPath);
             ProjectErrorUtilities.VerifyThrowInvalidProject(element.LocalName == XMakeElements.project, element.Location, "UnrecognizedElement", element.Name);
 
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 6e3dc3a3ec7..54effc239c5 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -5,10 +5,10 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared.FileSystem;
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
@@ -135,7 +135,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public ItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
-        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem) => _wrapped.InitializeForEvaluation(toolsetProvider, fileSystem);
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
         public void FinishEvaluation() => _wrapped.FinishEvaluation();
         public void AddItem(I item) => _wrapped.AddItem(item);
         public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
new file mode 100644
index 00000000000..84c24fb02cc
--- /dev/null
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -0,0 +1,118 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+
+#if FEATURE_MSIOREDIST
+using Path = Microsoft.IO.Path;
+#endif
+
+namespace Microsoft.Build.FileSystem
+{
+    internal class DirectoryCacheFileSystemWrapper : IFileSystem
+    {
+        /// <summary>
+        /// The base <see cref="IFileSystem"/> to fall back to for functionality not provided by <see cref="_directoryCache"/>.
+        /// </summary>
+        private readonly IFileSystem _fileSystem;
+
+        /// <summary>
+        /// A host-provided cache used for file existence and directory enumeration.
+        /// </summary>
+        private readonly IDirectoryCache _directoryCache;
+
+        public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache)
+        {
+            _fileSystem = fileSystem;
+            _directoryCache = directoryCache;
+        }
+
+        #region IFileSystem implementation based on IDirectoryCache
+
+        public bool FileOrDirectoryExists(string path)
+        {
+            return _directoryCache.FileExists(path) || _directoryCache.DirectoryExists(path);
+        }
+
+        public bool DirectoryExists(string path)
+        {
+            return _directoryCache.DirectoryExists(path);
+        }
+
+        public bool FileExists(string path)
+        {
+            return _directoryCache.FileExists(path);
+        }
+
+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: false, includeDirectories: true);
+        }
+
+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: false);
+        }
+
+        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: true);
+        }
+
+        private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories)
+        {
+            FindPredicate predicate = (ref ReadOnlySpan<char> fileName) =>
+            {
+                return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);
+            };
+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);
+
+            IEnumerable<string> directories = includeDirectories
+                ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)
+                : Enumerable.Empty<string>();
+            IEnumerable<string> files = includeFiles
+                ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)
+                : Enumerable.Empty<string>();
+
+            return Enumerable.Concat(directories, files);
+        }
+
+        #endregion
+
+        #region IFileSystem pass-through implementation
+
+        public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);
+
+        public DateTime GetLastWriteTimeUtc(string path) => _fileSystem.GetLastWriteTimeUtc(path);
+
+        public TextReader ReadFile(string path) => _fileSystem.ReadFile(path);
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => _fileSystem.GetFileStream(path, mode, access, share);
+
+        public string ReadFileAllText(string path) => _fileSystem.ReadFileAllText(path);
+
+        public byte[] ReadFileAllBytes(string path) => _fileSystem.ReadFileAllBytes(path);
+
+        #endregion
+    }
+}
diff --git a/src/Build/FileSystem/IDirectoryCache.cs b/src/Build/FileSystem/IDirectoryCache.cs
new file mode 100644
index 00000000000..fb6e62c1b6a
--- /dev/null
+++ b/src/Build/FileSystem/IDirectoryCache.cs
@@ -0,0 +1,89 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.FileSystem
+{
+    /// <summary>
+    /// A provider of <see cref="IDirectoryCache"/> instances. To be implemented by MSBuild hosts that wish to intercept
+    /// file existence checks and file enumerations performed during project evaluation.
+    /// </summary>
+    /// <remarks>
+    /// Unlike <see cref="MSBuildFileSystemBase"/>, file enumeration returns file/directory names, not full paths.
+    /// The host uses <see cref="Definition.ProjectOptions.DirectoryCacheFactory"/> to specify the directory cache
+    /// factory per project.
+    /// </remarks>
+    public interface IDirectoryCacheFactory
+    {
+        /// <summary>
+        /// Returns an <see cref="IDirectoryCache"/> to be used when evaluating the project associated with this <see cref="IDirectoryCacheFactory"/>.
+        /// </summary>
+        /// <param name="evaluationId">The ID of the evaluation for which the interface is requested.</param>
+        IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
+    }
+
+    /// <summary>
+    /// A predicate taking file name.
+    /// </summary>
+    /// <param name="fileName">The file name to check.</param>
+    public delegate bool FindPredicate(ref ReadOnlySpan<char> fileName);
+
+    /// <summary>
+    /// A function taking file name and returning an arbitrary result.
+    /// </summary>
+    /// <typeparam name="TResult">The type of the result to return</typeparam>
+    /// <param name="fileName">The file name to transform.</param>
+    public delegate TResult FindTransform<TResult>(ref ReadOnlySpan<char> fileName);
+
+    /// <summary>
+    /// Allows the implementor to intercept file existence checks and file enumerations performed during project evaluation.
+    /// </summary>
+    public interface IDirectoryCache
+    {
+        /// <summary>
+        /// Returns <code>true</code> if the given path points to an existing file on disk.
+        /// </summary>
+        /// <param name="path">A full and normalized path.</param>
+        bool FileExists(string path);
+
+        /// <summary>
+        /// Returns <code>true</code> if the given path points to an existing directory on disk.
+        /// </summary>
+        /// <param name="path">A full and normalized path.</param>
+        bool DirectoryExists(string path);
+
+        /// <summary>
+        /// Enumerates files in the given directory only (non-recursively).
+        /// </summary>
+        /// <typeparam name="TResult">The desired return type.</typeparam>
+        /// <param name="path">The directory to enumerate, specified as a full normalized path.</param>
+        /// <param name="pattern">A search pattern supported by the platform which is guaranteed to return a superset of relevant files.</param>
+        /// <param name="predicate">A predicate to test whether a file should be included.</param>
+        /// <param name="transform">A transform from <code>ReadOnlySpan&lt;char&gt;</code> to <typeparamref name="TResult"/>.</param>
+        /// <remarks>
+        /// The <paramref name="pattern"/> parameter may match more files than what the caller is interested in. In other words,
+        /// <paramref name="predicate"/> can return <code>false</code> even if the implementation enumerates only files whose names
+        /// match the pattern. The implementation is free to ignore the pattern and call the predicate for all files on the given
+        /// <paramref name="path"/>.
+        /// </remarks>
+        IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform);
+
+        /// <summary>
+        /// Enumerates subdirectories in the given directory only (non-recursively).
+        /// </summary>
+        /// <typeparam name="TResult">The desired return type.</typeparam>
+        /// <param name="path">The directory to enumerate, specified as a full normalized path.</param>
+        /// <param name="pattern">A search pattern supported by the platform which is guaranteed to return a superset of relevant directories.</param>
+        /// <param name="predicate">A predicate to test whether a directory should be included.</param>
+        /// <param name="transform">A transform from <code>ReadOnlySpan&lt;char&gt;</code> to <typeparamref name="TResult"/>.</param>
+        /// <remarks>
+        /// The <paramref name="pattern"/> parameter may match more direcories than what the caller is interested in. In other words,
+        /// <paramref name="predicate"/> can return <code>false</code> even if the implementation enumerates only directories whose names
+        /// match the pattern. The implementation is free to ignore the pattern and call the predicate for all directories on the given
+        /// <paramref name="path"/>.
+        /// </remarks>
+        IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform);
+    }
+}
diff --git a/src/Build/FxCopExclusions/Microsoft.Build.Suppressions.cs b/src/Build/FxCopExclusions/Microsoft.Build.Suppressions.cs
deleted file mode 100644
index 00cd81357fe..00000000000
--- a/src/Build/FxCopExclusions/Microsoft.Build.Suppressions.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-// FxCop Suppression file
-// To Use:
-// Add module level suppressions to this file to have them suppressed in the assembly
-//
-
-#if CODE_ANALYSIS
-[module: SuppressMessage("Microsoft.Design","CA1020:AvoidNamespacesWithFewTypes", Scope="namespace", Target="Microsoft.Build.Debugging", Justification="This deserves its own namespace")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Strings.resources", MessageId="itemname", Justification="itemname is spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Strings.resources", MessageId="sln", Justification="sln is the extension for a solution")]
-[module: SuppressMessage("Microsoft.Design","CA1032:ImplementStandardExceptionConstructors",Justification="We require this constructor for deserialization")]
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames", Justification="We delay sign our assemblies.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Strings.resources", MessageId="precompilation", Justification="precompilation is correctly spelled.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Strings.resources", MessageId="devenv", Justification="devenv is correctly spelled.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", Scope="namespace", Target="Microsoft.Build.Shared", MessageId="Shared")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.Shared")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="aspnetcompiler", Scope="resource", Target="Microsoft.Build.Strings.resources", Justification="AspNetCompiler is the name of the task")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="vcproj", Scope="resource", Target="Microsoft.Build.Strings.resources", Justification="vcproj is an extension and is spelled correctly")]
-
-[module: SuppressMessage("Microsoft.Security","CA2119:SealMethodsThatSatisfyPrivateInterfaces", Scope="member", Target="Microsoft.Build.Construction.ElementLocation.#get_Line()", Justification="This must be overridable. SmallElementLocation and RegularElementLocation already override it")]
-[module: SuppressMessage("Microsoft.Security","CA2119:SealMethodsThatSatisfyPrivateInterfaces", Scope="member", Target="Microsoft.Build.Construction.ElementLocation.#get_File()", Justification="This must be overridable. SmallElementLocation and RegularElementLocation already override it")]
-[module: SuppressMessage("Microsoft.Security","CA2119:SealMethodsThatSatisfyPrivateInterfaces", Scope="member", Target="Microsoft.Build.Construction.ElementLocation.#get_Column()", Justification="This must be overridable. SmallElementLocation and RegularElementLocation already override it")]
-
-#endif
diff --git a/src/Build/Globbing/CompositeGlob.cs b/src/Build/Globbing/CompositeGlob.cs
index 58687130fa4..4be643c1695 100644
--- a/src/Build/Globbing/CompositeGlob.cs
+++ b/src/Build/Globbing/CompositeGlob.cs
@@ -5,48 +5,147 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Globbing
 {
     /// <summary>
-    ///     A Composite glob
+    ///     A composite glob that returns a match for an input if any of its
+    ///     inner globs match the input (disjunction).
     /// </summary>
     public class CompositeGlob : IMSBuildGlob
     {
+        private readonly ImmutableArray<IMSBuildGlob> _globs;
+
         /// <summary>
         /// The direct children of this composite
         /// </summary>
-        public IEnumerable<IMSBuildGlob> Globs { get; }
+        public IEnumerable<IMSBuildGlob> Globs => _globs;
 
         /// <summary>
         ///     Constructor
         /// </summary>
         /// <param name="globs">Children globs. Input gets shallow cloned</param>
         public CompositeGlob(IEnumerable<IMSBuildGlob> globs)
-        {
-            // ImmutableArray also does this check, but copied it here just in case they remove it
-            if (globs is ImmutableArray<IMSBuildGlob>)
-            {
-                Globs = (ImmutableArray<IMSBuildGlob>)globs;
-            }
-
-            Globs = globs.ToImmutableArray();
-        }
+            : this(globs.ToImmutableArray())
+        {}
 
         /// <summary>
         ///     Constructor
         /// </summary>
         /// <param name="globs">Children globs. Input gets shallow cloned</param>
-        public CompositeGlob(params IMSBuildGlob[] globs) : this(globs.ToImmutableArray())
+        public CompositeGlob(params IMSBuildGlob[] globs)
+            : this(ImmutableArray.Create(globs))
+        {}
+
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="glob1">First child glob.</param>
+        /// <param name="glob2">Second child glob.</param>
+        internal CompositeGlob(IMSBuildGlob glob1, IMSBuildGlob glob2)
+            : this(ImmutableArray.Create(glob1, glob2))
         {}
 
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="globs">Children globs.</param>
+        private CompositeGlob(ImmutableArray<IMSBuildGlob> globs)
+        {
+            _globs = globs;
+        }
+
         /// <inheritdoc />
         public bool IsMatch(string stringToMatch)
         {
             // Threadpools are a scarce resource in Visual Studio, do not use them.
             //return Globs.AsParallel().Any(g => g.IsMatch(stringToMatch));
 
-            return Globs.Any(g => g.IsMatch(stringToMatch));
+            return _globs.Any(static (glob, str) => glob.IsMatch(str), stringToMatch);
+        }
+
+        /// <summary>
+        ///     Creates an <see cref="IMSBuildGlob"/> that aggregates multiple other globs
+        ///     such that the resulting glob matches when any inner glob matches (disjunction).
+        /// </summary>
+        /// <remarks>
+        ///     <para>
+        ///         When <paramref name="globs"/> contains no elements, a singleton glob is
+        ///         returned that never matches, regardless of input.
+        ///     </para>
+        ///     <para>
+        ///         When <paramref name="globs"/> contains one element, that single element is
+        ///         returned directly. This avoids allocating a redundant wrapper instance.
+        ///     </para>
+        /// </remarks>
+        /// <param name="globs">An enumeration of globs to compose.</param>
+        /// <returns>The logical disjunction of the input globs.</returns>
+        public static IMSBuildGlob Create(IEnumerable<IMSBuildGlob> globs)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(globs, nameof(globs));
+
+            if (globs is ImmutableArray<IMSBuildGlob> immutableGlobs)
+            {
+                // Avoid allocations in the case that the input is an ImmutableArray
+                return immutableGlobs.Length switch
+                {
+                    0 => NeverMatchingGlob.Instance,
+                    1 => immutableGlobs[0],
+                    _ => new CompositeGlob(immutableGlobs)
+                };
+            }
+
+            // Use explicit enumeration so we can do minimal work in the case
+            // that the input set of globs is either empty or only contains a
+            // single item.
+
+            using var enumerator = globs.GetEnumerator();
+
+            if (!enumerator.MoveNext())
+            {
+                // The input is empty, so return our singleton that doesn't
+                // match anything.
+                return NeverMatchingGlob.Instance;
+            }
+
+            var first = enumerator.Current;
+
+            if (!enumerator.MoveNext())
+            {
+                // The input contains only a single glob. Disjunction has no
+                // effect on a single input, so return it directly and avoid
+                // allocating a CompositeGlob instance.
+                return first;
+            }
+
+            // We have more than one input glob, to add them all to a builder
+            // and create a new CompositeGlob.
+
+            var builder = ImmutableArray.CreateBuilder<IMSBuildGlob>();
+
+            builder.Add(first);
+            builder.Add(enumerator.Current);
+
+            while (enumerator.MoveNext())
+            {
+                builder.Add(enumerator.Current);
+            }
+
+            return new CompositeGlob(builder.ToImmutable());
+        }
+
+        /// <summary>
+        ///    A glob that never returns a match.
+        /// </summary>
+        private sealed class NeverMatchingGlob : IMSBuildGlob
+        {
+            /// <summary>
+            ///    Singleton instance of this type.
+            /// </summary>
+            public static NeverMatchingGlob Instance { get; } = new();
+
+            public bool IsMatch(string stringToMatch) => false;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/IMSBuildGlob.cs b/src/Build/Globbing/IMSBuildGlob.cs
index 59e630fd225..c6b9279ab50 100644
--- a/src/Build/Globbing/IMSBuildGlob.cs
+++ b/src/Build/Globbing/IMSBuildGlob.cs
@@ -15,7 +15,7 @@ public interface IMSBuildGlob
         ///     - arguments representing relative paths are normalized against the glob's root.
         ///     For example, the glob **/*.cs does not match ../a.cs, since ../a.cs points outside of the glob root.
         /// 
-        ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters>
+        ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters.
         /// </summary>
         /// <param name="stringToMatch">The string to match. If the string represents a relative path, it will get normalized against the glob's root. Cannot be null.</param>
         /// <returns></returns>
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 9460958a40f..706933b8c43 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
@@ -260,7 +261,7 @@ public static MSBuildGlob Parse(string fileSpec)
         /// <summary>
         ///     Return type of <see cref="MSBuildGlob.MatchInfo" />
         /// </summary>
-        public struct MatchInfoResult
+        public readonly struct MatchInfoResult
         {
             /// <summary>
             ///     Whether the <see cref="MSBuildGlob.MatchInfo" /> argument was matched against the glob
diff --git a/src/Build/Globbing/MSBuildGlobWithGaps.cs b/src/Build/Globbing/MSBuildGlobWithGaps.cs
index 1a1abe4d149..fd6cf67baf4 100644
--- a/src/Build/Globbing/MSBuildGlobWithGaps.cs
+++ b/src/Build/Globbing/MSBuildGlobWithGaps.cs
@@ -32,6 +32,20 @@ public class MSBuildGlobWithGaps : IMSBuildGlob
         /// </summary>
         public IMSBuildGlob Gaps { get; }
 
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="mainGlob">The main glob</param>
+        /// <param name="gaps">The gap glob</param>
+        internal MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IMSBuildGlob gaps)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(mainGlob, nameof(mainGlob));
+            ErrorUtilities.VerifyThrowArgumentNull(gaps, nameof(gaps));
+
+            MainGlob = mainGlob;
+            Gaps = gaps;
+        }
+
         /// <summary>
         ///     Constructor
         /// </summary>
@@ -43,7 +57,7 @@ public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IEnumerable<IMSBuildGlob> gaps
             ErrorUtilities.VerifyThrowArgumentNull(gaps, nameof(gaps));
 
             MainGlob = mainGlob;
-            Gaps = new CompositeGlob(gaps);
+            Gaps = CompositeGlob.Create(gaps);
         }
 
         /// <summary>
diff --git a/src/Build/Globbing/Visitor/GlobVisitor.cs b/src/Build/Globbing/Visitor/GlobVisitor.cs
index 26a349c2c35..972af2443ad 100644
--- a/src/Build/Globbing/Visitor/GlobVisitor.cs
+++ b/src/Build/Globbing/Visitor/GlobVisitor.cs
@@ -7,25 +7,22 @@ internal abstract class GlobVisitor
     {
         public void Visit(IMSBuildGlob glob)
         {
-            var msbuildGlob = glob as MSBuildGlob;
-            if (msbuildGlob != null)
+            if (glob is MSBuildGlob msbuildGlob)
             {
                 VisitMSBuildGlob(msbuildGlob);
             }
 
-            var compositGlob = glob as CompositeGlob;
-            if (compositGlob != null)
+            if (glob is CompositeGlob compositeGlob)
             {
-                VisitCompositeGlob(compositGlob);
+                VisitCompositeGlob(compositeGlob);
 
-                foreach (var globPart in compositGlob.Globs)
+                foreach (var globPart in compositeGlob.Globs)
                 {
                     Visit(globPart);
                 }
             }
 
-            var globWithGaps = glob as MSBuildGlobWithGaps;
-            if (globWithGaps != null)
+            if (glob is MSBuildGlobWithGaps globWithGaps)
             {
                 VisitGlobWithGaps(globWithGaps);
 
@@ -37,7 +34,7 @@ protected virtual void VisitGlobWithGaps(MSBuildGlobWithGaps globWithGaps)
         {
         }
 
-        protected virtual void VisitCompositeGlob(CompositeGlob compositGlob)
+        protected virtual void VisitCompositeGlob(CompositeGlob compositeGlob)
         {
         }
 
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index b67aba3de21..35795e9d705 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1347,7 +1347,7 @@ ICollection<ProjectItemInstance> IItemProvider<ProjectItemInstance>.GetItems(str
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.
-            InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
         {
             // All been done in the constructor.  We don't allow re-evaluation of project instances.
         }
@@ -2761,6 +2761,7 @@ out var usingDifferentToolsVersionFromProjectFile
 
             Evaluator<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Evaluate(
                 this,
+                null,
                 xml,
                 projectLoadSettings ?? buildParameters.ProjectLoadSettings, /* Use override ProjectLoadSettings if specified */
                 buildParameters.MaxNodeCount,
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index 62f79e2d8a0..2ba9a93a0e4 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -459,6 +459,8 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _keepMetadataLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _removeMetadataLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _keepDuplicatesLocation, ElementLocation.FactoryForDeserialization);
+            translator.Translate(ref _matchOnMetadataLocation, ElementLocation.FactoryForDeserialization);
+            translator.Translate(ref _matchOnMetadataOptionsLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _conditionLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _metadata, ProjectItemGroupTaskMetadataInstance.FactoryForDeserialization);
         }
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 802539f6077..4596be57f52 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -282,7 +282,7 @@ string taskProjectFile
             {
                 // Exception thrown by the called code itself
                 // Log the stack, so the task vendor can fix their code
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
             }
             catch (ReflectionTypeLoadException e)
             {
@@ -295,12 +295,12 @@ string taskProjectFile
                     }
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
             catch (ArgumentNullException e)
             {
                 // taskName may be null
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
@@ -309,7 +309,7 @@ string taskProjectFile
                     throw;
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
 
             return _loadedType;
@@ -355,15 +355,12 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 
                 mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                string runtime = null;
-                string architecture = null;
-
-                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.runtime))
                 {
-                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.MSBuildRuntimeValues.clr4;
+                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.GetCurrentMSBuildRuntime();
                 }
 
-                if (!mergedParameters.TryGetValue(XMakeAttributes.architecture, out architecture))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.architecture))
                 {
                     mergedParameters[XMakeAttributes.architecture] = XMakeAttributes.GetCurrentMSBuildArchitecture();
                 }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 167a67e396e..1f7480ffc0c 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -352,7 +352,7 @@ internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance i
                     return LoggerVerbosity.Detailed;
 
                 default:
-                    ErrorUtilities.VerifyThrow(false, "Impossible");
+                    ErrorUtilities.ThrowInternalError("Impossible");
                     lightenText = false;
                     return LoggerVerbosity.Detailed;
             }
@@ -1003,7 +1003,7 @@ public virtual void Initialize(IEventSource eventSource)
                 eventSource.CustomEventRaised += CustomEventHandler;
                 eventSource.StatusEventRaised += StatusEventHandler;
 
-                bool logPropertiesAndItemsAfterEvaluation = Utilities.Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
+                bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
                 if (logPropertiesAndItemsAfterEvaluation && eventSource is IEventSource4 eventSource4)
                 {
                     eventSource4.IncludeEvaluationPropertiesAndItems();
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index c64e5f2fd85..72f225241d3 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -183,7 +183,7 @@ public LoggerVerbosity Verbosity
         {
             get
             {
-                ErrorUtilities.VerifyThrow(false, "Should not be getting verbosity from distributed file logger");
+                ErrorUtilities.ThrowInternalError("Should not be getting verbosity from distributed file logger");
                 return LoggerVerbosity.Detailed;
             }
             set
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 7394b006c0f..96732da2b2d 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -153,15 +153,7 @@ private void Write(string text)
         /// </summary>
         public override void Shutdown()
         {
-            try
-            {
-                // Do, or do not, there is no try.
-            }
-            finally
-            {
-                // Keep FxCop happy by closing in a Finally.
-                _fileWriter?.Dispose();
-            }
+            _fileWriter?.Dispose();
         }
 
         /// <summary>
diff --git a/src/Build/Logging/NullCentralLogger.cs b/src/Build/Logging/NullCentralLogger.cs
index b2101e63bc6..de64da650a1 100644
--- a/src/Build/Logging/NullCentralLogger.cs
+++ b/src/Build/Logging/NullCentralLogger.cs
@@ -53,7 +53,7 @@ public void AnyEventRaisedHandler(object sender, BuildEventArgs e)
         {
             if (!(e is BuildStartedEventArgs) && !(e is BuildFinishedEventArgs))
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(false, "Should not receive any events other than build started or finished");
+                ErrorUtilities.ThrowInvalidOperation("Should not receive any events other than build started or finished");
             }
         }
 
diff --git a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
new file mode 100644
index 00000000000..9f839cfff5f
--- /dev/null
+++ b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
@@ -0,0 +1,143 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Diagnostics;
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BackEnd.Logging
+{
+    /// <summary>
+    /// Align output to multiple lines so no logged test is lost due to limited <see cref="Console.BufferWidth"/>.
+    /// During alignment optional prefix/indent is applied.
+    /// </summary>
+    /// <remarks>
+    /// This class is not thread safe.
+    /// </remarks>
+    internal class ConsoleOutputAligner
+    {
+        internal const int ConsoleTabWidth = 8;
+
+        private readonly StringBuilder _reusedStringBuilder = new(1024);
+        private readonly int _bufferWidth;
+        private readonly bool _alignMessages;
+
+        /// <summary>
+        /// Constructor.
+        /// </summary>
+        /// <param name="bufferWidth">Console buffer width. -1 if unknown/unlimited</param>
+        /// <param name="alignMessages">Whether messages are aligned/wrapped into console buffer width</param>
+        public ConsoleOutputAligner(int bufferWidth, bool alignMessages)
+        {
+            _bufferWidth = bufferWidth;
+            _alignMessages = alignMessages;
+        }
+
+        /// <summary>
+        /// Based on bufferWidth split message into multiple lines and indent if needed.
+        /// TAB character are interpreted by standard Console logic. 
+        /// </summary>
+        /// <param name="message">Input message. May contains tabs and new lines. Both \r\n and \n is supported but replaced into current environment new line.</param>
+        /// <param name="prefixAlreadyWritten">true if message already contains prefix (message context, timestamp, etc...).</param>
+        /// <param name="prefixWidth">Width of the prefix. Every line in result string will be indented by this number of spaces except 1st line with already written prefix.</param>
+        /// <returns>Aligned message ready to be written to Console</returns>
+        /// <remarks>
+        /// For optimization purposes this method uses single <see cref="StringBuilder"/> instance. This makes this method non thread safe.
+        /// Calling side is expected this usage is non-concurrent. This shall not be an issue as it is expected that writing into Console shall be serialized anyway.
+        /// </remarks>
+        public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth)
+        {
+            int i = 0;
+            int j = message.IndexOfAny(MSBuildConstants.CrLf);
+
+            StringBuilder sb = _reusedStringBuilder;
+            // prepare reused StringBuilder instance for new use.
+            sb.Length = 0;
+            // The string contains new lines, treat each new line as a different string to format and send to the console
+            while (j >= 0)
+            {
+                AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, j - i);
+                i = j + (message[j] == '\r' && (j + 1) < message.Length && message[j + 1] == '\n' ? 2 : 1);
+                j = message.IndexOfAny(MSBuildConstants.CrLf, i);
+            }
+
+            // Process rest of message
+            AlignAndIndentLineOfMessage(sb, prefixAlreadyWritten, prefixWidth, message, i, message.Length - i);
+
+            return sb.ToString();
+        }
+
+        /// <summary>
+        /// Append aligned and indented message lines into running <see cref="StringBuilder"/>.
+        /// </summary>
+        private void AlignAndIndentLineOfMessage(StringBuilder sb, bool prefixAlreadyWritten, int prefixWidth, string message, int start, int count)
+        {
+            int bufferWidthMinusNewLine = _bufferWidth - 1;
+
+            bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > prefixWidth;
+            if (_alignMessages && bufferIsLargerThanPrefix && count > 0)
+            {
+                // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages
+
+                // Beginning index of string to be written
+                int index = 0;
+                // Loop until all the string has been sent to the console
+                while (index < count)
+                {
+                    // Position of virtual console cursor.
+                    // By simulating cursor position adjustment for tab characters '\t' we can compute
+                    //   exact numbers of characters from source string to fit into Console.BufferWidth.
+                    int cursor = 0;
+
+                    // Write prefix if needed
+                    if ((!prefixAlreadyWritten || index > 0 || start > 0) && prefixWidth > 0)
+                    {
+                        sb.Append(' ', prefixWidth);
+                    }
+                    // We have to adjust cursor position whether the prefix has been already written or we wrote/indented it ourselves
+                    cursor += prefixWidth;
+
+                    // End index of string to be written (behind last character)
+                    int endIndex = index;
+                    while (cursor < bufferWidthMinusNewLine)
+                    {
+                        int remainingCharsToEndOfBuffer = Math.Min(bufferWidthMinusNewLine - cursor, count - endIndex);
+                        int nextTab = message.IndexOf('\t', start + endIndex, remainingCharsToEndOfBuffer);
+                        if (nextTab >= 0)
+                        {
+                            // Position before tab
+                            cursor += nextTab - (start + endIndex);
+                            // Move to next tab position
+                            cursor += ConsoleTabWidth - cursor % ConsoleTabWidth;
+                            // Move end index after the '\t' in preparation for following IndexOf '\t'
+                            endIndex += nextTab - (start + endIndex) + 1;
+                        }
+                        else
+                        {
+                            endIndex += remainingCharsToEndOfBuffer;
+                            break;
+                        }
+                    }
+
+                    sb.Append(message, start + index, endIndex - index);
+                    sb.AppendLine();
+
+                    index = endIndex;
+                }
+            }
+            else
+            {
+                // If there is not enough room just print the message out and let the console do the formatting
+                if (!prefixAlreadyWritten && prefixWidth > 0)
+                {
+                    sb.Append(' ', prefixWidth);
+                }
+
+                sb.Append(message, start, count);
+                sb.AppendLine();
+            }
+        }
+    }
+}
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 26ed295bc8b..a68b477bfdc 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -2,15 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Text;
 using System.Collections;
 using System.Globalization;
 using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-
+using Microsoft.Build.Utilities;
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
@@ -105,6 +103,8 @@ private void CheckIfOutputSupportsAlignment()
                     _alignMessages = false;
                 }
             }
+
+            _consoleOutputAligner = new ConsoleOutputAligner(_bufferWidth, _alignMessages);
         }
 
         #endregion
@@ -1344,42 +1344,49 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
             {
                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;
 
-                // The string may contain new lines, treat each new line as a different string to format and send to the console
-                string[] nonNullMessages = SplitStringOnNewLines(message);
-                for (int i = 0; i < nonNullMessages.Length; i++)
+                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
                 {
-                    string nonNullMessage = nonNullMessages[i];
-                    // Take into account the new line char which will be added to the end or each reformatted string
-                    int bufferWidthMinusNewLine = _bufferWidth - 1;
-
-                    // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. 
-                    // If there is not enough room just print the message out and let the console do the formatting
-                    bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;
-                    bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;
-                    if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)
+                    // The string may contain new lines, treat each new line as a different string to format and send to the console
+                    string[] nonNullMessages = SplitStringOnNewLines(message);
+                    for (int i = 0; i < nonNullMessages.Length; i++)
                     {
-                        // Our message may have embedded tab characters, so expand those to their space
-                        // equivalent so that wrapping works as expected.
-                        nonNullMessage = nonNullMessage.Replace("\t", consoleTab);
-
-                        // If the message and the prefix are too large for one line in the console, split the string to fit
-                        int index = 0;
-                        int messageLength = nonNullMessage.Length;
-                        // Loop until all the string has been sent to the console
-                        while (index < messageLength)
+                        string nonNullMessage = nonNullMessages[i];
+                        // Take into account the new line char which will be added to the end or each reformatted string
+                        int bufferWidthMinusNewLine = _bufferWidth - 1;
+
+                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. 
+                        // If there is not enough room just print the message out and let the console do the formatting
+                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;
+                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;
+                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)
                         {
-                            // Calculate how many chars will fit on the console buffer
-                            int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
-                            WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);
-                            index += amountToCopy;
+                            // Our message may have embedded tab characters, so expand those to their space
+                            // equivalent so that wrapping works as expected.
+                            nonNullMessage = nonNullMessage.Replace("\t", consoleTab);
+
+                            // If the message and the prefix are too large for one line in the console, split the string to fit
+                            int index = 0;
+                            int messageLength = nonNullMessage.Length;
+                            // Loop until all the string has been sent to the console
+                            while (index < messageLength)
+                            {
+                                // Calculate how many chars will fit on the console buffer
+                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
+                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);
+                                index += amountToCopy;
+                            }
+                        }
+                        else
+                        {
+                            //there is not enough room just print the message out and let the console do the formatting
+                            WriteBasedOnPrefix(nonNullMessage, prefixAlreadyWritten, adjustedPrefixWidth);
                         }
-                    }
-                    else
-                    {
-                        //there is not enough room just print the message out and let the console do the formatting
-                        WriteBasedOnPrefix(nonNullMessage, prefixAlreadyWritten, adjustedPrefixWidth);
                     }
                 }
+                else
+                {
+                    WriteHandler(_consoleOutputAligner.AlignConsoleOutput(message, prefixAlreadyWritten, adjustedPrefixWidth));
+                }
             }
         }
 
@@ -1779,6 +1786,8 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
         private bool _hasBuildStarted;
         private bool? _showCommandLine;
         private bool _showTimeStamp;
+        private ConsoleOutputAligner _consoleOutputAligner;
+
         #endregion
     }
 }
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 9deedd88b0e..4784c183001 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -702,7 +702,7 @@ private string GetCurrentlyBuildingProjectFile()
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unexpected frame type.");
+                ErrorUtilities.ThrowInternalError("Unexpected frame type.");
                 return null;
             }
         }
@@ -752,7 +752,7 @@ private void ShowDeferredMessages()
                         break;
 
                     default:
-                        ErrorUtilities.VerifyThrow(false, "Unexpected frame type.");
+                        ErrorUtilities.ThrowInternalError("Unexpected frame type.");
                         break;
                 }
             }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d08e337c5da..cbfee6c66db 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -36,6 +36,8 @@
     <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
+
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
@@ -65,9 +67,6 @@
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>SharedUtilities\EncodingStringWriter.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\AssemblyNameComparer.cs">
       <Link>SharedUtilities\AssemblyNameComparer.cs</Link>
     </Compile>
@@ -103,9 +102,6 @@
     <Compile Include="..\Shared\StringBuilderCache.cs">
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedUtilities\Traits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskCancelled.cs" />
@@ -146,9 +142,6 @@
     </Compile>
     <Compile Include="..\Shared\ReuseableStringBuilder.cs" />
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>SharedUtilities\VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="BackEnd\BuildManager\BuildManager.cs" />
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
@@ -160,6 +153,7 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Utilities\ImmutableCollectionsExtensions.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
@@ -610,6 +604,7 @@
     <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="Logging\ParallelLogger\ConsoleOutputAligner.cs" />
     <Compile Include="Logging\FileLogger.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -723,21 +718,10 @@
     <Compile Include="..\Shared\IElementLocation.cs">
       <Link>SharedUtilities\IElementLocation.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <Link>Errors\InternalErrorException.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\LoadedType.cs">
       <Link>SharedUtilities\LoadedType.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <Link>SharedUtilities\NativeMethodsShared.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <Link>SharedUtilities\AssemblyUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>InprocTrackingNativeMethods.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -781,9 +765,6 @@
       <Link>SharedUtilities\XmlUtilities.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="FxCopExclusions\Microsoft.Build.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="Evaluation\LazyItemEvaluator.EvaluatorData.cs" />
 
     <!-- Win32 RC Files -->
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..7b51af24c2f
--- /dev/null
+++ b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
@@ -0,0 +1,1822 @@
+abstract Microsoft.Build.Construction.ElementLocation.Column.get -> int
+abstract Microsoft.Build.Construction.ElementLocation.File.get -> string
+abstract Microsoft.Build.Construction.ElementLocation.Line.get -> int
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsImported.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.Name.get -> string
+abstract Microsoft.Build.Evaluation.ProjectProperty.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.get -> string
+abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.set -> void
+abstract Microsoft.Build.Evaluation.ProjectProperty.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
+abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Condition.get -> string
+abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Condition.get -> string
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.get -> bool
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.set -> void
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogError(string error) -> void
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = null) -> void
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogWarning(string warning) -> void
+abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
+abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
+abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult>
+abstract Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.GetLoadedProjects(string filePath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElement child) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.Count.get -> int
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.LastChild.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Attributes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ElementName.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(string attributeName) -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(string attributeName, bool nullIfNotExists) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Location.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.OuterElement.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PureText.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.GetSubElement(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.SetSubElement(string name, string value) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadataValue(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ItemType.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Project.get -> Microsoft.Build.Evaluation.Project
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ChangeItemType(string newType) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ChangeItemType(string newItemType) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.DirectMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.EvaluatedInclude.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadataValue(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.HasMetadata(string name) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.MetadataCollection.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Project.get -> Microsoft.Build.Evaluation.Project
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.RemoveMetadata(string name) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Rename(string name) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ExpandString(string unexpandedValue) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetPropertyValue(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsDirty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemTypes.get -> System.Collections.Generic.ICollection<string>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.LastEvaluationId.get -> int
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.MarkDirty() -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveGlobalProperty(string name) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SaveLogicalProject(System.IO.TextWriter writer) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetGlobalProperty(string name, string escapedValue) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SubToolsetVersion.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ToolsVersion.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Unload() -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ChangeName(string newName) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.EvaluatedValueEscaped.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Parent.get -> object
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ChangeName(string newName) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.EvaluatedIncludeEscaped.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsEnvironmentProperty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsGlobalProperty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsImported.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsReservedProperty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Name.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Project.get -> Microsoft.Build.Evaluation.Project
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.DirectoryPath.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Encoding.get -> System.Text.Encoding
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.HasUnsavedChanges.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.LastWriteTimeWhenRead.get -> System.DateTime
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.MarkDirty(string reason, string param) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.PreserveFormatting.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.RawXml.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.IO.TextWriter writer) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.Text.Encoding saveEncoding) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.TimeLastChanged.get -> System.DateTime
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Version.get -> int
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Returns.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.GetParameter(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveAllParameters() -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveParameter(string name) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.SetParameter(string name, string unevaluatedValue) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.set -> void
+const Microsoft.Build.Evaluation.MatchOnMetadataConstants.MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Resolver.get -> Microsoft.Build.Framework.SdkResolver
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Sdk.get -> Microsoft.Build.Framework.SdkReference
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) -> void
+Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ElementLocation.ElementLocation() -> void
+Microsoft.Build.Construction.ElementLocation.LocationString.get -> string
+Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ImplicitImportLocation.Bottom = 2 -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ImplicitImportLocation.None = 0 -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ImplicitImportLocation.Top = 1 -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ProjectChooseElement
+Microsoft.Build.Construction.ProjectChooseElement.OtherwiseElement.get -> Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.Construction.ProjectChooseElement.WhenElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement>
+Microsoft.Build.Construction.ProjectConfigurationInSolution
+Microsoft.Build.Construction.ProjectConfigurationInSolution.ConfigurationName.get -> string
+Microsoft.Build.Construction.ProjectConfigurationInSolution.FullName.get -> string
+Microsoft.Build.Construction.ProjectConfigurationInSolution.IncludeInBuild.get -> bool
+Microsoft.Build.Construction.ProjectConfigurationInSolution.PlatformName.get -> string
+Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElement.AllParents.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer>
+Microsoft.Build.Construction.ProjectElement.Clone() -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElement.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Construction.ProjectElement.ElementName.get -> string
+Microsoft.Build.Construction.ProjectElement.Label.get -> string
+Microsoft.Build.Construction.ProjectElement.Label.set -> void
+Microsoft.Build.Construction.ProjectElement.LabelLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectElement.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectElement.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElement.OuterElement.get -> string
+Microsoft.Build.Construction.ProjectElement.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
+Microsoft.Build.Construction.ProjectElement.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElementContainer
+Microsoft.Build.Construction.ProjectElementContainer.AllChildren.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement child) -> void
+Microsoft.Build.Construction.ProjectElementContainer.Children.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Construction.ProjectElementContainer.ChildrenReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Construction.ProjectElementContainer.Count.get -> int
+Microsoft.Build.Construction.ProjectElementContainer.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+Microsoft.Build.Construction.ProjectElementContainer.LastChild.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement child) -> void
+Microsoft.Build.Construction.ProjectElementContainer.RemoveAllChildren() -> void
+Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
+Microsoft.Build.Construction.ProjectExtensionsElement
+Microsoft.Build.Construction.ProjectExtensionsElement.Content.get -> string
+Microsoft.Build.Construction.ProjectExtensionsElement.Content.set -> void
+Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].get -> string
+Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].set -> void
+Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.get -> string
+Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.set -> void
+Microsoft.Build.Construction.ProjectImportElement.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectImportElement.Project.get -> string
+Microsoft.Build.Construction.ProjectImportElement.Project.set -> void
+Microsoft.Build.Construction.ProjectImportElement.ProjectLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectImportElement.Sdk.get -> string
+Microsoft.Build.Construction.ProjectImportElement.Sdk.set -> void
+Microsoft.Build.Construction.ProjectImportElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectImportElement.Version.get -> string
+Microsoft.Build.Construction.ProjectImportElement.Version.set -> void
+Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.Construction.ProjectImportGroupElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectImportGroupElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
+Microsoft.Build.Construction.ProjectInSolution
+Microsoft.Build.Construction.ProjectInSolution.AbsolutePath.get -> string
+Microsoft.Build.Construction.ProjectInSolution.Dependencies.get -> System.Collections.Generic.IReadOnlyList<string>
+Microsoft.Build.Construction.ProjectInSolution.ParentProjectGuid.get -> string
+Microsoft.Build.Construction.ProjectInSolution.ProjectConfigurations.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution>
+Microsoft.Build.Construction.ProjectInSolution.ProjectGuid.get -> string
+Microsoft.Build.Construction.ProjectInSolution.ProjectName.get -> string
+Microsoft.Build.Construction.ProjectInSolution.ProjectType.get -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.ProjectInSolution.ProjectType.set -> void
+Microsoft.Build.Construction.ProjectInSolution.RelativePath.get -> string
+Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemDefinitionElement.ItemType.get -> string
+Microsoft.Build.Construction.ProjectItemDefinitionElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
+Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
+Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemElement.Exclude.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Exclude.set -> void
+Microsoft.Build.Construction.ProjectItemElement.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.HasMetadata.get -> bool
+Microsoft.Build.Construction.ProjectItemElement.Include.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Include.set -> void
+Microsoft.Build.Construction.ProjectItemElement.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.ItemType.get -> string
+Microsoft.Build.Construction.ProjectItemElement.ItemType.set -> void
+Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.get -> string
+Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.set -> void
+Microsoft.Build.Construction.ProjectItemElement.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.get -> string
+Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.set -> void
+Microsoft.Build.Construction.ProjectItemElement.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.get -> string
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.set -> void
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.get -> string
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.set -> void
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
+Microsoft.Build.Construction.ProjectItemElement.Remove.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Remove.set -> void
+Microsoft.Build.Construction.ProjectItemElement.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.get -> string
+Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.set -> void
+Microsoft.Build.Construction.ProjectItemElement.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.Update.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Update.set -> void
+Microsoft.Build.Construction.ProjectItemElement.UpdateLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectItemGroupElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
+Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.get -> bool
+Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.set -> void
+Microsoft.Build.Construction.ProjectMetadataElement.Name.get -> string
+Microsoft.Build.Construction.ProjectMetadataElement.Name.set -> void
+Microsoft.Build.Construction.ProjectMetadataElement.Value.get -> string
+Microsoft.Build.Construction.ProjectMetadataElement.Value.set -> void
+Microsoft.Build.Construction.ProjectOnErrorElement
+Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.get -> string
+Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.set -> void
+Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.Construction.ProjectOtherwiseElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
+Microsoft.Build.Construction.ProjectOtherwiseElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectOtherwiseElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectOutputElement.IsOutputItem.get -> bool
+Microsoft.Build.Construction.ProjectOutputElement.IsOutputProperty.get -> bool
+Microsoft.Build.Construction.ProjectOutputElement.ItemType.get -> string
+Microsoft.Build.Construction.ProjectOutputElement.ItemType.set -> void
+Microsoft.Build.Construction.ProjectOutputElement.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectOutputElement.PropertyName.get -> string
+Microsoft.Build.Construction.ProjectOutputElement.PropertyName.set -> void
+Microsoft.Build.Construction.ProjectOutputElement.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.get -> string
+Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.set -> void
+Microsoft.Build.Construction.ProjectOutputElement.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectPropertyElement.Name.get -> string
+Microsoft.Build.Construction.ProjectPropertyElement.Name.set -> void
+Microsoft.Build.Construction.ProjectPropertyElement.Value.get -> string
+Microsoft.Build.Construction.ProjectPropertyElement.Value.set -> void
+Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectPropertyGroupElement.AddProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectPropertyGroupElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
+Microsoft.Build.Construction.ProjectPropertyGroupElement.PropertiesReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
+Microsoft.Build.Construction.ProjectPropertyGroupElement.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Construction.ProjectRootElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectRootElement.AddImportGroup() -> Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddProperty(string name, string value) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddTarget(string name) -> Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(string name, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectRootElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
+Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
+Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
+Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
+Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
+Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
+Microsoft.Build.Construction.ProjectRootElement.DeepClone() -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.get -> string
+Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.set -> void
+Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.DirectoryPath.get -> string
+Microsoft.Build.Construction.ProjectRootElement.Encoding.get -> System.Text.Encoding
+Microsoft.Build.Construction.ProjectRootElement.EscapedFullPath.get -> string
+Microsoft.Build.Construction.ProjectRootElement.FullPath.get -> string
+Microsoft.Build.Construction.ProjectRootElement.FullPath.set -> void
+Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges.get -> bool
+Microsoft.Build.Construction.ProjectRootElement.ImportGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
+Microsoft.Build.Construction.ProjectRootElement.InitialTargets.get -> string
+Microsoft.Build.Construction.ProjectRootElement.InitialTargets.set -> void
+Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
+Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead.get -> System.DateTime
+Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting.get -> bool
+Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
+Microsoft.Build.Construction.ProjectRootElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.RawXml.get -> string
+Microsoft.Build.Construction.ProjectRootElement.Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
+Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
+Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save() -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(string path) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(string path, System.Text.Encoding encoding) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter writer) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding saveEncoding) -> void
+Microsoft.Build.Construction.ProjectRootElement.Sdk.get -> string
+Microsoft.Build.Construction.ProjectRootElement.Sdk.set -> void
+Microsoft.Build.Construction.ProjectRootElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.Targets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement>
+Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged.get -> System.DateTime
+Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.get -> string
+Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.set -> void
+Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.get -> string
+Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.set -> void
+Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.UsingTasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement>
+Microsoft.Build.Construction.ProjectRootElement.Version.get -> int
+Microsoft.Build.Construction.ProjectSdkElement
+Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.get -> string
+Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.set -> void
+Microsoft.Build.Construction.ProjectSdkElement.Name.get -> string
+Microsoft.Build.Construction.ProjectSdkElement.Name.set -> void
+Microsoft.Build.Construction.ProjectSdkElement.Version.get -> string
+Microsoft.Build.Construction.ProjectSdkElement.Version.set -> void
+Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.Construction.ProjectTargetElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectTargetElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectTargetElement.AddTask(string taskName) -> Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.Inputs.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Inputs.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.Name.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Name.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.NameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.OnErrors.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement>
+Microsoft.Build.Construction.ProjectTargetElement.Outputs.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Outputs.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectTargetElement.Returns.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Returns.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement>
+Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.set -> void
+Microsoft.Build.Construction.ProjectTaskElement.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTaskElement.GetParameter(string name) -> string
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.set -> void
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.set -> void
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTaskElement.Name.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.Outputs.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement>
+Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
+Microsoft.Build.Construction.ProjectTaskElement.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters() -> void
+Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(string name) -> void
+Microsoft.Build.Construction.ProjectTaskElement.SetParameter(string name, string unevaluatedValue) -> void
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.EvaluateLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.AddParameterGroup() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.AddUsingTaskBody(string evaluate, string taskBody) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.ArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.RuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskBody.get -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactoryLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.OutputLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.RequiredLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectWhenElement
+Microsoft.Build.Construction.ProjectWhenElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
+Microsoft.Build.Construction.ProjectWhenElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectWhenElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.SolutionConfigurationInSolution
+Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationName.get -> string
+Microsoft.Build.Construction.SolutionConfigurationInSolution.FullName.get -> string
+Microsoft.Build.Construction.SolutionConfigurationInSolution.PlatformName.get -> string
+Microsoft.Build.Construction.SolutionFile
+Microsoft.Build.Construction.SolutionFile.GetDefaultConfigurationName() -> string
+Microsoft.Build.Construction.SolutionFile.GetDefaultPlatformName() -> string
+Microsoft.Build.Construction.SolutionFile.ProjectsByGuid.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution>
+Microsoft.Build.Construction.SolutionFile.ProjectsInOrder.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution>
+Microsoft.Build.Construction.SolutionFile.SolutionConfigurations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution>
+Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.EtpSubProject = 5 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.KnownToBeMSBuildFormat = 1 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.SharedProject = 6 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.SolutionFolder = 2 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.Unknown = 0 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.WebDeploymentProject = 4 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.WebProject = 3 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.UsingTaskParameterGroupElement.Parameters.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement>
+Microsoft.Build.Definition.ProjectOptions
+Microsoft.Build.Definition.ProjectOptions.EvaluationContext.get -> Microsoft.Build.Evaluation.Context.EvaluationContext
+Microsoft.Build.Definition.ProjectOptions.EvaluationContext.set -> void
+Microsoft.Build.Definition.ProjectOptions.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Definition.ProjectOptions.GlobalProperties.set -> void
+Microsoft.Build.Definition.ProjectOptions.LoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Definition.ProjectOptions.LoadSettings.set -> void
+Microsoft.Build.Definition.ProjectOptions.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.Definition.ProjectOptions.ProjectCollection.set -> void
+Microsoft.Build.Definition.ProjectOptions.ProjectOptions() -> void
+Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.get -> string
+Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.set -> void
+Microsoft.Build.Definition.ProjectOptions.ToolsVersion.get -> string
+Microsoft.Build.Definition.ProjectOptions.ToolsVersion.set -> void
+Microsoft.Build.Evaluation.Context.EvaluationContext
+Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
+Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated = 1 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
+Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Shared = 0 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
+Microsoft.Build.Evaluation.GlobResult
+Microsoft.Build.Evaluation.GlobResult.Excludes.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Evaluation.GlobResult.GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) -> void
+Microsoft.Build.Evaluation.GlobResult.IncludeGlobs.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Evaluation.GlobResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.set -> void
+Microsoft.Build.Evaluation.GlobResult.Removes.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Evaluation.GlobResult.Removes.set -> void
+Microsoft.Build.Evaluation.MatchOnMetadataConstants
+Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseInsensitive = 1 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive = 0 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.MatchOnMetadataOptions.PathLike = 2 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeAllOptions = -1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeToolsVersion = 2 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlDeclaration = 1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlNamespace = 4 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.None = 0 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Exclude = 1 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Include = 0 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Remove = 3 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Update = 2 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.Project.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+Microsoft.Build.Evaluation.Project.Build() -> bool
+Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger logger) -> bool
+Microsoft.Build.Evaluation.Project.Build(string target) -> bool
+Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
+Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Evaluation.Project.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
+Microsoft.Build.Evaluation.Project.CreateProjectInstance() -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Evaluation.Project.DirectoryPath.get -> string
+Microsoft.Build.Evaluation.Project.DisableMarkDirty.get -> bool
+Microsoft.Build.Evaluation.Project.DisableMarkDirty.set -> void
+Microsoft.Build.Evaluation.Project.EvaluationCounter.get -> int
+Microsoft.Build.Evaluation.Project.ExpandString(string unexpandedValue) -> string
+Microsoft.Build.Evaluation.Project.FullPath.get -> string
+Microsoft.Build.Evaluation.Project.FullPath.set -> void
+Microsoft.Build.Evaluation.Project.GetAllGlobs() -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Evaluation.Project.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.Evaluation.Project.GetPropertyValue(string name) -> string
+Microsoft.Build.Evaluation.Project.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Evaluation.Project.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+Microsoft.Build.Evaluation.Project.IsBuildEnabled.get -> bool
+Microsoft.Build.Evaluation.Project.IsBuildEnabled.set -> void
+Microsoft.Build.Evaluation.Project.IsDirty.get -> bool
+Microsoft.Build.Evaluation.Project.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
+Microsoft.Build.Evaluation.Project.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.ItemTypes.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Evaluation.Project.LastEvaluationId.get -> int
+Microsoft.Build.Evaluation.Project.MarkDirty() -> void
+Microsoft.Build.Evaluation.Project.Project() -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.Evaluation.Project.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Evaluation.Project.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary() -> void
+Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
+Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(string name) -> bool
+Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
+Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
+Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
+Microsoft.Build.Evaluation.Project.Save() -> void
+Microsoft.Build.Evaluation.Project.Save(string path) -> void
+Microsoft.Build.Evaluation.Project.Save(string path, System.Text.Encoding encoding) -> void
+Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter writer) -> void
+Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding encoding) -> void
+Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter writer) -> void
+Microsoft.Build.Evaluation.Project.SetGlobalProperty(string name, string escapedValue) -> bool
+Microsoft.Build.Evaluation.Project.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.Evaluation.Project.SkipEvaluation.get -> bool
+Microsoft.Build.Evaluation.Project.SkipEvaluation.set -> void
+Microsoft.Build.Evaluation.Project.SubToolsetVersion.get -> string
+Microsoft.Build.Evaluation.Project.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
+Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.get -> bool
+Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.set -> void
+Microsoft.Build.Evaluation.Project.ToolsVersion.get -> string
+Microsoft.Build.Evaluation.Project.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ProjectChangedEventArgs
+Microsoft.Build.Evaluation.ProjectChangedEventArgs.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset toolset) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(string toolsVersion) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.Count.get -> int
+Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.get -> string
+Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.Dispose() -> void
+Microsoft.Build.Evaluation.ProjectCollection.GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) -> string
+Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(string fullPath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
+Microsoft.Build.Evaluation.ProjectCollection.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
+Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Evaluation.ProjectCollection.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Evaluation.ProjectCollection.HostServices.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.Loggers.get -> System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger>
+Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded -> Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectRootElement.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs>
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection() -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs>
+Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs>
+Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> void
+Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
+Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> void
+Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets() -> void
+Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(string name) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(string toolsVersion) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(string name, string value) -> void
+Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ProjectCollection.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
+Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects() -> void
+Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> void
+Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project project) -> void
+Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers() -> void
+Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs
+Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.Changed.get -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.DefaultToolsVersion = 0 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.DisableMarkDirty = 7 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.GlobalProperties = 3 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.HostServices = 6 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.IsBuildEnabled = 4 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.Loggers = 2 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.OnlyLogCriticalEvents = 5 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.SkipEvaluation = 8 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.Toolsets = 1 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectItem
+Microsoft.Build.Evaluation.ProjectItem.DirectMetadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount.get -> int
+Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude.get -> string
+Microsoft.Build.Evaluation.ProjectItem.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(string name) -> string
+Microsoft.Build.Evaluation.ProjectItem.HasMetadata(string name) -> bool
+Microsoft.Build.Evaluation.ProjectItem.IsImported.get -> bool
+Microsoft.Build.Evaluation.ProjectItem.ItemType.get -> string
+Microsoft.Build.Evaluation.ProjectItem.ItemType.set -> void
+Microsoft.Build.Evaluation.ProjectItem.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.ProjectItem.MetadataCount.get -> int
+Microsoft.Build.Evaluation.ProjectItem.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(string name) -> bool
+Microsoft.Build.Evaluation.ProjectItem.Rename(string name) -> void
+Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.get -> string
+Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.set -> void
+Microsoft.Build.Evaluation.ProjectItem.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Evaluation.ProjectItemDefinition
+Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(string name) -> string
+Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType.get -> string
+Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount.get -> int
+Microsoft.Build.Evaluation.ProjectItemDefinition.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.Default = 0 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.DoNotEvaluateElementsWithFalseCondition = 32 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.FailOnUnresolvedSdk = 256 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreEmptyImports = 16 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports = 64 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.ProfileEvaluation = 128 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.RecordDuplicateButNotCircularImports = 2 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements = 8 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.RejectCircularImports = 4 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.IsImported.get -> bool
+Microsoft.Build.Evaluation.ProjectMetadata.ItemType.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Evaluation.ProjectMetadata.Name.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectMetadata.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.set -> void
+Microsoft.Build.Evaluation.ProjectMetadata.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue.get -> string
+Microsoft.Build.Evaluation.ProjectProperty.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs
+Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.ProjectXml.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.Reason.get -> string
+Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.Glob = 2 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.Inconclusive = 4 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.StringLiteral = 1 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.Undefined = 0 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.ProvenanceResult
+Microsoft.Build.Evaluation.ProvenanceResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Evaluation.ProvenanceResult.Occurrences.get -> int
+Microsoft.Build.Evaluation.ProvenanceResult.Operation.get -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.ProvenanceResult.Provenance.get -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.ProvenanceResult.ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) -> void
+Microsoft.Build.Evaluation.ResolvedImport
+Microsoft.Build.Evaluation.ResolvedImport.ImportedProject.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ResolvedImport.ImportingElement.get -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Evaluation.ResolvedImport.IsImported.get -> bool
+Microsoft.Build.Evaluation.ResolvedImport.ResolvedImport() -> void
+Microsoft.Build.Evaluation.ResolvedImport.SdkResult.get -> Microsoft.Build.Framework.SdkResult
+Microsoft.Build.Evaluation.SubToolset
+Microsoft.Build.Evaluation.SubToolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Evaluation.SubToolset.SubToolsetVersion.get -> string
+Microsoft.Build.Evaluation.Toolset
+Microsoft.Build.Evaluation.Toolset.DefaultSubToolsetVersion.get -> string
+Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion() -> string
+Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) -> string
+Microsoft.Build.Evaluation.Toolset.GetProperty(string propertyName, string subToolsetVersion) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Evaluation.Toolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Evaluation.Toolset.SubToolsets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset>
+Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
+Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
+Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) -> void
+Microsoft.Build.Evaluation.Toolset.ToolsPath.get -> string
+Microsoft.Build.Evaluation.Toolset.ToolsVersion.get -> string
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Default = Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile | Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Local = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Exceptions.BuildAbortedException
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException() -> void
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message) -> void
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Exceptions.BuildAbortedException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.CircularDependencyException
+Microsoft.Build.Exceptions.CircularDependencyException.CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Exceptions.InternalLoggerException
+Microsoft.Build.Exceptions.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
+Microsoft.Build.Exceptions.InternalLoggerException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.InternalLoggerException.HelpKeyword.get -> string
+Microsoft.Build.Exceptions.InternalLoggerException.InitializationException.get -> bool
+Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException() -> void
+Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message) -> void
+Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException
+Microsoft.Build.Exceptions.InvalidProjectFileException.BaseMessage.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.ColumnNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.EndColumnNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.EndLineNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorSubcategory.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.HasBeenLogged.get -> bool
+Microsoft.Build.Exceptions.InvalidProjectFileException.HelpKeyword.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException() -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.LineNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.ProjectFile.get -> string
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Execution.BuildManager
+Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) -> void
+Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) -> void
+Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Execution.BuildManager.BuildManager() -> void
+Microsoft.Build.Execution.BuildManager.BuildManager(string hostName) -> void
+Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Execution.BuildManager.CancelAllSubmissions() -> void
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage() -> void
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Importance.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Text.get -> string
+Microsoft.Build.Execution.BuildManager.Dispose() -> void
+Microsoft.Build.Execution.BuildManager.EndBuild() -> void
+Microsoft.Build.Execution.BuildManager.GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildSubmission
+Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildSubmission
+Microsoft.Build.Execution.BuildManager.ResetCaches() -> void
+Microsoft.Build.Execution.BuildManager.ShutdownAllNodes() -> void
+Microsoft.Build.Execution.BuildManager.~BuildManager() -> void
+Microsoft.Build.Execution.BuildParameters
+Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.get -> bool
+Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
+Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
+Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
+Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
+Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
+Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
+Microsoft.Build.Execution.BuildParameters.Culture.set -> void
+Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.get -> string
+Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.set -> void
+Microsoft.Build.Execution.BuildParameters.DetailedSummary.get -> bool
+Microsoft.Build.Execution.BuildParameters.DetailedSummary.set -> void
+Microsoft.Build.Execution.BuildParameters.DisableInProcNode.get -> bool
+Microsoft.Build.Execution.BuildParameters.DisableInProcNode.set -> void
+Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.get -> bool
+Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.set -> void
+Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.get -> bool
+Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.set -> void
+Microsoft.Build.Execution.BuildParameters.EnvironmentProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord>
+Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.set -> void
+Microsoft.Build.Execution.BuildParameters.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
+Microsoft.Build.Execution.BuildParameters.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.GlobalProperties.set -> void
+Microsoft.Build.Execution.BuildParameters.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Execution.BuildParameters.HostServices.set -> void
+Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.get -> string[]
+Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.set -> void
+Microsoft.Build.Execution.BuildParameters.Interactive.get -> bool
+Microsoft.Build.Execution.BuildParameters.Interactive.set -> void
+Microsoft.Build.Execution.BuildParameters.IsolateProjects.get -> bool
+Microsoft.Build.Execution.BuildParameters.IsolateProjects.set -> void
+Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.get -> bool
+Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.set -> void
+Microsoft.Build.Execution.BuildParameters.Loggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger>
+Microsoft.Build.Execution.BuildParameters.Loggers.set -> void
+Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.get -> bool
+Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.set -> void
+Microsoft.Build.Execution.BuildParameters.LogTaskInputs.get -> bool
+Microsoft.Build.Execution.BuildParameters.LogTaskInputs.set -> void
+Microsoft.Build.Execution.BuildParameters.LowPriority.get -> bool
+Microsoft.Build.Execution.BuildParameters.LowPriority.set -> void
+Microsoft.Build.Execution.BuildParameters.MaxNodeCount.get -> int
+Microsoft.Build.Execution.BuildParameters.MaxNodeCount.set -> void
+Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.get -> int
+Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.set -> void
+Microsoft.Build.Execution.BuildParameters.NodeExeLocation.get -> string
+Microsoft.Build.Execution.BuildParameters.NodeExeLocation.set -> void
+Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.get -> bool
+Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.set -> void
+Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.get -> string
+Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.set -> void
+Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.set -> void
+Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.set -> void
+Microsoft.Build.Execution.BuildParameters.ResetCaches.get -> bool
+Microsoft.Build.Execution.BuildParameters.ResetCaches.set -> void
+Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.get -> bool
+Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.set -> void
+Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.get -> bool
+Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.set -> void
+Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.set -> void
+Microsoft.Build.Execution.BuildParameters.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
+Microsoft.Build.Execution.BuildParameters.UICulture.get -> System.Globalization.CultureInfo
+Microsoft.Build.Execution.BuildParameters.UICulture.set -> void
+Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.get -> bool
+Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
+Microsoft.Build.Execution.BuildRequestData
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
+Microsoft.Build.Execution.BuildRequestData.ExplicitlySpecifiedToolsVersion.get -> string
+Microsoft.Build.Execution.BuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestData.GlobalProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Execution.BuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Execution.BuildRequestData.ProjectFullPath.get -> string
+Microsoft.Build.Execution.BuildRequestData.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.BuildRequestData.PropertiesToTransfer.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Execution.BuildRequestData.RequestedProjectState.get -> Microsoft.Build.Execution.RequestedProjectState
+Microsoft.Build.Execution.BuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild = 8 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.FailOnUnresolvedSdk = 128 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState = 4 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports = 64 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.None = 0 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild = 2 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild = 32 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance = 1 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets = 16 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildResult.AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) -> void
+Microsoft.Build.Execution.BuildResult.BuildResult() -> void
+Microsoft.Build.Execution.BuildResult.CircularDependency.get -> bool
+Microsoft.Build.Execution.BuildResult.ConfigurationId.get -> int
+Microsoft.Build.Execution.BuildResult.Exception.get -> System.Exception
+Microsoft.Build.Execution.BuildResult.GlobalRequestId.get -> int
+Microsoft.Build.Execution.BuildResult.HasResultsForTarget(string target) -> bool
+Microsoft.Build.Execution.BuildResult.MergeResults(Microsoft.Build.Execution.BuildResult results) -> void
+Microsoft.Build.Execution.BuildResult.NodeRequestId.get -> int
+Microsoft.Build.Execution.BuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildResult.ParentGlobalRequestId.get -> int
+Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.set -> void
+Microsoft.Build.Execution.BuildResult.ResultsByTarget.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>
+Microsoft.Build.Execution.BuildResult.SubmissionId.get -> int
+Microsoft.Build.Execution.BuildResult.this[string target].get -> Microsoft.Build.Execution.ITargetResult
+Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildResultCode.Failure = 1 -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildResultCode.Success = 0 -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildSubmission
+Microsoft.Build.Execution.BuildSubmission.AsyncContext.get -> object
+Microsoft.Build.Execution.BuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
+Microsoft.Build.Execution.BuildSubmission.BuildResult.get -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildSubmission.BuildResult.set -> void
+Microsoft.Build.Execution.BuildSubmission.Execute() -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) -> void
+Microsoft.Build.Execution.BuildSubmission.IsCompleted.get -> bool
+Microsoft.Build.Execution.BuildSubmission.SubmissionId.get -> int
+Microsoft.Build.Execution.BuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
+Microsoft.Build.Execution.BuildSubmissionCompleteCallback
+Microsoft.Build.Execution.HostServices
+Microsoft.Build.Execution.HostServices.GetHostObject(string projectFile, string targetName, string taskName) -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.HostServices.HostServices() -> void
+Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
+Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
+Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
+Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
+Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
+Microsoft.Build.Execution.ITargetResult
+Microsoft.Build.Execution.ITargetResult.Exception.get -> System.Exception
+Microsoft.Build.Execution.ITargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Execution.ITargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeAffinity.Any = 2 -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeAffinity.InProc = 0 -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeAffinity.OutOfProc = 1 -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.BuildComplete = 0 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.BuildCompleteReuse = 1 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.ConnectionFailed = 2 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.Error = 3 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcNode
+Microsoft.Build.Execution.OutOfProcNode.OutOfProcNode() -> void
+Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude) -> Microsoft.Build.Execution.ProjectItemInstance
+Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Execution.ProjectItemInstance
+Microsoft.Build.Execution.ProjectInstance.Build() -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.DeepCopy() -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.DeepCopy(bool isImmutable) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.DefaultTargets.get -> System.Collections.Generic.List<string>
+Microsoft.Build.Execution.ProjectInstance.Directory.get -> string
+Microsoft.Build.Execution.ProjectInstance.EvaluateCondition(string condition) -> bool
+Microsoft.Build.Execution.ProjectInstance.EvaluatedItemElements.get -> System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement>
+Microsoft.Build.Execution.ProjectInstance.EvaluationId.get -> int
+Microsoft.Build.Execution.ProjectInstance.EvaluationId.set -> void
+Microsoft.Build.Execution.ProjectInstance.ExpandString(string unexpandedValue) -> string
+Microsoft.Build.Execution.ProjectInstance.FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.FullPath.get -> string
+Microsoft.Build.Execution.ProjectInstance.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
+Microsoft.Build.Execution.ProjectInstance.GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance>
+Microsoft.Build.Execution.ProjectInstance.GetProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Execution.ProjectInstance.GetPropertyValue(string name) -> string
+Microsoft.Build.Execution.ProjectInstance.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.ProjectInstance.ImportPaths.get -> System.Collections.Generic.IReadOnlyList<string>
+Microsoft.Build.Execution.ProjectInstance.ImportPathsIncludingDuplicates.get -> System.Collections.Generic.IReadOnlyList<string>
+Microsoft.Build.Execution.ProjectInstance.InitialTargets.get -> System.Collections.Generic.List<string>
+Microsoft.Build.Execution.ProjectInstance.IsImmutable.get -> bool
+Microsoft.Build.Execution.ProjectInstance.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance>
+Microsoft.Build.Execution.ProjectInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
+Microsoft.Build.Execution.ProjectInstance.ItemTypes.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Execution.ProjectInstance.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Execution.ProjectInstance.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) -> bool
+Microsoft.Build.Execution.ProjectInstance.RemoveProperty(string name) -> bool
+Microsoft.Build.Execution.ProjectInstance.SetProperty(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Execution.ProjectInstance.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
+Microsoft.Build.Execution.ProjectInstance.ToolsVersion.get -> string
+Microsoft.Build.Execution.ProjectInstance.ToProjectRootElement() -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.get -> bool
+Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.set -> void
+Microsoft.Build.Execution.ProjectInstance.UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) -> void
+Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectInstanceSettings.Immutable = 1 -> Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectInstanceSettings.ImmutableWithFastItemLookup = 3 -> Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectInstanceSettings.None = 0 -> Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectItemDefinitionInstance
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance>
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataCount.get -> int
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataNames.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Execution.ProjectItemGroupTaskInstance
+Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance>
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Exclude.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Include.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicates.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadata.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadata.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptions.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance>
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Remove.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadata.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Value.get -> string
+Microsoft.Build.Execution.ProjectItemInstance
+Microsoft.Build.Execution.ProjectItemInstance.DirectMetadataCount.get -> int
+Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.get -> string
+Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.set -> void
+Microsoft.Build.Execution.ProjectItemInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectItemInstance.GetMetadataValue(string name) -> string
+Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(string name) -> bool
+Microsoft.Build.Execution.ProjectItemInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectItemInstance.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance>
+Microsoft.Build.Execution.ProjectItemInstance.MetadataCount.get -> int
+Microsoft.Build.Execution.ProjectItemInstance.MetadataNames.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Execution.ProjectItemInstance.Project.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectItemInstance.RemoveMetadata(string metadataName) -> void
+Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) -> void
+Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectMetadataInstance.DeepClone() -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValue.get -> string
+Microsoft.Build.Execution.ProjectMetadataInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectOnErrorInstance
+Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargets.get -> string
+Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance
+Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance>
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Value.get -> string
+Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.get -> string
+Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.set -> void
+Microsoft.Build.Execution.ProjectPropertyInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance
+Microsoft.Build.Execution.ProjectTargetInstance.AfterTargets.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargets.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Children.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild>
+Microsoft.Build.Execution.ProjectTargetInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargets.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.FullPath.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.Inputs.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputs.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.OnErrorChildren.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance>
+Microsoft.Build.Execution.ProjectTargetInstance.Outputs.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Returns.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance>
+Microsoft.Build.Execution.ProjectTargetInstanceChild
+Microsoft.Build.Execution.ProjectTargetInstanceChild.FullPath.get -> string
+Microsoft.Build.Execution.ProjectTargetInstanceChild.ProjectTargetInstanceChild() -> void
+Microsoft.Build.Execution.ProjectTaskInstance
+Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnError.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitecture.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntime.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.Outputs.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild>
+Microsoft.Build.Execution.ProjectTaskInstance.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.ProjectTaskInstanceChild
+Microsoft.Build.Execution.ProjectTaskInstanceChild.ProjectTaskInstanceChild() -> void
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameter.get -> string
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyName.get -> string
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameter.get -> string
+Microsoft.Build.Execution.RequestedProjectState
+Microsoft.Build.Execution.RequestedProjectState.ItemFilters.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
+Microsoft.Build.Execution.RequestedProjectState.ItemFilters.set -> void
+Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.get -> System.Collections.Generic.List<string>
+Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.set -> void
+Microsoft.Build.Execution.RequestedProjectState.RequestedProjectState() -> void
+Microsoft.Build.Execution.TargetResult
+Microsoft.Build.Execution.TargetResult.Exception.get -> System.Exception
+Microsoft.Build.Execution.TargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Execution.TargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode.Failure = 2 -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode.Skipped = 0 -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode.Success = 1 -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Experimental.ProjectCache.CacheContext
+Microsoft.Build.Experimental.ProjectCache.CacheContext.CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) -> void
+Microsoft.Build.Experimental.ProjectCache.CacheContext.FileSystem.get -> Microsoft.Build.FileSystem.MSBuildFileSystemBase
+Microsoft.Build.Experimental.ProjectCache.CacheContext.Graph.get -> Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Experimental.ProjectCache.CacheContext.GraphEntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
+Microsoft.Build.Experimental.ProjectCache.CacheContext.MSBuildExePath.get -> string
+Microsoft.Build.Experimental.ProjectCache.CacheContext.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.Experimental.ProjectCache.CacheResult
+Microsoft.Build.Experimental.ProjectCache.CacheResult.BuildResult.get -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Experimental.ProjectCache.CacheResult.ProxyTargets.get -> Microsoft.Build.Experimental.ProjectCache.ProxyTargets
+Microsoft.Build.Experimental.ProjectCache.CacheResult.ResultType.get -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheHit = 1 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
+Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
+Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
+Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.ProjectCachePluginBase() -> void
+Microsoft.Build.Experimental.ProjectCache.ProxyTargets
+Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) -> void
+Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargetToRealTargetMap.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.FileSystem.MSBuildFileSystemBase
+Microsoft.Build.FileSystem.MSBuildFileSystemBase.MSBuildFileSystemBase() -> void
+Microsoft.Build.Globbing.CompositeGlob
+Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) -> void
+Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> void
+Microsoft.Build.Globbing.CompositeGlob.Globs.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob>
+Microsoft.Build.Globbing.CompositeGlob.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions
+Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Globbing.IMSBuildGlob.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.MSBuildGlob
+Microsoft.Build.Globbing.MSBuildGlob.FilenamePart.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.FixedDirectoryPart.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.IsLegal.get -> bool
+Microsoft.Build.Globbing.MSBuildGlob.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(string stringToMatch) -> Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FilenamePartMatchGroup.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FixedDirectoryPartMatchGroup.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.IsMatch.get -> bool
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.MatchInfoResult() -> void
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.WildcardDirectoryPartMatchGroup.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.WildcardDirectoryPart.get -> string
+Microsoft.Build.Globbing.MSBuildGlobWithGaps
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.Gaps.get -> Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) -> void
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) -> void
+Microsoft.Build.Graph.GraphBuildOptions
+Microsoft.Build.Graph.GraphBuildOptions.Build.get -> bool
+Microsoft.Build.Graph.GraphBuildOptions.Build.init -> void
+Microsoft.Build.Graph.GraphBuildRequestData
+Microsoft.Build.Graph.GraphBuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildOptions.get -> Microsoft.Build.Graph.GraphBuildOptions
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraphEntryPoints.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint>
+Microsoft.Build.Graph.GraphBuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Graph.GraphBuildResult.CircularDependency.get -> bool
+Microsoft.Build.Graph.GraphBuildResult.Exception.get -> System.Exception
+Microsoft.Build.Graph.GraphBuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Graph.GraphBuildResult.ResultsByNode.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult>
+Microsoft.Build.Graph.GraphBuildResult.SubmissionId.get -> int
+Microsoft.Build.Graph.GraphBuildResult.this[Microsoft.Build.Graph.ProjectGraphNode node].get -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Graph.GraphBuildSubmission
+Microsoft.Build.Graph.GraphBuildSubmission.AsyncContext.get -> object
+Microsoft.Build.Graph.GraphBuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
+Microsoft.Build.Graph.GraphBuildSubmission.BuildResult.get -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Graph.GraphBuildSubmission.Execute() -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Graph.GraphBuildSubmission.ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) -> void
+Microsoft.Build.Graph.GraphBuildSubmission.IsCompleted.get -> bool
+Microsoft.Build.Graph.GraphBuildSubmission.SubmissionId.get -> int
+Microsoft.Build.Graph.GraphBuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
+Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback
+Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Graph.ProjectGraph.ConstructionMetrics.get -> Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
+Microsoft.Build.Graph.ProjectGraph.EntryPointNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraph.GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>>
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.ConstructionTime.get -> System.TimeSpan
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.EdgeCount.get -> int
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics() -> void
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) -> void
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.NodeCount.get -> int
+Microsoft.Build.Graph.ProjectGraph.GraphRoots.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc
+Microsoft.Build.Graph.ProjectGraph.ProjectNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraph.ProjectNodesTopologicallySorted.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraphEntryPoint
+Microsoft.Build.Graph.ProjectGraphEntryPoint.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectFile.get -> string
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint() -> void
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile) -> void
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Graph.ProjectGraphNode
+Microsoft.Build.Graph.ProjectGraphNode.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Graph.ProjectGraphNode.ProjectReferences.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraphNode.ReferencingProjects.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Logging.BinaryLogger
+Microsoft.Build.Logging.BinaryLogger.BinaryLogger() -> void
+Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.get -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.set -> void
+Microsoft.Build.Logging.BinaryLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Logging.BinaryLogger.Parameters.get -> string
+Microsoft.Build.Logging.BinaryLogger.Parameters.set -> void
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.Embed = 1 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.None = 0 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.ZipFile = 2 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.Shutdown() -> void
+Microsoft.Build.Logging.BinaryLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.BinaryLogger.Verbosity.set -> void
+Microsoft.Build.Logging.BinaryLogReplayEventSource
+Microsoft.Build.Logging.BinaryLogReplayEventSource.BinaryLogReplayEventSource() -> void
+Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath) -> void
+Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) -> void
+Microsoft.Build.Logging.BuildEventArgsReader
+Microsoft.Build.Logging.BuildEventArgsReader.BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) -> void
+Microsoft.Build.Logging.BuildEventArgsReader.Dispose() -> void
+Microsoft.Build.Logging.BuildEventArgsReader.Read() -> Microsoft.Build.Framework.BuildEventArgs
+Microsoft.Build.Logging.ColorResetter
+Microsoft.Build.Logging.ColorSetter
+Microsoft.Build.Logging.ConfigurableForwardingLogger
+Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.get -> int
+Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.set -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.get -> string
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.set -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.set -> void
+Microsoft.Build.Logging.ConsoleLogger
+Microsoft.Build.Logging.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
+Microsoft.Build.Logging.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger() -> void
+Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) -> void
+Microsoft.Build.Logging.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.Parameters.get -> string
+Microsoft.Build.Logging.ConsoleLogger.Parameters.set -> void
+Microsoft.Build.Logging.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ShowSummary.get -> bool
+Microsoft.Build.Logging.ConsoleLogger.ShowSummary.set -> void
+Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.get -> bool
+Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.set -> void
+Microsoft.Build.Logging.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ConsoleLogger.Verbosity.set -> void
+Microsoft.Build.Logging.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.WriteHandler.get -> Microsoft.Build.Logging.WriteHandler
+Microsoft.Build.Logging.ConsoleLogger.WriteHandler.set -> void
+Microsoft.Build.Logging.DistributedFileLogger
+Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.set -> void
+Microsoft.Build.Logging.DistributedFileLogger.DistributedFileLogger() -> void
+Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.Logging.DistributedFileLogger.NodeId.get -> int
+Microsoft.Build.Logging.DistributedFileLogger.NodeId.set -> void
+Microsoft.Build.Logging.DistributedFileLogger.Parameters.get -> string
+Microsoft.Build.Logging.DistributedFileLogger.Parameters.set -> void
+Microsoft.Build.Logging.DistributedFileLogger.Shutdown() -> void
+Microsoft.Build.Logging.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.DistributedFileLogger.Verbosity.set -> void
+Microsoft.Build.Logging.EventArgsDispatcher
+Microsoft.Build.Logging.EventArgsDispatcher.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
+Microsoft.Build.Logging.EventArgsDispatcher.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.EventArgsDispatcher() -> void
+Microsoft.Build.Logging.EventArgsDispatcher.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
+Microsoft.Build.Logging.FileLogger
+Microsoft.Build.Logging.FileLogger.FileLogger() -> void
+Microsoft.Build.Logging.ForwardingLoggerRecord
+Microsoft.Build.Logging.ForwardingLoggerRecord.CentralLogger.get -> Microsoft.Build.Framework.ILogger
+Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerDescription.get -> Microsoft.Build.Logging.LoggerDescription
+Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) -> void
+Microsoft.Build.Logging.LoggerDescription
+Microsoft.Build.Logging.LoggerDescription.CreateLogger() -> Microsoft.Build.Framework.ILogger
+Microsoft.Build.Logging.LoggerDescription.IsOptional.get -> bool
+Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) -> void
+Microsoft.Build.Logging.LoggerDescription.LoggerSwitchParameters.get -> string
+Microsoft.Build.Logging.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ProfilerLogger
+Microsoft.Build.Logging.ProfilerLogger.FileToLog.get -> string
+Microsoft.Build.Logging.ProfilerLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Logging.ProfilerLogger.Parameters.get -> string
+Microsoft.Build.Logging.ProfilerLogger.Parameters.set -> void
+Microsoft.Build.Logging.ProfilerLogger.ProfilerLogger(string fileToLog) -> void
+Microsoft.Build.Logging.ProfilerLogger.Shutdown() -> void
+Microsoft.Build.Logging.ProfilerLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ProfilerLogger.Verbosity.set -> void
+Microsoft.Build.Logging.WriteHandler
+Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider
+Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.ExternalProjectsProvider() -> void
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Collection.get -> Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) -> Microsoft.Build.Evaluation.ResolvedImport
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) -> Microsoft.Build.Construction.ProjectChooseElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) -> Microsoft.Build.Construction.ProjectExtensionsElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) -> Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectItemDefinition
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) -> Microsoft.Build.Evaluation.ProjectItem
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) -> Microsoft.Build.Construction.ProjectOnErrorElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) -> Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) -> Microsoft.Build.Construction.ProjectSdkElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) -> Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) -> Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) -> Microsoft.Build.Construction.ProjectWhenElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink.ProjectChooseElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
+Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.ProjectElementContainerLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ProjectElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.ProjectExtensionsElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ProjectImportElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink.ProjectImportGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink.ProjectItemDefinitionElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink.ProjectItemDefinitionGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ProjectItemDefinitionLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ProjectItemElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink.ProjectItemGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ProjectItemLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectLink
+Microsoft.Build.ObjectModelRemoting.ProjectLink.ProjectLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ProjectMetadataElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.ProjectMetadataLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink.ProjectOnErrorElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink.ProjectOtherwiseElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink.ProjectOutputElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ProjectPropertyElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink.ProjectPropertyGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.ProjectPropertyLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectRootElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink.ProjectSdkElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.ProjectTargetElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ProjectTaskElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.ProjectUsingTaskBodyElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink.ProjectUsingTaskElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.ProjectUsingTaskParameterElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink.ProjectWhenElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink
+Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink.UsingTaskParameterGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.LocalName.get -> string
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.NamespaceURI.get -> string
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.Value.get -> string
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink() -> void
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink(string localName, string value, string namespaceUri) -> void
+override Microsoft.Build.Construction.ElementLocation.Equals(object obj) -> bool
+override Microsoft.Build.Construction.ElementLocation.GetHashCode() -> int
+override Microsoft.Build.Construction.ElementLocation.ToString() -> string
+override Microsoft.Build.Construction.ProjectChooseElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectChooseElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectChooseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectExtensionsElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectExtensionsElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectItemElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectItemGroupElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectOtherwiseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectRootElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectRootElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectRootElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectTargetElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectTaskElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.get -> string
+override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.set -> void
+override Microsoft.Build.Construction.UsingTaskParameterGroupElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Exceptions.BuildAbortedException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Exceptions.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Exceptions.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Exceptions.InvalidProjectFileException.Message.get -> string
+override Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectItemInstance.ToString() -> string
+override Microsoft.Build.Execution.ProjectMetadataInstance.ToString() -> string
+override Microsoft.Build.Execution.ProjectOnErrorInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectOnErrorInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectOnErrorInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectPropertyInstance.ToString() -> string
+override Microsoft.Build.Execution.ProjectTaskInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+override Microsoft.Build.Logging.FileLogger.Shutdown() -> void
+static Microsoft.Build.Construction.ProjectRootElement.Create() -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Open(string path) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.SolutionFile.Parse(string solutionFile) -> Microsoft.Build.Construction.SolutionFile
+static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) -> Microsoft.Build.Evaluation.Context.EvaluationContext
+static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) -> Microsoft.Build.Evaluation.Context.EvaluationContext
+static Microsoft.Build.Evaluation.Project.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
+static Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
+static Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
+static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) -> string
+static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) -> string
+static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) -> string
+static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) -> string
+static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) -> string
+static Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
+static Microsoft.Build.Evaluation.ProjectCollection.DisplayVersion.get -> string
+static Microsoft.Build.Evaluation.ProjectCollection.Escape(string unescapedString) -> string
+static Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
+static Microsoft.Build.Evaluation.ProjectCollection.Unescape(string escapedString) -> string
+static Microsoft.Build.Evaluation.ProjectCollection.Version.get -> System.Version
+static Microsoft.Build.Execution.BuildManager.DefaultBuildManager.get -> Microsoft.Build.Execution.BuildManager
+static Microsoft.Build.Execution.ProjectInstance.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
+static Microsoft.Build.Execution.ProjectInstance.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
+static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) -> string
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
+static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
+static Microsoft.Build.Globbing.MSBuildGlob.Parse(string globRoot, string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
+static Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) -> void
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Get(Microsoft.Build.Evaluation.ProjectCollection collection) -> Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLink(object obj) -> object
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project>
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.IsLocal(object obj) -> bool
+static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) -> Microsoft.Build.Construction.ElementLocation
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributes(Microsoft.Build.Construction.ProjectElement xml) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) -> string
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) -> bool
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetPureText(Microsoft.Build.Construction.ProjectElement xml) -> string
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> string
+static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> object
+static Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
+virtual Microsoft.Build.Construction.ProjectElement.Condition.get -> string
+virtual Microsoft.Build.Construction.ProjectElement.Condition.set -> void
+virtual Microsoft.Build.Construction.ProjectElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+virtual Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+virtual Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) -> void
+virtual Microsoft.Build.Evaluation.ProjectCollection.Dispose(bool disposing) -> void
+virtual Microsoft.Build.Execution.ProjectPropertyInstance.IsImmutable.get -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.DirectoryExists(string path) -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileExists(string path) -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileOrDirectoryExists(string path) -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetAttributes(string path) -> System.IO.FileAttributes
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetLastWriteTimeUtc(string path) -> System.DateTime
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFile(string path) -> System.IO.TextReader
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllBytes(string path) -> byte[]
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllText(string path) -> string
+virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
+virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
+virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..c095b7f8e50
--- /dev/null
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -0,0 +1,12 @@
+Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
+Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
+Microsoft.Build.FileSystem.FindPredicate
+Microsoft.Build.FileSystem.FindTransform<TResult>
+Microsoft.Build.FileSystem.IDirectoryCache
+Microsoft.Build.FileSystem.IDirectoryCache.DirectoryExists(string path) -> bool
+Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
+Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
+Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
+Microsoft.Build.FileSystem.IDirectoryCacheFactory
+Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
+static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
\ No newline at end of file
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..eb03a4d60f0
--- /dev/null
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -0,0 +1,1819 @@
+abstract Microsoft.Build.Construction.ElementLocation.Column.get -> int
+abstract Microsoft.Build.Construction.ElementLocation.File.get -> string
+abstract Microsoft.Build.Construction.ElementLocation.Line.get -> int
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsImported.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty.get -> bool
+abstract Microsoft.Build.Evaluation.ProjectProperty.Name.get -> string
+abstract Microsoft.Build.Evaluation.ProjectProperty.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.get -> string
+abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.set -> void
+abstract Microsoft.Build.Evaluation.ProjectProperty.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
+abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Condition.get -> string
+abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Condition.get -> string
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.get -> bool
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.set -> void
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogError(string error) -> void
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = null) -> void
+abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogWarning(string warning) -> void
+abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
+abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
+abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult>
+abstract Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.GetLoadedProjects(string filePath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElement child) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.Count.get -> int
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.LastChild.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Attributes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ElementName.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(string attributeName) -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(string attributeName, bool nullIfNotExists) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Location.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.OuterElement.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PureText.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.GetSubElement(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.SetSubElement(string name, string value) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadataValue(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ItemType.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Project.get -> Microsoft.Build.Evaluation.Project
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ChangeItemType(string newType) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ChangeItemType(string newItemType) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.DirectMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.EvaluatedInclude.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadataValue(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.HasMetadata(string name) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.MetadataCollection.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Project.get -> Microsoft.Build.Evaluation.Project
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.RemoveMetadata(string name) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Rename(string name) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ExpandString(string unexpandedValue) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetPropertyValue(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsDirty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemTypes.get -> System.Collections.Generic.ICollection<string>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.LastEvaluationId.get -> int
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.MarkDirty() -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveGlobalProperty(string name) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SaveLogicalProject(System.IO.TextWriter writer) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetGlobalProperty(string name, string escapedValue) -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SubToolsetVersion.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ToolsVersion.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Unload() -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ChangeName(string newName) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.EvaluatedValueEscaped.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Parent.get -> object
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
+abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ChangeName(string newName) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.EvaluatedIncludeEscaped.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsEnvironmentProperty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsGlobalProperty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsImported.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsReservedProperty.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Name.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Project.get -> Microsoft.Build.Evaluation.Project
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.DirectoryPath.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Encoding.get -> System.Text.Encoding
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.HasUnsavedChanges.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.LastWriteTimeWhenRead.get -> System.DateTime
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.MarkDirty(string reason, string param) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.PreserveFormatting.get -> bool
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.RawXml.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.IO.TextWriter writer) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.Text.Encoding saveEncoding) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.TimeLastChanged.get -> System.DateTime
+abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Version.get -> int
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Returns.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.GetParameter(string name) -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveAllParameters() -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveParameter(string name) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.SetParameter(string name, string unevaluatedValue) -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.set -> void
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.get -> string
+abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.set -> void
+const Microsoft.Build.Evaluation.MatchOnMetadataConstants.MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Resolver.get -> Microsoft.Build.Framework.SdkResolver
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Sdk.get -> Microsoft.Build.Framework.SdkReference
+Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) -> void
+Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ElementLocation.ElementLocation() -> void
+Microsoft.Build.Construction.ElementLocation.LocationString.get -> string
+Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ImplicitImportLocation.Bottom = 2 -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ImplicitImportLocation.None = 0 -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ImplicitImportLocation.Top = 1 -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ProjectChooseElement
+Microsoft.Build.Construction.ProjectChooseElement.OtherwiseElement.get -> Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.Construction.ProjectChooseElement.WhenElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement>
+Microsoft.Build.Construction.ProjectConfigurationInSolution
+Microsoft.Build.Construction.ProjectConfigurationInSolution.ConfigurationName.get -> string
+Microsoft.Build.Construction.ProjectConfigurationInSolution.FullName.get -> string
+Microsoft.Build.Construction.ProjectConfigurationInSolution.IncludeInBuild.get -> bool
+Microsoft.Build.Construction.ProjectConfigurationInSolution.PlatformName.get -> string
+Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElement.AllParents.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer>
+Microsoft.Build.Construction.ProjectElement.Clone() -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElement.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Construction.ProjectElement.ElementName.get -> string
+Microsoft.Build.Construction.ProjectElement.Label.get -> string
+Microsoft.Build.Construction.ProjectElement.Label.set -> void
+Microsoft.Build.Construction.ProjectElement.LabelLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectElement.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectElement.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElement.OuterElement.get -> string
+Microsoft.Build.Construction.ProjectElement.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
+Microsoft.Build.Construction.ProjectElement.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElementContainer
+Microsoft.Build.Construction.ProjectElementContainer.AllChildren.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement child) -> void
+Microsoft.Build.Construction.ProjectElementContainer.Children.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Construction.ProjectElementContainer.ChildrenReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Construction.ProjectElementContainer.Count.get -> int
+Microsoft.Build.Construction.ProjectElementContainer.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
+Microsoft.Build.Construction.ProjectElementContainer.LastChild.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement child) -> void
+Microsoft.Build.Construction.ProjectElementContainer.RemoveAllChildren() -> void
+Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
+Microsoft.Build.Construction.ProjectExtensionsElement
+Microsoft.Build.Construction.ProjectExtensionsElement.Content.get -> string
+Microsoft.Build.Construction.ProjectExtensionsElement.Content.set -> void
+Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].get -> string
+Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].set -> void
+Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
+Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.get -> string
+Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.set -> void
+Microsoft.Build.Construction.ProjectImportElement.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
+Microsoft.Build.Construction.ProjectImportElement.Project.get -> string
+Microsoft.Build.Construction.ProjectImportElement.Project.set -> void
+Microsoft.Build.Construction.ProjectImportElement.ProjectLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectImportElement.Sdk.get -> string
+Microsoft.Build.Construction.ProjectImportElement.Sdk.set -> void
+Microsoft.Build.Construction.ProjectImportElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectImportElement.Version.get -> string
+Microsoft.Build.Construction.ProjectImportElement.Version.set -> void
+Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.Construction.ProjectImportGroupElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectImportGroupElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
+Microsoft.Build.Construction.ProjectInSolution
+Microsoft.Build.Construction.ProjectInSolution.AbsolutePath.get -> string
+Microsoft.Build.Construction.ProjectInSolution.Dependencies.get -> System.Collections.Generic.IReadOnlyList<string>
+Microsoft.Build.Construction.ProjectInSolution.ParentProjectGuid.get -> string
+Microsoft.Build.Construction.ProjectInSolution.ProjectConfigurations.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution>
+Microsoft.Build.Construction.ProjectInSolution.ProjectGuid.get -> string
+Microsoft.Build.Construction.ProjectInSolution.ProjectName.get -> string
+Microsoft.Build.Construction.ProjectInSolution.ProjectType.get -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.ProjectInSolution.ProjectType.set -> void
+Microsoft.Build.Construction.ProjectInSolution.RelativePath.get -> string
+Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemDefinitionElement.ItemType.get -> string
+Microsoft.Build.Construction.ProjectItemDefinitionElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
+Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
+Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectItemElement.Exclude.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Exclude.set -> void
+Microsoft.Build.Construction.ProjectItemElement.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.HasMetadata.get -> bool
+Microsoft.Build.Construction.ProjectItemElement.Include.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Include.set -> void
+Microsoft.Build.Construction.ProjectItemElement.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.ItemType.get -> string
+Microsoft.Build.Construction.ProjectItemElement.ItemType.set -> void
+Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.get -> string
+Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.set -> void
+Microsoft.Build.Construction.ProjectItemElement.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.get -> string
+Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.set -> void
+Microsoft.Build.Construction.ProjectItemElement.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.get -> string
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.set -> void
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.get -> string
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.set -> void
+Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
+Microsoft.Build.Construction.ProjectItemElement.Remove.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Remove.set -> void
+Microsoft.Build.Construction.ProjectItemElement.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.get -> string
+Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.set -> void
+Microsoft.Build.Construction.ProjectItemElement.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemElement.Update.get -> string
+Microsoft.Build.Construction.ProjectItemElement.Update.set -> void
+Microsoft.Build.Construction.ProjectItemElement.UpdateLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectItemGroupElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
+Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.get -> bool
+Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.set -> void
+Microsoft.Build.Construction.ProjectMetadataElement.Name.get -> string
+Microsoft.Build.Construction.ProjectMetadataElement.Name.set -> void
+Microsoft.Build.Construction.ProjectMetadataElement.Value.get -> string
+Microsoft.Build.Construction.ProjectMetadataElement.Value.set -> void
+Microsoft.Build.Construction.ProjectOnErrorElement
+Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.get -> string
+Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.set -> void
+Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.Construction.ProjectOtherwiseElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
+Microsoft.Build.Construction.ProjectOtherwiseElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectOtherwiseElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectOutputElement.IsOutputItem.get -> bool
+Microsoft.Build.Construction.ProjectOutputElement.IsOutputProperty.get -> bool
+Microsoft.Build.Construction.ProjectOutputElement.ItemType.get -> string
+Microsoft.Build.Construction.ProjectOutputElement.ItemType.set -> void
+Microsoft.Build.Construction.ProjectOutputElement.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectOutputElement.PropertyName.get -> string
+Microsoft.Build.Construction.ProjectOutputElement.PropertyName.set -> void
+Microsoft.Build.Construction.ProjectOutputElement.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.get -> string
+Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.set -> void
+Microsoft.Build.Construction.ProjectOutputElement.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectPropertyElement.Name.get -> string
+Microsoft.Build.Construction.ProjectPropertyElement.Name.set -> void
+Microsoft.Build.Construction.ProjectPropertyElement.Value.get -> string
+Microsoft.Build.Construction.ProjectPropertyElement.Value.set -> void
+Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectPropertyGroupElement.AddProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectPropertyGroupElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
+Microsoft.Build.Construction.ProjectPropertyGroupElement.PropertiesReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
+Microsoft.Build.Construction.ProjectPropertyGroupElement.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Construction.ProjectRootElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectRootElement.AddImportGroup() -> Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddProperty(string name, string value) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectRootElement.AddTarget(string name) -> Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(string name, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectRootElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
+Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
+Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
+Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
+Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
+Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
+Microsoft.Build.Construction.ProjectRootElement.DeepClone() -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.get -> string
+Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.set -> void
+Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.DirectoryPath.get -> string
+Microsoft.Build.Construction.ProjectRootElement.Encoding.get -> System.Text.Encoding
+Microsoft.Build.Construction.ProjectRootElement.EscapedFullPath.get -> string
+Microsoft.Build.Construction.ProjectRootElement.FullPath.get -> string
+Microsoft.Build.Construction.ProjectRootElement.FullPath.set -> void
+Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges.get -> bool
+Microsoft.Build.Construction.ProjectRootElement.ImportGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
+Microsoft.Build.Construction.ProjectRootElement.InitialTargets.get -> string
+Microsoft.Build.Construction.ProjectRootElement.InitialTargets.set -> void
+Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
+Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead.get -> System.DateTime
+Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting.get -> bool
+Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
+Microsoft.Build.Construction.ProjectRootElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectRootElement.RawXml.get -> string
+Microsoft.Build.Construction.ProjectRootElement.Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
+Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
+Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save() -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(string path) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(string path, System.Text.Encoding encoding) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter writer) -> void
+Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding saveEncoding) -> void
+Microsoft.Build.Construction.ProjectRootElement.Sdk.get -> string
+Microsoft.Build.Construction.ProjectRootElement.Sdk.set -> void
+Microsoft.Build.Construction.ProjectRootElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.Targets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement>
+Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged.get -> System.DateTime
+Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.get -> string
+Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.set -> void
+Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.get -> string
+Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.set -> void
+Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectRootElement.UsingTasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement>
+Microsoft.Build.Construction.ProjectRootElement.Version.get -> int
+Microsoft.Build.Construction.ProjectSdkElement
+Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.get -> string
+Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.set -> void
+Microsoft.Build.Construction.ProjectSdkElement.Name.get -> string
+Microsoft.Build.Construction.ProjectSdkElement.Name.set -> void
+Microsoft.Build.Construction.ProjectSdkElement.Version.get -> string
+Microsoft.Build.Construction.ProjectSdkElement.Version.set -> void
+Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.Construction.ProjectTargetElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.Construction.ProjectTargetElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.Construction.ProjectTargetElement.AddTask(string taskName) -> Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.Inputs.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Inputs.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.Name.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Name.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.NameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.OnErrors.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement>
+Microsoft.Build.Construction.ProjectTargetElement.Outputs.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Outputs.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.ProjectTargetElement.Returns.get -> string
+Microsoft.Build.Construction.ProjectTargetElement.Returns.set -> void
+Microsoft.Build.Construction.ProjectTargetElement.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTargetElement.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement>
+Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.set -> void
+Microsoft.Build.Construction.ProjectTaskElement.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTaskElement.GetParameter(string name) -> string
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.set -> void
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.set -> void
+Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectTaskElement.Name.get -> string
+Microsoft.Build.Construction.ProjectTaskElement.Outputs.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement>
+Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
+Microsoft.Build.Construction.ProjectTaskElement.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters() -> void
+Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(string name) -> void
+Microsoft.Build.Construction.ProjectTaskElement.SetParameter(string name, string unevaluatedValue) -> void
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.EvaluateLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.AddParameterGroup() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.AddUsingTaskBody(string evaluate, string taskBody) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.ArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.RuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskBody.get -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactoryLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.TaskNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.OutputLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskParameterElement.RequiredLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectWhenElement
+Microsoft.Build.Construction.ProjectWhenElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
+Microsoft.Build.Construction.ProjectWhenElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
+Microsoft.Build.Construction.ProjectWhenElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
+Microsoft.Build.Construction.SolutionConfigurationInSolution
+Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationName.get -> string
+Microsoft.Build.Construction.SolutionConfigurationInSolution.FullName.get -> string
+Microsoft.Build.Construction.SolutionConfigurationInSolution.PlatformName.get -> string
+Microsoft.Build.Construction.SolutionFile
+Microsoft.Build.Construction.SolutionFile.GetDefaultConfigurationName() -> string
+Microsoft.Build.Construction.SolutionFile.GetDefaultPlatformName() -> string
+Microsoft.Build.Construction.SolutionFile.ProjectsByGuid.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution>
+Microsoft.Build.Construction.SolutionFile.ProjectsInOrder.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution>
+Microsoft.Build.Construction.SolutionFile.SolutionConfigurations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution>
+Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.EtpSubProject = 5 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.KnownToBeMSBuildFormat = 1 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.SharedProject = 6 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.SolutionFolder = 2 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.Unknown = 0 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.WebDeploymentProject = 4 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.SolutionProjectType.WebProject = 3 -> Microsoft.Build.Construction.SolutionProjectType
+Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.Construction.UsingTaskParameterGroupElement.Parameters.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement>
+Microsoft.Build.Definition.ProjectOptions
+Microsoft.Build.Definition.ProjectOptions.EvaluationContext.get -> Microsoft.Build.Evaluation.Context.EvaluationContext
+Microsoft.Build.Definition.ProjectOptions.EvaluationContext.set -> void
+Microsoft.Build.Definition.ProjectOptions.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Definition.ProjectOptions.GlobalProperties.set -> void
+Microsoft.Build.Definition.ProjectOptions.LoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Definition.ProjectOptions.LoadSettings.set -> void
+Microsoft.Build.Definition.ProjectOptions.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.Definition.ProjectOptions.ProjectCollection.set -> void
+Microsoft.Build.Definition.ProjectOptions.ProjectOptions() -> void
+Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.get -> string
+Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.set -> void
+Microsoft.Build.Definition.ProjectOptions.ToolsVersion.get -> string
+Microsoft.Build.Definition.ProjectOptions.ToolsVersion.set -> void
+Microsoft.Build.Evaluation.Context.EvaluationContext
+Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
+Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated = 1 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
+Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Shared = 0 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
+Microsoft.Build.Evaluation.GlobResult
+Microsoft.Build.Evaluation.GlobResult.Excludes.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Evaluation.GlobResult.GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) -> void
+Microsoft.Build.Evaluation.GlobResult.IncludeGlobs.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Evaluation.GlobResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.set -> void
+Microsoft.Build.Evaluation.GlobResult.Removes.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Evaluation.GlobResult.Removes.set -> void
+Microsoft.Build.Evaluation.MatchOnMetadataConstants
+Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseInsensitive = 1 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive = 0 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.MatchOnMetadataOptions.PathLike = 2 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeAllOptions = -1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeToolsVersion = 2 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlDeclaration = 1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlNamespace = 4 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.NewProjectFileOptions.None = 0 -> Microsoft.Build.Evaluation.NewProjectFileOptions
+Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Exclude = 1 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Include = 0 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Remove = 3 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Operation.Update = 2 -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.Project.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+Microsoft.Build.Evaluation.Project.Build() -> bool
+Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger logger) -> bool
+Microsoft.Build.Evaluation.Project.Build(string target) -> bool
+Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
+Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Evaluation.Project.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
+Microsoft.Build.Evaluation.Project.CreateProjectInstance() -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Evaluation.Project.DirectoryPath.get -> string
+Microsoft.Build.Evaluation.Project.DisableMarkDirty.get -> bool
+Microsoft.Build.Evaluation.Project.DisableMarkDirty.set -> void
+Microsoft.Build.Evaluation.Project.EvaluationCounter.get -> int
+Microsoft.Build.Evaluation.Project.ExpandString(string unexpandedValue) -> string
+Microsoft.Build.Evaluation.Project.FullPath.get -> string
+Microsoft.Build.Evaluation.Project.FullPath.set -> void
+Microsoft.Build.Evaluation.Project.GetAllGlobs() -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
+Microsoft.Build.Evaluation.Project.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
+Microsoft.Build.Evaluation.Project.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.Evaluation.Project.GetPropertyValue(string name) -> string
+Microsoft.Build.Evaluation.Project.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Evaluation.Project.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
+Microsoft.Build.Evaluation.Project.IsBuildEnabled.get -> bool
+Microsoft.Build.Evaluation.Project.IsBuildEnabled.set -> void
+Microsoft.Build.Evaluation.Project.IsDirty.get -> bool
+Microsoft.Build.Evaluation.Project.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
+Microsoft.Build.Evaluation.Project.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
+Microsoft.Build.Evaluation.Project.ItemTypes.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Evaluation.Project.LastEvaluationId.get -> int
+Microsoft.Build.Evaluation.Project.MarkDirty() -> void
+Microsoft.Build.Evaluation.Project.Project() -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
+Microsoft.Build.Evaluation.Project.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.Evaluation.Project.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Evaluation.Project.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
+Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary() -> void
+Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
+Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(string name) -> bool
+Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
+Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
+Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
+Microsoft.Build.Evaluation.Project.Save() -> void
+Microsoft.Build.Evaluation.Project.Save(string path) -> void
+Microsoft.Build.Evaluation.Project.Save(string path, System.Text.Encoding encoding) -> void
+Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter writer) -> void
+Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding encoding) -> void
+Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter writer) -> void
+Microsoft.Build.Evaluation.Project.SetGlobalProperty(string name, string escapedValue) -> bool
+Microsoft.Build.Evaluation.Project.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.Evaluation.Project.SkipEvaluation.get -> bool
+Microsoft.Build.Evaluation.Project.SkipEvaluation.set -> void
+Microsoft.Build.Evaluation.Project.SubToolsetVersion.get -> string
+Microsoft.Build.Evaluation.Project.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
+Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.get -> bool
+Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.set -> void
+Microsoft.Build.Evaluation.Project.ToolsVersion.get -> string
+Microsoft.Build.Evaluation.Project.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ProjectChangedEventArgs
+Microsoft.Build.Evaluation.ProjectChangedEventArgs.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset toolset) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(string toolsVersion) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.Count.get -> int
+Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.get -> string
+Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.Dispose() -> void
+Microsoft.Build.Evaluation.ProjectCollection.GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) -> string
+Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(string fullPath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
+Microsoft.Build.Evaluation.ProjectCollection.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
+Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Evaluation.ProjectCollection.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Evaluation.ProjectCollection.HostServices.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectCollection.Loggers.get -> System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger>
+Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded -> Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectRootElement.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs>
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection() -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs>
+Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs>
+Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> void
+Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
+Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> void
+Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets() -> void
+Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(string name) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(string toolsVersion) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(string name, string value) -> void
+Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.get -> bool
+Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.set -> void
+Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ProjectCollection.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
+Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> bool
+Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects() -> void
+Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> void
+Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project project) -> void
+Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers() -> void
+Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs
+Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.Changed.get -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.DefaultToolsVersion = 0 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.DisableMarkDirty = 7 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.GlobalProperties = 3 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.HostServices = 6 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.IsBuildEnabled = 4 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.Loggers = 2 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.OnlyLogCriticalEvents = 5 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.SkipEvaluation = 8 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectCollectionChangedState.Toolsets = 1 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
+Microsoft.Build.Evaluation.ProjectItem
+Microsoft.Build.Evaluation.ProjectItem.DirectMetadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount.get -> int
+Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude.get -> string
+Microsoft.Build.Evaluation.ProjectItem.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(string name) -> string
+Microsoft.Build.Evaluation.ProjectItem.HasMetadata(string name) -> bool
+Microsoft.Build.Evaluation.ProjectItem.IsImported.get -> bool
+Microsoft.Build.Evaluation.ProjectItem.ItemType.get -> string
+Microsoft.Build.Evaluation.ProjectItem.ItemType.set -> void
+Microsoft.Build.Evaluation.ProjectItem.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.ProjectItem.MetadataCount.get -> int
+Microsoft.Build.Evaluation.ProjectItem.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(string name) -> bool
+Microsoft.Build.Evaluation.ProjectItem.Rename(string name) -> void
+Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.get -> string
+Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.set -> void
+Microsoft.Build.Evaluation.ProjectItem.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Evaluation.ProjectItemDefinition
+Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(string name) -> string
+Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType.get -> string
+Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
+Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount.get -> int
+Microsoft.Build.Evaluation.ProjectItemDefinition.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.Default = 0 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.DoNotEvaluateElementsWithFalseCondition = 32 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.FailOnUnresolvedSdk = 256 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreEmptyImports = 16 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports = 64 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.ProfileEvaluation = 128 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.RecordDuplicateButNotCircularImports = 2 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements = 8 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectLoadSettings.RejectCircularImports = 4 -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.IsImported.get -> bool
+Microsoft.Build.Evaluation.ProjectMetadata.ItemType.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Evaluation.ProjectMetadata.Name.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.Evaluation.ProjectMetadata.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.get -> string
+Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.set -> void
+Microsoft.Build.Evaluation.ProjectMetadata.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue.get -> string
+Microsoft.Build.Evaluation.ProjectProperty.Project.get -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs
+Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.ProjectXml.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.Reason.get -> string
+Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.Glob = 2 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.Inconclusive = 4 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.StringLiteral = 1 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.Provenance.Undefined = 0 -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.ProvenanceResult
+Microsoft.Build.Evaluation.ProvenanceResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.Evaluation.ProvenanceResult.Occurrences.get -> int
+Microsoft.Build.Evaluation.ProvenanceResult.Operation.get -> Microsoft.Build.Evaluation.Operation
+Microsoft.Build.Evaluation.ProvenanceResult.Provenance.get -> Microsoft.Build.Evaluation.Provenance
+Microsoft.Build.Evaluation.ProvenanceResult.ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) -> void
+Microsoft.Build.Evaluation.ResolvedImport
+Microsoft.Build.Evaluation.ResolvedImport.ImportedProject.get -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Evaluation.ResolvedImport.ImportingElement.get -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.Evaluation.ResolvedImport.IsImported.get -> bool
+Microsoft.Build.Evaluation.ResolvedImport.ResolvedImport() -> void
+Microsoft.Build.Evaluation.ResolvedImport.SdkResult.get -> Microsoft.Build.Framework.SdkResult
+Microsoft.Build.Evaluation.SubToolset
+Microsoft.Build.Evaluation.SubToolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Evaluation.SubToolset.SubToolsetVersion.get -> string
+Microsoft.Build.Evaluation.Toolset
+Microsoft.Build.Evaluation.Toolset.DefaultSubToolsetVersion.get -> string
+Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion() -> string
+Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) -> string
+Microsoft.Build.Evaluation.Toolset.GetProperty(string propertyName, string subToolsetVersion) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Evaluation.Toolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Evaluation.Toolset.SubToolsets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset>
+Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
+Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
+Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) -> void
+Microsoft.Build.Evaluation.Toolset.ToolsPath.get -> string
+Microsoft.Build.Evaluation.Toolset.ToolsVersion.get -> string
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Default = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Local = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Exceptions.BuildAbortedException
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException() -> void
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message) -> void
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Exceptions.BuildAbortedException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.CircularDependencyException
+Microsoft.Build.Exceptions.CircularDependencyException.CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Exceptions.InternalLoggerException
+Microsoft.Build.Exceptions.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
+Microsoft.Build.Exceptions.InternalLoggerException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.InternalLoggerException.HelpKeyword.get -> string
+Microsoft.Build.Exceptions.InternalLoggerException.InitializationException.get -> bool
+Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException() -> void
+Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message) -> void
+Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException
+Microsoft.Build.Exceptions.InvalidProjectFileException.BaseMessage.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.ColumnNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.EndColumnNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.EndLineNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorSubcategory.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.HasBeenLogged.get -> bool
+Microsoft.Build.Exceptions.InvalidProjectFileException.HelpKeyword.get -> string
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException() -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
+Microsoft.Build.Exceptions.InvalidProjectFileException.LineNumber.get -> int
+Microsoft.Build.Exceptions.InvalidProjectFileException.ProjectFile.get -> string
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.ErrorCode.get -> string
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
+Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Execution.BuildManager
+Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) -> void
+Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) -> void
+Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Execution.BuildManager.BuildManager() -> void
+Microsoft.Build.Execution.BuildManager.BuildManager(string hostName) -> void
+Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Execution.BuildManager.CancelAllSubmissions() -> void
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage() -> void
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Importance.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Text.get -> string
+Microsoft.Build.Execution.BuildManager.Dispose() -> void
+Microsoft.Build.Execution.BuildManager.EndBuild() -> void
+Microsoft.Build.Execution.BuildManager.GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildSubmission
+Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildSubmission
+Microsoft.Build.Execution.BuildManager.ResetCaches() -> void
+Microsoft.Build.Execution.BuildManager.ShutdownAllNodes() -> void
+Microsoft.Build.Execution.BuildManager.~BuildManager() -> void
+Microsoft.Build.Execution.BuildParameters
+Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.get -> bool
+Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
+Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
+Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
+Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
+Microsoft.Build.Execution.BuildParameters.Culture.set -> void
+Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.get -> string
+Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.set -> void
+Microsoft.Build.Execution.BuildParameters.DetailedSummary.get -> bool
+Microsoft.Build.Execution.BuildParameters.DetailedSummary.set -> void
+Microsoft.Build.Execution.BuildParameters.DisableInProcNode.get -> bool
+Microsoft.Build.Execution.BuildParameters.DisableInProcNode.set -> void
+Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.get -> bool
+Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.set -> void
+Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.get -> bool
+Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.set -> void
+Microsoft.Build.Execution.BuildParameters.EnvironmentProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord>
+Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.set -> void
+Microsoft.Build.Execution.BuildParameters.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
+Microsoft.Build.Execution.BuildParameters.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.GlobalProperties.set -> void
+Microsoft.Build.Execution.BuildParameters.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Execution.BuildParameters.HostServices.set -> void
+Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.get -> string[]
+Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.set -> void
+Microsoft.Build.Execution.BuildParameters.Interactive.get -> bool
+Microsoft.Build.Execution.BuildParameters.Interactive.set -> void
+Microsoft.Build.Execution.BuildParameters.IsolateProjects.get -> bool
+Microsoft.Build.Execution.BuildParameters.IsolateProjects.set -> void
+Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.get -> bool
+Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.set -> void
+Microsoft.Build.Execution.BuildParameters.Loggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger>
+Microsoft.Build.Execution.BuildParameters.Loggers.set -> void
+Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.get -> bool
+Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.set -> void
+Microsoft.Build.Execution.BuildParameters.LogTaskInputs.get -> bool
+Microsoft.Build.Execution.BuildParameters.LogTaskInputs.set -> void
+Microsoft.Build.Execution.BuildParameters.LowPriority.get -> bool
+Microsoft.Build.Execution.BuildParameters.LowPriority.set -> void
+Microsoft.Build.Execution.BuildParameters.MaxNodeCount.get -> int
+Microsoft.Build.Execution.BuildParameters.MaxNodeCount.set -> void
+Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.get -> int
+Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.set -> void
+Microsoft.Build.Execution.BuildParameters.NodeExeLocation.get -> string
+Microsoft.Build.Execution.BuildParameters.NodeExeLocation.set -> void
+Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.get -> bool
+Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.set -> void
+Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.get -> string
+Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.set -> void
+Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.set -> void
+Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
+Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.set -> void
+Microsoft.Build.Execution.BuildParameters.ResetCaches.get -> bool
+Microsoft.Build.Execution.BuildParameters.ResetCaches.set -> void
+Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.get -> bool
+Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.set -> void
+Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.get -> bool
+Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.set -> void
+Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
+Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.set -> void
+Microsoft.Build.Execution.BuildParameters.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
+Microsoft.Build.Execution.BuildParameters.UICulture.get -> System.Globalization.CultureInfo
+Microsoft.Build.Execution.BuildParameters.UICulture.set -> void
+Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.get -> bool
+Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
+Microsoft.Build.Execution.BuildRequestData
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
+Microsoft.Build.Execution.BuildRequestData.ExplicitlySpecifiedToolsVersion.get -> string
+Microsoft.Build.Execution.BuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestData.GlobalProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Execution.BuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Execution.BuildRequestData.ProjectFullPath.get -> string
+Microsoft.Build.Execution.BuildRequestData.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.BuildRequestData.PropertiesToTransfer.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Execution.BuildRequestData.RequestedProjectState.get -> Microsoft.Build.Execution.RequestedProjectState
+Microsoft.Build.Execution.BuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild = 8 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.FailOnUnresolvedSdk = 128 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState = 4 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports = 64 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.None = 0 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild = 2 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild = 32 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance = 1 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets = 16 -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildResult.AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) -> void
+Microsoft.Build.Execution.BuildResult.BuildResult() -> void
+Microsoft.Build.Execution.BuildResult.CircularDependency.get -> bool
+Microsoft.Build.Execution.BuildResult.ConfigurationId.get -> int
+Microsoft.Build.Execution.BuildResult.Exception.get -> System.Exception
+Microsoft.Build.Execution.BuildResult.GlobalRequestId.get -> int
+Microsoft.Build.Execution.BuildResult.HasResultsForTarget(string target) -> bool
+Microsoft.Build.Execution.BuildResult.MergeResults(Microsoft.Build.Execution.BuildResult results) -> void
+Microsoft.Build.Execution.BuildResult.NodeRequestId.get -> int
+Microsoft.Build.Execution.BuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildResult.ParentGlobalRequestId.get -> int
+Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.set -> void
+Microsoft.Build.Execution.BuildResult.ResultsByTarget.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>
+Microsoft.Build.Execution.BuildResult.SubmissionId.get -> int
+Microsoft.Build.Execution.BuildResult.this[string target].get -> Microsoft.Build.Execution.ITargetResult
+Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildResultCode.Failure = 1 -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildResultCode.Success = 0 -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Execution.BuildSubmission
+Microsoft.Build.Execution.BuildSubmission.AsyncContext.get -> object
+Microsoft.Build.Execution.BuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
+Microsoft.Build.Execution.BuildSubmission.BuildResult.get -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildSubmission.BuildResult.set -> void
+Microsoft.Build.Execution.BuildSubmission.Execute() -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) -> void
+Microsoft.Build.Execution.BuildSubmission.IsCompleted.get -> bool
+Microsoft.Build.Execution.BuildSubmission.SubmissionId.get -> int
+Microsoft.Build.Execution.BuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
+Microsoft.Build.Execution.BuildSubmissionCompleteCallback
+Microsoft.Build.Execution.HostServices
+Microsoft.Build.Execution.HostServices.GetHostObject(string projectFile, string targetName, string taskName) -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.HostServices.HostServices() -> void
+Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
+Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
+Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
+Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
+Microsoft.Build.Execution.ITargetResult
+Microsoft.Build.Execution.ITargetResult.Exception.get -> System.Exception
+Microsoft.Build.Execution.ITargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Execution.ITargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeAffinity.Any = 2 -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeAffinity.InProc = 0 -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeAffinity.OutOfProc = 1 -> Microsoft.Build.Execution.NodeAffinity
+Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.BuildComplete = 0 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.BuildCompleteReuse = 1 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.ConnectionFailed = 2 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.NodeEngineShutdownReason.Error = 3 -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcNode
+Microsoft.Build.Execution.OutOfProcNode.OutOfProcNode() -> void
+Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude) -> Microsoft.Build.Execution.ProjectItemInstance
+Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Execution.ProjectItemInstance
+Microsoft.Build.Execution.ProjectInstance.Build() -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
+Microsoft.Build.Execution.ProjectInstance.DeepCopy() -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.DeepCopy(bool isImmutable) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.DefaultTargets.get -> System.Collections.Generic.List<string>
+Microsoft.Build.Execution.ProjectInstance.Directory.get -> string
+Microsoft.Build.Execution.ProjectInstance.EvaluateCondition(string condition) -> bool
+Microsoft.Build.Execution.ProjectInstance.EvaluatedItemElements.get -> System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement>
+Microsoft.Build.Execution.ProjectInstance.EvaluationId.get -> int
+Microsoft.Build.Execution.ProjectInstance.EvaluationId.set -> void
+Microsoft.Build.Execution.ProjectInstance.ExpandString(string unexpandedValue) -> string
+Microsoft.Build.Execution.ProjectInstance.FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectInstance.FullPath.get -> string
+Microsoft.Build.Execution.ProjectInstance.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
+Microsoft.Build.Execution.ProjectInstance.GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance>
+Microsoft.Build.Execution.ProjectInstance.GetProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Execution.ProjectInstance.GetPropertyValue(string name) -> string
+Microsoft.Build.Execution.ProjectInstance.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.ProjectInstance.ImportPaths.get -> System.Collections.Generic.IReadOnlyList<string>
+Microsoft.Build.Execution.ProjectInstance.ImportPathsIncludingDuplicates.get -> System.Collections.Generic.IReadOnlyList<string>
+Microsoft.Build.Execution.ProjectInstance.InitialTargets.get -> System.Collections.Generic.List<string>
+Microsoft.Build.Execution.ProjectInstance.IsImmutable.get -> bool
+Microsoft.Build.Execution.ProjectInstance.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance>
+Microsoft.Build.Execution.ProjectInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
+Microsoft.Build.Execution.ProjectInstance.ItemTypes.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Execution.ProjectInstance.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Execution.ProjectInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
+Microsoft.Build.Execution.ProjectInstance.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) -> bool
+Microsoft.Build.Execution.ProjectInstance.RemoveProperty(string name) -> bool
+Microsoft.Build.Execution.ProjectInstance.SetProperty(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Execution.ProjectInstance.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
+Microsoft.Build.Execution.ProjectInstance.ToolsVersion.get -> string
+Microsoft.Build.Execution.ProjectInstance.ToProjectRootElement() -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.get -> bool
+Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.set -> void
+Microsoft.Build.Execution.ProjectInstance.UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) -> void
+Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectInstanceSettings.Immutable = 1 -> Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectInstanceSettings.ImmutableWithFastItemLookup = 3 -> Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectInstanceSettings.None = 0 -> Microsoft.Build.Execution.ProjectInstanceSettings
+Microsoft.Build.Execution.ProjectItemDefinitionInstance
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance>
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataCount.get -> int
+Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataNames.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.Execution.ProjectItemGroupTaskInstance
+Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance>
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Exclude.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Include.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicates.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadata.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadata.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptions.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance>
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Remove.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadata.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Value.get -> string
+Microsoft.Build.Execution.ProjectItemInstance
+Microsoft.Build.Execution.ProjectItemInstance.DirectMetadataCount.get -> int
+Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.get -> string
+Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.set -> void
+Microsoft.Build.Execution.ProjectItemInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectItemInstance.GetMetadataValue(string name) -> string
+Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(string name) -> bool
+Microsoft.Build.Execution.ProjectItemInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectItemInstance.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance>
+Microsoft.Build.Execution.ProjectItemInstance.MetadataCount.get -> int
+Microsoft.Build.Execution.ProjectItemInstance.MetadataNames.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Execution.ProjectItemInstance.Project.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Execution.ProjectItemInstance.RemoveMetadata(string metadataName) -> void
+Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) -> void
+Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectMetadataInstance.DeepClone() -> Microsoft.Build.Execution.ProjectMetadataInstance
+Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValue.get -> string
+Microsoft.Build.Execution.ProjectMetadataInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectOnErrorInstance
+Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargets.get -> string
+Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance
+Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance>
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Value.get -> string
+Microsoft.Build.Execution.ProjectPropertyInstance
+Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.get -> string
+Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.set -> void
+Microsoft.Build.Execution.ProjectPropertyInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance
+Microsoft.Build.Execution.ProjectTargetInstance.AfterTargets.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargets.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Children.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild>
+Microsoft.Build.Execution.ProjectTargetInstance.Condition.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargets.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.FullPath.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.Inputs.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputs.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.OnErrorChildren.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance>
+Microsoft.Build.Execution.ProjectTargetInstance.Outputs.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Returns.get -> string
+Microsoft.Build.Execution.ProjectTargetInstance.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTargetInstance.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance>
+Microsoft.Build.Execution.ProjectTargetInstanceChild
+Microsoft.Build.Execution.ProjectTargetInstanceChild.FullPath.get -> string
+Microsoft.Build.Execution.ProjectTargetInstanceChild.ProjectTargetInstanceChild() -> void
+Microsoft.Build.Execution.ProjectTaskInstance
+Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnError.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitecture.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntime.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskInstance.Name.get -> string
+Microsoft.Build.Execution.ProjectTaskInstance.Outputs.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild>
+Microsoft.Build.Execution.ProjectTaskInstance.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.ProjectTaskInstanceChild
+Microsoft.Build.Execution.ProjectTaskInstanceChild.ProjectTaskInstanceChild() -> void
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemType.get -> string
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameter.get -> string
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyName.get -> string
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameter.get -> string
+Microsoft.Build.Execution.RequestedProjectState
+Microsoft.Build.Execution.RequestedProjectState.ItemFilters.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
+Microsoft.Build.Execution.RequestedProjectState.ItemFilters.set -> void
+Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.get -> System.Collections.Generic.List<string>
+Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.set -> void
+Microsoft.Build.Execution.RequestedProjectState.RequestedProjectState() -> void
+Microsoft.Build.Execution.TargetResult
+Microsoft.Build.Execution.TargetResult.Exception.get -> System.Exception
+Microsoft.Build.Execution.TargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Execution.TargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode.Failure = 2 -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode.Skipped = 0 -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Execution.TargetResultCode.Success = 1 -> Microsoft.Build.Execution.TargetResultCode
+Microsoft.Build.Experimental.ProjectCache.CacheContext
+Microsoft.Build.Experimental.ProjectCache.CacheContext.CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) -> void
+Microsoft.Build.Experimental.ProjectCache.CacheContext.FileSystem.get -> Microsoft.Build.FileSystem.MSBuildFileSystemBase
+Microsoft.Build.Experimental.ProjectCache.CacheContext.Graph.get -> Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Experimental.ProjectCache.CacheContext.GraphEntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
+Microsoft.Build.Experimental.ProjectCache.CacheContext.MSBuildExePath.get -> string
+Microsoft.Build.Experimental.ProjectCache.CacheContext.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.Experimental.ProjectCache.CacheResult
+Microsoft.Build.Experimental.ProjectCache.CacheResult.BuildResult.get -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Experimental.ProjectCache.CacheResult.ProxyTargets.get -> Microsoft.Build.Experimental.ProjectCache.ProxyTargets
+Microsoft.Build.Experimental.ProjectCache.CacheResult.ResultType.get -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheHit = 1 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
+Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
+Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
+Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
+Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
+Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
+Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.ProjectCachePluginBase() -> void
+Microsoft.Build.Experimental.ProjectCache.ProxyTargets
+Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) -> void
+Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargetToRealTargetMap.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.FileSystem.MSBuildFileSystemBase
+Microsoft.Build.FileSystem.MSBuildFileSystemBase.MSBuildFileSystemBase() -> void
+Microsoft.Build.Globbing.CompositeGlob
+Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) -> void
+Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> void
+Microsoft.Build.Globbing.CompositeGlob.Globs.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob>
+Microsoft.Build.Globbing.CompositeGlob.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions
+Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Globbing.IMSBuildGlob.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.MSBuildGlob
+Microsoft.Build.Globbing.MSBuildGlob.FilenamePart.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.FixedDirectoryPart.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.IsLegal.get -> bool
+Microsoft.Build.Globbing.MSBuildGlob.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(string stringToMatch) -> Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FilenamePartMatchGroup.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FixedDirectoryPartMatchGroup.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.IsMatch.get -> bool
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.MatchInfoResult() -> void
+Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.WildcardDirectoryPartMatchGroup.get -> string
+Microsoft.Build.Globbing.MSBuildGlob.WildcardDirectoryPart.get -> string
+Microsoft.Build.Globbing.MSBuildGlobWithGaps
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.Gaps.get -> Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.IsMatch(string stringToMatch) -> bool
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) -> void
+Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) -> void
+Microsoft.Build.Graph.GraphBuildOptions
+Microsoft.Build.Graph.GraphBuildOptions.Build.get -> bool
+Microsoft.Build.Graph.GraphBuildOptions.Build.init -> void
+Microsoft.Build.Graph.GraphBuildRequestData
+Microsoft.Build.Graph.GraphBuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildOptions.get -> Microsoft.Build.Graph.GraphBuildOptions
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) -> void
+Microsoft.Build.Graph.GraphBuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
+Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraphEntryPoints.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint>
+Microsoft.Build.Graph.GraphBuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
+Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Graph.GraphBuildResult.CircularDependency.get -> bool
+Microsoft.Build.Graph.GraphBuildResult.Exception.get -> System.Exception
+Microsoft.Build.Graph.GraphBuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
+Microsoft.Build.Graph.GraphBuildResult.ResultsByNode.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult>
+Microsoft.Build.Graph.GraphBuildResult.SubmissionId.get -> int
+Microsoft.Build.Graph.GraphBuildResult.this[Microsoft.Build.Graph.ProjectGraphNode node].get -> Microsoft.Build.Execution.BuildResult
+Microsoft.Build.Graph.GraphBuildSubmission
+Microsoft.Build.Graph.GraphBuildSubmission.AsyncContext.get -> object
+Microsoft.Build.Graph.GraphBuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
+Microsoft.Build.Graph.GraphBuildSubmission.BuildResult.get -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Graph.GraphBuildSubmission.Execute() -> Microsoft.Build.Graph.GraphBuildResult
+Microsoft.Build.Graph.GraphBuildSubmission.ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) -> void
+Microsoft.Build.Graph.GraphBuildSubmission.IsCompleted.get -> bool
+Microsoft.Build.Graph.GraphBuildSubmission.SubmissionId.get -> int
+Microsoft.Build.Graph.GraphBuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
+Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback
+Microsoft.Build.Graph.ProjectGraph
+Microsoft.Build.Graph.ProjectGraph.ConstructionMetrics.get -> Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
+Microsoft.Build.Graph.ProjectGraph.EntryPointNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraph.GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>>
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.ConstructionTime.get -> System.TimeSpan
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.EdgeCount.get -> int
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics() -> void
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) -> void
+Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.NodeCount.get -> int
+Microsoft.Build.Graph.ProjectGraph.GraphRoots.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
+Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc
+Microsoft.Build.Graph.ProjectGraph.ProjectNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraph.ProjectNodesTopologicallySorted.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraphEntryPoint
+Microsoft.Build.Graph.ProjectGraphEntryPoint.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectFile.get -> string
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint() -> void
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile) -> void
+Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
+Microsoft.Build.Graph.ProjectGraphNode
+Microsoft.Build.Graph.ProjectGraphNode.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
+Microsoft.Build.Graph.ProjectGraphNode.ProjectReferences.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Graph.ProjectGraphNode.ReferencingProjects.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
+Microsoft.Build.Logging.BinaryLogger
+Microsoft.Build.Logging.BinaryLogger.BinaryLogger() -> void
+Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.get -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.set -> void
+Microsoft.Build.Logging.BinaryLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Logging.BinaryLogger.Parameters.get -> string
+Microsoft.Build.Logging.BinaryLogger.Parameters.set -> void
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.Embed = 1 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.None = 0 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.ZipFile = 2 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
+Microsoft.Build.Logging.BinaryLogger.Shutdown() -> void
+Microsoft.Build.Logging.BinaryLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.BinaryLogger.Verbosity.set -> void
+Microsoft.Build.Logging.BinaryLogReplayEventSource
+Microsoft.Build.Logging.BinaryLogReplayEventSource.BinaryLogReplayEventSource() -> void
+Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath) -> void
+Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) -> void
+Microsoft.Build.Logging.BuildEventArgsReader
+Microsoft.Build.Logging.BuildEventArgsReader.BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) -> void
+Microsoft.Build.Logging.BuildEventArgsReader.Dispose() -> void
+Microsoft.Build.Logging.BuildEventArgsReader.Read() -> Microsoft.Build.Framework.BuildEventArgs
+Microsoft.Build.Logging.ColorResetter
+Microsoft.Build.Logging.ColorSetter
+Microsoft.Build.Logging.ConfigurableForwardingLogger
+Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.get -> int
+Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.set -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.get -> string
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.set -> void
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.set -> void
+Microsoft.Build.Logging.ConsoleLogger
+Microsoft.Build.Logging.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
+Microsoft.Build.Logging.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger() -> void
+Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) -> void
+Microsoft.Build.Logging.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.Parameters.get -> string
+Microsoft.Build.Logging.ConsoleLogger.Parameters.set -> void
+Microsoft.Build.Logging.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.ShowSummary.get -> bool
+Microsoft.Build.Logging.ConsoleLogger.ShowSummary.set -> void
+Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.get -> bool
+Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.set -> void
+Microsoft.Build.Logging.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ConsoleLogger.Verbosity.set -> void
+Microsoft.Build.Logging.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
+Microsoft.Build.Logging.ConsoleLogger.WriteHandler.get -> Microsoft.Build.Logging.WriteHandler
+Microsoft.Build.Logging.ConsoleLogger.WriteHandler.set -> void
+Microsoft.Build.Logging.DistributedFileLogger
+Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.set -> void
+Microsoft.Build.Logging.DistributedFileLogger.DistributedFileLogger() -> void
+Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.Logging.DistributedFileLogger.NodeId.get -> int
+Microsoft.Build.Logging.DistributedFileLogger.NodeId.set -> void
+Microsoft.Build.Logging.DistributedFileLogger.Parameters.get -> string
+Microsoft.Build.Logging.DistributedFileLogger.Parameters.set -> void
+Microsoft.Build.Logging.DistributedFileLogger.Shutdown() -> void
+Microsoft.Build.Logging.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.DistributedFileLogger.Verbosity.set -> void
+Microsoft.Build.Logging.EventArgsDispatcher
+Microsoft.Build.Logging.EventArgsDispatcher.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
+Microsoft.Build.Logging.EventArgsDispatcher.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.EventArgsDispatcher() -> void
+Microsoft.Build.Logging.EventArgsDispatcher.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
+Microsoft.Build.Logging.EventArgsDispatcher.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
+Microsoft.Build.Logging.FileLogger
+Microsoft.Build.Logging.FileLogger.FileLogger() -> void
+Microsoft.Build.Logging.ForwardingLoggerRecord
+Microsoft.Build.Logging.ForwardingLoggerRecord.CentralLogger.get -> Microsoft.Build.Framework.ILogger
+Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerDescription.get -> Microsoft.Build.Logging.LoggerDescription
+Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) -> void
+Microsoft.Build.Logging.LoggerDescription
+Microsoft.Build.Logging.LoggerDescription.CreateLogger() -> Microsoft.Build.Framework.ILogger
+Microsoft.Build.Logging.LoggerDescription.IsOptional.get -> bool
+Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) -> void
+Microsoft.Build.Logging.LoggerDescription.LoggerSwitchParameters.get -> string
+Microsoft.Build.Logging.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ProfilerLogger
+Microsoft.Build.Logging.ProfilerLogger.FileToLog.get -> string
+Microsoft.Build.Logging.ProfilerLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Logging.ProfilerLogger.Parameters.get -> string
+Microsoft.Build.Logging.ProfilerLogger.Parameters.set -> void
+Microsoft.Build.Logging.ProfilerLogger.ProfilerLogger(string fileToLog) -> void
+Microsoft.Build.Logging.ProfilerLogger.Shutdown() -> void
+Microsoft.Build.Logging.ProfilerLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Logging.ProfilerLogger.Verbosity.set -> void
+Microsoft.Build.Logging.WriteHandler
+Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider
+Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.ExternalProjectsProvider() -> void
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Collection.get -> Microsoft.Build.Evaluation.ProjectCollection
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) -> Microsoft.Build.Evaluation.ResolvedImport
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) -> Microsoft.Build.Construction.ProjectChooseElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) -> Microsoft.Build.Construction.ProjectExtensionsElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) -> Microsoft.Build.Construction.ProjectImportElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) -> Microsoft.Build.Construction.ProjectImportGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectItemDefinition
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) -> Microsoft.Build.Construction.ProjectItemElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) -> Microsoft.Build.Evaluation.ProjectItem
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) -> Microsoft.Build.Evaluation.Project
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) -> Microsoft.Build.Construction.ProjectMetadataElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) -> Microsoft.Build.Evaluation.ProjectMetadata
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) -> Microsoft.Build.Construction.ProjectOnErrorElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) -> Microsoft.Build.Construction.ProjectOtherwiseElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) -> Microsoft.Build.Construction.ProjectOutputElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) -> Microsoft.Build.Construction.ProjectPropertyElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) -> Microsoft.Build.Construction.ProjectPropertyGroupElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectProperty
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) -> Microsoft.Build.Construction.ProjectSdkElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) -> Microsoft.Build.Construction.ProjectTargetElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) -> Microsoft.Build.Construction.ProjectTaskElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) -> Microsoft.Build.Construction.ProjectWhenElement
+Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
+Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink.ProjectChooseElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
+Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.ProjectElementContainerLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ProjectElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.ProjectExtensionsElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ProjectImportElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink.ProjectImportGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink.ProjectItemDefinitionElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink.ProjectItemDefinitionGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ProjectItemDefinitionLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ProjectItemElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink.ProjectItemGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectItemLink
+Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ProjectItemLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectLink
+Microsoft.Build.ObjectModelRemoting.ProjectLink.ProjectLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ProjectMetadataElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink
+Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.ProjectMetadataLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink.ProjectOnErrorElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink.ProjectOtherwiseElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink.ProjectOutputElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ProjectPropertyElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink.ProjectPropertyGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink
+Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.ProjectPropertyLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectRootElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink.ProjectSdkElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.ProjectTargetElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ProjectTaskElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.ProjectUsingTaskBodyElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink.ProjectUsingTaskElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.ProjectUsingTaskParameterElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink
+Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink.ProjectWhenElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink
+Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink.UsingTaskParameterGroupElementLink() -> void
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.LocalName.get -> string
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.NamespaceURI.get -> string
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.Value.get -> string
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink() -> void
+Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink(string localName, string value, string namespaceUri) -> void
+override Microsoft.Build.Construction.ElementLocation.Equals(object obj) -> bool
+override Microsoft.Build.Construction.ElementLocation.GetHashCode() -> int
+override Microsoft.Build.Construction.ElementLocation.ToString() -> string
+override Microsoft.Build.Construction.ProjectChooseElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectChooseElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectChooseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectExtensionsElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectExtensionsElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectItemElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectItemGroupElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectOtherwiseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectRootElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectRootElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectRootElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectTargetElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectTaskElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.get -> string
+override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.set -> void
+override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.get -> string
+override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.set -> void
+override Microsoft.Build.Construction.UsingTaskParameterGroupElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Exceptions.BuildAbortedException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Exceptions.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Exceptions.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Exceptions.InvalidProjectFileException.Message.get -> string
+override Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectItemInstance.ToString() -> string
+override Microsoft.Build.Execution.ProjectMetadataInstance.ToString() -> string
+override Microsoft.Build.Execution.ProjectOnErrorInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectOnErrorInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectOnErrorInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectPropertyInstance.ToString() -> string
+override Microsoft.Build.Execution.ProjectTaskInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Condition.get -> string
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
+override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+override Microsoft.Build.Logging.FileLogger.Shutdown() -> void
+static Microsoft.Build.Construction.ProjectRootElement.Create() -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Open(string path) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
+static Microsoft.Build.Construction.SolutionFile.Parse(string solutionFile) -> Microsoft.Build.Construction.SolutionFile
+static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) -> Microsoft.Build.Evaluation.Context.EvaluationContext
+static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) -> Microsoft.Build.Evaluation.Context.EvaluationContext
+static Microsoft.Build.Evaluation.Project.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
+static Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
+static Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
+static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) -> string
+static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) -> string
+static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) -> string
+static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) -> string
+static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) -> string
+static Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
+static Microsoft.Build.Evaluation.ProjectCollection.DisplayVersion.get -> string
+static Microsoft.Build.Evaluation.ProjectCollection.Escape(string unescapedString) -> string
+static Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
+static Microsoft.Build.Evaluation.ProjectCollection.Unescape(string escapedString) -> string
+static Microsoft.Build.Evaluation.ProjectCollection.Version.get -> System.Version
+static Microsoft.Build.Execution.BuildManager.DefaultBuildManager.get -> Microsoft.Build.Execution.BuildManager
+static Microsoft.Build.Execution.ProjectInstance.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
+static Microsoft.Build.Execution.ProjectInstance.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
+static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) -> string
+static Microsoft.Build.Execution.ProjectInstance.GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) -> string
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
+static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
+static Microsoft.Build.Globbing.MSBuildGlob.Parse(string globRoot, string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
+static Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) -> void
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Get(Microsoft.Build.Evaluation.ProjectCollection collection) -> Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLink(object obj) -> object
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project>
+static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.IsLocal(object obj) -> bool
+static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) -> Microsoft.Build.Construction.ElementLocation
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributes(Microsoft.Build.Construction.ProjectElement xml) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) -> string
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) -> bool
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetPureText(Microsoft.Build.Construction.ProjectElement xml) -> string
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) -> void
+static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> string
+static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> object
+static Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
+virtual Microsoft.Build.Construction.ProjectElement.Condition.get -> string
+virtual Microsoft.Build.Construction.ProjectElement.Condition.set -> void
+virtual Microsoft.Build.Construction.ProjectElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
+virtual Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
+virtual Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) -> void
+virtual Microsoft.Build.Evaluation.ProjectCollection.Dispose(bool disposing) -> void
+virtual Microsoft.Build.Execution.ProjectPropertyInstance.IsImmutable.get -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.DirectoryExists(string path) -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileExists(string path) -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileOrDirectoryExists(string path) -> bool
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetAttributes(string path) -> System.IO.FileAttributes
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetLastWriteTimeUtc(string path) -> System.DateTime
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFile(string path) -> System.IO.TextReader
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllBytes(string path) -> byte[]
+virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllText(string path) -> string
+virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
+virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
+virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..c095b7f8e50
--- /dev/null
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -0,0 +1,12 @@
+Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
+Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
+Microsoft.Build.FileSystem.FindPredicate
+Microsoft.Build.FileSystem.FindTransform<TResult>
+Microsoft.Build.FileSystem.IDirectoryCache
+Microsoft.Build.FileSystem.IDirectoryCache.DirectoryExists(string path) -> bool
+Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
+Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
+Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
+Microsoft.Build.FileSystem.IDirectoryCacheFactory
+Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
+static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
\ No newline at end of file
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index da8165d3369..180e3c29fda 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -6,16 +6,15 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Internal
 {
-    internal class EngineFileUtilities
+    internal static class EngineFileUtilities
     {
-        private readonly FileMatcher _fileMatcher;
-
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
         private static List<Regex> s_lazyWildCardExpansionRegexes;
@@ -34,13 +33,6 @@ internal static void CaptureLazyWildcardRegexes()
             s_lazyWildCardExpansionRegexes = PopulateRegexFromEnvironment();
         }
 
-        public static EngineFileUtilities Default = new EngineFileUtilities(FileMatcher.Default);
-
-        public EngineFileUtilities(FileMatcher fileMatcher)
-        {
-            _fileMatcher = fileMatcher;
-        }
-
         /// <summary>
         /// Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
         /// ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
@@ -54,14 +46,14 @@ public EngineFileUtilities(FileMatcher fileMatcher)
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <returns>Array of file paths, unescaped.</returns>
-        internal string[] GetFileListUnescaped
+        internal static string[] GetFileListUnescaped
             (
             string directoryEscaped,
             string filespecEscaped
             )
 
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false, excludeSpecsEscaped: null, fileMatcher: FileMatcher.Default);
         }
 
         /// <summary>
@@ -78,16 +70,18 @@ string filespecEscaped
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="excludeSpecsEscaped">Filespecs to exclude, escaped.</param>
         /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
+        /// <param name="fileMatcher"></param>
         /// <returns>Array of file paths, escaped.</returns>
-        internal string[] GetFileListEscaped
+        internal static string[] GetFileListEscaped
             (
             string directoryEscaped,
             string filespecEscaped,
             IEnumerable<string> excludeSpecsEscaped = null,
-            bool forceEvaluate = false
+            bool forceEvaluate = false,
+            FileMatcher fileMatcher = null
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped, fileMatcher ?? FileMatcher.Default);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
@@ -119,14 +113,16 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// <param name="returnEscaped"><code>true</code> to return escaped specs.</param>
         /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off</param>
         /// <param name="excludeSpecsEscaped">The exclude specification, escaped.</param>
+        /// <param name="fileMatcher"></param>
         /// <returns>Array of file paths.</returns>
-        private string[] GetFileList
+        private static string[] GetFileList
             (
             string directoryEscaped,
             string filespecEscaped,
             bool returnEscaped,
             bool forceEvaluateWildCards,
-            IEnumerable<string> excludeSpecsEscaped = null
+            IEnumerable<string> excludeSpecsEscaped,
+            FileMatcher fileMatcher
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
@@ -156,7 +152,7 @@ private string[] GetFileList
                 // as a relative path, we will get back a bunch of relative paths.
                 // If the filespec started out as an absolute path, we will get
                 // back a bunch of absolute paths.
-                fileList = _fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                fileList = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
                 ErrorUtilities.VerifyThrow(fileList != null, "We must have a list of files here, even if it's empty.");
 
@@ -241,18 +237,13 @@ internal static Func<string, bool> GetFileSpecMatchTester(IList<string> filespec
             return file => matchers.Any(m => m.Value.IsMatch(file));
         }
 
-        internal class IOCache
+        internal sealed class IOCache
         {
             private readonly Lazy<ConcurrentDictionary<string, bool>> existenceCache = new Lazy<ConcurrentDictionary<string, bool>>(() => new ConcurrentDictionary<string, bool>(), true);
 
-            public virtual bool DirectoryExists(string directory)
-            {
-                return existenceCache.Value.GetOrAdd(directory, Directory.Exists);
-            }
-
-            public virtual bool FileExists(string file)
+            public bool DirectoryExists(string directory)
             {
-                return existenceCache.Value.GetOrAdd(file, File.Exists);
+                return existenceCache.Value.GetOrAdd(directory, directory => Directory.Exists(directory));
             }
         }
     }
diff --git a/src/Build/Utilities/ImmutableCollectionsExtensions.cs b/src/Build/Utilities/ImmutableCollectionsExtensions.cs
new file mode 100644
index 00000000000..242c5248400
--- /dev/null
+++ b/src/Build/Utilities/ImmutableCollectionsExtensions.cs
@@ -0,0 +1,40 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Immutable;
+
+// Added to the System.Linq extension method as these extensions augment those
+// provided by Linq. The immutable collections library includes ImmutableArrayExtensions
+// which is also in this namespace.
+
+namespace System.Linq
+{
+    internal static class ImmutableCollectionsExtensions
+    {
+        /// <summary>
+        /// Gets a value indicating whether any elements are in this collection
+        /// that match a given condition.
+        /// </summary>
+        /// <remarks>
+        /// This extension method accepts an argument which is then passed, on the stack, to the predicate.
+        /// This allows using a static lambda, which can avoid a per-call allocation of a closure object.
+        /// </remarks>
+        /// <typeparam name="TElement">The type of element contained by the collection.</typeparam>
+        /// <typeparam name="TArg">The type of argument passed to <paramref name="predicate"/>.</typeparam>
+        /// <param name="immutableArray">The array to check.</param>
+        /// <param name="predicate">The predicate.</param>
+        /// <param name="arg">The argument to pass to <paramref name="predicate"/>.</param>
+        public static bool Any<TElement, TArg>(this ImmutableArray<TElement> immutableArray, Func<TElement, TArg, bool> predicate, TArg arg)
+        {
+            foreach (TElement element in immutableArray)
+            {
+                if (predicate(element, arg))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 3bb52fd3d73..a318ddb8117 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -4,6 +4,8 @@
 using System;
 using System.IO;
 using System.Reflection;
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj b/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj
index 3f67674e3f2..e40299d2289 100644
--- a/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj
+++ b/src/Deprecated/Conversion.UnitTests/XMakeConversionUnitTests.csproj
@@ -33,9 +33,6 @@
   </PropertyGroup>
   <ItemGroup>
     <!-- Source Files -->
-    <Compile Include="..\..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\..\shared\unittests\MockLogger.cs" />
     <Compile Include="..\..\shared\unittests\ObjectModelHelpers.cs" />
     <Compile Include="OldVSProjectFileReader_Tests.cs" />
diff --git a/src/Deprecated/Conversion/FxCopExclusions/Microsoft.Build.Conversion.Suppressions.cs b/src/Deprecated/Conversion/FxCopExclusions/Microsoft.Build.Conversion.Suppressions.cs
deleted file mode 100644
index 6fccf7578e9..00000000000
--- a/src/Deprecated/Conversion/FxCopExclusions/Microsoft.Build.Conversion.Suppressions.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-// FxCop Suppression file
-// To Use:
-// Add module level suppressions to this file to have them suppressed in the assembly
-//
-
-#if CODE_ANALYSIS
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="0", Scope="module", Target="microsoft.build.conversion.v12.0.dll", Justification="Already shipped for several versions with a name like this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="v", Justification="Spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="5", Justification="Spelled correctly")]
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames", Justification="We delay sign our assemblies.")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.Conversion", Justification="Microsoft.Build.Conversion is an approved namespace according to http://ddwww/apps/apiowners/")]
-#endif
-
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index 66d4a698bf3..57e9ef80921 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -15,7 +15,6 @@
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyResources.cs" />
     <Compile Include="Constants.cs" />
-    <Compile Include="FxCopExclusions\Microsoft.Build.Conversion.Suppressions.cs" />
     <Compile Include="OldVSProjectFileReader.cs" />
     <Compile Include="ProjectFileConverter.cs" />
 
diff --git a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt b/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..cc40354b757
--- /dev/null
+++ b/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt
@@ -0,0 +1,21 @@
+Microsoft.Build.Conversion.ProjectFileConverter
+Microsoft.Build.Conversion.ProjectFileConverter.ConversionSkippedBecauseProjectAlreadyConverted.get -> bool
+Microsoft.Build.Conversion.ProjectFileConverter.ConversionWarnings.get -> string[]
+Microsoft.Build.Conversion.ProjectFileConverter.Convert() -> void
+Microsoft.Build.Conversion.ProjectFileConverter.Convert(Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
+Microsoft.Build.Conversion.ProjectFileConverter.Convert(string msbuildBinPath) -> void
+Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory() -> Microsoft.Build.Construction.ProjectRootElement
+Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine) -> Microsoft.Build.BuildEngine.Project
+Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> Microsoft.Build.BuildEngine.Project
+Microsoft.Build.Conversion.ProjectFileConverter.FSharpSpecificConversions(bool actuallyMakeChanges) -> bool
+Microsoft.Build.Conversion.ProjectFileConverter.IsMinorUpgrade.get -> bool
+Microsoft.Build.Conversion.ProjectFileConverter.IsMinorUpgrade.set -> void
+Microsoft.Build.Conversion.ProjectFileConverter.IsUserFile.get -> bool
+Microsoft.Build.Conversion.ProjectFileConverter.IsUserFile.set -> void
+Microsoft.Build.Conversion.ProjectFileConverter.NewProjectFile.get -> string
+Microsoft.Build.Conversion.ProjectFileConverter.NewProjectFile.set -> void
+Microsoft.Build.Conversion.ProjectFileConverter.OldProjectFile.get -> string
+Microsoft.Build.Conversion.ProjectFileConverter.OldProjectFile.set -> void
+Microsoft.Build.Conversion.ProjectFileConverter.ProjectFileConverter() -> void
+Microsoft.Build.Conversion.ProjectFileConverter.SolutionFile.get -> string
+Microsoft.Build.Conversion.ProjectFileConverter.SolutionFile.set -> void
\ No newline at end of file
diff --git a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index 908d29e9aad..4d7552ed0fa 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -106,19 +106,6 @@ bool            importedFromAnotherProject
             this.taskName = taskElement.Name;
         }
 
-        /// <summary>
-        /// Default constructor.  This is not allowed, because it leaves the
-        /// BuildTask in a bad state. But we have to have it, otherwise FXCop
-        /// complains.
-        /// </summary>
-        /// <owner>rgoel</owner>
-        private BuildTask
-            (
-            )
-        {
-            // Not allowed.
-        }
-
         #endregion
 
         #region Properties
diff --git a/src/Deprecated/Engine/Engine/EventSource.cs b/src/Deprecated/Engine/Engine/EventSource.cs
index 99454be7fa2..b44d10aa901 100644
--- a/src/Deprecated/Engine/Engine/EventSource.cs
+++ b/src/Deprecated/Engine/Engine/EventSource.cs
@@ -520,43 +520,57 @@ internal void RaiseAnyEvent(object sender, BuildEventArgs e)
         }
 
         /// <summary>
-        /// Raises the given event to all registered loggers. This method up-cast the events
-        /// extracted from the queue.
+        /// Raises the given event to all registered loggers.
+        /// This method casts the events extracted from the queue to a more specific type.
         /// </summary>
         /// <param name="e"></param>
         internal void RaiseStronglyTypedEvent(BuildEventArgs e)
         {
-            // FXCop may complain that there are unecessary casts here, and there are, but
-            // using "as" and allocating another variable for each event is extremely costly
-            // and is much slower then this approach even with the additional casts
-            if (e is BuildMessageEventArgs)
-                this.RaiseMessageEvent(null, (BuildMessageEventArgs)e);
-            else if (e is TaskStartedEventArgs)
-                this.RaiseTaskStartedEvent(null, (TaskStartedEventArgs)e);
-            else if (e is TaskFinishedEventArgs)
-                this.RaiseTaskFinishedEvent(null, (TaskFinishedEventArgs)e);
-            else if (e is TargetStartedEventArgs)
-                this.RaiseTargetStartedEvent(null, (TargetStartedEventArgs)e);
-            else if (e is TargetFinishedEventArgs)
-                this.RaiseTargetFinishedEvent(null, (TargetFinishedEventArgs)e);
-            else if (e is ProjectStartedEventArgs)
-                this.RaiseProjectStartedEvent(null, (ProjectStartedEventArgs)e);
-            else if (e is ProjectFinishedEventArgs)
-                this.RaiseProjectFinishedEvent(null, (ProjectFinishedEventArgs)e);
-            else if (e is BuildStartedEventArgs)
-                this.RaiseBuildStartedEvent(null, (BuildStartedEventArgs)e);
-            else if (e is BuildFinishedEventArgs)
-                this.RaiseBuildFinishedEvent(null, (BuildFinishedEventArgs)e);
-            else if (e is CustomBuildEventArgs)
-                this.RaiseCustomEvent(null, (CustomBuildEventArgs)e);
-            else if (e is BuildStatusEventArgs)
-                this.RaiseStatusEvent(null, (BuildStatusEventArgs)e);
-            else if (e is BuildWarningEventArgs)
-                this.RaiseWarningEvent(null, (BuildWarningEventArgs)e);
-            else if (e is BuildErrorEventArgs)
-                this.RaiseErrorEvent(null, (BuildErrorEventArgs)e);
-            else
-                ErrorUtilities.VerifyThrow(false, "Unknown event args type.");
+            switch (e)
+            {
+                case BuildMessageEventArgs buildMessageEvent:
+                    RaiseMessageEvent(null, buildMessageEvent);
+                    break;
+                case TaskStartedEventArgs taskStartedEvent:
+                    RaiseTaskStartedEvent(null, taskStartedEvent);
+                    break;
+                case TaskFinishedEventArgs taskFinishedEvent:
+                    RaiseTaskFinishedEvent(null, taskFinishedEvent);
+                    break;
+                case TargetStartedEventArgs targetStartedEvent:
+                    RaiseTargetStartedEvent(null, targetStartedEvent);
+                    break;
+                case TargetFinishedEventArgs targetFinishedEvent:
+                    RaiseTargetFinishedEvent(null, targetFinishedEvent);
+                    break;
+                case ProjectStartedEventArgs projectStartedEvent:
+                    RaiseProjectStartedEvent(null, projectStartedEvent);
+                    break;
+                case ProjectFinishedEventArgs projectFinishedEvent:
+                    RaiseProjectFinishedEvent(null, projectFinishedEvent);
+                    break;
+                case BuildStartedEventArgs buildStartedEvent:
+                    RaiseBuildStartedEvent(null, buildStartedEvent);
+                    break;
+                case BuildFinishedEventArgs buildFinishedEvent:
+                    RaiseBuildFinishedEvent(null, buildFinishedEvent);
+                    break;
+                case CustomBuildEventArgs customBuildEvent:
+                    RaiseCustomEvent(null, customBuildEvent);
+                    break;
+                case BuildStatusEventArgs buildStatusEvent:
+                    RaiseStatusEvent(null, buildStatusEvent);
+                    break;
+                case BuildWarningEventArgs buildWarningEvent:
+                    RaiseWarningEvent(null, buildWarningEvent);
+                    break;
+                case BuildErrorEventArgs buildErrorEvent:
+                    RaiseErrorEvent(null, buildErrorEvent);
+                    break;
+                default:
+                    ErrorUtilities.VerifyThrow(false, "Unknown event args type.");
+                    break;
+            }
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/FxCopExclusions/Microsoft.Build.Engine.Suppressions.cs b/src/Deprecated/Engine/FxCopExclusions/Microsoft.Build.Engine.Suppressions.cs
deleted file mode 100644
index d811d37062d..00000000000
--- a/src/Deprecated/Engine/FxCopExclusions/Microsoft.Build.Engine.Suppressions.cs
+++ /dev/null
@@ -1,299 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-// FxCop Suppression file
-// To Use:
-// Add module level suppressions to this file to have them suppressed in the assembly
-//
-#if CODE_ANALYSIS
-using System.Diagnostics.CodeAnalysis;
-[module: SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Scope="member", Target="Microsoft.Build.BuildEngine.Shared.InternalErrorException..ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)", Justification="This is a shared class which is implementing the correct constructors, in this case the method is internal.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Scope="member", Target="Microsoft.Build.BuildEngine.BuildTask.Type", Justification="This method returns the object type of the task, however we need to do some work to actually get the object out to look at it, therefore a custom method is needed.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Engine.Resources.Strings.resources", MessageId="itemname", Justification="itemname is spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Engine.Resources.Strings.resources", MessageId="sln", Justification="sln is the extension for a solution")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.BuildEngine.Utilities.Escape(System.String):System.String", MessageId="unescaped", Justification="unescaped is spelled correctly and cased correctly")]
-[module: SuppressMessage("Microsoft.Performance", "CA1816:DisposeMethodsShouldCallSuppressFinalize", Scope="member", Target="Microsoft.Build.BuildEngine.SharedMemory.Dispose():System.Void", Justification="The methods is being called, fxcop is not picking it up for some reason")]
-[module: SuppressMessage("Microsoft.Design","CA1032:ImplementStandardExceptionConstructors",Justification="We require this constructor for serialization")]
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames", Justification="We delay sign our assemblies.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Scope="member", Target="Microsoft.Build.BuildEngine.Shared.NativeMethods.GetCurrentDirectory(System.Int32,System.Text.StringBuilder):System.Int32", Justification="Native call is used to GetCurrentDirectory for perf reasons")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Shared.FileUtilities.IsItemSpecModifier(System.String):System.Boolean", Justification="This is necessarily complex to give proven perf benefits.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Shared.FileUtilities.GetItemSpecModifier(System.String,System.String,System.String,System.Collections.Hashtable&):System.String")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.Shared.TypeLoader.Load(System.String,Microsoft.Build.BuildEngine.Shared.AssemblyLoadInfo):Microsoft.Build.BuildEngine.Shared.LoadedType", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We are deliberately calling LoadFrom, and we know what we're doing.")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.BuildEngine", Justification="Microsoft.Build.BuildEngine is an approved namespace according to http://ddwww/apps/apiowners/")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.TaskWorkerThread.NodeActionLoop(Microsoft.Build.BuildEngine.TaskWorkerThread+NodeLoopExecutionMode,System.Int32,Microsoft.Build.BuildEngine.BuildResult[]):System.Void", Justification="This is a very tight loop, extracting methods would introduce overhead which is detremental in this case")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Scanner.Advance():System.Boolean", Justification="I think this is most easily understandable as it is written.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.BuildEngine.ColorResetter", MessageId="Resetter", Justification="Resetter may not be a real word in the dictionary, but most people will figure out what it means and it's spelled correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.ImportCollection", Justification="We shouldn't implement generic interfaces in the engine only - we need to address this across the product if the team thinks its worth it.  I'll open a separate bug for that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", Scope="member", Target="Microsoft.Build.BuildEngine.InvalidProjectFileException..ctor(System.Xml.XmlNode,System.String,System.String,System.String,System.String)", MessageId="System.Xml.XmlNode", Justification="This is by design, we need specific functionality provided by XMLDoc/Node classes that is not exposed by IXPathNavigable.")]
-[module: SuppressMessage("Microsoft.Design", "CA1035:ICollectionImplementationsHaveStronglyTypedMembers", Scope="type", Target="Microsoft.Build.BuildEngine.BuildPropertyGroupCollection", Justification="The strongly typed version of CopyTo is provided, but has a different name to avoid problems with COM interop.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope="member", Target="Microsoft.Build.BuildEngine.ItemExpander.itemVectorWithoutSeparatorSpecification", Justification="These fields are actually used, but only to compose static constants, so they aren't visible in the assembly")]
-[module: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope="member", Target="Microsoft.Build.BuildEngine.ItemExpander.itemVectorWithTransformRHS", Justification="These fields are actually used, but only to compose static constants, so they aren't visible in the assembly")]
-[module: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope="member", Target="Microsoft.Build.BuildEngine.ItemExpander.itemVectorWithTransformLHS", Justification="These fields are actually used, but only to compose static constants, so they aren't visible in the assembly")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Introspector.DetectDeadlock(System.Int32,System.Int64,System.Int32):System.Int32", Justification="Ignore for now")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngine.ExecuteInstantiatedTask(Microsoft.Build.BuildEngine.EngineProxy,Microsoft.Build.BuildEngine.ItemBucket,Microsoft.Build.BuildEngine.TaskExecutionMode,Microsoft.Build.Framework.ITask,System.Boolean&):System.Boolean", Justification="General exception types caught as part of task plugin model")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngine.GatherTaskItemOutputs(Microsoft.Build.BuildEngine.Lookup,Microsoft.Build.BuildEngine.TaskOutput,System.String,System.String,System.Object):System.Void", Justification="According to the code author it is faster to use 'is' than 'as' here")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngine.InitializeTask(Microsoft.Build.Framework.ITask,Microsoft.Build.BuildEngine.ItemBucket,Microsoft.Build.BuildEngine.EngineProxy):System.Boolean", Justification="General exception types caught as part of task plugin model")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project,System.String[]):System.Boolean", Justification="IProjectCacheable is going away soon.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.EngineBuildLoop(Microsoft.Build.BuildEngine.BuildRequest):Microsoft.Build.BuildEngine.BuildResult", Justification="These are tight performance critical loops, additional method calls due to refactoring could have a performance impact")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project,System.String[],System.Collections.IDictionary,Microsoft.Build.BuildEngine.BuildSettings):System.Boolean", Justification="IProjectCacheable is going away soon.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.UnregisterLoggersInternal(System.Collections.ArrayList):System.Void", Justification="Used to catch all exceptions related to logger initialization so they can be handled correctly. ")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.RegisterLogger(Microsoft.Build.Framework.ILogger):System.Void", Justification="We do rethrow the exception, we just wrap it in a known exception so we know where it came from.")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project):System.Boolean", Justification="IProjectCacheable is going away soon.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.RegisterLoggerInternal(Microsoft.Build.Framework.ILogger,Microsoft.Build.BuildEngine.EventSource,System.Boolean):System.Void", Justification="an is, is being used to determine which type of logger is being use, it is faster to do an is then a single usage of the correct type rather than an as")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.RegisterLoggerInternal(Microsoft.Build.Framework.ILogger,Microsoft.Build.BuildEngine.EventSource,System.Boolean):System.Void", Justification="Used to catch all exceptions related to logger initialization so they can be handled correctly. ")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.RegisterDistributedLogger(Microsoft.Build.Framework.ILogger,Microsoft.Build.BuildEngine.LoggerDescription):System.Void", Justification="Used to catch all exceptions related to logger initialization so they can be handled correctly. ")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.UnregisterAllLoggers():System.Void", Justification="We do rethrow the exception, we just wrap it in a known exception so we know where it came from.")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project,System.String[],System.Collections.IDictionary):System.Boolean", Justification="I don't think so.  IProjectCacheable is an internal-only interface, and Engine.BuildProject is public.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.SolutionWrapperProject.AddPropertyGroupForAspNetConfiguration(Microsoft.Build.BuildEngine.Project,Microsoft.Build.BuildEngine.Shared.ProjectInSolution,System.String,Microsoft.Build.BuildEngine.Shared.AspNetCompilerParameters,System.String):System.Void", Justification="We do rethrow the exception as part of the call to ExceptionHandling.RethrowUnlessFileIO")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.SolutionWrapperProject.ScanProjectDependencies(Microsoft.Build.BuildEngine.Shared.SolutionParser,Microsoft.Build.BuildEngine.Engine,System.String,Microsoft.Build.Framework.BuildEventContext):System.Void", Justification="We don't want any problems scanning the project file to result in aborting the build.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.SolutionWrapperProject.AddTargetForWebProject(Microsoft.Build.BuildEngine.Project,Microsoft.Build.BuildEngine.Shared.SolutionParser,Microsoft.Build.BuildEngine.Shared.ProjectInSolution,System.String):System.Void", Justification="[lukaszg] A helper method rethrows the exception but FXCop cannot see that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.SolutionWrapperProject.AddTargetForVCProject(Microsoft.Build.BuildEngine.Project,Microsoft.Build.BuildEngine.Shared.SolutionParser,Microsoft.Build.BuildEngine.Shared.ProjectInSolution,System.String):System.Void", Justification="[lukaszg] A helper method rethrows the exception but FXCop cannot see that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseBuildStartedEvent(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTaskFinishedEvent(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseProjectFinishedEvent(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseMessageEvent(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseStronglyTypedEvent(Microsoft.Build.Framework.BuildEventArgs):System.Void", Justification="for performance reasons is is used rather than an as")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseWarningEvent(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTargetStartedEvent(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseProjectStartedEvent(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTargetFinishedEvent(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseBuildFinishedEvent(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseAnyEvent(System.Object,Microsoft.Build.Framework.BuildEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTaskStartedEvent(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseCustomEvent(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseErrorEvent(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseStatusEvent(System.Object,Microsoft.Build.Framework.BuildStatusEventArgs):System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.InternalLoggerException.SetDefaultsBeforeSerialization(System.Runtime.Serialization.StreamingContext):System.Void", MessageId="sc", Justification="Using the before serialization to set defaults. Am not using the serialization Context")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.InternalLoggerException.SetValueAfterDeserialization(System.Runtime.Serialization.StreamingContext):System.Void", MessageId="sx", Justification="Serialization context is not used but is required for method signature")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeCallback.SharedMemoryWriterThread():System.Void", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeCallback.PostMessageToParent(Microsoft.Build.BuildEngine.LocalCallDescriptor,System.Boolean):System.Void", Justification="Catch all exceptions so that they can be sent back to the parent")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.BuildItemGroup", Justification="We shouldn't implement generic interfaces in the engine only - we need to address this across the product if the team thinks its worth it.  I'll open a separate bug for that.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Scope="type", Target="Microsoft.Build.BuildEngine.BuildItemGroup", Justification="This class represents the <ItemGroup> element in the XMake project file, so the name is appropriate.  We also have a class that represents a collection of these things, and we wouldn't want to call that class BuildItemCollectionCollection.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ApplyParameter(System.String,System.String):System.Void", MessageId="parameterValue", Justification="Would be a breaking change to fix this now (on a public method) and it's not worth the risk.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.MessageHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs):System.Void", Justification="No, this makes no sense.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs):System.Void", Justification="No, this makes no sense.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ErrorHandler(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.WarningHandler(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs):System.Void", Justification="Reviewed these.  They are public by design so that the HostLogger can call them.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.GroupingCollection.InsertAfter(Microsoft.Build.BuildEngine.IItemPropertyGrouping,Microsoft.Build.BuildEngine.IItemPropertyGrouping):System.Void", Justification="I don't think fixing either of these is worth it.  In both cases, a series of run-time type checks are performed to properly identify an input's type.  To avoid the second cast (after the is check), we'd need to allocate local variables for each of the three possible types, and we'd only end up using one - I wouldn't be surprised if that in fact led to another FxCop violation.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.GroupingCollection.InsertAtEnd(Microsoft.Build.BuildEngine.IItemPropertyGrouping):System.Void", Justification="I don't think fixing either of these is worth it.  In both cases, a series of run-time type checks are performed to properly identify an input's type.  To avoid the second cast (after the is check), we'd need to allocate local variables for each of the three possible types, and we'd only end up using one - I wouldn't be surprised if that in fact led to another FxCop violation.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.ReportExceptionEngineCommand.Execute(Microsoft.Build.BuildEngine.Engine):System.Void", Justification="used to wrap communication errors")]
-[module: SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Project.Xml", MessageId="System.Xml.XmlNode", Justification="This is by design, we need specific functionality provided by XMLDoc/Node classes that is not exposed by IXPathNavigable.")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.NullCentralLogger.AnyEventRaisedHandler(System.Object,Microsoft.Build.Framework.BuildEventArgs):System.Void", Justification="These will only be called by the engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1035:ICollectionImplementationsHaveStronglyTypedMembers", Scope="type", Target="Microsoft.Build.BuildEngine.TargetCollection", Justification="The strongly typed version of CopyTo is provided, but has a different name to avoid problems with COM interop.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.PropertyCacheEntry.set_Value(System.String):System.Void", MessageId="value", Justification="value is proper name")]
-[module: SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Scope="type", Target="Microsoft.Build.BuildEngine.RemoteErrorException", Justification="This class is used to wrap remote exceptions, it is not to be instantiated by the public")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.LaunchNodeAndPostBuildRequest():System.Void", Justification="A helper method rethrows the exception, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.LaunchNodeAndPostBuildRequest():System.Void", Justification="used to wrap communication failures")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.RecordNodeResponse(System.Int32,Microsoft.Build.BuildEngine.Node+NodeShutdownLevel,System.Int32):System.Void", MessageId="totalTaskTime", Justification="Used for debugging purposes")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.SharedMemoryWriterThread():System.Void", Justification="The exception will be rethrown as an inner exception")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.SharedMemoryReaderThread():System.Void", Justification="The exception will be rethrown as an inner exception")]
-[module: SuppressMessage("Microsoft.Performance", "CA1814:PreferJaggedArraysOverMultidimensional", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.InitializeNode(System.Int32):System.Void", MessageId="Body", Justification="We do not want to use jagged arrays as they are not cls compliant")]
-[module: SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Scope="type", Target="Microsoft.Build.BuildEngine.FileLogger", Justification="FileLogger implements the Shutdown method, which has the same purpose as Dispose. ")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.FileLogger.FileLoggerBuildFinished(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs):System.Void", Justification="These will only be called by the engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Scope="type", Target="Microsoft.Build.BuildEngine.LocalNode", Justification="We are already disposing of the shared memory within the reader method so that it is only disposed when it is finished being used")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.ReportFatalCommunicationError(System.Exception):System.Void", Justification="used to wrap communication errors")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.ShutdownHandler(System.Exception):System.Void", Justification=" Ignore exception because the error may have been caused by the parent failing in which case we want to avoid additional watson dialogs for each child node")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.SharedMemoryReaderThread():System.Void", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.StartLocalNodeServer(System.Int32):System.Void", MessageId="System.GC.Collect", Justification="We need to free resources when we know the resources are not going to be needed right away, in this case the node will be idling and does not need its resources")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.ShutdownNode(Microsoft.Build.BuildEngine.Node+NodeShutdownLevel,System.Boolean,System.Boolean):System.Void", Justification="Report all communications which do not involve loss of node to node communication")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.BuildEngine.SharedMemory.pageFileView", Justification="Used as an offset rather than a handle")]
-[module: SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", Scope="member", Target="Microsoft.Build.BuildEngine.SharedMemory.Dispose(System.Boolean):System.Void", MessageId="writeStream", Justification="the build writer when closed will close  its associated base stream")]
-[module: SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", Scope="member", Target="Microsoft.Build.BuildEngine.SharedMemory.Dispose(System.Boolean):System.Void", MessageId="readStream", Justification="BuildReader will close its base stream when closed")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostStatus(Microsoft.Build.BuildEngine.NodeStatus,System.Boolean):System.Void", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.Node.UpdateNodeSettings(System.Boolean,System.Boolean,System.Boolean):System.Void", MessageId="useBreadthFirstTraversal", Justification="Used to set bool field, variable is not used for any other reason")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.ReportUnhandledError(System.Exception):System.Void", Justification="used to wrap communication errors")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostBuildResultToHost(Microsoft.Build.BuildEngine.BuildResult):System.Void", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostBuildResult(Microsoft.Build.BuildEngine.BuildResult):System.Void", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostLoggingMessagesToHost(Microsoft.Build.BuildEngine.NodeLoggingEvent[]):System.Void", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.GetCachedEntriesFromHost(System.String[],System.String,Microsoft.Build.BuildEngine.BuildPropertyGroup,System.String,Microsoft.Build.BuildEngine.CacheContentType):Microsoft.Build.BuildEngine.CacheEntry[]", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.NodeLocalEngineLoop():System.Void", Justification="We actually rethrow the exception but FXCop doesn't detect that")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostBuildRequestToHost(Microsoft.Build.BuildEngine.BuildRequest):System.Void", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostCacheEntriesToHost(Microsoft.Build.BuildEngine.CacheEntry[],System.String,Microsoft.Build.BuildEngine.BuildPropertyGroup,System.String,Microsoft.Build.BuildEngine.CacheContentType):System.Exception", Justification="Used to catch all exceptions at different points on child engines so they can be forwarded to the parent engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.Target", Justification="We shouldn't implement generic interfaces in the engine only - we need to address this across the product if the team thinks its worth it.  I'll open a separate bug for that.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Scope="type", Target="Microsoft.Build.BuildEngine.Target", Justification="This doesn't make sense for us. It is better for it to map to the name of the element in our XML file format. ")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.BuildEngine.Utilities.Escape(System.String):System.String", MessageId="0#unescaped", Justification="unescaped is spelled correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.BuildPropertyGroup", Justification="We shouldn't implement generic interfaces in the engine only - we need to address this across the product if the team thinks its worth it.  I'll open a separate bug for that.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Scope="type", Target="Microsoft.Build.BuildEngine.BuildPropertyGroup", Justification="This class represents the <PropertyGroup> element in the XMake project file, so the name is appropriate.  We also have a class that represents a collection of these things, and we wouldn't want to call that class BuildPropertyCollectionCollection.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngineAssemblyResolver.ResolveAssembly(System.Object,System.ResolveEventArgs):System.Reflection.Assembly", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We need to call Assembly.LoadFrom, it's by design. It's an optional way to load task assemblies.")]
-[module: SuppressMessage("Microsoft.Design", "CA1035:ICollectionImplementationsHaveStronglyTypedMembers", Scope="type", Target="Microsoft.Build.BuildEngine.BuildItemGroupCollection", Justification="The strongly typed version of CopyTo is provided, but has a different name to avoid problems with COM interop.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.ExpressionShredder.GetReferencedItemNamesAndMetadata(System.String,System.Int32,System.Int32,Microsoft.Build.BuildEngine.ItemsAndMetadataPair&,Microsoft.Build.BuildEngine.ShredderOptions):System.Void", Justification="Any simpler and the readability would suffer, I think")]
-[module: SuppressMessage("Microsoft.Performance", "CA1802:UseLiteralsWhereAppropriate", Scope="member", Target="Microsoft.Build.BuildEngine.NativeMethods.NullPtr", Justification="Cannot declare IntPtr as const must be static readonly")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildRequest(System.Int32,Microsoft.Build.BuildEngine.BuildRequest,System.Int32):System.Void", MessageId="currentRequest", Justification="Parameters are used to document API")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildRequest(System.Int32,Microsoft.Build.BuildEngine.BuildRequest,System.Int32):System.Void", MessageId="parentHandleId", Justification="Parameters are used to document API")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildRequest(System.Int32,Microsoft.Build.BuildEngine.BuildRequest,System.Int32):System.Void", MessageId="nodeIndex", Justification="Parameters are used to document API")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildResult(System.Int32,Microsoft.Build.BuildEngine.BuildResult):System.Void", MessageId="nodeId", Justification="Parameters are used to document API")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.XmlSearcher.GetElementAndAttributeNumber(System.Xml.XmlNode,System.Int32&,System.Int32&):System.Boolean", Justification="Again, code readability would degrade too much to save a single cast within this method.")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.UsingTaskCollection", Justification="We shouldn't implement generic interfaces in the engine only - we need to address this across the product if the team thinks its worth it.  I'll open a separate bug for that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.BuildRequest..ctor(System.Int32,System.String,System.String[],System.Collections.IDictionary,System.String,System.Int32,System.Boolean,System.Boolean)", Justification="For performance reasons  and is and cast is faster than an  as")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.TaskExecutionContext.SetTaskOutputs(System.Boolean,System.Exception,System.Int64):System.Void", MessageId="taskExecutedSuccessfully", Justification="These are used to set the fields in TaskExecutionContext, the variable names are important in describing what they are setting. There is no other code in the SetOutPuts so the variables cannot be confused for local ones - vladf")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.TaskExecutionContext.SetTaskOutputs(System.Boolean,System.Exception,System.Int64):System.Void", MessageId="thrownException", Justification="These are used to set the fields in TaskExecutionContext, the variable names are important in describing what they are setting. There is no other code in the SetOutPuts so the variables cannot be confused for local ones - vladf")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Engine.Resources.Strings.resources", MessageId="precompilation", Justification="precompilation is correctly spelled.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Engine.Resources.Strings.resources", MessageId="devenv", Justification="devenv is correctly spelled.")]
-
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.BuildEngine")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.TaskWorkerThread.NodeActionLoop(Microsoft.Build.BuildEngine.TaskWorkerThread+NodeLoopExecutionMode,System.Int32,Microsoft.Build.BuildEngine.BuildResult[]):System.Void")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Scanner.Advance():System.Boolean")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.BuildEngine.ColorResetter", MessageId="Resetter")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.ImportCollection")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", Scope="member", Target="Microsoft.Build.BuildEngine.InvalidProjectFileException..ctor(System.Xml.XmlNode,System.String,System.String,System.String,System.String)", MessageId="System.Xml.XmlNode")]
-[module: SuppressMessage("Microsoft.Design", "CA1035:ICollectionImplementationsHaveStronglyTypedMembers", Scope="type", Target="Microsoft.Build.BuildEngine.BuildPropertyGroupCollection")]
-[module: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope="member", Target="Microsoft.Build.BuildEngine.ItemExpander.itemVectorWithoutSeparatorSpecification")]
-[module: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope="member", Target="Microsoft.Build.BuildEngine.ItemExpander.itemVectorWithTransformRHS")]
-[module: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope="member", Target="Microsoft.Build.BuildEngine.ItemExpander.itemVectorWithTransformLHS")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Introspector.SystemShutdown():System.Void", MessageId="Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Object[])")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Introspector.DetectDeadlock(System.Int32,System.Int64,System.Int32):System.Int32")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngine.ExecuteInstantiatedTask(Microsoft.Build.BuildEngine.EngineProxy,Microsoft.Build.BuildEngine.ItemBucket,Microsoft.Build.BuildEngine.TaskExecutionMode,Microsoft.Build.Framework.ITask,System.Boolean&):System.Boolean")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngine.GatherTaskItemOutputs(Microsoft.Build.BuildEngine.Lookup,Microsoft.Build.BuildEngine.TaskOutput,System.String,System.String,System.Object):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngine.InitializeTask(Microsoft.Build.Framework.ITask,Microsoft.Build.BuildEngine.ItemBucket,Microsoft.Build.BuildEngine.EngineProxy):System.Boolean")]
-[module: SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Scope="type", Target="Microsoft.Build.BuildEngine.Engine")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project,System.String[]):System.Boolean")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.EngineBuildLoop(Microsoft.Build.BuildEngine.BuildRequest):Microsoft.Build.BuildEngine.BuildResult")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project,System.String[],System.Collections.IDictionary,Microsoft.Build.BuildEngine.BuildSettings):System.Boolean")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.RegisterLogger(Microsoft.Build.Framework.ILogger):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project):System.Boolean")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project,System.String[],System.Collections.IDictionary):System.Boolean")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.RegisterDistributedLogger(Microsoft.Build.Framework.ILogger,Microsoft.Build.BuildEngine.LoggerDescription):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Engine.UnregisterAllLoggers():System.Void")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.SerialConsoleLogger.VerifyStack(System.Boolean,System.String,System.Object[]):System.Void", MessageId="Microsoft.Build.Framework.BuildErrorEventArgs.#ctor(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.String)")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.SerialConsoleLogger.VerifyStack(System.Boolean,System.String,System.Object[]):System.Void", MessageId="Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Object[])")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseBuildStartedEvent(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTaskFinishedEvent(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseProjectFinishedEvent(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseMessageEvent(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseStronglyTypedEvent(Microsoft.Build.Framework.BuildEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseWarningEvent(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTargetStartedEvent(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseProjectStartedEvent(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTargetFinishedEvent(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseBuildFinishedEvent(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseAnyEvent(System.Object,Microsoft.Build.Framework.BuildEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseTaskStartedEvent(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseCustomEvent(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseErrorEvent(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.EventSource.RaiseStatusEvent(System.Object,Microsoft.Build.Framework.BuildStatusEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext):System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.InternalLoggerException.SetDefaultsBeforeSerialization(System.Runtime.Serialization.StreamingContext):System.Void", MessageId="sc")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.InternalLoggerException.SetValueAfterDeserialization(System.Runtime.Serialization.StreamingContext):System.Void", MessageId="sx")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.CopyOnWriteHashtable..ctor(System.Collections.IDictionary,System.StringComparer)", MessageId="Microsoft.Build.Shared.InternalErrorException.#ctor(System.String,System.Boolean)")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.CopyOnWriteHashtable..ctor(System.Collections.IDictionary,System.StringComparer)", MessageId="Microsoft.Build.Shared.ErrorUtilities.ThrowInternalError(System.String,System.Object[])")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeCallback.SharedMemoryWriterThread():System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeCallback.PostMessageToParent(Microsoft.Build.BuildEngine.LocalCallDescriptor,System.Boolean):System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.BuildItem.BuildItemHelper(System.Xml.XmlDocument,System.String,System.String,System.Boolean,Microsoft.Build.BuildEngine.ItemDefinitionLibrary):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.BuildItemGroup")]
-[module: SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Scope="type", Target="Microsoft.Build.BuildEngine.BuildItemGroup")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ProjectStartedHandler(System.Object,Microsoft.Build.Framework.ProjectStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ProjectFinishedHandler(System.Object,Microsoft.Build.Framework.ProjectFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ApplyParameter(System.String,System.String):System.Void", MessageId="parameterValue")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.MessageHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.MessageHandler(System.Object,Microsoft.Build.Framework.BuildMessageEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TaskStartedHandler(System.Object,Microsoft.Build.Framework.TaskStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TaskFinishedHandler(System.Object,Microsoft.Build.Framework.TaskFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TargetFinishedHandler(System.Object,Microsoft.Build.Framework.TargetFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(System.Object,Microsoft.Build.Framework.BuildStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(System.Object,Microsoft.Build.Framework.CustomBuildEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.TargetStartedHandler(System.Object,Microsoft.Build.Framework.TargetStartedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.BuildFinishedHandler(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.ErrorHandler(System.Object,Microsoft.Build.Framework.BuildErrorEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.ConsoleLogger.WarningHandler(System.Object,Microsoft.Build.Framework.BuildWarningEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.GroupingCollection.InsertAfter(Microsoft.Build.BuildEngine.IItemPropertyGrouping,Microsoft.Build.BuildEngine.IItemPropertyGrouping):System.Void")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.GroupingCollection.InsertAtEnd(Microsoft.Build.BuildEngine.IItemPropertyGrouping):System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.EngineProxy.GetUpdatedMessage(System.String,System.String,System.String):System.String", MessageId="parentProjectFullFileName")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.EngineProxy.GetUpdatedMessage(System.String,System.String,System.String):System.String", MessageId="file")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.EngineProxy.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.ReportExceptionEngineCommand.Execute(Microsoft.Build.BuildEngine.Engine):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Project.Xml", MessageId="System.Xml.XmlNode")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope="member", Target="Microsoft.Build.BuildEngine.Project.get_Xml():System.String")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.NullCentralLogger.AnyEventRaisedHandler(System.Object,Microsoft.Build.Framework.BuildEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.NullCentralLogger.Initialize(Microsoft.Build.Framework.IEventSource,System.Int32):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1035:ICollectionImplementationsHaveStronglyTypedMembers", Scope="type", Target="Microsoft.Build.BuildEngine.TargetCollection")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.PropertyCacheEntry.set_Value(System.String):System.Void", MessageId="value")]
-[module: SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Scope="type", Target="Microsoft.Build.BuildEngine.RemoteErrorException")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.RemoteErrorException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext):System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.RecordNodeResponse(System.Int32,Microsoft.Build.BuildEngine.Node+NodeShutdownLevel,System.Int32):System.Void", MessageId="totalTaskTime")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.LaunchNode(System.Int32):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.SharedMemoryWriterThread():System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.SharedMemoryReaderThread():System.Void")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.ReportNodeCommunicationFailure(System.Int32,System.Exception,System.Boolean):System.Void", MessageId="System.Exception.#ctor(System.String,System.Exception)")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.Initialize(System.String,Microsoft.Build.BuildEngine.IEngineCallback,Microsoft.Build.BuildEngine.BuildPropertyGroup,Microsoft.Build.BuildEngine.ToolsetDefinitionLocations,System.String):System.Void", MessageId="startupDirectory")]
-[module: SuppressMessage("Microsoft.Performance", "CA1814:PreferJaggedArraysOverMultidimensional", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.InitializeNode(System.Int32):System.Void", MessageId="Body")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.LaunchNodeAndPostBuildRequest():System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNodeProvider.LaunchNodeAndPostBuildRequest():System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Scope="type", Target="Microsoft.Build.BuildEngine.FileLogger")]
-[module: SuppressMessage("Microsoft.Performance", "CA1807:AvoidUnnecessaryStringCreation", Scope="member", Target="Microsoft.Build.BuildEngine.FileLogger.ApplyFileLoggerParameter(System.String,System.String):System.Void", MessageId="parameterName")]
-[module: SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope="member", Target="Microsoft.Build.BuildEngine.FileLogger.FileLoggerBuildFinished(System.Object,Microsoft.Build.Framework.BuildFinishedEventArgs):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Scope="type", Target="Microsoft.Build.BuildEngine.LocalNode")]
-[module: SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode..cctor()")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.ShutdownNode(Microsoft.Build.BuildEngine.Node+NodeShutdownLevel,System.Boolean,System.Boolean):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.SharedMemoryReaderThread():System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.ReportFatalCommunicationError(System.Exception):System.Void")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.StartLocalNodeServer(System.Int32):System.Void", MessageId="System.GC.Collect")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope="member", Target="Microsoft.Build.BuildEngine.LocalNode.StartLocalNodeServer(System.Int32):System.Void")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.BuildEngine.SharedMemory.pageFileView")]
-[module: SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", Scope="member", Target="Microsoft.Build.BuildEngine.SharedMemory.Dispose(System.Boolean):System.Void", MessageId="writeStream")]
-[module: SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", Scope="member", Target="Microsoft.Build.BuildEngine.SharedMemory.Dispose(System.Boolean):System.Void", MessageId="readStream")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostStatus(Microsoft.Build.BuildEngine.NodeStatus,System.Boolean):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.ReportUnhandledError(System.Exception):System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.ReportUnhandledError(System.Exception):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostBuildResultToHost(Microsoft.Build.BuildEngine.BuildResult):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostLoggingMessagesToHost(Microsoft.Build.BuildEngine.NodeLoggingEvent[]):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.GetCachedEntriesFromHost(System.String[],System.String,Microsoft.Build.BuildEngine.BuildPropertyGroup,System.String,Microsoft.Build.BuildEngine.CacheContentType):Microsoft.Build.BuildEngine.CacheEntry[]")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.NodeLocalEngineLoop():System.Void")]
-[module: SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.ReportFatalCommunicationError(System.Exception,System.IO.TextWriter):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostBuildResult(Microsoft.Build.BuildEngine.BuildResult):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostBuildRequestToHost(Microsoft.Build.BuildEngine.BuildRequest):System.Void")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.BuildEngine.Node.PostCacheEntriesToHost(Microsoft.Build.BuildEngine.CacheEntry[],System.String,Microsoft.Build.BuildEngine.BuildPropertyGroup,System.String,Microsoft.Build.BuildEngine.CacheContentType):System.Exception")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.Target")]
-[module: SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Scope="type", Target="Microsoft.Build.BuildEngine.Target")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.BaseConsoleLogger+ITaskItemItemSpecComparer.Compare(System.Object,System.Object):System.Int32")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.ItemBucket.CompareTo(System.Object):System.Int32")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.BuildEngine.Utilities.Escape(System.String):System.String", MessageId="0#unescaped")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.BuildPropertyGroup")]
-[module: SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Scope="type", Target="Microsoft.Build.BuildEngine.BuildPropertyGroup")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.BuildPropertyGroup.set_Item(System.String,Microsoft.Build.BuildEngine.BuildProperty):System.Void")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.TaskEngineAssemblyResolver.ResolveAssembly(System.Object,System.ResolveEventArgs):System.Reflection.Assembly", MessageId="System.Reflection.Assembly.LoadFrom")]
-[module: SuppressMessage("Microsoft.Design", "CA1035:ICollectionImplementationsHaveStronglyTypedMembers", Scope="type", Target="Microsoft.Build.BuildEngine.BuildItemGroupCollection")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.BuildEngine.ExpressionShredder.GetReferencedItemNamesAndMetadata(System.String,System.Int32,System.Int32,Microsoft.Build.BuildEngine.ItemsAndMetadataPair&,Microsoft.Build.BuildEngine.ShredderOptions):System.Void")]
-[module: SuppressMessage("Microsoft.Performance", "CA1802:UseLiteralsWhereAppropriate", Scope="member", Target="Microsoft.Build.BuildEngine.NativeMethods.NullPtr")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildRequest(System.Int32,Microsoft.Build.BuildEngine.BuildRequest,System.Int32):System.Void", MessageId="currentRequest")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildRequest(System.Int32,Microsoft.Build.BuildEngine.BuildRequest,System.Int32):System.Void", MessageId="parentHandleId")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildRequest(System.Int32,Microsoft.Build.BuildEngine.BuildRequest,System.Int32):System.Void", MessageId="nodeIndex")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.BuildEngine.Scheduler.NotifyOfBuildResult(System.Int32,Microsoft.Build.BuildEngine.BuildResult):System.Void", MessageId="nodeId")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope="member", Target="Microsoft.Build.BuildEngine.ProjectSchemaValidationHandler.VerifyProjectFileSchema(System.String,System.String):System.Void")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope="member", Target="Microsoft.Build.BuildEngine.ProjectSchemaValidationHandler.VerifyProjectSchema(System.String,System.String):System.Void")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.XmlSearcher.GetElementAndAttributeNumber(System.Xml.XmlNode,System.Int32&,System.Int32&):System.Boolean")]
-[module: SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope="type", Target="Microsoft.Build.BuildEngine.UsingTaskCollection")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.BuildEngine.BuildRequest..ctor(System.Int32,System.String,System.String[],System.Collections.IDictionary,System.String,System.Int32,System.Boolean,System.Boolean)")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.TaskExecutionContext.SetTaskOutputs(System.Boolean,System.Exception,System.Int64):System.Void", MessageId="taskExecutedSuccessfully")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", Scope="member", Target="Microsoft.Build.BuildEngine.TaskExecutionContext.SetTaskOutputs(System.Boolean,System.Exception,System.Int64):System.Void", MessageId="thrownException")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope="member", Target="Microsoft.Build.BuildEngine.BaseConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource):System.Void")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Engine.Resources.Strings.resources", MessageId="precompilation")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Engine.Resources.Strings.resources", MessageId="devenv")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="vcproj", Scope="resource", Target="Microsoft.Build.Engine.Resources.Strings.resources", Justification="vcproj is a file extension and is spelled correctly")]
-[module: SuppressMessage("Microsoft.Reliability","CA2001:AvoidCallingProblematicMethods", MessageId="System.Reflection.Assembly.LoadWithPartialName", Scope="member", Target="Microsoft.Build.BuildEngine.Expander+Function.#GetTypeFromAssembly(System.String,System.String)")]
-
-#endif
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index e6c767ac775..a8bfd10fa98 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -136,15 +136,7 @@ private void Write(string text)
         /// <owner>KieranMo</owner>
         public override void Shutdown()
         {
-            try
-            {
-                // Do, or do not, there is no try.
-            }
-            finally
-            {
-                // Keep FxCop happy by closing in a Finally.
-                fileWriter?.Close();
-            }
+            fileWriter?.Close();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index c409b5b1a14..909942a9425 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -126,7 +126,6 @@
     <Compile Include="Errors\InvalidToolsetDefinitionException.cs" />
     <Compile Include="Errors\RegistryException.cs" />
     <Compile Include="Errors\RemoteErrorException.cs" />
-    <Compile Include="FxCopExclusions\Microsoft.Build.Engine.Suppressions.cs" />
     <Compile Include="Introspector\Introspector.cs" />
     <Compile Include="Introspector\NodeStatus.cs" />
     <Compile Include="Introspector\TargetCycleDetector.cs" />
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index 5f09f69875c..6d1d947f2e5 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -344,19 +344,6 @@ string propertyValue
         {
         }
 
-        /// <summary>
-        /// Default constructor.  This is not allowed because it leaves the
-        /// property in a bad state -- without a name or value.  But we have to
-        /// have it, otherwise FXCop complains.
-        /// </summary>
-        /// <owner>sumedhk</owner>
-        private BuildProperty
-            (
-            )
-        {
-            // not allowed.
-        }
-
         #endregion
 
         #region Properties
diff --git a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt b/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..7abb6ba25e8
--- /dev/null
+++ b/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt
@@ -0,0 +1,419 @@
+Microsoft.Build.BuildEngine.BuildItem
+Microsoft.Build.BuildEngine.BuildItem.BuildItem(string itemName, Microsoft.Build.Framework.ITaskItem taskItem) -> void
+Microsoft.Build.BuildEngine.BuildItem.BuildItem(string itemName, string itemInclude) -> void
+Microsoft.Build.BuildEngine.BuildItem.Clone() -> Microsoft.Build.BuildEngine.BuildItem
+Microsoft.Build.BuildEngine.BuildItem.Condition.get -> string
+Microsoft.Build.BuildEngine.BuildItem.Condition.set -> void
+Microsoft.Build.BuildEngine.BuildItem.CopyCustomMetadataTo(Microsoft.Build.BuildEngine.BuildItem destinationItem) -> void
+Microsoft.Build.BuildEngine.BuildItem.CustomMetadataCount.get -> int
+Microsoft.Build.BuildEngine.BuildItem.CustomMetadataNames.get -> System.Collections.ICollection
+Microsoft.Build.BuildEngine.BuildItem.Exclude.get -> string
+Microsoft.Build.BuildEngine.BuildItem.Exclude.set -> void
+Microsoft.Build.BuildEngine.BuildItem.FinalItemSpec.get -> string
+Microsoft.Build.BuildEngine.BuildItem.GetEvaluatedMetadata(string metadataName) -> string
+Microsoft.Build.BuildEngine.BuildItem.GetMetadata(string metadataName) -> string
+Microsoft.Build.BuildEngine.BuildItem.HasMetadata(string metadataName) -> bool
+Microsoft.Build.BuildEngine.BuildItem.Include.get -> string
+Microsoft.Build.BuildEngine.BuildItem.Include.set -> void
+Microsoft.Build.BuildEngine.BuildItem.IsImported.get -> bool
+Microsoft.Build.BuildEngine.BuildItem.MetadataCount.get -> int
+Microsoft.Build.BuildEngine.BuildItem.MetadataNames.get -> System.Collections.ICollection
+Microsoft.Build.BuildEngine.BuildItem.Name.get -> string
+Microsoft.Build.BuildEngine.BuildItem.Name.set -> void
+Microsoft.Build.BuildEngine.BuildItem.RemoveMetadata(string metadataName) -> void
+Microsoft.Build.BuildEngine.BuildItem.SetMetadata(string metadataName, string metadataValue) -> void
+Microsoft.Build.BuildEngine.BuildItem.SetMetadata(string metadataName, string metadataValue, bool treatMetadataValueAsLiteral) -> void
+Microsoft.Build.BuildEngine.BuildItemGroup
+Microsoft.Build.BuildEngine.BuildItemGroup.AddNewItem(string itemName, string itemInclude) -> Microsoft.Build.BuildEngine.BuildItem
+Microsoft.Build.BuildEngine.BuildItemGroup.AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) -> Microsoft.Build.BuildEngine.BuildItem
+Microsoft.Build.BuildEngine.BuildItemGroup.BuildItemGroup() -> void
+Microsoft.Build.BuildEngine.BuildItemGroup.Clear() -> void
+Microsoft.Build.BuildEngine.BuildItemGroup.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildItemGroup
+Microsoft.Build.BuildEngine.BuildItemGroup.Condition.get -> string
+Microsoft.Build.BuildEngine.BuildItemGroup.Condition.set -> void
+Microsoft.Build.BuildEngine.BuildItemGroup.Count.get -> int
+Microsoft.Build.BuildEngine.BuildItemGroup.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.BuildItemGroup.IsImported.get -> bool
+Microsoft.Build.BuildEngine.BuildItemGroup.RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) -> void
+Microsoft.Build.BuildEngine.BuildItemGroup.RemoveItemAt(int index) -> void
+Microsoft.Build.BuildEngine.BuildItemGroup.this[int index].get -> Microsoft.Build.BuildEngine.BuildItem
+Microsoft.Build.BuildEngine.BuildItemGroup.ToArray() -> Microsoft.Build.BuildEngine.BuildItem[]
+Microsoft.Build.BuildEngine.BuildItemGroupCollection
+Microsoft.Build.BuildEngine.BuildItemGroupCollection.CopyTo(System.Array array, int index) -> void
+Microsoft.Build.BuildEngine.BuildItemGroupCollection.Count.get -> int
+Microsoft.Build.BuildEngine.BuildItemGroupCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.BuildItemGroupCollection.IsSynchronized.get -> bool
+Microsoft.Build.BuildEngine.BuildItemGroupCollection.SyncRoot.get -> object
+Microsoft.Build.BuildEngine.BuildProperty
+Microsoft.Build.BuildEngine.BuildProperty.BuildProperty(string propertyName, string propertyValue) -> void
+Microsoft.Build.BuildEngine.BuildProperty.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildProperty
+Microsoft.Build.BuildEngine.BuildProperty.Condition.get -> string
+Microsoft.Build.BuildEngine.BuildProperty.Condition.set -> void
+Microsoft.Build.BuildEngine.BuildProperty.FinalValue.get -> string
+Microsoft.Build.BuildEngine.BuildProperty.IsImported.get -> bool
+Microsoft.Build.BuildEngine.BuildProperty.Name.get -> string
+Microsoft.Build.BuildEngine.BuildProperty.Value.get -> string
+Microsoft.Build.BuildEngine.BuildProperty.Value.set -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup
+Microsoft.Build.BuildEngine.BuildPropertyGroup.AddNewProperty(string propertyName, string propertyValue) -> Microsoft.Build.BuildEngine.BuildProperty
+Microsoft.Build.BuildEngine.BuildPropertyGroup.AddNewProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) -> Microsoft.Build.BuildEngine.BuildProperty
+Microsoft.Build.BuildEngine.BuildPropertyGroup.BuildPropertyGroup() -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.BuildPropertyGroup(Microsoft.Build.BuildEngine.Project parentProject) -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.Clear() -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildPropertyGroup
+Microsoft.Build.BuildEngine.BuildPropertyGroup.Condition.get -> string
+Microsoft.Build.BuildEngine.BuildPropertyGroup.Condition.set -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.Count.get -> int
+Microsoft.Build.BuildEngine.BuildPropertyGroup.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.BuildPropertyGroup.IsImported.get -> bool
+Microsoft.Build.BuildEngine.BuildPropertyGroup.RemoveProperty(Microsoft.Build.BuildEngine.BuildProperty property) -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.RemoveProperty(string propertyName) -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.SetImportedPropertyGroupCondition(string condition) -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.SetProperty(string propertyName, string propertyValue) -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.SetProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroup.this[string propertyName].get -> Microsoft.Build.BuildEngine.BuildProperty
+Microsoft.Build.BuildEngine.BuildPropertyGroup.this[string propertyName].set -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroupCollection
+Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.CopyTo(System.Array array, int index) -> void
+Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.Count.get -> int
+Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.IsSynchronized.get -> bool
+Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.SyncRoot.get -> object
+Microsoft.Build.BuildEngine.BuildSettings
+Microsoft.Build.BuildEngine.BuildSettings.DoNotResetPreviouslyBuiltTargets = 1 -> Microsoft.Build.BuildEngine.BuildSettings
+Microsoft.Build.BuildEngine.BuildSettings.None = 0 -> Microsoft.Build.BuildEngine.BuildSettings
+Microsoft.Build.BuildEngine.BuildTask
+Microsoft.Build.BuildEngine.BuildTask.AddOutputItem(string taskParameter, string itemName) -> void
+Microsoft.Build.BuildEngine.BuildTask.AddOutputProperty(string taskParameter, string propertyName) -> void
+Microsoft.Build.BuildEngine.BuildTask.Condition.get -> string
+Microsoft.Build.BuildEngine.BuildTask.Condition.set -> void
+Microsoft.Build.BuildEngine.BuildTask.ContinueOnError.get -> bool
+Microsoft.Build.BuildEngine.BuildTask.ContinueOnError.set -> void
+Microsoft.Build.BuildEngine.BuildTask.Execute() -> bool
+Microsoft.Build.BuildEngine.BuildTask.GetParameterNames() -> string[]
+Microsoft.Build.BuildEngine.BuildTask.GetParameterValue(string attributeName) -> string
+Microsoft.Build.BuildEngine.BuildTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.BuildEngine.BuildTask.HostObject.set -> void
+Microsoft.Build.BuildEngine.BuildTask.Name.get -> string
+Microsoft.Build.BuildEngine.BuildTask.SetParameterValue(string parameterName, string parameterValue) -> void
+Microsoft.Build.BuildEngine.BuildTask.SetParameterValue(string parameterName, string parameterValue, bool treatParameterValueAsLiteral) -> void
+Microsoft.Build.BuildEngine.BuildTask.Type.get -> System.Type
+Microsoft.Build.BuildEngine.ColorResetter
+Microsoft.Build.BuildEngine.ColorSetter
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.NodeId.get -> int
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.NodeId.set -> void
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Parameters.get -> string
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Parameters.set -> void
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Verbosity.set -> void
+Microsoft.Build.BuildEngine.ConsoleLogger
+Microsoft.Build.BuildEngine.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger() -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.BuildEngine.WriteHandler write, Microsoft.Build.BuildEngine.ColorSetter colorSet, Microsoft.Build.BuildEngine.ColorResetter colorReset) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.Parameters.get -> string
+Microsoft.Build.BuildEngine.ConsoleLogger.Parameters.set -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.ShowSummary.get -> bool
+Microsoft.Build.BuildEngine.ConsoleLogger.ShowSummary.set -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.SkipProjectStartedText.get -> bool
+Microsoft.Build.BuildEngine.ConsoleLogger.SkipProjectStartedText.set -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.BuildEngine.ConsoleLogger.Verbosity.set -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
+Microsoft.Build.BuildEngine.ConsoleLogger.WriteHandler.get -> Microsoft.Build.BuildEngine.WriteHandler
+Microsoft.Build.BuildEngine.ConsoleLogger.WriteHandler.set -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger
+Microsoft.Build.BuildEngine.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.BuildEngine.DistributedFileLogger.BuildEventRedirector.set -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger.DistributedFileLogger() -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger.NodeId.get -> int
+Microsoft.Build.BuildEngine.DistributedFileLogger.NodeId.set -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger.Parameters.get -> string
+Microsoft.Build.BuildEngine.DistributedFileLogger.Parameters.set -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger.Shutdown() -> void
+Microsoft.Build.BuildEngine.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.BuildEngine.DistributedFileLogger.Verbosity.set -> void
+Microsoft.Build.BuildEngine.Engine
+Microsoft.Build.BuildEngine.Engine.BinPath.get -> string
+Microsoft.Build.BuildEngine.Engine.BinPath.set -> void
+Microsoft.Build.BuildEngine.Engine.BuildEnabled.get -> bool
+Microsoft.Build.BuildEngine.Engine.BuildEnabled.set -> void
+Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string targetName) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string targetName) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string toolsVersion) -> bool
+Microsoft.Build.BuildEngine.Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject, Microsoft.Build.BuildEngine.BuildPropertyGroup[] globalPropertiesPerProject, System.Collections.IDictionary[] targetOutputsPerProject, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string[] toolsVersions) -> bool
+Microsoft.Build.BuildEngine.Engine.CreateNewProject() -> Microsoft.Build.BuildEngine.Project
+Microsoft.Build.BuildEngine.Engine.DefaultToolsVersion.get -> string
+Microsoft.Build.BuildEngine.Engine.DefaultToolsVersion.set -> void
+Microsoft.Build.BuildEngine.Engine.Engine() -> void
+Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) -> void
+Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) -> void
+Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations, int numberOfCpus, string localNodeProviderParameters) -> void
+Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) -> void
+Microsoft.Build.BuildEngine.Engine.Engine(string binPath) -> void
+Microsoft.Build.BuildEngine.Engine.GetLoadedProject(string projectFullFileName) -> Microsoft.Build.BuildEngine.Project
+Microsoft.Build.BuildEngine.Engine.GlobalProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
+Microsoft.Build.BuildEngine.Engine.GlobalProperties.set -> void
+Microsoft.Build.BuildEngine.Engine.IsBuilding.get -> bool
+Microsoft.Build.BuildEngine.Engine.OnlyLogCriticalEvents.get -> bool
+Microsoft.Build.BuildEngine.Engine.OnlyLogCriticalEvents.set -> void
+Microsoft.Build.BuildEngine.Engine.RegisterDistributedLogger(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.BuildEngine.LoggerDescription forwardingLogger) -> void
+Microsoft.Build.BuildEngine.Engine.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
+Microsoft.Build.BuildEngine.Engine.Shutdown() -> void
+Microsoft.Build.BuildEngine.Engine.Toolsets.get -> Microsoft.Build.BuildEngine.ToolsetCollection
+Microsoft.Build.BuildEngine.Engine.UnloadAllProjects() -> void
+Microsoft.Build.BuildEngine.Engine.UnloadProject(Microsoft.Build.BuildEngine.Project project) -> void
+Microsoft.Build.BuildEngine.Engine.UnregisterAllLoggers() -> void
+Microsoft.Build.BuildEngine.FileLogger
+Microsoft.Build.BuildEngine.FileLogger.FileLogger() -> void
+Microsoft.Build.BuildEngine.Import
+Microsoft.Build.BuildEngine.Import.Condition.get -> string
+Microsoft.Build.BuildEngine.Import.Condition.set -> void
+Microsoft.Build.BuildEngine.Import.EvaluatedProjectPath.get -> string
+Microsoft.Build.BuildEngine.Import.IsImported.get -> bool
+Microsoft.Build.BuildEngine.Import.ProjectPath.get -> string
+Microsoft.Build.BuildEngine.Import.ProjectPath.set -> void
+Microsoft.Build.BuildEngine.ImportCollection
+Microsoft.Build.BuildEngine.ImportCollection.AddNewImport(string projectFile, string condition) -> void
+Microsoft.Build.BuildEngine.ImportCollection.CopyTo(Microsoft.Build.BuildEngine.Import[] array, int index) -> void
+Microsoft.Build.BuildEngine.ImportCollection.CopyTo(System.Array array, int index) -> void
+Microsoft.Build.BuildEngine.ImportCollection.Count.get -> int
+Microsoft.Build.BuildEngine.ImportCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.ImportCollection.IsSynchronized.get -> bool
+Microsoft.Build.BuildEngine.ImportCollection.RemoveImport(Microsoft.Build.BuildEngine.Import importToRemove) -> void
+Microsoft.Build.BuildEngine.ImportCollection.SyncRoot.get -> object
+Microsoft.Build.BuildEngine.InternalLoggerException
+Microsoft.Build.BuildEngine.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
+Microsoft.Build.BuildEngine.InternalLoggerException.ErrorCode.get -> string
+Microsoft.Build.BuildEngine.InternalLoggerException.HelpKeyword.get -> string
+Microsoft.Build.BuildEngine.InternalLoggerException.InitializationException.get -> bool
+Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException() -> void
+Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException(string message) -> void
+Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
+Microsoft.Build.BuildEngine.InvalidProjectFileException
+Microsoft.Build.BuildEngine.InvalidProjectFileException.BaseMessage.get -> string
+Microsoft.Build.BuildEngine.InvalidProjectFileException.ColumnNumber.get -> int
+Microsoft.Build.BuildEngine.InvalidProjectFileException.EndColumnNumber.get -> int
+Microsoft.Build.BuildEngine.InvalidProjectFileException.EndLineNumber.get -> int
+Microsoft.Build.BuildEngine.InvalidProjectFileException.ErrorCode.get -> string
+Microsoft.Build.BuildEngine.InvalidProjectFileException.ErrorSubcategory.get -> string
+Microsoft.Build.BuildEngine.InvalidProjectFileException.HelpKeyword.get -> string
+Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException() -> void
+Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
+Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
+Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
+Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(System.Xml.XmlNode xmlNode, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
+Microsoft.Build.BuildEngine.InvalidProjectFileException.LineNumber.get -> int
+Microsoft.Build.BuildEngine.InvalidProjectFileException.ProjectFile.get -> string
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.ErrorCode.get -> string
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
+Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.BuildEngine.LocalNode
+Microsoft.Build.BuildEngine.LoggerDescription
+Microsoft.Build.BuildEngine.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
+Microsoft.Build.BuildEngine.LoggerDescription.LoggerSwitchParameters.get -> string
+Microsoft.Build.BuildEngine.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.BuildEngine.Project
+Microsoft.Build.BuildEngine.Project.AddNewImport(string projectFile, string condition) -> void
+Microsoft.Build.BuildEngine.Project.AddNewItem(string itemName, string itemInclude) -> Microsoft.Build.BuildEngine.BuildItem
+Microsoft.Build.BuildEngine.Project.AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) -> Microsoft.Build.BuildEngine.BuildItem
+Microsoft.Build.BuildEngine.Project.AddNewItemGroup() -> Microsoft.Build.BuildEngine.BuildItemGroup
+Microsoft.Build.BuildEngine.Project.AddNewPropertyGroup(bool insertAtEndOfProject) -> Microsoft.Build.BuildEngine.BuildPropertyGroup
+Microsoft.Build.BuildEngine.Project.AddNewUsingTaskFromAssemblyFile(string taskName, string assemblyFile) -> void
+Microsoft.Build.BuildEngine.Project.AddNewUsingTaskFromAssemblyName(string taskName, string assemblyName) -> void
+Microsoft.Build.BuildEngine.Project.Build() -> bool
+Microsoft.Build.BuildEngine.Project.Build(string targetName) -> bool
+Microsoft.Build.BuildEngine.Project.Build(string[] targetNames) -> bool
+Microsoft.Build.BuildEngine.Project.Build(string[] targetNames, System.Collections.IDictionary targetOutputs) -> bool
+Microsoft.Build.BuildEngine.Project.Build(string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
+Microsoft.Build.BuildEngine.Project.BuildEnabled.get -> bool
+Microsoft.Build.BuildEngine.Project.BuildEnabled.set -> void
+Microsoft.Build.BuildEngine.Project.DefaultTargets.get -> string
+Microsoft.Build.BuildEngine.Project.DefaultTargets.set -> void
+Microsoft.Build.BuildEngine.Project.DefaultToolsVersion.get -> string
+Microsoft.Build.BuildEngine.Project.DefaultToolsVersion.set -> void
+Microsoft.Build.BuildEngine.Project.Encoding.get -> System.Text.Encoding
+Microsoft.Build.BuildEngine.Project.EvaluatedItems.get -> Microsoft.Build.BuildEngine.BuildItemGroup
+Microsoft.Build.BuildEngine.Project.EvaluatedItemsIgnoringCondition.get -> Microsoft.Build.BuildEngine.BuildItemGroup
+Microsoft.Build.BuildEngine.Project.EvaluatedProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
+Microsoft.Build.BuildEngine.Project.FullFileName.get -> string
+Microsoft.Build.BuildEngine.Project.FullFileName.set -> void
+Microsoft.Build.BuildEngine.Project.GetConditionedPropertyValues(string propertyName) -> string[]
+Microsoft.Build.BuildEngine.Project.GetEvaluatedItemsByName(string itemName) -> Microsoft.Build.BuildEngine.BuildItemGroup
+Microsoft.Build.BuildEngine.Project.GetEvaluatedItemsByNameIgnoringCondition(string itemName) -> Microsoft.Build.BuildEngine.BuildItemGroup
+Microsoft.Build.BuildEngine.Project.GetEvaluatedProperty(string propertyName) -> string
+Microsoft.Build.BuildEngine.Project.GetProjectExtensions(string id) -> string
+Microsoft.Build.BuildEngine.Project.GlobalProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
+Microsoft.Build.BuildEngine.Project.GlobalProperties.set -> void
+Microsoft.Build.BuildEngine.Project.HasToolsVersionAttribute.get -> bool
+Microsoft.Build.BuildEngine.Project.Imports.get -> Microsoft.Build.BuildEngine.ImportCollection
+Microsoft.Build.BuildEngine.Project.InitialTargets.get -> string
+Microsoft.Build.BuildEngine.Project.InitialTargets.set -> void
+Microsoft.Build.BuildEngine.Project.IsDirty.get -> bool
+Microsoft.Build.BuildEngine.Project.IsValidated.get -> bool
+Microsoft.Build.BuildEngine.Project.IsValidated.set -> void
+Microsoft.Build.BuildEngine.Project.ItemGroups.get -> Microsoft.Build.BuildEngine.BuildItemGroupCollection
+Microsoft.Build.BuildEngine.Project.Load(string projectFileName) -> void
+Microsoft.Build.BuildEngine.Project.Load(string projectFileName, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
+Microsoft.Build.BuildEngine.Project.Load(System.IO.TextReader textReader) -> void
+Microsoft.Build.BuildEngine.Project.Load(System.IO.TextReader textReader, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
+Microsoft.Build.BuildEngine.Project.LoadXml(string projectXml) -> void
+Microsoft.Build.BuildEngine.Project.LoadXml(string projectXml, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
+Microsoft.Build.BuildEngine.Project.MarkProjectAsDirty() -> void
+Microsoft.Build.BuildEngine.Project.ParentEngine.get -> Microsoft.Build.BuildEngine.Engine
+Microsoft.Build.BuildEngine.Project.Project() -> void
+Microsoft.Build.BuildEngine.Project.Project(Microsoft.Build.BuildEngine.Engine engine) -> void
+Microsoft.Build.BuildEngine.Project.Project(Microsoft.Build.BuildEngine.Engine engine, string toolsVersion) -> void
+Microsoft.Build.BuildEngine.Project.PropertyGroups.get -> Microsoft.Build.BuildEngine.BuildPropertyGroupCollection
+Microsoft.Build.BuildEngine.Project.RemoveAllItemGroups() -> void
+Microsoft.Build.BuildEngine.Project.RemoveAllPropertyGroups() -> void
+Microsoft.Build.BuildEngine.Project.RemoveImportedPropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) -> void
+Microsoft.Build.BuildEngine.Project.RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) -> void
+Microsoft.Build.BuildEngine.Project.RemoveItemGroup(Microsoft.Build.BuildEngine.BuildItemGroup itemGroupToRemove) -> void
+Microsoft.Build.BuildEngine.Project.RemoveItemGroupsWithMatchingCondition(string matchCondition) -> void
+Microsoft.Build.BuildEngine.Project.RemoveItemsByName(string itemName) -> void
+Microsoft.Build.BuildEngine.Project.RemovePropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) -> void
+Microsoft.Build.BuildEngine.Project.RemovePropertyGroupsWithMatchingCondition(string matchCondition) -> void
+Microsoft.Build.BuildEngine.Project.RemovePropertyGroupsWithMatchingCondition(string matchCondition, bool includeImportedPropertyGroups) -> void
+Microsoft.Build.BuildEngine.Project.ResetBuildStatus() -> void
+Microsoft.Build.BuildEngine.Project.Save(string projectFileName) -> void
+Microsoft.Build.BuildEngine.Project.Save(string projectFileName, System.Text.Encoding encoding) -> void
+Microsoft.Build.BuildEngine.Project.Save(System.IO.TextWriter textWriter) -> void
+Microsoft.Build.BuildEngine.Project.SchemaFile.get -> string
+Microsoft.Build.BuildEngine.Project.SchemaFile.set -> void
+Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position) -> void
+Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) -> void
+Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importProject) -> void
+Microsoft.Build.BuildEngine.Project.SetProjectExtensions(string id, string content) -> void
+Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue) -> void
+Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition) -> void
+Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position) -> void
+Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) -> void
+Microsoft.Build.BuildEngine.Project.Targets.get -> Microsoft.Build.BuildEngine.TargetCollection
+Microsoft.Build.BuildEngine.Project.TimeOfLastDirty.get -> System.DateTime
+Microsoft.Build.BuildEngine.Project.ToolsVersion.get -> string
+Microsoft.Build.BuildEngine.Project.UsingTasks.get -> Microsoft.Build.BuildEngine.UsingTaskCollection
+Microsoft.Build.BuildEngine.Project.Xml.get -> string
+Microsoft.Build.BuildEngine.ProjectLoadSettings
+Microsoft.Build.BuildEngine.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.BuildEngine.ProjectLoadSettings
+Microsoft.Build.BuildEngine.ProjectLoadSettings.None = 0 -> Microsoft.Build.BuildEngine.ProjectLoadSettings
+Microsoft.Build.BuildEngine.PropertyPosition
+Microsoft.Build.BuildEngine.PropertyPosition.UseExistingOrCreateAfterLastImport = 1 -> Microsoft.Build.BuildEngine.PropertyPosition
+Microsoft.Build.BuildEngine.PropertyPosition.UseExistingOrCreateAfterLastPropertyGroup = 0 -> Microsoft.Build.BuildEngine.PropertyPosition
+Microsoft.Build.BuildEngine.RemoteErrorException
+Microsoft.Build.BuildEngine.SolutionWrapperProject
+Microsoft.Build.BuildEngine.Target
+Microsoft.Build.BuildEngine.Target.AddNewTask(string taskName) -> Microsoft.Build.BuildEngine.BuildTask
+Microsoft.Build.BuildEngine.Target.Condition.get -> string
+Microsoft.Build.BuildEngine.Target.Condition.set -> void
+Microsoft.Build.BuildEngine.Target.DependsOnTargets.get -> string
+Microsoft.Build.BuildEngine.Target.DependsOnTargets.set -> void
+Microsoft.Build.BuildEngine.Target.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.Target.Inputs.get -> string
+Microsoft.Build.BuildEngine.Target.Inputs.set -> void
+Microsoft.Build.BuildEngine.Target.IsImported.get -> bool
+Microsoft.Build.BuildEngine.Target.Name.get -> string
+Microsoft.Build.BuildEngine.Target.Outputs.get -> string
+Microsoft.Build.BuildEngine.Target.Outputs.set -> void
+Microsoft.Build.BuildEngine.Target.RemoveTask(Microsoft.Build.BuildEngine.BuildTask taskElement) -> void
+Microsoft.Build.BuildEngine.TargetCollection
+Microsoft.Build.BuildEngine.TargetCollection.AddNewTarget(string targetName) -> Microsoft.Build.BuildEngine.Target
+Microsoft.Build.BuildEngine.TargetCollection.CopyTo(System.Array array, int index) -> void
+Microsoft.Build.BuildEngine.TargetCollection.Count.get -> int
+Microsoft.Build.BuildEngine.TargetCollection.Exists(string targetName) -> bool
+Microsoft.Build.BuildEngine.TargetCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.TargetCollection.IsSynchronized.get -> bool
+Microsoft.Build.BuildEngine.TargetCollection.RemoveTarget(Microsoft.Build.BuildEngine.Target targetToRemove) -> void
+Microsoft.Build.BuildEngine.TargetCollection.SyncRoot.get -> object
+Microsoft.Build.BuildEngine.TargetCollection.this[string index].get -> Microsoft.Build.BuildEngine.Target
+Microsoft.Build.BuildEngine.Toolset
+Microsoft.Build.BuildEngine.Toolset.BuildProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
+Microsoft.Build.BuildEngine.Toolset.Clone() -> Microsoft.Build.BuildEngine.Toolset
+Microsoft.Build.BuildEngine.Toolset.Toolset(string toolsVersion, string toolsPath) -> void
+Microsoft.Build.BuildEngine.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.BuildEngine.BuildPropertyGroup buildProperties) -> void
+Microsoft.Build.BuildEngine.Toolset.ToolsPath.get -> string
+Microsoft.Build.BuildEngine.Toolset.ToolsVersion.get -> string
+Microsoft.Build.BuildEngine.ToolsetCollection
+Microsoft.Build.BuildEngine.ToolsetCollection.Add(Microsoft.Build.BuildEngine.Toolset item) -> void
+Microsoft.Build.BuildEngine.ToolsetCollection.Clear() -> void
+Microsoft.Build.BuildEngine.ToolsetCollection.Contains(Microsoft.Build.BuildEngine.Toolset item) -> bool
+Microsoft.Build.BuildEngine.ToolsetCollection.Contains(string toolsVersion) -> bool
+Microsoft.Build.BuildEngine.ToolsetCollection.CopyTo(Microsoft.Build.BuildEngine.Toolset[] array, int arrayIndex) -> void
+Microsoft.Build.BuildEngine.ToolsetCollection.Count.get -> int
+Microsoft.Build.BuildEngine.ToolsetCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<Microsoft.Build.BuildEngine.Toolset>
+Microsoft.Build.BuildEngine.ToolsetCollection.IsReadOnly.get -> bool
+Microsoft.Build.BuildEngine.ToolsetCollection.Remove(Microsoft.Build.BuildEngine.Toolset item) -> bool
+Microsoft.Build.BuildEngine.ToolsetCollection.this[string toolsVersion].get -> Microsoft.Build.BuildEngine.Toolset
+Microsoft.Build.BuildEngine.ToolsetCollection.ToolsVersions.get -> System.Collections.Generic.IEnumerable<string>
+Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
+Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
+Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
+Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
+Microsoft.Build.BuildEngine.UsingTask
+Microsoft.Build.BuildEngine.UsingTask.AssemblyFile.get -> string
+Microsoft.Build.BuildEngine.UsingTask.AssemblyName.get -> string
+Microsoft.Build.BuildEngine.UsingTask.Condition.get -> string
+Microsoft.Build.BuildEngine.UsingTask.IsImported.get -> bool
+Microsoft.Build.BuildEngine.UsingTask.TaskName.get -> string
+Microsoft.Build.BuildEngine.UsingTaskCollection
+Microsoft.Build.BuildEngine.UsingTaskCollection.CopyTo(Microsoft.Build.BuildEngine.UsingTask[] array, int index) -> void
+Microsoft.Build.BuildEngine.UsingTaskCollection.CopyTo(System.Array array, int index) -> void
+Microsoft.Build.BuildEngine.UsingTaskCollection.Count.get -> int
+Microsoft.Build.BuildEngine.UsingTaskCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.BuildEngine.UsingTaskCollection.IsSynchronized.get -> bool
+Microsoft.Build.BuildEngine.UsingTaskCollection.SyncRoot.get -> object
+Microsoft.Build.BuildEngine.Utilities
+Microsoft.Build.BuildEngine.WriteHandler
+override Microsoft.Build.BuildEngine.BuildProperty.ToString() -> string
+override Microsoft.Build.BuildEngine.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+override Microsoft.Build.BuildEngine.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+override Microsoft.Build.BuildEngine.FileLogger.Shutdown() -> void
+override Microsoft.Build.BuildEngine.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.BuildEngine.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.BuildEngine.InvalidProjectFileException.Message.get -> string
+override Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.BuildEngine.RemoteErrorException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+static Microsoft.Build.BuildEngine.BuildProperty.explicit operator string(Microsoft.Build.BuildEngine.BuildProperty propertyToCast) -> string
+static Microsoft.Build.BuildEngine.Engine.GlobalEngine.get -> Microsoft.Build.BuildEngine.Engine
+static Microsoft.Build.BuildEngine.Engine.Version.get -> System.Version
+static Microsoft.Build.BuildEngine.LocalNode.StartLocalNodeServer(int nodeNumber) -> void
+static Microsoft.Build.BuildEngine.SolutionWrapperProject.Generate(string solutionPath, string toolsVersionOverride, Microsoft.Build.Framework.BuildEventContext projectBuildEventContext) -> string
+static Microsoft.Build.BuildEngine.Utilities.Escape(string unescapedExpression) -> string
+virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
+virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Shutdown() -> void
+virtual Microsoft.Build.BuildEngine.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+virtual Microsoft.Build.BuildEngine.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+virtual Microsoft.Build.BuildEngine.ConsoleLogger.Shutdown() -> void
\ No newline at end of file
diff --git a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 913c97b1281..cb6fabf4c0d 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -80,7 +80,6 @@
     <DefineConstants>$(DefineConstants);FEATURE_SYSTEMPAGESIZE</DefineConstants>
     <FeatureSystemConfiguration>true</FeatureSystemConfiguration>
     <DefineConstants>$(DefineConstants);FEATURE_TASK_GENERATERESOURCES</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_TASKHOST</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_ABORT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_CULTURE</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_PRIORITY</DefineConstants>
@@ -142,4 +141,9 @@
     <DocumentationFile Condition=" '$(GenerateDocumentationFile)' == 'true' ">$(IntermediateOutputPath)\$(AssemblyName).xml</DocumentationFile>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">
+    <DefineConstants>$(DefineConstants);FEATURE_MSIOREDIST</DefineConstants>
+    <FeatureMSIORedist>true</FeatureMSIORedist>
+  </PropertyGroup>
+
 </Project>
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index b0e23319446..1df6bcbc259 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -54,15 +54,14 @@
 
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
 
-    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --exclude-api-list:&quot;$(RepoRoot)ref\ExcludeAPIList.txt&quot;</GenAPIAdditionalParameters>
-    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --exclude-attributes-list:&quot;$(RepoRoot)ref\ExcludeAttributeList.txt&quot;</GenAPIAdditionalParameters>
-    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --header-file:&quot;$(RepoRoot)ref\LicenseHeader.txt&quot;</GenAPIAdditionalParameters>
-
     <PackageLicenseUrl Condition="'$(PackageLicenseExpression)' == ''">http://go.microsoft.com/fwlink/?LinkId=329770</PackageLicenseUrl>
     <PackageProjectUrl>http://go.microsoft.com/fwlink/?LinkId=624683</PackageProjectUrl>
     <PackageIconUrl>https://go.microsoft.com/fwlink/?linkid=825694</PackageIconUrl>
 
     <DevDivPackagesDir>$(VisualStudioSetupOutputPath)DevDivPackages\</DevDivPackagesDir>
+
+    <!-- Work around issue with official builds using 6.0.100 GA SDK with older MSBuild. Remove after internal pools use 17.0 GA -->
+    <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained>
   </PropertyGroup>
 
   <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index be0e8112f2e..365238883da 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -74,23 +74,21 @@
     <AdditionalFiles Include="$(MSBuildThisFileDirectory)BannedSymbols.txt" />
   </ItemGroup>
 
-  <!-- GenAPI settings -->
-  <PropertyGroup Condition="'$(MonoBuild)' == 'true'">
-    <!-- Disable reference assembly source when building for Mono, as some APIs are excluded when compiling for Mono -->
-    <GenerateReferenceAssemblySource>false</GenerateReferenceAssemblySource>
-  </PropertyGroup>
+  <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true'">
+    <PublicApiTfm Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">net</PublicApiTfm>
+    <PublicApiTfm Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework' and $([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == '3.5'">net35</PublicApiTfm>
+    <PublicApiTfm Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETStandard'">netstandard</PublicApiTfm>
+    <PublicApiTfm Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETCoreApp'">netstandard</PublicApiTfm>
 
-  <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
-    <GenAPIAssemblyName>$(AssemblyName)</GenAPIAssemblyName>
-    <GenAPIAssemblyName Condition="'$(GenAPIAssemblyName)' == ''">$(MSBuildProjectName)</GenAPIAssemblyName>
-    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">net</GenAPIShortFrameworkIdentifier>
-    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETStandard'">netstandard</GenAPIShortFrameworkIdentifier>
-    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETCoreApp'">netstandard</GenAPIShortFrameworkIdentifier>
-    <GenAPITargetPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\$(GenAPIAssemblyName).cs</GenAPITargetPath>
+    <GenAPIFolderPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\</GenAPIFolderPath>
   </PropertyGroup>
 
-  <ItemGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
-    <PackageReference Include="Microsoft.DotNet.GenAPI" PrivateAssets="All" />
+  <ItemGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true'">
+    <!-- Ensure API stability for shipping packages -->
+    <PackageReference Include="Microsoft.CodeAnalysis.PublicApiAnalyzers" PrivateAssets="all" />
+
+    <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Shipped.txt" />
+    <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Unshipped.txt" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true' And '$(TargetFrameworkIdentifier)' != '.NETFramework' ">
diff --git a/src/Framework.UnitTests/AssemblyInfo.cs b/src/Framework.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/Framework.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 2043a496e46..2ce98b0c404 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -11,6 +11,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
@@ -36,18 +37,13 @@
     <Compile Include="..\Shared\FileUtilities.cs" />
     <Compile Include="..\Shared\TempFileUtilities.cs" />
     <Compile Include="..\Shared\ErrorUtilities.cs" />
-    <Compile Include="..\Shared\NativeMethodsShared.cs" />
     <Compile Include="..\Shared\EscapingUtilities.cs" />
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs" />
-    <Compile Include="..\Shared\AssemblyUtilities.cs" />
     <Compile Include="..\Shared\ResourceUtilities.cs" />
-    <Compile Include="..\Shared\InternalErrorException.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs" />
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs" />
     <Compile Include="..\Shared\StringBuilderCache.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyResources.cs" />
-    <Compile Include="..\Shared\Traits.cs" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Shared/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
similarity index 93%
rename from src/Shared/AssemblyUtilities.cs
rename to src/Framework/AssemblyUtilities.cs
index 46d679293c5..cc87eb6448a 100644
--- a/src/Shared/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -6,6 +6,8 @@
 using System.Linq;
 using System.Reflection;
 
+using Microsoft.Build.Framework;
+
 // Declare this to get init properties. See https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239
 namespace System.Runtime.CompilerServices
 {
@@ -148,7 +150,7 @@ private static Assembly GetEntryAssembly()
 #else
             var getEntryAssembly = typeof(Assembly).GetMethod("GetEntryAssembly");
 
-            ErrorUtilities.VerifyThrowInternalNull(getEntryAssembly, "Assembly does not have the method GetEntryAssembly");
+            FrameworkErrorUtilities.VerifyThrowInternalNull(getEntryAssembly, "Assembly does not have the method GetEntryAssembly");
 
             return (Assembly) getEntryAssembly.Invoke(null, Array.Empty<object>());
 #endif
@@ -159,7 +161,7 @@ private static CultureInfo[] GetValidCultures()
         {
             var cultureTypesType = s_cultureInfoGetCultureMethod?.GetParameters().FirstOrDefault()?.ParameterType;
 
-            ErrorUtilities.VerifyThrow(cultureTypesType?.Name == "CultureTypes" &&
+            FrameworkErrorUtilities.VerifyThrow(cultureTypesType?.Name == "CultureTypes" &&
                                        Enum.IsDefined(cultureTypesType, "AllCultures"),
                                        "GetCulture is expected to accept CultureTypes.AllCultures");
 
@@ -167,7 +169,7 @@ private static CultureInfo[] GetValidCultures()
 
             var cultures = s_cultureInfoGetCultureMethod.Invoke(null, new[] {allCulturesEnumValue}) as CultureInfo[];
 
-            ErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
+            FrameworkErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
 
             return cultures;
         }
diff --git a/src/Framework/BuildEnvironmentState.cs b/src/Framework/BuildEnvironmentState.cs
new file mode 100644
index 00000000000..fae6127700e
--- /dev/null
+++ b/src/Framework/BuildEnvironmentState.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Class to encapsulate state that was stored in BuildEnvironmentHelper.
+    /// </summary>
+    /// <remarks>
+    /// This should be deleted when BuildEnvironmentHelper can be moved into Framework.
+    /// </remarks>
+    internal static class BuildEnvironmentState
+    {
+        internal static bool s_runningInVisualStudio = false;
+        internal static bool s_runningTests = false;
+    }
+}
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 3f70c7d9e2f..0aaa6f0baaf 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.Runtime.Serialization;
 using System.IO;
 using System.Text;
@@ -24,9 +23,9 @@ namespace Microsoft.Build.Framework
     public abstract class BuildEventArgs : EventArgs
     {
         /// <summary>
-        /// Message
+        /// Message. Volatile because it may be updated lock-free after construction.
         /// </summary>
-        private string message;
+        private volatile string message;
 
         /// <summary>
         /// Help keyword
@@ -144,10 +143,19 @@ public virtual string Message
         /// </summary>
         protected internal string RawMessage
         {
-            get => message;
+            get => FormattedMessage;
             set => message = value;
         }
 
+        /// <summary>
+        /// Like <see cref="RawMessage"/> but returns a formatted message string if available.
+        /// Used for serialization.
+        /// </summary>
+        private protected virtual string FormattedMessage
+        {
+            get => message;
+        }
+
         /// <summary>
         /// Custom help keyword associated with event.
         /// </summary>
@@ -172,9 +180,10 @@ public BuildEventContext BuildEventContext
         /// Serializes to a stream through a binary writer
         /// </summary>
         /// <param name="writer">Binary writer which is attached to the stream the event will be serialized into</param>
-        internal virtual void WriteToStream(BinaryWriter writer)
+        /// <param name="messageToWrite">The message to write to the stream.</param>
+        private protected void WriteToStreamWithExplicitMessage(BinaryWriter writer, string messageToWrite)
         {
-            writer.WriteOptionalString(message);
+            writer.WriteOptionalString(messageToWrite);
             writer.WriteOptionalString(helpKeyword);
             writer.WriteOptionalString(senderName);
             writer.WriteTimestamp(timestamp);
@@ -182,6 +191,15 @@ internal virtual void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalBuildEventContext(buildEventContext);
         }
 
+        /// <summary>
+        /// Serializes to a stream through a binary writer
+        /// </summary>
+        /// <param name="writer">Binary writer which is attached to the stream the event will be serialized into</param>
+        internal virtual void WriteToStream(BinaryWriter writer)
+        {
+            WriteToStreamWithExplicitMessage(writer, RawMessage);
+        }
+
         /// <summary>
         /// Deserializes from a stream through a binary reader
         /// </summary>
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index d97becfa1d0..90eed3b8aad 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Linq;
 
-namespace Microsoft.Build.Utilities
+namespace Microsoft.Build.Framework
 {
     internal enum ChangeWaveConversionState
     {
diff --git a/src/Framework/ErrorUtilities.cs b/src/Framework/ErrorUtilities.cs
new file mode 100644
index 00000000000..8611d41a549
--- /dev/null
+++ b/src/Framework/ErrorUtilities.cs
@@ -0,0 +1,75 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework
+{
+    // TODO: this should be unified with Shared\ErrorUtilities.cs, but it is hard to untangle everything
+    //       because some of the errors there will use localized resources from different assemblies,
+    //       which won't be referenceable in Framework.
+
+    internal class FrameworkErrorUtilities
+    {
+        /// <summary>
+        /// Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
+        /// and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
+        /// then we can give them this undocumented environment variable as an immediate workaround.
+        /// </summary>
+        private static readonly bool s_throwExceptions = string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
+
+        /// <summary>
+        /// This method should be used in places where one would normally put
+        /// an "assert". It should be used to validate that our assumptions are
+        /// true, where false would indicate that there must be a bug in our
+        /// code somewhere. This should not be used to throw errors based on bad
+        /// user input or anything that the user did wrong.
+        /// </summary>
+        /// <param name="condition"></param>
+        /// <param name="unformattedMessage"></param>
+        internal static void VerifyThrow
+        (
+            bool condition,
+            string unformattedMessage
+        )
+        {
+            if (!condition)
+            {
+                // PERF NOTE: explicitly passing null for the arguments array
+                // prevents memory allocation
+                ThrowInternalError(unformattedMessage, null, null);
+            }
+        }
+
+        /// <summary>
+        /// Helper to throw an InternalErrorException when the specified parameter is null.
+        /// This should be used ONLY if this would indicate a bug in MSBuild rather than
+        /// anything caused by user action.
+        /// </summary>
+        /// <param name="parameter">The value of the argument.</param>
+        /// <param name="parameterName">Parameter that should not be null</param>
+        internal static void VerifyThrowInternalNull(object parameter, string parameterName)
+        {
+            if (parameter == null)
+            {
+                ThrowInternalError("{0} unexpectedly null", innerException: null, args: parameterName);
+            }
+        }
+
+        /// <summary>
+        /// Throws InternalErrorException.
+        /// This is only for situations that would mean that there is a bug in MSBuild itself.
+        /// </summary>
+        internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
+        {
+            if (s_throwExceptions)
+            {
+                throw new InternalErrorException(string.Format(message, args), innerException);
+            }
+        }
+    }
+}
diff --git a/src/Framework/FxCopExclusions/Microsoft.Build.Framework.Suppressions.cs b/src/Framework/FxCopExclusions/Microsoft.Build.Framework.Suppressions.cs
deleted file mode 100644
index 9596e6a1cbd..00000000000
--- a/src/Framework/FxCopExclusions/Microsoft.Build.Framework.Suppressions.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-// FxCop Suppression file
-// To Use:
-// Add add module level suppressions to this file to have them suppressed in the assembly
-
-#if CODE_ANALYSIS
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.CommandLine", Justification="This is an approved namespace.")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="STA", Scope="type", Target="Microsoft.Build.Framework.RunInSTAAttribute", Justification="Not worth breaking custormers because of case.")]
-#endif
diff --git a/src/Shared/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
similarity index 86%
rename from src/Shared/InternalErrorException.cs
rename to src/Framework/InternalErrorException.cs
index 448cc5f6a46..7c6f9a27d21 100644
--- a/src/Shared/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -5,25 +5,19 @@
 using System.Diagnostics;
 using System.Runtime.Serialization;
 
-namespace Microsoft.Build.Shared
+namespace Microsoft.Build.Framework
 {
     /// <summary>
     /// This exception is to be thrown whenever an assumption we have made in the code turns out to be false. Thus, if this
     /// exception ever gets thrown, it is because of a bug in our own code, not because of something the user or project author
     /// did wrong.
-    /// 
-    /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
-    /// WARNING: When this file is shared into multiple assemblies each assembly will view this as a different type.
-    ///          Don't throw this exception from one assembly and catch it in another.
-    /// !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
-    ///     
     /// </summary>
     [Serializable]
     internal sealed class InternalErrorException : Exception
     {
         /// <summary>
         /// Default constructor.
-        /// SHOULD ONLY BE CALLED BY DESERIALIZER. 
+        /// SHOULD ONLY BE CALLED BY DESERIALIZER.
         /// SUPPLY A MESSAGE INSTEAD.
         /// </summary>
         internal InternalErrorException() : base()
@@ -76,21 +70,21 @@ private InternalErrorException(SerializationInfo info, StreamingContext context)
         #region ConsiderDebuggerLaunch
         /// <summary>
         /// A fatal internal error due to a bug has occurred. Give the dev a chance to debug it, if possible.
-        /// 
+        ///
         /// Will in all cases launch the debugger, if the environment variable "MSBUILDLAUNCHDEBUGGER" is set.
-        /// 
+        ///
         /// In DEBUG build, will always launch the debugger, unless we are in razzle (_NTROOT is set) or in NUnit,
         /// or MSBUILDDONOTLAUNCHDEBUGGER is set (that could be useful in suite runs).
         /// We don't launch in retail or LKG so builds don't jam; they get a callstack, and continue or send a mail, etc.
         /// We don't launch in NUnit as tests often intentionally cause InternalErrorExceptions.
-        /// 
-        /// Because we only call this method from this class, just before throwing an InternalErrorException, there is 
+        ///
+        /// Because we only call this method from this class, just before throwing an InternalErrorException, there is
         /// no danger that this suppression will cause a bug to only manifest itself outside NUnit
         /// (which would be most unfortunate!). Do not make this non-private.
-        /// 
+        ///
         /// Unfortunately NUnit can't handle unhandled exceptions like InternalErrorException on anything other than
         /// the main test thread. However, there's still a callstack displayed before it quits.
-        /// 
+        ///
         /// If it is going to launch the debugger, it first does a Debug.Fail to give information about what needs to
         /// be debugged -- the exception hasn't been thrown yet. This automatically displays the current callstack.
         /// </summary>
@@ -120,7 +114,7 @@ private static void LaunchDebugger(string message, string innerMessage)
             Debug.Fail(message, innerMessage);
             Debugger.Launch();
 #else
-            Console.WriteLine("MSBuild Failure: " + message);    
+            Console.WriteLine("MSBuild Failure: " + message);
             if (!string.IsNullOrEmpty(innerMessage))
             {
                 Console.WriteLine(innerMessage);
@@ -134,6 +128,6 @@ private static void LaunchDebugger(string message, string innerMessage)
         }
         #endregion
 
-        private static bool RunningTests() => BuildEnvironmentHelper.Instance.RunningTests;
+        private static bool RunningTests() => BuildEnvironmentState.s_runningTests;
     }
 }
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index ae7be349bd4..9f0e8aded43 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Globalization;
 using System.IO;
-using System.Runtime.Serialization;
 
 namespace Microsoft.Build.Framework
 {
@@ -17,33 +16,34 @@ public class LazyFormattedBuildEventArgs : BuildEventArgs
         /// <summary>
         /// Stores the message arguments.
         /// </summary>
-        private object[] arguments;
+        private volatile object argumentsOrFormattedMessage;
 
         /// <summary>
         /// Exposes the underlying arguments field to serializers.
         /// </summary>
         internal object[] RawArguments
         {
-            get => arguments;
-            set => arguments = value;
+            get => (argumentsOrFormattedMessage is object[] arguments) ? arguments : null;
         }
 
         /// <summary>
-        /// Stores the original culture for String.Format.
+        /// Exposes the formatted message string to serializers.
         /// </summary>
-        private string originalCultureName;
+        private protected override string FormattedMessage
+        {
+            get => (argumentsOrFormattedMessage is string formattedMessage) ? formattedMessage : base.FormattedMessage;
+        }
 
         /// <summary>
-        /// Non-serializable CultureInfo object
+        /// Stores the original culture for String.Format.
         /// </summary>
-        [NonSerialized]
-        private CultureInfo originalCultureInfo;
+        private string originalCultureName;
 
         /// <summary>
-        /// Lock object.
+        /// Non-serializable CultureInfo object
         /// </summary>
         [NonSerialized]
-        protected Object locker;
+        private volatile CultureInfo originalCultureInfo;
 
         /// <summary>
         /// This constructor allows all event data to be initialized.
@@ -79,10 +79,9 @@ params object[] messageArgs
         )
             : base(message, helpKeyword, senderName, eventTimestamp)
         {
-            arguments = messageArgs;
+            argumentsOrFormattedMessage = messageArgs;
             originalCultureName = CultureInfo.CurrentCulture.Name;
             originalCultureInfo = CultureInfo.CurrentCulture;
-            locker = new Object();
         }
 
         /// <summary>
@@ -91,7 +90,6 @@ params object[] messageArgs
         protected LazyFormattedBuildEventArgs()
             : base()
         {
-            locker = new Object();
         }
 
         /// <summary>
@@ -101,18 +99,22 @@ public override string Message
         {
             get
             {
-                lock (locker)
+                object argsOrMessage = argumentsOrFormattedMessage;
+                if (argsOrMessage is string formattedMessage)
                 {
-                    if (arguments?.Length > 0)
-                    {
-                        if (originalCultureInfo == null)
-                        {
-                            originalCultureInfo = new CultureInfo(originalCultureName);
-                        }
+                    return formattedMessage;
+                }
 
-                        base.Message = FormatString(originalCultureInfo, base.Message, arguments);
-                        arguments = null;
+                if (argsOrMessage is object[] arguments && arguments.Length > 0)
+                {
+                    if (originalCultureInfo == null)
+                    {
+                        originalCultureInfo = new CultureInfo(originalCultureName);
                     }
+
+                    formattedMessage = FormatString(originalCultureInfo, base.Message, arguments);
+                    argumentsOrFormattedMessage = formattedMessage;
+                    return formattedMessage;
                 }
 
                 return base.Message;
@@ -125,37 +127,26 @@ public override string Message
         /// <param name="writer">Binary writer which is attached to the stream the event will be serialized into.</param>
         internal override void WriteToStream(BinaryWriter writer)
         {
-            // Locking is needed here as this is invoked on the serialization thread,
-            // whereas a local logger (a distributed logger) may concurrently invoke this.Message
-            // which will trigger formatting and thus the exception below
-            lock (locker)
+            object argsOrMessage = argumentsOrFormattedMessage;
+            if (argsOrMessage is object[] arguments && arguments.Length > 0)
             {
-                bool hasArguments = arguments != null;
-                base.WriteToStream(writer);
+                base.WriteToStreamWithExplicitMessage(writer, base.Message);
+                writer.Write(arguments.Length);
 
-                if (hasArguments && arguments == null)
+                foreach (object argument in arguments)
                 {
-                    throw new InvalidOperationException("BuildEventArgs has formatted message while serializing!");
+                    // Arguments may be ints, etc, so explicitly convert
+                    // Convert.ToString returns String.Empty when it cannot convert, rather than throwing
+                    writer.Write(Convert.ToString(argument, CultureInfo.CurrentCulture));
                 }
-
-                if (arguments != null)
-                {
-                    writer.Write(arguments.Length);
-
-                    foreach (object argument in arguments)
-                    {
-                        // Arguments may be ints, etc, so explicitly convert
-                        // Convert.ToString returns String.Empty when it cannot convert, rather than throwing
-                        writer.Write(Convert.ToString(argument, CultureInfo.CurrentCulture));
-                    }
-                }
-                else
-                {
-                    writer.Write(-1);
-                }
-
-                writer.Write(originalCultureName);
             }
+            else
+            {
+                base.WriteToStreamWithExplicitMessage(writer, (argsOrMessage is string formattedMessage) ? formattedMessage : base.Message);
+                writer.Write(-1);
+            }
+
+            writer.Write(originalCultureName);
         }
 
         /// <summary>
@@ -182,7 +173,7 @@ internal override void CreateFromStream(BinaryReader reader, Int32 version)
                     }
                 }
 
-                arguments = messageArgs;
+                argumentsOrFormattedMessage = messageArgs;
 
                 originalCultureName = reader.ReadString();
             }
@@ -248,16 +239,5 @@ private static string FormatString(CultureInfo culture, string unformatted, para
 
             return formatted;
         }
-
-        /// <summary>
-        /// Deserialization does not call any constructors, not even
-        /// the parameterless constructor. Therefore since we do not serialize
-        /// this field, we must populate it here.
-        /// </summary>
-        [OnDeserialized]
-        private void OnDeserialized(StreamingContext context)
-        {
-            locker = new Object();
-        }
     }
 }
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 3581225789d..e32cb633fbc 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -429,7 +429,7 @@ public void TargetUpToDateStop(int result)
         {
             WriteEvent(57, result);
         }
-        
+
         [Event(58, Keywords = Keywords.All)]
         public void CopyUpToDateStart(string path)
         {
@@ -454,6 +454,42 @@ public void WriteLinesToFileUpToDateStop(string fileItemSpec, bool wasUpToDate)
             WriteEvent(61, fileItemSpec, wasUpToDate);
         }
 
+        [Event(62, Keywords = Keywords.All)]
+        public void SdkResolverServiceInitializeStart()
+        {
+            WriteEvent(62);
+        }
+
+        [Event(63, Keywords = Keywords.All)]
+        public void SdkResolverServiceInitializeStop(int resolverCount)
+        {
+            WriteEvent(63, resolverCount);
+        }
+
+        [Event(64, Keywords = Keywords.All)]
+        public void SdkResolverResolveSdkStart()
+        {
+            WriteEvent(64);
+        }
+
+        [Event(65, Keywords = Keywords.All)]
+        public void SdkResolverResolveSdkStop(string resolverName, string sdkName, string solutionPath, string projectPath, string sdkPath, bool success)
+        {
+            WriteEvent(65, resolverName, sdkName, solutionPath, projectPath, sdkPath, success);
+        }
+
+        [Event(66, Keywords = Keywords.All)]
+        public void CachedSdkResolverServiceResolveSdkStart(string sdkName, string solutionPath, string projectPath)
+        {
+            WriteEvent(66, sdkName, solutionPath, projectPath);
+        }
+
+        [Event(67, Keywords = Keywords.All)]
+        public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success)
+        {
+            WriteEvent(67, sdkName, solutionPath, projectPath, success);
+        }
+
         #endregion
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index d2b221eb376..df75564473e 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -22,9 +22,17 @@
     <PackageReference Include="Microsoft.CodeAnalysis.Collections" PrivateAssets="all" />
   </ItemGroup>
 
-  <ItemGroup>
-    <PackageReference Include="System.Security.Permissions" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
-    <Reference Include="System.Xaml" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
+    <PackageReference Include="System.Security.Permissions" />
+    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
+    <PackageReference Include="Microsoft.Win32.Registry" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <!-- Promote CompilerServices.Unsafe from the old version we get from System.Memory on net472. -->
+    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
+    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
+    <Reference Include="System.Xaml" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
new file mode 100644
index 00000000000..e9cfcc62d94
--- /dev/null
+++ b/src/Framework/NativeMethods.cs
@@ -0,0 +1,1723 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.InteropServices;
+using System.Text;
+using System.Threading;
+
+using Microsoft.Build.Shared;
+using Microsoft.Win32;
+using Microsoft.Win32.SafeHandles;
+
+using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
+
+namespace Microsoft.Build.Framework;
+internal static class NativeMethods
+{
+    #region Constants
+
+    internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
+    internal const uint STARTUP_LOADER_SAFEMODE = 0x10;
+    internal const uint S_OK = 0x0;
+    internal const uint S_FALSE = 0x1;
+    internal const uint ERROR_ACCESS_DENIED = 0x5;
+    internal const uint ERROR_FILE_NOT_FOUND = 0x80070002;
+    internal const uint FUSION_E_PRIVATE_ASM_DISALLOWED = 0x80131044; // Tried to find unsigned assembly in GAC
+    internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
+    internal const uint FILE_TYPE_CHAR = 0x0002;
+    internal const Int32 STD_OUTPUT_HANDLE = -11;
+    internal const uint RPC_S_CALLPENDING = 0x80010115;
+    internal const uint E_ABORT = (uint)0x80004004;
+
+    internal const int FILE_ATTRIBUTE_READONLY = 0x00000001;
+    internal const int FILE_ATTRIBUTE_DIRECTORY = 0x00000010;
+    internal const int FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400;
+
+    /// <summary>
+    /// Default buffer size to use when dealing with the Windows API.
+    /// </summary>
+    internal const int MAX_PATH = 260;
+
+    private const string kernel32Dll = "kernel32.dll";
+    private const string mscoreeDLL = "mscoree.dll";
+
+    private const string WINDOWS_FILE_SYSTEM_REGISTRY_KEY = @"SYSTEM\CurrentControlSet\Control\FileSystem";
+    private const string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME = "LongPathsEnabled";
+
+    internal static DateTime MinFileDate { get; } = DateTime.FromFileTimeUtc(0);
+
+#if FEATURE_HANDLEREF
+    internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
+#endif
+
+    internal static IntPtr NullIntPtr = new IntPtr(0);
+
+    // As defined in winnt.h:
+    internal const ushort PROCESSOR_ARCHITECTURE_INTEL = 0;
+    internal const ushort PROCESSOR_ARCHITECTURE_ARM = 5;
+    internal const ushort PROCESSOR_ARCHITECTURE_IA64 = 6;
+    internal const ushort PROCESSOR_ARCHITECTURE_AMD64 = 9;
+    internal const ushort PROCESSOR_ARCHITECTURE_ARM64 = 12;
+
+    internal const uint INFINITE = 0xFFFFFFFF;
+    internal const uint WAIT_ABANDONED_0 = 0x00000080;
+    internal const uint WAIT_OBJECT_0 = 0x00000000;
+    internal const uint WAIT_TIMEOUT = 0x00000102;
+
+#if FEATURE_CHARSET_AUTO
+    internal const CharSet AutoOrUnicode = CharSet.Auto;
+#else
+        internal const CharSet AutoOrUnicode = CharSet.Unicode;
+#endif
+
+    #endregion
+
+    #region Enums
+
+    private enum PROCESSINFOCLASS : int
+    {
+        ProcessBasicInformation = 0,
+        ProcessQuotaLimits,
+        ProcessIoCounters,
+        ProcessVmCounters,
+        ProcessTimes,
+        ProcessBasePriority,
+        ProcessRaisePriority,
+        ProcessDebugPort,
+        ProcessExceptionPort,
+        ProcessAccessToken,
+        ProcessLdtInformation,
+        ProcessLdtSize,
+        ProcessDefaultHardErrorMode,
+        ProcessIoPortHandlers, // Note: this is kernel mode only
+        ProcessPooledUsageAndLimits,
+        ProcessWorkingSetWatch,
+        ProcessUserModeIOPL,
+        ProcessEnableAlignmentFaultFixup,
+        ProcessPriorityClass,
+        ProcessWx86Information,
+        ProcessHandleCount,
+        ProcessAffinityMask,
+        ProcessPriorityBoost,
+        MaxProcessInfoClass
+    };
+
+    private enum eDesiredAccess : int
+    {
+        DELETE = 0x00010000,
+        READ_CONTROL = 0x00020000,
+        WRITE_DAC = 0x00040000,
+        WRITE_OWNER = 0x00080000,
+        SYNCHRONIZE = 0x00100000,
+        STANDARD_RIGHTS_ALL = 0x001F0000,
+
+        PROCESS_TERMINATE = 0x0001,
+        PROCESS_CREATE_THREAD = 0x0002,
+        PROCESS_SET_SESSIONID = 0x0004,
+        PROCESS_VM_OPERATION = 0x0008,
+        PROCESS_VM_READ = 0x0010,
+        PROCESS_VM_WRITE = 0x0020,
+        PROCESS_DUP_HANDLE = 0x0040,
+        PROCESS_CREATE_PROCESS = 0x0080,
+        PROCESS_SET_QUOTA = 0x0100,
+        PROCESS_SET_INFORMATION = 0x0200,
+        PROCESS_QUERY_INFORMATION = 0x0400,
+        PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF
+    }
+#pragma warning disable 0649, 0169
+    internal enum LOGICAL_PROCESSOR_RELATIONSHIP
+    {
+        RelationProcessorCore,
+        RelationNumaNode,
+        RelationCache,
+        RelationProcessorPackage,
+        RelationGroup,
+        RelationAll = 0xffff
+    }
+    internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
+    {
+        public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
+        public uint Size;
+        public PROCESSOR_RELATIONSHIP Processor;
+    }
+    [StructLayout(LayoutKind.Sequential)]
+    internal unsafe struct PROCESSOR_RELATIONSHIP
+    {
+        public byte Flags;
+        private byte EfficiencyClass;
+        private fixed byte Reserved[20];
+        public ushort GroupCount;
+        public IntPtr GroupInfo;
+    }
+#pragma warning restore 0169, 0149
+
+    /// <summary>
+    /// Flags for CoWaitForMultipleHandles
+    /// </summary>
+    [Flags]
+    public enum COWAIT_FLAGS : int
+    {
+        /// <summary>
+        /// Exit when a handle is signaled.
+        /// </summary>
+        COWAIT_NONE = 0,
+
+        /// <summary>
+        /// Exit when all handles are signaled AND a message is received.
+        /// </summary>
+        COWAIT_WAITALL = 0x00000001,
+
+        /// <summary>
+        /// Exit when an RPC call is serviced.
+        /// </summary>
+        COWAIT_ALERTABLE = 0x00000002
+    }
+
+    /// <summary>
+    /// Processor architecture values
+    /// </summary>
+    internal enum ProcessorArchitectures
+    {
+        // Intel 32 bit
+        X86,
+
+        // AMD64 64 bit
+        X64,
+
+        // Itanium 64
+        IA64,
+
+        // ARM
+        ARM,
+
+        // ARM64
+        ARM64,
+
+        // Who knows
+        Unknown
+    }
+
+    #endregion
+
+    #region Structs
+
+    /// <summary>
+    /// Structure that contain information about the system on which we are running
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential)]
+    internal struct SYSTEM_INFO
+    {
+        // This is a union of a DWORD and a struct containing 2 WORDs.
+        internal ushort wProcessorArchitecture;
+        internal ushort wReserved;
+
+        internal uint dwPageSize;
+        internal IntPtr lpMinimumApplicationAddress;
+        internal IntPtr lpMaximumApplicationAddress;
+        internal IntPtr dwActiveProcessorMask;
+        internal uint dwNumberOfProcessors;
+        internal uint dwProcessorType;
+        internal uint dwAllocationGranularity;
+        internal ushort wProcessorLevel;
+        internal ushort wProcessorRevision;
+    }
+
+    /// <summary>
+    /// Wrap the intptr returned by OpenProcess in a safe handle.
+    /// </summary>
+    internal class SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid
+    {
+        // Create a SafeHandle, informing the base class
+        // that this SafeHandle instance "owns" the handle,
+        // and therefore SafeHandle should call
+        // our ReleaseHandle method when the SafeHandle
+        // is no longer in use
+        private SafeProcessHandle() : base(true)
+        {
+        }
+        protected override bool ReleaseHandle()
+        {
+            return CloseHandle(handle);
+        }
+    }
+
+    /// <summary>
+    /// Contains information about the current state of both physical and virtual memory, including extended memory
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential, CharSet = AutoOrUnicode)]
+    internal class MemoryStatus
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
+        /// </summary>
+        public MemoryStatus()
+        {
+#if (CLR2COMPATIBILITY)
+            _length = (uint)Marshal.SizeOf(typeof(MemoryStatus));
+#else
+            _length = (uint)Marshal.SizeOf<MemoryStatus>();
+#endif
+        }
+
+        /// <summary>
+        /// Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
+        /// </summary>
+        private uint _length;
+
+        /// <summary>
+        /// Number between 0 and 100 that specifies the approximate percentage of physical
+        /// memory that is in use (0 indicates no memory use and 100 indicates full memory use).
+        /// </summary>
+        public uint MemoryLoad;
+
+        /// <summary>
+        /// Total size of physical memory, in bytes.
+        /// </summary>
+        public ulong TotalPhysical;
+
+        /// <summary>
+        /// Size of physical memory available, in bytes.
+        /// </summary>
+        public ulong AvailablePhysical;
+
+        /// <summary>
+        /// Size of the committed memory limit, in bytes. This is physical memory plus the
+        /// size of the page file, minus a small overhead.
+        /// </summary>
+        public ulong TotalPageFile;
+
+        /// <summary>
+        /// Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
+        /// </summary>
+        public ulong AvailablePageFile;
+
+        /// <summary>
+        /// Total size of the user mode portion of the virtual address space of the calling process, in bytes.
+        /// </summary>
+        public ulong TotalVirtual;
+
+        /// <summary>
+        /// Size of unreserved and uncommitted memory in the user mode portion of the virtual
+        /// address space of the calling process, in bytes.
+        /// </summary>
+        public ulong AvailableVirtual;
+
+        /// <summary>
+        /// Size of unreserved and uncommitted memory in the extended portion of the virtual
+        /// address space of the calling process, in bytes.
+        /// </summary>
+        public ulong AvailableExtendedVirtual;
+    }
+
+    [StructLayout(LayoutKind.Sequential)]
+    private struct PROCESS_BASIC_INFORMATION
+    {
+        public uint ExitStatus;
+        public IntPtr PebBaseAddress;
+        public UIntPtr AffinityMask;
+        public int BasePriority;
+        public UIntPtr UniqueProcessId;
+        public UIntPtr InheritedFromUniqueProcessId;
+
+        public uint Size
+        {
+            get
+            {
+                unsafe
+                {
+                    return (uint)sizeof(PROCESS_BASIC_INFORMATION);
+                }
+            }
+        }
+    };
+
+    /// <summary>
+    /// Contains information about a file or directory; used by GetFileAttributesEx.
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential)]
+    public struct WIN32_FILE_ATTRIBUTE_DATA
+    {
+        internal int fileAttributes;
+        internal uint ftCreationTimeLow;
+        internal uint ftCreationTimeHigh;
+        internal uint ftLastAccessTimeLow;
+        internal uint ftLastAccessTimeHigh;
+        internal uint ftLastWriteTimeLow;
+        internal uint ftLastWriteTimeHigh;
+        internal uint fileSizeHigh;
+        internal uint fileSizeLow;
+    }
+
+    /// <summary>
+    /// Contains the security descriptor for an object and specifies whether
+    /// the handle retrieved by specifying this structure is inheritable.
+    /// </summary>
+    [StructLayout(LayoutKind.Sequential)]
+    internal class SecurityAttributes
+    {
+        public SecurityAttributes()
+        {
+#if (CLR2COMPATIBILITY)
+            _nLength = (uint)Marshal.SizeOf(typeof(SecurityAttributes));
+#else
+            _nLength = (uint)Marshal.SizeOf<SecurityAttributes>();
+#endif
+        }
+
+        private uint _nLength;
+
+        public IntPtr lpSecurityDescriptor;
+
+        public bool bInheritHandle;
+    }
+
+    private class SystemInformationData
+    {
+        /// <summary>
+        /// Architecture as far as the current process is concerned.
+        /// It's x86 in wow64 (native architecture is x64 in that case).
+        /// Otherwise it's the same as the native architecture.
+        /// </summary>
+        public readonly ProcessorArchitectures ProcessorArchitectureType;
+
+        /// <summary>
+        /// Actual architecture of the system.
+        /// </summary>
+        public readonly ProcessorArchitectures ProcessorArchitectureTypeNative;
+
+        /// <summary>
+        /// Convert SYSTEM_INFO architecture values to the internal enum
+        /// </summary>
+        /// <param name="arch"></param>
+        /// <returns></returns>
+        private static ProcessorArchitectures ConvertSystemArchitecture(ushort arch)
+        {
+            return arch switch
+            {
+                PROCESSOR_ARCHITECTURE_INTEL => ProcessorArchitectures.X86,
+                PROCESSOR_ARCHITECTURE_AMD64 => ProcessorArchitectures.X64,
+                PROCESSOR_ARCHITECTURE_ARM => ProcessorArchitectures.ARM,
+                PROCESSOR_ARCHITECTURE_IA64 => ProcessorArchitectures.IA64,
+                PROCESSOR_ARCHITECTURE_ARM64 => ProcessorArchitectures.ARM64,
+                _ => ProcessorArchitectures.Unknown,
+            };
+        }
+
+        /// <summary>
+        /// Read system info values
+        /// </summary>
+        public SystemInformationData()
+        {
+            ProcessorArchitectureType = ProcessorArchitectures.Unknown;
+            ProcessorArchitectureTypeNative = ProcessorArchitectures.Unknown;
+
+            if (IsWindows)
+            {
+                var systemInfo = new SYSTEM_INFO();
+
+                GetSystemInfo(ref systemInfo);
+                ProcessorArchitectureType = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
+
+                GetNativeSystemInfo(ref systemInfo);
+                ProcessorArchitectureTypeNative = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
+            }
+            else
+            {
+                ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
+#if !NET35
+                // Get the architecture from the runtime.
+                processorArchitecture = RuntimeInformation.OSArchitecture switch
+                {
+                    Architecture.Arm => ProcessorArchitectures.ARM,
+                    Architecture.Arm64 => ProcessorArchitectures.ARM64,
+                    Architecture.X64 => ProcessorArchitectures.X64,
+                    Architecture.X86 => ProcessorArchitectures.X86,
+                    _ => ProcessorArchitectures.Unknown,
+                };
+#endif
+                // Fall back to 'uname -m' to get the architecture.
+                if (processorArchitecture == ProcessorArchitectures.Unknown)
+                {
+                    try
+                    {
+                        // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
+                        using (
+                            var proc =
+                                Process.Start(
+                                    new ProcessStartInfo("uname")
+                                    {
+                                        Arguments = "-m",
+                                        UseShellExecute = false,
+                                        RedirectStandardOutput = true,
+                                        CreateNoWindow = true
+                                    }))
+                        {
+                            string arch = null;
+                            if (proc != null)
+                            {
+                                arch = proc.StandardOutput.ReadLine();
+                                proc.WaitForExit();
+                            }
+
+                            if (!string.IsNullOrEmpty(arch))
+                            {
+                                if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.X64;
+                                }
+                                else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.IA64;
+                                }
+                                else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.ARM;
+                                }
+                                else if (arch.StartsWith("aarch64", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.ARM64;
+                                }
+                                else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
+                                        && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
+                                {
+                                    ProcessorArchitectureType = ProcessorArchitectures.X86;
+                                }
+                            }
+                        }
+                    }
+                    catch
+                    {
+                        // Best effort: fall back to Unknown
+                    }
+                }
+
+                ProcessorArchitectureTypeNative = ProcessorArchitectureType = processorArchitecture;
+            }
+        }
+    }
+
+    public static int GetLogicalCoreCount()
+    {
+        int numberOfCpus = Environment.ProcessorCount;
+#if !MONO
+        // .NET Core on Windows returns a core count limited to the current NUMA node
+        //     https://github.com/dotnet/runtime/issues/29686
+        // so always double-check it.
+        if (IsWindows
+#if NETFRAMEWORK
+            // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
+            // So if we get a high core count on full framework, double-check it.
+            && (numberOfCpus >= 32)
+#endif
+            )
+        {
+            var result = GetLogicalCoreCountOnWindows();
+            if (result != -1)
+            {
+                numberOfCpus = result;
+            }
+        }
+#endif
+
+        return numberOfCpus;
+    }
+
+    /// <summary>
+    /// Get the exact physical core count on Windows
+    /// Useful for getting the exact core count in 32 bits processes,
+    /// as Environment.ProcessorCount has a 32-core limit in that case.
+    /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
+    /// </summary>
+    private unsafe static int GetLogicalCoreCountOnWindows()
+    {
+        uint len = 0;
+        const int ERROR_INSUFFICIENT_BUFFER = 122;
+
+        if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref len) &&
+            Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)
+        {
+            // Allocate that much space
+            var buffer = new byte[len];
+            fixed (byte* bufferPtr = buffer)
+            {
+                // Call GetLogicalProcessorInformationEx with the allocated buffer
+                if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, (IntPtr)bufferPtr, ref len))
+                {
+                    // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how
+                    // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.
+                    int processorCount = 0;
+                    byte* ptr = bufferPtr;
+                    byte* endPtr = bufferPtr + len;
+                    while (ptr < endPtr)
+                    {
+                        var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;
+                        if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
+                        {
+                            // Flags is 0 if the core has a single logical proc, LTP_PC_SMT if more than one
+                            // for now, assume "more than 1" == 2, as it has historically been for hyperthreading
+                            processorCount += (current->Processor.Flags == 0) ? 1 : 2;
+                        }
+                        ptr += current->Size;
+                    }
+                    return processorCount;
+                }
+            }
+        }
+
+        return -1;
+    }
+
+    #endregion
+
+    #region Member data
+
+    internal static bool HasMaxPath => MaxPath == MAX_PATH;
+
+    /// <summary>
+    /// Gets the max path limit of the current OS.
+    /// </summary>
+    internal static int MaxPath
+    {
+        get
+        {
+            if (!IsMaxPathSet)
+            {
+                SetMaxPath();
+            }
+            return _maxPath;
+        }
+    }
+
+    /// <summary>
+    /// Cached value for MaxPath.
+    /// </summary>
+    private static int _maxPath;
+
+    private static bool IsMaxPathSet { get; set; }
+
+    private static readonly object MaxPathLock = new object();
+
+    private static void SetMaxPath()
+    {
+        lock (MaxPathLock)
+        {
+            if (!IsMaxPathSet)
+            {
+                bool isMaxPathRestricted = Traits.Instance.EscapeHatches.DisableLongPaths || IsMaxPathLegacyWindows();
+                _maxPath = isMaxPathRestricted ? MAX_PATH : int.MaxValue;
+                IsMaxPathSet = true;
+            }
+        }
+    }
+
+    internal static bool IsMaxPathLegacyWindows()
+    {
+        try
+        {
+            return IsWindows && !IsLongPathsEnabledRegistry();
+        }
+        catch
+        {
+            return true;
+        }
+    }
+
+    // CA1416 warns about code that can only run on Windows, but we verified we're running on Windows before this.
+    // This is the most reasonable way to resolve this part because other ways would require ifdef'ing on NET472.
+#pragma warning disable CA1416
+    private static bool IsLongPathsEnabledRegistry()
+    {
+        using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
+        {
+            object longPathsEnabledValue = fileSystemKey?.GetValue(WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME, 0);
+            return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
+        }
+    }
+#pragma warning restore CA1416
+
+    /// <summary>
+    /// Cached value for IsUnixLike (this method is called frequently during evaluation).
+    /// </summary>
+    private static readonly bool s_isUnixLike = IsLinux || IsOSX || IsBSD;
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under a Unix-like system (Mac, Linux, etc.)
+    /// </summary>
+    internal static bool IsUnixLike
+    {
+        get { return s_isUnixLike; }
+    }
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under Linux
+    /// </summary>
+    internal static bool IsLinux
+    {
+#if CLR2COMPATIBILITY
+            get { return false; }
+#else
+        get { return RuntimeInformation.IsOSPlatform(OSPlatform.Linux); }
+#endif
+    }
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under flavor of BSD (NetBSD, OpenBSD, FreeBSD)
+    /// </summary>
+    internal static bool IsBSD
+    {
+#if CLR2COMPATIBILITY
+            get { return false; }
+#else
+        get
+        {
+            return RuntimeInformation.IsOSPlatform(OSPlatform.Create("FREEBSD")) ||
+                   RuntimeInformation.IsOSPlatform(OSPlatform.Create("NETBSD")) ||
+                   RuntimeInformation.IsOSPlatform(OSPlatform.Create("OPENBSD"));
+        }
+#endif
+    }
+
+    private static readonly object IsMonoLock = new object();
+
+    private static bool? _isMono;
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under MONO
+    /// </summary>
+    internal static bool IsMono
+    {
+        get
+        {
+            if (_isMono != null) return _isMono.Value;
+
+            lock (IsMonoLock)
+            {
+                if (_isMono == null)
+                {
+                    // There could be potentially expensive TypeResolve events, so cache IsMono.
+                    // Also, VS does not host Mono runtimes, so turn IsMono off when msbuild is running under VS
+                    _isMono = !BuildEnvironmentState.s_runningInVisualStudio &&
+                              Type.GetType("Mono.Runtime") != null;
+                }
+            }
+
+            return _isMono.Value;
+        }
+    }
+
+#if !CLR2COMPATIBILITY
+    private static bool? _isWindows;
+#endif
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under some version of Windows
+    /// </summary>
+    internal static bool IsWindows
+    {
+#if CLR2COMPATIBILITY
+            get { return true; }
+#else
+        get
+        {
+            if (_isWindows == null)
+            {
+                _isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+            }
+            return _isWindows.Value;
+        }
+#endif
+    }
+
+#if !CLR2COMPATIBILITY
+    private static bool? _isOSX;
+#endif
+
+    /// <summary>
+    /// Gets a flag indicating if we are running under Mac OSX
+    /// </summary>
+    internal static bool IsOSX
+    {
+#if CLR2COMPATIBILITY
+            get { return false; }
+#else
+        get
+        {
+            if (_isOSX == null)
+            {
+                _isOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
+            }
+            return _isOSX.Value;
+        }
+#endif
+    }
+
+    /// <summary>
+    /// Gets a string for the current OS. This matches the OS env variable
+    /// for Windows (Windows_NT).
+    /// </summary>
+    internal static string OSName
+    {
+        get { return IsWindows ? "Windows_NT" : "Unix"; }
+    }
+
+    /// <summary>
+    /// OS name that can be used for the msbuildExtensionsPathSearchPaths element
+    /// for a toolset
+    /// </summary>
+    internal static string GetOSNameForExtensionsPath()
+    {
+        return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
+    }
+
+    internal static bool OSUsesCaseSensitivePaths
+    {
+        get { return IsLinux; }
+    }
+
+    /// <summary>
+    /// The base directory for all framework paths in Mono
+    /// </summary>
+    private static string s_frameworkBasePath;
+
+    /// <summary>
+    /// The directory of the current framework
+    /// </summary>
+    private static string s_frameworkCurrentPath;
+
+    /// <summary>
+    /// Gets the currently running framework path
+    /// </summary>
+    internal static string FrameworkCurrentPath
+    {
+        get
+        {
+            if (s_frameworkCurrentPath == null)
+            {
+                var baseTypeLocation = AssemblyUtilities.GetAssemblyLocation(typeof(string).GetTypeInfo().Assembly);
+
+                s_frameworkCurrentPath =
+                    Path.GetDirectoryName(baseTypeLocation)
+                    ?? string.Empty;
+            }
+
+            return s_frameworkCurrentPath;
+        }
+    }
+
+    /// <summary>
+    /// Gets the base directory of all Mono frameworks
+    /// </summary>
+    internal static string FrameworkBasePath
+    {
+        get
+        {
+            if (s_frameworkBasePath == null)
+            {
+                var dir = FrameworkCurrentPath;
+                if (dir != string.Empty)
+                {
+                    dir = Path.GetDirectoryName(dir);
+                }
+
+                s_frameworkBasePath = dir ?? string.Empty;
+            }
+
+            return s_frameworkBasePath;
+        }
+    }
+
+    /// <summary>
+    /// System information, initialized when required.
+    /// </summary>
+    /// <remarks>
+    /// Initially implemented as <see cref="Lazy{SystemInformationData}"/>, but
+    /// that's .NET 4+, and this is used in MSBuildTaskHost.
+    /// </remarks>
+    private static SystemInformationData SystemInformation
+    {
+        get
+        {
+            if (!_systemInformationInitialized)
+            {
+                lock (SystemInformationLock)
+                {
+                    if (!_systemInformationInitialized)
+                    {
+                        _systemInformation = new SystemInformationData();
+                        _systemInformationInitialized = true;
+                    }
+                }
+            }
+            return _systemInformation;
+        }
+    }
+
+    private static SystemInformationData _systemInformation;
+    private static bool _systemInformationInitialized;
+    private static readonly object SystemInformationLock = new object();
+
+    /// <summary>
+    /// Architecture getter
+    /// </summary>
+    internal static ProcessorArchitectures ProcessorArchitecture => SystemInformation.ProcessorArchitectureType;
+
+    /// <summary>
+    /// Native architecture getter
+    /// </summary>
+    internal static ProcessorArchitectures ProcessorArchitectureNative => SystemInformation.ProcessorArchitectureTypeNative;
+
+    #endregion
+
+    #region Wrapper methods
+
+    /// <summary>
+    /// Really truly non pumping wait.
+    /// Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
+    /// single SafeHandles.
+    /// </summary>
+    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
+    public static extern Int32 WaitForMultipleObjects(uint handle, IntPtr[] handles, bool waitAll, uint milliseconds);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern void GetSystemInfo(ref SYSTEM_INFO lpSystemInfo);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
+
+    /// <summary>
+    /// Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
+    /// if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
+    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, out DateTime fileModifiedTimeUtc)
+    {
+        // This code was copied from the reference manager, if there is a bug fix in that code, see if the same fix should also be made
+        // there
+        if (IsWindows)
+        {
+            fileModifiedTimeUtc = DateTime.MinValue;
+
+            WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+            bool success = GetFileAttributesEx(fullPath, 0, ref data);
+            if (success)
+            {
+                if ((data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
+                {
+                    long dt = ((long)(data.ftLastWriteTimeHigh) << 32) | ((long)data.ftLastWriteTimeLow);
+                    fileModifiedTimeUtc = DateTime.FromFileTimeUtc(dt);
+                }
+                else
+                {
+                    // Path does not point to a directory
+                    success = false;
+                }
+            }
+
+            return success;
+        }
+
+        if (Directory.Exists(fullPath))
+        {
+            fileModifiedTimeUtc = Directory.GetLastWriteTimeUtc(fullPath);
+            return true;
+        }
+        else
+        {
+            fileModifiedTimeUtc = DateTime.MinValue;
+            return false;
+        }
+    }
+
+    /// <summary>
+    /// Takes the path and returns the short path
+    /// </summary>
+    internal static string GetShortFilePath(string path)
+    {
+        if (!IsWindows)
+        {
+            return path;
+        }
+
+        if (path != null)
+        {
+            int length = GetShortPathName(path, null, 0);
+            int errorCode = Marshal.GetLastWin32Error();
+
+            if (length > 0)
+            {
+                StringBuilder fullPathBuffer = new StringBuilder(length);
+                length = GetShortPathName(path, fullPathBuffer, length);
+                errorCode = Marshal.GetLastWin32Error();
+
+                if (length > 0)
+                {
+                    string fullPath = fullPathBuffer.ToString();
+                    path = fullPath;
+                }
+            }
+
+            if (length == 0 && errorCode != 0)
+            {
+                ThrowExceptionForErrorCode(errorCode);
+            }
+        }
+
+        return path;
+    }
+
+    /// <summary>
+    /// Takes the path and returns a full path
+    /// </summary>
+    /// <param name="path"></param>
+    /// <returns></returns>
+    internal static string GetLongFilePath(string path)
+    {
+        if (IsUnixLike)
+        {
+            return path;
+        }
+
+        if (path != null)
+        {
+            int length = GetLongPathName(path, null, 0);
+            int errorCode = Marshal.GetLastWin32Error();
+
+            if (length > 0)
+            {
+                StringBuilder fullPathBuffer = new StringBuilder(length);
+                length = GetLongPathName(path, fullPathBuffer, length);
+                errorCode = Marshal.GetLastWin32Error();
+
+                if (length > 0)
+                {
+                    string fullPath = fullPathBuffer.ToString();
+                    path = fullPath;
+                }
+            }
+
+            if (length == 0 && errorCode != 0)
+            {
+                ThrowExceptionForErrorCode(errorCode);
+            }
+        }
+
+        return path;
+    }
+
+    /// <summary>
+    /// Retrieves the current global memory status.
+    /// </summary>
+    internal static MemoryStatus GetMemoryStatus()
+    {
+        if (IsWindows)
+        {
+            MemoryStatus status = new MemoryStatus();
+            bool returnValue = GlobalMemoryStatusEx(status);
+            if (!returnValue)
+            {
+                return null;
+            }
+
+            return status;
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    /// Get the last write time of the fullpath to the file.
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
+    /// <remarks>
+    /// This method should be accurate for regular files and symlinks, but can report incorrect data
+    /// if the file's content was modified by writing to it through a different link, unless
+    /// MSBUILDALWAYSCHECKCONTENTTIMESTAMP=1.
+    /// </remarks>
+    internal static DateTime GetLastWriteFileUtcTime(string fullPath)
+    {
+#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+        if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+        {
+            return LastWriteFileUtcTime(fullPath);
+        }
+
+        bool isNonModifiable = FileClassifier.Shared.IsNonModifiable(fullPath);
+        if (isNonModifiable)
+        {
+            if (ImmutableFilesTimestampCache.Shared.TryGetValue(fullPath, out DateTime modifiedAt))
+            {
+                return modifiedAt;
+            }
+        }
+
+        DateTime modifiedTime = LastWriteFileUtcTime(fullPath);
+
+        if (isNonModifiable && modifiedTime != DateTime.MinValue)
+        {
+            ImmutableFilesTimestampCache.Shared.TryAdd(fullPath, modifiedTime);
+        }
+
+        return modifiedTime;
+#else
+        return LastWriteFileUtcTime(fullPath);
+#endif
+
+        DateTime LastWriteFileUtcTime(string path)
+        {
+            DateTime fileModifiedTime = DateTime.MinValue;
+
+            if (IsWindows)
+            {
+                if (Traits.Instance.EscapeHatches.AlwaysUseContentTimestamp)
+                {
+                    return GetContentLastWriteFileUtcTime(path);
+                }
+
+                WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+                bool success = NativeMethods.GetFileAttributesEx(path, 0, ref data);
+
+                if (success && (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0)
+                {
+                    long dt = ((long) (data.ftLastWriteTimeHigh) << 32) | ((long) data.ftLastWriteTimeLow);
+                    fileModifiedTime = DateTime.FromFileTimeUtc(dt);
+
+                    // If file is a symlink _and_ we're not instructed to do the wrong thing, get a more accurate timestamp.
+                    if ((data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT && !Traits.Instance.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime)
+                    {
+                        fileModifiedTime = GetContentLastWriteFileUtcTime(path);
+                    }
+                }
+
+                return fileModifiedTime;
+            }
+            else
+            {
+                return File.Exists(path)
+                    ? File.GetLastWriteTimeUtc(path)
+                    : DateTime.MinValue;
+            }
+        }
+    }
+
+    /// <summary>
+    /// Get the last write time of the content pointed to by a file path.
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
+    /// <remarks>
+    /// This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
+    /// See https://github.com/Microsoft/msbuild/issues/2052.
+    /// </remarks>
+    private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
+    {
+        DateTime fileModifiedTime = DateTime.MinValue;
+
+        using (SafeFileHandle handle =
+            CreateFile(fullPath,
+                GENERIC_READ,
+                FILE_SHARE_READ,
+                IntPtr.Zero,
+                OPEN_EXISTING,
+                FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
+                IntPtr.Zero))
+        {
+            if (!handle.IsInvalid)
+            {
+                FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;
+                if (GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime))
+                {
+                    long fileTime = ((long)(uint)ftLastWriteTime.dwHighDateTime) << 32 |
+                                    (long)(uint)ftLastWriteTime.dwLowDateTime;
+                    fileModifiedTime =
+                        DateTime.FromFileTimeUtc(fileTime);
+                }
+            }
+        }
+
+        return fileModifiedTime;
+    }
+
+    /// <summary>
+    /// Did the HRESULT succeed
+    /// </summary>
+    public static bool HResultSucceeded(int hr)
+    {
+        return hr >= 0;
+    }
+
+    /// <summary>
+    /// Did the HRESULT Fail
+    /// </summary>
+    public static bool HResultFailed(int hr)
+    {
+        return hr < 0;
+    }
+
+    /// <summary>
+    /// Given an error code, converts it to an HRESULT and throws the appropriate exception.
+    /// </summary>
+    /// <param name="errorCode"></param>
+    public static void ThrowExceptionForErrorCode(int errorCode)
+    {
+        // See ndp\clr\src\bcl\system\io\__error.cs for this code as it appears in the CLR.
+
+        // Something really bad went wrong with the call
+        // translate the error into an exception
+
+        // Convert the errorcode into an HRESULT (See MakeHRFromErrorCode in Win32Native.cs in
+        // ndp\clr\src\bcl\microsoft\win32)
+        errorCode = unchecked(((int)0x80070000) | errorCode);
+
+        // Throw an exception as best we can
+        Marshal.ThrowExceptionForHR(errorCode);
+    }
+
+    /// <summary>
+    /// Kills the specified process by id and all of its children recursively.
+    /// </summary>
+    internal static void KillTree(int processIdToKill)
+    {
+        // Note that GetProcessById does *NOT* internally hold on to the process handle.
+        // Only when you create the process using the Process object
+        // does the Process object retain the original handle.
+
+        Process thisProcess;
+        try
+        {
+            thisProcess = Process.GetProcessById(processIdToKill);
+        }
+        catch (ArgumentException)
+        {
+            // The process has already died for some reason.  So shrug and assume that any child processes
+            // have all also either died or are in the process of doing so.
+            return;
+        }
+
+        try
+        {
+            DateTime myStartTime = thisProcess.StartTime;
+
+            // Grab the process handle.  We want to keep this open for the duration of the function so that
+            // it cannot be reused while we are running.
+            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill);
+            if (hProcess.IsInvalid)
+            {
+                return;
+            }
+
+            try
+            {
+                try
+                {
+                    // Kill this process, so that no further children can be created.
+                    thisProcess.Kill();
+                }
+                catch (Win32Exception e)
+                {
+                    // Access denied is potentially expected -- it happens when the process that
+                    // we're attempting to kill is already dead.  So just ignore in that case.
+                    if (e.NativeErrorCode != ERROR_ACCESS_DENIED)
+                    {
+                        throw;
+                    }
+                }
+
+                // Now enumerate our children.  Children of this process are any process which has this process id as its parent
+                // and which also started after this process did.
+                List<KeyValuePair<int, SafeProcessHandle>> children = GetChildProcessIds(processIdToKill, myStartTime);
+
+                try
+                {
+                    foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
+                    {
+                        KillTree(childProcessInfo.Key);
+                    }
+                }
+                finally
+                {
+                    foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
+                    {
+                        childProcessInfo.Value.Dispose();
+                    }
+                }
+            }
+            finally
+            {
+                // Release the handle.  After this point no more children of this process exist and this process has also exited.
+                hProcess.Dispose();
+            }
+        }
+        finally
+        {
+            thisProcess.Dispose();
+        }
+    }
+
+    /// <summary>
+    /// Returns the parent process id for the specified process.
+    /// Returns zero if it cannot be gotten for some reason.
+    /// </summary>
+    internal static int GetParentProcessId(int processId)
+    {
+        int ParentID = 0;
+#if !CLR2COMPATIBILITY
+        if (IsUnixLike)
+        {
+            string line = null;
+
+            try
+            {
+                // /proc/<processID>/stat returns a bunch of space separated fields. Get that string
+
+                // TODO: this was
+                // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
+                // and could be again when FileUtilities moves to Framework
+
+                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, FileAccess.Read);
+                using StreamReader r = new(fileStream);
+
+                line = r.ReadLine();
+            }
+            catch // Ignore errors since the process may have terminated
+            {
+            }
+
+            if (!string.IsNullOrWhiteSpace(line))
+            {
+                // One of the fields is the process name. It may contain any characters, but since it's
+                // in parenthesis, we can finds its end by looking for the last parenthesis. After that,
+                // there comes a space, then the second fields separated by a space is the parent id.
+                string[] statFields = line.Substring(line.LastIndexOf(')')).Split(MSBuildConstants.SpaceChar, 4);
+                if (statFields.Length >= 3)
+                {
+                    ParentID = Int32.Parse(statFields[2]);
+                }
+            }
+        }
+        else
+#endif
+        {
+            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
+
+            if (!hProcess.IsInvalid)
+            {
+                try
+                {
+                    // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
+                    // For now just return zero and worst case we will not kill some children.
+                    PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
+                    int pSize = 0;
+
+                    if (0 == NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, pbi.Size, ref pSize))
+                    {
+                        ParentID = (int)pbi.InheritedFromUniqueProcessId;
+                    }
+                }
+                finally
+                {
+                    hProcess.Dispose();
+                }
+            }
+        }
+
+        return ParentID;
+    }
+
+    /// <summary>
+    /// Returns an array of all the immediate child processes by id.
+    /// NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
+    /// </summary>
+    internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime)
+    {
+        List<KeyValuePair<int, SafeProcessHandle>> myChildren = new List<KeyValuePair<int, SafeProcessHandle>>();
+
+        foreach (Process possibleChildProcess in Process.GetProcesses())
+        {
+            using (possibleChildProcess)
+            {
+                // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.
+                // This way, any handle we pass back is guaranteed to be one of our actual children.
+                SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);
+                if (childHandle.IsInvalid)
+                {
+                    continue;
+                }
+
+                bool keepHandle = false;
+                try
+                {
+                    if (possibleChildProcess.StartTime > parentStartTime)
+                    {
+                        int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
+                        if (childParentProcessId != 0)
+                        {
+                            if (parentProcessId == childParentProcessId)
+                            {
+                                // Add this one
+                                myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
+                                keepHandle = true;
+                            }
+                        }
+                    }
+                }
+                finally
+                {
+                    if (!keepHandle)
+                    {
+                        childHandle.Dispose();
+                    }
+                }
+            }
+        }
+
+        return myChildren;
+    }
+
+    /// <summary>
+    /// Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
+    /// </summary>
+    /// <returns></returns>
+    internal unsafe static string GetCurrentDirectory()
+    {
+#if FEATURE_LEGACY_GETCURRENTDIRECTORY
+        if (IsWindows)
+        {
+            int bufferSize = GetCurrentDirectoryWin32(0, null);
+            char* buffer = stackalloc char[bufferSize];
+            int pathLength = GetCurrentDirectoryWin32(bufferSize, buffer);
+            return new string(buffer, startIndex: 0, length: pathLength);
+        }
+#endif
+        return Directory.GetCurrentDirectory();
+    }
+
+    private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBuffer)
+    {
+        int pathLength = GetCurrentDirectory(nBufferLength, lpBuffer);
+        VerifyThrowWin32Result(pathLength);
+        return pathLength;
+    }
+
+    internal unsafe static string GetFullPath(string path)
+    {
+        int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
+        char* buffer = stackalloc char[bufferSize];
+        int fullPathLength = GetFullPathWin32(path, bufferSize, buffer, IntPtr.Zero);
+        // Avoid creating new strings unnecessarily
+        return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
+    }
+
+    private unsafe static int GetFullPathWin32(string target, int bufferLength, char* buffer, IntPtr mustBeZero)
+    {
+        int pathLength = GetFullPathName(target, bufferLength, buffer, mustBeZero);
+        VerifyThrowWin32Result(pathLength);
+        return pathLength;
+    }
+
+    /// <summary>
+    /// Compare an unsafe char buffer with a <see cref="System.String"/> to see if their contents are identical.
+    /// </summary>
+    /// <param name="buffer">The beginning of the char buffer.</param>
+    /// <param name="len">The length of the buffer.</param>
+    /// <param name="s">The string.</param>
+    /// <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
+    private unsafe static bool AreStringsEqual(char* buffer, int len, string s)
+    {
+        if (len != s.Length)
+        {
+            return false;
+        }
+
+        foreach (char ch in s)
+        {
+            if (ch != *buffer++)
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    internal static void VerifyThrowWin32Result(int result)
+    {
+        bool isError = result == 0;
+        if (isError)
+        {
+            int code = Marshal.GetLastWin32Error();
+            ThrowExceptionForErrorCode(code);
+        }
+    }
+
+    #endregion
+
+    #region PInvoke
+
+    /// <summary>
+    /// Gets the current OEM code page which is used by console apps
+    /// (as opposed to the Windows/ANSI code page)
+    /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
+    /// that needs to be used for instance when writing to batch files
+    /// </summary>
+    [DllImport(kernel32Dll)]
+    internal static extern int GetOEMCP();
+
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);
+
+    [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
+    private static extern uint SearchPath
+    (
+        string path,
+        string fileName,
+        string extension,
+        int numBufferChars,
+        [Out] StringBuilder buffer,
+        int[] filePart
+    );
+
+    [DllImport("kernel32.dll", PreserveSig = true, SetLastError = true)]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool FreeLibrary([In] IntPtr module);
+
+    [DllImport("kernel32.dll", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true, CharSet = CharSet.Ansi, SetLastError = true)]
+    internal static extern IntPtr GetProcAddress(IntPtr module, string procName);
+
+    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, PreserveSig = true, SetLastError = true)]
+    internal static extern IntPtr LoadLibrary(string fileName);
+
+    [DllImport(mscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]
+    internal static extern uint GetRequestedRuntimeInfo(String pExe,
+                                            String pwszVersion,
+                                            String pConfigurationFile,
+                                            uint startupFlags,
+                                            uint runtimeInfoFlags,
+                                            [Out] StringBuilder pDirectory,
+                                            int dwDirectory,
+                                            out uint dwDirectoryLength,
+                                            [Out] StringBuilder pVersion,
+                                            int cchBuffer,
+                                            out uint dwlength);
+
+    /// <summary>
+    /// Gets the fully qualified filename of the currently executing .exe
+    /// </summary>
+    [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
+    internal static extern int GetModuleFileName(
+#if FEATURE_HANDLEREF
+            HandleRef hModule,
+#else
+            IntPtr hModule,
+#endif
+            [Out] StringBuilder buffer, int length);
+
+    [DllImport("kernel32.dll")]
+    internal static extern IntPtr GetStdHandle(int nStdHandle);
+
+    [DllImport("kernel32.dll")]
+    internal static extern uint GetFileType(IntPtr hFile);
+
+    [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    internal unsafe static extern int GetCurrentDirectory(int nBufferLength, char* lpBuffer);
+
+    [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = "SetCurrentDirectory")]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool SetCurrentDirectoryWindows(string path);
+
+    internal static bool SetCurrentDirectory(string path)
+    {
+        if (IsWindows)
+        {
+            return SetCurrentDirectoryWindows(path);
+        }
+
+        // Make sure this does not throw
+        try
+        {
+            Directory.SetCurrentDirectory(path);
+        }
+        catch
+        {
+        }
+        return true;
+    }
+
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    internal static unsafe extern int GetFullPathName(string target, int bufferLength, char* buffer, IntPtr mustBeZero);
+
+    [DllImport("KERNEL32.DLL")]
+    private static extern SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);
+
+    [DllImport("NTDLL.DLL")]
+    private static extern int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, ref PROCESS_BASIC_INFORMATION pbi, uint cb, ref int pSize);
+
+    [return: MarshalAs(UnmanagedType.Bool)]
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
+    private static extern bool GlobalMemoryStatusEx([In, Out] MemoryStatus lpBuffer);
+
+    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    internal static extern int GetShortPathName(string path, [Out] StringBuilder fullpath, [In] int length);
+
+    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    internal static extern int GetLongPathName([In] string path, [Out] StringBuilder fullpath, [In] int length);
+
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
+    internal static extern bool CreatePipe(out SafeFileHandle hReadPipe, out SafeFileHandle hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
+
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
+    internal static extern bool ReadFile(SafeFileHandle hFile, byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);
+
+    /// <summary>
+    /// CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
+    /// VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
+    /// build thread which the main thread (blocked on BuildSubmission.Execute) must service.
+    /// </summary>
+    [DllImport("ole32.dll")]
+    public static extern int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] pHandles, out int pdwIndex);
+
+    internal const uint GENERIC_READ = 0x80000000;
+    internal const uint FILE_SHARE_READ = 0x1;
+    internal const uint FILE_ATTRIBUTE_NORMAL = 0x80;
+    internal const uint FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;
+    internal const uint OPEN_EXISTING = 3;
+
+    [DllImport("kernel32.dll", CharSet = AutoOrUnicode, CallingConvention = CallingConvention.StdCall,
+        SetLastError = true)]
+    internal static extern SafeFileHandle CreateFile(
+        string lpFileName,
+        uint dwDesiredAccess,
+        uint dwShareMode,
+        IntPtr lpSecurityAttributes,
+        uint dwCreationDisposition,
+        uint dwFlagsAndAttributes,
+        IntPtr hTemplateFile
+        );
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern bool GetFileTime(
+        SafeFileHandle hFile,
+        out FILETIME lpCreationTime,
+        out FILETIME lpLastAccessTime,
+        out FILETIME lpLastWriteTime
+        );
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    [return: MarshalAs(UnmanagedType.Bool)]
+    internal static extern bool CloseHandle(IntPtr hObject);
+
+    [DllImport("kernel32.dll", SetLastError = true)]
+    internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
+
+    #endregion
+
+    #region Extensions
+
+    /// <summary>
+    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
+    /// servicing COM calls from other threads.
+    /// </summary>
+    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Scope = "member", Target = "Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.Int32)", Justification = "This is necessary and it has been used for a long time. No need to change it now.")]
+    internal static bool MsgWaitOne(this WaitHandle handle)
+    {
+        return handle.MsgWaitOne(Timeout.Infinite);
+    }
+
+    /// <summary>
+    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
+    /// servicing COM calls from other threads.
+    /// </summary>
+    internal static bool MsgWaitOne(this WaitHandle handle, TimeSpan timeout)
+    {
+        return MsgWaitOne(handle, (int)timeout.TotalMilliseconds);
+    }
+
+    /// <summary>
+    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
+    /// servicing COM calls from other threads.
+    /// </summary>
+    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Justification = "Necessary to avoid pumping")]
+    internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
+    {
+        // CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
+        // VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
+        // build thread which the main thread (blocked on BuildSubmission.Execute) must service.
+        int waitIndex;
+#if FEATURE_HANDLE_SAFEWAITHANDLE
+        IntPtr handlePtr = handle.SafeWaitHandle.DangerousGetHandle();
+#else
+            IntPtr handlePtr = handle.GetSafeWaitHandle().DangerousGetHandle();
+#endif
+        int returnValue = CoWaitForMultipleHandles(COWAIT_FLAGS.COWAIT_NONE, timeout, 1, new IntPtr[] { handlePtr }, out waitIndex);
+
+        if (!(returnValue == 0 || ((uint)returnValue == RPC_S_CALLPENDING && timeout != Timeout.Infinite)))
+        {
+           throw new InternalErrorException($"Received {returnValue} from CoWaitForMultipleHandles, but expected 0 (S_OK)");
+        }
+
+        return returnValue == 0;
+    }
+
+    #endregion
+
+    #region helper methods
+
+    internal static bool DirectoryExists(string fullPath)
+    {
+        return IsWindows
+            ? DirectoryExistsWindows(fullPath)
+            : Directory.Exists(fullPath);
+    }
+
+    internal static bool DirectoryExistsWindows(string fullPath)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+        bool success = GetFileAttributesEx(fullPath, 0, ref data);
+        return success && (data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
+    }
+
+    internal static bool FileExists(string fullPath)
+    {
+        return IsWindows
+            ? FileExistsWindows(fullPath)
+            : File.Exists(fullPath);
+    }
+
+    internal static bool FileExistsWindows(string fullPath)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+        bool success = GetFileAttributesEx(fullPath, 0, ref data);
+        return success && (data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0;
+    }
+
+    internal static bool FileOrDirectoryExists(string path)
+    {
+        return IsWindows
+            ? FileOrDirectoryExistsWindows(path)
+            : File.Exists(path) || Directory.Exists(path);
+    }
+
+    internal static bool FileOrDirectoryExistsWindows(string path)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+        return GetFileAttributesEx(path, 0, ref data);
+    }
+
+    #endregion
+
+}
diff --git a/src/Framework/ProjectFinishedEventArgs.cs b/src/Framework/ProjectFinishedEventArgs.cs
index 1aa08dbd263..77cedfe049d 100644
--- a/src/Framework/ProjectFinishedEventArgs.cs
+++ b/src/Framework/ProjectFinishedEventArgs.cs
@@ -116,13 +116,7 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
-                    {
-                        if (RawMessage == null)
-                        {
-                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? "ProjectFinishedSuccess" : "ProjectFinishedFailure", Path.GetFileName(ProjectFile));
-                        }
-                    }
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? "ProjectFinishedSuccess" : "ProjectFinishedFailure", Path.GetFileName(ProjectFile));
                 }
 
                 return RawMessage;
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 0de7b555f68..230d0629058 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -489,24 +489,18 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
+                    string projectFilePath = Path.GetFileName(ProjectFile);
+
+                    // Check to see if the there are any specific target names to be built.
+                    // If targetNames is null or empty then we will be building with the
+                    // default targets.
+                    if (!string.IsNullOrEmpty(TargetNames))
+                    {
+                        RawMessage = FormatResourceStringIgnoreCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", projectFilePath, TargetNames);
+                    }
+                    else
                     {
-                        if (RawMessage == null)
-                        {
-                            string projectFilePath = Path.GetFileName(ProjectFile);
-
-                            // Check to see if the there are any specific target names to be built.
-                            // If targetNames is null or empty then we will be building with the 
-                            // default targets.
-                            if (!string.IsNullOrEmpty(TargetNames))
-                            {
-                                RawMessage = FormatResourceStringIgnoreCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", projectFilePath, TargetNames);
-                            }
-                            else
-                            {
-                                RawMessage = FormatResourceStringIgnoreCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", projectFilePath);
-                            }
-                        }
+                        RawMessage = FormatResourceStringIgnoreCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", projectFilePath);
                     }
                 }
 
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 5ab3c12ac9a..79b1e377c75 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -45,6 +45,11 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+// Ideally we wouldn't need to IVT to OM.UnitTests, which is supposed to test
+// only the public surface area of Microsoft.Build. However, there's a bunch
+// of shared code in Framework that's used there, and we can still avoid IVT
+// from Microsoft.Build to OM.UnitTests.
+[assembly: InternalsVisibleTo("Microsoft.Build.Engine.OM.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 42642a593bd..8820254215f 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -71,13 +71,7 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
-                    {
-                        if (RawMessage == null)
-                        {
-                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyReassignment", PropertyName, NewValue, PreviousValue, Location);
-                        }
-                    }
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyReassignment", PropertyName, NewValue, PreviousValue, Location);
                 }
 
                 return RawMessage;
diff --git a/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt b/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..4ba35aaf1b9
--- /dev/null
+++ b/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt
@@ -0,0 +1,919 @@
+abstract Microsoft.Build.Framework.SdkLogger.LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+abstract Microsoft.Build.Framework.SdkResolver.Name.get -> string
+abstract Microsoft.Build.Framework.SdkResolver.Priority.get -> int
+abstract Microsoft.Build.Framework.SdkResolver.Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory) -> Microsoft.Build.Framework.SdkResult
+abstract Microsoft.Build.Framework.SdkResultFactory.IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
+abstract Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
+const Microsoft.Build.Framework.BuildEventContext.InvalidEvaluationId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidNodeId = -2 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidProjectContextId = -2 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidProjectInstanceId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidSubmissionId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidTargetId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidTaskId = -1 -> int
+const Microsoft.Build.Framework.EngineServices.Version1 = 1 -> int
+const Microsoft.Build.Framework.ProjectStartedEventArgs.InvalidProjectId = -1 -> int
+Microsoft.Build.Framework.AnyEventHandler
+Microsoft.Build.Framework.BuildEngineResult
+Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult() -> void
+Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) -> void
+Microsoft.Build.Framework.BuildEngineResult.Result.get -> bool
+Microsoft.Build.Framework.BuildEngineResult.TargetOutputsPerProject.get -> System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>>
+Microsoft.Build.Framework.BuildErrorEventArgs
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs() -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.Code.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.EndColumnNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.EndLineNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.File.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.HelpLink.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.Subcategory.get -> string
+Microsoft.Build.Framework.BuildErrorEventHandler
+Microsoft.Build.Framework.BuildEventArgs
+Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs() -> void
+Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.set -> void
+Microsoft.Build.Framework.BuildEventArgs.HelpKeyword.get -> string
+Microsoft.Build.Framework.BuildEventArgs.RawMessage.get -> string
+Microsoft.Build.Framework.BuildEventArgs.RawMessage.set -> void
+Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.get -> System.DateTime
+Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.set -> void
+Microsoft.Build.Framework.BuildEventArgs.SenderName.get -> string
+Microsoft.Build.Framework.BuildEventArgs.ThreadId.get -> int
+Microsoft.Build.Framework.BuildEventArgs.Timestamp.get -> System.DateTime
+Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildRequestId.get -> long
+Microsoft.Build.Framework.BuildEventContext.EvaluationId.get -> int
+Microsoft.Build.Framework.BuildEventContext.NodeId.get -> int
+Microsoft.Build.Framework.BuildEventContext.ProjectContextId.get -> int
+Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId.get -> int
+Microsoft.Build.Framework.BuildEventContext.SubmissionId.get -> int
+Microsoft.Build.Framework.BuildEventContext.TargetId.get -> int
+Microsoft.Build.Framework.BuildEventContext.TaskId.get -> int
+Microsoft.Build.Framework.BuildFinishedEventArgs
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs() -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.BuildFinishedEventHandler
+Microsoft.Build.Framework.BuildMessageEventArgs
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs() -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.Code.get -> string
+Microsoft.Build.Framework.BuildMessageEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.EndColumnNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.EndLineNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.File.get -> string
+Microsoft.Build.Framework.BuildMessageEventArgs.Importance.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.BuildMessageEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.Subcategory.get -> string
+Microsoft.Build.Framework.BuildMessageEventHandler
+Microsoft.Build.Framework.BuildStartedEventArgs
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs() -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword) -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildStartedEventHandler
+Microsoft.Build.Framework.BuildStatusEventArgs
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs() -> void
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildStatusEventHandler
+Microsoft.Build.Framework.BuildWarningEventArgs
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs() -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.Code.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.EndColumnNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.EndLineNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.File.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.HelpLink.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.Subcategory.get -> string
+Microsoft.Build.Framework.BuildWarningEventHandler
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs() -> void
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.CustomBuildEventArgs
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs() -> void
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.CustomBuildEventHandler
+Microsoft.Build.Framework.EngineServices
+Microsoft.Build.Framework.EngineServices.EngineServices() -> void
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.get -> string
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.set -> void
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs() -> void
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs() -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs() -> void
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) -> void
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.TargetNames.get -> string
+Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Framework.IBuildEngine.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs) -> bool
+Microsoft.Build.Framework.IBuildEngine.ColumnNumberOfTaskNode.get -> int
+Microsoft.Build.Framework.IBuildEngine.ContinueOnError.get -> bool
+Microsoft.Build.Framework.IBuildEngine.LineNumberOfTaskNode.get -> int
+Microsoft.Build.Framework.IBuildEngine.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.ProjectFileOfTaskNode.get -> string
+Microsoft.Build.Framework.IBuildEngine10
+Microsoft.Build.Framework.IBuildEngine10.EngineServices.get -> Microsoft.Build.Framework.EngineServices
+Microsoft.Build.Framework.IBuildEngine2
+Microsoft.Build.Framework.IBuildEngine2.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion) -> bool
+Microsoft.Build.Framework.IBuildEngine2.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion) -> bool
+Microsoft.Build.Framework.IBuildEngine2.IsRunningMultipleNodes.get -> bool
+Microsoft.Build.Framework.IBuildEngine3
+Microsoft.Build.Framework.IBuildEngine3.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs) -> Microsoft.Build.Framework.BuildEngineResult
+Microsoft.Build.Framework.IBuildEngine3.Reacquire() -> void
+Microsoft.Build.Framework.IBuildEngine3.Yield() -> void
+Microsoft.Build.Framework.IBuildEngine4
+Microsoft.Build.Framework.IBuildEngine4.GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
+Microsoft.Build.Framework.IBuildEngine4.RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection) -> void
+Microsoft.Build.Framework.IBuildEngine4.UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
+Microsoft.Build.Framework.IBuildEngine5
+Microsoft.Build.Framework.IBuildEngine5.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
+Microsoft.Build.Framework.IBuildEngine6
+Microsoft.Build.Framework.IBuildEngine6.GetGlobalProperties() -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.Framework.IBuildEngine7
+Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.get -> bool
+Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.set -> void
+Microsoft.Build.Framework.IBuildEngine8
+Microsoft.Build.Framework.IBuildEngine8.ShouldTreatWarningAsError(string warningCode) -> bool
+Microsoft.Build.Framework.IBuildEngine9
+Microsoft.Build.Framework.IBuildEngine9.ReleaseCores(int coresToRelease) -> void
+Microsoft.Build.Framework.IBuildEngine9.RequestCores(int requestedCores) -> int
+Microsoft.Build.Framework.ICancelableTask
+Microsoft.Build.Framework.ICancelableTask.Cancel() -> void
+Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Framework.IEventRedirector.ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
+Microsoft.Build.Framework.IEventSource
+Microsoft.Build.Framework.IEventSource.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
+Microsoft.Build.Framework.IEventSource.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
+Microsoft.Build.Framework.IEventSource.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
+Microsoft.Build.Framework.IEventSource.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
+Microsoft.Build.Framework.IEventSource.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
+Microsoft.Build.Framework.IEventSource.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
+Microsoft.Build.Framework.IEventSource.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
+Microsoft.Build.Framework.IEventSource.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
+Microsoft.Build.Framework.IEventSource.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
+Microsoft.Build.Framework.IEventSource.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
+Microsoft.Build.Framework.IEventSource2
+Microsoft.Build.Framework.IEventSource2.TelemetryLogged -> Microsoft.Build.Framework.TelemetryEventHandler
+Microsoft.Build.Framework.IEventSource3
+Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects() -> void
+Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles() -> void
+Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs() -> void
+Microsoft.Build.Framework.IEventSource4
+Microsoft.Build.Framework.IEventSource4.IncludeEvaluationPropertiesAndItems() -> void
+Microsoft.Build.Framework.IForwardingLogger
+Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.set -> void
+Microsoft.Build.Framework.IForwardingLogger.NodeId.get -> int
+Microsoft.Build.Framework.IForwardingLogger.NodeId.set -> void
+Microsoft.Build.Framework.IGeneratedTask
+Microsoft.Build.Framework.IGeneratedTask.GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property) -> object
+Microsoft.Build.Framework.IGeneratedTask.SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value) -> void
+Microsoft.Build.Framework.ILogger
+Microsoft.Build.Framework.ILogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Framework.ILogger.Parameters.get -> string
+Microsoft.Build.Framework.ILogger.Parameters.set -> void
+Microsoft.Build.Framework.ILogger.Shutdown() -> void
+Microsoft.Build.Framework.ILogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.ILogger.Verbosity.set -> void
+Microsoft.Build.Framework.INodeLogger
+Microsoft.Build.Framework.INodeLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.Framework.IProjectElement
+Microsoft.Build.Framework.IProjectElement.ElementName.get -> string
+Microsoft.Build.Framework.IProjectElement.OuterElement.get -> string
+Microsoft.Build.Framework.ITask
+Microsoft.Build.Framework.ITask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Framework.ITask.BuildEngine.set -> void
+Microsoft.Build.Framework.ITask.Execute() -> bool
+Microsoft.Build.Framework.ITask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Framework.ITask.HostObject.set -> void
+Microsoft.Build.Framework.ITaskFactory
+Microsoft.Build.Framework.ITaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Framework.ITaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Framework.ITaskFactory.FactoryName.get -> string
+Microsoft.Build.Framework.ITaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Framework.ITaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Framework.ITaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Framework.ITaskFactory2
+Microsoft.Build.Framework.ITaskFactory2.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Framework.ITaskFactory2.Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
+Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
+Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) -> string
+Microsoft.Build.Framework.ITaskItem.ItemSpec.get -> string
+Microsoft.Build.Framework.ITaskItem.ItemSpec.set -> void
+Microsoft.Build.Framework.ITaskItem.MetadataCount.get -> int
+Microsoft.Build.Framework.ITaskItem.MetadataNames.get -> System.Collections.ICollection
+Microsoft.Build.Framework.ITaskItem.RemoveMetadata(string metadataName) -> void
+Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) -> void
+Microsoft.Build.Framework.ITaskItem2
+Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() -> System.Collections.IDictionary
+Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.get -> string
+Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.set -> void
+Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) -> string
+Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) -> void
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs() -> void
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute
+Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute.LoadInSeparateAppDomainAttribute() -> void
+Microsoft.Build.Framework.LoggerException
+Microsoft.Build.Framework.LoggerException.ErrorCode.get -> string
+Microsoft.Build.Framework.LoggerException.HelpKeyword.get -> string
+Microsoft.Build.Framework.LoggerException.LoggerException() -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(string message) -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException) -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Detailed = 3 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Diagnostic = 4 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Minimal = 1 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Normal = 2 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Quiet = 0 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MessageImportance.High = 0 -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MessageImportance.Low = 2 -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MessageImportance.Normal = 1 -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MetaprojectGeneratedEventArgs
+Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) -> void
+Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.metaprojectXml -> string
+Microsoft.Build.Framework.OutputAttribute
+Microsoft.Build.Framework.OutputAttribute.OutputAttribute() -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementDescription.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementName.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation() -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPass.get -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPassDescription.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.File.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.Id.get -> long
+Microsoft.Build.Framework.Profiler.EvaluationLocation.IsEvaluationPass.get -> bool
+Microsoft.Build.Framework.Profiler.EvaluationLocation.Kind.get -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocation.Line.get -> int?
+Microsoft.Build.Framework.Profiler.EvaluationLocation.ParentId.get -> long?
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFile(string file) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndCondition(string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithGlob(string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithParentId(long? parentId) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Condition = 1 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Element = 0 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Glob = 2 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.InitialProperties = 2 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.ItemDefinitionGroups = 4 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.Items = 5 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.LazyItems = 6 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.Properties = 3 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.Targets = 8 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.TotalEvaluation = 0 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.TotalGlobbing = 1 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.UsingTasks = 7 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.ProfiledLocation
+Microsoft.Build.Framework.Profiler.ProfiledLocation.ExclusiveTime.get -> System.TimeSpan
+Microsoft.Build.Framework.Profiler.ProfiledLocation.InclusiveTime.get -> System.TimeSpan
+Microsoft.Build.Framework.Profiler.ProfiledLocation.NumberOfHits.get -> int
+Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation() -> void
+Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) -> void
+Microsoft.Build.Framework.Profiler.ProfilerResult
+Microsoft.Build.Framework.Profiler.ProfilerResult.ProfiledLocations.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation>
+Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult() -> void
+Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.get -> Microsoft.Build.Framework.Profiler.ProfilerResult?
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs() -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.set -> void
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs() -> void
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs() -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.ProjectFinishedEventHandler
+Microsoft.Build.Framework.ProjectImportedEventArgs
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.get -> string
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.set -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.get -> bool
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.set -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs() -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.get -> string
+Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.set -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs
+Microsoft.Build.Framework.ProjectStartedEventArgs.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Framework.ProjectStartedEventArgs.Items.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectStartedEventArgs.ParentProjectBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectId.get -> int
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs() -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.Properties.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectStartedEventArgs.TargetNames.get -> string
+Microsoft.Build.Framework.ProjectStartedEventArgs.ToolsVersion.get -> string
+Microsoft.Build.Framework.ProjectStartedEventHandler
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs() -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.get -> string
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.set -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.get -> string
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.set -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.get -> string
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs() -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+Microsoft.Build.Framework.RegisteredTaskObjectLifetime
+Microsoft.Build.Framework.RegisteredTaskObjectLifetime.AppDomain = 1 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
+Microsoft.Build.Framework.RegisteredTaskObjectLifetime.Build = 0 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
+Microsoft.Build.Framework.RequiredAttribute
+Microsoft.Build.Framework.RequiredAttribute.RequiredAttribute() -> void
+Microsoft.Build.Framework.RequiredRuntimeAttribute
+Microsoft.Build.Framework.RequiredRuntimeAttribute.RequiredRuntimeAttribute(string runtimeVersion) -> void
+Microsoft.Build.Framework.RequiredRuntimeAttribute.RuntimeVersion.get -> string
+Microsoft.Build.Framework.RunInMTAAttribute
+Microsoft.Build.Framework.RunInMTAAttribute.RunInMTAAttribute() -> void
+Microsoft.Build.Framework.RunInSTAAttribute
+Microsoft.Build.Framework.RunInSTAAttribute.RunInSTAAttribute() -> void
+Microsoft.Build.Framework.SdkLogger
+Microsoft.Build.Framework.SdkLogger.SdkLogger() -> void
+Microsoft.Build.Framework.SdkReference
+Microsoft.Build.Framework.SdkReference.Equals(Microsoft.Build.Framework.SdkReference other) -> bool
+Microsoft.Build.Framework.SdkReference.MinimumVersion.get -> string
+Microsoft.Build.Framework.SdkReference.Name.get -> string
+Microsoft.Build.Framework.SdkReference.SdkReference(string name, string version, string minimumVersion) -> void
+Microsoft.Build.Framework.SdkReference.Version.get -> string
+Microsoft.Build.Framework.SdkResolver
+Microsoft.Build.Framework.SdkResolver.SdkResolver() -> void
+Microsoft.Build.Framework.SdkResolverContext
+Microsoft.Build.Framework.SdkResolverContext.SdkResolverContext() -> void
+Microsoft.Build.Framework.SdkResult
+Microsoft.Build.Framework.SdkResult.SdkResult() -> void
+Microsoft.Build.Framework.SdkResultFactory
+Microsoft.Build.Framework.SdkResultFactory.SdkResultFactory() -> void
+Microsoft.Build.Framework.SdkResultItem
+Microsoft.Build.Framework.SdkResultItem.ItemSpec.get -> string
+Microsoft.Build.Framework.SdkResultItem.ItemSpec.set -> void
+Microsoft.Build.Framework.SdkResultItem.Metadata.get -> System.Collections.Generic.Dictionary<string, string>
+Microsoft.Build.Framework.SdkResultItem.SdkResultItem() -> void
+Microsoft.Build.Framework.SdkResultItem.SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) -> void
+Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.AfterTargets = 3 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.BeforeTargets = 1 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.DependsOn = 2 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.None = 0 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetFinishedEventArgs
+Microsoft.Build.Framework.TargetFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TargetFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFile.get -> string
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs() -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetName.get -> string
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.set -> void
+Microsoft.Build.Framework.TargetFinishedEventHandler
+Microsoft.Build.Framework.TargetSkippedEventArgs
+Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.get -> bool
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.get -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs() -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs(string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.ConditionWasFalse = 4 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.None = 0 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.OutputsUpToDate = 3 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltSuccessfully = 1 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltUnsuccessfully = 2 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetStartedEventArgs
+Microsoft.Build.Framework.TargetStartedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetStartedEventArgs.ParentTarget.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetFile.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetName.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs() -> void
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) -> void
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TargetStartedEventHandler
+Microsoft.Build.Framework.TaskCommandLineEventArgs
+Microsoft.Build.Framework.TaskCommandLineEventArgs.CommandLine.get -> string
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs() -> void
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskName.get -> string
+Microsoft.Build.Framework.TaskFinishedEventArgs
+Microsoft.Build.Framework.TaskFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TaskFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFile.get -> string
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs() -> void
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) -> void
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskName.get -> string
+Microsoft.Build.Framework.TaskFinishedEventHandler
+Microsoft.Build.Framework.TaskParameterEventArgs
+Microsoft.Build.Framework.TaskParameterEventArgs.Items.get -> System.Collections.IList
+Microsoft.Build.Framework.TaskParameterEventArgs.ItemType.get -> string
+Microsoft.Build.Framework.TaskParameterEventArgs.Kind.get -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterEventArgs.LogItemMetadata.get -> bool
+Microsoft.Build.Framework.TaskParameterEventArgs.TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.AddItem = 2 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.RemoveItem = 3 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetInputs = 4 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetOutputs = 5 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.TaskInput = 0 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.TaskOutput = 1 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskPropertyInfo
+Microsoft.Build.Framework.TaskPropertyInfo.Log.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.Log.set -> void
+Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.set -> void
+Microsoft.Build.Framework.TaskPropertyInfo.Name.get -> string
+Microsoft.Build.Framework.TaskPropertyInfo.Output.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.PropertyType.get -> System.Type
+Microsoft.Build.Framework.TaskPropertyInfo.Required.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) -> void
+Microsoft.Build.Framework.TaskStartedEventArgs
+Microsoft.Build.Framework.TaskStartedEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.TaskStartedEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.TaskStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskFile.get -> string
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskName.get -> string
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs() -> void
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) -> void
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskStartedEventHandler
+Microsoft.Build.Framework.TelemetryEventArgs
+Microsoft.Build.Framework.TelemetryEventArgs.EventName.get -> string
+Microsoft.Build.Framework.TelemetryEventArgs.EventName.set -> void
+Microsoft.Build.Framework.TelemetryEventArgs.Properties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Framework.TelemetryEventArgs.Properties.set -> void
+Microsoft.Build.Framework.TelemetryEventArgs.TelemetryEventArgs() -> void
+Microsoft.Build.Framework.TelemetryEventHandler
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.get -> string
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.set -> void
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs() -> void
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+Microsoft.Build.Framework.XamlTypes.Argument
+Microsoft.Build.Framework.XamlTypes.Argument.Argument() -> void
+Microsoft.Build.Framework.XamlTypes.Argument.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.Argument.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.Argument.IsRequired.get -> bool
+Microsoft.Build.Framework.XamlTypes.Argument.IsRequired.set -> void
+Microsoft.Build.Framework.XamlTypes.Argument.Property.get -> string
+Microsoft.Build.Framework.XamlTypes.Argument.Property.set -> void
+Microsoft.Build.Framework.XamlTypes.Argument.Separator.get -> string
+Microsoft.Build.Framework.XamlTypes.Argument.Separator.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Arguments.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument>
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Arguments.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.BaseProperty() -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Category.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Category.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.ContainingRule.get -> Microsoft.Build.Framework.XamlTypes.Rule
+Microsoft.Build.Framework.XamlTypes.BaseProperty.DataSource.get -> Microsoft.Build.Framework.XamlTypes.DataSource
+Microsoft.Build.Framework.XamlTypes.BaseProperty.DataSource.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Default.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Default.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Description.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Description.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.DisplayName.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.DisplayName.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.F1Keyword.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.F1Keyword.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpContext.get -> int
+Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpContext.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpFile.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpFile.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpUrl.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpUrl.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.IncludeInCommandLine.get -> bool
+Microsoft.Build.Framework.XamlTypes.BaseProperty.IncludeInCommandLine.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.IsRequired.get -> bool
+Microsoft.Build.Framework.XamlTypes.BaseProperty.IsRequired.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Metadata.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.MultipleValuesAllowed.get -> bool
+Microsoft.Build.Framework.XamlTypes.BaseProperty.MultipleValuesAllowed.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.ReadOnly.get -> bool
+Microsoft.Build.Framework.XamlTypes.BaseProperty.ReadOnly.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Separator.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Separator.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Subcategory.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Subcategory.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Switch.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Switch.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.SwitchPrefix.get -> string
+Microsoft.Build.Framework.XamlTypes.BaseProperty.SwitchPrefix.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.ValueEditors.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.ValueEditor>
+Microsoft.Build.Framework.XamlTypes.BaseProperty.ValueEditors.set -> void
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Visible.get -> bool
+Microsoft.Build.Framework.XamlTypes.BaseProperty.Visible.set -> void
+Microsoft.Build.Framework.XamlTypes.BoolProperty
+Microsoft.Build.Framework.XamlTypes.BoolProperty.BoolProperty() -> void
+Microsoft.Build.Framework.XamlTypes.BoolProperty.ReverseSwitch.get -> string
+Microsoft.Build.Framework.XamlTypes.BoolProperty.ReverseSwitch.set -> void
+Microsoft.Build.Framework.XamlTypes.Category
+Microsoft.Build.Framework.XamlTypes.Category.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.Category.Category() -> void
+Microsoft.Build.Framework.XamlTypes.Category.Description.get -> string
+Microsoft.Build.Framework.XamlTypes.Category.Description.set -> void
+Microsoft.Build.Framework.XamlTypes.Category.DisplayName.get -> string
+Microsoft.Build.Framework.XamlTypes.Category.DisplayName.set -> void
+Microsoft.Build.Framework.XamlTypes.Category.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.Category.HelpString.get -> string
+Microsoft.Build.Framework.XamlTypes.Category.HelpString.set -> void
+Microsoft.Build.Framework.XamlTypes.Category.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.Category.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.Category.Subtype.get -> string
+Microsoft.Build.Framework.XamlTypes.Category.Subtype.set -> void
+Microsoft.Build.Framework.XamlTypes.CategorySchema
+Microsoft.Build.Framework.XamlTypes.CategorySchema.CategorySchema() -> void
+Microsoft.Build.Framework.XamlTypes.ContentType
+Microsoft.Build.Framework.XamlTypes.ContentType.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.ContentType() -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.DefaultContentTypeForItemType.get -> bool
+Microsoft.Build.Framework.XamlTypes.ContentType.DefaultContentTypeForItemType.set -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.DisplayName.get -> string
+Microsoft.Build.Framework.XamlTypes.ContentType.DisplayName.set -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.GetMetadata(string metadataName) -> string
+Microsoft.Build.Framework.XamlTypes.ContentType.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
+Microsoft.Build.Framework.XamlTypes.ContentType.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
+Microsoft.Build.Framework.XamlTypes.ContentType.ItemGroupName.get -> string
+Microsoft.Build.Framework.XamlTypes.ContentType.ItemGroupName.set -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.ItemType.get -> string
+Microsoft.Build.Framework.XamlTypes.ContentType.ItemType.set -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
+Microsoft.Build.Framework.XamlTypes.ContentType.Metadata.set -> void
+Microsoft.Build.Framework.XamlTypes.ContentType.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.ContentType.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource
+Microsoft.Build.Framework.XamlTypes.DataSource.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.DataSource() -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.HasConfigurationCondition.get -> bool
+Microsoft.Build.Framework.XamlTypes.DataSource.HasConfigurationCondition.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.ItemType.get -> string
+Microsoft.Build.Framework.XamlTypes.DataSource.ItemType.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.Label.get -> string
+Microsoft.Build.Framework.XamlTypes.DataSource.Label.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.MSBuildTarget.get -> string
+Microsoft.Build.Framework.XamlTypes.DataSource.MSBuildTarget.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.PersistedName.get -> string
+Microsoft.Build.Framework.XamlTypes.DataSource.PersistedName.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.Persistence.get -> string
+Microsoft.Build.Framework.XamlTypes.DataSource.Persistence.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.PersistenceStyle.get -> string
+Microsoft.Build.Framework.XamlTypes.DataSource.PersistenceStyle.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.SourceOfDefaultValue.get -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
+Microsoft.Build.Framework.XamlTypes.DataSource.SourceOfDefaultValue.set -> void
+Microsoft.Build.Framework.XamlTypes.DataSource.SourceType.get -> string
+Microsoft.Build.Framework.XamlTypes.DataSource.SourceType.set -> void
+Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
+Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation.AfterContext = 1 -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
+Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation.BeforeContext = 0 -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
+Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty
+Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.DynamicEnumProperty() -> void
+Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.EnumProvider.get -> string
+Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.EnumProvider.set -> void
+Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.ProviderSettings.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
+Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.ProviderSettings.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumProperty
+Microsoft.Build.Framework.XamlTypes.EnumProperty.AdmissibleValues.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.EnumValue>
+Microsoft.Build.Framework.XamlTypes.EnumProperty.AdmissibleValues.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumProperty.EnumProperty() -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue
+Microsoft.Build.Framework.XamlTypes.EnumValue.Arguments.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument>
+Microsoft.Build.Framework.XamlTypes.EnumValue.Arguments.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.Description.get -> string
+Microsoft.Build.Framework.XamlTypes.EnumValue.Description.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.DisplayName.get -> string
+Microsoft.Build.Framework.XamlTypes.EnumValue.DisplayName.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.EnumValue() -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.HelpString.get -> string
+Microsoft.Build.Framework.XamlTypes.EnumValue.HelpString.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.IsDefault.get -> bool
+Microsoft.Build.Framework.XamlTypes.EnumValue.IsDefault.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
+Microsoft.Build.Framework.XamlTypes.EnumValue.Metadata.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.EnumValue.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.Switch.get -> string
+Microsoft.Build.Framework.XamlTypes.EnumValue.Switch.set -> void
+Microsoft.Build.Framework.XamlTypes.EnumValue.SwitchPrefix.get -> string
+Microsoft.Build.Framework.XamlTypes.EnumValue.SwitchPrefix.set -> void
+Microsoft.Build.Framework.XamlTypes.FileExtension
+Microsoft.Build.Framework.XamlTypes.FileExtension.ContentType.get -> string
+Microsoft.Build.Framework.XamlTypes.FileExtension.ContentType.set -> void
+Microsoft.Build.Framework.XamlTypes.FileExtension.FileExtension() -> void
+Microsoft.Build.Framework.XamlTypes.FileExtension.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
+Microsoft.Build.Framework.XamlTypes.FileExtension.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
+Microsoft.Build.Framework.XamlTypes.FileExtension.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.FileExtension.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.IntProperty
+Microsoft.Build.Framework.XamlTypes.IntProperty.IntProperty() -> void
+Microsoft.Build.Framework.XamlTypes.IntProperty.MaxValue.get -> int?
+Microsoft.Build.Framework.XamlTypes.IntProperty.MaxValue.set -> void
+Microsoft.Build.Framework.XamlTypes.IntProperty.MinValue.get -> int?
+Microsoft.Build.Framework.XamlTypes.IntProperty.MinValue.set -> void
+Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode
+Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
+Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
+Microsoft.Build.Framework.XamlTypes.ItemType
+Microsoft.Build.Framework.XamlTypes.ItemType.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.ItemType.DefaultContentType.get -> string
+Microsoft.Build.Framework.XamlTypes.ItemType.DefaultContentType.set -> void
+Microsoft.Build.Framework.XamlTypes.ItemType.DisplayName.get -> string
+Microsoft.Build.Framework.XamlTypes.ItemType.DisplayName.set -> void
+Microsoft.Build.Framework.XamlTypes.ItemType.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.ItemType.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
+Microsoft.Build.Framework.XamlTypes.ItemType.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
+Microsoft.Build.Framework.XamlTypes.ItemType.ItemType() -> void
+Microsoft.Build.Framework.XamlTypes.ItemType.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.ItemType.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.ItemType.UpToDateCheckInput.get -> bool
+Microsoft.Build.Framework.XamlTypes.ItemType.UpToDateCheckInput.set -> void
+Microsoft.Build.Framework.XamlTypes.NameValuePair
+Microsoft.Build.Framework.XamlTypes.NameValuePair.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.NameValuePair.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.NameValuePair.NameValuePair() -> void
+Microsoft.Build.Framework.XamlTypes.NameValuePair.Value.get -> string
+Microsoft.Build.Framework.XamlTypes.NameValuePair.Value.set -> void
+Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions
+Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
+Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
+Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.Nodes.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode>
+Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.Nodes.set -> void
+Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.ProjectSchemaDefinitions() -> void
+Microsoft.Build.Framework.XamlTypes.Rule
+Microsoft.Build.Framework.XamlTypes.Rule.AdditionalInputs.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.AdditionalInputs.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Categories.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category>
+Microsoft.Build.Framework.XamlTypes.Rule.Categories.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.CommandLine.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.CommandLine.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.DataSource.get -> Microsoft.Build.Framework.XamlTypes.DataSource
+Microsoft.Build.Framework.XamlTypes.Rule.DataSource.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Description.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.Description.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.DisplayName.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.DisplayName.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.Rule.EvaluatedCategories.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category>
+Microsoft.Build.Framework.XamlTypes.Rule.ExecutionDescription.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.ExecutionDescription.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.FileExtension.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.FileExtension.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.GetPropertiesByCategory() -> System.Collections.Specialized.OrderedDictionary
+Microsoft.Build.Framework.XamlTypes.Rule.GetPropertiesInCategory(string categoryName) -> System.Collections.Generic.IList<Microsoft.Build.Framework.XamlTypes.BaseProperty>
+Microsoft.Build.Framework.XamlTypes.Rule.GetProperty(string propertyName) -> Microsoft.Build.Framework.XamlTypes.BaseProperty
+Microsoft.Build.Framework.XamlTypes.Rule.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
+Microsoft.Build.Framework.XamlTypes.Rule.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
+Microsoft.Build.Framework.XamlTypes.Rule.HelpString.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.HelpString.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Metadata.get -> System.Collections.Generic.Dictionary<string, object>
+Microsoft.Build.Framework.XamlTypes.Rule.Metadata.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Name.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.Name.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Order.get -> int
+Microsoft.Build.Framework.XamlTypes.Rule.Order.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Outputs.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.Outputs.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.OverrideMode.get -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
+Microsoft.Build.Framework.XamlTypes.Rule.OverrideMode.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.PageTemplate.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.PageTemplate.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Properties.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.BaseProperty>
+Microsoft.Build.Framework.XamlTypes.Rule.Properties.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.PropertyPagesHidden.get -> bool
+Microsoft.Build.Framework.XamlTypes.Rule.PropertyPagesHidden.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Rule() -> void
+Microsoft.Build.Framework.XamlTypes.Rule.Separator.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.Separator.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.ShowOnlyRuleProperties.get -> bool
+Microsoft.Build.Framework.XamlTypes.Rule.ShowOnlyRuleProperties.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.SupportsFileBatching.get -> bool
+Microsoft.Build.Framework.XamlTypes.Rule.SupportsFileBatching.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.SwitchPrefix.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.SwitchPrefix.set -> void
+Microsoft.Build.Framework.XamlTypes.Rule.ToolName.get -> string
+Microsoft.Build.Framework.XamlTypes.Rule.ToolName.set -> void
+Microsoft.Build.Framework.XamlTypes.RuleBag
+Microsoft.Build.Framework.XamlTypes.RuleBag.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.RuleBag.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.RuleBag.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
+Microsoft.Build.Framework.XamlTypes.RuleBag.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
+Microsoft.Build.Framework.XamlTypes.RuleBag.RuleBag() -> void
+Microsoft.Build.Framework.XamlTypes.RuleBag.Rules.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Rule>
+Microsoft.Build.Framework.XamlTypes.RuleBag.Rules.set -> void
+Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
+Microsoft.Build.Framework.XamlTypes.RuleOverrideMode.Extend = 1 -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
+Microsoft.Build.Framework.XamlTypes.RuleOverrideMode.Replace = 0 -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
+Microsoft.Build.Framework.XamlTypes.RuleSchema
+Microsoft.Build.Framework.XamlTypes.RuleSchema.RuleSchema() -> void
+Microsoft.Build.Framework.XamlTypes.StringListProperty
+Microsoft.Build.Framework.XamlTypes.StringListProperty.CommandLineValueSeparator.get -> string
+Microsoft.Build.Framework.XamlTypes.StringListProperty.CommandLineValueSeparator.set -> void
+Microsoft.Build.Framework.XamlTypes.StringListProperty.RendererValueSeparator.get -> string
+Microsoft.Build.Framework.XamlTypes.StringListProperty.RendererValueSeparator.set -> void
+Microsoft.Build.Framework.XamlTypes.StringListProperty.StringListProperty() -> void
+Microsoft.Build.Framework.XamlTypes.StringListProperty.Subtype.get -> string
+Microsoft.Build.Framework.XamlTypes.StringListProperty.Subtype.set -> void
+Microsoft.Build.Framework.XamlTypes.StringProperty
+Microsoft.Build.Framework.XamlTypes.StringProperty.StringProperty() -> void
+Microsoft.Build.Framework.XamlTypes.StringProperty.Subtype.get -> string
+Microsoft.Build.Framework.XamlTypes.StringProperty.Subtype.set -> void
+Microsoft.Build.Framework.XamlTypes.ValueEditor
+Microsoft.Build.Framework.XamlTypes.ValueEditor.BeginInit() -> void
+Microsoft.Build.Framework.XamlTypes.ValueEditor.DisplayName.get -> string
+Microsoft.Build.Framework.XamlTypes.ValueEditor.DisplayName.set -> void
+Microsoft.Build.Framework.XamlTypes.ValueEditor.EditorType.get -> string
+Microsoft.Build.Framework.XamlTypes.ValueEditor.EditorType.set -> void
+Microsoft.Build.Framework.XamlTypes.ValueEditor.EndInit() -> void
+Microsoft.Build.Framework.XamlTypes.ValueEditor.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
+Microsoft.Build.Framework.XamlTypes.ValueEditor.Metadata.set -> void
+Microsoft.Build.Framework.XamlTypes.ValueEditor.ValueEditor() -> void
+override Microsoft.Build.Framework.BuildEventContext.Equals(object obj) -> bool
+override Microsoft.Build.Framework.BuildEventContext.GetHashCode() -> int
+override Microsoft.Build.Framework.BuildEventContext.ToString() -> string
+override Microsoft.Build.Framework.LazyFormattedBuildEventArgs.Message.get -> string
+override Microsoft.Build.Framework.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Framework.Profiler.EvaluationLocation.Equals(object obj) -> bool
+override Microsoft.Build.Framework.Profiler.EvaluationLocation.GetHashCode() -> int
+override Microsoft.Build.Framework.Profiler.EvaluationLocation.ToString() -> string
+override Microsoft.Build.Framework.Profiler.ProfiledLocation.Equals(object obj) -> bool
+override Microsoft.Build.Framework.Profiler.ProfiledLocation.GetHashCode() -> int
+override Microsoft.Build.Framework.Profiler.ProfiledLocation.ToString() -> string
+override Microsoft.Build.Framework.Profiler.ProfilerResult.Equals(object obj) -> bool
+override Microsoft.Build.Framework.Profiler.ProfilerResult.GetHashCode() -> int
+override Microsoft.Build.Framework.ProjectFinishedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.ProjectStartedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.PropertyReassignmentEventArgs.Message.get -> string
+override Microsoft.Build.Framework.SdkReference.Equals(object obj) -> bool
+override Microsoft.Build.Framework.SdkReference.GetHashCode() -> int
+override Microsoft.Build.Framework.SdkReference.ToString() -> string
+override Microsoft.Build.Framework.SdkResultItem.Equals(object obj) -> bool
+override Microsoft.Build.Framework.SdkResultItem.GetHashCode() -> int
+override Microsoft.Build.Framework.TargetFinishedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TargetSkippedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TargetStartedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TaskFinishedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TaskParameterEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TaskStartedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.XamlTypes.EnumProperty.EndInit() -> void
+override Microsoft.Build.Framework.XamlTypes.IntProperty.EndInit() -> void
+static Microsoft.Build.Framework.BuildEventContext.Invalid.get -> Microsoft.Build.Framework.BuildEventContext
+static Microsoft.Build.Framework.BuildEventContext.operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
+static Microsoft.Build.Framework.BuildEventContext.operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForAggregatedGlob() -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.EmptyLocation.get -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.SdkReference.TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) -> bool
+virtual Microsoft.Build.Framework.BuildEventArgs.Message.get -> string
+virtual Microsoft.Build.Framework.BuildEventArgs.Message.set -> void
+virtual Microsoft.Build.Framework.EngineServices.IsTaskInputLoggingEnabled.get -> bool
+virtual Microsoft.Build.Framework.EngineServices.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
+virtual Microsoft.Build.Framework.EngineServices.Version.get -> int
+virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.get -> bool
+virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.get -> bool
+virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.Logger.get -> Microsoft.Build.Framework.SdkLogger
+virtual Microsoft.Build.Framework.SdkResolverContext.Logger.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.get -> System.Version
+virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.get -> string
+virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.get -> string
+virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.State.get -> object
+virtual Microsoft.Build.Framework.SdkResolverContext.State.set -> void
+virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.get -> System.Collections.Generic.IList<string>
+virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.set -> void
+virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem>
+virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.set -> void
+virtual Microsoft.Build.Framework.SdkResult.Path.get -> string
+virtual Microsoft.Build.Framework.SdkResult.Path.set -> void
+virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.get -> System.Collections.Generic.IDictionary<string, string>
+virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.set -> void
+virtual Microsoft.Build.Framework.SdkResult.SdkReference.get -> Microsoft.Build.Framework.SdkReference
+virtual Microsoft.Build.Framework.SdkResult.SdkReference.set -> void
+virtual Microsoft.Build.Framework.SdkResult.Success.get -> bool
+virtual Microsoft.Build.Framework.SdkResult.Success.set -> void
+virtual Microsoft.Build.Framework.SdkResult.Version.get -> string
+virtual Microsoft.Build.Framework.SdkResult.Version.set -> void
+virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
+virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
+virtual Microsoft.Build.Framework.XamlTypes.BaseProperty.BeginInit() -> void
+virtual Microsoft.Build.Framework.XamlTypes.BaseProperty.EndInit() -> void
diff --git a/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..49f59b81603
--- /dev/null
+++ b/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -0,0 +1,632 @@
+abstract Microsoft.Build.Framework.SdkLogger.LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+abstract Microsoft.Build.Framework.SdkResolver.Name.get -> string
+abstract Microsoft.Build.Framework.SdkResolver.Priority.get -> int
+abstract Microsoft.Build.Framework.SdkResolver.Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory) -> Microsoft.Build.Framework.SdkResult
+abstract Microsoft.Build.Framework.SdkResultFactory.IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
+abstract Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
+const Microsoft.Build.Framework.BuildEventContext.InvalidEvaluationId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidNodeId = -2 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidProjectContextId = -2 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidProjectInstanceId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidSubmissionId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidTargetId = -1 -> int
+const Microsoft.Build.Framework.BuildEventContext.InvalidTaskId = -1 -> int
+const Microsoft.Build.Framework.EngineServices.Version1 = 1 -> int
+const Microsoft.Build.Framework.ProjectStartedEventArgs.InvalidProjectId = -1 -> int
+Microsoft.Build.Framework.AnyEventHandler
+Microsoft.Build.Framework.BuildEngineResult
+Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult() -> void
+Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) -> void
+Microsoft.Build.Framework.BuildEngineResult.Result.get -> bool
+Microsoft.Build.Framework.BuildEngineResult.TargetOutputsPerProject.get -> System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>>
+Microsoft.Build.Framework.BuildErrorEventArgs
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs() -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.Code.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.EndColumnNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.EndLineNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.File.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.HelpLink.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.BuildErrorEventArgs.Subcategory.get -> string
+Microsoft.Build.Framework.BuildErrorEventHandler
+Microsoft.Build.Framework.BuildEventArgs
+Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs() -> void
+Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.set -> void
+Microsoft.Build.Framework.BuildEventArgs.HelpKeyword.get -> string
+Microsoft.Build.Framework.BuildEventArgs.RawMessage.get -> string
+Microsoft.Build.Framework.BuildEventArgs.RawMessage.set -> void
+Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.get -> System.DateTime
+Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.set -> void
+Microsoft.Build.Framework.BuildEventArgs.SenderName.get -> string
+Microsoft.Build.Framework.BuildEventArgs.ThreadId.get -> int
+Microsoft.Build.Framework.BuildEventArgs.Timestamp.get -> System.DateTime
+Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
+Microsoft.Build.Framework.BuildEventContext.BuildRequestId.get -> long
+Microsoft.Build.Framework.BuildEventContext.EvaluationId.get -> int
+Microsoft.Build.Framework.BuildEventContext.NodeId.get -> int
+Microsoft.Build.Framework.BuildEventContext.ProjectContextId.get -> int
+Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId.get -> int
+Microsoft.Build.Framework.BuildEventContext.SubmissionId.get -> int
+Microsoft.Build.Framework.BuildEventContext.TargetId.get -> int
+Microsoft.Build.Framework.BuildEventContext.TaskId.get -> int
+Microsoft.Build.Framework.BuildFinishedEventArgs
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs() -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.BuildFinishedEventHandler
+Microsoft.Build.Framework.BuildMessageEventArgs
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs() -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.Code.get -> string
+Microsoft.Build.Framework.BuildMessageEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.EndColumnNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.EndLineNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.File.get -> string
+Microsoft.Build.Framework.BuildMessageEventArgs.Importance.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.BuildMessageEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.BuildMessageEventArgs.Subcategory.get -> string
+Microsoft.Build.Framework.BuildMessageEventHandler
+Microsoft.Build.Framework.BuildStartedEventArgs
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs() -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword) -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildStartedEventHandler
+Microsoft.Build.Framework.BuildStatusEventArgs
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs() -> void
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildStatusEventHandler
+Microsoft.Build.Framework.BuildWarningEventArgs
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs() -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.Code.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.EndColumnNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.EndLineNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.File.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.HelpLink.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.BuildWarningEventArgs.Subcategory.get -> string
+Microsoft.Build.Framework.BuildWarningEventHandler
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs() -> void
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.CustomBuildEventArgs
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs() -> void
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.CustomBuildEventHandler
+Microsoft.Build.Framework.EngineServices
+Microsoft.Build.Framework.EngineServices.EngineServices() -> void
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.get -> string
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.set -> void
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs() -> void
+Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs() -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs() -> void
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) -> void
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ExternalProjectStartedEventArgs.TargetNames.get -> string
+Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Framework.IBuildEngine.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs) -> bool
+Microsoft.Build.Framework.IBuildEngine.ColumnNumberOfTaskNode.get -> int
+Microsoft.Build.Framework.IBuildEngine.ContinueOnError.get -> bool
+Microsoft.Build.Framework.IBuildEngine.LineNumberOfTaskNode.get -> int
+Microsoft.Build.Framework.IBuildEngine.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
+Microsoft.Build.Framework.IBuildEngine.ProjectFileOfTaskNode.get -> string
+Microsoft.Build.Framework.IBuildEngine10
+Microsoft.Build.Framework.IBuildEngine10.EngineServices.get -> Microsoft.Build.Framework.EngineServices
+Microsoft.Build.Framework.IBuildEngine2
+Microsoft.Build.Framework.IBuildEngine2.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion) -> bool
+Microsoft.Build.Framework.IBuildEngine2.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion) -> bool
+Microsoft.Build.Framework.IBuildEngine2.IsRunningMultipleNodes.get -> bool
+Microsoft.Build.Framework.IBuildEngine3
+Microsoft.Build.Framework.IBuildEngine3.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs) -> Microsoft.Build.Framework.BuildEngineResult
+Microsoft.Build.Framework.IBuildEngine3.Reacquire() -> void
+Microsoft.Build.Framework.IBuildEngine3.Yield() -> void
+Microsoft.Build.Framework.IBuildEngine4
+Microsoft.Build.Framework.IBuildEngine4.GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
+Microsoft.Build.Framework.IBuildEngine4.RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection) -> void
+Microsoft.Build.Framework.IBuildEngine4.UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
+Microsoft.Build.Framework.IBuildEngine5
+Microsoft.Build.Framework.IBuildEngine5.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
+Microsoft.Build.Framework.IBuildEngine6
+Microsoft.Build.Framework.IBuildEngine6.GetGlobalProperties() -> System.Collections.Generic.IReadOnlyDictionary<string, string>
+Microsoft.Build.Framework.IBuildEngine7
+Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.get -> bool
+Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.set -> void
+Microsoft.Build.Framework.IBuildEngine8
+Microsoft.Build.Framework.IBuildEngine8.ShouldTreatWarningAsError(string warningCode) -> bool
+Microsoft.Build.Framework.IBuildEngine9
+Microsoft.Build.Framework.IBuildEngine9.ReleaseCores(int coresToRelease) -> void
+Microsoft.Build.Framework.IBuildEngine9.RequestCores(int requestedCores) -> int
+Microsoft.Build.Framework.ICancelableTask
+Microsoft.Build.Framework.ICancelableTask.Cancel() -> void
+Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Framework.IEventRedirector.ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
+Microsoft.Build.Framework.IEventSource
+Microsoft.Build.Framework.IEventSource.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
+Microsoft.Build.Framework.IEventSource.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
+Microsoft.Build.Framework.IEventSource.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
+Microsoft.Build.Framework.IEventSource.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
+Microsoft.Build.Framework.IEventSource.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
+Microsoft.Build.Framework.IEventSource.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
+Microsoft.Build.Framework.IEventSource.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
+Microsoft.Build.Framework.IEventSource.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
+Microsoft.Build.Framework.IEventSource.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
+Microsoft.Build.Framework.IEventSource.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
+Microsoft.Build.Framework.IEventSource.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
+Microsoft.Build.Framework.IEventSource2
+Microsoft.Build.Framework.IEventSource2.TelemetryLogged -> Microsoft.Build.Framework.TelemetryEventHandler
+Microsoft.Build.Framework.IEventSource3
+Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects() -> void
+Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles() -> void
+Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs() -> void
+Microsoft.Build.Framework.IEventSource4
+Microsoft.Build.Framework.IEventSource4.IncludeEvaluationPropertiesAndItems() -> void
+Microsoft.Build.Framework.IForwardingLogger
+Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
+Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.set -> void
+Microsoft.Build.Framework.IForwardingLogger.NodeId.get -> int
+Microsoft.Build.Framework.IForwardingLogger.NodeId.set -> void
+Microsoft.Build.Framework.IGeneratedTask
+Microsoft.Build.Framework.IGeneratedTask.GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property) -> object
+Microsoft.Build.Framework.IGeneratedTask.SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value) -> void
+Microsoft.Build.Framework.ILogger
+Microsoft.Build.Framework.ILogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Framework.ILogger.Parameters.get -> string
+Microsoft.Build.Framework.ILogger.Parameters.set -> void
+Microsoft.Build.Framework.ILogger.Shutdown() -> void
+Microsoft.Build.Framework.ILogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.ILogger.Verbosity.set -> void
+Microsoft.Build.Framework.INodeLogger
+Microsoft.Build.Framework.INodeLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
+Microsoft.Build.Framework.IProjectElement
+Microsoft.Build.Framework.IProjectElement.ElementName.get -> string
+Microsoft.Build.Framework.IProjectElement.OuterElement.get -> string
+Microsoft.Build.Framework.ITask
+Microsoft.Build.Framework.ITask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Framework.ITask.BuildEngine.set -> void
+Microsoft.Build.Framework.ITask.Execute() -> bool
+Microsoft.Build.Framework.ITask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Framework.ITask.HostObject.set -> void
+Microsoft.Build.Framework.ITaskFactory
+Microsoft.Build.Framework.ITaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Framework.ITaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Framework.ITaskFactory.FactoryName.get -> string
+Microsoft.Build.Framework.ITaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Framework.ITaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Framework.ITaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Framework.ITaskFactory2
+Microsoft.Build.Framework.ITaskFactory2.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Framework.ITaskFactory2.Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
+Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
+Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) -> string
+Microsoft.Build.Framework.ITaskItem.ItemSpec.get -> string
+Microsoft.Build.Framework.ITaskItem.ItemSpec.set -> void
+Microsoft.Build.Framework.ITaskItem.MetadataCount.get -> int
+Microsoft.Build.Framework.ITaskItem.MetadataNames.get -> System.Collections.ICollection
+Microsoft.Build.Framework.ITaskItem.RemoveMetadata(string metadataName) -> void
+Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) -> void
+Microsoft.Build.Framework.ITaskItem2
+Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() -> System.Collections.IDictionary
+Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.get -> string
+Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.set -> void
+Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) -> string
+Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) -> void
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs() -> void
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) -> void
+Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
+Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute
+Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute.LoadInSeparateAppDomainAttribute() -> void
+Microsoft.Build.Framework.LoggerException
+Microsoft.Build.Framework.LoggerException.ErrorCode.get -> string
+Microsoft.Build.Framework.LoggerException.HelpKeyword.get -> string
+Microsoft.Build.Framework.LoggerException.LoggerException() -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(string message) -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException) -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) -> void
+Microsoft.Build.Framework.LoggerException.LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Detailed = 3 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Diagnostic = 4 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Minimal = 1 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Normal = 2 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.LoggerVerbosity.Quiet = 0 -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MessageImportance.High = 0 -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MessageImportance.Low = 2 -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MessageImportance.Normal = 1 -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Framework.MetaprojectGeneratedEventArgs
+Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) -> void
+Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.metaprojectXml -> string
+Microsoft.Build.Framework.OutputAttribute
+Microsoft.Build.Framework.OutputAttribute.OutputAttribute() -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementDescription.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementName.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation() -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPass.get -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPassDescription.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.File.get -> string
+Microsoft.Build.Framework.Profiler.EvaluationLocation.Id.get -> long
+Microsoft.Build.Framework.Profiler.EvaluationLocation.IsEvaluationPass.get -> bool
+Microsoft.Build.Framework.Profiler.EvaluationLocation.Kind.get -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocation.Line.get -> int?
+Microsoft.Build.Framework.Profiler.EvaluationLocation.ParentId.get -> long?
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFile(string file) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndCondition(string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithGlob(string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocation.WithParentId(long? parentId) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Condition = 1 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Element = 0 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Glob = 2 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
+Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.InitialProperties = 2 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.ItemDefinitionGroups = 4 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.Items = 5 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.LazyItems = 6 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.Properties = 3 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.Targets = 8 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.TotalEvaluation = 0 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.TotalGlobbing = 1 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.EvaluationPass.UsingTasks = 7 -> Microsoft.Build.Framework.Profiler.EvaluationPass
+Microsoft.Build.Framework.Profiler.ProfiledLocation
+Microsoft.Build.Framework.Profiler.ProfiledLocation.ExclusiveTime.get -> System.TimeSpan
+Microsoft.Build.Framework.Profiler.ProfiledLocation.InclusiveTime.get -> System.TimeSpan
+Microsoft.Build.Framework.Profiler.ProfiledLocation.NumberOfHits.get -> int
+Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation() -> void
+Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) -> void
+Microsoft.Build.Framework.Profiler.ProfilerResult
+Microsoft.Build.Framework.Profiler.ProfilerResult.ProfiledLocations.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation>
+Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult() -> void
+Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.get -> Microsoft.Build.Framework.Profiler.ProfilerResult?
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs() -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.set -> void
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs() -> void
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.set -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs() -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ProjectFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.ProjectFinishedEventHandler
+Microsoft.Build.Framework.ProjectImportedEventArgs
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.get -> string
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.set -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.get -> bool
+Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.set -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs() -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.get -> string
+Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.set -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs
+Microsoft.Build.Framework.ProjectStartedEventArgs.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Framework.ProjectStartedEventArgs.Items.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectStartedEventArgs.ParentProjectBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectId.get -> int
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs() -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.ProjectStartedEventArgs.Properties.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.ProjectStartedEventArgs.TargetNames.get -> string
+Microsoft.Build.Framework.ProjectStartedEventArgs.ToolsVersion.get -> string
+Microsoft.Build.Framework.ProjectStartedEventHandler
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs() -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.get -> string
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.set -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.get -> string
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.set -> void
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.get -> string
+Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.get -> string
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.set -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs() -> void
+Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+Microsoft.Build.Framework.RegisteredTaskObjectLifetime
+Microsoft.Build.Framework.RegisteredTaskObjectLifetime.AppDomain = 1 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
+Microsoft.Build.Framework.RegisteredTaskObjectLifetime.Build = 0 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
+Microsoft.Build.Framework.RequiredAttribute
+Microsoft.Build.Framework.RequiredAttribute.RequiredAttribute() -> void
+Microsoft.Build.Framework.RequiredRuntimeAttribute
+Microsoft.Build.Framework.RequiredRuntimeAttribute.RequiredRuntimeAttribute(string runtimeVersion) -> void
+Microsoft.Build.Framework.RequiredRuntimeAttribute.RuntimeVersion.get -> string
+Microsoft.Build.Framework.RunInMTAAttribute
+Microsoft.Build.Framework.RunInMTAAttribute.RunInMTAAttribute() -> void
+Microsoft.Build.Framework.RunInSTAAttribute
+Microsoft.Build.Framework.RunInSTAAttribute.RunInSTAAttribute() -> void
+Microsoft.Build.Framework.SdkLogger
+Microsoft.Build.Framework.SdkLogger.SdkLogger() -> void
+Microsoft.Build.Framework.SdkReference
+Microsoft.Build.Framework.SdkReference.Equals(Microsoft.Build.Framework.SdkReference other) -> bool
+Microsoft.Build.Framework.SdkReference.MinimumVersion.get -> string
+Microsoft.Build.Framework.SdkReference.Name.get -> string
+Microsoft.Build.Framework.SdkReference.SdkReference(string name, string version, string minimumVersion) -> void
+Microsoft.Build.Framework.SdkReference.Version.get -> string
+Microsoft.Build.Framework.SdkResolver
+Microsoft.Build.Framework.SdkResolver.SdkResolver() -> void
+Microsoft.Build.Framework.SdkResolverContext
+Microsoft.Build.Framework.SdkResolverContext.SdkResolverContext() -> void
+Microsoft.Build.Framework.SdkResult
+Microsoft.Build.Framework.SdkResult.SdkResult() -> void
+Microsoft.Build.Framework.SdkResultFactory
+Microsoft.Build.Framework.SdkResultFactory.SdkResultFactory() -> void
+Microsoft.Build.Framework.SdkResultItem
+Microsoft.Build.Framework.SdkResultItem.ItemSpec.get -> string
+Microsoft.Build.Framework.SdkResultItem.ItemSpec.set -> void
+Microsoft.Build.Framework.SdkResultItem.Metadata.get -> System.Collections.Generic.Dictionary<string, string>
+Microsoft.Build.Framework.SdkResultItem.SdkResultItem() -> void
+Microsoft.Build.Framework.SdkResultItem.SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) -> void
+Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.AfterTargets = 3 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.BeforeTargets = 1 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.DependsOn = 2 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetBuiltReason.None = 0 -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetFinishedEventArgs
+Microsoft.Build.Framework.TargetFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TargetFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFile.get -> string
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs() -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) -> void
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetName.get -> string
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.get -> System.Collections.IEnumerable
+Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.set -> void
+Microsoft.Build.Framework.TargetFinishedEventHandler
+Microsoft.Build.Framework.TargetSkippedEventArgs
+Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.get -> bool
+Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.get -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.get -> string
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.set -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs() -> void
+Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs(string message, params object[] messageArgs) -> void
+Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.ConditionWasFalse = 4 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.None = 0 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.OutputsUpToDate = 3 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltSuccessfully = 1 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltUnsuccessfully = 2 -> Microsoft.Build.Framework.TargetSkipReason
+Microsoft.Build.Framework.TargetStartedEventArgs
+Microsoft.Build.Framework.TargetStartedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
+Microsoft.Build.Framework.TargetStartedEventArgs.ParentTarget.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetFile.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetName.get -> string
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs() -> void
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) -> void
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TargetStartedEventHandler
+Microsoft.Build.Framework.TaskCommandLineEventArgs
+Microsoft.Build.Framework.TaskCommandLineEventArgs.CommandLine.get -> string
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs() -> void
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) -> void
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskName.get -> string
+Microsoft.Build.Framework.TaskFinishedEventArgs
+Microsoft.Build.Framework.TaskFinishedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TaskFinishedEventArgs.Succeeded.get -> bool
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFile.get -> string
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs() -> void
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) -> void
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskFinishedEventArgs.TaskName.get -> string
+Microsoft.Build.Framework.TaskFinishedEventHandler
+Microsoft.Build.Framework.TaskParameterEventArgs
+Microsoft.Build.Framework.TaskParameterEventArgs.Items.get -> System.Collections.IList
+Microsoft.Build.Framework.TaskParameterEventArgs.ItemType.get -> string
+Microsoft.Build.Framework.TaskParameterEventArgs.Kind.get -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterEventArgs.LogItemMetadata.get -> bool
+Microsoft.Build.Framework.TaskParameterEventArgs.TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.AddItem = 2 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.RemoveItem = 3 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetInputs = 4 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetOutputs = 5 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.TaskInput = 0 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskParameterMessageKind.TaskOutput = 1 -> Microsoft.Build.Framework.TaskParameterMessageKind
+Microsoft.Build.Framework.TaskPropertyInfo
+Microsoft.Build.Framework.TaskPropertyInfo.Log.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.Log.set -> void
+Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.set -> void
+Microsoft.Build.Framework.TaskPropertyInfo.Name.get -> string
+Microsoft.Build.Framework.TaskPropertyInfo.Output.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.PropertyType.get -> System.Type
+Microsoft.Build.Framework.TaskPropertyInfo.Required.get -> bool
+Microsoft.Build.Framework.TaskPropertyInfo.TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) -> void
+Microsoft.Build.Framework.TaskStartedEventArgs
+Microsoft.Build.Framework.TaskStartedEventArgs.ColumnNumber.get -> int
+Microsoft.Build.Framework.TaskStartedEventArgs.LineNumber.get -> int
+Microsoft.Build.Framework.TaskStartedEventArgs.ProjectFile.get -> string
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskFile.get -> string
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskName.get -> string
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs() -> void
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) -> void
+Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) -> void
+Microsoft.Build.Framework.TaskStartedEventHandler
+Microsoft.Build.Framework.TelemetryEventArgs
+Microsoft.Build.Framework.TelemetryEventArgs.EventName.get -> string
+Microsoft.Build.Framework.TelemetryEventArgs.EventName.set -> void
+Microsoft.Build.Framework.TelemetryEventArgs.Properties.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Framework.TelemetryEventArgs.Properties.set -> void
+Microsoft.Build.Framework.TelemetryEventArgs.TelemetryEventArgs() -> void
+Microsoft.Build.Framework.TelemetryEventHandler
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.get -> string
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.set -> void
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs() -> void
+Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
+override Microsoft.Build.Framework.BuildEventContext.Equals(object obj) -> bool
+override Microsoft.Build.Framework.BuildEventContext.GetHashCode() -> int
+override Microsoft.Build.Framework.BuildEventContext.ToString() -> string
+override Microsoft.Build.Framework.LazyFormattedBuildEventArgs.Message.get -> string
+override Microsoft.Build.Framework.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
+override Microsoft.Build.Framework.Profiler.EvaluationLocation.Equals(object obj) -> bool
+override Microsoft.Build.Framework.Profiler.EvaluationLocation.GetHashCode() -> int
+override Microsoft.Build.Framework.Profiler.EvaluationLocation.ToString() -> string
+override Microsoft.Build.Framework.Profiler.ProfiledLocation.Equals(object obj) -> bool
+override Microsoft.Build.Framework.Profiler.ProfiledLocation.GetHashCode() -> int
+override Microsoft.Build.Framework.Profiler.ProfiledLocation.ToString() -> string
+override Microsoft.Build.Framework.Profiler.ProfilerResult.Equals(object obj) -> bool
+override Microsoft.Build.Framework.Profiler.ProfilerResult.GetHashCode() -> int
+override Microsoft.Build.Framework.ProjectFinishedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.ProjectStartedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.PropertyReassignmentEventArgs.Message.get -> string
+override Microsoft.Build.Framework.SdkReference.Equals(object obj) -> bool
+override Microsoft.Build.Framework.SdkReference.GetHashCode() -> int
+override Microsoft.Build.Framework.SdkReference.ToString() -> string
+override Microsoft.Build.Framework.SdkResultItem.Equals(object obj) -> bool
+override Microsoft.Build.Framework.SdkResultItem.GetHashCode() -> int
+override Microsoft.Build.Framework.TargetFinishedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TargetSkippedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TargetStartedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TaskFinishedEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TaskParameterEventArgs.Message.get -> string
+override Microsoft.Build.Framework.TaskStartedEventArgs.Message.get -> string
+static Microsoft.Build.Framework.BuildEventContext.Invalid.get -> Microsoft.Build.Framework.BuildEventContext
+static Microsoft.Build.Framework.BuildEventContext.operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
+static Microsoft.Build.Framework.BuildEventContext.operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForAggregatedGlob() -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.Profiler.EvaluationLocation.EmptyLocation.get -> Microsoft.Build.Framework.Profiler.EvaluationLocation
+static Microsoft.Build.Framework.SdkReference.TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) -> bool
+virtual Microsoft.Build.Framework.BuildEventArgs.Message.get -> string
+virtual Microsoft.Build.Framework.BuildEventArgs.Message.set -> void
+virtual Microsoft.Build.Framework.EngineServices.IsTaskInputLoggingEnabled.get -> bool
+virtual Microsoft.Build.Framework.EngineServices.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
+virtual Microsoft.Build.Framework.EngineServices.Version.get -> int
+virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.get -> bool
+virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.get -> bool
+virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.Logger.get -> Microsoft.Build.Framework.SdkLogger
+virtual Microsoft.Build.Framework.SdkResolverContext.Logger.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.get -> System.Version
+virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.get -> string
+virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.get -> string
+virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.set -> void
+virtual Microsoft.Build.Framework.SdkResolverContext.State.get -> object
+virtual Microsoft.Build.Framework.SdkResolverContext.State.set -> void
+virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.get -> System.Collections.Generic.IList<string>
+virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.set -> void
+virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem>
+virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.set -> void
+virtual Microsoft.Build.Framework.SdkResult.Path.get -> string
+virtual Microsoft.Build.Framework.SdkResult.Path.set -> void
+virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.get -> System.Collections.Generic.IDictionary<string, string>
+virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.set -> void
+virtual Microsoft.Build.Framework.SdkResult.SdkReference.get -> Microsoft.Build.Framework.SdkReference
+virtual Microsoft.Build.Framework.SdkResult.SdkReference.set -> void
+virtual Microsoft.Build.Framework.SdkResult.Success.get -> bool
+virtual Microsoft.Build.Framework.SdkResult.Success.set -> void
+virtual Microsoft.Build.Framework.SdkResult.Version.get -> string
+virtual Microsoft.Build.Framework.SdkResult.Version.set -> void
+virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
+virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
diff --git a/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Framework/TargetFinishedEventArgs.cs b/src/Framework/TargetFinishedEventArgs.cs
index 435475eb4c7..fceebc108da 100644
--- a/src/Framework/TargetFinishedEventArgs.cs
+++ b/src/Framework/TargetFinishedEventArgs.cs
@@ -183,13 +183,7 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
-                    {
-                        if (RawMessage == null)
-                        {
-                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? "TargetFinishedSuccess" : "TargetFinishedFailure", targetName, Path.GetFileName(projectFile));
-                        }
-                    }
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? "TargetFinishedSuccess" : "TargetFinishedFailure", targetName, Path.GetFileName(projectFile));
                 }
 
                 return RawMessage;
diff --git a/src/Framework/TargetSkippedEventArgs.cs b/src/Framework/TargetSkippedEventArgs.cs
index d34e468ff32..61580ae92b5 100644
--- a/src/Framework/TargetSkippedEventArgs.cs
+++ b/src/Framework/TargetSkippedEventArgs.cs
@@ -157,35 +157,29 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
+                    RawMessage = SkipReason switch
                     {
-                        if (RawMessage == null)
-                        {
-                            RawMessage = SkipReason switch
-                            {
-                                TargetSkipReason.PreviouslyBuiltSuccessfully or TargetSkipReason.PreviouslyBuiltUnsuccessfully =>
-                                    FormatResourceStringIgnoreCodeAndKeyword(
-                                        OriginallySucceeded
-                                        ? "TargetAlreadyCompleteSuccess"
-                                        : "TargetAlreadyCompleteFailure",
-                                        TargetName),
-
-                                TargetSkipReason.ConditionWasFalse =>
-                                    FormatResourceStringIgnoreCodeAndKeyword(
-                                        "TargetSkippedFalseCondition",
-                                        TargetName,
-                                        Condition,
-                                        EvaluatedCondition),
-
-                                TargetSkipReason.OutputsUpToDate =>
-                                    FormatResourceStringIgnoreCodeAndKeyword(
-                                        "SkipTargetBecauseOutputsUpToDate",
-                                        TargetName),
-
-                                _ => SkipReason.ToString()
-                            };
-                        }
-                    }
+                        TargetSkipReason.PreviouslyBuiltSuccessfully or TargetSkipReason.PreviouslyBuiltUnsuccessfully =>
+                            FormatResourceStringIgnoreCodeAndKeyword(
+                                OriginallySucceeded
+                                ? "TargetAlreadyCompleteSuccess"
+                                : "TargetAlreadyCompleteFailure",
+                                TargetName),
+
+                        TargetSkipReason.ConditionWasFalse =>
+                            FormatResourceStringIgnoreCodeAndKeyword(
+                                "TargetSkippedFalseCondition",
+                                TargetName,
+                                Condition,
+                                EvaluatedCondition),
+
+                        TargetSkipReason.OutputsUpToDate =>
+                            FormatResourceStringIgnoreCodeAndKeyword(
+                                "SkipTargetBecauseOutputsUpToDate",
+                                TargetName),
+
+                        _ => SkipReason.ToString()
+                    };
                 }
 
                 return RawMessage;
diff --git a/src/Framework/TargetStartedEventArgs.cs b/src/Framework/TargetStartedEventArgs.cs
index e615e4f1461..c4a44a744b0 100644
--- a/src/Framework/TargetStartedEventArgs.cs
+++ b/src/Framework/TargetStartedEventArgs.cs
@@ -182,32 +182,26 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
+                    if (string.Equals(projectFile, targetFile, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (RawMessage == null)
+                        if (!string.IsNullOrEmpty(parentTarget))
                         {
-                            if (string.Equals(projectFile, targetFile, StringComparison.OrdinalIgnoreCase))
-                            {
-                                if (!string.IsNullOrEmpty(parentTarget))
-                                {
-                                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedProjectDepends", targetName, projectFile, parentTarget);
-                                }
-                                else
-                                {
-                                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedProjectEntry", targetName, projectFile);
-                                }
-                            }
-                            else
-                            {
-                                if (!string.IsNullOrEmpty(parentTarget))
-                                {
-                                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedFileProjectDepends", targetName, targetFile, projectFile, parentTarget);
-                                }
-                                else
-                                {
-                                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedFileProjectEntry", targetName, targetFile, projectFile);
-                                }
-                            }
+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedProjectDepends", targetName, projectFile, parentTarget);
+                        }
+                        else
+                        {
+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedProjectEntry", targetName, projectFile);
+                        }
+                    }
+                    else
+                    {
+                        if (!string.IsNullOrEmpty(parentTarget))
+                        {
+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedFileProjectDepends", targetName, targetFile, projectFile, parentTarget);
+                        }
+                        else
+                        {
+                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TargetStartedFileProjectEntry", targetName, targetFile, projectFile);
                         }
                     }
                 }
diff --git a/src/Framework/TaskFinishedEventArgs.cs b/src/Framework/TaskFinishedEventArgs.cs
index f0c3b8d7dcf..def68d090d9 100644
--- a/src/Framework/TaskFinishedEventArgs.cs
+++ b/src/Framework/TaskFinishedEventArgs.cs
@@ -144,13 +144,7 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
-                    {
-                        if (RawMessage == null)
-                        {
-                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? "TaskFinishedSuccess" : "TaskFinishedFailure", TaskName);
-                        }
-                    }
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword(Succeeded ? "TaskFinishedSuccess" : "TaskFinishedFailure", TaskName);
                 }
 
                 return RawMessage;
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index 207d20472d2..55e6ca69998 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -143,13 +143,7 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    lock (locker)
-                    {
-                        if (RawMessage == null)
-                        {
-                            RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TaskStarted", TaskName);
-                        }
-                    }
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TaskStarted", TaskName);
                 }
 
                 return RawMessage;
diff --git a/src/Shared/Traits.cs b/src/Framework/Traits.cs
similarity index 92%
rename from src/Shared/Traits.cs
rename to src/Framework/Traits.cs
index aa9fbaaa3bb..bf06a1551c1 100644
--- a/src/Shared/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,9 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Shared;
+using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Utilities
+namespace Microsoft.Build.Framework
 {
     /// <summary>
     ///     Represents toggleable features of the MSBuild engine
@@ -16,7 +16,7 @@ public static Traits Instance
         {
             get
             {
-                if (BuildEnvironmentHelper.Instance.RunningTests)
+                if (BuildEnvironmentState.s_runningTests)
                 {
                     return new Traits();
                 }
@@ -348,7 +348,7 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
                 return result;
             }
 
-            ErrorUtilities.ThrowInternalError($"Environment variable \"{environmentVariable}\" should have values \"true\", \"false\" or undefined");
+            ThrowInternalError($"Environment variable \"{environmentVariable}\" should have values \"true\", \"false\" or undefined");
 
             return null;
         }
@@ -372,7 +372,7 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
                 return ProjectInstanceTranslationMode.Partial;
             }
 
-            ErrorUtilities.ThrowInternalError($"Invalid escape hatch for project instance translation: {mode}");
+            ThrowInternalError($"Invalid escape hatch for project instance translation: {mode}");
 
             return null;
         }
@@ -412,7 +412,7 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
                 return SdkReferencePropertyExpansionMode.ExpandLeaveEscaped;
             }
 
-            ErrorUtilities.ThrowInternalError($"Invalid escape hatch for SdkReference property expansion: {mode}");
+            ThrowInternalError($"Invalid escape hatch for SdkReference property expansion: {mode}");
 
             return null;
         }
@@ -430,5 +430,30 @@ public enum SdkReferencePropertyExpansionMode
             ExpandUnescape,
             ExpandLeaveEscaped
         }
+
+        /// <summary>
+        /// Emergency escape hatch. If a customer hits a bug in the shipped product causing an internal exception,
+        /// and fortuitously it happens that ignoring the VerifyThrow allows execution to continue in a reasonable way,
+        /// then we can give them this undocumented environment variable as an immediate workaround.
+        /// </summary>
+        /// <remarks>
+        /// Clone from ErrorUtilities which isn't (yet?) available in Framework.
+        /// </remarks>
+
+        private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
+
+        /// <summary>
+        /// Throws InternalErrorException.
+        /// </summary>
+        /// <remarks>
+        /// Clone of ErrorUtilities.ThrowInternalError which isn't (yet?) available in Framework.
+        /// </remarks>
+        internal static void ThrowInternalError(string message)
+        {
+            if (s_throwExceptions)
+            {
+                throw new InternalErrorException(message);
+            }
+        }
     }
 }
diff --git a/src/Shared/VisualStudioLocationHelper.cs b/src/Framework/VisualStudioLocationHelper.cs
similarity index 100%
rename from src/Shared/VisualStudioLocationHelper.cs
rename to src/Framework/VisualStudioLocationHelper.cs
diff --git a/src/MSBuild.UnitTests/AssemblyInfo.cs b/src/MSBuild.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/MSBuild.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 701d0c1e3fc..e301c3a16b3 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -25,9 +25,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\RegistryDelegates.cs">
       <Link>RegistryDelegates.cs</Link>
     </Compile>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c9dbd905e72..c6909ccceb1 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -57,6 +57,23 @@ public void GatherCommandLineSwitchesTwoProperties()
             parameters[1].ShouldBe("c=d");
         }
 
+        [Fact]
+        public void GatherCommandLineSwitchesAnyDash()
+        {
+            var switches = new CommandLineSwitches();
+
+            var arguments = new List<string> {
+                "-p:a=b",
+                "--p:maxcpucount=8"
+            };
+
+            MSBuildApp.GatherCommandLineSwitches(arguments, switches);
+
+            string[] parameters = switches[CommandLineSwitches.ParameterizedSwitch.Property];
+            parameters[0].ShouldBe("a=b");
+            parameters[1].ShouldBe("maxcpucount=8");
+        }
+
         [Fact]
         public void GatherCommandLineSwitchesMaxCpuCountWithArgument()
         {
@@ -392,46 +409,85 @@ public void ExtractSwitchParametersTest()
         {
             string commandLineArg = "\"/p:foo=\"bar";
             string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":\"foo=\"bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":\"foo=\"bar");
             doubleQuotesRemovedFromArg.ShouldBe(2);
 
             commandLineArg = "\"/p:foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(2);
 
             commandLineArg = "/p:foo=bar";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(0);
 
             commandLineArg = "\"\"/p:foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar\"");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar\"");
             doubleQuotesRemovedFromArg.ShouldBe(3);
 
             // this test is totally unreal -- we'd never attempt to extract switch parameters if the leading character is not a
             // switch indicator (either '-' or '/') -- here the leading character is a double-quote
             commandLineArg = "\"\"\"/p:foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "/p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar\"");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "/p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar\"");
             doubleQuotesRemovedFromArg.ShouldBe(3);
 
             commandLineArg = "\"/pr\"operty\":foo=bar";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(3);
 
             commandLineArg = "\"/pr\"op\"\"erty\":foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(6);
 
             commandLineArg = "/p:\"foo foo\"=\"bar bar\";\"baz=onga\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":\"foo foo\"=\"bar bar\";\"baz=onga\"");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":\"foo foo\"=\"bar bar\";\"baz=onga\"");
             doubleQuotesRemovedFromArg.ShouldBe(6);
         }
+        
+        [Fact]
+        public void ExtractSwitchParametersTestDoubleDash()
+        {
+            var commandLineArg = "\"--p:foo=\"bar";
+            var unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":\"foo=\"bar");
+            doubleQuotesRemovedFromArg.ShouldBe(2);
+
+            commandLineArg = "\"--p:foo=bar\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(2);
+
+            commandLineArg = "--p:foo=bar";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(0);
+
+            commandLineArg = "\"\"--p:foo=bar\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar\"");
+            doubleQuotesRemovedFromArg.ShouldBe(3);
+
+            commandLineArg = "\"--pr\"operty\":foo=bar";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(3);
+
+            commandLineArg = "\"--pr\"op\"\"erty\":foo=bar\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(6);
+
+            commandLineArg = "--p:\"foo foo\"=\"bar bar\";\"baz=onga\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":\"foo foo\"=\"bar bar\";\"baz=onga\"");
+            doubleQuotesRemovedFromArg.ShouldBe(6);
+        }        
 
         [Fact]
         public void GetLengthOfSwitchIndicatorTest()
diff --git a/src/MSBuild/AssemblyInfo.cs b/src/MSBuild/AssemblyInfo.cs
index 67d13ed587e..b30ea61e1dc 100644
--- a/src/MSBuild/AssemblyInfo.cs
+++ b/src/MSBuild/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 using System.Runtime.CompilerServices;
@@ -9,8 +11,8 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/MSBuild/FxCopExclusions/MsBuild.Suppressions.cs b/src/MSBuild/FxCopExclusions/MsBuild.Suppressions.cs
deleted file mode 100644
index a3931515f98..00000000000
--- a/src/MSBuild/FxCopExclusions/MsBuild.Suppressions.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-// FxCop Suppression file
-// To Use:
-// Add module level suppressions to this file to have them suppressed in the assembly
-//
-
-#if CODE_ANALYSIS
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="wrn", Scope="resource", Target="MSBuild.Strings.resources", Justification="These are correct for the help text, they are file paths extensions and switches")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="warningsonly", Scope="resource", Target="MSBuild.Strings.resources", Justification="These are correct for the help text, they are file paths extensions and switches")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="logfile", Scope="resource", Target="MSBuild.Strings.resources", Justification="These are correct for the help text, they are file paths extensions and switches")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="filelogger", Scope="resource", Target="MSBuild.Strings.resources", Justification="These are correct for the help text, they are file paths extensions and switches")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="errorsonly", Scope="resource", Target="MSBuild.Strings.resources", Justification="These are correct for the help text, they are file paths extensions and switches")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="nologo", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="nostic", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="consoleloggerparameters", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="val", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="maxcpucount", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="ormal", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="ignoreprojectextensions", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="noconsolelogger", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="noautoresponse", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="nodeid", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="fileloggerparameters", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="noautorsp", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="nodereuse", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="diag", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="noconlog", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="etailed", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="flp", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="uiet", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="clp", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="distributedlogger", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="ver", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="toolsversion", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="inimal", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="MSBuild.Strings.resources", MessageId="rsp", Justification="These are spelled correctly for the help text")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="dsp", Scope="resource", Target="MSBuild.Strings.resources", Justification=".dsp is a file extension, and is spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="inlining", Scope="resource", Target="MSBuild.Strings.resources", Justification="A valid form of the verb 'to inline', and perfectly understandable to the user even if it may not technically be in the dictionary.")]
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames", Justification="Our assemblies are delay signed.")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.CommandLine", Justification="This is an approved namespace.")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="detailedsummary", Scope="resource", Target="MSBuild.Strings.resources")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="metaproj", Scope="resource", Target="MSBuild.Strings.resources")]
-
-#endif
-
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 93185ce820a..4361f23bd06 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -61,9 +61,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\AssemblyNameComparer.cs">
       <Link>AssemblyNameComparer.cs</Link>
     </Compile>
@@ -105,25 +102,16 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\ExceptionHandling.cs" />
-    <Compile Include="..\Shared\InternalErrorException.cs" />
     <Compile Include="..\Shared\EventArgsFormatting.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs">
       <Link>TempFileUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -160,9 +148,6 @@
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -186,9 +171,6 @@
     <Compile Include="DistributedLoggerRecord.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="FxCopExclusions\MsBuild.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="InitializationException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -229,6 +211,7 @@
     </None>
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index c032f6978c2..bfda5bb404b 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -720,7 +720,15 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="Compile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                             <xs:element name="VBMyExtensionTemplateID"/>
                         </xs:choice>
                     </xs:sequence>
@@ -730,6 +738,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Compile_Include" _locComment="" -->Semi-colon separated list of source files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -770,7 +788,15 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                             <xs:element name="LogicalName"/>
                         </xs:choice>
                     </xs:sequence>
@@ -780,6 +806,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="EmbeddedResource_Include" _locComment="" -->Semi-colon separated list of resource files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -819,15 +855,29 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
-                            <xs:element name="CopyToPublishDirectory" type="msb:boolean">
+                            <xs:element name="CopyToPublishDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -837,6 +887,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Content_Include" _locComment="" -->Semi-colon separated list of content files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -865,10 +925,17 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, Never, PreserveNewest or Always, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -878,6 +945,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Page_Include" _locComment="" -->Semi-colon separated list of XAML files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -906,10 +983,17 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -919,6 +1003,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Resource_Include" _locComment="" -->Semi-colon separated list of files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -947,13 +1041,30 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -985,7 +1096,15 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="None_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                         </xs:choice>
                     </xs:sequence>
                 </xs:extension>
@@ -1164,9 +1283,11 @@ elementFormDefault="qualified">
       </xs:annotation>
       <xs:simpleType>
         <xs:restriction base="xs:string">
-          <xs:enumeration value="Default" />
-          <xs:enumeration value="AllEnabledByDefault" />
-          <xs:enumeration value="AllDisabledByDefault" />
+          <xs:enumeration value="none" />
+          <xs:enumeration value="default" />
+          <xs:enumeration value="minimum" />
+          <xs:enumeration value="recommended" />
+          <xs:enumeration value="all" />
         </xs:restriction>
       </xs:simpleType>
     </xs:element>
@@ -1608,7 +1729,32 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="InstallFrom" _locComment="" -->Web, Unc, or Disk</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="AnalysisLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="AnalysisLevel" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AnalysisLevel" _locComment="" -->Customizes the set of rules that are enabled by default.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="none" />
+          <xs:enumeration value="latest" />
+          <xs:enumeration value="latest-minimum" />
+          <xs:enumeration value="latest-recommended" />
+          <xs:enumeration value="latest-all" />
+          <xs:enumeration value="preview" />
+          <xs:enumeration value="preview-minimum" />
+          <xs:enumeration value="preview-recommended" />
+          <xs:enumeration value="preview-all" />
+          <xs:enumeration value="5.0" />
+          <xs:enumeration value="5.0-minimum" />
+          <xs:enumeration value="5.0-recommended" />
+          <xs:enumeration value="5.0-all" />
+          <xs:enumeration value="6.0" />
+          <xs:enumeration value="6.0-minimum" />
+          <xs:enumeration value="6.0-recommended" />
+          <xs:enumeration value="6.0-all" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
     <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="IsCodeSharingProject" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="IsPackable" type="msb:boolean" substitutionGroup="msb:Property">
@@ -3020,6 +3166,33 @@ elementFormDefault="qualified">
             </xs:complexContent>
         </xs:complexType>
     </xs:element>
+    <xs:element name="AssemblySearchPaths" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation>
+                Semicolon-delimited ordered list of paths to search when the ResolveAssemblyReference task looks for an assembly. Some non-path locations like the Global Assembly Cache can also be searched using curly braces: {GAC}.
+            </xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseCandidateAssemblyFiles" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseReferencePath" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseHintPathFromItem" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseTargetFrameworkDirectory" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseAssemblyFoldersConfigFileSearchPath" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseRegistry" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseAssemblyFolders" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseGAC" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseRawFileName" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
+    <xs:element name="AssemblySearchPathUseOutDir" type="msb:boolean" substitutionGroup="msb:Property">
+    </xs:element>
     <xs:element name="ResolveAssemblyReference" substitutionGroup="msb:Task">
         <xs:complexType>
             <xs:complexContent>
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index a03db6f636f..1714165cad1 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -16,10 +16,9 @@ internal class NodeEndpointOutOfProcTaskHost : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal NodeEndpointOutOfProcTaskHost(string pipeName)
+        internal NodeEndpointOutOfProcTaskHost()
         {
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion // Constructors and Factories
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 6dc795d6762..e747dbcc9a3 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -15,7 +15,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
 #endif
@@ -612,9 +611,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
             // Snapshot the current environment
             _savedEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
 
-            string pipeName = "MSBuild" + Process.GetCurrentProcess().Id;
-
-            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost(pipeName);
+            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost();
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 683606d4fa8..3391a53a640 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1331,7 +1331,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild nejde spustit v této verzi operačního systému. Podporuje se jenom v systémech Windows 2000, Windows XP a novějších verzích.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild nejde spustit v této verzi operačního systému. Podporuje se jenom v systémech Windows 7 a novějších verzích.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a6d4afe3c64..63493f136ce 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgeführt werden. Nur Windows 2000, Windows XP und Folgeversionen werden unterstützt.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgeführt werden. Nur Windows 7 und Folgeversionen werden unterstützt.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index e284447ae5d..956059968ba 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1332,7 +1332,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild no se puede ejecutar en esta versión del sistema operativo. Solo es compatible con Windows 2000, Windows XP y versiones posteriores.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild no se ha podido ejecutar en esta versión del sistema operativo. Solo se admite en Windows 7 y versiones posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 1f465b9f5fa..a0aa66f7a84 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild ne s'exécute pas sur cette version du système d'exploitation. Il est pris en charge uniquement sur Windows 2000, Windows XP et les versions ultérieures.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild ne s'exécute pas sur cette version du système d'exploitation. Il n'est pris en charge que sur Windows 7 et les versions ultérieures.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 17f8ef60d33..200a7a77dae 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1345,7 +1345,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild non può essere eseguito su questa versione del sistema operativo. È supportato solo in Windows 2000, Windows XP e versioni successive.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild non può essere eseguito su questa versione del sistema operativo. È supportato solo in Windows 7 e versioni successive.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 6c17289c3c1..453bbc44766 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild はこのバージョンのオペレーティング システムでは実行できません。Windows 2000、Windows XP およびそれ以降のバージョンでのみサポートされています。</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild はこのバージョンのオペレーティング システムでは実行できません。Windows 7 およびそれ以降のバージョンでのみサポートされています。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index aaa3d3ec15c..e57ed62661a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: 이 운영 체제 버전에서는 MSBuild를 실행할 수 없습니다. MSBuild는 Windows 2000 및 Windows XP 이상 버전에서만 지원됩니다.</target>
+        <target state="translated">MSBUILD : error MSB1015: 이 운영 체제 버전에서는 MSBuild를 실행할 수 없습니다. MSBuild는 Windows 7 이상의 버전에서만 지원됩니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index bf6053ea021..c1e63e21afe 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1337,7 +1337,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: Program MSBuild nie działa w tej wersji systemu operacyjnego. Jest obsługiwany tylko w systemie Windows 2000, Windows XP oraz nowszych wersjach.</target>
+        <target state="translated">MSBUILD : error MSB1015: Program MSBuild nie działa w tej wersji systemu operacyjnego. Jest obsługiwany tylko w systemie Windows 7 i nowszych wersjach.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index ed957260598..e8293005192 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1324,7 +1324,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: O MSBuild não é executado nesta versão de sistema operacional. Há suporte para ele somente nas versões Windows 2000, Windows XP e versões posteriores.</target>
+        <target state="translated">MSBUILD : error MSB1015: O MSBuild não é executado nesta versão do sistema operacional. É suportado apenas no Windows 7 e em versões posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index a16f15e95bc..d5f02251680 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1322,7 +1322,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild не работает в этой версии операционной системы. Он поддерживается только в Windows 2000, Windows XP и более поздних версиях.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild не работает в этой версии операционной системы. Он поддерживается только в Windows 7, Windows XP и более поздних версиях.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 6de7f438111..06ed57c5523 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1327,7 +1327,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild işletim sisteminin bu sürümünde çalışmaz. Yalnızca Windows 2000, Windows XP ve sonraki sürümlerde desteklenir.</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild işletim sisteminin bu sürümünde çalışmaz. Yalnızca Windows 7 ve üzeri sürümlerde desteklenir.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index d29ed7c8e4b..3a68a4c3a6b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild 不能在此版本的操作系统上运行。它仅在 Windows 2000、Windows XP 及更高版本的操作系统上受支持。</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild 不在此版本操作系统上运行，而仅在 Windows 7 及更高版本的操作系统上受支持。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 95fe02eeca4..5992ad480da 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1323,7 +1323,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="UnsupportedOS">
         <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1015: MSBuild 在此版本的作業系統上不會執行。只有在 Windows 2000、Windows XP 及更新版本才受支援。</target>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild 不會在此版本的作業系統上執行。只有在 Windows 7 及更新版本才受支援。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index b3cf4561a15..ae95d608193 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1551,7 +1551,7 @@ private static void VerifyThrowSupportedOS()
             {
                 // If we're running on any of the unsupported OS's, fail immediately.  This way,
                 // we don't run into some obscure error down the line, totally confusing the user.
-                InitializationException.VerifyThrow(false, "UnsupportedOS");
+                InitializationException.Throw("UnsupportedOS", null, null, false);
             }
 #endif
         }
@@ -1704,8 +1704,8 @@ internal static void GatherCommandLineSwitches(List<string> commandLineArgs, Com
                             }
                             else
                             {
-                                switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength, switchParameterIndicator - 1);
-                                switchParameters = ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, switchName, switchParameterIndicator);
+                                switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength, switchParameterIndicator - switchIndicatorsLength);
+                                switchParameters = ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, switchName, switchParameterIndicator, switchIndicatorsLength);
                             }
                         }
 
@@ -1764,6 +1764,7 @@ internal static void GatherCommandLineSwitches(List<string> commandLineArgs, Com
         /// <param name="doubleQuotesRemovedFromArg"></param>
         /// <param name="switchName"></param>
         /// <param name="switchParameterIndicator"></param>
+        /// <param name="switchIndicatorsLength"></param>
         /// <returns>The given switch's parameters (with interesting quoting preserved).</returns>
         internal static string ExtractSwitchParameters
         (
@@ -1771,7 +1772,8 @@ internal static string ExtractSwitchParameters
             string unquotedCommandLineArg,
             int doubleQuotesRemovedFromArg,
             string switchName,
-            int switchParameterIndicator
+            int switchParameterIndicator,
+            int switchIndicatorsLength
         )
         {
 
@@ -1783,7 +1785,7 @@ int switchParameterIndicator
             // check if there is any quoting in the name portion of the switch
             string unquotedSwitchIndicatorAndName = QuotingUtilities.Unquote(commandLineArg.Substring(0, quotedSwitchParameterIndicator), out var doubleQuotesRemovedFromSwitchIndicatorAndName);
 
-            ErrorUtilities.VerifyThrow(switchName == unquotedSwitchIndicatorAndName.Substring(1),
+            ErrorUtilities.VerifyThrow(switchName == unquotedSwitchIndicatorAndName.Substring(switchIndicatorsLength),
                 "The switch name extracted from either the partially or completely unquoted arg should be the same.");
 
             ErrorUtilities.VerifyThrow(doubleQuotesRemovedFromArg >= doubleQuotesRemovedFromSwitchIndicatorAndName,
@@ -2841,7 +2843,7 @@ DirectoryGetFiles getFiles
                 // If there is more than one solution file in the current directory we have no idea which one to use
                 else if (actualSolutionFiles.Count > 1)
                 {
-                    InitializationException.VerifyThrow(false, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(false, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory, false);
                 }
                 // If there is more than one project file in the current directory we may be able to figure it out
                 else if (actualProjectFiles.Count > 1)
@@ -2881,7 +2883,7 @@ DirectoryGetFiles getFiles
                          actualSolutionFiles.Count== 0 &&
                          solutionFilterFiles.Count == 0)
                 {
-                    InitializationException.VerifyThrow(false, "MissingProjectError");
+                    InitializationException.Throw("MissingProjectError", null, null, false);
                 }
                 else
                 {
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 93697e88064..86cc8288001 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -87,20 +87,20 @@
           <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
-        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
-      </dependentAssembly>
+          <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-5.0.0.1" newVersion="5.0.0.1" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-5.0.0.2" newVersion="5.0.0.2" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
-          <assemblyIdentity name="Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.6.3.0" newVersion="4.6.3.0" />
+          <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -127,15 +127,15 @@
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
         <dependentAssembly>
           <assemblyIdentity name="FxCopTask" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\FxCopTask.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\FxCopTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
       </assemblyBinding>
     </runtime>
@@ -146,7 +146,7 @@
         <property name="MSBuildToolsPath32" value="$([MSBuild]::GetToolsDirectory32())" />
         <property name="MSBuildToolsPath64" value="$([MSBuild]::GetToolsDirectory64())" />
         <property name="MSBuildSDKsPath" value="$([MSBuild]::GetMSBuildSDKsPath())" />
-        <property name="FrameworkSDKRoot" value="$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8@InstallationFolder)" />
+        <property name="FrameworkSDKRoot" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="MSBuildRuntimeVersion" value="4.0.30319" />
         <property name="MSBuildFrameworkToolsPath" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsPath32" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
@@ -154,7 +154,7 @@
         <property name="MSBuildFrameworkToolsRoot" value="$(SystemRoot)\Microsoft.NET\Framework\" />
         <property name="SDK35ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx35Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="SDK40ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
-        <property name="WindowsSDK80Path" value="$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1@InstallationFolder)" />
+        <property name="WindowsSDK80Path" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="VsInstallRoot" value="$([MSBuild]::GetVsInstallRoot())" />
         <property name="MSBuildToolsRoot" value="$(VsInstallRoot)\MSBuild" />
         <property name="MSBuildExtensionsPath" value="$([MSBuild]::GetMSBuildExtensionsPath())" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 047b20fb44c..347edae06e6 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -77,20 +77,20 @@
           <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
-        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
-      </dependentAssembly>
+          <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-5.0.0.1" newVersion="5.0.0.1" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-5.0.0.2" newVersion="5.0.0.2" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
-          <assemblyIdentity name="Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.6.3.0" newVersion="4.6.3.0" />
+          <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -119,15 +119,15 @@
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
         <dependentAssembly>
           <assemblyIdentity name="FxCopTask" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\FxCopTask.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\FxCopTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
       </assemblyBinding>
     </runtime>
@@ -138,7 +138,7 @@
         <property name="MSBuildToolsPath32" value="$([MSBuild]::GetToolsDirectory32())" />
         <property name="MSBuildToolsPath64" value="$([MSBuild]::GetToolsDirectory64())" />
         <property name="MSBuildSDKsPath" value="$([MSBuild]::GetMSBuildSDKsPath())" />
-        <property name="FrameworkSDKRoot" value="$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8@InstallationFolder)" />
+        <property name="FrameworkSDKRoot" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="MSBuildRuntimeVersion" value="4.0.30319" />
         <property name="MSBuildFrameworkToolsPath" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsPath32" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
@@ -146,7 +146,7 @@
         <property name="MSBuildFrameworkToolsRoot" value="$(SystemRoot)\Microsoft.NET\Framework\" />
         <property name="SDK35ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx35Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="SDK40ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
-        <property name="WindowsSDK80Path" value="$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1@InstallationFolder)" />
+        <property name="WindowsSDK80Path" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="VsInstallRoot" value="$([MSBuild]::GetVsInstallRoot())" />
         <property name="MSBuildToolsRoot" value="$(VsInstallRoot)\MSBuild" />
         <property name="MSBuildExtensionsPath" value="$([MSBuild]::GetMSBuildExtensionsPath())" />
diff --git a/src/MSBuildTaskHost/AssemblyInfo.cs b/src/MSBuildTaskHost/AssemblyInfo.cs
index 11f47e95489..32460f62989 100644
--- a/src/MSBuildTaskHost/AssemblyInfo.cs
+++ b/src/MSBuildTaskHost/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System.Runtime.CompilerServices;
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 66f5bc78f00..091fbda3b3e 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -16,7 +16,7 @@
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
 
     <EnableDefaultItems>false</EnableDefaultItems>
-    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST</DefineConstants>
+    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST;NO_FRAMEWORK_IVT</DefineConstants>
     <!-- Need pointers for getting environment block -->
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <!-- It is vital that msbuildtaskhost.exe is allowed to use the full 4GB on 64 bit machines in order to help avoid
@@ -39,6 +39,9 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BuildEnvironmentState.cs">
+      <Link>BuildEnvironmentState.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\AssemblyNameComparer.cs">
       <Link>AssemblyNameComparer.cs</Link>
     </Compile>
@@ -54,7 +57,7 @@
     <Compile Include="..\Framework\ITaskItem2.cs">
       <Link>ITaskItem2.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs" />
+    <Compile Include="..\Framework\AssemblyUtilities.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
@@ -96,7 +99,7 @@
       <Link>ITranslator.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
-    <Compile Include="..\Shared\InternalErrorException.cs">
+    <Compile Include="..\Framework\InternalErrorException.cs">
       <Link>InternalErrorException.cs</Link>
     </Compile>
     <Compile Include="..\Shared\InterningBinaryReader.cs">
@@ -108,7 +111,8 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
+    <Compile Include="..\Framework\NativeMethods.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
     <Compile Include="..\Shared\NodeBuildComplete.cs">
@@ -144,10 +148,10 @@
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs">
       <Link>TaskParameterTypeVerifier.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
+    <Compile Include="..\Framework\Traits.cs">
+      <Link>FrameworkTraits.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
+    <Compile Include="..\Framework\VisualStudioLocationHelper.cs">
       <Link>VisualStudioLocationHelper.cs</Link>
     </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index 2918e172a5c..04a42dbfce4 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -31,6 +31,7 @@
     <file src="$X86BinPath$/Microsoft.Build.Framework.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.IO.Redist.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin" />
@@ -87,6 +88,7 @@
     <file src="$X86BinPath$/Microsoft.Build.Framework.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.IO.Redist.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin/amd64" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 67e5764974d..8de7164fde5 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -32,6 +32,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.Build.Framework.tlb
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe vs.file.ngenArchitecture=x86
@@ -42,6 +43,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.ValueTuple.dll
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -184,8 +186,10 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.ValueTuple.dll
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index f35dc2f8a6e..6f305333738 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -7,6 +7,8 @@
 using System.Linq;
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
@@ -505,6 +507,11 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
             CurrentMSBuildExePath = currentMSBuildExePath;
             VisualStudioInstallRootDirectory = visualStudioPath;
 
+#if !NO_FRAMEWORK_IVT
+            Framework.BuildEnvironmentState.s_runningTests = true;
+            Framework.BuildEnvironmentState.s_runningInVisualStudio = runningInVisualStudio;
+#endif
+
             if (!string.IsNullOrEmpty(currentMSBuildExePath))
             {
                 currentMSBuildExeFile = new FileInfo(currentMSBuildExePath);
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 4b118f31594..487080a3dff 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -11,9 +11,9 @@
 using System.Security.Principal;
 using System.Threading;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Microsoft.Build.Utilities;
 
 #if !CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Debugging;
@@ -60,7 +60,12 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with administrator privileges
         /// </summary>
-        Administrator = 32
+        Administrator = 32,
+
+        /// <summary>
+        /// Using the .NET Core/.NET 5.0+ runtime
+        /// </summary>
+        NET = 64,
     }
 
     internal readonly struct Handshake
@@ -75,7 +80,7 @@ internal readonly struct Handshake
 
         internal Handshake(HandshakeOptions nodeType)
         {
-            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // We currently use 7 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
             // This indicates in the first byte that we are a modern build.
             options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
@@ -213,8 +218,8 @@ internal static Dictionary<string, string> GetEnvironmentVariables()
                         // Copy strings out, parsing into pairs and inserting into the table.
                         // The first few environment variable entries start with an '='!
                         // The current working directory of every drive (except for those drives
-                        // you haven't cd'ed into in your DOS window) are stored in the 
-                        // environment block (as =C:=pwd) and the program's exit code is 
+                        // you haven't cd'ed into in your DOS window) are stored in the
+                        // environment block (as =C:=pwd) and the program's exit code is
                         // as well (=ExitCode=00000000)  Skip all that start with =.
                         // Read docs about Environment Blocks on MSDN's CreateProcess page.
 
@@ -228,8 +233,8 @@ internal static Dictionary<string, string> GetEnvironmentVariables()
                             int startKey = i;
 
                             // Skip to key
-                            // On some old OS, the environment block can be corrupted. 
-                            // Some lines will not have '=', so we need to check for '\0'. 
+                            // On some old OS, the environment block can be corrupted.
+                            // Some lines will not have '=', so we need to check for '\0'.
                             while (*(pEnvironmentBlock + i) != '=' && *(pEnvironmentBlock + i) != '\0')
                             {
                                 i++;
@@ -306,7 +311,7 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)
                     }
                 }
 
-                // Then, make sure the old ones have their old values. 
+                // Then, make sure the old ones have their old values.
                 foreach (KeyValuePair<string, string> entry in newEnvironment)
                 {
                     Environment.SetEnvironmentVariable(entry.Key, entry.Value);
@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
 
-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 2;
+                    } 
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 4;
+                    }
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.net, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 5;
+                    }
+                    else
+                    {
+                        ErrorUtilities.ThrowInternalErrorUnreachable();
+                    }
+
                     is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
@@ -501,10 +522,26 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
             {
                 context |= HandshakeOptions.X64;
             }
-            if (clrVersion == 2)
+
+            switch (clrVersion)
             {
-                context |= HandshakeOptions.CLR2;
+                case 0:
+                    // Not a taskhost, runtime must match
+                case 4:
+                    // Default for MSBuild running on .NET Framework 4,
+                    // not represented in handshake
+                    break;
+                case 2:
+                    context |= HandshakeOptions.CLR2;
+                    break;
+                case >= 5:
+                    context |= HandshakeOptions.NET;
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalErrorUnreachable();
+                    break;
             }
+
             if (nodeReuse)
             {
                 context |= HandshakeOptions.NodeReuse;
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 6289ef54bef..9a36fc1816e 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -77,6 +77,16 @@ internal static class MSBuildConstants
         /// </summary>
         internal const string DefaultTargetsMarker = ".default";
 
+        /// <summary>
+        /// Framework version against which our test projects should be built.
+        /// </summary>
+        /// <remarks>
+        /// The targeting pack for this version of .NET Framework must be installed
+        /// on any machine that wants to run tests successfully, so this can be
+        /// periodically updated.
+        /// </remarks>
+        internal const string StandardTestTargetFrameworkVersion = "v4.8";
+
         /// <summary>
         /// Symbol used in ProjectReferenceTarget items to represent targets specified on the ProjectReference item
         /// with fallback to default targets if the ProjectReference item has no targets specified.
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 351b3b04e46..a6febc5c973 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Globalization;
 using System.Text;
-using error = Microsoft.Build.Shared.ErrorUtilities;
+using Error = Microsoft.Build.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.Shared
 {
@@ -33,7 +33,7 @@ internal static bool ConvertStringToBool(string parameterValue)
             else
             {
                 // Unsupported boolean representation.
-                error.VerifyThrowArgument(false, "Shared.CannotConvertStringToBool", parameterValue);
+                Error.ThrowArgument("Shared.CannotConvertStringToBool", parameterValue);
                 return false;
             }
         }
@@ -64,6 +64,21 @@ internal static string ConvertByteArrayToHex(byte[] bytes)
             return sb.ToString();
         }
 
+        internal static bool TryConvertStringToBool(string parameterValue, out bool boolValue)
+        {
+            boolValue = false;
+            if (ValidBooleanTrue(parameterValue))
+            {
+                boolValue = true;
+                return true;
+            }
+            else if (ValidBooleanFalse(parameterValue))
+            {
+                return true;
+            }
+            return false;
+        }
+
         /// <summary>
         /// Returns true if the string can be successfully converted to a bool,
         /// such as "on" or "yes"
@@ -123,30 +138,40 @@ internal static double ConvertHexToDouble(string number)
         /// </summary>
         internal static double ConvertDecimalOrHexToDouble(string number)
         {
-            if (ConversionUtilities.ValidDecimalNumber(number))
+            if (TryConvertDecimalOrHexToDouble(number, out double result))
             {
-                return ConversionUtilities.ConvertDecimalToDouble(number);
+                return result;
             }
-            else if (ConversionUtilities.ValidHexNumber(number))
+            Error.ThrowInternalError("Cannot numeric evaluate");
+            return 0.0D;
+        }
+
+        internal static bool TryConvertDecimalOrHexToDouble(string number, out double doubleValue)
+        {
+            if (ConversionUtilities.ValidDecimalNumber(number, out doubleValue))
             {
-                return ConversionUtilities.ConvertHexToDouble(number);
+                return true;
+            }
+            else if (ConversionUtilities.ValidHexNumber(number, out int hexValue))
+            {
+                doubleValue = (double)hexValue;
+                return true;
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Cannot numeric evaluate");
-                return 0.0D;
+                return false;
             }
         }
 
         /// <summary>
         /// Returns true if the string is a valid hex number, like "0xABC"
         /// </summary>
-        private static bool ValidHexNumber(string number)
+        private static bool ValidHexNumber(string number, out int value)
         {
             bool canConvert = false;
+            value = 0;
             if (number.Length >= 3 && number[0] == '0' && (number[1] == 'x' || number[1] == 'X'))
             {
-                int value;
                 canConvert = Int32.TryParse(number.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat, out value);
             }
             return canConvert;
@@ -155,9 +180,8 @@ private static bool ValidHexNumber(string number)
         /// <summary>
         /// Returns true if the string is a valid decimal number, like "-123.456"
         /// </summary>
-        private static bool ValidDecimalNumber(string number)
+        private static bool ValidDecimalNumber(string number, out double value)
         {
-            double value;
             return Double.TryParse(number, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out value) && !double.IsInfinity(value);
         }
 
@@ -166,7 +190,7 @@ private static bool ValidDecimalNumber(string number)
         /// </summary>
         internal static bool ValidDecimalOrHexNumber(string number)
         {
-            return ValidDecimalNumber(number) || ValidHexNumber(number);
+            return ValidDecimalNumber(number, out _) || ValidHexNumber(number, out _);
         }
     }
 }
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 19b6d03f5d0..cd02dba6528 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -1,5 +1,6 @@
 ﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 using System;
@@ -164,12 +165,10 @@ private Assembly TryResolveAssemblyFromPaths(AssemblyLoadContext context, Assemb
                     }
 
                     AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
-                    if (candidateAssemblyName.Version != assemblyName.Version)
+                    if (candidateAssemblyName.Version >= assemblyName.Version)
                     {
-                        continue;
+                        return LoadAndCache(context, candidatePath);
                     }
-
-                    return LoadAndCache(context, candidatePath);
                 }
             }
 
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index aa83426e5af..0ba09dac396 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -1,7 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Utilities;
+using Microsoft.Build.Framework;
 using System;
 using System.Diagnostics;
 using System.IO;
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 9bb3502596b..ec9ea9a668c 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -8,6 +8,8 @@
 using System.Globalization;
 using System.Threading;
 
+using Microsoft.Build.Framework;
+
 #if BUILDINGAPPXTASKS
 namespace Microsoft.Build.AppxPackage.Shared
 #else
@@ -56,7 +58,7 @@ internal static void VerifyThrowInternalError(bool condition, string message, pa
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
         internal static void ThrowInternalError(string message, params object[] args)
@@ -68,7 +70,7 @@ internal static void ThrowInternalError(string message, params object[] args)
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
         internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
@@ -80,7 +82,7 @@ internal static void ThrowInternalError(string message, Exception innerException
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
@@ -93,7 +95,7 @@ internal static void ThrowInternalErrorUnreachable()
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
@@ -106,7 +108,7 @@ internal static void VerifyThrowInternalErrorUnreachable(bool condition)
         }
 
         /// <summary>
-        /// Throws InternalErrorException. 
+        /// Throws InternalErrorException.
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
@@ -461,7 +463,7 @@ object arg3
 
         /// <summary>
         /// Throws an ArgumentException that can include an inner exception.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -477,7 +479,7 @@ params object[] args
 
         /// <summary>
         /// Throws an ArgumentException that can include an inner exception.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -488,7 +490,7 @@ params object[] args
         /// <param name="innerException">Can be null.</param>
         /// <param name="resourceName"></param>
         /// <param name="args"></param>
-        private static void ThrowArgument
+        internal static void ThrowArgument
         (
             Exception innerException,
             string resourceName,
@@ -783,7 +785,7 @@ internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T
             }
         }
 #endif
-        
+
         /// <summary>
         /// Throws an ArgumentNullException if the given string parameter is null
         /// and ArgumentException if it has zero length.
@@ -801,7 +803,7 @@ internal static void VerifyThrowArgumentInvalidPath(string parameter, string par
         }
 
         /// <summary>
-        /// Throws an ArgumentException if the string has zero length, unless it is 
+        /// Throws an ArgumentException if the string has zero length, unless it is
         /// null, in which case no exception is thrown.
         /// </summary>
         internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)
@@ -831,7 +833,7 @@ internal static void VerifyThrowArgumentNull(object parameter, string parameterN
         {
             if (parameter == null && s_throwExceptions)
             {
-                // Most ArgumentNullException overloads append its own rather clunky multi-line message. 
+                // Most ArgumentNullException overloads append its own rather clunky multi-line message.
                 // So use the one overload that doesn't.
                 throw new ArgumentNullException(
                     ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, parameterName),
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 8ba3e225520..f359e71a71d 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.AppxPackage.Shared
 #if !CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Debugging;
 #endif
-using Microsoft.Build.Utilities;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Shared
 #endif
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9af0619bab7..f228386a909 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -10,13 +10,14 @@
 using System.Text.RegularExpressions;
 using System.Collections.Generic;
 using System.Threading.Tasks;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// Functions for matching file names with patterns. 
+    /// Functions for matching file names with patterns.
     /// </summary>
     internal class FileMatcher
     {
@@ -132,7 +133,7 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE
                                     directory,
                                     false));
                         IEnumerable<string> filteredEntriesForPath = (pattern != null && !IsAllFilesWildcard(pattern))
-                            ? allEntriesForPath.Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
                             : allEntriesForPath;
                         return stripProjectDirectory
                             ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
@@ -244,9 +245,9 @@ private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem
             {
                 case FileSystemEntity.Files: return GetAccessibleFiles(fileSystem, path, pattern, projectDirectory, stripProjectDirectory);
                 case FileSystemEntity.Directories: return GetAccessibleDirectories(fileSystem, path, pattern);
-                case FileSystemEntity.FilesAndDirectories: return GetAccessibleFilesAndDirectories(fileSystem,path, pattern);
+                case FileSystemEntity.FilesAndDirectories: return GetAccessibleFilesAndDirectories(fileSystem, path, pattern);
                 default:
-                    ErrorUtilities.VerifyThrow(false, "Unexpected filesystem entity type.");
+                    ErrorUtilities.ThrowInternalError("Unexpected filesystem entity type.");
                     break;
             }
             return Array.Empty<string>();
@@ -268,7 +269,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                 {
                     return (ShouldEnforceMatching(pattern)
                         ? fileSystem.EnumerateFileSystemEntries(path, pattern)
-                            .Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            .Where(o => IsFileNameMatch(o, pattern))
                         : fileSystem.EnumerateFileSystemEntries(path, pattern)
                         ).ToArray();
                 }
@@ -317,7 +318,7 @@ private static bool ShouldEnforceMatching(string searchPattern)
         /// <summary>
         /// Same as Directory.EnumerateFiles(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -351,7 +352,7 @@ bool stripProjectDirectory
                     files = fileSystem.EnumerateFiles(dir, filespec);
                     if (ShouldEnforceMatching(filespec))
                     {
-                        files = files.Where(o => IsMatch(Path.GetFileName(o), filespec));
+                        files = files.Where(o => IsFileNameMatch(o, filespec));
                     }
                 }
                 // If the Item is based on a relative path we need to strip
@@ -387,7 +388,7 @@ bool stripProjectDirectory
         /// <summary>
         /// Same as Directory.EnumerateDirectories(...) except that files that
         /// aren't accessible are skipped instead of throwing an exception.
-        /// 
+        ///
         /// Other exceptions are passed through.
         /// </summary>
         /// <param name="path">The path.</param>
@@ -414,7 +415,7 @@ string pattern
                     directories = fileSystem.EnumerateDirectories((path.Length == 0) ? s_thisDirectory : path, pattern);
                     if (ShouldEnforceMatching(pattern))
                     {
-                        directories = directories.Where(o => IsMatch(Path.GetFileName(o), pattern));
+                        directories = directories.Where(o => IsFileNameMatch(o, pattern));
                     }
                 }
 
@@ -581,7 +582,7 @@ internal void SplitFileSpec(
                 out filenamePart
             );
 
-            /* 
+            /*
              * Handle the special case in which filenamePart is '**'.
              * In this case, filenamePart becomes '*.*' and the '**' is appended
              * to the end of the wildcardDirectory part.
@@ -622,12 +623,12 @@ out string filenamePart
             {
                 /*
                  * No dir separator found. This is either this form,
-                 * 
+                 *
                  *      Source.cs
                  *      *.cs
-                 * 
+                 *
                  *  or this form,
-                 * 
+                 *
                  *     **
                  */
                 fixedDirectoryPart = string.Empty;
@@ -648,14 +649,14 @@ out string filenamePart
                  * wildcard is after the dir separator.
                  *
                  * The form is one of these:
-                 * 
+                 *
                  *      dir1\Source.cs
                  *      dir1\*.cs
-                 * 
+                 *
                  * Where the trailing spec is meant to be a filename. Or,
-                 * 
+                 *
                  *      dir1\**
-                 * 
+                 *
                  * Where the trailing spec is meant to be any file recursively.
                  */
 
@@ -675,11 +676,11 @@ out string filenamePart
             {
                 /*
                  * There is no separator before the wildcard, so the form is like this:
-                 * 
+                 *
                  *      dir?\Source.cs
-                 * 
+                 *
                  * or this,
-                 * 
+                 *
                  *      dir?\**
                  */
                 fixedDirectoryPart = string.Empty;
@@ -697,7 +698,7 @@ out string filenamePart
         }
 
         /// <summary>
-        /// Removes the leading ".\" from all of the paths in the array. 
+        /// Removes the leading ".\" from all of the paths in the array.
         /// </summary>
         /// <param name="paths">Paths to remove .\ from.</param>
         private static IEnumerable<string> RemoveInitialDotSlash
@@ -728,7 +729,7 @@ internal static bool IsDirectorySeparator(char c)
             return c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar;
         }
         /// <summary>
-        /// Removes the current directory converting the file back to relative path 
+        /// Removes the current directory converting the file back to relative path
         /// </summary>
         /// <param name="paths">Paths to remove current directory from.</param>
         /// <param name="projectDirectory"></param>
@@ -837,7 +838,7 @@ struct RecursionState
         }
 
         /// <summary>
-        /// Get all files that match either the file-spec or the regular expression. 
+        /// Get all files that match either the file-spec or the regular expression.
         /// </summary>
         /// <param name="listOfFiles">List of files that gets populated.</param>
         /// <param name="recursionState">Information about the search</param>
@@ -956,7 +957,7 @@ private void GetFilesRecursive(
                     for (int i = 0; i < excludeNextSteps.Length; i++)
                     {
                         if (excludeNextSteps[i].NeedsDirectoryRecursion &&
-                            (excludeNextSteps[i].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[i].DirectoryPattern)))
+                            (excludeNextSteps[i].DirectoryPattern == null || IsFileNameMatch(subdir, excludeNextSteps[i].DirectoryPattern)))
                         {
                             RecursionState thisExcludeStep = searchesToExclude[i];
                             thisExcludeStep.BaseDirectory = subdir;
@@ -986,7 +987,7 @@ private void GetFilesRecursive(
                     }
                 }
 
-                // We never want to strip the project directory from the leaves, because the current 
+                // We never want to strip the project directory from the leaves, because the current
                 // process directory maybe different
                 GetFilesRecursive(
                     listOfFiles,
@@ -1097,7 +1098,7 @@ private static bool MatchFileRecursionStep(RecursionState recursionState, string
             }
             else if (recursionState.SearchData.Filespec != null)
             {
-                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec);
+                return IsFileNameMatch(file, recursionState.SearchData.Filespec);
             }
 
             // if no file-spec provided, match the file to the regular expression
@@ -1171,7 +1172,7 @@ RecursionState recursionState
                         //        foo\**\bar
                         //
                         // back into remainingWildcardDirectory.
-                        // This is a performance optimization. We don't want to enumerate everything if we 
+                        // This is a performance optimization. We don't want to enumerate everything if we
                         // don't have to.
                         recursionState.RemainingWildcardDirectory = indexOfNextSlash != -1 ? recursionState.RemainingWildcardDirectory.Substring(indexOfNextSlash + 1) : string.Empty;
                     }
@@ -1190,7 +1191,7 @@ RecursionState recursionState
         /// a sub-directory containing wildcard characters,
         /// and a filename which may contain wildcard characters,
         /// create a regular expression that will match that file spec.
-        /// 
+        ///
         /// PERF WARNING: this method is called in performance-critical
         /// scenarios, so keep it fast and cheap
         /// </summary>
@@ -1227,9 +1228,9 @@ string filenamePart
 
         /// <summary>
         /// Determine if the filespec is legal according to the following conditions:
-        /// 
+        ///
         /// (1) It is not legal for there to be a ".." after a wildcard.
-        /// 
+        ///
         /// (2) By definition, "**" must appear alone between directory slashes.If there is any remaining "**" then this is not
         ///     a valid filespec.
         /// </summary>
@@ -1273,7 +1274,7 @@ private static bool HasMisplacedRecursiveOperator(string str)
         /// Append the regex equivalents for character sequences in the fixed directory part of a filespec:
         ///
         /// (1) The leading \\ in UNC paths, so that the doubled slash isn't reduced in the last step
-        /// 
+        ///
         /// (2) Common filespec characters
         /// </summary>
         private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBuilder regex, string fixedDir)
@@ -1300,7 +1301,7 @@ private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBui
         /// (1) The leading **\ if existing
         ///
         /// (2) Each occurrence of recursive wildcard \**\
-        /// 
+        ///
         /// (3) Common filespec characters
         /// </summary>
         private static void AppendRegularExpressionFromWildcardDirectory(ReuseableStringBuilder regex, string wildcardDir)
@@ -1343,7 +1344,7 @@ private static void AppendRegularExpressionFromWildcardDirectory(ReuseableString
         ///
         ///     but 'foo' doesn't have a trailing '.' so we need to handle this while still being careful
         ///     not to match 'foo.txt' by modifying the generated regex for wildcard characters * and ?
-        /// 
+        ///
         /// (2) Common filespec characters
         ///
         /// (3) Ignore the .* portion of any *.* sequence when no trailing dot exists
@@ -1422,7 +1423,7 @@ private static bool IsSpecialRegexCharacter(char ch) =>
         ///     This is an identity, so for example, these two are equivalent,
         ///
         ///         dir1\.\dir2 == dir1\dir2
-        /// 
+        ///
         ///     (2) \\ -> \
         ///         Double directory separators are treated as a single directory separator,
         ///         so, for example, this is an identity:
@@ -1432,7 +1433,7 @@ private static bool IsSpecialRegexCharacter(char ch) =>
         ///         The single exemption is for UNC path names, like this:
         ///
         ///             \\server\share != \server\share
-        /// 
+        ///
         ///         This case is handled by isUncPath in
         ///         a prior step.
         ///
@@ -1472,9 +1473,9 @@ private static int LastIndexOfDirectorySequence(string str, int startIndex)
         /// <summary>
         /// Given an index at a directory separator or start of a recursive operator,
         /// iteratively skip to the end of three sequences:
-        /// 
+        ///
         /// (1), (2) Both sequences handled by IndexOfNextNonCollapsibleChar
-        /// 
+        ///
         /// (3) \**\**\ -> \**\
         ///              This is an identity, so for example, these two are equivalent,
         ///
@@ -1515,7 +1516,7 @@ private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int start
         }
 
         /// <summary>
-        /// Given a filespec, get the information needed for file matching. 
+        /// Given a filespec, get the information needed for file matching.
         /// </summary>
         /// <param name="filespec">The filespec.</param>
         /// <param name="regexFileMatch">Receives the regular expression.</param>
@@ -1616,7 +1617,7 @@ internal static bool RawFileSpecIsValid(string filespec)
 
             /*
              * Check for patterns in the filespec that are explicitly illegal.
-             * 
+             *
              * Any path with "..." in it is illegal.
              */
             if (-1 != filespec.IndexOf("...", StringComparison.Ordinal))
@@ -1627,9 +1628,9 @@ internal static bool RawFileSpecIsValid(string filespec)
             /*
              * If there is a ':' anywhere but the second character, this is an illegal pattern.
              * Catches this case among others,
-             * 
+             *
              *        http://www.website.com
-             * 
+             *
              */
             int rightmostColon = filespec.LastIndexOf(":", StringComparison.Ordinal);
 
@@ -1664,12 +1665,39 @@ internal Result()
             internal string wildcardDirectoryPart = string.Empty;
         }
 
+        /// <summary>
+        /// A wildcard (* and ?) matching algorithm that tests whether the input path file name matches against the pattern.
+        /// </summary>
+        /// <param name="path">The path whose file name is matched against the pattern.</param>
+        /// <param name="pattern">The pattern.</param>
+        internal static bool IsFileNameMatch(string path, string pattern)
+        {
+            // Use a span-based Path.GetFileName if it is available.
+#if FEATURE_MSIOREDIST
+            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);
+#elif NETSTANDARD2_0
+            return IsMatch(Path.GetFileName(path), pattern);
+#else
+            return IsMatch(Path.GetFileName(path.AsSpan()), pattern);
+#endif
+        }
+
         /// <summary>
         /// A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
         /// </summary>
         /// <param name="input">String which is matched against the pattern.</param>
         /// <param name="pattern">Pattern against which string is matched.</param>
         internal static bool IsMatch(string input, string pattern)
+        {
+            return IsMatch(input.AsSpan(), pattern);
+        }
+
+        /// <summary>
+        /// A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
+        /// </summary>
+        /// <param name="input">String which is matched against the pattern.</param>
+        /// <param name="pattern">Pattern against which string is matched.</param>
+        internal static bool IsMatch(ReadOnlySpan<char> input, string pattern)
         {
             if (input == null)
             {
@@ -1705,9 +1733,12 @@ internal static bool IsMatch(string input, string pattern)
             // to using the string indexer. The iIndex and pIndex parameters are only used
             // when we have to compare two non ASCII characters. Using just string.Compare for
             // character comparison, would reduce the speed by approx. 5 times.
-            bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
+            bool CompareIgnoreCase(ref ReadOnlySpan<char> input, int iIndex, int pIndex)
 #endif
             {
+                char inputChar = input[iIndex];
+                char patternChar = pattern[pIndex];
+
                 // We will mostly be comparing ASCII characters, check English letters first.
                 char inputCharLower = (char)(inputChar | 0x20);
                 if (inputCharLower >= 'a' && inputCharLower <= 'z')
@@ -1721,7 +1752,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table
                     return inputChar == patternChar;
                 }
-                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;
+                return MemoryExtensions.Equals(input.Slice(iIndex, 1), pattern.AsSpan(pIndex, 1), StringComparison.OrdinalIgnoreCase);
             }
 #if MONO
             ; // The end of the CompareIgnoreCase anonymous function
@@ -1761,7 +1792,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                                     break;
                                 }
                                 // If the tail doesn't match, we can safely return e.g. ("aaa", "*b")
-                                if (!CompareIgnoreCase(input[inputTailIndex], pattern[patternTailIndex], patternTailIndex, inputTailIndex) &&
+                                if (!CompareIgnoreCase(ref input, inputTailIndex, patternTailIndex) &&
                                     pattern[patternTailIndex] != '?')
                                 {
                                     return false;
@@ -1781,7 +1812,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                         // The ? wildcard cannot be skipped as we will have a wrong result for e.g. ("aab" "*?b")
                         if (pattern[patternIndex] != '?')
                         {
-                            while (!CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex))
+                            while (!CompareIgnoreCase(ref input, inputIndex, patternIndex))
                             {
                                 // Return if there is no character that match e.g. ("aa", "*b")
                                 if (++inputIndex >= inputLength)
@@ -1796,7 +1827,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     }
 
                     // If we have a match, step to the next character
-                    if (CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex) ||
+                    if (CompareIgnoreCase(ref input, inputIndex, patternIndex) ||
                         pattern[patternIndex] == '?')
                     {
                         patternIndex++;
@@ -1903,7 +1934,7 @@ public TaskOptions(int maxTasks)
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// Will never throw IO exceptions: if there is no match, returns the input verbatim.
         /// </summary>
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
@@ -2279,7 +2310,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
         }
 
         /// <summary>
-        /// Given a filespec, find the files that match. 
+        /// Given a filespec, find the files that match.
         /// Will never throw IO exceptions: if there is no match, returns the input verbatim.
         /// </summary>
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
@@ -2557,14 +2588,14 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
         private static bool DirectoryEndsWithPattern(string directoryPath, string pattern)
         {
             int index = directoryPath.LastIndexOfAny(FileUtilities.Slashes);
-            return (index != -1 && IsMatch(directoryPath.Substring(index + 1), pattern));
+            return (index != -1 && IsMatch(directoryPath.AsSpan(index + 1), pattern));
         }
 
         /// <summary>
         /// Returns true if <paramref name="pattern"/> is <code>*</code> or <code>*.*</code>.
         /// </summary>
         /// <param name="pattern">The filename pattern to check.</param>
-        private static bool IsAllFilesWildcard(string pattern) => pattern?.Length switch
+        internal static bool IsAllFilesWildcard(string pattern) => pattern?.Length switch
         {
             1 => pattern[0] == '*',
             3 => pattern[0] == '*' && pattern[1] == '.' && pattern[2] == '*',
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 6d8bd32fb4e..982a7d97273 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -16,6 +17,20 @@ internal class ManagedFileSystem : IFileSystem
 
         public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
 
+        private static bool ShouldUseMicrosoftIO
+        {
+            get
+            {
+#if !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+#else
+                // We need to mock usage of ChangeWaves class,
+                // because Microsoft.Build.Engine.OM.UnitTests should not have access to internals of Microsoft.Build.Framework.
+                return true;
+#endif
+            }
+        }
+
         protected ManagedFileSystem() { }
 
         public TextReader ReadFile(string path)
@@ -38,19 +53,78 @@ public byte[] ReadFileAllBytes(string path)
             return File.ReadAllBytes(path);
         }
 
+#if FEATURE_MSIOREDIST
+        private static IEnumerable<string> HandleFileLoadException(
+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,
+            string path,
+            string searchPattern,
+            Microsoft.IO.SearchOption searchOption
+        )
+        {
+            try
+            {
+                return enumerateFunctionDelegate(path, searchPattern, searchOption);
+            }
+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.
+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.
+            // We rethrow it to make it fail with a proper error message and call stack.
+            catch (FileLoadException ex)
+            {
+                throw new InvalidOperationException(ex.Message, ex);
+            }
+            // Sometimes FileNotFoundException is thrown when there is an assembly load failure. In this case it should have FusionLog.
+            catch (FileNotFoundException ex) when (ex.FusionLog != null)
+            {
+                throw new InvalidOperationException(ex.Message, ex);
+            }
+        }
+#endif
+
         public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFiles(path, searchPattern, searchOption),
+                    path,
+                    searchPattern,
+                    (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateFiles(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateFiles(path, searchPattern, searchOption);
+#endif
         }
 
         public virtual IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateDirectories(path, searchPattern, searchOption),
+                    path,
+                    searchPattern,
+                    (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateDirectories(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateDirectories(path, searchPattern, searchOption);
+#endif
         }
 
         public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption),
+                    path,
+                    searchPattern, (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+#endif
         }
 
         public FileAttributes GetAttributes(string path)
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 76155b33800..5d90ac65a18 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -17,7 +17,7 @@
 using System.Runtime.CompilerServices;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.Utilities;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
@@ -903,7 +903,7 @@ internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSys
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.DirectoryExists(fullPath))
                     : fileSystem.DirectoryExists(fullPath);
             }
             catch
@@ -927,7 +927,7 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.FileExists(fullPath))
                     : fileSystem.FileExists(fullPath);
             }
             catch
@@ -951,7 +951,7 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileOrDirectoryExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.FileOrDirectoryExists(fullPath))
                     : fileSystem.FileOrDirectoryExists(fullPath);
             }
             catch
@@ -1061,7 +1061,7 @@ internal static string MakeRelative(string basePath, string path)
             {
                 return ".";
             }
-            
+
             // If the paths have no component in common, the only valid relative path is the full path.
             if (index == 0)
             {
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index afdbc7fefec..42237dde8c9 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -976,13 +976,10 @@ internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootP
 
             try
             {
-                string path = targetFrameworkRootPath;
-                path = Path.Combine(path, frameworkName.Identifier);
-                path = Path.Combine(path, "v" + frameworkName.Version.ToString());
+                string path = Path.Combine(targetFrameworkRootPath, frameworkName.Identifier, "v" + frameworkName.Version.ToString());
                 if (!String.IsNullOrEmpty(frameworkName.Profile))
                 {
-                    path = Path.Combine(path, "Profile");
-                    path = Path.Combine(path, frameworkName.Profile);
+                    path = Path.Combine(path, "Profile", frameworkName.Profile);
                 }
 
                 return Path.GetFullPath(path);
diff --git a/src/Shared/FxCopExclusions/Microsoft.Build.Shared.Suppressions.cs b/src/Shared/FxCopExclusions/Microsoft.Build.Shared.Suppressions.cs
deleted file mode 100644
index e0dd6eed111..00000000000
--- a/src/Shared/FxCopExclusions/Microsoft.Build.Shared.Suppressions.cs
+++ /dev/null
@@ -1,153 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-// FxCop Suppression file
-// To Use:
-// Add module level suppressions to this file to have them suppressed in the assembly
-//
-
-#if CODE_ANALYSIS
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#GetExplicitMSBuildArchitecture(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#GetExplicitMSBuildRuntime(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#IsBadlyCasedSpecialTaskAttribute(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#IsNonBatchingTargetAttribute(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#IsSpecialTaskAttribute(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#IsValidMSBuildArchitectureValue(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#IsValidMSBuildRuntimeValue(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#RuntimeValuesMatch(System.String,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#TryMergeArchitectureValues(System.String,System.String,System.String&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#TryMergeRuntimeValues(System.String,System.String,System.String&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#ArchitectureValuesMatch(System.String,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.TypeLoader.#ReflectionOnlyLoad(System.String,Microsoft.Build.Shared.AssemblyLoadInfo)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared+PROCESS_BASIC_INFORMATION.#get_Size()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#WaitForMultipleObjects(System.UInt32,System.IntPtr[],System.Boolean,System.UInt32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#SetErrorMode_Win7AndNewer(System.Int32,System.Int32&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#SetErrorMode_VistaAndOlder(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#SetErrorMode(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#SearchPath(System.String,System.String,System.String,System.Int32,System.Text.StringBuilder,System.Int32[])", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#ReadFile(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Byte[],System.UInt32,System.UInt32&,System.IntPtr)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#OpenProcess(Microsoft.Build.Shared.NativeMethodsShared+eDesiredAccess,System.Boolean,System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#NtQueryInformationProcess(Microsoft.Build.Shared.NativeMethodsShared+SafeProcessHandle,Microsoft.Build.Shared.NativeMethodsShared+PROCESSINFOCLASS,Microsoft.Build.Shared.NativeMethodsShared+PROCESS_BASIC_INFORMATION&,System.Int32,System.Int32&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.TimeSpan)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#LoadLibrary(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#KillTree(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#HResultSucceeded(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#HResultFailed(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GlobalMemoryStatusEx(Microsoft.Build.Shared.NativeMethodsShared+MemoryStatus)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetSystemInfo(Microsoft.Build.Shared.NativeMethodsShared+SYSTEM_INFO&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetStdHandle(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetShortPathName(System.String,System.Text.StringBuilder,System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetShortFilePath(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetRequestedRuntimeInfo(System.String,System.String,System.String,System.UInt32,System.UInt32,System.Text.StringBuilder,System.Int32,System.UInt32&,System.Text.StringBuilder,System.Int32,System.UInt32&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetProcAddress(System.IntPtr,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetParentProcessId(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetOEMCP()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetNativeSystemInfo(Microsoft.Build.Shared.NativeMethodsShared+SYSTEM_INFO&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetModuleFileName(System.Runtime.InteropServices.HandleRef,System.Text.StringBuilder,System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetMemoryStatus()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetLongPathName(System.String,System.Text.StringBuilder,System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#CreatePipe(Microsoft.Win32.SafeHandles.SafeFileHandle&,Microsoft.Win32.SafeHandles.SafeFileHandle&,Microsoft.Build.Shared.NativeMethodsShared+SecurityAttributes,System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#FreeLibrary(System.IntPtr)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetChildProcessIds(System.Int32,System.DateTime)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetCurrentDirectory()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetCurrentDirectory(System.Int32,System.Text.StringBuilder)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetFileAttributesEx(System.String,System.Int32,Microsoft.Build.Shared.NativeMethodsShared+WIN32_FILE_ATTRIBUTE_DATA&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetFileType(System.IntPtr)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetLastWriteDirectoryUtcTime(System.String,System.DateTime&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetLastWriteFileUtcTime(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#GetLongFilePath(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#IsMetaprojectFilename(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#IsSolutionFilename(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#IsVCProjFilename(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#MakeRelative(System.String,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#TrimAndStripAnyQuotes(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities+ItemSpecModifiers.#GetItemSpecModifier(System.String,System.String,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.LoadedType.#.ctor(System.Type,Microsoft.Build.Shared.AssemblyLoadInfo)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.LogMessagePacketBase.#.ctor(Microsoft.Build.BackEnd.ITranslator)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.LogMessagePacketBase.#get_EventType()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.LogMessagePacketBase.#get_NodeBuildEvent()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.NativeMethodsShared.#CoWaitForMultipleHandles(Microsoft.Build.Shared.NativeMethodsShared+COWAIT_FLAGS,System.Int32,System.Int32,System.IntPtr[],System.Int32&)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#EnsureNoLeadingSlash(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#EnsureNoTrailingSlash(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#EnsureTrailingSlash(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#get_ExecutingAssemblyPath()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#FileExistsNoThrow(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#FileOrDirectoryExistsNoThrow(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#GetCacheDirectory()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#GetDirectoryNameOfFullPath(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#GetHexHash(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#GetPathsHash(System.Collections.Generic.IEnumerable`1<System.String>)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#HasExtension(System.String,System.String[])", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling+LineAndColumn.#set_Line(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#ClearCacheDirectory()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#CreateUriFromPath(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#get_CurrentExecutableConfigurationFilePath()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#get_CurrentExecutableDirectory()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#get_CurrentExecutableName()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#get_CurrentExecutablePath()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#DeleteDirectoryNoThrow(System.String,System.Boolean)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#DeleteNoThrow(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#DirectoryExistsNoThrow(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#GetXmlLineAndColumn(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#IsIoRelatedException(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#IsXmlException(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#NotExpectedFunctionException(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#NotExpectedIoOrXmlException(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#NotExpectedReflectionException(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#NotExpectedRegistryException(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling.#NotExpectedSerializationException(System.Exception)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling+LineAndColumn.#get_Column()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling+LineAndColumn.#set_Column(System.Int32)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ExceptionHandling+LineAndColumn.#get_Line()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgumentArraysSameLength(System.Array,System.Array,System.String,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgumentLengthIfNotNull(System.String,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgumentOutOfRange(System.Boolean,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowInternalLength(System.String,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowInternalLockHeld(System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowInternalRooted(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowInvalidOperation(System.Boolean,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowInvalidOperation(System.Boolean,System.String,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.EscapingUtilities.#ContainsEscapedWildcards(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#ThrowIfTypeDoesNotImplementToString(System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrow(System.Boolean,System.String,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrow(System.Boolean,System.String,System.Object,System.Object,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.Exception,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.Exception,System.String,System.Object,System.Object,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#VerifyThrowArgument(System.Boolean,System.String,System.Object,System.Object,System.Object)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.PartialComparisonFlags)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,Microsoft.Build.Shared.PartialComparisonFlags,System.Boolean)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#PartialNameCompare(Microsoft.Build.Shared.AssemblyNameExtension,System.Boolean)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_ProcessorArchitecture()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_RemappedFromEnumerator()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#ReplaceVersion(System.Version)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_UnnamedAssembly()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.CollectionHelpers.#RemoveNulls`1(System.Collections.Generic.List`1<!!0>)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#DebugTraceMessage(System.String,System.String,System.Object[])", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.ErrorUtilities.#ThrowArgument(System.String,System.Object[])", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#Clone()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#CloneImmutable()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#CompareTo(Microsoft.Build.Shared.AssemblyNameExtension)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#EqualsIgnoreVersion(Microsoft.Build.Shared.AssemblyNameExtension)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#EscapeDisplayNameCharacters(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#GetAssemblyNameEx(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_HasProcessorArchitectureInFusionName()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_Immutable()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_IsSimpleName()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_IsUnnamedAssembly()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#MarkImmutable()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyLoadInfo.#FactoryForTranslation(Microsoft.Build.BackEnd.ITranslator)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#.ctor(System.String,System.Boolean)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#AddRemappedAssemblyName(Microsoft.Build.Shared.AssemblyNameExtension)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension.#get_AssemblyName()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#get_CurrentExecutableName()", Justification="Source file used by several assemblies and this method is not called by all of them.")]
-
-#endif
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 1de3e06bced..7e3842bbbbd 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -53,22 +53,20 @@ public MSBuildLoadContext(string assemblyPath)
                 // bare search directory if that fails.
                 : new[] { assemblyName.CultureName, string.Empty })
             {
-                    var candidatePath = Path.Combine(_directory,
-                        cultureSubfolder,
-                        $"{assemblyName.Name}.dll");
+                var candidatePath = Path.Combine(_directory,
+                    cultureSubfolder,
+                    $"{assemblyName.Name}.dll");
 
-                    if (!FileSystems.Default.FileExists(candidatePath))
-                    {
-                        continue;
-                    }
-
-                    AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
-                    if (candidateAssemblyName.Version != assemblyName.Version)
-                    {
-                        continue;
-                    }
+                if (!FileSystems.Default.FileExists(candidatePath))
+                {
+                    continue;
+                }
 
+                AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
+                if (candidateAssemblyName.Version >= assemblyName.Version)
+                {
                     return LoadFromAssemblyPath(candidatePath);
+                }
             }
 
             // If the Assembly is provided via a file path, the following rules are used to load the assembly:
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index 1ad37579cb6..bfb564d884b 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -599,7 +599,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    ErrorUtilities.VerifyThrowInvalidOperation(false, "Shared.InvalidFilespecForTransform", modifier, itemSpec, e.Message);
+                    ErrorUtilities.ThrowInvalidOperation("Shared.InvalidFilespecForTransform", modifier, itemSpec, e.Message);
                 }
 
                 return modifiedItemSpec;
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index a7f8913e7d7..e3b1341515f 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -1,15 +1,24 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
+using System.Diagnostics;
 using System.IO;
 
+#nullable enable
+
 namespace Microsoft.Build.Shared
 {
     internal static class NamedPipeUtil
     {
-        internal static string GetPipeNameOrPath(string pipeName)
+        internal static string GetPipeNameOrPath(int? processId = null)
         {
+            if (processId is null)
+            {
+                processId = Process.GetCurrentProcess().Id;
+            }
+
+            string pipeName = $"MSBuild{processId}";
+
             if (NativeMethodsShared.IsUnixLike)
             {
                 // If we're on a Unix machine then named pipes are implemented using Unix Domain Sockets.
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
deleted file mode 100644
index 28460e8aa15..00000000000
--- a/src/Shared/NativeMethodsShared.cs
+++ /dev/null
@@ -1,1739 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Text;
-using System.Threading;
-using System.Reflection;
-using Microsoft.Build.Framework;
-using Microsoft.Win32;
-using Microsoft.Win32.SafeHandles;
-
-using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
-using Microsoft.Build.Utilities;
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// Interop methods.
-    /// </summary>
-    internal static class NativeMethodsShared
-    {
-        #region Constants
-
-        internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
-        internal const uint STARTUP_LOADER_SAFEMODE = 0x10;
-        internal const uint S_OK = 0x0;
-        internal const uint S_FALSE = 0x1;
-        internal const uint ERROR_ACCESS_DENIED = 0x5;
-        internal const uint ERROR_FILE_NOT_FOUND = 0x80070002;
-        internal const uint FUSION_E_PRIVATE_ASM_DISALLOWED = 0x80131044; // Tried to find unsigned assembly in GAC
-        internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
-        internal const uint FILE_TYPE_CHAR = 0x0002;
-        internal const Int32 STD_OUTPUT_HANDLE = -11;
-        internal const uint RPC_S_CALLPENDING = 0x80010115;
-        internal const uint E_ABORT = (uint)0x80004004;
-
-        internal const int FILE_ATTRIBUTE_READONLY = 0x00000001;
-        internal const int FILE_ATTRIBUTE_DIRECTORY = 0x00000010;
-        internal const int FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400;
-
-        /// <summary>
-        /// Default buffer size to use when dealing with the Windows API.
-        /// </summary>
-        internal const int MAX_PATH = 260;
-
-        private const string kernel32Dll = "kernel32.dll";
-        private const string mscoreeDLL = "mscoree.dll";
-
-        private const string WINDOWS_FILE_SYSTEM_REGISTRY_KEY = @"SYSTEM\CurrentControlSet\Control\FileSystem";
-        private const string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME = "LongPathsEnabled";
-
-        internal static DateTime MinFileDate { get; } = DateTime.FromFileTimeUtc(0);
-
-#if FEATURE_HANDLEREF
-        internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
-#endif
-
-        internal static IntPtr NullIntPtr = new IntPtr(0);
-
-        // As defined in winnt.h:
-        internal const ushort PROCESSOR_ARCHITECTURE_INTEL = 0;
-        internal const ushort PROCESSOR_ARCHITECTURE_ARM = 5;
-        internal const ushort PROCESSOR_ARCHITECTURE_IA64 = 6;
-        internal const ushort PROCESSOR_ARCHITECTURE_AMD64 = 9;
-        internal const ushort PROCESSOR_ARCHITECTURE_ARM64 = 12;
-
-        internal const uint INFINITE = 0xFFFFFFFF;
-        internal const uint WAIT_ABANDONED_0 = 0x00000080;
-        internal const uint WAIT_OBJECT_0 = 0x00000000;
-        internal const uint WAIT_TIMEOUT = 0x00000102;
-
-#if FEATURE_CHARSET_AUTO
-        internal const CharSet AutoOrUnicode = CharSet.Auto;
-#else
-        internal const CharSet AutoOrUnicode = CharSet.Unicode;
-#endif
-
-        #endregion
-
-        #region Enums
-
-        private enum PROCESSINFOCLASS : int
-        {
-            ProcessBasicInformation = 0,
-            ProcessQuotaLimits,
-            ProcessIoCounters,
-            ProcessVmCounters,
-            ProcessTimes,
-            ProcessBasePriority,
-            ProcessRaisePriority,
-            ProcessDebugPort,
-            ProcessExceptionPort,
-            ProcessAccessToken,
-            ProcessLdtInformation,
-            ProcessLdtSize,
-            ProcessDefaultHardErrorMode,
-            ProcessIoPortHandlers, // Note: this is kernel mode only
-            ProcessPooledUsageAndLimits,
-            ProcessWorkingSetWatch,
-            ProcessUserModeIOPL,
-            ProcessEnableAlignmentFaultFixup,
-            ProcessPriorityClass,
-            ProcessWx86Information,
-            ProcessHandleCount,
-            ProcessAffinityMask,
-            ProcessPriorityBoost,
-            MaxProcessInfoClass
-        };
-
-        private enum eDesiredAccess : int
-        {
-            DELETE = 0x00010000,
-            READ_CONTROL = 0x00020000,
-            WRITE_DAC = 0x00040000,
-            WRITE_OWNER = 0x00080000,
-            SYNCHRONIZE = 0x00100000,
-            STANDARD_RIGHTS_ALL = 0x001F0000,
-
-            PROCESS_TERMINATE = 0x0001,
-            PROCESS_CREATE_THREAD = 0x0002,
-            PROCESS_SET_SESSIONID = 0x0004,
-            PROCESS_VM_OPERATION = 0x0008,
-            PROCESS_VM_READ = 0x0010,
-            PROCESS_VM_WRITE = 0x0020,
-            PROCESS_DUP_HANDLE = 0x0040,
-            PROCESS_CREATE_PROCESS = 0x0080,
-            PROCESS_SET_QUOTA = 0x0100,
-            PROCESS_SET_INFORMATION = 0x0200,
-            PROCESS_QUERY_INFORMATION = 0x0400,
-            PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF
-        }
-#pragma warning disable 0649, 0169
-        internal enum LOGICAL_PROCESSOR_RELATIONSHIP
-        {
-            RelationProcessorCore,
-            RelationNumaNode,
-            RelationCache,
-            RelationProcessorPackage,
-            RelationGroup,
-            RelationAll = 0xffff
-        }
-        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
-        {
-            public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
-            public uint Size;
-            public PROCESSOR_RELATIONSHIP Processor;
-        }
-        [StructLayout(LayoutKind.Sequential)]
-        internal unsafe struct PROCESSOR_RELATIONSHIP
-        {
-            public byte Flags;
-            private byte EfficiencyClass;
-            private fixed byte Reserved[20];
-            public ushort GroupCount;
-            public IntPtr GroupInfo;
-        }
-#pragma warning restore 0169, 0149
-
-        /// <summary>
-        /// Flags for CoWaitForMultipleHandles
-        /// </summary>
-        [Flags]
-        public enum COWAIT_FLAGS : int
-        {
-            /// <summary>
-            /// Exit when a handle is signaled.
-            /// </summary>
-            COWAIT_NONE = 0,
-
-            /// <summary>
-            /// Exit when all handles are signaled AND a message is received.
-            /// </summary>
-            COWAIT_WAITALL = 0x00000001,
-
-            /// <summary>
-            /// Exit when an RPC call is serviced.
-            /// </summary>
-            COWAIT_ALERTABLE = 0x00000002
-        }
-
-        /// <summary>
-        /// Processor architecture values
-        /// </summary>
-        internal enum ProcessorArchitectures
-        {
-            // Intel 32 bit
-            X86,
-
-            // AMD64 64 bit
-            X64,
-
-            // Itanium 64
-            IA64,
-
-            // ARM
-            ARM,
-
-            // ARM64
-            ARM64,
-
-            // Who knows
-            Unknown
-        }
-
-        #endregion
-
-        #region Structs
-
-        /// <summary>
-        /// Structure that contain information about the system on which we are running
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential)]
-        internal struct SYSTEM_INFO
-        {
-            // This is a union of a DWORD and a struct containing 2 WORDs.
-            internal ushort wProcessorArchitecture;
-            internal ushort wReserved;
-
-            internal uint dwPageSize;
-            internal IntPtr lpMinimumApplicationAddress;
-            internal IntPtr lpMaximumApplicationAddress;
-            internal IntPtr dwActiveProcessorMask;
-            internal uint dwNumberOfProcessors;
-            internal uint dwProcessorType;
-            internal uint dwAllocationGranularity;
-            internal ushort wProcessorLevel;
-            internal ushort wProcessorRevision;
-        }
-
-        /// <summary>
-        /// Wrap the intptr returned by OpenProcess in a safe handle.
-        /// </summary>
-        internal class SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid
-        {
-            // Create a SafeHandle, informing the base class
-            // that this SafeHandle instance "owns" the handle,
-            // and therefore SafeHandle should call
-            // our ReleaseHandle method when the SafeHandle
-            // is no longer in use
-            private SafeProcessHandle() : base(true)
-            {
-            }
-            protected override bool ReleaseHandle()
-            {
-                return CloseHandle(handle);
-            }
-        }
-
-        /// <summary>
-        /// Contains information about the current state of both physical and virtual memory, including extended memory
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential, CharSet = AutoOrUnicode)]
-        internal class MemoryStatus
-        {
-            /// <summary>
-            /// Initializes a new instance of the <see cref="T:MemoryStatus"/> class.
-            /// </summary>
-            public MemoryStatus()
-            {
-#if (CLR2COMPATIBILITY)
-            _length = (uint)Marshal.SizeOf(typeof(NativeMethodsShared.MemoryStatus));
-#else
-            _length = (uint)Marshal.SizeOf<NativeMethodsShared.MemoryStatus>();
-#endif
-            }
-
-            /// <summary>
-            /// Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
-            /// </summary>
-            private uint _length;
-
-            /// <summary>
-            /// Number between 0 and 100 that specifies the approximate percentage of physical
-            /// memory that is in use (0 indicates no memory use and 100 indicates full memory use).
-            /// </summary>
-            public uint MemoryLoad;
-
-            /// <summary>
-            /// Total size of physical memory, in bytes.
-            /// </summary>
-            public ulong TotalPhysical;
-
-            /// <summary>
-            /// Size of physical memory available, in bytes.
-            /// </summary>
-            public ulong AvailablePhysical;
-
-            /// <summary>
-            /// Size of the committed memory limit, in bytes. This is physical memory plus the
-            /// size of the page file, minus a small overhead.
-            /// </summary>
-            public ulong TotalPageFile;
-
-            /// <summary>
-            /// Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
-            /// </summary>
-            public ulong AvailablePageFile;
-
-            /// <summary>
-            /// Total size of the user mode portion of the virtual address space of the calling process, in bytes.
-            /// </summary>
-            public ulong TotalVirtual;
-
-            /// <summary>
-            /// Size of unreserved and uncommitted memory in the user mode portion of the virtual
-            /// address space of the calling process, in bytes.
-            /// </summary>
-            public ulong AvailableVirtual;
-
-            /// <summary>
-            /// Size of unreserved and uncommitted memory in the extended portion of the virtual
-            /// address space of the calling process, in bytes.
-            /// </summary>
-            public ulong AvailableExtendedVirtual;
-        }
-
-        [StructLayout(LayoutKind.Sequential)]
-        private struct PROCESS_BASIC_INFORMATION
-        {
-            public uint ExitStatus;
-            public IntPtr PebBaseAddress;
-            public UIntPtr AffinityMask;
-            public int BasePriority;
-            public UIntPtr UniqueProcessId;
-            public UIntPtr InheritedFromUniqueProcessId;
-
-            public uint Size
-            {
-                get
-                {
-                    unsafe
-                    {
-                        return (uint)sizeof(PROCESS_BASIC_INFORMATION);
-                    }
-                }
-            }
-        };
-
-        /// <summary>
-        /// Contains information about a file or directory; used by GetFileAttributesEx.
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential)]
-        public struct WIN32_FILE_ATTRIBUTE_DATA
-        {
-            internal int fileAttributes;
-            internal uint ftCreationTimeLow;
-            internal uint ftCreationTimeHigh;
-            internal uint ftLastAccessTimeLow;
-            internal uint ftLastAccessTimeHigh;
-            internal uint ftLastWriteTimeLow;
-            internal uint ftLastWriteTimeHigh;
-            internal uint fileSizeHigh;
-            internal uint fileSizeLow;
-        }
-
-        /// <summary>
-        /// Contains the security descriptor for an object and specifies whether
-        /// the handle retrieved by specifying this structure is inheritable.
-        /// </summary>
-        [StructLayout(LayoutKind.Sequential)]
-        internal class SecurityAttributes
-        {
-            public SecurityAttributes()
-            {
-#if (CLR2COMPATIBILITY)
-            _nLength = (uint)Marshal.SizeOf(typeof(NativeMethodsShared.SecurityAttributes));
-#else
-            _nLength = (uint)Marshal.SizeOf<NativeMethodsShared.SecurityAttributes>();
-#endif
-            }
-
-            private uint _nLength;
-
-            public IntPtr lpSecurityDescriptor;
-
-            public bool bInheritHandle;
-        }
-
-        private class SystemInformationData
-        {
-            /// <summary>
-            /// Architecture as far as the current process is concerned.
-            /// It's x86 in wow64 (native architecture is x64 in that case).
-            /// Otherwise it's the same as the native architecture.
-            /// </summary>
-            public readonly ProcessorArchitectures ProcessorArchitectureType;
-
-            /// <summary>
-            /// Actual architecture of the system.
-            /// </summary>
-            public readonly ProcessorArchitectures ProcessorArchitectureTypeNative;
-
-            /// <summary>
-            /// Convert SYSTEM_INFO architecture values to the internal enum
-            /// </summary>
-            /// <param name="arch"></param>
-            /// <returns></returns>
-            private static ProcessorArchitectures ConvertSystemArchitecture(ushort arch)
-            {
-                return arch switch
-                {
-                    PROCESSOR_ARCHITECTURE_INTEL => ProcessorArchitectures.X86,
-                    PROCESSOR_ARCHITECTURE_AMD64 => ProcessorArchitectures.X64,
-                    PROCESSOR_ARCHITECTURE_ARM => ProcessorArchitectures.ARM,
-                    PROCESSOR_ARCHITECTURE_IA64 => ProcessorArchitectures.IA64,
-                    PROCESSOR_ARCHITECTURE_ARM64 => ProcessorArchitectures.ARM64,
-                    _ => ProcessorArchitectures.Unknown,
-                };
-            }
-
-            /// <summary>
-            /// Read system info values
-            /// </summary>
-            public SystemInformationData()
-            {
-                ProcessorArchitectureType = ProcessorArchitectures.Unknown;
-                ProcessorArchitectureTypeNative = ProcessorArchitectures.Unknown;
-
-                if (IsWindows)
-                {
-                    var systemInfo = new SYSTEM_INFO();
-
-                    GetSystemInfo(ref systemInfo);
-                    ProcessorArchitectureType = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
-
-                    GetNativeSystemInfo(ref systemInfo);
-                    ProcessorArchitectureTypeNative = ConvertSystemArchitecture(systemInfo.wProcessorArchitecture);
-                }
-                else
-                {
-                    ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
-#if !NET35
-                    // Get the architecture from the runtime.
-                    processorArchitecture = RuntimeInformation.OSArchitecture switch
-                    {
-                        Architecture.Arm => ProcessorArchitectures.ARM,
-                        Architecture.Arm64 =>  ProcessorArchitectures.ARM64,
-                        Architecture.X64 => ProcessorArchitectures.X64,
-                        Architecture.X86 => ProcessorArchitectures.X86,
-                        _ => ProcessorArchitectures.Unknown,
-                    };
-#endif
-                    // Fall back to 'uname -m' to get the architecture.
-                    if (processorArchitecture == ProcessorArchitectures.Unknown)
-                    {
-                        try
-                        {
-                            // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
-                            using (
-                                var proc =
-                                    Process.Start(
-                                        new ProcessStartInfo("uname")
-                                        {
-                                            Arguments = "-m",
-                                            UseShellExecute = false,
-                                            RedirectStandardOutput = true,
-                                            CreateNoWindow = true
-                                        }))
-                            {
-                                string arch = null;
-                                if (proc != null)
-                                {
-                                    arch = proc.StandardOutput.ReadLine();
-                                    proc.WaitForExit();
-                                }
-
-                                if (!string.IsNullOrEmpty(arch))
-                                {
-                                    if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.X64;
-                                    }
-                                    else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.IA64;
-                                    }
-                                    else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.ARM;
-                                    }
-                                    else if (arch.StartsWith("aarch64", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.ARM64;
-                                    }
-                                    else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
-                                            && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
-                                    {
-                                        ProcessorArchitectureType = ProcessorArchitectures.X86;
-                                    }
-                                }
-                            }
-                        }
-                        catch
-                        {
-                            // Best effort: fall back to Unknown
-                        }
-                    }
-
-                    ProcessorArchitectureTypeNative = ProcessorArchitectureType = processorArchitecture;
-                }
-            }
-        }
-
-        public static int GetLogicalCoreCount()
-        {
-            int numberOfCpus = Environment.ProcessorCount;
-#if !MONO
-            // .NET Core on Windows returns a core count limited to the current NUMA node
-            //     https://github.com/dotnet/runtime/issues/29686
-            // so always double-check it.
-            if (IsWindows
-#if NETFRAMEWORK
-                // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
-                // So if we get a high core count on full framework, double-check it.
-                && (numberOfCpus >= 32)
-#endif
-            )
-            {
-                var result = GetLogicalCoreCountOnWindows();
-                if (result != -1)
-                {
-                    numberOfCpus = result;
-                }
-            }
-#endif
-
-            return numberOfCpus;
-        }
-
-        /// <summary>
-        /// Get the exact physical core count on Windows
-        /// Useful for getting the exact core count in 32 bits processes,
-        /// as Environment.ProcessorCount has a 32-core limit in that case. 
-        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
-        /// </summary>
-        private unsafe static int GetLogicalCoreCountOnWindows()
-        {
-            uint len = 0;
-            const int ERROR_INSUFFICIENT_BUFFER = 122;
-
-            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref len) &&
-                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)
-            {
-                // Allocate that much space
-                var buffer = new byte[len];
-                fixed (byte* bufferPtr = buffer)
-                {
-                    // Call GetLogicalProcessorInformationEx with the allocated buffer
-                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, (IntPtr)bufferPtr, ref len))
-                    {
-                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how
-                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.
-                        int processorCount = 0;
-                        byte* ptr = bufferPtr;
-                        byte* endPtr = bufferPtr + len;
-                        while (ptr < endPtr)
-                        {
-                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;
-                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
-                            {
-                                // Flags is 0 if the core has a single logical proc, LTP_PC_SMT if more than one
-                                // for now, assume "more than 1" == 2, as it has historically been for hyperthreading
-                                processorCount += (current->Processor.Flags == 0) ? 1 : 2;
-                            }
-                            ptr += current->Size;
-                        }
-                        return processorCount;
-                    }
-                }
-            }
-
-            return -1;
-        }
-
-        #endregion
-
-        #region Member data
-
-        internal static bool HasMaxPath => MaxPath == MAX_PATH;
-
-        /// <summary>
-        /// Gets the max path limit of the current OS.
-        /// </summary>
-        internal static int MaxPath
-        {
-            get
-            {
-                if (!IsMaxPathSet)
-                {
-                    SetMaxPath();
-                }
-                return _maxPath;
-            }
-        }
-
-        /// <summary>
-        /// Cached value for MaxPath.
-        /// </summary>
-        private static int _maxPath;
-
-        private static bool IsMaxPathSet { get; set; }
-
-        private static readonly object MaxPathLock = new object();
-
-        private static void SetMaxPath()
-        {
-            lock (MaxPathLock)
-            {
-                if (!IsMaxPathSet)
-                {
-                    bool isMaxPathRestricted = Traits.Instance.EscapeHatches.DisableLongPaths || IsMaxPathLegacyWindows();
-                    _maxPath = isMaxPathRestricted ? MAX_PATH : int.MaxValue;
-                    IsMaxPathSet = true;
-                }
-            }
-        }
-
-        internal static bool IsMaxPathLegacyWindows()
-        {
-            try
-            {
-                return IsWindows && !IsLongPathsEnabledRegistry();
-            }
-            catch
-            {
-                return true;
-            }
-        }
-
-        // CA1416 warns about code that can only run on Windows, but we verified we're running on Windows before this.
-        // This is the most reasonable way to resolve this part because other ways would require ifdef'ing on NET472.
-#pragma warning disable CA1416
-        private static bool IsLongPathsEnabledRegistry()
-        {
-            using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
-            {
-                object longPathsEnabledValue = fileSystemKey?.GetValue(WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME, 0);
-                return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
-            }
-        }
-#pragma warning restore CA1416
-
-        /// <summary>
-        /// Cached value for IsUnixLike (this method is called frequently during evaluation).
-        /// </summary>
-        private static readonly bool s_isUnixLike = IsLinux || IsOSX || IsBSD;
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under a Unix-like system (Mac, Linux, etc.)
-        /// </summary>
-        internal static bool IsUnixLike
-        {
-            get { return s_isUnixLike; }
-        }
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under Linux
-        /// </summary>
-        internal static bool IsLinux
-        {
-#if CLR2COMPATIBILITY
-            get { return false; }
-#else
-            get { return RuntimeInformation.IsOSPlatform(OSPlatform.Linux); }
-#endif
-        }
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under flavor of BSD (NetBSD, OpenBSD, FreeBSD)
-        /// </summary>
-        internal static bool IsBSD
-        {
-#if CLR2COMPATIBILITY
-            get { return false; }
-#else
-            get
-            {
-                return RuntimeInformation.IsOSPlatform(OSPlatform.Create("FREEBSD")) ||
-                       RuntimeInformation.IsOSPlatform(OSPlatform.Create("NETBSD")) ||
-                       RuntimeInformation.IsOSPlatform(OSPlatform.Create("OPENBSD"));
-            }
-#endif
-        }
-
-        private static readonly object IsMonoLock = new object();
-
-        private static bool? _isMono;
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under MONO
-        /// </summary>
-        internal static bool IsMono
-        {
-            get
-            {
-                if (_isMono != null) return _isMono.Value;
-
-                lock (IsMonoLock)
-                {
-                    if (_isMono == null)
-                    {
-                        // There could be potentially expensive TypeResolve events, so cache IsMono.
-                        // Also, VS does not host Mono runtimes, so turn IsMono off when msbuild is running under VS
-                        _isMono = !BuildEnvironmentHelper.Instance.RunningInVisualStudio &&
-                                  Type.GetType("Mono.Runtime") != null;
-                    }
-                }
-
-                return _isMono.Value;
-            }
-        }
-
-#if !CLR2COMPATIBILITY
-        private static bool? _isWindows;
-#endif
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under some version of Windows
-        /// </summary>
-        internal static bool IsWindows
-        {
-#if CLR2COMPATIBILITY
-            get { return true; }
-#else
-            get {
-                if (_isWindows == null)
-                {
-                    _isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
-                }
-                return _isWindows.Value;
-            }
-#endif
-        }
-
-#if !CLR2COMPATIBILITY
-        private static bool? _isOSX;
-#endif
-
-        /// <summary>
-        /// Gets a flag indicating if we are running under Mac OSX
-        /// </summary>
-        internal static bool IsOSX
-        {
-#if CLR2COMPATIBILITY
-            get { return false; }
-#else
-            get {
-                if (_isOSX == null)
-                {
-                    _isOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
-                }
-                return _isOSX.Value;
-            }
-#endif
-        }
-
-        /// <summary>
-        /// Gets a string for the current OS. This matches the OS env variable
-        /// for Windows (Windows_NT).
-        /// </summary>
-        internal static string OSName
-        {
-            get { return IsWindows ? "Windows_NT" : "Unix"; }
-        }
-
-        /// <summary>
-        /// OS name that can be used for the msbuildExtensionsPathSearchPaths element
-        /// for a toolset
-        /// </summary>
-        internal static string GetOSNameForExtensionsPath()
-        {
-            return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
-        }
-
-        internal static bool OSUsesCaseSensitivePaths
-        {
-            get { return IsLinux; }
-        }
-
-        /// <summary>
-        /// The base directory for all framework paths in Mono
-        /// </summary>
-        private static string s_frameworkBasePath;
-
-        /// <summary>
-        /// The directory of the current framework
-        /// </summary>
-        private static string s_frameworkCurrentPath;
-
-        /// <summary>
-        /// Gets the currently running framework path
-        /// </summary>
-        internal static string FrameworkCurrentPath
-        {
-            get
-            {
-                if (s_frameworkCurrentPath == null)
-                {
-                    var baseTypeLocation = AssemblyUtilities.GetAssemblyLocation(typeof(string).GetTypeInfo().Assembly);
-
-                    s_frameworkCurrentPath =
-                        Path.GetDirectoryName(baseTypeLocation)
-                        ?? string.Empty;
-                }
-
-                return s_frameworkCurrentPath;
-            }
-        }
-
-        /// <summary>
-        /// Gets the base directory of all Mono frameworks
-        /// </summary>
-        internal static string FrameworkBasePath
-        {
-            get
-            {
-                if (s_frameworkBasePath == null)
-                {
-                    var dir = FrameworkCurrentPath;
-                    if (dir != string.Empty)
-                    {
-                        dir = Path.GetDirectoryName(dir);
-                    }
-
-                    s_frameworkBasePath = dir ?? string.Empty;
-                }
-
-                return s_frameworkBasePath;
-            }
-        }
-
-        /// <summary>
-        /// System information, initialized when required.
-        /// </summary>
-        /// <remarks>
-        /// Initially implemented as <see cref="Lazy{SystemInformationData}"/>, but
-        /// that's .NET 4+, and this is used in MSBuildTaskHost.
-        /// </remarks>
-        private static SystemInformationData SystemInformation
-        {
-            get
-            {
-                if (!_systemInformationInitialized)
-                {
-                    lock (SystemInformationLock)
-                    {
-                        if (!_systemInformationInitialized)
-                        {
-                            _systemInformation = new SystemInformationData();
-                            _systemInformationInitialized = true;
-                        }
-                    }
-                }
-                return _systemInformation;
-            }
-        }
-
-        private static SystemInformationData _systemInformation;
-        private static bool _systemInformationInitialized;
-        private static readonly object SystemInformationLock = new object();
-
-        /// <summary>
-        /// Architecture getter
-        /// </summary>
-        internal static ProcessorArchitectures ProcessorArchitecture => SystemInformation.ProcessorArchitectureType;
-
-        /// <summary>
-        /// Native architecture getter
-        /// </summary>
-        internal static ProcessorArchitectures ProcessorArchitectureNative => SystemInformation.ProcessorArchitectureTypeNative;
-
-#endregion
-
-#region Wrapper methods
-
-        /// <summary>
-        /// Really truly non pumping wait.
-        /// Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
-        /// single SafeHandles.
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
-        public static extern Int32 WaitForMultipleObjects(uint handle, IntPtr[] handles, bool waitAll, uint milliseconds);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern void GetSystemInfo(ref SYSTEM_INFO lpSystemInfo);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
-        
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
-
-        /// <summary>
-        /// Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
-        /// if the directory does not exist, then false is returned and fileModifiedTimeUtc is set DateTime.MinValue.
-        /// </summary>
-        /// <param name="fullPath">Full path to the file in the filesystem</param>
-        /// <param name="fileModifiedTimeUtc">The UTC last write time for the directory</param>
-        internal static bool GetLastWriteDirectoryUtcTime(string fullPath, out DateTime fileModifiedTimeUtc)
-        {
-            // This code was copied from the reference manager, if there is a bug fix in that code, see if the same fix should also be made
-            // there
-            if (IsWindows)
-            {
-                fileModifiedTimeUtc = DateTime.MinValue;
-
-                WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = GetFileAttributesEx(fullPath, 0, ref data);
-                if (success)
-                {
-                    if ((data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
-                    {
-                        long dt = ((long)(data.ftLastWriteTimeHigh) << 32) | ((long)data.ftLastWriteTimeLow);
-                        fileModifiedTimeUtc = DateTime.FromFileTimeUtc(dt);
-                    }
-                    else
-                    {
-                        // Path does not point to a directory
-                        success = false;
-                    }
-                }
-
-                return success;
-            }
-
-            if (Directory.Exists(fullPath))
-            {
-                fileModifiedTimeUtc = Directory.GetLastWriteTimeUtc(fullPath);
-                return true;
-            }
-            else
-            {
-                fileModifiedTimeUtc = DateTime.MinValue;
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Takes the path and returns the short path
-        /// </summary>
-        internal static string GetShortFilePath(string path)
-        {
-            if (!IsWindows)
-            {
-                return path;
-            }
-
-            if (path != null)
-            {
-                int length = GetShortPathName(path, null, 0);
-                int errorCode = Marshal.GetLastWin32Error();
-
-                if (length > 0)
-                {
-                    StringBuilder fullPathBuffer = new StringBuilder(length);
-                    length = GetShortPathName(path, fullPathBuffer, length);
-                    errorCode = Marshal.GetLastWin32Error();
-
-                    if (length > 0)
-                    {
-                        string fullPath = fullPathBuffer.ToString();
-                        path = fullPath;
-                    }
-                }
-
-                if (length == 0 && errorCode != 0)
-                {
-                    ThrowExceptionForErrorCode(errorCode);
-                }
-            }
-
-            return path;
-        }
-
-        /// <summary>
-        /// Takes the path and returns a full path
-        /// </summary>
-        /// <param name="path"></param>
-        /// <returns></returns>
-        internal static string GetLongFilePath(string path)
-        {
-            if (IsUnixLike)
-            {
-                return path;
-            }
-
-            if (path != null)
-            {
-                int length = GetLongPathName(path, null, 0);
-                int errorCode = Marshal.GetLastWin32Error();
-
-                if (length > 0)
-                {
-                    StringBuilder fullPathBuffer = new StringBuilder(length);
-                    length = GetLongPathName(path, fullPathBuffer, length);
-                    errorCode = Marshal.GetLastWin32Error();
-
-                    if (length > 0)
-                    {
-                        string fullPath = fullPathBuffer.ToString();
-                        path = fullPath;
-                    }
-                }
-
-                if (length == 0 && errorCode != 0)
-                {
-                    ThrowExceptionForErrorCode(errorCode);
-                }
-            }
-
-            return path;
-        }
-
-        /// <summary>
-        /// Retrieves the current global memory status.
-        /// </summary>
-        internal static MemoryStatus GetMemoryStatus()
-        {
-            if (NativeMethodsShared.IsWindows)
-            {
-                MemoryStatus status = new MemoryStatus();
-                bool returnValue = NativeMethodsShared.GlobalMemoryStatusEx(status);
-                if (!returnValue)
-                {
-                    return null;
-                }
-
-                return status;
-            }
-
-            return null;
-        }
-
-        /// <summary>
-        /// Get the last write time of the fullpath to the file.
-        /// </summary>
-        /// <param name="fullPath">Full path to the file in the filesystem</param>
-        /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
-        /// <remarks>
-        /// This method should be accurate for regular files and symlinks, but can report incorrect data
-        /// if the file's content was modified by writing to it through a different link, unless
-        /// MSBUILDALWAYSCHECKCONTENTTIMESTAMP=1.
-        /// </remarks>
-        internal static DateTime GetLastWriteFileUtcTime(string fullPath)
-        {
-#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-            if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                return LastWriteFileUtcTime(fullPath);
-            }
-
-            bool isNonModifiable = FileClassifier.Shared.IsNonModifiable(fullPath);
-            if (isNonModifiable)
-            {
-                if (ImmutableFilesTimestampCache.Shared.TryGetValue(fullPath, out DateTime modifiedAt))
-                {
-                    return modifiedAt;
-                }
-            }
-
-            DateTime modifiedTime = LastWriteFileUtcTime(fullPath);
-
-            if (isNonModifiable && modifiedTime != DateTime.MinValue)
-            {
-                ImmutableFilesTimestampCache.Shared.TryAdd(fullPath, modifiedTime);
-            }
-
-            return modifiedTime;
-#else
-            return LastWriteFileUtcTime(fullPath);
-#endif
-
-            DateTime LastWriteFileUtcTime(string path)
-            {
-                DateTime fileModifiedTime = DateTime.MinValue;
-
-                if (IsWindows)
-                {
-                    if (Traits.Instance.EscapeHatches.AlwaysUseContentTimestamp)
-                    {
-                        return GetContentLastWriteFileUtcTime(path);
-                    }
-
-                    WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                    bool success = NativeMethodsShared.GetFileAttributesEx(path, 0, ref data);
-
-                    if (success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0)
-                    {
-                        long dt = ((long) (data.ftLastWriteTimeHigh) << 32) | ((long) data.ftLastWriteTimeLow);
-                        fileModifiedTime = DateTime.FromFileTimeUtc(dt);
-
-                        // If file is a symlink _and_ we're not instructed to do the wrong thing, get a more accurate timestamp. 
-                        if ((data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT && !Traits.Instance.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime)
-                        {
-                            fileModifiedTime = GetContentLastWriteFileUtcTime(path);
-                        }
-                    }
-
-                    return fileModifiedTime;
-                }
-                else
-                {
-                    return File.Exists(path)
-                        ? File.GetLastWriteTimeUtc(path)
-                        : DateTime.MinValue;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Get the last write time of the content pointed to by a file path.
-        /// </summary>
-        /// <param name="fullPath">Full path to the file in the filesystem</param>
-        /// <returns>The last write time of the file, or DateTime.MinValue if the file does not exist.</returns>
-        /// <remarks>
-        /// This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
-        /// See https://github.com/Microsoft/msbuild/issues/2052.
-        /// </remarks>
-        private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
-        {
-            DateTime fileModifiedTime = DateTime.MinValue;
-
-            using (SafeFileHandle handle =
-                CreateFile(fullPath,
-                    GENERIC_READ,
-                    FILE_SHARE_READ,
-                    IntPtr.Zero,
-                    OPEN_EXISTING,
-                    FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
-                    IntPtr.Zero))
-            {
-                if (!handle.IsInvalid)
-                {
-                    FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;
-                    if (GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime))
-                    {
-                        long fileTime = ((long)(uint)ftLastWriteTime.dwHighDateTime) << 32 |
-                                        (long)(uint)ftLastWriteTime.dwLowDateTime;
-                        fileModifiedTime =
-                            DateTime.FromFileTimeUtc(fileTime);
-                    }
-                }
-            }
-
-            return fileModifiedTime;
-        }
-
-        /// <summary>
-        /// Did the HRESULT succeed
-        /// </summary>
-        public static bool HResultSucceeded(int hr)
-        {
-            return hr >= 0;
-        }
-
-        /// <summary>
-        /// Did the HRESULT Fail
-        /// </summary>
-        public static bool HResultFailed(int hr)
-        {
-            return hr < 0;
-        }
-
-        /// <summary>
-        /// Given an error code, converts it to an HRESULT and throws the appropriate exception.
-        /// </summary>
-        /// <param name="errorCode"></param>
-        public static void ThrowExceptionForErrorCode(int errorCode)
-        {
-            // See ndp\clr\src\bcl\system\io\__error.cs for this code as it appears in the CLR.
-
-            // Something really bad went wrong with the call
-            // translate the error into an exception
-
-            // Convert the errorcode into an HRESULT (See MakeHRFromErrorCode in Win32Native.cs in
-            // ndp\clr\src\bcl\microsoft\win32)
-            errorCode = unchecked(((int)0x80070000) | errorCode);
-
-            // Throw an exception as best we can
-            Marshal.ThrowExceptionForHR(errorCode);
-        }
-
-        /// <summary>
-        /// Kills the specified process by id and all of its children recursively.
-        /// </summary>
-        internal static void KillTree(int processIdToKill)
-        {
-            // Note that GetProcessById does *NOT* internally hold on to the process handle.
-            // Only when you create the process using the Process object
-            // does the Process object retain the original handle.
-
-            Process thisProcess;
-            try
-            {
-                thisProcess = Process.GetProcessById(processIdToKill);
-            }
-            catch (ArgumentException)
-            {
-                // The process has already died for some reason.  So shrug and assume that any child processes
-                // have all also either died or are in the process of doing so.
-                return;
-            }
-
-            try
-            {
-                DateTime myStartTime = thisProcess.StartTime;
-
-                // Grab the process handle.  We want to keep this open for the duration of the function so that
-                // it cannot be reused while we are running.
-                SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill);
-                if (hProcess.IsInvalid)
-                {
-                    return;
-                }
-
-                try
-                {
-                    try
-                    {
-                        // Kill this process, so that no further children can be created.
-                        thisProcess.Kill();
-                    }
-                    catch (Win32Exception e)
-                    {
-                        // Access denied is potentially expected -- it happens when the process that
-                        // we're attempting to kill is already dead.  So just ignore in that case.
-                        if (e.NativeErrorCode != ERROR_ACCESS_DENIED)
-                        {
-                            throw;
-                        }
-                    }
-
-                    // Now enumerate our children.  Children of this process are any process which has this process id as its parent
-                    // and which also started after this process did.
-                    List<KeyValuePair<int, SafeProcessHandle>> children = GetChildProcessIds(processIdToKill, myStartTime);
-
-                    try
-                    {
-                        foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
-                        {
-                            KillTree(childProcessInfo.Key);
-                        }
-                    }
-                    finally
-                    {
-                        foreach (KeyValuePair<int, SafeProcessHandle> childProcessInfo in children)
-                        {
-                            childProcessInfo.Value.Dispose();
-                        }
-                    }
-                }
-                finally
-                {
-                    // Release the handle.  After this point no more children of this process exist and this process has also exited.
-                    hProcess.Dispose();
-                }
-            }
-            finally
-            {
-                thisProcess.Dispose();
-            }
-        }
-
-        /// <summary>
-        /// Returns the parent process id for the specified process.
-        /// Returns zero if it cannot be gotten for some reason.
-        /// </summary>
-        internal static int GetParentProcessId(int processId)
-        {
-            int ParentID = 0;
-#if !CLR2COMPATIBILITY
-            if (IsUnixLike)
-            {
-                string line = null;
-
-                try
-                {
-                    // /proc/<processID>/stat returns a bunch of space separated fields. Get that string
-                    using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
-                    {
-                        line = r.ReadLine();
-                    }
-                }
-                catch // Ignore errors since the process may have terminated
-                {
-                }
-
-                if (!string.IsNullOrWhiteSpace(line))
-                {
-                    // One of the fields is the process name. It may contain any characters, but since it's
-                    // in parenthesis, we can finds its end by looking for the last parenthesis. After that,
-                    // there comes a space, then the second fields separated by a space is the parent id.
-                    string[] statFields = line.Substring(line.LastIndexOf(')')).Split(MSBuildConstants.SpaceChar, 4);
-                    if (statFields.Length >= 3)
-                    {
-                        ParentID = Int32.Parse(statFields[2]);
-                    }
-                }
-            }
-            else
-#endif
-            {
-                SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
-
-                if (!hProcess.IsInvalid)
-                {
-                    try
-                    {
-                        // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
-                        // For now just return zero and worst case we will not kill some children.
-                        PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
-                        int pSize = 0;
-
-                        if (0 == NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, pbi.Size, ref pSize))
-                        {
-                            ParentID = (int)pbi.InheritedFromUniqueProcessId;
-                        }
-                    }
-                    finally
-                    {
-                        hProcess.Dispose();
-                    }
-                }
-            }
-
-            return ParentID;
-        }
-
-        /// <summary>
-        /// Returns an array of all the immediate child processes by id.
-        /// NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
-        /// </summary>
-        internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime)
-        {
-            List<KeyValuePair<int, SafeProcessHandle>> myChildren = new List<KeyValuePair<int, SafeProcessHandle>>();
-
-            foreach (Process possibleChildProcess in Process.GetProcesses())
-            {
-                using (possibleChildProcess)
-                {
-                    // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.
-                    // This way, any handle we pass back is guaranteed to be one of our actual children.
-                    SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);
-                    if (childHandle.IsInvalid)
-                    {
-                        continue;
-                    }
-
-                    bool keepHandle = false;
-                    try
-                    {
-                        if (possibleChildProcess.StartTime > parentStartTime)
-                        {
-                            int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
-                            if (childParentProcessId != 0)
-                            {
-                                if (parentProcessId == childParentProcessId)
-                                {
-                                    // Add this one
-                                    myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
-                                    keepHandle = true;
-                                }
-                            }
-                        }
-                    }
-                    finally
-                    {
-                        if (!keepHandle)
-                        {
-                            childHandle.Dispose();
-                        }
-                    }
-                }
-            }
-
-            return myChildren;
-        }
-
-        /// <summary>
-        /// Internal, optimized GetCurrentDirectory implementation that simply delegates to the native method
-        /// </summary>
-        /// <returns></returns>
-        internal unsafe static string GetCurrentDirectory()
-        {
-#if FEATURE_LEGACY_GETCURRENTDIRECTORY
-            if (IsWindows)
-            {
-                int bufferSize = GetCurrentDirectoryWin32(0, null);
-                char* buffer = stackalloc char[bufferSize];
-                int pathLength = GetCurrentDirectoryWin32(bufferSize, buffer);
-                return new string(buffer, startIndex: 0, length: pathLength);
-            }
-#endif
-            return Directory.GetCurrentDirectory();
-        }
-
-        private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBuffer)
-        {
-            int pathLength = GetCurrentDirectory(nBufferLength, lpBuffer);
-            VerifyThrowWin32Result(pathLength);
-            return pathLength;
-        }
-
-        internal unsafe static string GetFullPath(string path)
-        {
-            int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
-            char* buffer = stackalloc char[bufferSize];
-            int fullPathLength = GetFullPathWin32(path, bufferSize, buffer, IntPtr.Zero);
-            // Avoid creating new strings unnecessarily
-            return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
-        }
-
-        private unsafe static int GetFullPathWin32(string target, int bufferLength, char* buffer, IntPtr mustBeZero)
-        {
-            int pathLength = GetFullPathName(target, bufferLength, buffer, mustBeZero);
-            VerifyThrowWin32Result(pathLength);
-            return pathLength;
-        }
-
-        /// <summary>
-        /// Compare an unsafe char buffer with a <see cref="System.String"/> to see if their contents are identical.
-        /// </summary>
-        /// <param name="buffer">The beginning of the char buffer.</param>
-        /// <param name="len">The length of the buffer.</param>
-        /// <param name="s">The string.</param>
-        /// <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
-        private unsafe static bool AreStringsEqual(char* buffer, int len, string s)
-        {
-            if (len != s.Length)
-            {
-                return false;
-            }
-
-            foreach (char ch in s)
-            {
-                if (ch != *buffer++)
-                {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-
-        internal static void VerifyThrowWin32Result(int result)
-        {
-            bool isError = result == 0;
-            if (isError)
-            {
-                int code = Marshal.GetLastWin32Error();
-                ThrowExceptionForErrorCode(code);
-            }
-        }
-
-#endregion
-
-#region PInvoke
-
-        /// <summary>
-        /// Gets the current OEM code page which is used by console apps
-        /// (as opposed to the Windows/ANSI code page)
-        /// Basically for each ANSI code page (set in Regional settings) there's a corresponding OEM code page
-        /// that needs to be used for instance when writing to batch files
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(kernel32Dll)]
-        internal static extern int GetOEMCP();
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
-        private static extern uint SearchPath
-        (
-            string path,
-            string fileName,
-            string extension,
-            int numBufferChars,
-            [Out] StringBuilder buffer,
-            int[] filePart
-        );
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", PreserveSig = true, SetLastError = true)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool FreeLibrary([In] IntPtr module);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true, CharSet = CharSet.Ansi, SetLastError = true)]
-        internal static extern IntPtr GetProcAddress(IntPtr module, string procName);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, PreserveSig = true, SetLastError = true)]
-        internal static extern IntPtr LoadLibrary(string fileName);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(mscoreeDLL, SetLastError = true, CharSet = CharSet.Unicode)]
-        internal static extern uint GetRequestedRuntimeInfo(String pExe,
-                                                String pwszVersion,
-                                                String pConfigurationFile,
-                                                uint startupFlags,
-                                                uint runtimeInfoFlags,
-                                                [Out] StringBuilder pDirectory,
-                                                int dwDirectory,
-                                                out uint dwDirectoryLength,
-                                                [Out] StringBuilder pVersion,
-                                                int cchBuffer,
-                                                out uint dwlength);
-
-        /// <summary>
-        /// Gets the fully qualified filename of the currently executing .exe
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
-        internal static extern int GetModuleFileName(
-#if FEATURE_HANDLEREF
-            HandleRef hModule,
-#else
-            IntPtr hModule,
-#endif
-            [Out] StringBuilder buffer, int length);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll")]
-        internal static extern IntPtr GetStdHandle(int nStdHandle);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll")]
-        internal static extern uint GetFileType(IntPtr hFile);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        internal unsafe static extern int GetCurrentDirectory(int nBufferLength, char* lpBuffer);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = "SetCurrentDirectory")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool SetCurrentDirectoryWindows(string path);
-
-        internal static bool SetCurrentDirectory(string path)
-        {
-            if (IsWindows)
-            {
-                return SetCurrentDirectoryWindows(path);
-            }
-
-            // Make sure this does not throw
-            try
-            {
-                Directory.SetCurrentDirectory(path);
-            }
-            catch
-            {
-            }
-            return true;
-        }
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        internal static unsafe extern int GetFullPathName(string target, int bufferLength, char* buffer, IntPtr mustBeZero);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("KERNEL32.DLL")]
-        private static extern SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("NTDLL.DLL")]
-        private static extern int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, ref PROCESS_BASIC_INFORMATION pbi, uint cb, ref int pSize);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
-        private static extern bool GlobalMemoryStatusEx([In, Out] MemoryStatus lpBuffer);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
-        internal static extern int GetShortPathName(string path, [Out] StringBuilder fullpath, [In] int length);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
-        internal static extern int GetLongPathName([In] string path, [Out] StringBuilder fullpath, [In] int length);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
-        internal static extern bool CreatePipe(out SafeFileHandle hReadPipe, out SafeFileHandle hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, SetLastError = true)]
-        internal static extern bool ReadFile(SafeFileHandle hFile, byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);
-
-        /// <summary>
-        /// CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
-        /// VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
-        /// build thread which the main thread (blocked on BuildSubmission.Execute) must service.
-        /// </summary>
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("ole32.dll")]
-        public static extern int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] pHandles, out int pdwIndex);
-
-        internal const uint GENERIC_READ = 0x80000000;
-        internal const uint FILE_SHARE_READ = 0x1;
-        internal const uint FILE_ATTRIBUTE_NORMAL = 0x80;
-        internal const uint FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;
-        internal const uint OPEN_EXISTING = 3;
-
-        [DllImport("kernel32.dll", CharSet = AutoOrUnicode, CallingConvention = CallingConvention.StdCall,
-            SetLastError = true)]
-        internal static extern SafeFileHandle CreateFile(
-            string lpFileName,
-            uint dwDesiredAccess,
-            uint dwShareMode,
-            IntPtr lpSecurityAttributes,
-            uint dwCreationDisposition,
-            uint dwFlagsAndAttributes,
-            IntPtr hTemplateFile
-            );
-
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern bool GetFileTime(
-            SafeFileHandle hFile,
-            out FILETIME lpCreationTime,
-            out FILETIME lpLastAccessTime,
-            out FILETIME lpLastWriteTime
-            );
-
-        [DllImport("kernel32.dll", SetLastError = true)]
-        [return: MarshalAs(UnmanagedType.Bool)]
-        internal static extern bool CloseHandle(IntPtr hObject);
-
-        [DllImport("kernel32.dll", SetLastError = true)]
-        internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
-
-#endregion
-
-#region Extensions
-
-        /// <summary>
-        /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-        /// servicing COM calls from other threads.
-        /// </summary>
-        [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Scope = "member", Target = "Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.Int32)", Justification = "This is necessary and it has been used for a long time. No need to change it now.")]
-        internal static bool MsgWaitOne(this WaitHandle handle)
-        {
-            return handle.MsgWaitOne(Timeout.Infinite);
-        }
-
-        /// <summary>
-        /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-        /// servicing COM calls from other threads.
-        /// </summary>
-        internal static bool MsgWaitOne(this WaitHandle handle, TimeSpan timeout)
-        {
-            return MsgWaitOne(handle, (int)timeout.TotalMilliseconds);
-        }
-
-        /// <summary>
-        /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-        /// servicing COM calls from other threads.
-        /// </summary>
-        [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Justification = "Necessary to avoid pumping")]
-        internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
-        {
-            // CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
-            // VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
-            // build thread which the main thread (blocked on BuildSubmission.Execute) must service.
-            int waitIndex;
-#if FEATURE_HANDLE_SAFEWAITHANDLE
-            IntPtr handlePtr = handle.SafeWaitHandle.DangerousGetHandle();
-#else
-            IntPtr handlePtr = handle.GetSafeWaitHandle().DangerousGetHandle();
-#endif
-            int returnValue = CoWaitForMultipleHandles(COWAIT_FLAGS.COWAIT_NONE, timeout, 1, new IntPtr[] { handlePtr }, out waitIndex);
-            ErrorUtilities.VerifyThrow(returnValue == 0 || ((uint)returnValue == RPC_S_CALLPENDING && timeout != Timeout.Infinite), "Received {0} from CoWaitForMultipleHandles, but expected 0 (S_OK)", returnValue);
-            return returnValue == 0;
-        }
-
-#endregion
-
-#region helper methods
-
-        internal static bool DirectoryExists(string fullPath)
-        {
-            return NativeMethodsShared.IsWindows
-                ? DirectoryExistsWindows(fullPath)
-                : Directory.Exists(fullPath);
-        }
-
-        internal static bool DirectoryExistsWindows(string fullPath)
-        {
-            NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
-            return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) != 0;
-        }
-
-        internal static bool FileExists(string fullPath)
-        {
-            return NativeMethodsShared.IsWindows
-                ? FileExistsWindows(fullPath)
-                : File.Exists(fullPath);
-        }
-
-        internal static bool FileExistsWindows(string fullPath)
-        {
-            NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
-            return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0;
-        }
-
-        internal static bool FileOrDirectoryExists(string path)
-        {
-            return IsWindows
-                ? FileOrDirectoryExistsWindows(path)
-                : File.Exists(path) || Directory.Exists(path);
-        }
-
-        internal static bool FileOrDirectoryExistsWindows(string path)
-        {
-            WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-            return GetFileAttributesEx(path, 0, ref data);
-        }
-
-#endregion
-    }
-}
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 3d468e23e95..4562c4309d7 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -183,11 +183,8 @@ public void SendData(INodePacket packet)
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal void InternalConstruct(string pipeName)
+        internal void InternalConstruct()
         {
-            ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
-
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
@@ -195,6 +192,8 @@ internal void InternalConstruct(string pipeName)
             _packetStream = new MemoryStream();
             _binaryWriter = new BinaryWriter(_packetStream);
 
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath();
+
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
             {
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index 540b26f71d1..b02ed0ef6c3 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -57,7 +57,7 @@ internal static void ThrowInvalidProject<T1>
             T1 arg0
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0);
         }
 
         /// <summary>
@@ -93,7 +93,7 @@ internal static void ThrowInvalidProject<T1, T2>
             T2 arg1
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1);
         }
 
         /// <summary>
@@ -113,7 +113,7 @@ internal static void ThrowInvalidProject<T1, T2, T3>
             T3 arg2
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1, arg2);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2);
         }
 
         /// <summary>
@@ -135,7 +135,7 @@ internal static void ThrowInvalidProject<T1, T2, T3, T4>
             T4 arg3
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
         }
 
         /// <summary>
@@ -396,16 +396,9 @@ params object[] args
 
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 #endif
-            string errorSubCategory = null;
+            string errorSubCategory = errorSubCategoryResourceName is null ? null : AssemblyResources.GetString(errorSubCategoryResourceName);
 
-            if (errorSubCategoryResourceName != null)
-            {
-                errorSubCategory = AssemblyResources.GetString(errorSubCategoryResourceName);
-            }
-
-            string errorCode;
-            string helpKeyword;
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errorCode, out helpKeyword, resourceName, args);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, resourceName, args);
 
             throw new InvalidProjectFileException(elementLocation.File, elementLocation.Line, elementLocation.Column, 0 /* Unknown end line */, 0 /* Unknown end column */, message, errorSubCategory, errorCode, helpKeyword);
         }
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index d672e250e5f..bcc433204d0 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -29,7 +29,7 @@ internal static void ThrowInvalidProjectFile
             params object[] args
         )
         {
-            VerifyThrowInvalidProjectFile(false, null, projectFile, resourceName, args);
+            ThrowInvalidProjectFile(null, projectFile, resourceName, args);
         }
 
         /// <summary>
@@ -157,16 +157,8 @@ params object[] args
 #endif
             if (!condition)
             {
-                string errorSubCategory = null;
-
-                if (errorSubCategoryResourceName != null)
-                {
-                    errorSubCategory = AssemblyResources.GetString(errorSubCategoryResourceName);
-                }
-
-                string errorCode;
-                string helpKeyword;
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errorCode, out helpKeyword, resourceName, args);
+                string errorSubCategory = errorSubCategoryResourceName is null ? null : AssemblyResources.GetString(errorSubCategoryResourceName);
+                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, resourceName, args);
 
                 throw new InvalidProjectFileException(projectFile.File, projectFile.Line, projectFile.Column, projectFile.EndLine, projectFile.EndColumn, message, errorSubCategory, errorCode, helpKeyword, innerException);
             }
diff --git a/src/Shared/Shared Code.doc b/src/Shared/Shared Code.doc
deleted file mode 100644
index 3bb7c7745d2..00000000000
Binary files a/src/Shared/Shared Code.doc and /dev/null differ
diff --git a/src/Shared/SharedCode.md b/src/Shared/SharedCode.md
new file mode 100644
index 00000000000..955f9af23f8
--- /dev/null
+++ b/src/Shared/SharedCode.md
@@ -0,0 +1,83 @@
+# Shared Code
+
+## **Namespace**
+All shared code _must_ live in `Microsoft.Build.Shared` namespace.
+___
+
+## **Internal Access Only**
+Shared code gets compiled into every assembly as it is referenced by. However this does _not_ mean that the shared types can migrate across the assemblies they are in.
+
+Even if two types in different assemblies have the same name and are in the same namespace, the CLR does _not_ recognize the types to be the same, because their assembly identities are different.
+
+As a result all shared code _must_ have **internal** access only. There should be _no_ public types in shared code.
+___
+
+## **Resources**
+Shared code needs access to assembly resources e.g. for loading error messages for exceptions. Each assembly that shares code, _must_ define a class called `AssemblyResources` in the shared namespace, with an `internal static readonly` member of type `ResourceManager` called `resources`. Each sharing assembly is required to do this because only it knows what the manifest resource name (a.k.a. logical name) of its resources is. Shared code can then statically reference the assembly’s resources. If the `AssemblyResources` class is not defined, it is a compile-time error.
+
+The `AssemblyResources` class at a minimum must look like this:
+
+```cs
+using System.Resources;
+using System.Reflection;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class AssemblyResources
+    {
+        internal static readonly ResourceManager resources =
+            new ResourceManager(
+                "<manifest resource name>",
+                Assembly.GetExecutingAssembly());
+    }
+}
+```
+
+NOTE: the class is explicitly marked `static`, because it only contains static members and methods -- making the class static prevents it from being instantiated, and allows the compiler to flag the (accidental) addition of instance members.
+___
+
+## **Shared Resources**
+Shared code sometimes needs to define its own resources. If this were not allowed, then each sharing assembly would have to redefine the same set of resources on behalf of the shared code. As with code, maintaining multiple copies of the same resources is not desirable.
+
+Shared resources must be placed in the file `Strings.shared.resx` in the shared code directory. All resource names must be prefixed with “`Shared.`” to distinguish the shared resources from an assembly’s primary resources. Each sharing assembly must add an `internal static readonly` member of type `ResourceManager`, called `sharedResources`, to the `AssemblyResources` class. This is necessary because only the sharing assembly can assign the correct manifest resource name to the shared resources. Shared code can then statically reference the shared resources. The absence of either the `AssemblyResources` class, or the `sharedResources` member is a compile-time error.
+
+For assemblies that share resources, the `AssemblyResources` class at a minimum must look like this:
+
+```cs
+using System.Resources;
+using System.Reflection;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class AssemblyResources
+    {
+        internal static readonly ResourceManager resources =
+            new ResourceManager(
+                "<manifest resource name>",
+                Assembly.GetExecutingAssembly());
+
+        internal static readonly ResourceManager sharedResources =
+            new ResourceManager(
+                "<manifest resource name of shared resources>",
+                Assembly.GetExecutingAssembly());
+    }
+}
+```
+
+To simplify the retrieval of resources, the `AssemblyResources` class can optionally define a method called `GetString()` that searches both the assembly’s primary resources as well as its shared resources for a given string. For example:
+
+```cs
+internal static string GetString(string name)
+{
+    string resource = resources.GetString(name, CultureInfo.CurrentUICulture);
+
+    if (resource == null)
+    {
+        resource = sharedResources.GetString(name, CultureInfo.CurrentUICulture);
+    }
+
+    return resource;
+}
+```
+
+NOTE: if the above method is added to the `AssemblyResources` class, it is advisable to make both `resources` and `sharedResources` private (instead of `internal`) to unify access to assembly resources.
\ No newline at end of file
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 4ee21110651..7de1b7c8ab1 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1435,7 +1435,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
                         }
 
                     default:
-                        ErrorUtilities.VerifyThrow(false, "Impossible canonical part.");
+                        ErrorUtilities.ThrowInternalError("Impossible canonical part.");
                         break;
                 }
             }
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 9902fd49a06..f3f240f8537 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -6,6 +6,7 @@
 using System.Configuration;
 using System.IO;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
diff --git a/src/Shared/UnitTests/ErrorUtilities_Tests.cs b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
index c642db01e3a..6b3556f4a51 100644
--- a/src/Shared/UnitTests/ErrorUtilities_Tests.cs
+++ b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index d8cf2eeed4c..f544b884b99 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using System;
@@ -12,6 +13,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -1244,13 +1246,20 @@ public void IllegalPaths()
         [Fact]
         [PlatformSpecific(TestPlatforms.Windows)] // Nothing's too long for Unix
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        public void IllegalTooLongPath()
+        public void IllegalTooLongPathOptOutWave17_0()
         {
-            string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-            string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
+            using (var env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_0.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            Assert.Equal(longString, result[0]); // Does not throw
+                string longString = new string('X', 500) + "*"; // need a wildcard to do anything
+                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
 
+                Assert.Equal(longString, result[0]); // Does not throw
+                ChangeWaves.ResetStateForTests();
+            }
             // Not checking that GetFileSpecMatchInfo returns the illegal-path flag,
             // not certain that won't break something; this fix is merely to avoid a crash.
         }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 9261b45785c..e647fd709c0 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -2019,6 +2019,65 @@ public void Dispose()
             }
         }
 
+        internal sealed class LoggingDirectoryCacheFactory : IDirectoryCacheFactory
+        {
+            public List<LoggingDirectoryCache> DirectoryCaches { get; } = new();
+
+            public IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
+            {
+                var directoryCache = new LoggingDirectoryCache(evaluationId);
+                DirectoryCaches.Add(directoryCache);
+                return directoryCache;
+            }
+        }
+
+        internal sealed class LoggingDirectoryCache : IDirectoryCache
+        {
+            internal int EvaluationId { get; }
+
+            public ConcurrentDictionary<string, int> ExistenceChecks { get; } = new();
+            public ConcurrentDictionary<string, int> Enumerations { get; } = new();
+
+            public LoggingDirectoryCache(int evaluationId)
+            {
+                EvaluationId = evaluationId;
+            }
+
+            public bool DirectoryExists(string path)
+            {
+                IncrementExistenceChecks(path);
+                return Directory.Exists(path);
+            }
+
+            public bool FileExists(string path)
+            {
+                IncrementExistenceChecks(path);
+                return File.Exists(path);
+            }
+
+            public IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform)
+            {
+                IncrementEnumerations(path);
+                return Enumerable.Empty<TResult>();
+            }
+
+            public IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform)
+            {
+                IncrementEnumerations(path);
+                return Enumerable.Empty<TResult>();
+            }
+
+            private void IncrementExistenceChecks(string path)
+            {
+                ExistenceChecks.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+
+            private void IncrementEnumerations(string path)
+            {
+                Enumerations.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+        }
+
         internal class LoggingFileSystem : MSBuildFileSystemBase
         {
             private int _fileSystemCalls;
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 9922585a325..d3e93024a61 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -17,7 +17,6 @@
 
 using TempPaths = System.Collections.Generic.Dictionary<string, string>;
 using CommonWriterType = System.Action<string, string, System.Collections.Generic.IEnumerable<string>>;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index f3c58b19237..70cf960d823 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
+
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -47,35 +49,82 @@ public void TestIsNonBatchingTargetAttribute()
         public void TestRuntimeValuesMatch()
         {
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime));
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.net));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any));
+#if NET5_0_OR_GREATER
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.net));
+#else
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4));
+#endif
 
+            // Never true
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2));
+
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.net));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.net));
         }
 
-        [Fact]
-        public void TestMergeRuntimeValues()
+        [Theory]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr2)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        public void TestMergeRuntimeValues(string left, string right, bool success, string expected)
         {
-            string mergedRuntime;
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            XMakeAttributes.TryMergeRuntimeValues(left, right, out string mergedRuntime)
+                .ShouldBe(success);
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(expected);
+        }
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr2, mergedRuntime);
+        [Fact]
+        public void TestMergeRuntimeValuesAnyAcceptsCurrent()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any,
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                out string mergedRuntime)
+                .ShouldBeTrue();
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(XMakeAttributes.GetCurrentMSBuildRuntime());
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
+            "Tests whether 'current' merges with 'clr4' which is true only on Framework")]
+        public void TestMergeRuntimeValuesCurrentToClr4()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.clr4);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework,
+            "Tests whether 'current' merges with 'net' which is true only on core")]
+        public void TestMergeRuntimeValuesCurrentToCore()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.net);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
         }
 
         [Fact]
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 461bc2ef740..d290eee6246 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Runtime.CompilerServices;
 
 namespace Microsoft.Build.Shared
 {
@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues
             internal const string clr2 = "CLR2";
             internal const string clr4 = "CLR4";
             internal const string currentRuntime = "CurrentRuntime";
+            internal const string net = "NET";
             internal const string any = "*";
         }
 
@@ -99,7 +101,7 @@ internal struct MSBuildArchitectureValues
 
         private static readonly HashSet<string> KnownBatchingTargetAttributes = new HashSet<string> { name, condition, dependsOnTargets, beforeTargets, afterTargets };
 
-        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.any };
+        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.net, MSBuildRuntimeValues.any };
 
         private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
 
@@ -179,10 +181,10 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
                 return true;
             }
 
-            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase)) ||
-                (runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
+            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase)) ||
+                (runtimeA.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
             {
-                // CLR4 is the current runtime, so this is also a match. 
+                // Matches the current runtime, so match.
                 return true;
             }
 
@@ -216,13 +218,15 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 runtimeB = MSBuildRuntimeValues.any;
             }
 
+            string actualCurrentRuntime = GetCurrentMSBuildRuntime();
+
             // if they're equal, then there's no problem -- just return the equivalent runtime.  
             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))
             {
                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                     runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
                 {
-                    mergedRuntime = MSBuildRuntimeValues.clr4;
+                    mergedRuntime = actualCurrentRuntime;
                 }
                 else
                 {
@@ -232,21 +236,22 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.  
+            // if both A and B are one of actual-current-runtime, don't care or current,
+            // then the end result will be current-runtime no matter what.  
             if (
                 (
-                 runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeA.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 ) &&
                 (
-                 runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeB.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 )
                )
             {
-                mergedRuntime = MSBuildRuntimeValues.clr4;
+                mergedRuntime = actualCurrentRuntime;
                 return true;
             }
 
@@ -320,8 +325,8 @@ internal static string GetExplicitMSBuildRuntime(string runtime)
                 MSBuildRuntimeValues.any.Equals(runtime, StringComparison.OrdinalIgnoreCase) ||
                 MSBuildRuntimeValues.currentRuntime.Equals(runtime, StringComparison.OrdinalIgnoreCase))
             {
-                // Default to CLR4.
-                return MSBuildRuntimeValues.clr4;
+                // Default to current.
+                return GetCurrentMSBuildRuntime();
             }
             else
             {
@@ -425,6 +430,18 @@ internal static string GetCurrentMSBuildArchitecture()
             return currentArchitecture;
         }
 
+        /// <summary>
+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. 
+        /// </summary>
+        internal static string GetCurrentMSBuildRuntime()
+        {
+#if NET40_OR_GREATER
+            return MSBuildRuntimeValues.clr4;
+#else
+            return MSBuildRuntimeValues.net;
+#endif
+        }
+
         /// <summary>
         /// Given an MSBuildArchitecture value that may be non-explicit -- e.g. "CurrentArchitecture" or "Any" --
         /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map 
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 15508eb6fea..302d50bfd6c 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -92,13 +92,13 @@ public bool MoveNext()
         }
 
         /// <summary>
-        /// The span held by this struct, inline to be able to represent <see cref="ReadOnlySpan{char}"/>. May be empty.
+        /// The span held by this struct, inline to be able to represent <see cref="ReadOnlySpan{T}"/>. May be empty.
         /// </summary>
         private readonly ReadOnlySpan<char> _inlineSpan;
 
 #if NETSTANDARD
         /// <summary>
-        /// .NET Core does not keep a reference to the containing object in <see cref="ReadOnlySpan{char}"/>. In particular,
+        /// .NET Core does not keep a reference to the containing object in <see cref="ReadOnlySpan{T}"/>. In particular,
         /// it cannot recover the string if the span represents one. We have to hold the reference separately to be able to
         /// roundtrip String-&gt;InternableString-&gt;String without allocating a new String.
         /// </summary>
@@ -111,7 +111,7 @@ public bool MoveNext()
         private List<ReadOnlyMemory<char>>? _spans;
 
         /// <summary>
-        /// Constructs a new InternableString wrapping the given <see cref="ReadOnlySpan{char}"/>.
+        /// Constructs a new InternableString wrapping the given <see cref="ReadOnlySpan{T}"/>.
         /// </summary>
         /// <param name="span">The span to wrap.</param>
         /// <remarks>
diff --git a/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..2cd09cc29ef
--- /dev/null
+++ b/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt
@@ -0,0 +1,26 @@
+#nullable enable
+Microsoft.NET.StringTools.SpanBasedStringBuilder
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string! value) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string! value, int startIndex, int count) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(System.ReadOnlyMemory<char> span) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Capacity.get -> int
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
+Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
+Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string! str) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Trim() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimEnd() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimStart() -> void
+Microsoft.NET.StringTools.Strings
+override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string!
+static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string!
+static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
+static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder!
+static Microsoft.NET.StringTools.Strings.WeakIntern(string! str) -> string!
+static Microsoft.NET.StringTools.Strings.WeakIntern(System.ReadOnlySpan<char> str) -> string!
diff --git a/src/StringTools/PublicAPI/net/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/net/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..3ac8d4a6e79
--- /dev/null
+++ b/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt
@@ -0,0 +1,21 @@
+#nullable enable
+Microsoft.NET.StringTools.SpanBasedStringBuilder
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator(System.Text.StringBuilder! builder) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
+Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
+Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string! str) -> void
+Microsoft.NET.StringTools.Strings
+override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string!
+static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string!
+static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
+static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder!
+static Microsoft.NET.StringTools.Strings.WeakIntern(string! str) -> string!
+static System.MemoryExtensions.AsSpan<T>(this T[]! array, int start, int length) -> string!
+System.MemoryExtensions
diff --git a/src/StringTools/PublicAPI/net35/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/net35/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..2cd09cc29ef
--- /dev/null
+++ b/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -0,0 +1,26 @@
+#nullable enable
+Microsoft.NET.StringTools.SpanBasedStringBuilder
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string! value) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string! value, int startIndex, int count) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(System.ReadOnlyMemory<char> span) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Capacity.get -> int
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
+Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
+Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string! str) -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.Trim() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimEnd() -> void
+Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimStart() -> void
+Microsoft.NET.StringTools.Strings
+override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string!
+static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string!
+static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
+static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder!
+static Microsoft.NET.StringTools.Strings.WeakIntern(string! str) -> string!
+static Microsoft.NET.StringTools.Strings.WeakIntern(System.ReadOnlySpan<char> str) -> string!
diff --git a/src/StringTools/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/netstandard/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index fef9909ce6f..f4108d5158b 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -5,6 +5,7 @@
     <PlatformTarget>AnyCPU</PlatformTarget>
     <WarningsAsErrors>true</WarningsAsErrors>
     <IsPackable>true</IsPackable>
+    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <LangVersion>8.0</LangVersion>
     <PackageId>Microsoft.NET.StringTools</PackageId>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -20,17 +21,12 @@
 
   <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
     <AssemblyName>Microsoft.NET.StringTools.net35</AssemblyName>
-    <!-- Disable Fx install checks as we're building against jnm2's 3.5 reference assemblies -->
-    <BypassFrameworkInstallChecks>true</BypassFrameworkInstallChecks>
   </PropertyGroup>
 
   <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
     <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
   </ItemGroup>
-  <ItemGroup>
-    <PackageReference Include="jnm2.ReferenceAssemblies.net35" PrivateAssets="All" />
-  </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFramework)' == 'net35'">
     <Compile Remove="SpanBasedStringBuilder.cs" />
diff --git a/src/StringTools/WeakStringCache.Locking.cs b/src/StringTools/WeakStringCache.Locking.cs
index 47daf7ee824..1000c4cbf7d 100644
--- a/src/StringTools/WeakStringCache.Locking.cs
+++ b/src/StringTools/WeakStringCache.Locking.cs
@@ -24,6 +24,7 @@ public WeakStringCache()
         /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
         /// </summary>
         /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <param name="cacheHit">Whether the entry was already in the cache.</param>
         /// <returns>A string matching the given internable.</returns>
         public string GetOrCreateEntry(ref InternableString internable, out bool cacheHit)
         {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index e932aba587b..e64d7b07d8c 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -14,6 +14,8 @@
 using Xunit;
 using Xunit.Abstractions;
 
+using NativeMethods = Microsoft.Build.Tasks.NativeMethods;
+
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
     public class ResolveAssemblyReferenceTestFixture : IDisposable
diff --git a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
index d82ce671a45..414f8d98bff 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
@@ -703,7 +703,7 @@ private void VerifyImplementationArchitecture(string winmdName, string targetPro
             string fullMessage;
             if (implementationFileArch.Equals("Unknown"))
             {
-                fullMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.UnknownProcessorArchitecture", @"C:\WinMDArchVerification\" + winmdName + ".dll", @"C:\WinMDArchVerification\" + winmdName + ".winmd", NativeMethods.IMAGE_FILE_MACHINE_R4000.ToString("X", CultureInfo.InvariantCulture));
+                fullMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.UnknownProcessorArchitecture", @"C:\WinMDArchVerification\" + winmdName + ".dll", @"C:\WinMDArchVerification\" + winmdName + ".winmd", Tasks.NativeMethods.IMAGE_FILE_MACHINE_R4000.ToString("X", CultureInfo.InvariantCulture));
             }
             else
             {
diff --git a/src/Tasks.UnitTests/AssemblyInfo.cs b/src/Tasks.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/Tasks.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 6d48ace8c4b..1d2e517b4ef 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -303,14 +303,14 @@ public void AlwaysRetryCopyEnvironmentOverride()
                     UseSymboliclinksIfPossible = UseSymbolicLinks,
                 };
 
-                // The file is read-only, so the retries will all fail. 
+                // The file is read-only, so the retries will all fail.
                 Assert.False(t.Execute());
 
-                // 3 warnings per retry, except the last one which has only two. 
+                // 3 warnings per retry, except the last one which has only two.
                 ((MockEngine)t.BuildEngine).AssertLogContains("MSB3026");
                 Assert.Equal(((t.Retries + 1) * 3) - 1, ((MockEngine)t.BuildEngine).Warnings);
 
-                // One error for "retrying failed", one error for "copy failed" 
+                // One error for "retrying failed", one error for "copy failed"
                 ((MockEngine)t.BuildEngine).AssertLogContains("MSB3027");
                 ((MockEngine)t.BuildEngine).AssertLogContains("MSB3021");
                 Assert.Equal(2, ((MockEngine)t.BuildEngine).Errors);
@@ -540,7 +540,7 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
 
                 File.WriteAllText(sourceFile, "This is a source temp file.");
 
-                // run copy twice, so we test if we are able to overwrite previously copied (or linked) file 
+                // run copy twice, so we test if we are able to overwrite previously copied (or linked) file
                 for (var i = 0; i < 2; i++)
                 {
                     var engine = new MockEngine(_testOutputHelper);
@@ -2315,7 +2315,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
                 {
                     string destLink = Path.Combine(destFolder, Path.GetFileNameWithoutExtension(sourceFile) + "." + n);
                     string linkError = String.Empty;
-                    NativeMethods.MakeHardLink(destLink, sourceFile, ref linkError);
+                    Tasks.NativeMethods.MakeHardLink(destLink, sourceFile, ref linkError);
                 }
 
                 ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index 88f8cf4959f..a88113e0319 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -23,9 +23,9 @@ sealed public class GetReferenceAssmeblyPath_Tests
         [Fact]
         public void TestGeneralFrameworkMonikerGood()
         {
-            string targetFrameworkMoniker = ".NetFramework, Version=v4.5";
-            MockEngine engine = new MockEngine();
-            GetReferenceAssemblyPaths getReferencePaths = new GetReferenceAssemblyPaths();
+            string targetFrameworkMoniker = ".NetFramework, Version=v4.8";
+            MockEngine engine = new();
+            GetReferenceAssemblyPaths getReferencePaths = new();
             getReferencePaths.BuildEngine = engine;
             getReferencePaths.TargetFrameworkMoniker = targetFrameworkMoniker;
             getReferencePaths.Execute();
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 05200fcfac9..04ef5ffcd1d 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 
@@ -350,12 +351,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), @"
+                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 98ae00b9da8..9d9813898bc 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Tasks.UnitTests</AssemblyName>
@@ -40,9 +39,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\AssemblyNameEx_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\EscapingUtilities_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\ErrorUtilities_Tests.cs" />
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index f400cef6a24..f9aabd40908 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -52,13 +52,16 @@ public void OverrideBaseIntermediateOutputPathSucceeds()
         [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows))]
         public void AssemblyAttributesLocation()
         {
-            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.0.AssemblyAttributes.cs");
+            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.8.AssemblyAttributes.cs");
 
             var project = ObjectModelHelpers.CreateInMemoryProject($@"
 <Project>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.Common.props"" />
+  <PropertyGroup>
+    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
+  </PropertyGroup>
   <ItemGroup>
-    <Compile Include=""a.cs""/>       
+    <Compile Include=""a.cs""/>
   </ItemGroup>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.CSharp.targets"" />
 
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 7f88ef17839..0dee182082b 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -1,15 +1,25 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
+using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
     sealed public class RemoveDir_Tests
     {
+        ITestOutputHelper _output;
+        public RemoveDir_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         /*
          * Method:   AttributeForwarding
          *
@@ -23,14 +33,42 @@ public void AttributeForwarding()
             ITaskItem i = new TaskItem("MyNonExistentDirectory");
             i.SetMetadata("Locale", "en-GB");
             t.Directories = new ITaskItem[] { i };
-            t.BuildEngine = new MockEngine();
+            t.BuildEngine = new MockEngine(_output);
 
             t.Execute();
 
-            Assert.Equal("en-GB", t.RemovedDirectories[0].GetMetadata("Locale"));
+            t.RemovedDirectories[0].GetMetadata("Locale").ShouldBe("en-GB");
+            t.RemovedDirectories[0].ItemSpec.ShouldBe("MyNonExistentDirectory");
+            Directory.Exists(t.RemovedDirectories[0].ItemSpec).ShouldBeFalse();
+        }
+
+        [Fact]
+        public void SimpleDelete()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                List<TaskItem> list = new List<TaskItem>();
+
+                for (int i = 0; i < 20; i++)
+                {
+                    list.Add(new TaskItem(env.CreateFolder().Path));
+                }
+
+                RemoveDir t = new RemoveDir();
+
+                t.Directories = list.ToArray();
+                t.BuildEngine = new MockEngine(_output);
+
+                t.Execute().ShouldBeTrue();
+
+                t.RemovedDirectories.Length.ShouldBe(list.Count);
 
-            // Output ItemSpec should not be overwritten.
-            Assert.Equal("MyNonExistentDirectory", t.RemovedDirectories[0].ItemSpec);
+                for (int i = 0; i < 20; i++)
+                {
+                    Directory.Exists(list[i].ItemSpec).ShouldBeFalse();
+                }
+            }
         }
     }
 }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 6d055df7140..8ffdf31868d 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -2369,14 +2369,15 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
 
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2546,13 +2547,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 99e3d7066b0..3e20f81bc0f 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -2730,14 +2730,14 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2908,13 +2908,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 5fc54d6dfcf..785bab86be5 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -13,6 +13,7 @@
 using System.Text.RegularExpressions;
 using System.Xml.Xsl;
 using System.Xml;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -386,7 +387,7 @@ public void OutputTest()
         /// Setting correct "Parameter" parameters for Xsl.
         /// </summary>
         [Fact]
-        public void XsltParamatersCorrect()
+        public void XsltParametersCorrect()
         {
             string dir;
             TaskItem[] xmlPaths;
@@ -780,6 +781,39 @@ public void OutputFileCannotBeWritten()
             CleanUp(dir);
         }
 
+        /// <summary>
+        /// The files are not kept locked by the task
+        /// </summary>
+        [Fact]
+        public void InputFilesDontLock()
+        {
+            string dir;
+            TaskItem[] xmlPaths;
+            TaskItem xslPath;
+            TaskItem[] outputPaths;
+            MockEngine engine;
+            Prepare(out dir, out xmlPaths, out xslPath, out _, out outputPaths, out _, out _, out engine);
+
+            // Test with files
+            {
+                XslTransformation t = new XslTransformation();
+                t.BuildEngine = engine;
+                t.XmlInputPaths = xmlPaths;
+                t.XslInputPath = xslPath;
+                t.OutputPaths = outputPaths;
+
+                t.Execute().ShouldBeTrue();
+                string xmlInputPath = xmlPaths[0].ItemSpec;
+                File.Delete(xmlInputPath); // this should succeed (file not locked by task)
+                File.Exists(xmlInputPath).ShouldBeFalse();
+                string xslInputPath = xslPath.ItemSpec;
+                File.Delete(xslInputPath); // this should succeed (file not locked by task)
+                File.Exists(xslInputPath).ShouldBeFalse();
+            }
+
+            CleanUp(dir);
+        }
+
         /// <summary>
         /// XslDocument that throws runtime exception.
         /// </summary>
diff --git a/src/Tasks/AppConfig/BindingRedirect.cs b/src/Tasks/AppConfig/BindingRedirect.cs
index 5e5404af394..8a226ede9c5 100644
--- a/src/Tasks/AppConfig/BindingRedirect.cs
+++ b/src/Tasks/AppConfig/BindingRedirect.cs
@@ -61,7 +61,7 @@ internal void Read(XmlReader reader)
                     throw;
                 }
 
-                ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidOldVersionAttribute", e.Message);
+                ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidOldVersionAttribute", e.Message);
             }
 
             string newVersionAttribute = reader.GetAttribute("newVersion");
@@ -80,7 +80,7 @@ internal void Read(XmlReader reader)
                     throw;
                 }
 
-                ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidNewVersionAttribute", e.Message);
+                ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidNewVersionAttribute", e.Message);
             }
         }
     }
diff --git a/src/Tasks/AppConfig/DependentAssembly.cs b/src/Tasks/AppConfig/DependentAssembly.cs
index 2337cafd376..2bbbc37e39a 100644
--- a/src/Tasks/AppConfig/DependentAssembly.cs
+++ b/src/Tasks/AppConfig/DependentAssembly.cs
@@ -96,7 +96,7 @@ internal void Read(XmlReader reader)
                     catch (System.IO.FileLoadException e)
                     {
                         // A badly formed assembly name.
-                        ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidAssemblyIdentityFields");
+                        ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidAssemblyIdentityFields");
                     }
                 }
 
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index 5f0cdbf64e0..882be85d3e8 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Tasks
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 196a70b8747..3b214c55a9f 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -741,13 +741,8 @@ out string redistName
         /// </summary>
         private static void TryConvertToAssemblyName(string itemSpec, string fusionName, ref AssemblyNameExtension assemblyName)
         {
-            // FusionName is used if available.
-            string finalName = fusionName;
-            if (string.IsNullOrEmpty(finalName))
-            {
-                // Otherwise, its itemSpec.
-                finalName = itemSpec;
-            }
+            // FusionName is used if available; otherwise use itemspec.
+            string finalName = string.IsNullOrEmpty(fusionName) ? itemSpec : fusionName;
 
             bool pathRooted = false;
             try
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 2cea34c71bb..53b19c17a62 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -3153,23 +3153,26 @@ public override bool Execute()
         {
             return Execute
             (
-                new FileExists(p => FileUtilities.FileExistsNoThrow(p)),
-                new DirectoryExists(p => FileUtilities.DirectoryExistsNoThrow(p)),
-                new GetDirectories(Directory.GetDirectories),
-                new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx),
-                new GetAssemblyMetadata(AssemblyInformation.GetAssemblyMetadata),
+                p => FileUtilities.FileExistsNoThrow(p),
+                p => FileUtilities.DirectoryExistsNoThrow(p),
+                (p, searchPattern) => Directory.GetDirectories(p, searchPattern),
+                p => AssemblyNameExtension.GetAssemblyNameEx(p),
+                (string path, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache, out AssemblyNameExtension[] dependencies, out string[] scatterFiles, out FrameworkNameVersioning frameworkName)
+                    => AssemblyInformation.GetAssemblyMetadata(path, assemblyMetadataCache, out dependencies, out scatterFiles, out frameworkName),
 #if FEATURE_WIN32_REGISTRY
-                new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames),
-                new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue),
+                (baseKey, subkey) => RegistryHelper.GetSubKeyNames(baseKey, subkey),
+                (baseKey, subkey) => RegistryHelper.GetDefaultValue(baseKey, subkey),
 #endif
-                new GetLastWriteTime(NativeMethodsShared.GetLastWriteFileUtcTime),
-                new GetAssemblyRuntimeVersion(AssemblyInformation.GetRuntimeVersion),
+                p => NativeMethodsShared.GetLastWriteFileUtcTime(p),
+                p => AssemblyInformation.GetRuntimeVersion(p),
 #if FEATURE_WIN32_REGISTRY
-                new OpenBaseKey(RegistryHelper.OpenBaseKey),
+                (hive, view) => RegistryHelper.OpenBaseKey(hive, view),
 #endif
-                new GetAssemblyPathInGac(GetAssemblyPathInGac),
-                new IsWinMDFile(AssemblyInformation.IsWinMDFile),
-                new ReadMachineTypeFromPEHeader(ReferenceTable.ReadMachineTypeFromPEHeader)
+                (assemblyName, targetProcessorArchitecture, getRuntimeVersion, targetedRuntimeVersion, fileExists, fullFusionName, specificVersion)
+                    => GetAssemblyPathInGac(assemblyName, targetProcessorArchitecture, getRuntimeVersion, targetedRuntimeVersion, fileExists, fullFusionName, specificVersion),
+                (string fullPath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, out string imageRuntimeVersion, out bool isManagedWinmd)
+                    => AssemblyInformation.IsWinMDFile(fullPath, getAssemblyRuntimeVersion, fileExists, out imageRuntimeVersion, out isManagedWinmd),
+                p => ReferenceTable.ReadMachineTypeFromPEHeader(p)
             );
         }
 
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index be72b128729..7a30ee1d703 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -52,13 +52,13 @@ internal abstract class Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
+        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
         {
             this.searchPathElement = searchPathElement;
             this.getAssemblyName = getAssemblyName;
             this.fileExists = fileExists;
             this.getRuntimeVersion = getRuntimeVersion;
-            this.targetedRuntimeVersion = targetedRuntimeVesion;
+            this.targetedRuntimeVersion = targetedRuntimeVersion;
             this.targetProcessorArchitecture = targetedProcessorArchitecture;
             this.compareProcessorArchitecture = compareProcessorArchitecture;
         }
@@ -214,6 +214,14 @@ ResolutionSearchLocation searchLocation
 
                     // ...falling through and relying on the targetAssemblyName==null behavior below...
                 }
+                catch (BadImageFormatException)
+                {
+                    // As above, this is weird: there's a valid reference to an assembly with a file on disk
+                    // that isn't a valid .NET assembly. Might be the result of mid-build corruption, but
+                    // could just be a name collision on one of the possible resolution paths.
+
+                    // as above, fall through.
+                }
 
                 if (searchLocation != null)
                 {
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index d6d3e0ae209..dfc0c4632c7 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -54,7 +54,7 @@ Dictionary<string, string> directories
                 }
                 else
                 {
-                    ErrorUtilities.VerifyThrow(false, "AssemblyFolder.AddFoldersFromRegistryKey expected a known hive.");
+                    ErrorUtilities.ThrowInternalError("AssemblyFolder.AddFoldersFromRegistryKey expected a known hive.");
                 }
 
                 if (baseKey != null)
diff --git a/src/Tasks/AssemblyInfo.cs b/src/Tasks/AssemblyInfo.cs
index df3964f3cd5..02ca0d38cf8 100644
--- a/src/Tasks/AssemblyInfo.cs
+++ b/src/Tasks/AssemblyInfo.cs
@@ -1,20 +1,22 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 using System.Runtime.InteropServices;
 using System.Runtime.CompilerServices;
 
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
-// this assembly.  We should specify this explicitly, as opposed to letting 
-// tlbexp just pick whatever it wants.  
+// this assembly.  We should specify this explicitly, as opposed to letting
+// tlbexp just pick whatever it wants.
 [assembly: GuidAttribute("E3D4D3B9-944C-407b-A82E-B19719EA7FB3")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index c3ecc2aac73..3e7da8c94cd 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -2091,7 +2091,10 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
+                    // Skip this check if the public key attribute is "0", as this means we're expecting the public key
+                    // comparison to be skipped at install time because the file is signed by an MS trusted cert.
+                    if (publicKeyAttribute.Value.Equals("0", StringComparison.OrdinalIgnoreCase) == false &&
+                        publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 6c91abeaab3..1575b55d11b 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -588,8 +588,7 @@ private bool CopyParallel(
                 if (!partitionAccepted)
                 {
                     // Retail assert...
-                    ErrorUtilities.VerifyThrow(false,
-                        "Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
+                    ErrorUtilities.ThrowInternalError("Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
                 }
             }
 
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index 9837e9b1f2a..bb939b9174a 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -3,11 +3,10 @@
 
 using System;
 using System.IO;
-using System.Text;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -114,7 +113,7 @@ internal static string CreateManifestNameImpl
                 info.culture = culture;
             }
 
-            var manifestName = new StringBuilder();
+            var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
@@ -212,7 +211,7 @@ internal static string CreateManifestNameImpl
                 }
             }
 
-            return manifestName.ToString();
+            return StringBuilderCache.GetStringAndRelease(manifestName);
         }
 
         /// <summary>
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 864450634a1..fe02c57753f 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -3,8 +3,8 @@
 
 using System;
 using System.IO;
-using System.Text;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -111,7 +111,7 @@ internal static string CreateManifestNameImpl
                 info.culture = culture;
             }
 
-            var manifestName = new StringBuilder();
+            var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
@@ -192,7 +192,7 @@ internal static string CreateManifestNameImpl
                 }
             }
 
-            return manifestName.ToString();
+            return StringBuilderCache.GetStringAndRelease(manifestName);
         }
 
         /// <summary>
diff --git a/src/Tasks/FxCopExclusions/Microsoft.Build.Tasks.Suppressions.cs b/src/Tasks/FxCopExclusions/Microsoft.Build.Tasks.Suppressions.cs
deleted file mode 100644
index 22d44319af5..00000000000
--- a/src/Tasks/FxCopExclusions/Microsoft.Build.Tasks.Suppressions.cs
+++ /dev/null
@@ -1,585 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-// FxCop Suppression file
-// To Use:
-// Add module level suppressions to this file to have them suppressed in the assembly
-//
-
-#if CODE_ANALYSIS
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="0", Scope="module", Target="microsoft.build.tasks.core.dll", Justification="Already shipped several versions with a name like this")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Build.Tasks.NativeMethods.GetCachePath(Microsoft.Build.Tasks.AssemblyCacheFlags,System.Text.StringBuilder,System.Int32@)", Scope="member", Target="Microsoft.Build.Tasks.GlobalAssemblyCache.#GetGacPath()", Justification="We do not use the method result we use one of the out parameters as a check instead. This is because the method can have a failed hresult but return a object in the out parameter.")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Build.Tasks.IAssemblyCache.QueryAssemblyInfo(System.UInt32,System.String,Microsoft.Build.Tasks.ASSEMBLY_INFO@)", Scope="member", Target="Microsoft.Build.Tasks.GlobalAssemblyCache.#GetLocationImpl(Microsoft.Build.Shared.AssemblyNameExtension,System.String)", Justification="We do not use the method result we use one of the out parameters as a check instead. This is because the method can have a failed hresult but return a object in the out parameter.")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Build.Tasks.NativeMethods.CreateAssemblyCache(Microsoft.Build.Tasks.IAssemblyCache@,System.UInt32)", Scope="member", Target="Microsoft.Build.Tasks.GlobalAssemblyCache.#GetLocationImpl(Microsoft.Build.Shared.AssemblyNameExtension,System.String)", Justification="We do not use the method result we use one of the out parameters as a check instead. This is because the method can have a failed hresult but return a object in the out parameter.")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Build.Tasks.NativeMethods.CompareAssemblyIdentity(System.String,System.Boolean,System.String,System.Boolean,System.Boolean@,Microsoft.Build.Tasks.NativeMethods+AssemblyComparisonResult@)", Scope="member", Target="Microsoft.Build.Tasks.ReferenceTable.#ResolveAssemblyNameConflict(Microsoft.Build.Tasks.AssemblyNameReference,Microsoft.Build.Tasks.AssemblyNameReference)", Justification="We do use this")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateBootstrapper.SupportUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationUrl", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1054:UriParametersShouldNotBeStrings", MessageId="0#", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity..ctor(System.String,Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity,Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity)", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1054:UriParametersShouldNotBeStrings", MessageId="0#", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity..ctor(System.String,System.String,System.String)", Justification="These are already public properties and parameters which cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.FormatUrl.OutputUrl", Justification="This is the input and output name of the format url task which are all public and cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.FormatUrl.InputUrl", Justification="This is the input and output name of the format url task which are all public and cannot be changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.SignFile.TimestampUrl", Justification="Do not want to change string to URI as this is a public property on a public task")]
-[module: SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="3#", Justification="Excluded until IFixedTypeInfo is replaced by ITypeInfo")]
-[module: SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(System.Object,System.Guid&,System.Object&):System.Void", MessageId="1#", Justification="Excluded until IFixedTypeInfo is replaced by ITypeInfo")]
-[module: SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(System.Object,System.Guid&,System.Object&):System.Void", MessageId="pUnk", Justification="Excluded until IFixedTypeInfo is replaced by ITypeInfo")]
-[module: SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr,Microsoft.Build.Tasks.IFixedTypeInfo&):System.Void", MessageId="hRef", Justification="Excluded until IFixedTypeInfo is replaced by ITypeInfo")]
-[module: SuppressMessage("Microsoft.Usage",  "CA2208:InstantiateArgumentExceptionsCorrectly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension):System.Void", Justification="The argument parameter is Sources, this is correct as the exception is thrown if there is a problem with the Sources[0].ItemSpec. This parameter is on the class rather than the method.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", Scope="member", Target="Microsoft.Build.Tasks.ToolTaskExtension.GetBoolParameterWithDefault(System.String,System.Boolean):System.Boolean", MessageId="bool", Justification="These are method that return supposed to return a language specific type. Also the method is public, has shipped and cannot be changed for compatibility reasons.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", Scope="member", Target="Microsoft.Build.Tasks.ToolTaskExtension.GetIntParameterWithDefault(System.String,System.Int32):System.Int32", MessageId="int", Justification="These are method that return supposed to return a language specific type. Also the method is public, has shipped and cannot be changed for compatibility reasons.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="regasm", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="vcbuild", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="IDE's", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="v", Justification="Casing is correct")]
-[module: SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID", MessageId="LCID", Justification="Casing is correct")]
-[module: SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID", MessageId="LCID", Justification="Casing is correct")]
-[module: SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.IID", MessageId="IID", Justification="Casing is correct")]
-[module: SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID", MessageId="IID", Justification="Casing is correct")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="5", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs", MessageId="Libs", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs", MessageId="Libs", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.NumMethods", MessageId="Num", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods", MessageId="Num", Justification="Are spelled correctly")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(System.Int32,System.IntPtr&):System.Void", MessageId="Impl", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(System.Int32,System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS&):System.Void", MessageId="Impl", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(System.Int32,System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS&):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(System.Int32,System.Runtime.InteropServices.ComTypes.INVOKEKIND,System.IntPtr,System.IntPtr,System.IntPtr):System.Void", MessageId="Bstr", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(System.Int32,System.Runtime.InteropServices.ComTypes.INVOKEKIND,System.IntPtr,System.IntPtr,System.IntPtr):System.Void", MessageId="pw", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(System.Int32,System.Runtime.InteropServices.ComTypes.INVOKEKIND,System.IntPtr,System.IntPtr,System.IntPtr):System.Void", MessageId="memid", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(System.Int32,System.Runtime.InteropServices.ComTypes.INVOKEKIND,System.IntPtr,System.IntPtr,System.IntPtr):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="Excep", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="w", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="memid", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="Disp", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="Params", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(System.Object,System.Int32,System.Int16,System.Runtime.InteropServices.ComTypes.DISPPARAMS&,System.IntPtr,System.IntPtr,System.Int32&):System.Void", MessageId="pu", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr):System.Void", MessageId="Func", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr):System.Void", MessageId="Desc", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(System.Int32,System.String&,System.String&,System.Int32&,System.String&):System.Void", MessageId="dw", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(System.Int32,System.String&,System.String&,System.Int32&,System.String&):System.Void", MessageId="str", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(System.String[],System.Int32,System.Int32[]):System.Void", MessageId="Mem", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(System.String[],System.Int32,System.Int32[]):System.Void", MessageId="c", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(System.String[],System.Int32,System.Int32[]):System.Void", MessageId="rgsz", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(System.String[],System.Int32,System.Int32[]):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(System.String[],System.Int32,System.Int32[]):System.Void", MessageId="IDs", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(System.Runtime.InteropServices.ComTypes.ITypeLib&,System.Int32&):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(System.Runtime.InteropServices.ComTypes.ITypeLib&,System.Int32&):System.Void", MessageId="TLB", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(System.Int32,System.Runtime.InteropServices.ComTypes.INVOKEKIND,System.IntPtr&):System.Void", MessageId="memid", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(System.Int32,System.Runtime.InteropServices.ComTypes.INVOKEKIND,System.IntPtr&):System.Void", MessageId="ppv", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr):System.Void", MessageId="Attr", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(System.Object,System.Guid&,System.Object&):System.Void", MessageId="Unk", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(System.Object,System.Guid&,System.Object&):System.Void", MessageId="riid", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(System.Object,System.Guid&,System.Object&):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(System.Object,System.Guid&,System.Object&):System.Void", MessageId="ppv", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(System.Int32,System.IntPtr&):System.Void", MessageId="Func", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(System.Int32,System.IntPtr&):System.Void", MessageId="Desc", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(System.Int32,System.String[],System.Int32,System.Int32&):System.Void", MessageId="Bstr", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(System.Int32,System.String[],System.Int32,System.Int32&):System.Void", MessageId="c", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(System.Int32,System.String[],System.Int32,System.Int32&):System.Void", MessageId="memid", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(System.Int32,System.String[],System.Int32,System.Int32&):System.Void", MessageId="rg", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(System.Int32,System.String&):System.Void", MessageId="Bstr", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(System.Int32,System.String&):System.Void", MessageId="memid", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(System.Int32,System.String&):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(System.IntPtr&):System.Void", MessageId="Attr", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr,Microsoft.Build.Tasks.IFixedTypeInfo&):System.Void", MessageId="h", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr):System.Void", MessageId="Desc", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr):System.Void", MessageId="p", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(System.Int32,System.IntPtr&):System.Void", MessageId="Desc", Justification="These are spelled and named in c++ syntax because it is a temporary fixed implementation of the ITypeInfo interface, when the interface is reverted to the original these suppression messages can go away.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames", Justification="Our assemblies are delay signed.")]
-[module: SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope="namespace", Target="Microsoft.Build.Tasks.Hosting", Justification="KCwalina explicitly asked us to move these types into their own namespace since they're not tasks.")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.Tasks.Hosting", Justification="Microsoft.Build.Tasks.Hosting is approved.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.Tasks.Hosting.ICscHostObject2", MessageId="Csc", Justification="This is the name of the C# compiler and this interface is a wrapper over it.  Keeping the name.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject", MessageId="Vbc", Justification="VBC and CSC are spelled correctly.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", Scope="member", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(System.Boolean):System.Boolean", MessageId="0#", Justification="This parameter is not referring to a type, it's referring to a switch on the VBC compiler.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.Tasks.Hosting.ICscHostObject", MessageId="Csc", Justification="VBC and CSC are spelled correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", Scope="member", Target="Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(System.String&,System.Int32&):System.Boolean", MessageId="0#", Justification="Method has multiple return values, so it must use out parameters.")]
-[module: SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", Scope="member", Target="Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(System.String&,System.Int32&):System.Boolean", MessageId="1#", Justification="Method has multiple return values, so it must use out parameters.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject2", MessageId="Vbc", Justification="Vbc is the correct spelling for the VB compiler.")]
-[module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.Tasks", Justification="Microsoft.Build.Tasks is an approved namespace according to http://ddwww/apps/apiowners/")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.GetFrameworkPath..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.LC.ReferencedAssemblies", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.LC.ReferencedAssemblies", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.LC.Sources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.LC.Sources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AssignProjectConfiguration..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration", Scope="member", Target="Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(System.String,System.String,System.String,System.String,System.IO.Stream):System.String", MessageId="2#", Justification="Cannot change parameter names because that would break compat with reflection users, theoretically.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.ResolveRef(System.Reflection.Assembly):System.Object", MessageId="0#", Justification="Cannot change parameter names because that would break compat with reflection users, theoretically.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.Register(System.String,System.String):System.Boolean", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We need to call Assembly.LoadFrom here, it's by design.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.Assemblies", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.Assemblies", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind,System.Int32,System.String):System.Void", MessageId="0#", Justification="Cannot change parameter names because that would break compat with reflection users, theoretically.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind,System.Int32,System.String):System.Void", MessageId="1#", Justification="Cannot change parameter names because that would break compat with reflection users, theoretically.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration", Scope="member", Target="Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind,System.Int32,System.String):System.Void", MessageId="2#", Justification="Cannot change parameter names because that would break compat with reflection users, theoretically.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateProperty.ValueSetByTask", Justification="this is the msbuild task authoring model")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateProperty.Value", Justification="this is the msbuild task authoring model")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CreateProperty.Value", Justification="this is the msbuild task authoring model")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateItem.Include", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CreateItem.Include", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.CreateItem..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateItem.AdditionalMetadata", Justification="msbuild task authoring model")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CreateItem.AdditionalMetadata", Justification="msbuild task authoring model")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateItem.Exclude", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CreateItem.Exclude", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.GetAssemblyIdentity.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ParseState..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.TypeLibNames", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.TypeLibNames", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.Execute():System.Boolean", Justification="In some situations the underlying wrapper generation code can throw a SystemException and there's nothing else we can do to prevent MSBuild from crashing.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.ResolvedModules", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.ResolvedModules", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReference.VerifyReferenceMetadataForNameItem(Microsoft.Build.Framework.ITaskItem,System.String&):System.Boolean", MessageId="System.Guid", Justification="The Guid is created and never used on purpose, to check if the passed-in guid is valid.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.DependentAssembly..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs", MessageId="Preresolved", Justification="Preresolved is spelled correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories", Justification="This is the MSBuild task authoring model for Whidbey.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories", Justification="This is the MSBuild task authoring model for Whidbey.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions", Justification="This is an appropriate design in this case.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions", Justification="This is an appropriate design in this case.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.set_FilesWritten(Microsoft.Build.Framework.ITaskItem[]):System.Void", MessageId="value", Justification="This is an output only property so we have no use for the implicit value input parameter.  We cannot however remove the property set because this would be a breaking change.  Excluding instead.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.SGen.SerializationAssembly", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.SGen.SerializationAssembly", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.SGen.References", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.SGen.References", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="member", Target="Microsoft.Build.Tasks.AspNetCompiler.MetabasePath", MessageId="Metabase", Justification="Metabase is spelled correctly - it's an IIS term")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AssemblyInformation..ctor(System.String)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignTargetPath.Files", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AssignTargetPath.Files", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AssignTargetPath..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveComReferenceCache..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.CreateManifestResourceName.Execute(Microsoft.Build.Tasks.CreateFileStream):System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.CreateManifestResourceName..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.MSBuild..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.Targets", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.Targets", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.TargetOutputs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.ExecuteTargets(Microsoft.Build.Framework.ITaskItem[],System.Collections.Hashtable,System.Collections.ArrayList,System.Boolean,System.Boolean,Microsoft.Build.Framework.IBuildEngine2,Microsoft.Build.Utilities.TaskLoggingHelper,System.Collections.ArrayList,System.Boolean,System.Boolean,System.String):System.Boolean", Justification="Refactoring would decrease readability")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.Projects", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.Projects", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.Properties", Justification="msbuild task authoring model")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.MSBuild.Properties", Justification="msbuild task authoring model")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.BindingRedirect..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes", Scope="type", Target="Microsoft.Build.Tasks.ExtractedClassName", Justification="This is an internally used class and it doesn't need an implementation of Equals.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AssemblyFoldersExResolver..ctor(System.String,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Shared.FileExists,Microsoft.Build.Tasks.GetRegistrySubKeyNames,Microsoft.Build.Tasks.GetRegistrySubKeyDefaultValue)", Justification="Explicit initialization improves code readability.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.AxReference.GenerateWrapper(Microsoft.Build.Tasks.ComReferenceWrapperInfo&):System.Boolean", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We need to call Assembly.LoadFrom here, it's by design.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.PiaReference.FindExistingWrapper(Microsoft.Build.Tasks.ComReferenceWrapperInfo&,System.DateTime):System.Boolean", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We need to call Assembly.LoadFrom here, it's by design.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.GetFrameworkSdkPath..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ProcessResourceFiles+LineNumberStreamReader..ctor(System.IO.Stream)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ProcessResourceFiles+LineNumberStreamReader..ctor(System.String,System.Text.Encoding,System.Boolean)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration", Scope="member", Target="Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(System.String,System.String,System.String,System.String,System.IO.Stream):System.String", MessageId="2#", Justification="Cannot change parameter names because that would break compat with reflection users, theoretically.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.ResolveKeySource.ResolveAssemblyKey():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Scope="member", Target="Microsoft.Build.Tasks.ResolveKeySource.ResolveAssemblyKey():System.Boolean", Justification="From comments:  We use ToLower(invariant) because this is what the native equivalent of this function (Create new key, or VC++ import-er). use as well and we want to keep the hash (and key container name the same) otherwise user could be prompt for a password twice.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveKeySource..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.DisposableBase..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.ResolvedOutputPaths", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.ResolvedOutputPaths", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput..cctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.vcProjectEngineDll", Justification="It's not necessary to use a SafeHandle here - we load the dll just once and it's released automatically on process shutdown by the system.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.ProjectReferences", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.ProjectReferences", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.ResolveUsingVCEngineObjectModel(Microsoft.Build.Framework.ITaskItem,System.String,System.String&,System.String&):System.Boolean", Justification="Refactoring would cause increased complexity rather than decrease it")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput.ResolveUsingVCEngineObjectModel(Microsoft.Build.Framework.ITaskItem,System.String,System.String&,System.String&):System.Boolean", Justification="The exception is rethrown unless it's a known type.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveVCProjectOutput..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Tasks.ProcessResourceFiles.ReadTextResources(System.String):System.Void", Justification="Further reduction would degrade readability.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.ProcessResourceFiles.ProcessFile(System.String,System.String):System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.ProcessResourceFiles.ResolveAssembly(System.Object,System.ResolveEventArgs):System.Reflection.Assembly", MessageId="System.Reflection.Assembly.LoadFile", Justification="This is by design.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.ProcessResourceFiles.ResolveAssembly(System.Object,System.ResolveEventArgs):System.Reflection.Assembly", MessageId="System.Reflection.Assembly.LoadFrom", Justification="This is intentional.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ProcessResourceFiles..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.InstalledAssemblies..ctor(Microsoft.Build.Tasks.RedistList)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.VCBuild.Projects", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.VCBuild.Projects", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.VCBuild.Execute():System.Boolean", Justification="This exception is rethrown if it's not a known type.")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope="member", Target="Microsoft.Build.Tasks.VCBuild.set_UserEnvironment(System.Boolean):System.Void", MessageId="value", Justification="This method only exists for backward compatibility and will be removed in a future release.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.VCBuild..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.VCBuild.AdditionalLibPaths", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.VCBuild.AdditionalLibPaths", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.VCBuild.get_EnvironmentOverride():System.Collections.Specialized.StringDictionary", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ComReference..cctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AL.SourceModules", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AL.SourceModules", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AL.EmbedResources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AL.EmbedResources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AL.LinkResources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AL.LinkResources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AL.ResponseFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AL.ResponseFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.WriteLinesToFile.Lines", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.WriteLinesToFile.Lines", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.WriteLinesToFile..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.WriteLinesToFile.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1049:TypesThatOwnNativeResourcesShouldBeDisposable", Scope="type", Target="Microsoft.Build.Tasks.NativeMethods+CRYPTOAPI_BLOB", Justification="Allocation/deallocation of these structs is handled elsewhere.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.Tasks.NativeMethods+CRYPTOAPI_BLOB.pbData", Justification="We will do this in Visual Studio 2008. In Whidbey we must still support the Everett runtime.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.RemoveDuplicates.Inputs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.RemoveDuplicates.Inputs", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.RemoveDuplicates.Filtered", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.RemoveDuplicates.Filtered", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.RemoveDuplicates..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.Tasks.Vbc", MessageId="Vbc", Justification="These are named after the compiler tool, so they are spelled correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Vbc.InitializeHostCompiler(Microsoft.Build.Tasks.Hosting.IVbcHostObject):System.Boolean")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.Vbc.InitializeHostCompiler(Microsoft.Build.Tasks.Hosting.IVbcHostObject):System.Boolean")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Vbc..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Vbc.Imports", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Vbc.Imports", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Exec.Outputs", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Exec.Outputs", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Exec..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Scope="member", Target="Microsoft.Build.Tasks.Exec.WorkingDirectory", Justification="GetWorkingDirectory() is an overridden protected method and is reasonably named. The WorkingDirectory property is public and also reasonably named and has different users. In his particular scenario I think these names are the best and won't cause confusion.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Tasks.AssemblyFoldersEx.FindDirectories(Microsoft.Win32.RegistryKey,System.String,System.String,System.String,System.String,System.String,Microsoft.Build.Tasks.GetRegistrySubKeyNames,Microsoft.Build.Tasks.GetRegistrySubKeyDefaultValue):System.Void", Justification="Further reduction would degrade readability.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", Scope="type", Target="Microsoft.Build.Tasks.Delete", Justification="We want to use Delete for the name of the task, as it matches the DOS command and is what users will expect.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Delete.Files", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Delete.Files", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Delete.DeletedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Delete.DeletedFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Delete..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.Delete.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.RemoveDir.RemovedDirectories", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.RemoveDir.RemovedDirectories", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.RemoveDir.RemoveReadOnlyAttributeRecursively(System.IO.DirectoryInfo):System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.RemoveDir.Directories", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.RemoveDir.Directories", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.RemoveDir.RemoveDirectory(Microsoft.Build.Framework.ITaskItem,System.Boolean,System.Boolean&):System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveProjectBase..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", Scope="member", Target="Microsoft.Build.Tasks.ResolveProjectBase.VerifyReferenceAttributes(Microsoft.Build.Framework.ITaskItem,System.String&):System.Boolean", MessageId="System.Guid", Justification="We're creating a Guid object from a string to confirm that the string is a valid GUID. The Guid structure provides no other way of checking this e.g. a TryParse() method. We don't actually need the Guid object for anything.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateTemporaryVCProject.ReferenceGuids", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CreateTemporaryVCProject.ReferenceGuids", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CreateTemporaryVCProject.ReferenceAssemblies", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CreateTemporaryVCProject.ReferenceAssemblies", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.CreateTemporaryVCProject.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.LinkResources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.LinkResources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.AddModules", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.AddModules", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.Sources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.Sources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.set_TargetType(System.String):System.Void", Justification="This string is not being normalized but rather formatted to be used as a command line switch, where it is expected in lowercase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.Resources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.Resources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.ResponseFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.ResponseFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.AdditionalLibPaths", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.AdditionalLibPaths", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.References", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ManagedCompiler.References", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.SystemState..ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.SystemState..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolutionSearchLocation..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.ReadStateFile():System.Void", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.FilesWritten", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.FilesWritten", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.Sources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.Sources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.NeedSeparateAppDomain():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.References", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.References", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.OutputResources", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.GenerateResource.OutputResources", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignCulture.Files", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.AssignCulture.Files", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignCulture.AssignedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AssignCulture..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Touch.Files", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Touch.Files", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Touch.TouchedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Touch.TouchedFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Touch..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Copy.SourceFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Copy.SourceFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Copy.DestinationFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Copy.DestinationFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Copy.CopiedFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.Copy.Execute(Microsoft.Build.Tasks.CopyFile):System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Copy..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AxTlbBaseReference..ctor(Microsoft.Build.Utilities.TaskLoggingHelper,Microsoft.Build.Tasks.IComReferenceResolver,Microsoft.Build.Tasks.ComReferenceInfo,System.String,System.String,System.Boolean,System.String,System.String)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.AxTlbBaseReference.IsWrapperUpToDate(Microsoft.Build.Tasks.ComReferenceWrapperInfo,System.DateTime):System.Boolean", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We need to call Assembly.LoadFrom here, it's by design.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.UnregisterAssembly.Unregister(System.String,System.String):System.Boolean", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We need to call Assembly.LoadFrom here, it's by design.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.UnregisterAssembly.Assemblies", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.UnregisterAssembly.Assemblies", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.UnregisterAssembly..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.StateFileBase.SerializeCache(System.String,Microsoft.Build.Utilities.TaskLoggingHelper):System.Void", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.StateFileBase.DeleteFile(System.String,Microsoft.Build.Utilities.TaskLoggingHelper):System.Void", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.StateFileBase.DeserializeCache(System.String,Microsoft.Build.Utilities.TaskLoggingHelper,System.Type):Microsoft.Build.Tasks.StateFileBase", Justification="We log the exception as a warning, but a problem reading the cache file should never cause building to fail, so we continue.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.SystemState+FileState..ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.SystemState+FileState..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope="type", Target="Microsoft.Build.Tasks.Csc", MessageId="Csc", Justification="These are named after the compiler tool, so they are spelled correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Csc..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Csc.InitializeHostCompiler(Microsoft.Build.Tasks.Hosting.ICscHostObject):System.Boolean")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.Csc.InitializeHostCompiler(Microsoft.Build.Tasks.Hosting.ICscHostObject):System.Boolean")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.Reference..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath.Files", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath.Files", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath.OutOfPath", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath.OutOfPath", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath.InPath", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath.InPath", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.FindUnderPath.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", Scope="type", Target="Microsoft.Build.Tasks.Error", Justification="This maps to an XML element name, so we need to use the name Error.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.DependencyFile..ctor(System.String)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", Scope="member", Target="Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService.GetAssemblyByPath(System.String,System.Boolean):System.Reflection.Assembly", MessageId="System.Reflection.Assembly.LoadFrom", Justification="We need to call Assembly.LoadFrom in AssemblyNamesTypeResolutionService.GetAssemblyByPath to locate the assembly on disk.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.ReadLinesFromFile.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ReadLinesFromFile..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ReadLinesFromFile.Lines", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ReadLinesFromFile.Lines", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Design", "CA1049:TypesThatOwnNativeResourcesShouldBeDisposable", Scope="type", Target="Microsoft.Build.Tasks.ASSEMBLYMETADATA", Justification="Allocation/deallocation of these structs is handled elsewhere.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.Tasks.ASSEMBLYMETADATA.rpLocale", Justification="These pointers are incidental members of structures that aren't used.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.Tasks.ASSEMBLYMETADATA.rOses", Justification="These pointers are incidental members of structures that aren't used.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.Tasks.ASSEMBLYMETADATA.rpProcessors", Justification="These pointers are incidental members of structures that aren't used.")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2006:UseSafeHandleToEncapsulateNativeResources", Scope="member", Target="Microsoft.Build.Tasks.NativeMethods.InvalidIntPtr", Justification="We will do this in Visual Studio 2008. In Whidbey we must still support the Everett runtime.")]
-[module: SuppressMessage("Microsoft.Interoperability", "CA1400:PInvokeEntryPointsShouldExist", Scope="member", Target="Microsoft.Build.Tasks.NativeMethods.CompareAssemblyIdentity(System.String,System.Boolean,System.String,System.Boolean,System.Boolean&,Microsoft.Build.Tasks.NativeMethods+AssemblyComparisonResult&):System.Int32", Justification="This method CompareAssemblyIdentity does exist, in fusion.dll.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CallTarget.Targets", Justification="msbuild task model necessitates this.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.CallTarget.Targets", Justification="msbuild task model necessitates this.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.CallTarget..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.CallTarget.TargetOutputs", Justification="msbuild task model necessitates this.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.MakeDir.Directories", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.MakeDir.Directories", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.MakeDir.DirectoriesCreated", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope="member", Target="Microsoft.Build.Tasks.MakeDir.Execute():System.Boolean", Justification="A helper method rethrows non-IO exceptions, but FXCop cannot detect that.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AppConfigException..ctor(System.String,System.String,System.Int32,System.Int32,System.Exception)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths", Justification="All MSBuild tasks accept input and output item arrays this way. This is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies", Justification="All MSBuild tasks accept input and output item arrays this way. This is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries", Justification="The MSBuild task model requires that we have read/write properties that are collections/arrays. Arrays are the only way to have strongly typed collections that build on Everett, and properties are used to map to XML attributes in the file format.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries", Justification="All MSBuild tasks accept and output item arrays this way, this is by design. Tasks are only called by the MSBuild engine, which will access them correctly.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Tasks.ResolveNativeReference.ExtractFromManifest(Microsoft.Build.Framework.ITaskItem,System.String,System.Collections.Hashtable,System.Collections.Hashtable,System.Collections.Hashtable,System.Collections.Hashtable,System.Collections.Hashtable,System.Collections.Hashtable):System.Boolean", Justification="Complexity is only 26 (cutoff is 25), and further reductions would degrade readability.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.TlbReference..ctor(Microsoft.Build.Utilities.TaskLoggingHelper,Microsoft.Build.Tasks.IComReferenceResolver,Microsoft.Build.Tasks.ComReferenceInfo,System.String,System.String,System.Boolean,System.Boolean,System.String,System.String,System.Boolean)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.AssemblyRegistrationCache..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.StreamMappedString..ctor(System.IO.Stream,System.Boolean,System.Int32)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.CSharpTokenEnumerator.FindNextToken():System.Boolean", Justification="Reduced complexity from 170+ to less than 40 - further reductions would make the code less readable.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.CSharpTokenEnumerator..ctor(System.IO.Stream,System.Boolean)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.TokenEnumerator..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.VisualBasicTokenEnumerator.FindNextToken():System.Boolean", Justification="Reduced complexity from 170+ to less than 40 - further reductions would make the code less readable.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.VisualBasicTokenEnumerator..ctor(System.IO.Stream,System.Boolean)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.VisualBasicTokenizer..ctor(System.IO.Stream,System.Boolean)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.Token..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.LanguageParser.CSharpTokenizer..ctor(System.IO.Stream,System.Boolean)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.FileMatcher+Result..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Scope="member", Target="NativeMethodsShared.GetCurrentDirectory(System.Int32,System.Text.StringBuilder):System.Int32", Justification="For performance reasons use unmanagedWin32 API. The managed one does extra security checks")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension..ctor(System.Reflection.AssemblyName)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension..ctor(System.String)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension..ctor(System.String,System.Boolean)", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Shared.AssemblyNameExtension..ctor()", Justification="We've chosen to retain these initializations because they improve the readability of the codebase.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.IsItemSpecModifier(System.String):System.Boolean", Justification="Further reduction would degrade readability.")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.GetItemSpecModifier(System.String,System.String,System.String,System.Collections.Hashtable&):System.String", Justification="was excluded before.")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="Metabase", Justification="These are correct spellings")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="bootstrapper", Justification="These are correct spellings")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="redist", Justification="These are correct spellings")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="aximp", Justification="These are correct spellings")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="tlbimp", Justification="These are correct spellings")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", MessageId="Resx", Justification="These are correct spellings")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateApplicationManifest.#ErrorReportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.GenerateDeploymentManifest.#ErrorReportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Naming","CA1711:IdentifiersShouldNotHaveIncorrectSuffix", Scope="type", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection", Justification="These are public properties on public interfaces, these cannot have their name changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Naming","CA1711:IdentifiersShouldNotHaveIncorrectSuffix", Scope="type", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection", Justification="These are public properties on public interfaces, these cannot have their name changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#ErrorReportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1008:EnumsShouldHaveZeroValue", Scope="type", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity+FullNameFlags", Justification="These are public properties on public tasks, these cannot have their values changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1034:NestedTypesShouldNotBeVisible", Scope="type", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity+FullNameFlags", Justification="These are public properties on public class, these cannot have their location changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#XmlErrorReportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Naming","CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId="ClsId", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.#ClsId", Justification="These are public properties on public class, these cannot have their name changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Naming","CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId="ClsId", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.#XmlClsId", Justification="These are public properties on public class, these cannot have their name changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#ErrorReportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#XmlErrorReportUrl", Justification="These are public properties on public tasks, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Design","CA1059:MembersShouldNotExposeCertainConcreteTypes", MessageId="System.Xml.XmlNode", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.#XmlToPermissionSet(System.Xml.XmlElement)", Justification="These are public functions on public classes, these cannot have their parameter changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Naming","CA1721:PropertyNamesShouldNotMatchGetMethods", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.#Type", Justification="hese are public properties on public class, these cannot have their type changed due to backwards compatibility")]
-[module: SuppressMessage("Microsoft.Performance","CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#XmlFileAssociations", Justification="Released API")]
-[module: SuppressMessage("Microsoft.Performance","CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.#XmlCompatibleFrameworks", Justification="Released API")]
-[module: SuppressMessage("Microsoft.Globalization","CA1307:SpecifyStringComparison", MessageId="System.String.CompareTo(System.String)", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest+ReferenceComparer.#Compare(System.Object,System.Object)", Justification="this is an overloaded Compare method.")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Build.Tasks.Deployment.ManifestUtilities.NativeMethods.EnumResourceNames(System.IntPtr,System.IntPtr,Microsoft.Build.Tasks.Deployment.ManifestUtilities.NativeMethods+EnumResNameProc,System.IntPtr)", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.EmbeddedManifestReader.#.ctor(System.String)")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.#Deserialize(System.String)")]
-[module: SuppressMessage("Microsoft.Usage","CA2208:InstantiateArgumentExceptionsCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.#set_PermissionSet(System.Security.PermissionSet)")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="System.Globalization.CultureInfo", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.Util.#IsValidCulture(System.String)")]
-[module: SuppressMessage("Microsoft.Usage","CA1816:CallGCSuppressFinalizeCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.MetadataReader.#System.IDisposable.Dispose()")]
-[module: SuppressMessage("Microsoft.Usage","CA1816:CallGCSuppressFinalizeCorrectly", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.MetadataReader.#System.IDisposable.Dispose()")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="System.IO.StreamReader", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.#GetXmlElement(System.String,Microsoft.Build.Utilities.FrameworkName)")]
-[module: SuppressMessage("Microsoft.Naming","CA1721:PropertyNamesShouldNotMatchGetMethods", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.#Type")]
-[module: SuppressMessage("Microsoft.Globalization","CA1307:SpecifyStringComparison", MessageId="System.String.CompareTo(System.String)", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder+GraphNodeNameComparer.#Compare(System.Object,System.Object)")]
-[module: SuppressMessage("Microsoft.Globalization","CA1307:SpecifyStringComparison", MessageId="System.String.CompareTo(System.String)", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.#GetOutputFolders(System.String[],System.String,System.String,Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation)")]
-[module: SuppressMessage("Microsoft.Naming", "CA1718:AvoidLanguageSpecificTypeNamesInParameters", Scope = "member", Target = "Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(System.Boolean):System.Boolean", MessageId = "0#")]
-[module: SuppressMessage("Microsoft.Naming", "CA1720:AvoidTypeNamesInParameters", Scope = "member", Target = "Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(System.Boolean):System.Boolean", MessageId = "0#")]
-[module: SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", Scope = "member", Target = "Microsoft.Build.Tasks.GetFrameworkSdkPath.set_Path(System.String):System.Void", MessageId = "value")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope = "member", Target = "Microsoft.Build.Tasks.ProcessResourceFiles.ReadResources(System.String,System.Boolean):System.Void")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope = "member", Target = "Microsoft.Build.Tasks.ProcessResourceFiles.WriteResources(System.String):System.Void")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope = "member", Target = "Microsoft.Build.Tasks.ProcessResourceFiles.WriteTextResources(System.String):System.Void")]
-[module: SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Scope = "member", Target = "Microsoft.Build.Tasks.Exec.CreateTemporaryBatchFile():System.Void")]
-[module: SuppressMessage("Microsoft.Performance", "CA1807:AvoidUnnecessaryStringCreation", Scope = "member", Target = "Microsoft.Build.Tasks.ManagedCompiler.set_TargetType(System.String):System.Void", MessageId = "value")]
-[module: SuppressMessage("Microsoft.Performance", "CA1807:AvoidUnnecessaryStringCreation", Scope = "member", Target = "Microsoft.Build.Tasks.ManagedCompiler.set_TargetType(System.String):System.Void", MessageId = "stack2")]
-[module: SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Scope = "member", Target = "Microsoft.Build.Tasks.ManagedCompiler.set_TargetType(System.String):System.Void")]
-[module: SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Scope = "member", Target = "Microsoft.Build.Shared.FileUtilities.GetItemSpecModifier(System.String,System.String,System.String,System.Collections.Generic.Dictionary`2<System.String,System.String>&):System.String")]
-[module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope = "resource", Target = "Microsoft.Build.Tasks.Strings.resources", MessageId = "progid")]
-[module: SuppressMessage("Microsoft.Performance","CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.#TaskItemArray")]
-[module: SuppressMessage("Microsoft.Naming","CA1721:PropertyNamesShouldNotMatchGetMethods", Scope="member", Target="Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.#Type")]
-[module: SuppressMessage("Microsoft.Globalization","CA2101:SpecifyMarshalingForPInvokeStringArguments", MessageId="4", Scope="member", Target="Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask+XamlTaskNativeMethods.#SearchPath(System.String,System.String,System.String,System.Int32,System.Text.StringBuilder,System.IntPtr&)")]
-[module: SuppressMessage("Microsoft.Performance","CA1819:PropertiesShouldNotReturnArrays", Scope="member", Target="Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.#StringList")]
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.#ErrorReportUrl")]
-[module: SuppressMessage("Microsoft.Performance","CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Utilities.CanonicalError+Parts.#.ctor()", Justification="clearer this way")]
-[module: SuppressMessage("Microsoft.Performance","CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Runtime.Hosting.StrongNameHelpers.#.cctor()", Justification="we don't own this code")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Runtime.Hosting.IClrStrongNameUsingIntPtr.StrongNameFreeBuffer(System.IntPtr)", Scope="member", Target="Microsoft.Runtime.Hosting.StrongNameHelpers.#StrongNameFreeBuffer(System.IntPtr)", Justification="we don't own this code")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="Assemblyfolders", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", Justification="it is correctly spelled")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Vbc", Scope="type", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject3", Justification="it is correctly spelled")]
-[module: SuppressMessage("Microsoft.Usage","CA1801:ReviewUnusedParameters", MessageId="getRuntimeVersion", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.#SetTargetedRuntimeVersion(Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="used by tests")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.#Execute(Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Tasks.GetDirectories,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyMetadata,Microsoft.Build.Tasks.GetRegistrySubKeyNames,Microsoft.Build.Tasks.GetRegistrySubKeyDefaultValue,Microsoft.Build.Tasks.GetLastWriteTime,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="Not going to rewrite it now")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1506:AvoidExcessiveClassCoupling", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.#Execute(Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Tasks.GetDirectories,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyMetadata,Microsoft.Build.Tasks.GetRegistrySubKeyNames,Microsoft.Build.Tasks.GetRegistrySubKeyDefaultValue,Microsoft.Build.Tasks.GetLastWriteTime,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="Not going to rewrite it now")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1500:VariableNamesShouldNotMatchFieldNames", MessageId="getAssemblyRuntimeVersion", Scope="member", Target="Microsoft.Build.Tasks.SystemState.#CacheDelegate(Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="clearer")]
-[module: SuppressMessage("Microsoft.Globalization","CA1309:UseOrdinalStringComparison", MessageId="System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)", Scope="member", Target="Microsoft.Build.Tasks.StronglyTypedResourceBuilder.#VerifyResourceNames(System.Collections.Generic.Dictionary`2<System.String,Microsoft.Build.Tasks.StronglyTypedResourceBuilder+ResourceData>,System.CodeDom.Compiler.CodeDomProvider,System.Collections.ArrayList,System.Collections.Hashtable&)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Globalization","CA1309:UseOrdinalStringComparison", MessageId="System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)", Scope="member", Target="Microsoft.Build.Tasks.StronglyTypedResourceBuilder.#VerifyResourceNames(System.Collections.Generic.Dictionary`2<System.String,Microsoft.Build.Tasks.StronglyTypedResourceBuilder+ResourceData>,System.CodeDom.Compiler.CodeDomProvider,System.Collections.ArrayList,System.Collections.Hashtable&)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1506:AvoidExcessiveClassCoupling", Scope="member", Target="Microsoft.Build.Tasks.StronglyTypedResourceBuilder.#InternalCreate(System.Collections.Generic.Dictionary`2<System.String,Microsoft.Build.Tasks.StronglyTypedResourceBuilder+ResourceData>,System.String,System.String,System.String,System.CodeDom.Compiler.CodeDomProvider,System.Boolean,System.String[]&)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Usage","CA1801:ReviewUnusedParameters", MessageId="supportsTryCatch", Scope="member", Target="Microsoft.Build.Tasks.StronglyTypedResourceBuilder.#EmitBasicClassMembers(System.CodeDom.CodeTypeDeclaration,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1506:AvoidExcessiveClassCoupling", Scope="member", Target="Microsoft.Build.Tasks.StronglyTypedResourceBuilder.#EmitBasicClassMembers(System.CodeDom.CodeTypeDeclaration,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Globalization","CA1309:UseOrdinalStringComparison", MessageId="System.Collections.Generic.Dictionary`2<System.String,Microsoft.Build.Tasks.StronglyTypedResourceBuilder+ResourceData>.#ctor(System.Collections.Generic.IEqualityComparer`1<System.String>)", Scope="member", Target="Microsoft.Build.Tasks.StronglyTypedResourceBuilder.#Create(System.String,System.String,System.String,System.String,System.CodeDom.Compiler.CodeDomProvider,System.Boolean,System.String[]&)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Globalization","CA1309:UseOrdinalStringComparison", MessageId="System.Collections.Generic.Dictionary`2<System.String,Microsoft.Build.Tasks.StronglyTypedResourceBuilder+ResourceData>.#ctor(System.Collections.Generic.IEqualityComparer`1<System.String>)", Scope="member", Target="Microsoft.Build.Tasks.StronglyTypedResourceBuilder.#Create(System.Collections.IDictionary,System.String,System.String,System.String,System.CodeDom.Compiler.CodeDomProvider,System.Boolean,System.String[]&)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Performance","CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.SRDescriptionAttribute.#.ctor(System.String)", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Performance","CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Tasks.SR.#.cctor()", Justification="Inherited code don't want to change it")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="resx", Scope="resource", Target="System.Design.resources", Justification="This is correct")]
-
-[module: SuppressMessage("Microsoft.Design","CA1056:UriPropertiesShouldNotBeStrings", Scope="member", Target="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.#ErrorReportUrl")]
-[module: SuppressMessage("Microsoft.Performance","CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Build.Utilities.CanonicalError+Parts.#.ctor()", Justification="clearer this way")]
-[module: SuppressMessage("Microsoft.Performance","CA1805:DoNotInitializeUnnecessarily", Scope="member", Target="Microsoft.Runtime.Hosting.StrongNameHelpers.#.cctor()", Justification="we don't own this code")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Runtime.Hosting.IClrStrongNameUsingIntPtr.StrongNameFreeBuffer(System.IntPtr)", Scope="member", Target="Microsoft.Runtime.Hosting.StrongNameHelpers.#StrongNameFreeBuffer(System.IntPtr)", Justification="we don't own this code")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="Assemblyfolders", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", Justification="it is correctly spelled")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Vbc", Scope="type", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject3", Justification="it is correctly spelled")]
-[module: SuppressMessage("Microsoft.Usage","CA1801:ReviewUnusedParameters", MessageId="getRuntimeVersion", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.#SetTargetedRuntimeVersion(Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="used by tests")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1502:AvoidExcessiveComplexity", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.#Execute(Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Tasks.GetDirectories,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyMetadata,Microsoft.Build.Tasks.GetRegistrySubKeyNames,Microsoft.Build.Tasks.GetRegistrySubKeyDefaultValue,Microsoft.Build.Tasks.GetLastWriteTime,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="Not going to rewrite it now")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1506:AvoidExcessiveClassCoupling", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.#Execute(Microsoft.Build.Shared.FileExists,Microsoft.Build.Shared.DirectoryExists,Microsoft.Build.Tasks.GetDirectories,Microsoft.Build.Tasks.GetAssemblyName,Microsoft.Build.Tasks.GetAssemblyMetadata,Microsoft.Build.Tasks.GetRegistrySubKeyNames,Microsoft.Build.Tasks.GetRegistrySubKeyDefaultValue,Microsoft.Build.Tasks.GetLastWriteTime,Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="Not going to rewrite it now")]
-[module: SuppressMessage("Microsoft.Maintainability","CA1500:VariableNamesShouldNotMatchFieldNames", MessageId="getAssemblyRuntimeVersion", Scope="member", Target="Microsoft.Build.Tasks.SystemState.#CacheDelegate(Microsoft.Build.Tasks.GetAssemblyRuntimeVersion)", Justification="clearer")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="sn", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", Justification="sn.exe is the name of a program")]
-
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.FileUtilities.#NormalizePath(System.String,System.String)", Justification="This is a shared class that this assembly doesn't use all the methods in.")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="foo", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", Justification="Used as an example")]
-[module: SuppressMessage("Microsoft.Globalization","CA2101:SpecifyMarshalingForPInvokeStringArguments", MessageId="1", Scope="member", Target="System.Deployment.Internal.CodeSigning.Win32.#CertTimestampAuthenticodeLicense(System.Deployment.Internal.CodeSigning.Win32+CRYPT_DATA_BLOB&,System.String,System.Deployment.Internal.CodeSigning.Win32+CRYPT_DATA_BLOB&)", Justification="Not code owned by us")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="System.Deployment.Internal.CodeSigning.Win32.CertFreeAuthenticodeTimestamperInfo(System.Deployment.Internal.CodeSigning.Win32+AXL_TIMESTAMPER_INFO@)", Scope="member", Target="System.Deployment.Internal.CodeSigning.SignedCmiManifest.#VerifyLicense(System.Deployment.Internal.CodeSigning.CmiManifestVerifyFlags,System.Boolean)", Justification="Not code owned by us")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="System.Deployment.Internal.CodeSigning.Win32.CertFreeAuthenticodeSignerInfo(System.Deployment.Internal.CodeSigning.Win32+AXL_SIGNER_INFO@)", Scope="member", Target="System.Deployment.Internal.CodeSigning.SignedCmiManifest.#VerifyLicense(System.Deployment.Internal.CodeSigning.CmiManifestVerifyFlags,System.Boolean)", Justification="Not code owned by us")]
-[module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="System.Deployment.Internal.CodeSigning.ManifestSignedXml.#FindIdElement(System.Xml.XmlElement,System.String)", Justification="Not code owned by us")]
-[module: SuppressMessage("Microsoft.Usage","CA2208:InstantiateArgumentExceptionsCorrectly", Scope="member", Target="System.Deployment.Internal.CodeSigning.CmiManifestSigner.#set_IncludeOption(System.Security.Cryptography.X509Certificates.X509IncludeOption)", Justification="Not code owned by us")]
-[module: SuppressMessage("Microsoft.Usage","CA2208:InstantiateArgumentExceptionsCorrectly", Scope="member", Target="System.Deployment.Internal.CodeSigning.CmiManifestSigner.#set_Flag(System.Deployment.Internal.CodeSigning.CmiManifestSignerFlag)", Justification="Not code owned by us")]
-[module: SuppressMessage("Microsoft.Globalization","CA1309:UseOrdinalStringComparison", MessageId="System.String.Compare(System.String,System.String,System.StringComparison)", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.#BuildPackages(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings,System.Xml.XmlElement,Microsoft.Build.Tasks.Deployment.Bootstrapper.ResourceUpdater,System.Collections.ArrayList,System.Collections.Hashtable)", Justification="vbcodev will look at these later")]
-[module: SuppressMessage("Microsoft.Globalization","CA1305:SpecifyIFormatProvider", MessageId="System.String.Format(System.String,System.Object,System.Object)", Scope="member", Target="Microsoft.Build.Tasks.Deployment.Bootstrapper.ResourceUpdater.#UpdateResources(System.String,Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults)", Justification="vbcodev will look at these later")]
-[module: SuppressMessage("Microsoft.Globalization","CA1305:SpecifyIFormatProvider", MessageId="System.Int32.ToString(System.IFormatProvider)", Scope="member", Target="Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.#ValidateFileAssociations()", Justification="vbcodev will look at these later")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="System.Boolean.TryParse(System.String,System.Boolean@)", Scope="member", Target="Microsoft.Build.Tasks.GenerateManifestBase.#IsEmbedInteropEnabledForAssembly(Microsoft.Build.Framework.ITaskItem)", Justification="vbcodev will look at these later")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Csc", Scope="type", Target="Microsoft.Build.Tasks.Hosting.ICscHostObject3", Justification="csc is the name of the tool and spelled correctly")]
-
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.GetSDKReferenceFiles.#ResolvedSDKReferences", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="type", Target="Microsoft.Build.Tasks.GetSDKReferenceFiles", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.GetInstalledSDKLocations.#SDKRegistryRoot", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.GetInstalledSDKLocations.#SDKDirectoryRoot", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDKs", Scope="member", Target="Microsoft.Build.Tasks.GetInstalledSDKLocations.#InstalledSDKs", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="type", Target="Microsoft.Build.Tasks.GetInstalledSDKLocations", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.ResolveAssemblyReference.#ResolvedSDKReferences", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="type", Target="Microsoft.Build.Tasks.ResolveSDKReference", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDKs", Scope="member", Target="Microsoft.Build.Tasks.ResolveSDKReference.#InstalledSDKs", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.ResolveSDKReference.#ResolvedSDKReferences", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.ResolveSDKReference.#SDKReferences", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.ResolveSDKReference.#TargetedSDKArchitecture", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Tasks.ResolveSDKReference.#TargetedSDKConfiguration", Justification="SDK is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="PDB", Scope="member", Target="Microsoft.Build.Tasks.WinMDExp.#InputPDBFile", Justification="PDB is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="PDB", Scope="member", Target="Microsoft.Build.Tasks.WinMDExp.#OutputPDBFile", Justification="PDB is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="System.Boolean.TryParse(System.String,System.Boolean@)", Scope="member", Target="Microsoft.Build.Tasks.GetSDKReferenceFiles+ResolvedReferenceAssembly.#.ctor(Microsoft.Build.Framework.ITaskItem,System.String)", Justification="copyLocal is false by default")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="VB", Scope="member", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject4.#SetVBRuntime(System.String)", Justification="VB is the proper casing for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Vbc", Scope="type", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject4", Justification="Vbc spelling is correct for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Vbc", Scope="type", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObject5", Justification="Vbc spelling is correct for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Vbc", Scope="type", Target="Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded", Justification="Vbc spelling is correct for this")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="appx", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", Justification="APPX spelling is correct")]
-[module: SuppressMessage("Microsoft.Usage","CA2227:CollectionPropertiesShouldBeReadOnly", Scope="member", Target="Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.#Arguments", Justification="It is ok for users to set the ICollection.")]
-[module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="fwlink", Scope="resource", Target="Microsoft.Build.Tasks.Strings.resources", Justification="fwlink is part of a valid domain")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Csc", Scope="type", Target="Microsoft.Build.Tasks.Hosting.ICscHostObject4", Justification="Not worh breaking customers")]
-#endif
-
-
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 26967ca64e7..a5f9c7646b3 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -3956,9 +3956,6 @@ internal sealed class TextFileException : Exception
             private int lineNumber;
             private int column;
 
-            /// <summary>
-            /// Fxcop want to have the correct basic exception constructors implemented
-            /// </summary>
             private TextFileException(SerializationInfo info, StreamingContext context)
                 : base(info, context)
             {
@@ -4146,7 +4143,7 @@ public Type GetType(string name, bool throwOnError, bool ignoreCase)
 
                 if (result == null && throwOnError)
                 {
-                    ErrorUtilities.VerifyThrowArgument(false, "GenerateResource.CouldNotLoadType", name);
+                    ErrorUtilities.ThrowArgument("GenerateResource.CouldNotLoadType", name);
                 }
 
                 _cachedTypes[name] = result;
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d8f81bf9926..19b5dde493f 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -33,8 +33,8 @@
     <Compile Include="..\Shared\ITranslator.cs" />
     <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
-    <Compile Include="..\Shared\TranslatorHelpers.cs" />    
-  </ItemGroup> 
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />
+  </ItemGroup>
   <ItemGroup>
     <!-- Source Files -->
     <Compile Include="..\Shared\EnvironmentUtilities.cs">
@@ -55,9 +55,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\AssemblyNameComparer.cs">
       <Link>AssemblyNameComparer.cs</Link>
     </Compile>
@@ -82,12 +79,6 @@
       <Link>FileDelegates.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\NGen.cs">
       <Link>NGen.cs</Link>
     </Compile>
@@ -152,9 +143,6 @@
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\Tracing.cs" />
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>SharedTraits.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\VersionUtilities.cs">
       <Link>VersionUtilities.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -162,9 +150,6 @@
     <Compile Include="..\Shared\VisualStudioConstants.cs">
       <Link>VisualStudioConstants.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -180,8 +165,6 @@
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-    </Compile>
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -412,9 +395,6 @@
     <Compile Include="FormatVersion.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="FxCopExclusions\Microsoft.Build.Tasks.Suppressions.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -969,7 +949,7 @@
   <!-- ==========================================================================================-->
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <PackageReference Include="System.Net.Http" />
-    
+
     <Reference Include="System" />
     <Reference Include="System.Core" />
     <Reference Include="System.IO.Compression" />
@@ -989,6 +969,8 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
@@ -1017,7 +999,7 @@
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
     <PackageReference Include="Microsoft.Win32.Registry" />
 
-    <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcoreapp3.1\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
+    <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net6.0\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(MonoBuild)' == 'true'">
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index ab2342d58e4..a8f5ca7fe04 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -575,33 +575,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <TargetPlatformRegistryBase Condition="'$(TargetPlatformRegistryBase)' == ''">Software\Microsoft\Microsoft SDKs\$(TargetPlatformIdentifier)</TargetPlatformRegistryBase>
     <AssemblyFoldersConfigFile Condition="'$(AssemblyFoldersConfigFile)' == ''">$([MSBuild]::GetToolsDirectory32())\AssemblyFolders.config</AssemblyFoldersConfigFile>
     <AssemblyFoldersConfigFileSearchPath Condition="Exists('$(AssemblyFoldersConfigFile)')">{AssemblyFoldersFromConfig:$(AssemblyFoldersConfigFile),$(TargetFrameworkVersion)};</AssemblyFoldersConfigFileSearchPath>
-    <!--
-        The SearchPaths property is set to find assemblies in the following order:
-
-            (1) Files from current project - indicated by {CandidateAssemblyFiles}
-            (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
-            (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
-            (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
-                The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
-            (5) Registered assembly folders, indicated by {Registry:*,*,*}
-            (6) Assembly folders from AssemblyFolders.config file (provided by Visual Studio Dev15+).
-            (7) Legacy registered assembly folders, indicated by {AssemblyFolders}
-            (8) Resolve to the GAC.
-            (9) Treat the reference's Include as if it were a real file name.
-            (10) Look in the application's output folder (like bin\debug)
-        -->
-    <AssemblySearchPaths Condition=" '$(AssemblySearchPaths)' == ''">
-      {CandidateAssemblyFiles};
-      $(ReferencePath);
-      {HintPathFromItem};
-      {TargetFrameworkDirectory};
-      $(AssemblyFoldersConfigFileSearchPath)
-      {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
-      {AssemblyFolders};
-      {GAC};
-      {RawFileName};
-      $(OutDir)
-    </AssemblySearchPaths>
 
     <!--
         These are the extensions that assembly reference resolution will consider for resolution.
@@ -634,6 +607,34 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <FullReferenceAssemblyNames Condition="'$(FullReferenceAssemblyNames)' == ''">Full</FullReferenceAssemblyNames>
   </PropertyGroup>
 
+  <PropertyGroup Condition="$(AssemblySearchPaths) == ''">
+    <!--
+        The SearchPaths property is set to find assemblies in the following order:
+
+            (1) Files from current project - indicated by {CandidateAssemblyFiles}
+            (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
+            (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
+            (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
+                The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
+            (5) Assembly folders from AssemblyFolders.config file (provided by Visual Studio Dev15+).
+            (6) Registered assembly folders, indicated by {Registry:*,*,*}
+            (7) Legacy registered assembly folders, indicated by {AssemblyFolders}
+            (8) Resolve to the GAC.
+            (9) Treat the reference's Include as if it were a real file name.
+            (10) Look in the application's output folder (like bin\debug)
+        -->
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseCandidateAssemblyFiles) != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseReferencePath) != 'false'">$(AssemblySearchPaths);$(ReferencePath)</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseHintPathFromItem) != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseTargetFrameworkDirectory) != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseAssemblyFoldersConfigFileSearchPath) != 'false'">$(AssemblySearchPaths);$(AssemblyFoldersConfigFileSearchPath)</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseRegistry) != 'false'">$(AssemblySearchPaths);{Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseAssemblyFolders) != 'false'">$(AssemblySearchPaths);{AssemblyFolders}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseGAC) != 'false'">$(AssemblySearchPaths);{GAC}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseRawFileName) != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="$(AssemblySearchPathUseOutDir) != 'false'">$(AssemblySearchPaths);$(OutDir)</AssemblySearchPaths>
+  </PropertyGroup>
+
   <!-- ContinueOnError takes 3 values:  WarnAndContinue (true), ErrorAndStop (false), and ErrorAndContinue.
          Default to ErrorAndStop, since that matches the behaviour in previous versions, and what users
          typically expect -->
@@ -1930,13 +1931,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
                                     GetTargetFrameworkProperties
 
-    Overrridden by cross-targeting projects to return the set of
-    properties (in the form "key1=value1;...keyN=valueN") needed
-    to build it with the best target for the referring project's
-    target framework.
-
-    The referring project's $(TargetFrameworkMoniker) is passed
-    in as $(ReferringTargetFramework)
+    OBSOLETE: present only for theoretical backward compatibility.
   -->
   <Target Name="GetTargetFrameworkProperties" />
 
@@ -4832,10 +4827,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          not be considered up to date, so touch this marker file that is considered an
          input to projects that reference this one. -->
     <Touch Files="@(CopyUpToDateMarker)"
-           AlwaysCreate="true"
-           Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'">
-        <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
-    </Touch>
+      AlwaysCreate="true"
+      Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'" />
+
+    <ItemGroup>
+      <FileWrites Include="@(CopyUpToDateMarker)" />
+    </ItemGroup>
 
   </Target>
 
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index f6b98da83af..f909cc1afe2 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -122,8 +122,9 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="NET" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''  and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -141,8 +142,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -164,8 +165,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..85f6da6f74e
--- /dev/null
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
@@ -0,0 +1,2422 @@
+abstract Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream) -> string
+abstract Microsoft.Build.Tasks.CreateManifestResourceName.IsSourceFile(string fileName) -> bool
+abstract Microsoft.Build.Tasks.CreateManifestResourceName.SourceFileExtension.get -> string
+abstract Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SortName.get -> string
+abstract Microsoft.Build.Tasks.GenerateManifestBase.GetObjectType() -> System.Type
+abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
+abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
+Microsoft.Build.Tasks.AL
+Microsoft.Build.Tasks.AL.AL() -> void
+Microsoft.Build.Tasks.AL.AlgorithmId.get -> string
+Microsoft.Build.Tasks.AL.AlgorithmId.set -> void
+Microsoft.Build.Tasks.AL.BaseAddress.get -> string
+Microsoft.Build.Tasks.AL.BaseAddress.set -> void
+Microsoft.Build.Tasks.AL.CompanyName.get -> string
+Microsoft.Build.Tasks.AL.CompanyName.set -> void
+Microsoft.Build.Tasks.AL.Configuration.get -> string
+Microsoft.Build.Tasks.AL.Configuration.set -> void
+Microsoft.Build.Tasks.AL.Copyright.get -> string
+Microsoft.Build.Tasks.AL.Copyright.set -> void
+Microsoft.Build.Tasks.AL.Culture.get -> string
+Microsoft.Build.Tasks.AL.Culture.set -> void
+Microsoft.Build.Tasks.AL.DelaySign.get -> bool
+Microsoft.Build.Tasks.AL.DelaySign.set -> void
+Microsoft.Build.Tasks.AL.Description.get -> string
+Microsoft.Build.Tasks.AL.Description.set -> void
+Microsoft.Build.Tasks.AL.EmbedResources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AL.EmbedResources.set -> void
+Microsoft.Build.Tasks.AL.EvidenceFile.get -> string
+Microsoft.Build.Tasks.AL.EvidenceFile.set -> void
+Microsoft.Build.Tasks.AL.FileVersion.get -> string
+Microsoft.Build.Tasks.AL.FileVersion.set -> void
+Microsoft.Build.Tasks.AL.Flags.get -> string
+Microsoft.Build.Tasks.AL.Flags.set -> void
+Microsoft.Build.Tasks.AL.GenerateFullPaths.get -> bool
+Microsoft.Build.Tasks.AL.GenerateFullPaths.set -> void
+Microsoft.Build.Tasks.AL.KeyContainer.get -> string
+Microsoft.Build.Tasks.AL.KeyContainer.set -> void
+Microsoft.Build.Tasks.AL.KeyFile.get -> string
+Microsoft.Build.Tasks.AL.KeyFile.set -> void
+Microsoft.Build.Tasks.AL.LinkResources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AL.LinkResources.set -> void
+Microsoft.Build.Tasks.AL.MainEntryPoint.get -> string
+Microsoft.Build.Tasks.AL.MainEntryPoint.set -> void
+Microsoft.Build.Tasks.AL.OutputAssembly.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.AL.OutputAssembly.set -> void
+Microsoft.Build.Tasks.AL.Platform.get -> string
+Microsoft.Build.Tasks.AL.Platform.set -> void
+Microsoft.Build.Tasks.AL.Prefer32Bit.get -> bool
+Microsoft.Build.Tasks.AL.Prefer32Bit.set -> void
+Microsoft.Build.Tasks.AL.ProductName.get -> string
+Microsoft.Build.Tasks.AL.ProductName.set -> void
+Microsoft.Build.Tasks.AL.ProductVersion.get -> string
+Microsoft.Build.Tasks.AL.ProductVersion.set -> void
+Microsoft.Build.Tasks.AL.ResponseFiles.get -> string[]
+Microsoft.Build.Tasks.AL.ResponseFiles.set -> void
+Microsoft.Build.Tasks.AL.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.AL.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.AL.SourceModules.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AL.SourceModules.set -> void
+Microsoft.Build.Tasks.AL.TargetType.get -> string
+Microsoft.Build.Tasks.AL.TargetType.set -> void
+Microsoft.Build.Tasks.AL.TemplateFile.get -> string
+Microsoft.Build.Tasks.AL.TemplateFile.set -> void
+Microsoft.Build.Tasks.AL.Title.get -> string
+Microsoft.Build.Tasks.AL.Title.set -> void
+Microsoft.Build.Tasks.AL.Trademark.get -> string
+Microsoft.Build.Tasks.AL.Trademark.set -> void
+Microsoft.Build.Tasks.AL.Version.get -> string
+Microsoft.Build.Tasks.AL.Version.set -> void
+Microsoft.Build.Tasks.AL.Win32Icon.get -> string
+Microsoft.Build.Tasks.AL.Win32Icon.set -> void
+Microsoft.Build.Tasks.AL.Win32Resource.get -> string
+Microsoft.Build.Tasks.AL.Win32Resource.set -> void
+Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension
+Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Tasks.AspNetCompiler
+Microsoft.Build.Tasks.AspNetCompiler.AllowPartiallyTrustedCallers.get -> bool
+Microsoft.Build.Tasks.AspNetCompiler.AllowPartiallyTrustedCallers.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.AspNetCompiler() -> void
+Microsoft.Build.Tasks.AspNetCompiler.Clean.get -> bool
+Microsoft.Build.Tasks.AspNetCompiler.Clean.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.Debug.get -> bool
+Microsoft.Build.Tasks.AspNetCompiler.Debug.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.DelaySign.get -> bool
+Microsoft.Build.Tasks.AspNetCompiler.DelaySign.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.FixedNames.get -> bool
+Microsoft.Build.Tasks.AspNetCompiler.FixedNames.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.Force.get -> bool
+Microsoft.Build.Tasks.AspNetCompiler.Force.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.KeyContainer.get -> string
+Microsoft.Build.Tasks.AspNetCompiler.KeyContainer.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.KeyFile.get -> string
+Microsoft.Build.Tasks.AspNetCompiler.KeyFile.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.MetabasePath.get -> string
+Microsoft.Build.Tasks.AspNetCompiler.MetabasePath.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.PhysicalPath.get -> string
+Microsoft.Build.Tasks.AspNetCompiler.PhysicalPath.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.AspNetCompiler.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.TargetPath.get -> string
+Microsoft.Build.Tasks.AspNetCompiler.TargetPath.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.Updateable.get -> bool
+Microsoft.Build.Tasks.AspNetCompiler.Updateable.set -> void
+Microsoft.Build.Tasks.AspNetCompiler.VirtualPath.get -> string
+Microsoft.Build.Tasks.AspNetCompiler.VirtualPath.set -> void
+Microsoft.Build.Tasks.AssignCulture
+Microsoft.Build.Tasks.AssignCulture.AssignCulture() -> void
+Microsoft.Build.Tasks.AssignCulture.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.Files.set -> void
+Microsoft.Build.Tasks.AssignLinkMetadata
+Microsoft.Build.Tasks.AssignLinkMetadata.AssignLinkMetadata() -> void
+Microsoft.Build.Tasks.AssignLinkMetadata.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignLinkMetadata.Items.set -> void
+Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration
+Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.AssignProjectConfiguration() -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.set -> void
+Microsoft.Build.Tasks.AssignTargetPath
+Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignTargetPath.AssignTargetPath() -> void
+Microsoft.Build.Tasks.AssignTargetPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignTargetPath.Files.set -> void
+Microsoft.Build.Tasks.AssignTargetPath.RootFolder.get -> string
+Microsoft.Build.Tasks.AssignTargetPath.RootFolder.set -> void
+Microsoft.Build.Tasks.CallTarget
+Microsoft.Build.Tasks.CallTarget.CallTarget() -> void
+Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.get -> bool
+Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.set -> void
+Microsoft.Build.Tasks.CallTarget.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CallTarget.Targets.get -> string[]
+Microsoft.Build.Tasks.CallTarget.Targets.set -> void
+Microsoft.Build.Tasks.CallTarget.UseResultsCache.get -> bool
+Microsoft.Build.Tasks.CallTarget.UseResultsCache.set -> void
+Microsoft.Build.Tasks.CodeTaskFactory
+Microsoft.Build.Tasks.CodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Tasks.CodeTaskFactory.CodeTaskFactory() -> void
+Microsoft.Build.Tasks.CodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine loggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Tasks.CodeTaskFactory.FactoryName.get -> string
+Microsoft.Build.Tasks.CodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Tasks.CodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Tasks.CodeTaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Tasks.CombinePath
+Microsoft.Build.Tasks.CombinePath.BasePath.get -> string
+Microsoft.Build.Tasks.CombinePath.BasePath.set -> void
+Microsoft.Build.Tasks.CombinePath.CombinedPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombinePath.CombinedPaths.set -> void
+Microsoft.Build.Tasks.CombinePath.CombinePath() -> void
+Microsoft.Build.Tasks.CombinePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombinePath.Paths.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.CombineTargetFrameworkInfoProperties() -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.get -> string
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.get -> string
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.get -> bool
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.set -> void
+Microsoft.Build.Tasks.CombineXmlElements
+Microsoft.Build.Tasks.CombineXmlElements.CombineXmlElements() -> void
+Microsoft.Build.Tasks.CombineXmlElements.Result.get -> string
+Microsoft.Build.Tasks.CombineXmlElements.Result.set -> void
+Microsoft.Build.Tasks.CombineXmlElements.RootElementName.get -> string
+Microsoft.Build.Tasks.CombineXmlElements.RootElementName.set -> void
+Microsoft.Build.Tasks.CombineXmlElements.XmlElements.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombineXmlElements.XmlElements.set -> void
+Microsoft.Build.Tasks.CommandLineBuilderExtension
+Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension() -> void
+Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
+Microsoft.Build.Tasks.CommandLineBuilderExtension.GetQuotedText(string unquotedText) -> string
+Microsoft.Build.Tasks.ConvertToAbsolutePath
+Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.set -> void
+Microsoft.Build.Tasks.ConvertToAbsolutePath.ConvertToAbsolutePath() -> void
+Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.set -> void
+Microsoft.Build.Tasks.Copy
+Microsoft.Build.Tasks.Copy.Cancel() -> void
+Microsoft.Build.Tasks.Copy.CopiedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Copy.Copy() -> void
+Microsoft.Build.Tasks.Copy.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Copy.DestinationFiles.set -> void
+Microsoft.Build.Tasks.Copy.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.Copy.DestinationFolder.set -> void
+Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.get -> bool
+Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.set -> void
+Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.get -> bool
+Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.set -> void
+Microsoft.Build.Tasks.Copy.Retries.get -> int
+Microsoft.Build.Tasks.Copy.Retries.set -> void
+Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.get -> int
+Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.set -> void
+Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.get -> bool
+Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.set -> void
+Microsoft.Build.Tasks.Copy.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Copy.SourceFiles.set -> void
+Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.get -> bool
+Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.set -> void
+Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.get -> bool
+Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.set -> void
+Microsoft.Build.Tasks.Copy.WroteAtLeastOneFile.get -> bool
+Microsoft.Build.Tasks.CreateCSharpManifestResourceName
+Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateCSharpManifestResourceName() -> void
+Microsoft.Build.Tasks.CreateItem
+Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.get -> string[]
+Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.set -> void
+Microsoft.Build.Tasks.CreateItem.CreateItem() -> void
+Microsoft.Build.Tasks.CreateItem.Exclude.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateItem.Exclude.set -> void
+Microsoft.Build.Tasks.CreateItem.Include.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateItem.Include.set -> void
+Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.get -> bool
+Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName
+Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestResourceName() -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.itemSpecToTaskitem -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem>
+Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.get -> bool
+Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.get -> string
+Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.get -> bool
+Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.set -> void
+Microsoft.Build.Tasks.CreateProperty
+Microsoft.Build.Tasks.CreateProperty.CreateProperty() -> void
+Microsoft.Build.Tasks.CreateProperty.Value.get -> string[]
+Microsoft.Build.Tasks.CreateProperty.Value.set -> void
+Microsoft.Build.Tasks.CreateProperty.ValueSetByTask.get -> string[]
+Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName
+Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateVisualBasicManifestResourceName() -> void
+Microsoft.Build.Tasks.Delete
+Microsoft.Build.Tasks.Delete.Cancel() -> void
+Microsoft.Build.Tasks.Delete.Delete() -> void
+Microsoft.Build.Tasks.Delete.DeletedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Delete.DeletedFiles.set -> void
+Microsoft.Build.Tasks.Delete.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Delete.Files.set -> void
+Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.get -> bool
+Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder() -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder(string visualStudioVersion) -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) -> string[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpId.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Message.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Error = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Info = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Warning = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.ComponentFiles.get -> string[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.KeyFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Succeeded.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.BuildSettings() -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Absolute = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Relative = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpId.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Message.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles.get -> string[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.KeyFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Succeeded.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Name.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductCode.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Name.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Product() -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductCode.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest(string targetFrameworkVersion) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.FileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.All = Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture | Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Default = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsFrameworkAssembly.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsInFramework(string frameworkIdentifier, string frameworkVersion) -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsNeutralPlatform.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsStrongName.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.AssemblyManifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(string name) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ClickOnceManifest = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ManagedAssembly = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.NativeAssembly = 3 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.Unspecified = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.get -> long
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ClsId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ComClass() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.Description.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ThreadingModel.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.TlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.CompatibleFramework() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest(string targetFrameworkMoniker) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.FileAssociation() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.Build(string filename, string outputPath) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherBuilder(string launcherPath) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.FileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.get -> System.IO.Stream
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Manifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.OutputMessages.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles(string[] searchPaths) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo(string targetFrameworkVersion) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ValidatePlatform() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.GetArguments() -> string[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Text.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Type.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.ErrorCount.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.WarningCount.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Error = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Info = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Warning = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.BaseInterface.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.IID.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.NumMethods.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.ProxyStub() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.TlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.HasUnmanagedCodePermission.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PermissionSet.get -> System.Security.PermissionSet
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PermissionSet.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.IO.Stream input) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.IO.Stream input) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.TrustInfo() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.IO.Stream output) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream input, System.IO.Stream output) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream output) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Flags.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.HelpDirectory.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.ResourceId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TypeLib() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Version.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Background = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Foreground = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Days = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Hours = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Weeks = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Versioned.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass(string name, bool versioned) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.set -> void
+Microsoft.Build.Tasks.DownloadFile
+Microsoft.Build.Tasks.DownloadFile.Cancel() -> void
+Microsoft.Build.Tasks.DownloadFile.DestinationFileName.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.DownloadFile.DestinationFileName.set -> void
+Microsoft.Build.Tasks.DownloadFile.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.DownloadFile.DestinationFolder.set -> void
+Microsoft.Build.Tasks.DownloadFile.DownloadedFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.DownloadFile.DownloadedFile.set -> void
+Microsoft.Build.Tasks.DownloadFile.DownloadFile() -> void
+Microsoft.Build.Tasks.DownloadFile.Retries.get -> int
+Microsoft.Build.Tasks.DownloadFile.Retries.set -> void
+Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.get -> int
+Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.set -> void
+Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
+Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
+Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
+Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
+Microsoft.Build.Tasks.Error
+Microsoft.Build.Tasks.Error.Code.get -> string
+Microsoft.Build.Tasks.Error.Code.set -> void
+Microsoft.Build.Tasks.Error.Error() -> void
+Microsoft.Build.Tasks.Error.File.get -> string
+Microsoft.Build.Tasks.Error.File.set -> void
+Microsoft.Build.Tasks.Error.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Error.HelpKeyword.set -> void
+Microsoft.Build.Tasks.Error.HelpLink.get -> string
+Microsoft.Build.Tasks.Error.HelpLink.set -> void
+Microsoft.Build.Tasks.Error.Text.get -> string
+Microsoft.Build.Tasks.Error.Text.set -> void
+Microsoft.Build.Tasks.ErrorFromResources
+Microsoft.Build.Tasks.ErrorFromResources.Arguments.get -> string[]
+Microsoft.Build.Tasks.ErrorFromResources.Arguments.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.Code.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.Code.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.ErrorFromResources() -> void
+Microsoft.Build.Tasks.ErrorFromResources.File.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.File.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.Resource.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.Resource.set -> void
+Microsoft.Build.Tasks.Exec
+Microsoft.Build.Tasks.Exec.Command.get -> string
+Microsoft.Build.Tasks.Exec.Command.set -> void
+Microsoft.Build.Tasks.Exec.ConsoleOutput.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.get -> bool
+Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.set -> void
+Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.get -> string
+Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.set -> void
+Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.get -> string
+Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.set -> void
+Microsoft.Build.Tasks.Exec.Exec() -> void
+Microsoft.Build.Tasks.Exec.IgnoreExitCode.get -> bool
+Microsoft.Build.Tasks.Exec.IgnoreExitCode.set -> void
+Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.get -> bool
+Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.set -> void
+Microsoft.Build.Tasks.Exec.Outputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Exec.Outputs.set -> void
+Microsoft.Build.Tasks.Exec.StdErrEncoding.get -> string
+Microsoft.Build.Tasks.Exec.StdErrEncoding.set -> void
+Microsoft.Build.Tasks.Exec.StdOutEncoding.get -> string
+Microsoft.Build.Tasks.Exec.StdOutEncoding.set -> void
+Microsoft.Build.Tasks.Exec.WorkingDirectory.get -> string
+Microsoft.Build.Tasks.Exec.WorkingDirectory.set -> void
+Microsoft.Build.Tasks.ExtractedClassName
+Microsoft.Build.Tasks.ExtractedClassName.ExtractedClassName() -> void
+Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.get -> bool
+Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.set -> void
+Microsoft.Build.Tasks.ExtractedClassName.Name.get -> string
+Microsoft.Build.Tasks.ExtractedClassName.Name.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile
+Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile.FindAppConfigFile() -> void
+Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.get -> string
+Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.set -> void
+Microsoft.Build.Tasks.FindInList
+Microsoft.Build.Tasks.FindInList.CaseSensitive.get -> bool
+Microsoft.Build.Tasks.FindInList.CaseSensitive.set -> void
+Microsoft.Build.Tasks.FindInList.FindInList() -> void
+Microsoft.Build.Tasks.FindInList.FindLastMatch.get -> bool
+Microsoft.Build.Tasks.FindInList.FindLastMatch.set -> void
+Microsoft.Build.Tasks.FindInList.ItemFound.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.FindInList.ItemFound.set -> void
+Microsoft.Build.Tasks.FindInList.ItemSpecToFind.get -> string
+Microsoft.Build.Tasks.FindInList.ItemSpecToFind.set -> void
+Microsoft.Build.Tasks.FindInList.List.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindInList.List.set -> void
+Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.get -> bool
+Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.set -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences
+Microsoft.Build.Tasks.FindInvalidProjectReferences.FindInvalidProjectReferences() -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences.InvalidReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.set -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.FindUnderPath
+Microsoft.Build.Tasks.FindUnderPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindUnderPath.Files.set -> void
+Microsoft.Build.Tasks.FindUnderPath.FindUnderPath() -> void
+Microsoft.Build.Tasks.FindUnderPath.InPath.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindUnderPath.InPath.set -> void
+Microsoft.Build.Tasks.FindUnderPath.OutOfPath.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindUnderPath.OutOfPath.set -> void
+Microsoft.Build.Tasks.FindUnderPath.Path.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.FindUnderPath.Path.set -> void
+Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.get -> bool
+Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.set -> void
+Microsoft.Build.Tasks.FormatUrl
+Microsoft.Build.Tasks.FormatUrl.FormatUrl() -> void
+Microsoft.Build.Tasks.FormatUrl.InputUrl.get -> string
+Microsoft.Build.Tasks.FormatUrl.InputUrl.set -> void
+Microsoft.Build.Tasks.FormatUrl.OutputUrl.get -> string
+Microsoft.Build.Tasks.FormatUrl.OutputUrl.set -> void
+Microsoft.Build.Tasks.FormatVersion
+Microsoft.Build.Tasks.FormatVersion.FormatType.get -> string
+Microsoft.Build.Tasks.FormatVersion.FormatType.set -> void
+Microsoft.Build.Tasks.FormatVersion.FormatVersion() -> void
+Microsoft.Build.Tasks.FormatVersion.OutputVersion.get -> string
+Microsoft.Build.Tasks.FormatVersion.OutputVersion.set -> void
+Microsoft.Build.Tasks.FormatVersion.Revision.get -> int
+Microsoft.Build.Tasks.FormatVersion.Revision.set -> void
+Microsoft.Build.Tasks.FormatVersion.Version.get -> string
+Microsoft.Build.Tasks.FormatVersion.Version.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest
+Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.Files.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.GenerateApplicationManifest() -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.get -> bool
+Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Product.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.Product.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.get -> bool
+Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.get -> bool
+Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects
+Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.GenerateBindingRedirects() -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.get -> string
+Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationFile.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationFile.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationName.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationName.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationRequiresElevation.get -> bool
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationRequiresElevation.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationUrl.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationUrl.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperComponentFiles.get -> string[]
+Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperComponentFiles.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperItems.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperItems.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperKeyFile.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperKeyFile.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsLocation.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsLocation.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsUrl.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsUrl.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.CopyComponents.get -> bool
+Microsoft.Build.Tasks.GenerateBootstrapper.CopyComponents.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.Culture.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.Culture.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.FallbackCulture.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.FallbackCulture.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.GenerateBootstrapper() -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.OutputPath.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.OutputPath.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.Path.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.Path.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.SupportUrl.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.SupportUrl.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.Validate.get -> bool
+Microsoft.Build.Tasks.GenerateBootstrapper.Validate.set -> void
+Microsoft.Build.Tasks.GenerateBootstrapper.VisualStudioVersion.get -> string
+Microsoft.Build.Tasks.GenerateBootstrapper.VisualStudioVersion.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest
+Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.GenerateDeploymentManifest() -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.get -> int
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.set -> void
+Microsoft.Build.Tasks.GenerateLauncher
+Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.GenerateLauncher() -> void
+Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.OutputPath.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.OutputPath.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase
+Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.GenerateManifestBase.AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.GenerateManifestBase.AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.Description.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.Description.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.GenerateManifestBase.GenerateManifestBase() -> void
+Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.get -> bool
+Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.get -> int
+Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.Platform.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.Platform.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.GenerateResource
+Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.set -> void
+Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.get -> string[]
+Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.set -> void
+Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.set -> void
+Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.get -> bool
+Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.set -> void
+Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.get -> bool
+Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.set -> void
+Microsoft.Build.Tasks.GenerateResource.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.GenerateResource() -> void
+Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.get -> bool
+Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.set -> void
+Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.get -> bool
+Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.set -> void
+Microsoft.Build.Tasks.GenerateResource.OutputDirectory.get -> string
+Microsoft.Build.Tasks.GenerateResource.OutputDirectory.set -> void
+Microsoft.Build.Tasks.GenerateResource.OutputResources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.OutputResources.set -> void
+Microsoft.Build.Tasks.GenerateResource.PublicClass.get -> bool
+Microsoft.Build.Tasks.GenerateResource.PublicClass.set -> void
+Microsoft.Build.Tasks.GenerateResource.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.References.set -> void
+Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.GenerateResource.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.Sources.set -> void
+Microsoft.Build.Tasks.GenerateResource.StateFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateResource.StateFile.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.set -> void
+Microsoft.Build.Tasks.GenerateResource.TLogReadFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.TLogWriteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.get -> string
+Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.get -> string
+Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.get -> string
+Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.get -> string
+Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.get -> bool
+Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.set -> void
+Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.get -> bool
+Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.set -> void
+Microsoft.Build.Tasks.GenerateResource.UseSourcePath.get -> bool
+Microsoft.Build.Tasks.GenerateResource.UseSourcePath.set -> void
+Microsoft.Build.Tasks.GenerateTrustInfo
+Microsoft.Build.Tasks.GenerateTrustInfo.ApplicationDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateTrustInfo.ApplicationDependencies.set -> void
+Microsoft.Build.Tasks.GenerateTrustInfo.BaseManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateTrustInfo.BaseManifest.set -> void
+Microsoft.Build.Tasks.GenerateTrustInfo.ExcludedPermissions.get -> string
+Microsoft.Build.Tasks.GenerateTrustInfo.ExcludedPermissions.set -> void
+Microsoft.Build.Tasks.GenerateTrustInfo.GenerateTrustInfo() -> void
+Microsoft.Build.Tasks.GenerateTrustInfo.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.GenerateTrustInfo.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.GenerateTrustInfo.TargetZone.get -> string
+Microsoft.Build.Tasks.GenerateTrustInfo.TargetZone.set -> void
+Microsoft.Build.Tasks.GenerateTrustInfo.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateTrustInfo.TrustInfoFile.set -> void
+Microsoft.Build.Tasks.GetAssemblyIdentity
+Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.set -> void
+Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.set -> void
+Microsoft.Build.Tasks.GetAssemblyIdentity.GetAssemblyIdentity() -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform
+Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.set -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.set -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.get -> string
+Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.set -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.GetCompatiblePlatform() -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.get -> string
+Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.set -> void
+Microsoft.Build.Tasks.GetFileHash
+Microsoft.Build.Tasks.GetFileHash.Algorithm.get -> string
+Microsoft.Build.Tasks.GetFileHash.Algorithm.set -> void
+Microsoft.Build.Tasks.GetFileHash.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetFileHash.Files.set -> void
+Microsoft.Build.Tasks.GetFileHash.GetFileHash() -> void
+Microsoft.Build.Tasks.GetFileHash.Hash.get -> string
+Microsoft.Build.Tasks.GetFileHash.Hash.set -> void
+Microsoft.Build.Tasks.GetFileHash.HashEncoding.get -> string
+Microsoft.Build.Tasks.GetFileHash.HashEncoding.set -> void
+Microsoft.Build.Tasks.GetFileHash.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetFileHash.Items.set -> void
+Microsoft.Build.Tasks.GetFileHash.MetadataName.get -> string
+Microsoft.Build.Tasks.GetFileHash.MetadataName.set -> void
+Microsoft.Build.Tasks.GetFrameworkPath
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion11Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion20Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion30Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion35Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion40Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion451Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion452Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion45Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion462Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion46Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion471Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion472Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
+Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath
+Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion20Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion35Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion40Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion451Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion45Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion461Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion46Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.GetFrameworkSdkPath() -> void
+Microsoft.Build.Tasks.GetFrameworkSdkPath.Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkSdkPath.Path.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations
+Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
+Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.FullFrameworkReferenceAssemblyPaths.get -> string[]
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.GetReferenceAssemblyPaths() -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.ReferenceAssemblyPaths.get -> string[]
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.get -> bool
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
+Microsoft.Build.Tasks.Hash
+Microsoft.Build.Tasks.Hash.Hash() -> void
+Microsoft.Build.Tasks.Hash.HashResult.get -> string
+Microsoft.Build.Tasks.Hash.HashResult.set -> void
+Microsoft.Build.Tasks.Hash.IgnoreCase.get -> bool
+Microsoft.Build.Tasks.Hash.IgnoreCase.set -> void
+Microsoft.Build.Tasks.Hash.ItemsToHash.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Hash.ItemsToHash.set -> void
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles) -> bool
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers) -> bool
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetRuleSet(string ruleSetFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject
+Microsoft.Build.Tasks.Hosting.ICscHostObject.BeginInitialization() -> void
+Microsoft.Build.Tasks.Hosting.ICscHostObject.Compile() -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(out string errorMessage, out int errorCode) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.IsDesignTime() -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.IsUpToDate() -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAddModules(string[] addModules) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAllowUnsafeBlocks(bool allowUnsafeBlocks) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetBaseAddress(string baseAddress) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCodePage(int codePage) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDebugType(string debugType) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDefineConstants(string defineConstants) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDelaySign(bool delaySignExplicitlySet, bool delaySign) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDocumentationFile(string documentationFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetEmitDebugInformation(bool emitDebugInformation) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetErrorReport(string errorReport) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetFileAlignment(int fileAlignment) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetGenerateFullPaths(bool generateFullPaths) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyContainer(string keyContainer) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyFile(string keyFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLangVersion(string langVersion) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetMainEntryPoint(string targetType, string mainEntryPoint) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetModuleAssemblyName(string moduleAssemblyName) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoConfig(bool noConfig) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoStandardLib(bool noStandardLib) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOptimize(bool optimize) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOutputAssembly(string outputAssembly) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPdbFile(string pdbFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPlatform(string platform) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTargetType(string targetType) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningLevel(int warningLevel) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Icon(string win32Icon) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Resource(string win32Resource) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject2
+Microsoft.Build.Tasks.Hosting.ICscHostObject2.SetWin32Manifest(string win32Manifest) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject3
+Microsoft.Build.Tasks.Hosting.ICscHostObject3.SetApplicationConfiguration(string applicationConfiguration) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject4
+Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetHighEntropyVA(bool highEntropyVA) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetSubsystemVersion(string subsystemVersion) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.BeginInitialization() -> void
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.Compile() -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.EndInitialization() -> void
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsDesignTime() -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsUpToDate() -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAddModules(string[] addModules) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetBaseAddress(string targetType, string baseAddress) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetCodePage(int codePage) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDebugType(bool emitDebugInformation, string debugType) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDefineConstants(string defineConstants) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDelaySign(bool delaySign) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDocumentationFile(string documentationFile) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetErrorReport(string errorReport) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetFileAlignment(int fileAlignment) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetGenerateDocumentation(bool generateDocumentation) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetImports(Microsoft.Build.Framework.ITaskItem[] importsList) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyContainer(string keyContainer) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyFile(string keyFile) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetMainEntryPoint(string mainEntryPoint) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoConfig(bool noConfig) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoStandardLib(bool noStandardLib) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoWarnings(bool noWarnings) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptimize(bool optimize) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionCompare(string optionCompare) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionExplicit(bool optionExplicit) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrict(bool optionStrict) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrictType(string optionStrictType) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOutputAssembly(string outputAssembly) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetPlatform(string platform) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(bool removeIntegerChecks) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRootNamespace(string rootNamespace) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSdkPath(string sdkPath) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetCompactFramework(bool targetCompactFramework) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetType(string targetType) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Icon(string win32Icon) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Resource(string win32Resource) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetModuleAssemblyName(string moduleAssemblyName) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetOptionInfer(bool optionInfer) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetWin32Manifest(string win32Manifest) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject3
+Microsoft.Build.Tasks.Hosting.IVbcHostObject3.SetLanguageVersion(string languageVersion) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject4
+Microsoft.Build.Tasks.Hosting.IVbcHostObject4.SetVBRuntime(string VBRuntime) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent) -> int
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.EndCompile(bool buildSuccess) -> int
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.GetFreeThreadedHostObject() -> Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetHighEntropyVA(bool highEntropyVA) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
+Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
+Microsoft.Build.Tasks.IFixedTypeInfo
+Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
+Microsoft.Build.Tasks.LC
+Microsoft.Build.Tasks.LC.LC() -> void
+Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.LC.LicenseTarget.set -> void
+Microsoft.Build.Tasks.LC.NoLogo.get -> bool
+Microsoft.Build.Tasks.LC.NoLogo.set -> void
+Microsoft.Build.Tasks.LC.OutputDirectory.get -> string
+Microsoft.Build.Tasks.LC.OutputDirectory.set -> void
+Microsoft.Build.Tasks.LC.OutputLicense.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.LC.OutputLicense.set -> void
+Microsoft.Build.Tasks.LC.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.LC.ReferencedAssemblies.set -> void
+Microsoft.Build.Tasks.LC.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.LC.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.LC.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.LC.Sources.set -> void
+Microsoft.Build.Tasks.LC.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.LC.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.MakeDir
+Microsoft.Build.Tasks.MakeDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MakeDir.Directories.set -> void
+Microsoft.Build.Tasks.MakeDir.DirectoriesCreated.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MakeDir.MakeDir() -> void
+Microsoft.Build.Tasks.Message
+Microsoft.Build.Tasks.Message.Code.get -> string
+Microsoft.Build.Tasks.Message.Code.set -> void
+Microsoft.Build.Tasks.Message.File.get -> string
+Microsoft.Build.Tasks.Message.File.set -> void
+Microsoft.Build.Tasks.Message.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Message.HelpKeyword.set -> void
+Microsoft.Build.Tasks.Message.Importance.get -> string
+Microsoft.Build.Tasks.Message.Importance.set -> void
+Microsoft.Build.Tasks.Message.IsCritical.get -> bool
+Microsoft.Build.Tasks.Message.IsCritical.set -> void
+Microsoft.Build.Tasks.Message.Message() -> void
+Microsoft.Build.Tasks.Message.Text.get -> string
+Microsoft.Build.Tasks.Message.Text.set -> void
+Microsoft.Build.Tasks.Move
+Microsoft.Build.Tasks.Move.Cancel() -> void
+Microsoft.Build.Tasks.Move.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Move.DestinationFiles.set -> void
+Microsoft.Build.Tasks.Move.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.Move.DestinationFolder.set -> void
+Microsoft.Build.Tasks.Move.Move() -> void
+Microsoft.Build.Tasks.Move.MovedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.get -> bool
+Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.set -> void
+Microsoft.Build.Tasks.Move.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Move.SourceFiles.set -> void
+Microsoft.Build.Tasks.MSBuild
+Microsoft.Build.Tasks.MSBuild.BuildInParallel.get -> bool
+Microsoft.Build.Tasks.MSBuild.BuildInParallel.set -> void
+Microsoft.Build.Tasks.MSBuild.MSBuild() -> void
+Microsoft.Build.Tasks.MSBuild.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MSBuild.Projects.set -> void
+Microsoft.Build.Tasks.MSBuild.Properties.get -> string[]
+Microsoft.Build.Tasks.MSBuild.Properties.set -> void
+Microsoft.Build.Tasks.MSBuild.RebaseOutputs.get -> bool
+Microsoft.Build.Tasks.MSBuild.RebaseOutputs.set -> void
+Microsoft.Build.Tasks.MSBuild.RemoveProperties.get -> string
+Microsoft.Build.Tasks.MSBuild.RemoveProperties.set -> void
+Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.get -> bool
+Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.set -> void
+Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.get -> string
+Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.set -> void
+Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.get -> bool
+Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.set -> void
+Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.get -> string[]
+Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.set -> void
+Microsoft.Build.Tasks.MSBuild.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MSBuild.Targets.get -> string[]
+Microsoft.Build.Tasks.MSBuild.Targets.set -> void
+Microsoft.Build.Tasks.MSBuild.ToolsVersion.get -> string
+Microsoft.Build.Tasks.MSBuild.ToolsVersion.set -> void
+Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.get -> bool
+Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.set -> void
+Microsoft.Build.Tasks.MSBuild.UseResultsCache.get -> bool
+Microsoft.Build.Tasks.MSBuild.UseResultsCache.set -> void
+Microsoft.Build.Tasks.ReadLinesFromFile
+Microsoft.Build.Tasks.ReadLinesFromFile.File.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ReadLinesFromFile.File.set -> void
+Microsoft.Build.Tasks.ReadLinesFromFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ReadLinesFromFile.Lines.set -> void
+Microsoft.Build.Tasks.ReadLinesFromFile.ReadLinesFromFile() -> void
+Microsoft.Build.Tasks.RegisterAssembly
+Microsoft.Build.Tasks.RegisterAssembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RegisterAssembly.Assemblies.set -> void
+Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile.set -> void
+Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase.get -> bool
+Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase.set -> void
+Microsoft.Build.Tasks.RegisterAssembly.RegisterAssembly() -> void
+Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind kind, int code, string msg) -> void
+Microsoft.Build.Tasks.RegisterAssembly.ResolveRef(System.Reflection.Assembly assemblyToResolve) -> object
+Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles.set -> void
+Microsoft.Build.Tasks.RemoveDir
+Microsoft.Build.Tasks.RemoveDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDir.Directories.set -> void
+Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.set -> void
+Microsoft.Build.Tasks.RemoveDir.RemoveDir() -> void
+Microsoft.Build.Tasks.RemoveDuplicates
+Microsoft.Build.Tasks.RemoveDuplicates.Filtered.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDuplicates.Filtered.set -> void
+Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.get -> bool
+Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.set -> void
+Microsoft.Build.Tasks.RemoveDuplicates.Inputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDuplicates.Inputs.set -> void
+Microsoft.Build.Tasks.RemoveDuplicates.RemoveDuplicates() -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Assemblies.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.CreateDesktopShortcut.get -> bool
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.CreateDesktopShortcut.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.DeploymentManifestEntryPoint.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.EntryPoint.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Files.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ReferencedAssemblies.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresFramework35SP1Assembly() -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresMinimumFramework35SP1.get -> bool
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresMinimumFramework35SP1.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SigningManifests.get -> bool
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SigningManifests.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SuiteName.get -> string
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SuiteName.set -> void
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnNETStandard.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnSystemRuntime.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolveAssemblyReference() -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolvedAssemblyConflicts.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.get -> string
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.get -> string[]
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.get -> string
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolveCodeAnalysisRuleSet() -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolvedCodeAnalysisRuleSet.get -> string
+Microsoft.Build.Tasks.ResolveComReference
+Microsoft.Build.Tasks.ResolveComReference.DelaySign.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.DelaySign.set -> void
+Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.get -> string[]
+Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.set -> void
+Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.set -> void
+Microsoft.Build.Tasks.ResolveComReference.KeyContainer.get -> string
+Microsoft.Build.Tasks.ResolveComReference.KeyContainer.set -> void
+Microsoft.Build.Tasks.ResolveComReference.KeyFile.get -> string
+Microsoft.Build.Tasks.ResolveComReference.KeyFile.set -> void
+Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolveComReference() -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.set -> void
+Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.ResolveComReference.Silent.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.Silent.set -> void
+Microsoft.Build.Tasks.ResolveComReference.StateFile.get -> string
+Microsoft.Build.Tasks.ResolveComReference.StateFile.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.set -> void
+Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.get -> string
+Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.set -> void
+Microsoft.Build.Tasks.ResolveKeySource
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.get -> int
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.get -> int
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.KeyFile.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.KeyFile.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolveKeySource() -> void
+Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.get -> bool
+Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.get -> bool
+Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles
+Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.Files.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.ResolveManifestFiles() -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference
+Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths.get -> string[]
+Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences.set -> void
+Microsoft.Build.Tasks.ResolveNativeReference.ResolveNativeReference() -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.get -> string
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.set -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.set -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolveNonMSBuildProjectOutput() -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.set -> void
+Microsoft.Build.Tasks.ResolveProjectBase
+Microsoft.Build.Tasks.ResolveProjectBase.AddSyntheticProjectReferences(string currentProjectAbsolutePath) -> void
+Microsoft.Build.Tasks.ResolveProjectBase.GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) -> System.Xml.XmlElement
+Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) -> string
+Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
+Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
+Microsoft.Build.Tasks.ResolveSDKReference
+Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
+Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
+Microsoft.Build.Tasks.RoslynCodeTaskFactory
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.FactoryName.get -> string
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.RoslynCodeTaskFactory() -> void
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Tasks.SGen
+Microsoft.Build.Tasks.SGen.BuildAssemblyName.get -> string
+Microsoft.Build.Tasks.SGen.BuildAssemblyName.set -> void
+Microsoft.Build.Tasks.SGen.BuildAssemblyPath.get -> string
+Microsoft.Build.Tasks.SGen.BuildAssemblyPath.set -> void
+Microsoft.Build.Tasks.SGen.DelaySign.get -> bool
+Microsoft.Build.Tasks.SGen.DelaySign.set -> void
+Microsoft.Build.Tasks.SGen.KeyContainer.get -> string
+Microsoft.Build.Tasks.SGen.KeyContainer.set -> void
+Microsoft.Build.Tasks.SGen.KeyFile.get -> string
+Microsoft.Build.Tasks.SGen.KeyFile.set -> void
+Microsoft.Build.Tasks.SGen.Platform.get -> string
+Microsoft.Build.Tasks.SGen.Platform.set -> void
+Microsoft.Build.Tasks.SGen.References.get -> string[]
+Microsoft.Build.Tasks.SGen.References.set -> void
+Microsoft.Build.Tasks.SGen.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.SGen.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.SGen.SerializationAssembly.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SGen.SerializationAssembly.set -> void
+Microsoft.Build.Tasks.SGen.SerializationAssemblyName.get -> string
+Microsoft.Build.Tasks.SGen.SGen() -> void
+Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.get -> bool
+Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.set -> void
+Microsoft.Build.Tasks.SGen.Types.get -> string[]
+Microsoft.Build.Tasks.SGen.Types.set -> void
+Microsoft.Build.Tasks.SGen.UseKeep.get -> bool
+Microsoft.Build.Tasks.SGen.UseKeep.set -> void
+Microsoft.Build.Tasks.SGen.UseProxyTypes.get -> bool
+Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
+Microsoft.Build.Tasks.SignFile
+Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
+Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.SignFile.SignFile() -> void
+Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
+Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.get -> string
+Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.set -> void
+Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.SignFile.TimestampUrl.get -> string
+Microsoft.Build.Tasks.SignFile.TimestampUrl.set -> void
+Microsoft.Build.Tasks.TaskExtension
+Microsoft.Build.Tasks.TaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Tasks.TaskLoggingHelperExtension
+Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.set -> void
+Microsoft.Build.Tasks.Telemetry
+Microsoft.Build.Tasks.Telemetry.EventData.get -> string
+Microsoft.Build.Tasks.Telemetry.EventData.set -> void
+Microsoft.Build.Tasks.Telemetry.EventName.get -> string
+Microsoft.Build.Tasks.Telemetry.EventName.set -> void
+Microsoft.Build.Tasks.Telemetry.Telemetry() -> void
+Microsoft.Build.Tasks.ToolTaskExtension
+Microsoft.Build.Tasks.ToolTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Tasks.Touch
+Microsoft.Build.Tasks.Touch.AlwaysCreate.get -> bool
+Microsoft.Build.Tasks.Touch.AlwaysCreate.set -> void
+Microsoft.Build.Tasks.Touch.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Touch.Files.set -> void
+Microsoft.Build.Tasks.Touch.ForceTouch.get -> bool
+Microsoft.Build.Tasks.Touch.ForceTouch.set -> void
+Microsoft.Build.Tasks.Touch.Time.get -> string
+Microsoft.Build.Tasks.Touch.Time.set -> void
+Microsoft.Build.Tasks.Touch.Touch() -> void
+Microsoft.Build.Tasks.Touch.TouchedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Touch.TouchedFiles.set -> void
+Microsoft.Build.Tasks.UnregisterAssembly
+Microsoft.Build.Tasks.UnregisterAssembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.UnregisterAssembly.Assemblies.set -> void
+Microsoft.Build.Tasks.UnregisterAssembly.AssemblyListFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.UnregisterAssembly.AssemblyListFile.set -> void
+Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles.set -> void
+Microsoft.Build.Tasks.UnregisterAssembly.UnregisterAssembly() -> void
+Microsoft.Build.Tasks.Unzip
+Microsoft.Build.Tasks.Unzip.Cancel() -> void
+Microsoft.Build.Tasks.Unzip.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.Unzip.DestinationFolder.set -> void
+Microsoft.Build.Tasks.Unzip.Exclude.get -> string
+Microsoft.Build.Tasks.Unzip.Exclude.set -> void
+Microsoft.Build.Tasks.Unzip.Include.get -> string
+Microsoft.Build.Tasks.Unzip.Include.set -> void
+Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.get -> bool
+Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.set -> void
+Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.get -> bool
+Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.set -> void
+Microsoft.Build.Tasks.Unzip.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Unzip.SourceFiles.set -> void
+Microsoft.Build.Tasks.Unzip.Unzip() -> void
+Microsoft.Build.Tasks.UpdateManifest
+Microsoft.Build.Tasks.UpdateManifest.ApplicationManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.UpdateManifest.ApplicationManifest.set -> void
+Microsoft.Build.Tasks.UpdateManifest.ApplicationPath.get -> string
+Microsoft.Build.Tasks.UpdateManifest.ApplicationPath.set -> void
+Microsoft.Build.Tasks.UpdateManifest.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.UpdateManifest.InputManifest.set -> void
+Microsoft.Build.Tasks.UpdateManifest.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.UpdateManifest.OutputManifest.set -> void
+Microsoft.Build.Tasks.UpdateManifest.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.UpdateManifest.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.UpdateManifest.UpdateManifest() -> void
+Microsoft.Build.Tasks.VerifyFileHash
+Microsoft.Build.Tasks.VerifyFileHash.Algorithm.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.Algorithm.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.File.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.File.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.Hash.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.Hash.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.VerifyFileHash() -> void
+Microsoft.Build.Tasks.Warning
+Microsoft.Build.Tasks.Warning.Code.get -> string
+Microsoft.Build.Tasks.Warning.Code.set -> void
+Microsoft.Build.Tasks.Warning.File.get -> string
+Microsoft.Build.Tasks.Warning.File.set -> void
+Microsoft.Build.Tasks.Warning.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Warning.HelpKeyword.set -> void
+Microsoft.Build.Tasks.Warning.HelpLink.get -> string
+Microsoft.Build.Tasks.Warning.HelpLink.set -> void
+Microsoft.Build.Tasks.Warning.Text.get -> string
+Microsoft.Build.Tasks.Warning.Text.set -> void
+Microsoft.Build.Tasks.Warning.Warning() -> void
+Microsoft.Build.Tasks.WinMDExp
+Microsoft.Build.Tasks.WinMDExp.AssemblyUnificationPolicy.get -> string
+Microsoft.Build.Tasks.WinMDExp.AssemblyUnificationPolicy.set -> void
+Microsoft.Build.Tasks.WinMDExp.DisabledWarnings.get -> string
+Microsoft.Build.Tasks.WinMDExp.DisabledWarnings.set -> void
+Microsoft.Build.Tasks.WinMDExp.InputDocumentationFile.get -> string
+Microsoft.Build.Tasks.WinMDExp.InputDocumentationFile.set -> void
+Microsoft.Build.Tasks.WinMDExp.InputPDBFile.get -> string
+Microsoft.Build.Tasks.WinMDExp.InputPDBFile.set -> void
+Microsoft.Build.Tasks.WinMDExp.OutputDocumentationFile.get -> string
+Microsoft.Build.Tasks.WinMDExp.OutputDocumentationFile.set -> void
+Microsoft.Build.Tasks.WinMDExp.OutputPDBFile.get -> string
+Microsoft.Build.Tasks.WinMDExp.OutputPDBFile.set -> void
+Microsoft.Build.Tasks.WinMDExp.OutputWindowsMetadataFile.get -> string
+Microsoft.Build.Tasks.WinMDExp.OutputWindowsMetadataFile.set -> void
+Microsoft.Build.Tasks.WinMDExp.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.WinMDExp.References.set -> void
+Microsoft.Build.Tasks.WinMDExp.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.WinMDExp.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.WinMDExp.TreatWarningsAsErrors.get -> bool
+Microsoft.Build.Tasks.WinMDExp.TreatWarningsAsErrors.set -> void
+Microsoft.Build.Tasks.WinMDExp.UTF8Output.get -> bool
+Microsoft.Build.Tasks.WinMDExp.UTF8Output.set -> void
+Microsoft.Build.Tasks.WinMDExp.WinMDExp() -> void
+Microsoft.Build.Tasks.WinMDExp.WinMDModule.get -> string
+Microsoft.Build.Tasks.WinMDExp.WinMDModule.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment
+Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.Language.get -> string
+Microsoft.Build.Tasks.WriteCodeFragment.Language.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.WriteCodeFragment() -> void
+Microsoft.Build.Tasks.WriteLinesToFile
+Microsoft.Build.Tasks.WriteLinesToFile.Encoding.get -> string
+Microsoft.Build.Tasks.WriteLinesToFile.Encoding.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.File.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.WriteLinesToFile.File.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.WriteLinesToFile.Lines.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.get -> bool
+Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.WriteLinesToFile() -> void
+Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.get -> bool
+Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation
+Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.CommandLineArgumentRelation(string argument, string value, bool required, string separator) -> void
+Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.Separator.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.Separator.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AdditionalOptions.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AdditionalOptions.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AlwaysAppend.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AlwaysAppend.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineGenerator(Microsoft.Build.Framework.XamlTypes.Rule rule, System.Collections.Generic.Dictionary<string, object> parameterValues) -> void
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineTemplate.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineTemplate.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GenerateCommandLine() -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.AllowMultipleValues.get -> bool
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.AllowMultipleValues.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ArgumentRequired.get -> bool
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ArgumentRequired.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Arguments.get -> System.Collections.Generic.ICollection<System.Tuple<string, bool>>
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Arguments.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.BooleanValue.get -> bool
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.BooleanValue.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.CommandLineToolSwitch() -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.CommandLineToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType toolType) -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Description.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Description.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.DisplayName.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.DisplayName.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FallbackArgumentParameter.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FallbackArgumentParameter.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FalseSuffix.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FalseSuffix.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IncludeInCommandLine.get -> bool
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IncludeInCommandLine.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IsValid.get -> bool
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IsValid.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Name.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Name.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Number.get -> int
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Number.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Overrides.get -> System.Collections.Generic.LinkedList<System.Collections.Generic.KeyValuePair<string, string>>
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Parents.get -> System.Collections.Generic.LinkedList<string>
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Required.get -> bool
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Required.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ReverseSwitchValue.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ReverseSwitchValue.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Reversible.get -> bool
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Reversible.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Separator.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Separator.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.StringList.get -> string[]
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.StringList.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.SwitchValue.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.SwitchValue.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TaskItemArray.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TaskItemArray.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TrueSuffix.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TrueSuffix.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Type.get -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Type.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Value.get -> string
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Value.set -> void
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Boolean = 0 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Integer = 1 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.ITaskItemArray = 4 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.String = 2 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
+Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.StringArray = 3 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
+Microsoft.Build.Tasks.Xaml.PropertyRelation
+Microsoft.Build.Tasks.Xaml.PropertyRelation.Argument.get -> string
+Microsoft.Build.Tasks.Xaml.PropertyRelation.Argument.set -> void
+Microsoft.Build.Tasks.Xaml.PropertyRelation.PropertyRelation() -> void
+Microsoft.Build.Tasks.Xaml.PropertyRelation.PropertyRelation(string argument, string value, bool required) -> void
+Microsoft.Build.Tasks.Xaml.PropertyRelation.Required.get -> bool
+Microsoft.Build.Tasks.Xaml.PropertyRelation.Required.set -> void
+Microsoft.Build.Tasks.Xaml.PropertyRelation.Value.get -> string
+Microsoft.Build.Tasks.Xaml.PropertyRelation.Value.set -> void
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitches.get -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch>
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitchesValues.get -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch>
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitchesValues.set -> void
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AddActiveSwitchToolValue(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) -> void
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AdditionalOptions.get -> string
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AdditionalOptions.set -> void
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLineTemplate.get -> string
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLineTemplate.set -> void
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CreateSwitchValue(string propertyName, string baseSwitch, string separator, System.Tuple<string, bool>[] arguments) -> string
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.IsPropertySet(string propertyName) -> bool
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap(string propertyName, string[][] switchMap, string value) -> string
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap2(string propertyName, System.Tuple<string, string, System.Tuple<string, bool>[]>[] switchMap, string value) -> int
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReplaceToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) -> void
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateInteger(string switchName, int min, int max, int value) -> bool
+Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.XamlDataDrivenToolTask(string[] switchOrderList, System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Tasks.XamlTaskFactory
+Microsoft.Build.Tasks.XamlTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Tasks.XamlTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Tasks.XamlTaskFactory.FactoryName.get -> string
+Microsoft.Build.Tasks.XamlTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Tasks.XamlTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Tasks.XamlTaskFactory.TaskElementContents.get -> string
+Microsoft.Build.Tasks.XamlTaskFactory.TaskName.get -> string
+Microsoft.Build.Tasks.XamlTaskFactory.TaskNamespace.get -> string
+Microsoft.Build.Tasks.XamlTaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Tasks.XamlTaskFactory.XamlTaskFactory() -> void
+Microsoft.Build.Tasks.XmlPeek
+Microsoft.Build.Tasks.XmlPeek.Namespaces.get -> string
+Microsoft.Build.Tasks.XmlPeek.Namespaces.set -> void
+Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.get -> bool
+Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.set -> void
+Microsoft.Build.Tasks.XmlPeek.Query.get -> string
+Microsoft.Build.Tasks.XmlPeek.Query.set -> void
+Microsoft.Build.Tasks.XmlPeek.Result.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.XmlPeek.XmlContent.get -> string
+Microsoft.Build.Tasks.XmlPeek.XmlContent.set -> void
+Microsoft.Build.Tasks.XmlPeek.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XmlPeek.XmlInputPath.set -> void
+Microsoft.Build.Tasks.XmlPeek.XmlPeek() -> void
+Microsoft.Build.Tasks.XmlPoke
+Microsoft.Build.Tasks.XmlPoke.Namespaces.get -> string
+Microsoft.Build.Tasks.XmlPoke.Namespaces.set -> void
+Microsoft.Build.Tasks.XmlPoke.Query.get -> string
+Microsoft.Build.Tasks.XmlPoke.Query.set -> void
+Microsoft.Build.Tasks.XmlPoke.Value.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XmlPoke.Value.set -> void
+Microsoft.Build.Tasks.XmlPoke.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XmlPoke.XmlInputPath.set -> void
+Microsoft.Build.Tasks.XmlPoke.XmlPoke() -> void
+Microsoft.Build.Tasks.XslTransformation
+Microsoft.Build.Tasks.XslTransformation.OutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.XslTransformation.OutputPaths.set -> void
+Microsoft.Build.Tasks.XslTransformation.Parameters.get -> string
+Microsoft.Build.Tasks.XslTransformation.Parameters.set -> void
+Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.get -> bool
+Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.set -> void
+Microsoft.Build.Tasks.XslTransformation.XmlContent.get -> string
+Microsoft.Build.Tasks.XslTransformation.XmlContent.set -> void
+Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslContent.get -> string
+Microsoft.Build.Tasks.XslTransformation.XslContent.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslInputPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XslTransformation.XslInputPath.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslTransformation() -> void
+Microsoft.Build.Tasks.ZipDirectory
+Microsoft.Build.Tasks.ZipDirectory.DestinationFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ZipDirectory.DestinationFile.set -> void
+Microsoft.Build.Tasks.ZipDirectory.Overwrite.get -> bool
+Microsoft.Build.Tasks.ZipDirectory.Overwrite.set -> void
+Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.set -> void
+Microsoft.Build.Tasks.ZipDirectory.ZipDirectory() -> void
+override Microsoft.Build.Tasks.AL.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.AL.Execute() -> bool
+override Microsoft.Build.Tasks.AL.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.AL.ToolName.get -> string
+override Microsoft.Build.Tasks.AspNetCompiler.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.AspNetCompiler.Execute() -> bool
+override Microsoft.Build.Tasks.AspNetCompiler.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.AspNetCompiler.ToolName.get -> string
+override Microsoft.Build.Tasks.AspNetCompiler.ValidateParameters() -> bool
+override Microsoft.Build.Tasks.AssignCulture.Execute() -> bool
+override Microsoft.Build.Tasks.AssignLinkMetadata.Execute() -> bool
+override Microsoft.Build.Tasks.AssignProjectConfiguration.Execute() -> bool
+override Microsoft.Build.Tasks.AssignTargetPath.Execute() -> bool
+override Microsoft.Build.Tasks.CallTarget.Execute() -> bool
+override Microsoft.Build.Tasks.CombinePath.Execute() -> bool
+override Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Execute() -> bool
+override Microsoft.Build.Tasks.CombineXmlElements.Execute() -> bool
+override Microsoft.Build.Tasks.ConvertToAbsolutePath.Execute() -> bool
+override Microsoft.Build.Tasks.Copy.Execute() -> bool
+override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
+override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.IsSourceFile(string fileName) -> bool
+override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.SourceFileExtension.get -> string
+override Microsoft.Build.Tasks.CreateItem.Execute() -> bool
+override Microsoft.Build.Tasks.CreateManifestResourceName.Execute() -> bool
+override Microsoft.Build.Tasks.CreateProperty.Execute() -> bool
+override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
+override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.IsSourceFile(string fileName) -> bool
+override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.SourceFileExtension.get -> string
+override Microsoft.Build.Tasks.Delete.Execute() -> bool
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.set -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Validate() -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.set -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Validate() -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ToString() -> string
+override Microsoft.Build.Tasks.DownloadFile.Execute() -> bool
+override Microsoft.Build.Tasks.Error.Execute() -> bool
+override Microsoft.Build.Tasks.ErrorFromResources.Execute() -> bool
+override Microsoft.Build.Tasks.Exec.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.Exec.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
+override Microsoft.Build.Tasks.Exec.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.Exec.GetWorkingDirectory() -> string
+override Microsoft.Build.Tasks.Exec.HandleTaskExecutionErrors() -> bool
+override Microsoft.Build.Tasks.Exec.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
+override Microsoft.Build.Tasks.Exec.LogPathToTool(string toolName, string pathToTool) -> void
+override Microsoft.Build.Tasks.Exec.LogToolCommand(string message) -> void
+override Microsoft.Build.Tasks.Exec.StandardErrorEncoding.get -> System.Text.Encoding
+override Microsoft.Build.Tasks.Exec.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+override Microsoft.Build.Tasks.Exec.StandardOutputEncoding.get -> System.Text.Encoding
+override Microsoft.Build.Tasks.Exec.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+override Microsoft.Build.Tasks.Exec.ToolName.get -> string
+override Microsoft.Build.Tasks.Exec.ValidateParameters() -> bool
+override Microsoft.Build.Tasks.FindAppConfigFile.Execute() -> bool
+override Microsoft.Build.Tasks.FindInList.Execute() -> bool
+override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
+override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
+override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
+override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateBootstrapper.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateTrustInfo.Execute() -> bool
+override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
+override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
+override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
+override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
+override Microsoft.Build.Tasks.GetFrameworkSdkPath.Execute() -> bool
+override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
+override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
+override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
+override Microsoft.Build.Tasks.Hash.Execute() -> bool
+override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.LC.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.LC.ToolName.get -> string
+override Microsoft.Build.Tasks.LC.ValidateParameters() -> bool
+override Microsoft.Build.Tasks.MakeDir.Execute() -> bool
+override Microsoft.Build.Tasks.Message.Execute() -> bool
+override Microsoft.Build.Tasks.Move.Execute() -> bool
+override Microsoft.Build.Tasks.MSBuild.Execute() -> bool
+override Microsoft.Build.Tasks.ReadLinesFromFile.Execute() -> bool
+override Microsoft.Build.Tasks.RegisterAssembly.Execute() -> bool
+override Microsoft.Build.Tasks.RemoveDir.Execute() -> bool
+override Microsoft.Build.Tasks.RemoveDuplicates.Execute() -> bool
+override Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveAssemblyReference.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveNativeReference.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
+override Microsoft.Build.Tasks.SGen.GenerateCommandLineCommands() -> string
+override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.SGen.SkipTaskExecution() -> bool
+override Microsoft.Build.Tasks.SGen.ToolName.get -> string
+override Microsoft.Build.Tasks.SGen.ValidateParameters() -> bool
+override Microsoft.Build.Tasks.SignFile.Execute() -> bool
+override Microsoft.Build.Tasks.TaskLoggingHelperExtension.FormatResourceString(string resourceName, params object[] args) -> string
+override Microsoft.Build.Tasks.Telemetry.Execute() -> bool
+override Microsoft.Build.Tasks.Touch.Execute() -> bool
+override Microsoft.Build.Tasks.UnregisterAssembly.Execute() -> bool
+override Microsoft.Build.Tasks.Unzip.Execute() -> bool
+override Microsoft.Build.Tasks.UpdateManifest.Execute() -> bool
+override Microsoft.Build.Tasks.VerifyFileHash.Execute() -> bool
+override Microsoft.Build.Tasks.Warning.Execute() -> bool
+override Microsoft.Build.Tasks.WinMDExp.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.WinMDExp.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.WinMDExp.SkipTaskExecution() -> bool
+override Microsoft.Build.Tasks.WinMDExp.StandardErrorEncoding.get -> System.Text.Encoding
+override Microsoft.Build.Tasks.WinMDExp.StandardOutputEncoding.get -> System.Text.Encoding
+override Microsoft.Build.Tasks.WinMDExp.ToolName.get -> string
+override Microsoft.Build.Tasks.WinMDExp.UseNewLineSeparatorInResponseFile.get -> bool
+override Microsoft.Build.Tasks.WinMDExp.ValidateParameters() -> bool
+override Microsoft.Build.Tasks.WriteCodeFragment.Execute() -> bool
+override Microsoft.Build.Tasks.WriteLinesToFile.Execute() -> bool
+override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.Execute() -> bool
+override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateCommandLineCommands() -> string
+override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateResponseFileCommands() -> string
+override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.HandleTaskExecutionErrors() -> bool
+override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ResponseFileEncoding.get -> System.Text.Encoding
+override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateParameters() -> bool
+override Microsoft.Build.Tasks.XmlPeek.Execute() -> bool
+override Microsoft.Build.Tasks.XmlPoke.Execute() -> bool
+override Microsoft.Build.Tasks.XslTransformation.Execute() -> bool
+override Microsoft.Build.Tasks.ZipDirectory.Execute() -> bool
+override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureDeformatter
+override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureFormatter
+static Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettIdentifier(string name) -> string
+static Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.XmlToConfigurationFile(System.Xml.XmlNode input) -> string
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromAssemblyName(string assemblyName) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromFile(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManagedAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManifest(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromNativeAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.ComputeZonePermissionSet(string targetZone, System.Security.PermissionSet includedPermissionSet, string[] excludedPermissions) -> System.Security.PermissionSet
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.IdentityListToPermissionSet(string[] ids) -> System.Security.PermissionSet
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.PermissionSetToIdentityList(System.Security.PermissionSet permissionSet) -> string[]
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.XmlToPermissionSet(System.Xml.XmlElement element) -> System.Security.PermissionSet
+System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
+System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
+virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.set -> void
+virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Validate() -> void
+virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateInputs() -> bool
+virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateOutput() -> bool
+virtual Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AcceptableNonZeroExitCodes.get -> string[]
+virtual Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AcceptableNonZeroExitCodes.set -> void
\ No newline at end of file
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..37b2642bb9b
--- /dev/null
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -0,0 +1,1900 @@
+abstract Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream) -> string
+abstract Microsoft.Build.Tasks.CreateManifestResourceName.IsSourceFile(string fileName) -> bool
+abstract Microsoft.Build.Tasks.CreateManifestResourceName.SourceFileExtension.get -> string
+abstract Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SortName.get -> string
+abstract Microsoft.Build.Tasks.GenerateManifestBase.GetObjectType() -> System.Type
+abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
+abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
+Microsoft.Build.Tasks.AssignCulture
+Microsoft.Build.Tasks.AssignCulture.AssignCulture() -> void
+Microsoft.Build.Tasks.AssignCulture.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignCulture.Files.set -> void
+Microsoft.Build.Tasks.AssignLinkMetadata
+Microsoft.Build.Tasks.AssignLinkMetadata.AssignLinkMetadata() -> void
+Microsoft.Build.Tasks.AssignLinkMetadata.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignLinkMetadata.Items.set -> void
+Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration
+Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.AssignProjectConfiguration() -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.get -> bool
+Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.set -> void
+Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.get -> string
+Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.set -> void
+Microsoft.Build.Tasks.AssignTargetPath
+Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignTargetPath.AssignTargetPath() -> void
+Microsoft.Build.Tasks.AssignTargetPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.AssignTargetPath.Files.set -> void
+Microsoft.Build.Tasks.AssignTargetPath.RootFolder.get -> string
+Microsoft.Build.Tasks.AssignTargetPath.RootFolder.set -> void
+Microsoft.Build.Tasks.CallTarget
+Microsoft.Build.Tasks.CallTarget.CallTarget() -> void
+Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.get -> bool
+Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.set -> void
+Microsoft.Build.Tasks.CallTarget.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CallTarget.Targets.get -> string[]
+Microsoft.Build.Tasks.CallTarget.Targets.set -> void
+Microsoft.Build.Tasks.CallTarget.UseResultsCache.get -> bool
+Microsoft.Build.Tasks.CallTarget.UseResultsCache.set -> void
+Microsoft.Build.Tasks.CodeTaskFactory
+Microsoft.Build.Tasks.CodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Tasks.CodeTaskFactory.CodeTaskFactory() -> void
+Microsoft.Build.Tasks.CodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Tasks.CodeTaskFactory.FactoryName.get -> string
+Microsoft.Build.Tasks.CodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Tasks.CodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Tasks.CodeTaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Tasks.CombinePath
+Microsoft.Build.Tasks.CombinePath.BasePath.get -> string
+Microsoft.Build.Tasks.CombinePath.BasePath.set -> void
+Microsoft.Build.Tasks.CombinePath.CombinedPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombinePath.CombinedPaths.set -> void
+Microsoft.Build.Tasks.CombinePath.CombinePath() -> void
+Microsoft.Build.Tasks.CombinePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombinePath.Paths.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.CombineTargetFrameworkInfoProperties() -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.get -> string
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.get -> string
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.set -> void
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.get -> bool
+Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.set -> void
+Microsoft.Build.Tasks.CombineXmlElements
+Microsoft.Build.Tasks.CombineXmlElements.CombineXmlElements() -> void
+Microsoft.Build.Tasks.CombineXmlElements.Result.get -> string
+Microsoft.Build.Tasks.CombineXmlElements.Result.set -> void
+Microsoft.Build.Tasks.CombineXmlElements.RootElementName.get -> string
+Microsoft.Build.Tasks.CombineXmlElements.RootElementName.set -> void
+Microsoft.Build.Tasks.CombineXmlElements.XmlElements.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CombineXmlElements.XmlElements.set -> void
+Microsoft.Build.Tasks.CommandLineBuilderExtension
+Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension() -> void
+Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
+Microsoft.Build.Tasks.CommandLineBuilderExtension.GetQuotedText(string unquotedText) -> string
+Microsoft.Build.Tasks.ConvertToAbsolutePath
+Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.set -> void
+Microsoft.Build.Tasks.ConvertToAbsolutePath.ConvertToAbsolutePath() -> void
+Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.set -> void
+Microsoft.Build.Tasks.Copy
+Microsoft.Build.Tasks.Copy.Cancel() -> void
+Microsoft.Build.Tasks.Copy.CopiedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Copy.Copy() -> void
+Microsoft.Build.Tasks.Copy.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Copy.DestinationFiles.set -> void
+Microsoft.Build.Tasks.Copy.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.Copy.DestinationFolder.set -> void
+Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.get -> bool
+Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.set -> void
+Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.get -> bool
+Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.set -> void
+Microsoft.Build.Tasks.Copy.Retries.get -> int
+Microsoft.Build.Tasks.Copy.Retries.set -> void
+Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.get -> int
+Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.set -> void
+Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.get -> bool
+Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.set -> void
+Microsoft.Build.Tasks.Copy.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Copy.SourceFiles.set -> void
+Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.get -> bool
+Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.set -> void
+Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.get -> bool
+Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.set -> void
+Microsoft.Build.Tasks.Copy.WroteAtLeastOneFile.get -> bool
+Microsoft.Build.Tasks.CreateCSharpManifestResourceName
+Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateCSharpManifestResourceName() -> void
+Microsoft.Build.Tasks.CreateItem
+Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.get -> string[]
+Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.set -> void
+Microsoft.Build.Tasks.CreateItem.CreateItem() -> void
+Microsoft.Build.Tasks.CreateItem.Exclude.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateItem.Exclude.set -> void
+Microsoft.Build.Tasks.CreateItem.Include.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateItem.Include.set -> void
+Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.get -> bool
+Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName
+Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestResourceName() -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.itemSpecToTaskitem -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem>
+Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.get -> bool
+Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.get -> string
+Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.set -> void
+Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.get -> bool
+Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.set -> void
+Microsoft.Build.Tasks.CreateProperty
+Microsoft.Build.Tasks.CreateProperty.CreateProperty() -> void
+Microsoft.Build.Tasks.CreateProperty.Value.get -> string[]
+Microsoft.Build.Tasks.CreateProperty.Value.set -> void
+Microsoft.Build.Tasks.CreateProperty.ValueSetByTask.get -> string[]
+Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName
+Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateVisualBasicManifestResourceName() -> void
+Microsoft.Build.Tasks.Delete
+Microsoft.Build.Tasks.Delete.Cancel() -> void
+Microsoft.Build.Tasks.Delete.Delete() -> void
+Microsoft.Build.Tasks.Delete.DeletedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Delete.DeletedFiles.set -> void
+Microsoft.Build.Tasks.Delete.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Delete.Files.set -> void
+Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.get -> bool
+Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder() -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder(string visualStudioVersion) -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) -> string[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpId.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Message.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Error = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Info = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Warning = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.ComponentFiles.get -> string[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.KeyFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Succeeded.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.BuildSettings() -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Absolute = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Relative = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpId.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Message.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles.get -> string[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.KeyFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Succeeded.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.get -> bool
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.set -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Name.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductCode.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Name.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Product() -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductCode.get -> string
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest(string targetFrameworkVersion) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.FileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.All = Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture | Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Default = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsFrameworkAssembly.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsInFramework(string frameworkIdentifier, string frameworkVersion) -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsNeutralPlatform.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsStrongName.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.AssemblyManifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(string name) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ClickOnceManifest = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ManagedAssembly = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.NativeAssembly = 3 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.Unspecified = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.get -> long
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ClsId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ComClass() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.Description.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ThreadingModel.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.TlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.CompatibleFramework() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest(string targetFrameworkMoniker) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.FileAssociation() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Count.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.Build(string filename, string outputPath) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherBuilder(string launcherPath) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.FileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.get -> System.IO.Stream
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Manifest() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.OutputMessages.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles(string[] searchPaths) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo(string targetFrameworkVersion) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ValidatePlatform() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.GetArguments() -> string[]
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Text.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Type.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.ErrorCount.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.GetEnumerator() -> System.Collections.IEnumerator
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.WarningCount.get -> int
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Error = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Info = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Warning = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.BaseInterface.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.IID.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.NumMethods.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.ProxyStub() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.TlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Clear() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.HasUnmanagedCodePermission.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.IO.Stream input) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.IO.Stream input) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.TrustInfo() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.IO.Stream output) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(string path) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream input, System.IO.Stream output) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream output) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Flags.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.HelpDirectory.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.ResourceId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TypeLib() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Version.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Background = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Foreground = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Days = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Hours = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Weeks = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Name.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Versioned.get -> bool
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass() -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass(string name, bool versioned) -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.set -> void
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.get -> string
+Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.set -> void
+Microsoft.Build.Tasks.DownloadFile
+Microsoft.Build.Tasks.DownloadFile.Cancel() -> void
+Microsoft.Build.Tasks.DownloadFile.DestinationFileName.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.DownloadFile.DestinationFileName.set -> void
+Microsoft.Build.Tasks.DownloadFile.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.DownloadFile.DestinationFolder.set -> void
+Microsoft.Build.Tasks.DownloadFile.DownloadedFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.DownloadFile.DownloadedFile.set -> void
+Microsoft.Build.Tasks.DownloadFile.DownloadFile() -> void
+Microsoft.Build.Tasks.DownloadFile.Retries.get -> int
+Microsoft.Build.Tasks.DownloadFile.Retries.set -> void
+Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.get -> int
+Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.set -> void
+Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
+Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
+Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
+Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
+Microsoft.Build.Tasks.Error
+Microsoft.Build.Tasks.Error.Code.get -> string
+Microsoft.Build.Tasks.Error.Code.set -> void
+Microsoft.Build.Tasks.Error.Error() -> void
+Microsoft.Build.Tasks.Error.File.get -> string
+Microsoft.Build.Tasks.Error.File.set -> void
+Microsoft.Build.Tasks.Error.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Error.HelpKeyword.set -> void
+Microsoft.Build.Tasks.Error.HelpLink.get -> string
+Microsoft.Build.Tasks.Error.HelpLink.set -> void
+Microsoft.Build.Tasks.Error.Text.get -> string
+Microsoft.Build.Tasks.Error.Text.set -> void
+Microsoft.Build.Tasks.ErrorFromResources
+Microsoft.Build.Tasks.ErrorFromResources.Arguments.get -> string[]
+Microsoft.Build.Tasks.ErrorFromResources.Arguments.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.Code.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.Code.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.ErrorFromResources() -> void
+Microsoft.Build.Tasks.ErrorFromResources.File.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.File.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.set -> void
+Microsoft.Build.Tasks.ErrorFromResources.Resource.get -> string
+Microsoft.Build.Tasks.ErrorFromResources.Resource.set -> void
+Microsoft.Build.Tasks.Exec
+Microsoft.Build.Tasks.Exec.Command.get -> string
+Microsoft.Build.Tasks.Exec.Command.set -> void
+Microsoft.Build.Tasks.Exec.ConsoleOutput.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.get -> bool
+Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.set -> void
+Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.get -> string
+Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.set -> void
+Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.get -> string
+Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.set -> void
+Microsoft.Build.Tasks.Exec.Exec() -> void
+Microsoft.Build.Tasks.Exec.IgnoreExitCode.get -> bool
+Microsoft.Build.Tasks.Exec.IgnoreExitCode.set -> void
+Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.get -> bool
+Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.set -> void
+Microsoft.Build.Tasks.Exec.Outputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Exec.Outputs.set -> void
+Microsoft.Build.Tasks.Exec.StdErrEncoding.get -> string
+Microsoft.Build.Tasks.Exec.StdErrEncoding.set -> void
+Microsoft.Build.Tasks.Exec.StdOutEncoding.get -> string
+Microsoft.Build.Tasks.Exec.StdOutEncoding.set -> void
+Microsoft.Build.Tasks.Exec.WorkingDirectory.get -> string
+Microsoft.Build.Tasks.Exec.WorkingDirectory.set -> void
+Microsoft.Build.Tasks.ExtractedClassName
+Microsoft.Build.Tasks.ExtractedClassName.ExtractedClassName() -> void
+Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.get -> bool
+Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.set -> void
+Microsoft.Build.Tasks.ExtractedClassName.Name.get -> string
+Microsoft.Build.Tasks.ExtractedClassName.Name.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile
+Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile.FindAppConfigFile() -> void
+Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.set -> void
+Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.get -> string
+Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.set -> void
+Microsoft.Build.Tasks.FindInList
+Microsoft.Build.Tasks.FindInList.CaseSensitive.get -> bool
+Microsoft.Build.Tasks.FindInList.CaseSensitive.set -> void
+Microsoft.Build.Tasks.FindInList.FindInList() -> void
+Microsoft.Build.Tasks.FindInList.FindLastMatch.get -> bool
+Microsoft.Build.Tasks.FindInList.FindLastMatch.set -> void
+Microsoft.Build.Tasks.FindInList.ItemFound.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.FindInList.ItemFound.set -> void
+Microsoft.Build.Tasks.FindInList.ItemSpecToFind.get -> string
+Microsoft.Build.Tasks.FindInList.ItemSpecToFind.set -> void
+Microsoft.Build.Tasks.FindInList.List.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindInList.List.set -> void
+Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.get -> bool
+Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.set -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences
+Microsoft.Build.Tasks.FindInvalidProjectReferences.FindInvalidProjectReferences() -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences.InvalidReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.set -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.FindUnderPath
+Microsoft.Build.Tasks.FindUnderPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindUnderPath.Files.set -> void
+Microsoft.Build.Tasks.FindUnderPath.FindUnderPath() -> void
+Microsoft.Build.Tasks.FindUnderPath.InPath.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindUnderPath.InPath.set -> void
+Microsoft.Build.Tasks.FindUnderPath.OutOfPath.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.FindUnderPath.OutOfPath.set -> void
+Microsoft.Build.Tasks.FindUnderPath.Path.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.FindUnderPath.Path.set -> void
+Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.get -> bool
+Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.set -> void
+Microsoft.Build.Tasks.FormatUrl
+Microsoft.Build.Tasks.FormatUrl.FormatUrl() -> void
+Microsoft.Build.Tasks.FormatUrl.InputUrl.get -> string
+Microsoft.Build.Tasks.FormatUrl.InputUrl.set -> void
+Microsoft.Build.Tasks.FormatUrl.OutputUrl.get -> string
+Microsoft.Build.Tasks.FormatUrl.OutputUrl.set -> void
+Microsoft.Build.Tasks.FormatVersion
+Microsoft.Build.Tasks.FormatVersion.FormatType.get -> string
+Microsoft.Build.Tasks.FormatVersion.FormatType.set -> void
+Microsoft.Build.Tasks.FormatVersion.FormatVersion() -> void
+Microsoft.Build.Tasks.FormatVersion.OutputVersion.get -> string
+Microsoft.Build.Tasks.FormatVersion.OutputVersion.set -> void
+Microsoft.Build.Tasks.FormatVersion.Revision.get -> int
+Microsoft.Build.Tasks.FormatVersion.Revision.set -> void
+Microsoft.Build.Tasks.FormatVersion.Version.get -> string
+Microsoft.Build.Tasks.FormatVersion.Version.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest
+Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.Files.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.GenerateApplicationManifest() -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.get -> bool
+Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Product.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.Product.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.get -> bool
+Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.get -> string
+Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.set -> void
+Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.get -> bool
+Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects
+Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.GenerateBindingRedirects() -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.set -> void
+Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.get -> string
+Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest
+Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.GenerateDeploymentManifest() -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.get -> bool
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.get -> int
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.set -> void
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.get -> string
+Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.set -> void
+Microsoft.Build.Tasks.GenerateLauncher
+Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.GenerateLauncher() -> void
+Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.OutputPath.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.OutputPath.set -> void
+Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.get -> string
+Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase
+Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.GenerateManifestBase.AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+Microsoft.Build.Tasks.GenerateManifestBase.AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.Description.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.Description.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
+Microsoft.Build.Tasks.GenerateManifestBase.GenerateManifestBase() -> void
+Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.get -> bool
+Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.get -> int
+Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.Platform.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.Platform.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.GenerateResource
+Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.set -> void
+Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.get -> string[]
+Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.set -> void
+Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.set -> void
+Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.get -> bool
+Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.set -> void
+Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.get -> bool
+Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.set -> void
+Microsoft.Build.Tasks.GenerateResource.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.GenerateResource() -> void
+Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.get -> bool
+Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.set -> void
+Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.get -> bool
+Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.set -> void
+Microsoft.Build.Tasks.GenerateResource.OutputDirectory.get -> string
+Microsoft.Build.Tasks.GenerateResource.OutputDirectory.set -> void
+Microsoft.Build.Tasks.GenerateResource.OutputResources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.OutputResources.set -> void
+Microsoft.Build.Tasks.GenerateResource.PublicClass.get -> bool
+Microsoft.Build.Tasks.GenerateResource.PublicClass.set -> void
+Microsoft.Build.Tasks.GenerateResource.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.References.set -> void
+Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.GenerateResource.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.Sources.set -> void
+Microsoft.Build.Tasks.GenerateResource.StateFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.GenerateResource.StateFile.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.set -> void
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.get -> string
+Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.set -> void
+Microsoft.Build.Tasks.GenerateResource.TLogReadFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.TLogWriteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.get -> string
+Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.get -> string
+Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.get -> string
+Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.get -> string
+Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.set -> void
+Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.get -> bool
+Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.set -> void
+Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.get -> bool
+Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.set -> void
+Microsoft.Build.Tasks.GenerateResource.UseSourcePath.get -> bool
+Microsoft.Build.Tasks.GenerateResource.UseSourcePath.set -> void
+Microsoft.Build.Tasks.GetAssemblyIdentity
+Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.set -> void
+Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.set -> void
+Microsoft.Build.Tasks.GetAssemblyIdentity.GetAssemblyIdentity() -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform
+Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.set -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.set -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.get -> string
+Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.set -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.GetCompatiblePlatform() -> void
+Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.get -> string
+Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.set -> void
+Microsoft.Build.Tasks.GetFileHash
+Microsoft.Build.Tasks.GetFileHash.Algorithm.get -> string
+Microsoft.Build.Tasks.GetFileHash.Algorithm.set -> void
+Microsoft.Build.Tasks.GetFileHash.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetFileHash.Files.set -> void
+Microsoft.Build.Tasks.GetFileHash.GetFileHash() -> void
+Microsoft.Build.Tasks.GetFileHash.Hash.get -> string
+Microsoft.Build.Tasks.GetFileHash.Hash.set -> void
+Microsoft.Build.Tasks.GetFileHash.HashEncoding.get -> string
+Microsoft.Build.Tasks.GetFileHash.HashEncoding.set -> void
+Microsoft.Build.Tasks.GetFileHash.Items.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetFileHash.Items.set -> void
+Microsoft.Build.Tasks.GetFileHash.MetadataName.get -> string
+Microsoft.Build.Tasks.GetFileHash.MetadataName.set -> void
+Microsoft.Build.Tasks.GetFrameworkPath
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion11Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion20Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion30Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion35Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion40Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion451Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion452Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion45Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion462Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion46Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion471Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion472Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
+Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
+Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.FullFrameworkReferenceAssemblyPaths.get -> string[]
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.GetReferenceAssemblyPaths() -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.ReferenceAssemblyPaths.get -> string[]
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.get -> bool
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
+Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
+Microsoft.Build.Tasks.Hash
+Microsoft.Build.Tasks.Hash.Hash() -> void
+Microsoft.Build.Tasks.Hash.HashResult.get -> string
+Microsoft.Build.Tasks.Hash.HashResult.set -> void
+Microsoft.Build.Tasks.Hash.IgnoreCase.get -> bool
+Microsoft.Build.Tasks.Hash.IgnoreCase.set -> void
+Microsoft.Build.Tasks.Hash.ItemsToHash.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Hash.ItemsToHash.set -> void
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles) -> bool
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers) -> bool
+Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetRuleSet(string ruleSetFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject
+Microsoft.Build.Tasks.Hosting.ICscHostObject.BeginInitialization() -> void
+Microsoft.Build.Tasks.Hosting.ICscHostObject.Compile() -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(out string errorMessage, out int errorCode) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.IsDesignTime() -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.IsUpToDate() -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAddModules(string[] addModules) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAllowUnsafeBlocks(bool allowUnsafeBlocks) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetBaseAddress(string baseAddress) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCodePage(int codePage) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDebugType(string debugType) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDefineConstants(string defineConstants) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDelaySign(bool delaySignExplicitlySet, bool delaySign) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDocumentationFile(string documentationFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetEmitDebugInformation(bool emitDebugInformation) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetErrorReport(string errorReport) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetFileAlignment(int fileAlignment) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetGenerateFullPaths(bool generateFullPaths) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyContainer(string keyContainer) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyFile(string keyFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLangVersion(string langVersion) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetMainEntryPoint(string targetType, string mainEntryPoint) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetModuleAssemblyName(string moduleAssemblyName) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoConfig(bool noConfig) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoStandardLib(bool noStandardLib) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOptimize(bool optimize) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOutputAssembly(string outputAssembly) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPdbFile(string pdbFile) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPlatform(string platform) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTargetType(string targetType) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningLevel(int warningLevel) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Icon(string win32Icon) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Resource(string win32Resource) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject2
+Microsoft.Build.Tasks.Hosting.ICscHostObject2.SetWin32Manifest(string win32Manifest) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject3
+Microsoft.Build.Tasks.Hosting.ICscHostObject3.SetApplicationConfiguration(string applicationConfiguration) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject4
+Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetHighEntropyVA(bool highEntropyVA) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
+Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetSubsystemVersion(string subsystemVersion) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.BeginInitialization() -> void
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.Compile() -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.EndInitialization() -> void
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsDesignTime() -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsUpToDate() -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAddModules(string[] addModules) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetBaseAddress(string targetType, string baseAddress) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetCodePage(int codePage) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDebugType(bool emitDebugInformation, string debugType) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDefineConstants(string defineConstants) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDelaySign(bool delaySign) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDocumentationFile(string documentationFile) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetErrorReport(string errorReport) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetFileAlignment(int fileAlignment) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetGenerateDocumentation(bool generateDocumentation) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetImports(Microsoft.Build.Framework.ITaskItem[] importsList) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyContainer(string keyContainer) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyFile(string keyFile) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetMainEntryPoint(string mainEntryPoint) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoConfig(bool noConfig) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoStandardLib(bool noStandardLib) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoWarnings(bool noWarnings) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptimize(bool optimize) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionCompare(string optionCompare) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionExplicit(bool optionExplicit) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrict(bool optionStrict) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrictType(string optionStrictType) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOutputAssembly(string outputAssembly) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetPlatform(string platform) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(bool removeIntegerChecks) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRootNamespace(string rootNamespace) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSdkPath(string sdkPath) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetCompactFramework(bool targetCompactFramework) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetType(string targetType) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Icon(string win32Icon) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Resource(string win32Resource) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetModuleAssemblyName(string moduleAssemblyName) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetOptionInfer(bool optionInfer) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetWin32Manifest(string win32Manifest) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject3
+Microsoft.Build.Tasks.Hosting.IVbcHostObject3.SetLanguageVersion(string languageVersion) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject4
+Microsoft.Build.Tasks.Hosting.IVbcHostObject4.SetVBRuntime(string VBRuntime) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent) -> int
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.EndCompile(bool buildSuccess) -> int
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.GetFreeThreadedHostObject() -> Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetHighEntropyVA(bool highEntropyVA) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
+Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
+Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
+Microsoft.Build.Tasks.MakeDir
+Microsoft.Build.Tasks.MakeDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MakeDir.Directories.set -> void
+Microsoft.Build.Tasks.MakeDir.DirectoriesCreated.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MakeDir.MakeDir() -> void
+Microsoft.Build.Tasks.Message
+Microsoft.Build.Tasks.Message.Code.get -> string
+Microsoft.Build.Tasks.Message.Code.set -> void
+Microsoft.Build.Tasks.Message.File.get -> string
+Microsoft.Build.Tasks.Message.File.set -> void
+Microsoft.Build.Tasks.Message.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Message.HelpKeyword.set -> void
+Microsoft.Build.Tasks.Message.Importance.get -> string
+Microsoft.Build.Tasks.Message.Importance.set -> void
+Microsoft.Build.Tasks.Message.IsCritical.get -> bool
+Microsoft.Build.Tasks.Message.IsCritical.set -> void
+Microsoft.Build.Tasks.Message.Message() -> void
+Microsoft.Build.Tasks.Message.Text.get -> string
+Microsoft.Build.Tasks.Message.Text.set -> void
+Microsoft.Build.Tasks.Move
+Microsoft.Build.Tasks.Move.Cancel() -> void
+Microsoft.Build.Tasks.Move.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Move.DestinationFiles.set -> void
+Microsoft.Build.Tasks.Move.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.Move.DestinationFolder.set -> void
+Microsoft.Build.Tasks.Move.Move() -> void
+Microsoft.Build.Tasks.Move.MovedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.get -> bool
+Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.set -> void
+Microsoft.Build.Tasks.Move.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Move.SourceFiles.set -> void
+Microsoft.Build.Tasks.MSBuild
+Microsoft.Build.Tasks.MSBuild.BuildInParallel.get -> bool
+Microsoft.Build.Tasks.MSBuild.BuildInParallel.set -> void
+Microsoft.Build.Tasks.MSBuild.MSBuild() -> void
+Microsoft.Build.Tasks.MSBuild.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MSBuild.Projects.set -> void
+Microsoft.Build.Tasks.MSBuild.Properties.get -> string[]
+Microsoft.Build.Tasks.MSBuild.Properties.set -> void
+Microsoft.Build.Tasks.MSBuild.RebaseOutputs.get -> bool
+Microsoft.Build.Tasks.MSBuild.RebaseOutputs.set -> void
+Microsoft.Build.Tasks.MSBuild.RemoveProperties.get -> string
+Microsoft.Build.Tasks.MSBuild.RemoveProperties.set -> void
+Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.get -> bool
+Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.set -> void
+Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.get -> string
+Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.set -> void
+Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.get -> bool
+Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.set -> void
+Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.get -> string[]
+Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.set -> void
+Microsoft.Build.Tasks.MSBuild.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.MSBuild.Targets.get -> string[]
+Microsoft.Build.Tasks.MSBuild.Targets.set -> void
+Microsoft.Build.Tasks.MSBuild.ToolsVersion.get -> string
+Microsoft.Build.Tasks.MSBuild.ToolsVersion.set -> void
+Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.get -> bool
+Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.set -> void
+Microsoft.Build.Tasks.MSBuild.UseResultsCache.get -> bool
+Microsoft.Build.Tasks.MSBuild.UseResultsCache.set -> void
+Microsoft.Build.Tasks.ReadLinesFromFile
+Microsoft.Build.Tasks.ReadLinesFromFile.File.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ReadLinesFromFile.File.set -> void
+Microsoft.Build.Tasks.ReadLinesFromFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ReadLinesFromFile.Lines.set -> void
+Microsoft.Build.Tasks.ReadLinesFromFile.ReadLinesFromFile() -> void
+Microsoft.Build.Tasks.RemoveDir
+Microsoft.Build.Tasks.RemoveDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDir.Directories.set -> void
+Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.set -> void
+Microsoft.Build.Tasks.RemoveDir.RemoveDir() -> void
+Microsoft.Build.Tasks.RemoveDuplicates
+Microsoft.Build.Tasks.RemoveDuplicates.Filtered.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDuplicates.Filtered.set -> void
+Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.get -> bool
+Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.set -> void
+Microsoft.Build.Tasks.RemoveDuplicates.Inputs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.RemoveDuplicates.Inputs.set -> void
+Microsoft.Build.Tasks.RemoveDuplicates.RemoveDuplicates() -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnNETStandard.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnSystemRuntime.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolveAssemblyReference() -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.get -> string[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolvedAssemblyConflicts.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.get -> bool
+Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.set -> void
+Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.get -> string
+Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.get -> string
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.get -> string[]
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.get -> string
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.set -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolveCodeAnalysisRuleSet() -> void
+Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolvedCodeAnalysisRuleSet.get -> string
+Microsoft.Build.Tasks.ResolveComReference
+Microsoft.Build.Tasks.ResolveComReference.DelaySign.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.DelaySign.set -> void
+Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.get -> string[]
+Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.set -> void
+Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.set -> void
+Microsoft.Build.Tasks.ResolveComReference.KeyContainer.get -> string
+Microsoft.Build.Tasks.ResolveComReference.KeyContainer.set -> void
+Microsoft.Build.Tasks.ResolveComReference.KeyFile.get -> string
+Microsoft.Build.Tasks.ResolveComReference.KeyFile.set -> void
+Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolveComReference() -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.set -> void
+Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.set -> void
+Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.ResolveComReference.Silent.get -> bool
+Microsoft.Build.Tasks.ResolveComReference.Silent.set -> void
+Microsoft.Build.Tasks.ResolveComReference.StateFile.get -> string
+Microsoft.Build.Tasks.ResolveComReference.StateFile.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.get -> string
+Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.set -> void
+Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.set -> void
+Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.get -> string
+Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.set -> void
+Microsoft.Build.Tasks.ResolveKeySource
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.get -> int
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.get -> int
+Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.KeyFile.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.KeyFile.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.get -> string
+Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.ResolveKeySource() -> void
+Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.get -> bool
+Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.set -> void
+Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.get -> bool
+Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles
+Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.Files.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.ResolveManifestFiles() -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.get -> bool
+Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.set -> void
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.get -> string
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.set -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.set -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolveNonMSBuildProjectOutput() -> void
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.set -> void
+Microsoft.Build.Tasks.ResolveProjectBase
+Microsoft.Build.Tasks.ResolveProjectBase.AddSyntheticProjectReferences(string currentProjectAbsolutePath) -> void
+Microsoft.Build.Tasks.ResolveProjectBase.GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) -> System.Xml.XmlElement
+Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) -> string
+Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
+Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
+Microsoft.Build.Tasks.RoslynCodeTaskFactory
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.FactoryName.get -> string
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.RoslynCodeTaskFactory() -> void
+Microsoft.Build.Tasks.RoslynCodeTaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Tasks.SGen
+Microsoft.Build.Tasks.SGen.BuildAssemblyName.get -> string
+Microsoft.Build.Tasks.SGen.BuildAssemblyName.set -> void
+Microsoft.Build.Tasks.SGen.BuildAssemblyPath.get -> string
+Microsoft.Build.Tasks.SGen.BuildAssemblyPath.set -> void
+Microsoft.Build.Tasks.SGen.DelaySign.get -> bool
+Microsoft.Build.Tasks.SGen.DelaySign.set -> void
+Microsoft.Build.Tasks.SGen.KeyContainer.get -> string
+Microsoft.Build.Tasks.SGen.KeyContainer.set -> void
+Microsoft.Build.Tasks.SGen.KeyFile.get -> string
+Microsoft.Build.Tasks.SGen.KeyFile.set -> void
+Microsoft.Build.Tasks.SGen.Platform.get -> string
+Microsoft.Build.Tasks.SGen.Platform.set -> void
+Microsoft.Build.Tasks.SGen.References.get -> string[]
+Microsoft.Build.Tasks.SGen.References.set -> void
+Microsoft.Build.Tasks.SGen.SdkToolsPath.get -> string
+Microsoft.Build.Tasks.SGen.SdkToolsPath.set -> void
+Microsoft.Build.Tasks.SGen.SerializationAssembly.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.SGen.SerializationAssembly.set -> void
+Microsoft.Build.Tasks.SGen.SerializationAssemblyName.get -> string
+Microsoft.Build.Tasks.SGen.SGen() -> void
+Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.get -> bool
+Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.set -> void
+Microsoft.Build.Tasks.SGen.Types.get -> string[]
+Microsoft.Build.Tasks.SGen.Types.set -> void
+Microsoft.Build.Tasks.SGen.UseKeep.get -> bool
+Microsoft.Build.Tasks.SGen.UseKeep.set -> void
+Microsoft.Build.Tasks.SGen.UseProxyTypes.get -> bool
+Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
+Microsoft.Build.Tasks.SignFile
+Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
+Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.SignFile.SignFile() -> void
+Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
+Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.get -> string
+Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.set -> void
+Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.get -> string
+Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.set -> void
+Microsoft.Build.Tasks.SignFile.TimestampUrl.get -> string
+Microsoft.Build.Tasks.SignFile.TimestampUrl.set -> void
+Microsoft.Build.Tasks.TaskExtension
+Microsoft.Build.Tasks.TaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Tasks.TaskLoggingHelperExtension
+Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.set -> void
+Microsoft.Build.Tasks.Telemetry
+Microsoft.Build.Tasks.Telemetry.EventData.get -> string
+Microsoft.Build.Tasks.Telemetry.EventData.set -> void
+Microsoft.Build.Tasks.Telemetry.EventName.get -> string
+Microsoft.Build.Tasks.Telemetry.EventName.set -> void
+Microsoft.Build.Tasks.Telemetry.Telemetry() -> void
+Microsoft.Build.Tasks.ToolTaskExtension
+Microsoft.Build.Tasks.ToolTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Tasks.Touch
+Microsoft.Build.Tasks.Touch.AlwaysCreate.get -> bool
+Microsoft.Build.Tasks.Touch.AlwaysCreate.set -> void
+Microsoft.Build.Tasks.Touch.Files.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Touch.Files.set -> void
+Microsoft.Build.Tasks.Touch.ForceTouch.get -> bool
+Microsoft.Build.Tasks.Touch.ForceTouch.set -> void
+Microsoft.Build.Tasks.Touch.Time.get -> string
+Microsoft.Build.Tasks.Touch.Time.set -> void
+Microsoft.Build.Tasks.Touch.Touch() -> void
+Microsoft.Build.Tasks.Touch.TouchedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Touch.TouchedFiles.set -> void
+Microsoft.Build.Tasks.Unzip
+Microsoft.Build.Tasks.Unzip.Cancel() -> void
+Microsoft.Build.Tasks.Unzip.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.Unzip.DestinationFolder.set -> void
+Microsoft.Build.Tasks.Unzip.Exclude.get -> string
+Microsoft.Build.Tasks.Unzip.Exclude.set -> void
+Microsoft.Build.Tasks.Unzip.Include.get -> string
+Microsoft.Build.Tasks.Unzip.Include.set -> void
+Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.get -> bool
+Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.set -> void
+Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.get -> bool
+Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.set -> void
+Microsoft.Build.Tasks.Unzip.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.Unzip.SourceFiles.set -> void
+Microsoft.Build.Tasks.Unzip.Unzip() -> void
+Microsoft.Build.Tasks.VerifyFileHash
+Microsoft.Build.Tasks.VerifyFileHash.Algorithm.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.Algorithm.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.File.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.File.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.Hash.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.Hash.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.get -> string
+Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.set -> void
+Microsoft.Build.Tasks.VerifyFileHash.VerifyFileHash() -> void
+Microsoft.Build.Tasks.Warning
+Microsoft.Build.Tasks.Warning.Code.get -> string
+Microsoft.Build.Tasks.Warning.Code.set -> void
+Microsoft.Build.Tasks.Warning.File.get -> string
+Microsoft.Build.Tasks.Warning.File.set -> void
+Microsoft.Build.Tasks.Warning.HelpKeyword.get -> string
+Microsoft.Build.Tasks.Warning.HelpKeyword.set -> void
+Microsoft.Build.Tasks.Warning.HelpLink.get -> string
+Microsoft.Build.Tasks.Warning.HelpLink.set -> void
+Microsoft.Build.Tasks.Warning.Text.get -> string
+Microsoft.Build.Tasks.Warning.Text.set -> void
+Microsoft.Build.Tasks.Warning.Warning() -> void
+Microsoft.Build.Tasks.WriteCodeFragment
+Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.Language.get -> string
+Microsoft.Build.Tasks.WriteCodeFragment.Language.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.set -> void
+Microsoft.Build.Tasks.WriteCodeFragment.WriteCodeFragment() -> void
+Microsoft.Build.Tasks.WriteLinesToFile
+Microsoft.Build.Tasks.WriteLinesToFile.Encoding.get -> string
+Microsoft.Build.Tasks.WriteLinesToFile.Encoding.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.File.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.WriteLinesToFile.File.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.WriteLinesToFile.Lines.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.get -> bool
+Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.set -> void
+Microsoft.Build.Tasks.WriteLinesToFile.WriteLinesToFile() -> void
+Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.get -> bool
+Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.set -> void
+Microsoft.Build.Tasks.XamlTaskFactory
+Microsoft.Build.Tasks.XamlTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
+Microsoft.Build.Tasks.XamlTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
+Microsoft.Build.Tasks.XamlTaskFactory.FactoryName.get -> string
+Microsoft.Build.Tasks.XamlTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
+Microsoft.Build.Tasks.XamlTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
+Microsoft.Build.Tasks.XamlTaskFactory.TaskType.get -> System.Type
+Microsoft.Build.Tasks.XamlTaskFactory.XamlTaskFactory() -> void
+Microsoft.Build.Tasks.XmlPeek
+Microsoft.Build.Tasks.XmlPeek.Namespaces.get -> string
+Microsoft.Build.Tasks.XmlPeek.Namespaces.set -> void
+Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.get -> bool
+Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.set -> void
+Microsoft.Build.Tasks.XmlPeek.Query.get -> string
+Microsoft.Build.Tasks.XmlPeek.Query.set -> void
+Microsoft.Build.Tasks.XmlPeek.Result.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.XmlPeek.XmlContent.get -> string
+Microsoft.Build.Tasks.XmlPeek.XmlContent.set -> void
+Microsoft.Build.Tasks.XmlPeek.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XmlPeek.XmlInputPath.set -> void
+Microsoft.Build.Tasks.XmlPeek.XmlPeek() -> void
+Microsoft.Build.Tasks.XmlPoke
+Microsoft.Build.Tasks.XmlPoke.Namespaces.get -> string
+Microsoft.Build.Tasks.XmlPoke.Namespaces.set -> void
+Microsoft.Build.Tasks.XmlPoke.Query.get -> string
+Microsoft.Build.Tasks.XmlPoke.Query.set -> void
+Microsoft.Build.Tasks.XmlPoke.Value.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XmlPoke.Value.set -> void
+Microsoft.Build.Tasks.XmlPoke.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XmlPoke.XmlInputPath.set -> void
+Microsoft.Build.Tasks.XmlPoke.XmlPoke() -> void
+Microsoft.Build.Tasks.XslTransformation
+Microsoft.Build.Tasks.XslTransformation.OutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.XslTransformation.OutputPaths.set -> void
+Microsoft.Build.Tasks.XslTransformation.Parameters.get -> string
+Microsoft.Build.Tasks.XslTransformation.Parameters.set -> void
+Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.get -> bool
+Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.set -> void
+Microsoft.Build.Tasks.XslTransformation.XmlContent.get -> string
+Microsoft.Build.Tasks.XslTransformation.XmlContent.set -> void
+Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslContent.get -> string
+Microsoft.Build.Tasks.XslTransformation.XslContent.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslInputPath.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.XslTransformation.XslInputPath.set -> void
+Microsoft.Build.Tasks.XslTransformation.XslTransformation() -> void
+Microsoft.Build.Tasks.ZipDirectory
+Microsoft.Build.Tasks.ZipDirectory.DestinationFile.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ZipDirectory.DestinationFile.set -> void
+Microsoft.Build.Tasks.ZipDirectory.Overwrite.get -> bool
+Microsoft.Build.Tasks.ZipDirectory.Overwrite.set -> void
+Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.get -> Microsoft.Build.Framework.ITaskItem
+Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.set -> void
+Microsoft.Build.Tasks.ZipDirectory.ZipDirectory() -> void
+override Microsoft.Build.Tasks.AssignCulture.Execute() -> bool
+override Microsoft.Build.Tasks.AssignLinkMetadata.Execute() -> bool
+override Microsoft.Build.Tasks.AssignProjectConfiguration.Execute() -> bool
+override Microsoft.Build.Tasks.AssignTargetPath.Execute() -> bool
+override Microsoft.Build.Tasks.CallTarget.Execute() -> bool
+override Microsoft.Build.Tasks.CombinePath.Execute() -> bool
+override Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Execute() -> bool
+override Microsoft.Build.Tasks.CombineXmlElements.Execute() -> bool
+override Microsoft.Build.Tasks.ConvertToAbsolutePath.Execute() -> bool
+override Microsoft.Build.Tasks.Copy.Execute() -> bool
+override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
+override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.IsSourceFile(string fileName) -> bool
+override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.SourceFileExtension.get -> string
+override Microsoft.Build.Tasks.CreateItem.Execute() -> bool
+override Microsoft.Build.Tasks.CreateManifestResourceName.Execute() -> bool
+override Microsoft.Build.Tasks.CreateProperty.Execute() -> bool
+override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
+override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.IsSourceFile(string fileName) -> bool
+override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.SourceFileExtension.get -> string
+override Microsoft.Build.Tasks.Delete.Execute() -> bool
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.set -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Validate() -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.set -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Validate() -> void
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ToString() -> string
+override Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ToString() -> string
+override Microsoft.Build.Tasks.DownloadFile.Execute() -> bool
+override Microsoft.Build.Tasks.Error.Execute() -> bool
+override Microsoft.Build.Tasks.ErrorFromResources.Execute() -> bool
+override Microsoft.Build.Tasks.Exec.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
+override Microsoft.Build.Tasks.Exec.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
+override Microsoft.Build.Tasks.Exec.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.Exec.GetWorkingDirectory() -> string
+override Microsoft.Build.Tasks.Exec.HandleTaskExecutionErrors() -> bool
+override Microsoft.Build.Tasks.Exec.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
+override Microsoft.Build.Tasks.Exec.LogPathToTool(string toolName, string pathToTool) -> void
+override Microsoft.Build.Tasks.Exec.LogToolCommand(string message) -> void
+override Microsoft.Build.Tasks.Exec.StandardErrorEncoding.get -> System.Text.Encoding
+override Microsoft.Build.Tasks.Exec.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+override Microsoft.Build.Tasks.Exec.StandardOutputEncoding.get -> System.Text.Encoding
+override Microsoft.Build.Tasks.Exec.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+override Microsoft.Build.Tasks.Exec.ToolName.get -> string
+override Microsoft.Build.Tasks.Exec.ValidateParameters() -> bool
+override Microsoft.Build.Tasks.FindAppConfigFile.Execute() -> bool
+override Microsoft.Build.Tasks.FindInList.Execute() -> bool
+override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
+override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
+override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
+override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
+override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
+override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
+override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
+override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
+override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
+override Microsoft.Build.Tasks.Hash.Execute() -> bool
+override Microsoft.Build.Tasks.MakeDir.Execute() -> bool
+override Microsoft.Build.Tasks.Message.Execute() -> bool
+override Microsoft.Build.Tasks.Move.Execute() -> bool
+override Microsoft.Build.Tasks.MSBuild.Execute() -> bool
+override Microsoft.Build.Tasks.ReadLinesFromFile.Execute() -> bool
+override Microsoft.Build.Tasks.RemoveDir.Execute() -> bool
+override Microsoft.Build.Tasks.RemoveDuplicates.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveAssemblyReference.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
+override Microsoft.Build.Tasks.SGen.Execute() -> bool
+override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
+override Microsoft.Build.Tasks.SGen.ToolName.get -> string
+override Microsoft.Build.Tasks.SignFile.Execute() -> bool
+override Microsoft.Build.Tasks.TaskLoggingHelperExtension.FormatResourceString(string resourceName, params object[] args) -> string
+override Microsoft.Build.Tasks.Telemetry.Execute() -> bool
+override Microsoft.Build.Tasks.Touch.Execute() -> bool
+override Microsoft.Build.Tasks.Unzip.Execute() -> bool
+override Microsoft.Build.Tasks.VerifyFileHash.Execute() -> bool
+override Microsoft.Build.Tasks.Warning.Execute() -> bool
+override Microsoft.Build.Tasks.WriteCodeFragment.Execute() -> bool
+override Microsoft.Build.Tasks.WriteLinesToFile.Execute() -> bool
+override Microsoft.Build.Tasks.XmlPeek.Execute() -> bool
+override Microsoft.Build.Tasks.XmlPoke.Execute() -> bool
+override Microsoft.Build.Tasks.XslTransformation.Execute() -> bool
+override Microsoft.Build.Tasks.ZipDirectory.Execute() -> bool
+override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureDeformatter
+override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureFormatter
+static Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettIdentifier(string name) -> string
+static Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.XmlToConfigurationFile(System.Xml.XmlNode input) -> string
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromAssemblyName(string assemblyName) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromFile(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManagedAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManifest(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromNativeAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
+System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
+System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
+virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
+virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.set -> void
+virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Validate() -> void
+virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateInputs() -> bool
+virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateOutput() -> bool
\ No newline at end of file
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index f802cbfc70d..c19be8486f6 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -44,8 +44,6 @@ public ITaskItem[] Directories
         //-----------------------------------------------------------------------------------
         public override bool Execute()
         {
-            // Delete each directory
-            bool overallSuccess = true;
             // Our record of the directories that were removed
             var removedDirectoriesList = new List<ITaskItem>();
 
@@ -73,12 +71,6 @@ public override bool Execute()
                         }
                     }
 
-                    // The current directory was not removed successfully
-                    if (!currentSuccess)
-                    {
-                        overallSuccess = false;
-                    }
-
                     // We successfully removed the directory, so add the removed directory to our record
                     if (currentSuccess)
                     {
@@ -97,7 +89,7 @@ public override bool Execute()
             }
             // convert the list of deleted files into an array of ITaskItems
             RemovedDirectories = removedDirectoriesList.ToArray();
-            return overallSuccess;
+            return !Log.HasLoggedErrors;
         }
 
         // Core implementation of directory removal
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index a8cf11d7a56..e64e155ca4b 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1040,7 +1040,7 @@ internal bool ResolveComClassicReference(ComReferenceInfo referenceInfo, string
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown wrapper type!");
+                ErrorUtilities.ThrowInternalError("Unknown wrapper type!");
             }
             referenceInfo.resolvedWrapper = wrapperInfo;
 
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 45b52e509f0..07b5097294d 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1406,7 +1406,7 @@
     <value>Considered "{0}", which was not found in the GAC.</value>
   </data>
   <data name="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-    <value>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</value>
+    <value>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</value>
   </data>
   <data name="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
     <value>Considered "{0}", which existed but had a processor architecture "{1}" which does not match the targeted processor architecture "{2}".</value>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index fc9e3d05a39..3a33ae32974 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">Byl proveden pokus o použití sestavení {0}, které sice existovalo, ale nemělo platnou identitu. Pravděpodobně nejde o sestavení.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index f8323176201..cf22389d9e3 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">"{0}" wurde berücksichtigt und war vorhanden, besaß jedoch keine gültige Identität. Dies ist möglicherweise keine Assembly.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index b8c5ecc2222..87efb516e77 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">Se consideró "{0}", que existía, pero no tenía una identidad válida. Es posible que no sea un ensamblado.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 13ea194a499..a4ca92ee6a5 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">"{0}" existe et a été envisagé, mais il ne comporte aucune identité valide. Il ne s'agit peut-être pas d'un assembly.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index a88e7c3eb65..0db2cfe8b96 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">È stato considerato "{0}", che è stato trovato, ma non aveva un'identità valida. Potrebbe non essere un assembly.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 72cf4592826..ddb420ea728 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">存在しましたが、有効な ID を持たなかった "{0}" を考慮しました。これはアセンブリでない可能性があります。</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index f856969c0a1..af7d179d562 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">이미 있는 "{0}"(으)로 간주했지만 유효한 ID가 없습니다. 어셈블리가 아닐 수 있습니다.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index e11f796daf7..0038f96560a 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">Wybrano element „{0}”, który istnieje, ale nie ma prawidłowej tożsamości. Może on nie być zestawem.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 68f71465eba..1799710bd7a 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">"{0}" foi considerado e existia, mas não continha uma identidade válida. Talvez não seja um assembly.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 1b6cb3afb2d..a4e39bad403 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">Рассмотрено "{0}", существовавшее, но не имевшее допустимого идентификатора. Возможно, это не сборка.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 7eedc3d6c70..d6606feeea8 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">Mevcut olan ancak geçerli bir kimliği olmayan "{0}" denendi. Bu, bir bütünleştirilmiş kod olmayabilir.</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index dff102f40f0..c4a74660fbd 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">已考虑使用“{0}”，它虽然存在，但没有有效的标识。这可能不是程序集。</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 21b825d4ad0..0a078594b53 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1652,8 +1652,8 @@
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.ConsideredAndRejectedBecauseTargetDidntHaveFusionName">
-        <source>Considered "{0}", which existed but didn't have a valid identity. This may not be an assembly.</source>
-        <target state="translated">已考慮 "{0}"，它雖然存在但沒有有效的識別。這可能不是組件。</target>
+        <source>Considered "{0}", which existed but did not appear to be a valid .NET assembly.</source>
+        <target state="new">Considered "{0}", which existed but did not appear to be a valid .NET assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch">
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 2992e07bc73..2c11513b244 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -366,19 +366,14 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             // If the process-wide cache contains an up-to-date FileState, always use it
             if (isProcessFileStateUpToDate)
             {
-                // If a FileState already exists in this instance cache due to deserialization, remove it;
-                // another instance has taken responsibility for serialization, and keeping this would
-                // result in multiple instances serializing the same data to disk
-                if (isCachedInInstance)
+                // For the next build, we may be using a different process. Update the file cache.
+                if (!isInstanceFileStateUpToDate)
                 {
-                    instanceLocalFileStateCache.Remove(path);
+                    instanceLocalFileStateCache[path] = cachedProcessFileState;
                     isDirty = true;
                 }
-
                 return cachedProcessFileState;
             }
-            // If the process-wide FileState is missing or out-of-date, this instance owns serialization;
-            // sync the process-wide cache and signal other instances to avoid data duplication
             if (isInstanceFileStateUpToDate)
             {
                 return s_processWideFileStateCache[path] = cachedInstanceFileState;
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 41d74bb1934..96fc22b7388 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -256,7 +256,7 @@ internal void GenerateCommandsAccordingToType(CommandLineBuilder clb, CommandLin
                     break;
                 default:
                     // should never reach this point - if it does, there's a bug somewhere.
-                    ErrorUtilities.VerifyThrow(false, "InternalError");
+                    ErrorUtilities.ThrowInternalError("InternalError");
                     break;
             }
         }
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 3b8810be561..0f47a2edfe2 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -334,9 +334,9 @@ public XmlReader CreateReader(int itemPos)
             {
                 if (XmlMode == XmlModes.XmlFile)
                 {
-                    return XmlReader.Create(new StreamReader(_data[itemPos]), null, _data[itemPos]);
+                    return XmlReader.Create(new StreamReader(_data[itemPos]), new XmlReaderSettings { CloseInput = true }, _data[itemPos]);
                 }
-                else // xmlModes.Xml 
+                else // xmlModes.Xml
                 {
                     return XmlReader.Create(new StringReader(_data[itemPos]));
                 }
@@ -459,7 +459,10 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                             _log.LogMessageFromResources(MessageImportance.Low, "XslTransform.UseTrustedSettings", _data);
                         }
 
-                        xslct.Load(new XPathDocument(XmlReader.Create(new StreamReader(_data), null, _data)), settings, new XmlUrlResolver());
+                        using (XmlReader reader = XmlReader.Create(new StreamReader(_data), new XmlReaderSettings { CloseInput = true }, _data))
+                        {
+                            xslct.Load(new XPathDocument(reader), settings, new XmlUrlResolver());
+                        }
                         break;
                     case XslModes.XsltCompiledDll:
 #if FEATURE_COMPILED_XSL
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 209e21d4d1e..3cb8f7f10e4 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -30,9 +30,6 @@
     <PackageReference Include="Microsoft.Win32.Registry" />
   </ItemGroup>
   <ItemGroup>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <Link>AssemblyUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
@@ -57,24 +54,12 @@
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>FileUtilitiesRegex.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <Link>InternalErrorException.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <Link>NativeMethodsShared.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>ResourceUtilities.cs</Link>
     </Compile>
     <Compile Include="..\Shared\StringBuilderCache.cs">
       <Link>StringBuilderCache.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>Traits.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>VisualStudioLocationHelper.cs</Link>
-    </Compile>
     <Compile Include="AssemblyResources.cs" />
     <Compile Include="RunnerUtilities.cs" />
   </ItemGroup>
@@ -88,4 +73,4 @@
     <None Include="project.json" />
   </ItemGroup>
   <Import Project="..\dir.targets" />
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 9dda37aa360..f5984764cce 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -42,7 +42,7 @@ private static void AdjustForShellExecution(ref string pathToExecutable, ref str
                 var comSpec = Environment.GetEnvironmentVariable("ComSpec");
 
                 // /D: Do not load AutoRun configuration from the registry (perf)
-                arguments = $"{(Traits.Instance.EscapeHatches.UseAutoRunWhenLaunchingProcessUnderCmd ? String.Empty : "/D ")}/C \"{pathToExecutable} {arguments}\"";
+                arguments = $"/D /C \"{pathToExecutable} {arguments}\"";
                 pathToExecutable = comSpec;
             }
             else
diff --git a/src/Utilities.UnitTests/AssemblyInfo.cs b/src/Utilities.UnitTests/AssemblyInfo.cs
new file mode 100644
index 00000000000..7f6f30fcef9
--- /dev/null
+++ b/src/Utilities.UnitTests/AssemblyInfo.cs
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index 2051aed69cf..3cdbee08cb6 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <AssemblyName>Microsoft.Build.Utilities.UnitTests</AssemblyName>
     <IsTestProject>true</IsTestProject>
     <RootNamespace>Microsoft.Build.Utilities.UnitTests</RootNamespace>
@@ -23,7 +22,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs" />
     <Compile Include="..\Shared\UnitTests\EscapingUtilities_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\ErrorUtilities_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\PrintLineDebugger_Tests.cs" />
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index b2099ce44c5..e2588de3155 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -1950,26 +1950,30 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
             }
            );
         }
+
         /// <summary>
-        /// Verify the method correctly returns the 4.5 reference assembly location information if .net 4.5 and
+        /// Verify the method correctly returns the 4.8 reference assembly location information if .net 4.8 and
         /// its corresponding reference assemblies are installed.
-        /// If they are not installed, the test should be ignored.
+        /// .NET 4.8 should always be installed for our tests. We cannot validly verify on Windows that by adding a check
+        /// that ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48)
+        /// returns something reasonable because later versions of the framework overwrote the current version in
+        /// place, which means it just looks for a folder starting with v4.0 in the right spot for any higher version.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
-        public void GetPathToReferenceAssembliesDefaultLocation45()
+        public void GetPathToReferenceAssembliesDefaultLocation48()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) != null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) != null)
             {
-                FrameworkNameVersioning frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
+                FrameworkNameVersioning frameworkName = new(".NETFramework", new Version("4.8"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
                 directories.Count.ShouldBe(1); // "Expected the method to return one path."
 
-                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45);
+                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48);
                 directories[0].ShouldBe(referenceAssemblyPath, StringCompareShould.IgnoreCase);
             }
             // else
-            // "Ignored because v4.5 did not seem to be installed"
+            // "Ignored because v4.8 did not seem to be installed"
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index f683c61ca7d..3b5d3eb6085 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -681,19 +681,20 @@ public void FindOnPathSucceeds()
         {
             string[] expectedCmdPath;
             string shellName;
+            string cmdPath;
             if (NativeMethodsShared.IsWindows)
             {
-                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe") };
+                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe").ToUpperInvariant() };
                 shellName = "cmd.exe";
+                cmdPath = ToolTask.FindOnPath(shellName).ToUpperInvariant();
             }
             else
             {
                 expectedCmdPath = new[] { "/bin/sh", "/usr/bin/sh" };
                 shellName = "sh";
+                cmdPath = ToolTask.FindOnPath(shellName);
             }
 
-            string cmdPath = ToolTask.FindOnPath(shellName);
-
             cmdPath.ShouldBeOneOf(expectedCmdPath);
         }
 
diff --git a/src/Utilities/AssemblyInfo.cs b/src/Utilities/AssemblyInfo.cs
index 0a6edcd2de0..fb29c8cb944 100644
--- a/src/Utilities/AssemblyInfo.cs
+++ b/src/Utilities/AssemblyInfo.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
 using System;
 using System.Resources;
 #if FEATURE_SECURITY_PERMISSIONS
@@ -17,8 +19,8 @@
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
-// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
-// so that we don't run into known security issues with loading libraries from unsafe locations 
+// This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
+// so that we don't run into known security issues with loading libraries from unsafe locations
 [assembly: DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories)]
 
 [assembly: NeutralResourcesLanguage("en")]
diff --git a/src/Utilities/FxCopExclusions/Microsoft.Build.Utilities.Suppressions.cs b/src/Utilities/FxCopExclusions/Microsoft.Build.Utilities.Suppressions.cs
deleted file mode 100644
index 881022b12ce..00000000000
--- a/src/Utilities/FxCopExclusions/Microsoft.Build.Utilities.Suppressions.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-// FxCop Suppression file
-// To Use:
-// Add module level suppressions to this file to have them suppressed in the assembly
-//
-
-#if CODE_ANALYSIS
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="0", Scope="module", Target="microsoft.build.utilities.core.dll", Justification="It's been named this way for several versions now.")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="v", Justification="v in v3.5 is correctly cased")]
-[module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="5", Justification="5 in v3.5 is correctly spelled")]
-[module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames", Justification="We delay sign our assemblies.")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Utilities.ToolLocationHelper.#GetInstalledSDKLocations()", Justification="SDK is the proper casing")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Utilities.ToolLocationHelper.#GetInstalledSDKLocations(System.String,System.String,System.String,System.String)", Justification="SDK is the proper casing")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Utilities.ToolLocationHelper.#GetInstalledSDKLocation(System.String)", Justification="SDK casing is correct")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Utilities.ToolLocationHelper.#GetInstalledSDKLocation(System.String,System.String,System.String)", Justification="SDK casing is correct")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Utilities.ToolLocationHelper.#GetInstalledSDKLocation(System.String,System.String,System.String,System.String,System.String)", Justification="SDK casing is correct")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Utilities.ToolLocationHelper.#GetInstalledSDKLocations(System.String,System.String)", Justification="SDK casing is correct")]
-[module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="SDK", Scope="member", Target="Microsoft.Build.Utilities.ToolLocationHelper.#GetWindowsSDKMetadataFolderLocations()", Justification="SDK casing is correct")]
-
-#endif
-
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 09634e72315..065b9fc3233 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -21,6 +21,7 @@
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
@@ -58,9 +59,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>Shared\BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
-      <Link>Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\CanonicalError.cs">
       <Link>Shared\CanonicalError.cs</Link>
     </Compile>
@@ -103,9 +101,6 @@
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
       <Link>Shared\IConstrainedEqualityComparer.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\InternalErrorException.cs">
-      <Link>Shared\InternalErrorException.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\IKeyed.cs">
       <Link>Shared\IKeyed.cs</Link>
     </Compile>
@@ -115,12 +110,6 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Shared\Modifiers.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\NativeMethodsShared.cs">
-      <Link>Shared\NativeMethodsShared.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyUtilities.cs">
-      <Link>Shared\AssemblyUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>Shared\InprocTrackingNativeMethods.cs</Link>
     </Compile>
@@ -163,12 +152,6 @@
     <Compile Include="..\Shared\ToolsetElement.cs">
       <Link>Shared\ToolsetElement.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\VisualStudioLocationHelper.cs">
-      <Link>Shared\VisualStudioLocationHelper.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\Traits.cs">
-      <Link>Shared\Traits.cs</Link>
-    </Compile>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..e85d5954bfd
--- /dev/null
+++ b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
@@ -0,0 +1,581 @@
+abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
+abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+abstract Microsoft.Build.Utilities.Task.Execute() -> bool
+abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
+abstract Microsoft.Build.Utilities.ToolTask.ToolName.get -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.AMD64 = "AMD64" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.ARM = "ARM" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.ARM64 = "ARM64" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.IA64 = "IA64" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.MSIL = "MSIL" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.X86 = "x86" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.APPX = "APPX" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.AppxLocation = "AppxLocation" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedist = "CopyRedist" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedistToSubDirectory = "CopyRedistToSubDirectory" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.DependsOnSDK = "DependsOn" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.DisplayName = "DisplayName" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.ExpandReferenceAssemblies = "ExpandReferenceAssemblies" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.FrameworkIdentity = "FrameworkIdentity" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxOSVersionTested = "MaxOSVersionTested" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxPlatformVersion = "MaxPlatformVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MinOSVersion = "MinOSVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MinVSVersion = "MinVSVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MoreInfo = "MoreInfo" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.PlatformIdentity = "PlatformIdentity" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.ProductFamilyName = "ProductFamilyName" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SDKType = "SDKType" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportedArchitectures = "SupportedArchitectures" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportPrefer32Bit = "SupportPrefer32Bit" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportsMultipleVersions = "SupportsMultipleVersions" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDK = "TargetedSDKArchitecture" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration = "TargetedSDKConfiguration" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
+Microsoft.Build.Utilities.AppDomainIsolatedTask
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.TargetFrameworkVersion.get -> System.Version
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem sourceFile, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Framework.ITaskItem[] outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.ComputeSourcesNeedingCompilation() -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.ComputeSourcesNeedingCompilation(bool searchForSubRootsInCompositeRootingMarkers) -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.DependencyTable.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, string>>
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.FileIsExcludedFromDependencyCheck(string fileName) -> bool
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntryForSourceRoot(string rootingMarker) -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.SaveTlog() -> void
+Microsoft.Build.Utilities.CanonicalTrackedInputFiles.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputForSourceRoot(string sourceKey, string computedOutput) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputsForSourceRoot(string sourceKey, Microsoft.Build.Framework.ITaskItem[] computedOutputs) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputsForSourceRoot(string sourceKey, string[] computedOutputs) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool constructOutputsFromTLogs) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.DependencyTable.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, System.DateTime>>
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForNonCompositeSource(params Microsoft.Build.Framework.ITaskItem[] sources) -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForSource(Microsoft.Build.Framework.ITaskItem[] sources, bool searchForSubRootsInCompositeRootingMarkers) -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForSource(params Microsoft.Build.Framework.ITaskItem[] sources) -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove) -> bool
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveRootsWithSharedOutputs(Microsoft.Build.Framework.ITaskItem[] sources) -> string[]
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.SaveTlog() -> void
+Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
+Microsoft.Build.Utilities.CommandLineBuilder
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(string fileName) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(string[] fileNames, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(string fileName) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty() -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(string switchName) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(string textToAppend) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(string textToAppend) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLine.get -> System.Text.StringBuilder
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder() -> void
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.Length.get -> int
+Microsoft.Build.Utilities.DependencyFilter
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness32 = 1 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness64 = 2 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.Managed32Bit = 3 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.Managed64Bit = 4 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.ManagedIL = 2 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.Native32Bit = 0 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.Native64Bit = 1 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.SameAsCurrentProcess = 5 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.FileTracker
+Microsoft.Build.Utilities.FlatTrackingData
+Microsoft.Build.Utilities.FlatTrackingData.FileIsExcludedFromDependencyCheck(string fileName) -> bool
+Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) -> void
+Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) -> void
+Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) -> void
+Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc) -> void
+Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache) -> void
+Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache, bool treatRootMarkersAsEntries) -> void
+Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) -> void
+Microsoft.Build.Utilities.FlatTrackingData.GetLastWriteTimeUtc(string file) -> System.DateTime
+Microsoft.Build.Utilities.FlatTrackingData.MissingFiles.get -> System.Collections.Generic.List<string>
+Microsoft.Build.Utilities.FlatTrackingData.MissingFiles.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.NewestFileName.get -> string
+Microsoft.Build.Utilities.FlatTrackingData.NewestFileName.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.NewestFileTime.get -> System.DateTime
+Microsoft.Build.Utilities.FlatTrackingData.NewestFileTime.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.NewestFileTimeUtc.get -> System.DateTime
+Microsoft.Build.Utilities.FlatTrackingData.NewestFileTimeUtc.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.NewestTLogFileName.get -> string
+Microsoft.Build.Utilities.FlatTrackingData.NewestTLogFileName.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTime.get -> System.DateTime
+Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTime.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTimeUtc.get -> System.DateTime
+Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTimeUtc.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.OldestFileName.get -> string
+Microsoft.Build.Utilities.FlatTrackingData.OldestFileName.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.OldestFileTime.get -> System.DateTime
+Microsoft.Build.Utilities.FlatTrackingData.OldestFileTime.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.OldestFileTimeUtc.get -> System.DateTime
+Microsoft.Build.Utilities.FlatTrackingData.OldestFileTimeUtc.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.SaveTlog() -> void
+Microsoft.Build.Utilities.FlatTrackingData.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
+Microsoft.Build.Utilities.FlatTrackingData.SkipMissingFiles.get -> bool
+Microsoft.Build.Utilities.FlatTrackingData.SkipMissingFiles.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.TlogFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Utilities.FlatTrackingData.TlogFiles.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.TlogsAvailable.get -> bool
+Microsoft.Build.Utilities.FlatTrackingData.TlogsAvailable.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.TreatRootMarkersAsEntries.get -> bool
+Microsoft.Build.Utilities.FlatTrackingData.TreatRootMarkersAsEntries.set -> void
+Microsoft.Build.Utilities.FlatTrackingData.UpdateFileEntryDetails() -> void
+Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnFailure = 3 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnSuccess = 2 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.UseAlternateToolToExecute = 1 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.UseHostObjectToExecute = 0 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.Logger
+Microsoft.Build.Utilities.Logger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) -> bool
+Microsoft.Build.Utilities.Logger.Logger() -> void
+Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MultipleVersionSupport.Allow = 0 -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MultipleVersionSupport.Error = 2 -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MultipleVersionSupport.Warning = 1 -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MuxLogger
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.set -> void
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.set -> void
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.set -> void
+Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.set -> void
+Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) -> void
+Microsoft.Build.Utilities.MuxLogger.MuxLogger() -> void
+Microsoft.Build.Utilities.MuxLogger.Parameters.get -> string
+Microsoft.Build.Utilities.MuxLogger.Parameters.set -> void
+Microsoft.Build.Utilities.MuxLogger.RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) -> void
+Microsoft.Build.Utilities.MuxLogger.Shutdown() -> void
+Microsoft.Build.Utilities.MuxLogger.UnregisterLoggers(int submissionId) -> bool
+Microsoft.Build.Utilities.MuxLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Utilities.MuxLogger.Verbosity.set -> void
+Microsoft.Build.Utilities.ProcessorArchitecture
+Microsoft.Build.Utilities.SDKManifest
+Microsoft.Build.Utilities.SDKManifest.AppxLocations.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Utilities.SDKManifest.Attributes
+Microsoft.Build.Utilities.SDKManifest.CopyRedistToSubDirectory.get -> string
+Microsoft.Build.Utilities.SDKManifest.DependsOnSDK.get -> string
+Microsoft.Build.Utilities.SDKManifest.DisplayName.get -> string
+Microsoft.Build.Utilities.SDKManifest.FrameworkIdentities.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Utilities.SDKManifest.FrameworkIdentity.get -> string
+Microsoft.Build.Utilities.SDKManifest.MaxOSVersionTested.get -> string
+Microsoft.Build.Utilities.SDKManifest.MaxPlatformVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.MinOSVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.MinVSVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.MoreInfo.get -> string
+Microsoft.Build.Utilities.SDKManifest.PlatformIdentity.get -> string
+Microsoft.Build.Utilities.SDKManifest.ProductFamilyName.get -> string
+Microsoft.Build.Utilities.SDKManifest.ReadError.get -> bool
+Microsoft.Build.Utilities.SDKManifest.ReadErrorMessage.get -> string
+Microsoft.Build.Utilities.SDKManifest.SDKManifest(string pathToSdk) -> void
+Microsoft.Build.Utilities.SDKManifest.SDKType.get -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKManifest.SupportedArchitectures.get -> string
+Microsoft.Build.Utilities.SDKManifest.SupportPrefer32Bit.get -> string
+Microsoft.Build.Utilities.SDKManifest.SupportsMultipleVersions.get -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.SDKManifest.TargetPlatform.get -> string
+Microsoft.Build.Utilities.SDKManifest.TargetPlatformMinVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.TargetPlatformVersion.get -> string
+Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.External = 1 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.Framework = 3 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.Platform = 2 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.Unspecified = 0 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Latest = 9999 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version11 = 0 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version20 = 1 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version30 = 2 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version35 = 3 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version40 = 4 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version45 = 5 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version451 = 6 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version452 = 9 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version46 = 7 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461 = 8 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version462 = 10 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version47 = 11 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version471 = 12 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version472 = 13 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version48 = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetPlatformSDK
+Microsoft.Build.Utilities.TargetPlatformSDK.ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) -> bool
+Microsoft.Build.Utilities.TargetPlatformSDK.DisplayName.get -> string
+Microsoft.Build.Utilities.TargetPlatformSDK.Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) -> bool
+Microsoft.Build.Utilities.TargetPlatformSDK.MinOSVersion.get -> System.Version
+Microsoft.Build.Utilities.TargetPlatformSDK.MinVSVersion.get -> System.Version
+Microsoft.Build.Utilities.TargetPlatformSDK.Path.get -> string
+Microsoft.Build.Utilities.TargetPlatformSDK.Path.set -> void
+Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) -> void
+Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformVersion.get -> System.Version
+Microsoft.Build.Utilities.Task
+Microsoft.Build.Utilities.Task.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.Task.BuildEngine.set -> void
+Microsoft.Build.Utilities.Task.BuildEngine2.get -> Microsoft.Build.Framework.IBuildEngine2
+Microsoft.Build.Utilities.Task.BuildEngine3.get -> Microsoft.Build.Framework.IBuildEngine3
+Microsoft.Build.Utilities.Task.BuildEngine4.get -> Microsoft.Build.Framework.IBuildEngine4
+Microsoft.Build.Utilities.Task.BuildEngine5.get -> Microsoft.Build.Framework.IBuildEngine5
+Microsoft.Build.Utilities.Task.BuildEngine6.get -> Microsoft.Build.Framework.IBuildEngine6
+Microsoft.Build.Utilities.Task.BuildEngine7.get -> Microsoft.Build.Framework.IBuildEngine7
+Microsoft.Build.Utilities.Task.BuildEngine8.get -> Microsoft.Build.Framework.IBuildEngine8
+Microsoft.Build.Utilities.Task.BuildEngine9.get -> Microsoft.Build.Framework.IBuildEngine9
+Microsoft.Build.Utilities.Task.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.Task.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.Task.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Utilities.Task.HostObject.set -> void
+Microsoft.Build.Utilities.Task.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.Task.Task() -> void
+Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.Task.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.Task.TaskResources.set -> void
+Microsoft.Build.Utilities.TaskItem
+Microsoft.Build.Utilities.TaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
+Microsoft.Build.Utilities.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
+Microsoft.Build.Utilities.TaskItem.GetMetadata(string metadataName) -> string
+Microsoft.Build.Utilities.TaskItem.ItemSpec.get -> string
+Microsoft.Build.Utilities.TaskItem.ItemSpec.set -> void
+Microsoft.Build.Utilities.TaskItem.MetadataCount.get -> int
+Microsoft.Build.Utilities.TaskItem.MetadataNames.get -> System.Collections.ICollection
+Microsoft.Build.Utilities.TaskItem.RemoveMetadata(string metadataName) -> void
+Microsoft.Build.Utilities.TaskItem.SetMetadata(string metadataName, string metadataValue) -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem() -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec) -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.TaskLoggingHelper.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.TaskLoggingHelper.ExtractMessageCode(string message, out string messageWithoutCodePrefix) -> string
+Microsoft.Build.Utilities.TaskLoggingHelper.HasLoggedErrors.get -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.IsTaskInputLoggingEnabled.get -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(string commandLine) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception, bool showStackTrace) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.MarkAsInactive() -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskName.get -> string
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.set -> void
+Microsoft.Build.Utilities.ToolLocationHelper
+Microsoft.Build.Utilities.ToolTask
+Microsoft.Build.Utilities.ToolTask.DeleteTempFile(string fileName) -> void
+Microsoft.Build.Utilities.ToolTask.EchoOff.get -> bool
+Microsoft.Build.Utilities.ToolTask.EchoOff.set -> void
+Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.get -> string[]
+Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.set -> void
+Microsoft.Build.Utilities.ToolTask.ExitCode.get -> int
+Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.get -> bool
+Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.set -> void
+Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.get -> string
+Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.set -> void
+Microsoft.Build.Utilities.ToolTask.StandardErrorImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.get -> string
+Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.set -> void
+Microsoft.Build.Utilities.ToolTask.StandardOutputImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.get -> int
+Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.set -> void
+Microsoft.Build.Utilities.ToolTask.ToolCanceled.get -> System.Threading.ManualResetEvent
+Microsoft.Build.Utilities.ToolTask.ToolPath.get -> string
+Microsoft.Build.Utilities.ToolTask.ToolPath.set -> void
+Microsoft.Build.Utilities.ToolTask.ToolTask() -> void
+Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.get -> bool
+Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.set -> void
+Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.get -> string
+Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.set -> void
+Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.get -> bool
+Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.set -> void
+Microsoft.Build.Utilities.TrackedDependencies
+Microsoft.Build.Utilities.UpToDateCheckType
+Microsoft.Build.Utilities.UpToDateCheckType.InputNewerThanOutput = 0 -> Microsoft.Build.Utilities.UpToDateCheckType
+Microsoft.Build.Utilities.UpToDateCheckType.InputNewerThanTracking = 2 -> Microsoft.Build.Utilities.UpToDateCheckType
+Microsoft.Build.Utilities.UpToDateCheckType.InputOrOutputNewerThanTracking = 1 -> Microsoft.Build.Utilities.UpToDateCheckType
+Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version100 = 0 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version110 = 1 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version120 = 2 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version140 = 3 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
+override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
+override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
+override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
+override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
+override Microsoft.Build.Utilities.TaskItem.InitializeLifetimeService() -> object
+override Microsoft.Build.Utilities.TaskItem.ToString() -> string
+override Microsoft.Build.Utilities.TaskLoggingHelper.InitializeLifetimeService() -> object
+override Microsoft.Build.Utilities.ToolTask.Execute() -> bool
+static Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(Microsoft.Build.Framework.ITaskItem[] sources) -> string
+static Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(string rootMarker) -> string
+static Microsoft.Build.Utilities.FileTracker.EndTrackingContext() -> void
+static Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath() -> string
+static Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath(string rootPath) -> string
+static Microsoft.Build.Utilities.FileTracker.FileIsExcludedFromDependencies(string fileName) -> bool
+static Microsoft.Build.Utilities.FileTracker.FileIsUnderPath(string fileName, string path) -> bool
+static Microsoft.Build.Utilities.FileTracker.FindTrackerOnPath() -> string
+static Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType) -> bool
+static Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string cancelEventName) -> bool
+static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source) -> string
+static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem output) -> string
+static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources) -> string
+static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem[] outputs) -> string
+static Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) -> string
+static Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) -> string
+static Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) -> string
+static Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) -> string
+static Microsoft.Build.Utilities.FileTracker.ResumeTracking() -> void
+static Microsoft.Build.Utilities.FileTracker.SetThreadCount(int threadCount) -> void
+static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType) -> System.Diagnostics.Process
+static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles) -> System.Diagnostics.Process
+static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> System.Diagnostics.Process
+static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string intermediateDirectory, string rootFiles) -> System.Diagnostics.Process
+static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string rootFiles) -> System.Diagnostics.Process
+static Microsoft.Build.Utilities.FileTracker.StartTrackingContext(string intermediateDirectory, string taskName) -> void
+static Microsoft.Build.Utilities.FileTracker.StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile) -> void
+static Microsoft.Build.Utilities.FileTracker.StopTrackingAndCleanup() -> void
+static Microsoft.Build.Utilities.FileTracker.SuspendTracking() -> void
+static Microsoft.Build.Utilities.FileTracker.TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles) -> string
+static Microsoft.Build.Utilities.FileTracker.TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> string
+static Microsoft.Build.Utilities.FileTracker.TrackerCommandArguments(string command, string arguments) -> string
+static Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles) -> string
+static Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> string
+static Microsoft.Build.Utilities.FileTracker.WriteAllTLogs(string intermediateDirectory, string taskName) -> void
+static Microsoft.Build.Utilities.FileTracker.WriteContextTLogs(string intermediateDirectory, string taskName) -> void
+static Microsoft.Build.Utilities.FlatTrackingData.FinalizeTLogs(bool trackedOperationsSucceeded, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames, Microsoft.Build.Framework.ITaskItem[] trackedFilesToRemoveFromTLogs) -> void
+static Microsoft.Build.Utilities.FlatTrackingData.IsUpToDate(Microsoft.Build.Utilities.Task hostTask, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames) -> bool
+static Microsoft.Build.Utilities.FlatTrackingData.IsUpToDate(Microsoft.Build.Utilities.TaskLoggingHelper Log, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Utilities.FlatTrackingData inputs, Microsoft.Build.Utilities.FlatTrackingData outputs) -> bool
+static Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture.get -> string
+static Microsoft.Build.Utilities.TaskItem.explicit operator string(Microsoft.Build.Utilities.TaskItem taskItemToCast) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.ClearSDKStaticCache() -> void
+static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
+static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) -> System.Collections.Generic.IEnumerable<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk() -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToSystemFile(string fileName) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) -> System.Collections.Generic.IEnumerable<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) -> System.Collections.Generic.IEnumerable<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot() -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSupportedTargetFrameworks() -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks() -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks(string[] diskRoots, string registryRoot) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
+static Microsoft.Build.Utilities.ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) -> System.Runtime.Versioning.FrameworkName
+static Microsoft.Build.Utilities.ToolLocationHelper.PathToSystem.get -> string
+static Microsoft.Build.Utilities.TrackedDependencies.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) -> Microsoft.Build.Framework.ITaskItem[]
+virtual Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(string parameter) -> bool
+virtual Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) -> void
+virtual Microsoft.Build.Utilities.Logger.FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) -> string
+virtual Microsoft.Build.Utilities.Logger.FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) -> string
+virtual Microsoft.Build.Utilities.Logger.Parameters.get -> string
+virtual Microsoft.Build.Utilities.Logger.Parameters.set -> void
+virtual Microsoft.Build.Utilities.Logger.Shutdown() -> void
+virtual Microsoft.Build.Utilities.Logger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+virtual Microsoft.Build.Utilities.Logger.Verbosity.set -> void
+virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatResourceString(string resourceName, params object[] args) -> string
+virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatString(string unformatted, params object[] args) -> string
+virtual Microsoft.Build.Utilities.TaskLoggingHelper.GetResourceMessage(string resourceName) -> string
+virtual Microsoft.Build.Utilities.ToolTask.AdjustCommandsForOperatingSystem(string input) -> string
+virtual Microsoft.Build.Utilities.ToolTask.CallHostObjectToExecute() -> bool
+virtual Microsoft.Build.Utilities.ToolTask.Cancel() -> void
+virtual Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get -> System.Collections.Generic.Dictionary<string, string>
+virtual Microsoft.Build.Utilities.ToolTask.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
+virtual Microsoft.Build.Utilities.ToolTask.GenerateCommandLineCommands() -> string
+virtual Microsoft.Build.Utilities.ToolTask.GenerateResponseFileCommands() -> string
+virtual Microsoft.Build.Utilities.ToolTask.GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) -> System.Diagnostics.ProcessStartInfo
+virtual Microsoft.Build.Utilities.ToolTask.GetResponseFileSwitch(string responseFilePath) -> string
+virtual Microsoft.Build.Utilities.ToolTask.GetWorkingDirectory() -> string
+virtual Microsoft.Build.Utilities.ToolTask.HandleTaskExecutionErrors() -> bool
+virtual Microsoft.Build.Utilities.ToolTask.HasLoggedErrors.get -> bool
+virtual Microsoft.Build.Utilities.ToolTask.InitializeHostObject() -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+virtual Microsoft.Build.Utilities.ToolTask.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
+virtual Microsoft.Build.Utilities.ToolTask.LogPathToTool(string toolName, string pathToTool) -> void
+virtual Microsoft.Build.Utilities.ToolTask.LogToolCommand(string message) -> void
+virtual Microsoft.Build.Utilities.ToolTask.ProcessStarted() -> void
+virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEncoding.get -> System.Text.Encoding
+virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEscape(string responseString) -> string
+virtual Microsoft.Build.Utilities.ToolTask.SkipTaskExecution() -> bool
+virtual Microsoft.Build.Utilities.ToolTask.StandardErrorEncoding.get -> System.Text.Encoding
+virtual Microsoft.Build.Utilities.ToolTask.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+virtual Microsoft.Build.Utilities.ToolTask.StandardOutputEncoding.get -> System.Text.Encoding
+virtual Microsoft.Build.Utilities.ToolTask.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+virtual Microsoft.Build.Utilities.ToolTask.Timeout.get -> int
+virtual Microsoft.Build.Utilities.ToolTask.Timeout.set -> void
+virtual Microsoft.Build.Utilities.ToolTask.ToolExe.get -> string
+virtual Microsoft.Build.Utilities.ToolTask.ToolExe.set -> void
+virtual Microsoft.Build.Utilities.ToolTask.ValidateParameters() -> bool
\ No newline at end of file
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
new file mode 100644
index 00000000000..f7bb4031d5e
--- /dev/null
+++ b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -0,0 +1,416 @@
+abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+abstract Microsoft.Build.Utilities.Task.Execute() -> bool
+abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
+abstract Microsoft.Build.Utilities.ToolTask.ToolName.get -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.AMD64 = "AMD64" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.ARM = "ARM" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.ARM64 = "ARM64" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.IA64 = "IA64" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.MSIL = "MSIL" -> string
+const Microsoft.Build.Utilities.ProcessorArchitecture.X86 = "x86" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.APPX = "APPX" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.AppxLocation = "AppxLocation" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedist = "CopyRedist" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedistToSubDirectory = "CopyRedistToSubDirectory" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.DependsOnSDK = "DependsOn" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.DisplayName = "DisplayName" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.ExpandReferenceAssemblies = "ExpandReferenceAssemblies" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.FrameworkIdentity = "FrameworkIdentity" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxOSVersionTested = "MaxOSVersionTested" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxPlatformVersion = "MaxPlatformVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MinOSVersion = "MinOSVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MinVSVersion = "MinVSVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.MoreInfo = "MoreInfo" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.PlatformIdentity = "PlatformIdentity" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.ProductFamilyName = "ProductFamilyName" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SDKType = "SDKType" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportedArchitectures = "SupportedArchitectures" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportPrefer32Bit = "SupportPrefer32Bit" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportsMultipleVersions = "SupportsMultipleVersions" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDK = "TargetedSDKArchitecture" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration = "TargetedSDKConfiguration" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
+const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.TargetFrameworkVersion.get -> System.Version
+Microsoft.Build.Utilities.CommandLineBuilder
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(string fileName) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(string[] fileNames, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(string fileName) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty() -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(string switchName) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string parameter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(string textToAppend) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(string textToAppend) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLine.get -> System.Text.StringBuilder
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder() -> void
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
+Microsoft.Build.Utilities.CommandLineBuilder.Length.get -> int
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness32 = 1 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness64 = 2 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
+Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnFailure = 3 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnSuccess = 2 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.UseAlternateToolToExecute = 1 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.HostObjectInitializationStatus.UseHostObjectToExecute = 0 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+Microsoft.Build.Utilities.Logger
+Microsoft.Build.Utilities.Logger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) -> bool
+Microsoft.Build.Utilities.Logger.Logger() -> void
+Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MultipleVersionSupport.Allow = 0 -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MultipleVersionSupport.Error = 2 -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MultipleVersionSupport.Warning = 1 -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.MuxLogger
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.set -> void
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.set -> void
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.set -> void
+Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.get -> bool
+Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.set -> void
+Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
+Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) -> void
+Microsoft.Build.Utilities.MuxLogger.MuxLogger() -> void
+Microsoft.Build.Utilities.MuxLogger.Parameters.get -> string
+Microsoft.Build.Utilities.MuxLogger.Parameters.set -> void
+Microsoft.Build.Utilities.MuxLogger.RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) -> void
+Microsoft.Build.Utilities.MuxLogger.Shutdown() -> void
+Microsoft.Build.Utilities.MuxLogger.UnregisterLoggers(int submissionId) -> bool
+Microsoft.Build.Utilities.MuxLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+Microsoft.Build.Utilities.MuxLogger.Verbosity.set -> void
+Microsoft.Build.Utilities.ProcessorArchitecture
+Microsoft.Build.Utilities.SDKManifest
+Microsoft.Build.Utilities.SDKManifest.AppxLocations.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Utilities.SDKManifest.Attributes
+Microsoft.Build.Utilities.SDKManifest.CopyRedistToSubDirectory.get -> string
+Microsoft.Build.Utilities.SDKManifest.DependsOnSDK.get -> string
+Microsoft.Build.Utilities.SDKManifest.DisplayName.get -> string
+Microsoft.Build.Utilities.SDKManifest.FrameworkIdentities.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Utilities.SDKManifest.FrameworkIdentity.get -> string
+Microsoft.Build.Utilities.SDKManifest.MaxOSVersionTested.get -> string
+Microsoft.Build.Utilities.SDKManifest.MaxPlatformVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.MinOSVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.MinVSVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.MoreInfo.get -> string
+Microsoft.Build.Utilities.SDKManifest.PlatformIdentity.get -> string
+Microsoft.Build.Utilities.SDKManifest.ProductFamilyName.get -> string
+Microsoft.Build.Utilities.SDKManifest.ReadError.get -> bool
+Microsoft.Build.Utilities.SDKManifest.ReadErrorMessage.get -> string
+Microsoft.Build.Utilities.SDKManifest.SDKManifest(string pathToSdk) -> void
+Microsoft.Build.Utilities.SDKManifest.SDKType.get -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKManifest.SupportedArchitectures.get -> string
+Microsoft.Build.Utilities.SDKManifest.SupportPrefer32Bit.get -> string
+Microsoft.Build.Utilities.SDKManifest.SupportsMultipleVersions.get -> Microsoft.Build.Utilities.MultipleVersionSupport
+Microsoft.Build.Utilities.SDKManifest.TargetPlatform.get -> string
+Microsoft.Build.Utilities.SDKManifest.TargetPlatformMinVersion.get -> string
+Microsoft.Build.Utilities.SDKManifest.TargetPlatformVersion.get -> string
+Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.External = 1 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.Framework = 3 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.Platform = 2 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.SDKType.Unspecified = 0 -> Microsoft.Build.Utilities.SDKType
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Latest = 9999 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version11 = 0 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version20 = 1 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version30 = 2 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version35 = 3 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version40 = 4 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version45 = 5 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version451 = 6 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version452 = 9 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version46 = 7 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461 = 8 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version462 = 10 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version47 = 11 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version471 = 12 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version472 = 13 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version48 = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
+Microsoft.Build.Utilities.TargetPlatformSDK
+Microsoft.Build.Utilities.TargetPlatformSDK.ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) -> bool
+Microsoft.Build.Utilities.TargetPlatformSDK.DisplayName.get -> string
+Microsoft.Build.Utilities.TargetPlatformSDK.Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) -> bool
+Microsoft.Build.Utilities.TargetPlatformSDK.MinOSVersion.get -> System.Version
+Microsoft.Build.Utilities.TargetPlatformSDK.MinVSVersion.get -> System.Version
+Microsoft.Build.Utilities.TargetPlatformSDK.Path.get -> string
+Microsoft.Build.Utilities.TargetPlatformSDK.Path.set -> void
+Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) -> void
+Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformVersion.get -> System.Version
+Microsoft.Build.Utilities.Task
+Microsoft.Build.Utilities.Task.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.Task.BuildEngine.set -> void
+Microsoft.Build.Utilities.Task.BuildEngine2.get -> Microsoft.Build.Framework.IBuildEngine2
+Microsoft.Build.Utilities.Task.BuildEngine3.get -> Microsoft.Build.Framework.IBuildEngine3
+Microsoft.Build.Utilities.Task.BuildEngine4.get -> Microsoft.Build.Framework.IBuildEngine4
+Microsoft.Build.Utilities.Task.BuildEngine5.get -> Microsoft.Build.Framework.IBuildEngine5
+Microsoft.Build.Utilities.Task.BuildEngine6.get -> Microsoft.Build.Framework.IBuildEngine6
+Microsoft.Build.Utilities.Task.BuildEngine7.get -> Microsoft.Build.Framework.IBuildEngine7
+Microsoft.Build.Utilities.Task.BuildEngine8.get -> Microsoft.Build.Framework.IBuildEngine8
+Microsoft.Build.Utilities.Task.BuildEngine9.get -> Microsoft.Build.Framework.IBuildEngine9
+Microsoft.Build.Utilities.Task.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.Task.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.Task.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Utilities.Task.HostObject.set -> void
+Microsoft.Build.Utilities.Task.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.Task.Task() -> void
+Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.Task.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.Task.TaskResources.set -> void
+Microsoft.Build.Utilities.TaskItem
+Microsoft.Build.Utilities.TaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
+Microsoft.Build.Utilities.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
+Microsoft.Build.Utilities.TaskItem.GetMetadata(string metadataName) -> string
+Microsoft.Build.Utilities.TaskItem.ItemSpec.get -> string
+Microsoft.Build.Utilities.TaskItem.ItemSpec.set -> void
+Microsoft.Build.Utilities.TaskItem.MetadataCount.get -> int
+Microsoft.Build.Utilities.TaskItem.MetadataNames.get -> System.Collections.ICollection
+Microsoft.Build.Utilities.TaskItem.RemoveMetadata(string metadataName) -> void
+Microsoft.Build.Utilities.TaskItem.SetMetadata(string metadataName, string metadataValue) -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem() -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec) -> void
+Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.TaskLoggingHelper.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.TaskLoggingHelper.ExtractMessageCode(string message, out string messageWithoutCodePrefix) -> string
+Microsoft.Build.Utilities.TaskLoggingHelper.HasLoggedErrors.get -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.IsTaskInputLoggingEnabled.get -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(string commandLine) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
+Microsoft.Build.Utilities.TaskLoggingHelper.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception, bool showStackTrace) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) -> void
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskName.get -> string
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.set -> void
+Microsoft.Build.Utilities.ToolLocationHelper
+Microsoft.Build.Utilities.ToolTask
+Microsoft.Build.Utilities.ToolTask.DeleteTempFile(string fileName) -> void
+Microsoft.Build.Utilities.ToolTask.EchoOff.get -> bool
+Microsoft.Build.Utilities.ToolTask.EchoOff.set -> void
+Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.get -> string[]
+Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.set -> void
+Microsoft.Build.Utilities.ToolTask.ExitCode.get -> int
+Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.get -> bool
+Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.set -> void
+Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.get -> string
+Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.set -> void
+Microsoft.Build.Utilities.ToolTask.StandardErrorImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.get -> string
+Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.set -> void
+Microsoft.Build.Utilities.ToolTask.StandardOutputImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
+Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.get -> int
+Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.set -> void
+Microsoft.Build.Utilities.ToolTask.ToolCanceled.get -> System.Threading.ManualResetEvent
+Microsoft.Build.Utilities.ToolTask.ToolPath.get -> string
+Microsoft.Build.Utilities.ToolTask.ToolPath.set -> void
+Microsoft.Build.Utilities.ToolTask.ToolTask() -> void
+Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.get -> bool
+Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.set -> void
+Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.get -> string
+Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.set -> void
+Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.get -> bool
+Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.set -> void
+Microsoft.Build.Utilities.TrackedDependencies
+Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version100 = 0 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version110 = 1 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version120 = 2 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version140 = 3 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
+Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
+override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
+override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
+override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
+override Microsoft.Build.Utilities.TaskItem.ToString() -> string
+override Microsoft.Build.Utilities.ToolTask.Execute() -> bool
+static Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture.get -> string
+static Microsoft.Build.Utilities.TaskItem.explicit operator string(Microsoft.Build.Utilities.TaskItem taskItemToCast) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.ClearSDKStaticCache() -> void
+static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
+static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) -> System.Collections.Generic.IEnumerable<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk() -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToSystemFile(string fileName) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) -> System.Collections.Generic.IEnumerable<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) -> System.Collections.Generic.IEnumerable<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot() -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetSupportedTargetFrameworks() -> System.Collections.Generic.IList<string>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string[]
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks() -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
+static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks(string[] diskRoots, string registryRoot) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
+static Microsoft.Build.Utilities.ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) -> System.Runtime.Versioning.FrameworkName
+static Microsoft.Build.Utilities.ToolLocationHelper.PathToSystem.get -> string
+static Microsoft.Build.Utilities.TrackedDependencies.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) -> Microsoft.Build.Framework.ITaskItem[]
+virtual Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(string parameter) -> bool
+virtual Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) -> void
+virtual Microsoft.Build.Utilities.Logger.FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) -> string
+virtual Microsoft.Build.Utilities.Logger.FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) -> string
+virtual Microsoft.Build.Utilities.Logger.Parameters.get -> string
+virtual Microsoft.Build.Utilities.Logger.Parameters.set -> void
+virtual Microsoft.Build.Utilities.Logger.Shutdown() -> void
+virtual Microsoft.Build.Utilities.Logger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
+virtual Microsoft.Build.Utilities.Logger.Verbosity.set -> void
+virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatResourceString(string resourceName, params object[] args) -> string
+virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatString(string unformatted, params object[] args) -> string
+virtual Microsoft.Build.Utilities.TaskLoggingHelper.GetResourceMessage(string resourceName) -> string
+virtual Microsoft.Build.Utilities.ToolTask.AdjustCommandsForOperatingSystem(string input) -> string
+virtual Microsoft.Build.Utilities.ToolTask.CallHostObjectToExecute() -> bool
+virtual Microsoft.Build.Utilities.ToolTask.Cancel() -> void
+virtual Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get -> System.Collections.Generic.Dictionary<string, string>
+virtual Microsoft.Build.Utilities.ToolTask.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
+virtual Microsoft.Build.Utilities.ToolTask.GenerateCommandLineCommands() -> string
+virtual Microsoft.Build.Utilities.ToolTask.GenerateResponseFileCommands() -> string
+virtual Microsoft.Build.Utilities.ToolTask.GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) -> System.Diagnostics.ProcessStartInfo
+virtual Microsoft.Build.Utilities.ToolTask.GetResponseFileSwitch(string responseFilePath) -> string
+virtual Microsoft.Build.Utilities.ToolTask.GetWorkingDirectory() -> string
+virtual Microsoft.Build.Utilities.ToolTask.HandleTaskExecutionErrors() -> bool
+virtual Microsoft.Build.Utilities.ToolTask.HasLoggedErrors.get -> bool
+virtual Microsoft.Build.Utilities.ToolTask.InitializeHostObject() -> Microsoft.Build.Utilities.HostObjectInitializationStatus
+virtual Microsoft.Build.Utilities.ToolTask.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
+virtual Microsoft.Build.Utilities.ToolTask.LogPathToTool(string toolName, string pathToTool) -> void
+virtual Microsoft.Build.Utilities.ToolTask.LogToolCommand(string message) -> void
+virtual Microsoft.Build.Utilities.ToolTask.ProcessStarted() -> void
+virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEncoding.get -> System.Text.Encoding
+virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEscape(string responseString) -> string
+virtual Microsoft.Build.Utilities.ToolTask.SkipTaskExecution() -> bool
+virtual Microsoft.Build.Utilities.ToolTask.StandardErrorEncoding.get -> System.Text.Encoding
+virtual Microsoft.Build.Utilities.ToolTask.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+virtual Microsoft.Build.Utilities.ToolTask.StandardOutputEncoding.get -> System.Text.Encoding
+virtual Microsoft.Build.Utilities.ToolTask.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
+virtual Microsoft.Build.Utilities.ToolTask.Timeout.get -> int
+virtual Microsoft.Build.Utilities.ToolTask.Timeout.set -> void
+virtual Microsoft.Build.Utilities.ToolTask.ToolExe.get -> string
+virtual Microsoft.Build.Utilities.ToolTask.ToolExe.set -> void
+virtual Microsoft.Build.Utilities.ToolTask.ValidateParameters() -> bool
\ No newline at end of file
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index e34d6eef2af..6237b17f4c7 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2199,7 +2199,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
                 }
             }
 
-            return new List<string>();
+            return pathsList ?? new List<string>();
         }
 
         /// <summary>
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index e7766038d11..6f58e9e66f0 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -638,12 +638,12 @@ string responseFileSwitch
             // New style environment overrides
             if (_environmentVariablePairs != null)
             {
-                foreach (KeyValuePair<object, object> variable in _environmentVariablePairs)
+                foreach (KeyValuePair<string, string> variable in _environmentVariablePairs)
                 {
 #if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
-                    startInfo.Environment[(string)variable.Key] = (string)variable.Value;
+                    startInfo.Environment[variable.Key] = variable.Value;
 #else
-                    startInfo.EnvironmentVariables[(string)variable.Key] = (string)variable.Value;
+                    startInfo.EnvironmentVariables[variable.Key] = variable.Value;
 #endif
                 }
             }
@@ -902,7 +902,7 @@ private void HandleToolNotifications(Process proc)
                             break;
 
                         default:
-                            ErrorUtilities.VerifyThrow(false, "Unknown tool notification.");
+                            ErrorUtilities.ThrowInternalError("Unknown tool notification.");
                             break;
                     }
                 }
@@ -1306,7 +1306,7 @@ public override bool Execute()
 
             if (EnvironmentVariables != null)
             {
-                _environmentVariablePairs = new List<KeyValuePair<object, object>>(EnvironmentVariables.Length);
+                _environmentVariablePairs = new List<KeyValuePair<string, string>>(EnvironmentVariables.Length);
 
                 foreach (string entry in EnvironmentVariables)
                 {
@@ -1318,7 +1318,7 @@ public override bool Execute()
                         return false;
                     }
 
-                    _environmentVariablePairs.Add(new KeyValuePair<object, object>((object)nameValuePair[0], (object)nameValuePair[1]));
+                    _environmentVariablePairs.Add(new KeyValuePair<string, string>(nameValuePair[0], nameValuePair[1]));
                 }
             }
 
@@ -1470,9 +1470,9 @@ public override bool Execute()
                 // New style environment overrides
                 if (_environmentVariablePairs != null)
                 {
-                    foreach (KeyValuePair<object, object> variable in _environmentVariablePairs)
+                    foreach (KeyValuePair<string, string> variable in _environmentVariablePairs)
                     {
-                        alreadyLoggedEnvironmentHeader = LogEnvironmentVariable(alreadyLoggedEnvironmentHeader, (string)variable.Key, (string)variable.Value);
+                        alreadyLoggedEnvironmentHeader = LogEnvironmentVariable(alreadyLoggedEnvironmentHeader, variable.Key, variable.Value);
                     }
                 }
 
@@ -1696,9 +1696,8 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         /// <summary>
         /// List of name, value pairs to be passed to the spawned tool's environment.
         /// May be null.
-        /// Object is used instead of string to avoid NGen/JIT FXcop flagging.
         /// </summary>
-        private List<KeyValuePair<object, object>> _environmentVariablePairs;
+        private List<KeyValuePair<string, string>> _environmentVariablePairs;
 
         /// <summary>
         /// Enumeration which indicates what kind of queue is being passed
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index ec2d396bfc5..423083dbd1b 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 
 using System.Collections.Generic;
@@ -13,8 +15,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
-#if FEATURE_FILE_TRACKER
-
 namespace Microsoft.Build.Utilities
 {
     /// <summary>
@@ -58,7 +58,7 @@ public enum ExecutableType
     /// </summary>
     public static class FileTracker
     {
-        #region Static Member Data
+#region Static Member Data
 
         // The default path to temp, used to create explicitly short and long paths
         private static readonly string s_tempPath = Path.GetTempPath();
@@ -101,9 +101,9 @@ public static class FileTracker
         // Static cache of the path separator character in an array for use in String.Split.
         private static readonly string pathSeparator = Path.PathSeparator.ToString();
 
-        #endregion
+#endregion
 
-        #region Static constructor
+#region Static constructor
 
         static FileTracker()
         {
@@ -128,9 +128,9 @@ static FileTracker()
             }
         }
 
-        #endregion
+#endregion
 
-        #region Native method wrappers
+#region Native method wrappers
 
         /// <summary>
         /// Stops tracking file accesses.  
@@ -195,9 +195,9 @@ public static void StartTrackingContextWithRoot(string intermediateDirectory, st
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteContextTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteContextTLogs(intermediateDirectory, taskName);
 
-        #endregion // Native method wrappers
+#endregion // Native method wrappers
 
-        #region Methods
+#region Methods
 
         /// <summary>
         /// Test to see if the specified file is excluded from tracked dependencies
@@ -627,7 +627,7 @@ public static string TrackerArguments(string command, string arguments, string d
         public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName)
             => TrackerResponseFileArguments(dllName, intermediateDirectory, rootFiles, cancelEventName) + TrackerCommandArguments(command, arguments);
 
-        #region StartProcess methods
+#region StartProcess methods
 
         /// <summary>
         /// Start the process; tracking the command.  
@@ -694,7 +694,7 @@ public static Process StartProcess(string command, string arguments, ExecutableT
         public static Process StartProcess(string command, string arguments, ExecutableType toolType)
             => StartProcess(command, arguments, toolType, null, null, null, null);
 
-        #endregion // StartProcess methods
+#endregion // StartProcess methods
 
         /// <summary>
         /// Logs a message of the given importance using the specified resource string. To the specified Log.
@@ -744,7 +744,7 @@ internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, stri
             Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
         }
 
-        #endregion
+#endregion
     }
 
     /// <summary>
