diff --git a/documentation/Property-tracking-capabilities.md b/documentation/Property-tracking-capabilities.md
new file mode 100644
index 00000000000..a2cef4e2543
--- /dev/null
+++ b/documentation/Property-tracking-capabilities.md
@@ -0,0 +1,49 @@
+# MSBuild's property tracking capabilities
+
+MSBuild Property Tracking is a built-in diagnostic feature that tracks property value changes during the build process.
+By default, this feature is opted out due to performance considerations.
+
+## Property Tracking Coverage
+
+The implementation tracks properties in the following scenarios:
+
+1. Properties set via command-line arguments (e.g. using `/p:` switches)
+
+2. Properties defined based on environment variables and used by MSBuild
+
+3. Properties set as target outputs
+   - Tracks changes when properties are modified by target execution
+
+4. Properties set as task outputs
+   - Monitors property modifications resulting from task execution
+
+5. Properties defined in XML during evaluation
+   - Provides exact location information for properties defined in project files
+   - Includes line and column information from the source XML
+   - Reports on property modifications
+
+## Event Types and Message Formatting
+
+The feature implements specialized event handling for three scenarios:
+
+1. `PropertyReassignmentEventArgs`
+   - Triggered when a property value is changed
+   `set MsBuildLogPropertyTracking=1`
+
+2. `PropertyInitialValueSetEventArgs`
+   - Triggered when a property is first initialized
+   `set MsBuildLogPropertyTracking=2`
+
+3. `EnvironmentVariableRead`
+   - Tracks when environment variables are read
+   `set MsBuildLogPropertyTracking=4`
+
+4. `UninitializedPropertyReadEventArgs`
+   - Triggered when attempting to read a property that hasn't been initialized
+   `set MsBuildLogPropertyTracking=8`
+
+5. None
+   - Disables all property tracking
+   `set MsBuildLogPropertyTracking=0`
+
+If you want to enable all these events reporting, enable it by `set MsBuildLogPropertyTracking=15`.
\ No newline at end of file
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index e9852d79c36..9c7670ec563 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -71,19 +71,19 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25077.4">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>bac7e1caea791275b7c3ccb4cb75fd6a04a26618</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25077.4">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>bac7e1caea791275b7c3ccb4cb75fd6a04a26618</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25077.4">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>bac7e1caea791275b7c3ccb4cb75fd6a04a26618</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.13.1-rc.1">
       <Uri>https://github.com/nuget/nuget.client</Uri>
@@ -98,9 +98,9 @@
       <Sha>19c9b9eb00ae9afa7bedb10bd6be06bb41a880f6</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25077.4">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>bac7e1caea791275b7c3ccb4cb75fd6a04a26618</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 610139fb61c..bdd84bbeff0 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -61,7 +61,7 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25077.4</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25111.5</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftNetCompilersToolsetVersion>4.14.0-2.25111.1</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.13.0-rc.113</NuGetBuildTasksVersion>
   </PropertyGroup>
diff --git a/global.json b/global.json
index eaefaede835..ee7246df20f 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.102",
+    "dotnet": "9.0.103",
     "vs": {
       "version": "17.12.0"
     },
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25077.4"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25111.5"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index 72f2b212e3f..99f6603f61c 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -78,28 +78,19 @@ public BuildManager_Logging_Tests(ITestOutputHelper output)
             _env = TestEnvironment.Create(output);
         }
 
-        [DotNetOnlyTheory]
-        [InlineData("1", true)]
-        // [InlineData("0", true)] <-- explicitly opting out on core will lead to node crash (as documented)
-        [InlineData(null, true)]
-        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)
-            => TestCustomEventWarning<BuildErrorEventArgs>(envVariableValue, isWarningExpected);
-
-        [WindowsFullFrameworkOnlyTheory]
-        [InlineData("1", true)]
-        [InlineData("0", false)]
-        [InlineData(null, true)]
-        public void Build_WithCustomBuildArgs_Framework(string envVariableValue, bool isWarningExpected) =>
-            TestCustomEventWarning<BuildWarningEventArgs>(envVariableValue, isWarningExpected);
-
-        private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningExpected) where T : LazyFormattedBuildEventArgs
+        [DotNetOnlyFact]
+        public void Build_WithCustomBuildArgs_ShouldEmitErrorOnNetCore() => Build_WithCustomBuildArgs_ShouldEmitEvent<BuildErrorEventArgs>();
+
+        [WindowsFullFrameworkOnlyFact]
+        public void Build_WithCustomBuildArgs_ShouldEmitWarningOnFramework() => Build_WithCustomBuildArgs_ShouldEmitEvent<BuildWarningEventArgs>();
+
+        private void Build_WithCustomBuildArgs_ShouldEmitEvent<T>() where T : LazyFormattedBuildEventArgs
         {
-            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, new[] { "main", "child1" }, string.Empty);
+            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, ["main", "child1"], string.Empty);
 
             ILoggingService service = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(_logger);
 
-            _env.SetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING", envVariableValue);
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
             _buildManager.BeginBuild(BuildParameters);
@@ -118,24 +109,17 @@ private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningEx
                    mainProjectPath,
                    new Dictionary<string, string>(),
                    MSBuildConstants.CurrentToolsVersion,
-                   new[] { "MainTarget" },
+                   ["MainTarget"],
                    null);
 
                 var submission = _buildManager.PendBuildRequest(buildRequestData);
                 var result = submission.Execute();
                 var allEvents = _logger.AllBuildEvents;
 
-                if (isWarningExpected)
-                {
-                    allEvents.OfType<T>().ShouldHaveSingleItem();
-                    allEvents.First(x => x is T).Message.ShouldContain(
-                        string.Format(ResourceUtilities.GetResourceString("DeprecatedEventSerialization"),
-                        "MyCustomBuildEventArgs"));
-                }
-                else
-                {
-                    allEvents.OfType<T>().ShouldBeEmpty();
-                }
+                allEvents.OfType<T>().ShouldHaveSingleItem();
+                allEvents.First(x => x is T).Message.ShouldContain(
+                    string.Format(ResourceUtilities.GetResourceString("DeprecatedEventSerialization"),
+                    "MyCustomBuildEventArgs"));
             }
             finally
             {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 707587dd7b8..2eef5fde018 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -881,8 +881,11 @@ public void RoundTripPropertyReassignmentEventArgs()
                 propertyName: "a",
                 previousValue: "b",
                 newValue: "c",
-                location: "d",
-                message: "Property reassignment: $(a)=\"c\" (previous value: \"b\") at d",
+                location: null,
+                file: "file.cs",
+                line: 10,
+                column: 20,
+                message: "Property reassignment: $(a)=\"c\" (previous value: \"b\") at file.cs (10,20)",
                 helpKeyword: "e",
                 senderName: "f");
 
@@ -900,8 +903,8 @@ public void RoundTripPropertyReassignmentEventArgs()
         public void UninitializedPropertyReadEventArgs()
         {
             var args = new UninitializedPropertyReadEventArgs(
-                propertyName: Guid.NewGuid().ToString(),
-                message: Guid.NewGuid().ToString(),
+                propertyName: "a",
+                message: "Read uninitialized property \"a\"",
                 helpKeyword: Guid.NewGuid().ToString(),
                 senderName: Guid.NewGuid().ToString());
 
@@ -916,17 +919,22 @@ public void UninitializedPropertyReadEventArgs()
         public void PropertyInitialValueEventArgs()
         {
             var args = new PropertyInitialValueSetEventArgs(
-                propertyName: Guid.NewGuid().ToString(),
-                propertyValue: Guid.NewGuid().ToString(),
-                propertySource: Guid.NewGuid().ToString(),
-                message: Guid.NewGuid().ToString(),
+                propertyName: "a",
+                propertyValue: "b",
+                propertySource: null,
+                file: "file.cs",
+                line: 10,
+                column: 20,
+                message: "Property initial value: $(a)=\"b\" Source: file.cs (10,20)",
                 helpKeyword: Guid.NewGuid().ToString(),
                 senderName: Guid.NewGuid().ToString());
 
             Roundtrip(args,
                 e => e.PropertyName,
                 e => e.PropertyValue,
-                e => e.PropertySource,
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.ColumnNumber.ToString(),
                 e => e.Message,
                 e => e.HelpKeyword,
                 e => e.SenderName);
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 117da04ce76..a456097ddbc 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4743,7 +4743,7 @@ public void VerifyPropertyTrackingLoggingDefault()
             // Having just environment variables defined should default to nothing being logged except one environment variable read.
             VerifyPropertyTrackingLoggingScenario(
                 null,
-                logger =>
+                 (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4775,7 +4775,7 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
         {
             VerifyPropertyTrackingLoggingScenario(
                 "1",
-                logger =>
+                (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4806,7 +4806,7 @@ public void VerifyPropertyTrackingLoggingNone()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "0",
-                logger =>
+                 (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4838,7 +4838,7 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "2",
-                logger =>
+                (logger, projectPath) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4864,11 +4864,11 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
 
                     // Verify logging of property initial values.
                     propertyInitialValueMap.ShouldContainKey("Prop");
-                    propertyInitialValueMap["Prop"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop"].PropertyValue.ShouldBe(string.Empty);
 
                     propertyInitialValueMap.ShouldContainKey("EnvVar");
-                    propertyInitialValueMap["EnvVar"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["EnvVar"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["EnvVar"].PropertyValue.ShouldBe("It's also Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("DEFINED_ENVIRONMENT_VARIABLE");
@@ -4876,11 +4876,11 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
                     propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertyValue.ShouldBe("It's Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("NotEnvVarRead");
-                    propertyInitialValueMap["NotEnvVarRead"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["NotEnvVarRead"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["NotEnvVarRead"].PropertyValue.ShouldBe("Overwritten!");
 
                     propertyInitialValueMap.ShouldContainKey("Prop2");
-                    propertyInitialValueMap["Prop2"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop2"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop2"].PropertyValue.ShouldBe("Value1");
                 });
         }
@@ -4890,7 +4890,7 @@ public void VerifyPropertyTrackingLoggingEnvironmentVariableRead()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "4",
-                logger =>
+                (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4924,7 +4924,7 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "8",
-                logger =>
+                (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4955,7 +4955,7 @@ public void VerifyPropertyTrackingLoggingAll()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "15",
-                logger =>
+                (logger, projectPath) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4984,11 +4984,11 @@ public void VerifyPropertyTrackingLoggingAll()
 
                     // Verify logging of property initial values.
                     propertyInitialValueMap.ShouldContainKey("Prop");
-                    propertyInitialValueMap["Prop"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop"].PropertyValue.ShouldBe(string.Empty);
 
                     propertyInitialValueMap.ShouldContainKey("EnvVar");
-                    propertyInitialValueMap["EnvVar"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["EnvVar"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["EnvVar"].PropertyValue.ShouldBe("It's also Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("DEFINED_ENVIRONMENT_VARIABLE");
@@ -4996,11 +4996,11 @@ public void VerifyPropertyTrackingLoggingAll()
                     propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertyValue.ShouldBe("It's Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("NotEnvVarRead");
-                    propertyInitialValueMap["NotEnvVarRead"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["NotEnvVarRead"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["NotEnvVarRead"].PropertyValue.ShouldBe("Overwritten!");
 
                     propertyInitialValueMap.ShouldContainKey("Prop2");
-                    propertyInitialValueMap["Prop2"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop2"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop2"].PropertyValue.ShouldBe("Value1");
                 });
         }
@@ -5022,7 +5022,7 @@ public void VerifyGetTypeEvaluationBlocked()
                 new Project(XmlReader.Create(new StringReader(projectContents)), null, "Fake", fakeProjectCollection));
         }
 
-        private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<MockLogger> loggerEvaluatorAction)
+        private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<MockLogger, string> loggerEvaluatorAction)
         {
             // The default is that only reassignments are logged.
 
@@ -5061,7 +5061,7 @@ private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<Mo
 
                 project.Build().ShouldBeTrue();
 
-                loggerEvaluatorAction?.Invoke(logger);
+                loggerEvaluatorAction?.Invoke(logger, tempPath.Path);
             }
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index a8d528d4fb4..6a60fd9ac0c 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -146,6 +146,11 @@ public class BuildParameters : ITranslatable
         /// </summary>
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties = new PropertyDictionary<ProjectPropertyInstance>();
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        private ICollection<string> _propertiesFromCommandLine;
+
         /// <summary>
         /// The loggers.
         /// </summary>
@@ -250,6 +255,7 @@ public BuildParameters(ProjectCollection projectCollection)
             _defaultToolsVersion = projectCollection.DefaultToolsVersion;
 
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(projectCollection.GlobalPropertiesCollection);
+            _propertiesFromCommandLine = projectCollection.PropertiesFromCommandLine;
         }
 
         /// <summary>
@@ -279,6 +285,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _environmentProperties = other._environmentProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._environmentProperties) : null;
             _forwardingLoggers = other._forwardingLoggers != null ? new List<ForwardingLoggerRecord>(other._forwardingLoggers) : null;
             _globalProperties = other._globalProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._globalProperties) : null;
+            _propertiesFromCommandLine = other._propertiesFromCommandLine != null ? new HashSet<string>(other._propertiesFromCommandLine, StringComparer.OrdinalIgnoreCase) : null;
             HostServices = other.HostServices;
             _loggers = other._loggers != null ? new List<ILogger>(other._loggers) : null;
             _maxNodeCount = other._maxNodeCount;
@@ -332,6 +339,10 @@ public bool UseSynchronousLogging
             set => _useSynchronousLogging = value;
         }
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        public ICollection<string> PropertiesFromCommandLine => _propertiesFromCommandLine;
 
         /// <summary>
         /// Indicates whether to emit a default error if a task returns false without logging an error.
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index c826b40c316..c08622d49eb 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -980,58 +980,11 @@ public void PacketReceived(int node, INodePacket packet)
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
             InjectNonSerializedData(loggingPacket);
 
-            WarnOnDeprecatedCustomArgsSerialization(loggingPacket);
+            ErrorUtilities.VerifyThrow(loggingPacket.EventType != LoggingEventType.CustomEvent, "Custom event types are no longer supported. Does the sending node have a different version?");
 
             ProcessLoggingEvent(loggingPacket.NodeBuildEvent);
         }
 
-        /// <summary>
-        /// Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet.
-        /// Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom
-        /// EventArgs derived from existing EventArgs.
-        /// </summary>
-        private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)
-        {
-            if (loggingPacket.EventType == LoggingEventType.CustomEvent
-                && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
-            {
-                BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;
-                BuildEventContext buildEventContext = buildEvent?.BuildEventContext ?? BuildEventContext.Invalid;
-
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
-                    out string warningCode,
-                    out string helpKeyword,
-                    "DeprecatedEventSerialization",
-                    buildEvent?.GetType().Name ?? string.Empty);
-
-                BuildWarningEventArgs warning = new(
-                    null,
-                    warningCode,
-                    BuildEventFileInfo.Empty.File,
-                    BuildEventFileInfo.Empty.Line,
-                    BuildEventFileInfo.Empty.Column,
-                    BuildEventFileInfo.Empty.EndLine,
-                    BuildEventFileInfo.Empty.EndColumn,
-                    message,
-                    helpKeyword,
-                    "MSBuild");
-
-                warning.BuildEventContext = buildEventContext;
-                if (warning.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    warning.ProjectFile = buildEvent switch
-                    {
-                        BuildMessageEventArgs buildMessageEvent => buildMessageEvent.ProjectFile,
-                        BuildErrorEventArgs buildErrorEvent => buildErrorEvent.ProjectFile,
-                        BuildWarningEventArgs buildWarningEvent => buildWarningEvent.ProjectFile,
-                        _ => null,
-                    };
-                }
-
-                ProcessLoggingEvent(warning);
-            }
-        }
-
         /// <summary>
         /// Register an instantiated logger which implements the ILogger interface. This logger will be registered to a specific event
         /// source (the central logger event source) which will receive all logging messages for a given build.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index 02ca6a1dab8..5bd3a49c331 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -25,6 +25,8 @@ internal class PropertyGroupIntrinsicTask : IntrinsicTask
         /// </summary>
         private ProjectPropertyGroupTaskInstance _taskInstance;
 
+        private readonly PropertyTrackingSetting _propertyTrackingSettings;
+
         /// <summary>
         /// Create a new PropertyGroup task.
         /// </summary>
@@ -36,6 +38,7 @@ public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance,
             : base(loggingContext, projectInstance, logTaskInputs)
         {
             _taskInstance = taskInstance;
+            _propertyTrackingSettings = (PropertyTrackingSetting)Traits.Instance.LogPropertyTracking;
         }
 
         /// <summary>
@@ -85,6 +88,14 @@ internal override void ExecuteTask(Lookup lookup)
                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);
                             bucket.Expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);
 
+                            PropertyTrackingUtils.LogPropertyAssignment(
+                                _propertyTrackingSettings,
+                                property.Name,
+                                evaluatedValue,
+                                property.Location,
+                                Project.GetProperty(property.Name)?.EvaluatedValue ?? null,
+                                LoggingContext);
+
                             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents)
                             {
                                 LoggingContext.LogComment(MessageImportance.Low, "PropertyGroupLogMessage", property.Name, evaluatedValue);
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 5148f89be9f..6a28b5e6c38 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -583,27 +583,27 @@ private void SendPacket(INodePacket packet)
         {
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
-#if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
-                    && logMessage.EventType == LoggingEventType.CustomEvent
-                    && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
+                    && logMessage.EventType == LoggingEventType.CustomEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
 
                     // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>
                     // Since BinaryFormatter is deprecated in dotnet 8+, log error so users discover root cause easier
                     // then by reading CommTrace where it would be otherwise logged as critical infra error.
-                    _loggingService.LogError(_loggingContext?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,
-                            "DeprecatedEventSerialization",
-                            buildEvent?.GetType().Name ?? string.Empty);
+#if RUNTIME_TYPE_NETCORE
+                    _loggingService.LogError(
+#else
+                    _loggingService.LogWarning(
+#endif
+                        _loggingContext?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,
+                        "DeprecatedEventSerialization",
+                        buildEvent?.GetType().Name ?? string.Empty);
                 }
                 else
                 {
                     _nodeEndpoint.SendData(packet);
                 }
-#else
-                _nodeEndpoint.SendData(packet);
-#endif
             }
         }
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index dc2383d7034..2f5a26be1fc 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -156,6 +156,8 @@ internal class TaskExecutionHost : IDisposable
         /// </summary>
         private readonly Dictionary<string, TaskFactoryWrapper> _intrinsicTasks = new Dictionary<string, TaskFactoryWrapper>(StringComparer.OrdinalIgnoreCase);
 
+        private readonly PropertyTrackingSetting _propertyTrackingSettings;
+
         /// <summary>
         /// Constructor
         /// </summary>
@@ -172,6 +174,8 @@ internal TaskExecutionHost(IBuildComponentHost host)
             {
                 LogTaskInputs = Traits.Instance.EscapeHatches.LogTaskInputs;
             }
+
+            _propertyTrackingSettings = (PropertyTrackingSetting)Traits.Instance.LogPropertyTracking;
         }
 
         /// <summary>
@@ -1585,6 +1589,14 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                             }
                         }
 
+                        PropertyTrackingUtils.LogPropertyAssignment(
+                            _propertyTrackingSettings,
+                            outputTargetName,
+                            outputString,
+                            parameterLocation,
+                            _projectInstance.GetProperty(outputTargetName)?.EvaluatedValue ?? null,
+                            _taskLoggingContext);
+
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
                     }
                 }
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 4a868767aea..1348a7cffcc 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3721,6 +3721,7 @@ private void Reevaluate(
                     loadSettings,
                     ProjectCollection.MaxNodeCount,
                     ProjectCollection.EnvironmentProperties,
+                    ProjectCollection.PropertiesFromCommandLine,
                     loggingServiceForEvaluation,
                     new ProjectItemFactory(Owner),
                     ProjectCollection,
@@ -4437,7 +4438,7 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false)
             {
                 ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
                 Properties.Set(property);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 031e31f1e2e..9973e5d3d80 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -497,6 +497,11 @@ public static string DisplayVersion
             }
         }
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        public ICollection<string> PropertiesFromCommandLine { get; set; }
+
         /// <summary>
         /// The default tools version of this project collection. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index daf8d0ea71b..e285a948aa4 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -158,6 +157,11 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private readonly PropertyDictionary<ProjectPropertyInstance> _environmentProperties;
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        private readonly ICollection<string> _propertiesFromCommandLine;
+
         /// <summary>
         /// The cache to consult for any imports that need loading.
         /// </summary>
@@ -201,6 +205,7 @@ private Evaluator(
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
+            ICollection<string> propertiesFromCommandLine,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
             IDirectoryCacheFactory directoryCacheFactory,
@@ -253,6 +258,7 @@ private Evaluator(
             _loadSettings = loadSettings;
             _maxNodeCount = maxNodeCount;
             _environmentProperties = environmentProperties;
+            _propertiesFromCommandLine = propertiesFromCommandLine ?? [];
             _itemFactory = itemFactory;
             _projectRootElementCache = projectRootElementCache;
             _sdkResolverService = sdkResolverService;
@@ -301,6 +307,7 @@ internal static void Evaluate(
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
+            ICollection<string> propertiesFromCommandLine,
             ILoggingService loggingService,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
@@ -321,6 +328,7 @@ internal static void Evaluate(
                 loadSettings,
                 maxNodeCount,
                 environmentProperties,
+                propertiesFromCommandLine,
                 itemFactory,
                 toolsetProvider,
                 directoryCacheFactory,
@@ -1240,7 +1248,7 @@ private void AddToolsetProperties()
         }
 
         /// <summary>
-        /// Put all the global properties into our property bag
+        /// Put all the global properties into our property bag.
         /// </summary>
         private int AddGlobalProperties()
         {
@@ -1251,7 +1259,13 @@ private int AddGlobalProperties()
 
             foreach (ProjectPropertyInstance globalProperty in _data.GlobalPropertiesDictionary)
             {
-                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);
+                _ = _data.SetProperty(
+                    globalProperty.Name,
+                    ((IProperty)globalProperty).EvaluatedValueEscaped,
+                    isGlobalProperty: true /* it is a global property, but it comes from command line and is tracked separately */,
+                    mayBeReserved: false /* may NOT be a reserved name */,
+                    loggingContext: _evaluationLoggingContext,
+                    isCommandLineProperty: _propertiesFromCommandLine.Contains(globalProperty.Name) /* IS coming from command line argument */);
             }
 
             return _data.GlobalPropertiesDictionary.Count;
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 212f446d70f..82ad36d6650 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -268,7 +268,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, BackEnd.Logging.LoggingContext loggingContext, bool isEnvironmentVariable = false);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, BackEnd.Logging.LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 5d749befd8d..b4685fa40d4 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -311,9 +311,9 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped, loggingContext);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false)
             {
-                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
+                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext, isCommandLineProperty);
             }
         }
     }
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 1e9861f742b..c7b8ae0d6ad 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -87,16 +87,23 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
+        public P SetProperty(
+            string name,
+            string evaluatedValueEscaped,
+            bool isGlobalProperty,
+            bool mayBeReserved,
+            LoggingContext loggingContext,
+            bool isEnvironmentVariable = false,
+            bool isCommandLineProperty = false)
         {
             P? originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, _evaluationLoggingContext, isEnvironmentVariable);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, _evaluationLoggingContext, isEnvironmentVariable, isCommandLineProperty);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
                 null,
-                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable),
+                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable, isCommandLineProperty),
                 loggingContext);
 
             return newProperty;
@@ -168,13 +175,10 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         #region Private Methods...
 
         private bool IsPropertyReadTrackingRequested
-            => IsEnvironmentVariableReadTrackingRequested ||
-               (_settings & PropertyTrackingSetting.UninitializedPropertyRead) ==
-               PropertyTrackingSetting.UninitializedPropertyRead;
+            => IsEnvironmentVariableReadTrackingRequested
+            || PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.UninitializedPropertyRead);
 
-        private bool IsEnvironmentVariableReadTrackingRequested
-            => (_settings & PropertyTrackingSetting.EnvironmentVariableRead) ==
-               PropertyTrackingSetting.EnvironmentVariableRead;
+        private bool IsEnvironmentVariableReadTrackingRequested => PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.EnvironmentVariableRead);
 
         /// <summary>
         /// Logic containing what to do when a property is read.
@@ -209,7 +213,7 @@ private void TrackPropertyRead(string name, P property)
         /// <param name="name">The name of the environment variable read.</param>
         private void TrackEnvironmentVariableRead(string name)
         {
-            if ((_settings & PropertyTrackingSetting.EnvironmentVariableRead) != PropertyTrackingSetting.EnvironmentVariableRead)
+            if (!IsEnvironmentVariableReadTrackingRequested)
             {
                 return;
             }
@@ -231,15 +235,15 @@ private void TrackEnvironmentVariableRead(string name)
         /// <param name="name">The name of the uninitialized property read.</param>
         private void TrackUninitializedPropertyRead(string name)
         {
-            if ((_settings & PropertyTrackingSetting.UninitializedPropertyRead) != PropertyTrackingSetting.UninitializedPropertyRead)
+            if (!PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.UninitializedPropertyRead))
             {
                 return;
             }
 
-            var args = new UninitializedPropertyReadEventArgs(
-                name,
-                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("UninitializedPropertyRead", name));
-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+            var args = new UninitializedPropertyReadEventArgs(name, message: null)
+            {
+                BuildEventContext = _evaluationLoggingContext.BuildEventContext,
+            };
 
             _evaluationLoggingContext.LogBuildEvent(args);
         }
@@ -258,12 +262,12 @@ private void TrackPropertyWrite(
             if (predecessor == null)
             {
                 // If this property had no previous value, then track an initial value.
-                TrackPropertyInitialValueSet(property, source);
+                TrackPropertyInitialValueSet(property, source, location);
             }
             else
             {
                 // There was a previous value, and it might have been changed. Track that.
-                TrackPropertyReassignment(predecessor, property, location?.LocationString);
+                TrackPropertyReassignment(predecessor, property, location);
             }
 
             // If this property was an environment variable but no longer is, track it.
@@ -278,19 +282,25 @@ private void TrackPropertyWrite(
         /// </summary>
         /// <param name="property">The property being set.</param>
         /// <param name="source">The source of the property.</param>
-        private void TrackPropertyInitialValueSet(P property, PropertySource source)
+        /// <param name="location">The exact location of the property. Can be null if comes not form xml.</param>
+        private void TrackPropertyInitialValueSet(P property, PropertySource source, IElementLocation? location)
         {
-            if ((_settings & PropertyTrackingSetting.PropertyInitialValueSet) != PropertyTrackingSetting.PropertyInitialValueSet)
+            if (!PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.PropertyInitialValueSet))
             {
                 return;
             }
 
             var args = new PropertyInitialValueSetEventArgs(
-                    property.Name,
-                    property.EvaluatedValue,
-                    source.ToString(),
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyAssignment", property.Name, property.EvaluatedValue, source));
-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+                property.Name,
+                property.EvaluatedValue,
+
+                // If the property is from XML, we don't need property source since a full location is available.
+                location == null ? GetPropertySourceName(source) : string.Empty,
+                location?.File,
+                location?.Line ?? 0,
+                location?.Column ?? 0,
+                message: null)
+            { BuildEventContext = _evaluationLoggingContext.BuildEventContext, };
 
             _evaluationLoggingContext.LogBuildEvent(args);
         }
@@ -301,7 +311,7 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)
         /// <param name="predecessor">The property's preceding state. Null if none.</param>
         /// <param name="property">The property's current state.</param>
         /// <param name="location">The location of this property's reassignment.</param>
-        private void TrackPropertyReassignment(P? predecessor, P property, string? location)
+        private void TrackPropertyReassignment(P? predecessor, P property, IElementLocation? location)
         {
             if (MSBuildNameIgnoreCaseComparer.Default.Equals(property.Name, "MSBuildAllProjects"))
             {
@@ -317,17 +327,17 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat
                 return;
             }
 
-            // Either we want to specifically track property reassignments
-            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.
-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||
-                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))
+            if (PropertyTrackingUtils.IsPropertyReassignmentEnabled(_settings))
             {
                 var args = new PropertyReassignmentEventArgs(
-                        property.Name,
-                        oldValue,
-                        newValue,
-                        location,
-                        message: null)
+                    property.Name,
+                    oldValue,
+                    newValue,
+                    location: null,
+                    location?.File,
+                    location?.Line ?? 0,
+                    location?.Column ?? 0,
+                    message: null)
                 { BuildEventContext = _evaluationLoggingContext.BuildEventContext, };
 
                 _evaluationLoggingContext.LogBuildEvent(args);
@@ -347,7 +357,7 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat
         /// <summary>
         /// Determines the source of a property given the variables SetProperty arguments provided. This logic follows what's in <see cref="Evaluator{P,I,M,D}"/>.
         /// </summary>
-        private PropertySource DeterminePropertySource(bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
+        private PropertySource DeterminePropertySource(bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, bool isCommandLineProperty)
         {
             if (isEnvironmentVariable)
             {
@@ -356,7 +366,7 @@ private PropertySource DeterminePropertySource(bool isGlobalProperty, bool mayBe
 
             if (isGlobalProperty)
             {
-                return PropertySource.Global;
+                return isCommandLineProperty ? PropertySource.CommandLine : PropertySource.Global;
             }
 
             return mayBeReserved ? PropertySource.BuiltIn : PropertySource.Toolset;
@@ -373,20 +383,107 @@ private enum PropertySource
             BuiltIn,
             Global,
             Toolset,
-            EnvironmentVariable
+            EnvironmentVariable,
+            CommandLine,
         }
 
-        [Flags]
-        private enum PropertyTrackingSetting
+        private static string GetPropertySourceName(PropertySource source) => source switch
         {
-            None = 0,
+            PropertySource.Xml => "Xml",
+            PropertySource.BuiltIn => "BuiltIn",
+            PropertySource.Global => "Global",
+            PropertySource.Toolset => "Toolset",
+            PropertySource.EnvironmentVariable => "EnvironmentVariable",
+            PropertySource.CommandLine => "CommandLine",
+            _ => throw new ArgumentOutOfRangeException(nameof(source), source, null)
+        };
+    }
+
+    [Flags]
+    internal enum PropertyTrackingSetting
+    {
+        None = 0,
+
+        PropertyReassignment = 1,
+        PropertyInitialValueSet = 1 << 1,
+        EnvironmentVariableRead = 1 << 2,
+        UninitializedPropertyRead = 1 << 3,
+
+        All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead
+    }
 
-            PropertyReassignment = 1,
-            PropertyInitialValueSet = 1 << 1,
-            EnvironmentVariableRead = 1 << 2,
-            UninitializedPropertyRead = 1 << 3,
+    internal class PropertyTrackingUtils
+    {
+        /// <summary>
+        /// Determines if a specific property tracking setting is enabled within the provided settings configuration.
+        /// </summary>
+        /// <param name="settings">The combined property tracking settings value to check against.</param>
+        /// <param name="currentTrackingSetting">The specific tracking setting to verify.</param>
+        /// <returns>true if the specified tracking setting is enabled in the settings configuration.</returns>
+        internal static bool IsPropertyTrackingEnabled(PropertyTrackingSetting settings, PropertyTrackingSetting currentTrackingSetting) => (settings & currentTrackingSetting) == currentTrackingSetting;
 
-            All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead
+        // Either we want to specifically track property reassignments
+        // or we do not want to track nothing - in which case the prop reassignment is enabled by default.
+        internal static bool IsPropertyReassignmentEnabled(PropertyTrackingSetting currentTrackingSetting) => IsPropertyTrackingEnabled(currentTrackingSetting, PropertyTrackingSetting.PropertyReassignment)
+                || (currentTrackingSetting == PropertyTrackingSetting.None && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10));
+
+        /// <summary>
+        /// Logs property assignment information during execution, providing detailed tracking of property value changes.
+        /// This internal method handles two scenarios:
+        /// 1. Initial property value assignment (when previousPropertyValue is null)
+        /// 2. Property value reassignment (when previousPropertyValue has a value)
+        /// If property tracking is disabled (PropertyTrackingSetting.None), no logging occurs.
+        /// </summary>
+        /// <param name="settings">Controls what types of property assignments should be tracked.</param>
+        /// <param name="propertyName">Name of the property being modified.</param>
+        /// <param name="propertyValue">New value being assigned to the property.</param>
+        /// <param name="location">Source location information (file, line, column).</param>
+        /// <param name="previousPropertyValue">Previous value of the property, null if this is initial assignment.</param>
+        /// <param name="loggingContext">Context for logging build events.</param>
+        internal static void LogPropertyAssignment(
+            PropertyTrackingSetting settings,
+            string propertyName,
+            string propertyValue,
+            IElementLocation location,
+            string? previousPropertyValue,
+            LoggingContext loggingContext)
+        {
+            if (previousPropertyValue == null)
+            {
+                if (IsPropertyTrackingEnabled(settings, PropertyTrackingSetting.PropertyInitialValueSet))
+                {
+                    var args = new PropertyInitialValueSetEventArgs(
+                        propertyName,
+                        propertyValue,
+                        propertySource: string.Empty,
+                        location.File,
+                        location.Line,
+                        location.Column,
+                        message: null) { BuildEventContext = loggingContext.BuildEventContext };
+
+                    loggingContext.LogBuildEvent(args);
+                }
+            }
+            else
+            {
+                if (IsPropertyReassignmentEnabled(settings))
+                {
+                    if (propertyValue != previousPropertyValue)
+                    {
+                        var args = new PropertyReassignmentEventArgs(
+                            propertyName,
+                            previousPropertyValue,
+                            propertyValue,
+                            location: null,
+                            location.File,
+                            location.Line,
+                            location.Column,
+                            message: null) { BuildEventContext = loggingContext.BuildEventContext, };
+
+                        loggingContext.LogBuildEvent(args);
+                    }
+                }
+            }
         }
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index e5eba2b291e..938fcc5cba9 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1791,7 +1791,7 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable, bool isCommandLineProperty)
         {
             // Mutability not verified as this is being populated during evaluation
             ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
@@ -3175,6 +3175,7 @@ private void Initialize(
                 projectLoadSettings ?? buildParameters.ProjectLoadSettings, /* Use override ProjectLoadSettings if specified */
                 buildParameters.MaxNodeCount,
                 buildParameters.EnvironmentPropertiesInternal,
+                buildParameters.PropertiesFromCommandLine,
                 loggingService,
                 new ProjectItemInstanceFactory(this),
                 buildParameters.ToolsetProvider,
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index be4eaa2288d..adadde7eb8b 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -80,6 +80,8 @@ public sealed class BinaryLogger : ILogger
         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent
         // version 24:
         //    - new record kind: BuildCanceledEventArgs
+        // version 25:
+        //    - add extra information to PropertyInitialValueSetEventArgs and PropertyReassignmentEventArgs and change message formatting logic.
 
         // MAKE SURE YOU KEEP BuildEventArgsWriter AND StructuredLogViewer.BuildEventArgsWriter IN SYNC WITH THE CHANGES ABOVE.
         // Both components must stay in sync to avoid issues with logging or event handling in the products.
@@ -90,7 +92,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 24;
+        internal const int FileFormatVersion = 25;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 0b97024c472..4b48d9a8592 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -1177,6 +1177,9 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
                 previousValue,
                 newValue,
                 location,
+                fields.File,
+                fields.LineNumber,
+                fields.ColumnNumber,
                 fields.Message,
                 fields.HelpKeyword,
                 fields.SenderName,
@@ -1193,7 +1196,7 @@ private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
 
             var e = new UninitializedPropertyReadEventArgs(
                 propertyName,
-                fields.Message,
+                message: null,
                 fields.HelpKeyword,
                 fields.SenderName,
                 fields.Importance);
@@ -1214,10 +1217,14 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
                 propertyName,
                 propertyValue,
                 propertySource,
+                fields.File,
+                fields.LineNumber,
+                fields.ColumnNumber,
                 fields.Message,
                 fields.HelpKeyword,
                 fields.SenderName,
                 fields.Importance);
+
             SetCommonFields(e, fields);
 
             return e;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index dba52023339..fc44128aba0 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -572,19 +572,21 @@ private BinaryLogRecordKind Write(PropertyReassignmentEventArgs e)
             WriteDeduplicatedString(e.PreviousValue);
             WriteDeduplicatedString(e.NewValue);
             WriteDeduplicatedString(e.Location);
+
             return BinaryLogRecordKind.PropertyReassignment;
         }
 
         private BinaryLogRecordKind Write(UninitializedPropertyReadEventArgs e)
         {
-            WriteMessageFields(e, writeImportance: true);
+            WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
+
             return BinaryLogRecordKind.UninitializedPropertyRead;
         }
 
         private BinaryLogRecordKind Write(PropertyInitialValueSetEventArgs e)
         {
-            WriteMessageFields(e, writeImportance: true);
+            WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
             WriteDeduplicatedString(e.PropertyValue);
             WriteDeduplicatedString(e.PropertySource);
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 41a5914dad6..c302b537038 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -493,22 +493,6 @@ public void TranslateEnum<T>(ref T value, int numericValue)
                 value = (T)Enum.ToObject(enumType, numericValue);
             }
 
-            /// <summary>
-            /// Translates a value using the .Net binary formatter.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            public void TranslateDotNet<T>(ref T value)
-            {
-                if (!TranslateNullable(value))
-                {
-                    return;
-                }
-
-                BinaryFormatter formatter = new BinaryFormatter();
-                value = (T)formatter.Deserialize(_packetStream);
-            }
-
             public void TranslateException(ref Exception value)
             {
                 if (!TranslateNullable(value))
@@ -1190,26 +1174,6 @@ public void TranslateEnum<T>(ref T value, int numericValue)
                 _writer.Write(numericValue);
             }
 
-            /// <summary>
-            /// Translates a value using the .Net binary formatter.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            public void TranslateDotNet<T>(ref T value)
-            {
-                // All the calling paths are already guarded by ChangeWaves.Wave17_10 - so it's a no-op adding it here as well.
-                // But let's have it here explicitly - so it's clearer for the CodeQL reviewers.
-                if (!TranslateNullable(value) || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
-                {
-                    return;
-                }
-
-                // codeql[cs/dangerous-binary-deserialization] This code needs explicit opt-in to be used (ChangeWaves.Wave17_10). This exists as a temporary compat opt-in for old 3rd party loggers, before they are migrated based on documented guidance.
-                // The opt-in documentation: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves.md#1710
-                BinaryFormatter formatter = new BinaryFormatter();
-                formatter.Serialize(_packetStream, value);
-            }
-
             public void TranslateException(ref Exception value)
             {
                 if (!TranslateNullable(value))
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index edf5b47765e..5f6655cef36 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -255,18 +255,6 @@ BinaryWriter Writer
         void TranslateEnum<T>(ref T value, int numericValue)
             where T : struct, Enum;
 
-        /// <summary>
-        /// Translates a value using the .Net binary formatter.
-        /// </summary>
-        /// <typeparam name="T">The reference type.</typeparam>
-        /// <param name="value">The value to be translated.</param>
-        /// <remarks>
-        /// The primary purpose of this method is to support serialization of Exceptions and
-        /// custom build logging events, since these do not support our custom serialization
-        /// methods.
-        /// </remarks>
-        void TranslateDotNet<T>(ref T value);
-
         void TranslateException(ref Exception value);
 
         /// <summary>
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index 318755fcde3..fe1e52023b6 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -37,13 +37,45 @@ public PropertyInitialValueSetEventArgs(
             string message,
             string helpKeyword = null,
             string senderName = null,
-            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+            MessageImportance importance = MessageImportance.Low)
+            : base(message, helpKeyword, senderName, importance)
         {
             this.PropertyName = propertyName;
             this.PropertyValue = propertyValue;
             this.PropertySource = propertySource;
         }
 
+        /// <summary>
+        /// Creates an instance of the <see cref="PropertyInitialValueSetEventArgs"/> class.
+        /// </summary>
+        /// <param name="propertyName">The name of the property.</param>
+        /// <param name="propertyValue">The value of the property.</param>
+        /// <param name="propertySource">The source of the property.</param>
+        /// <param name="file">The file associated with the event.</param>
+        /// <param name="line">The line number (0 if not applicable).</param>
+        /// <param name="column">The column number (0 if not applicable).</param>
+        /// <param name="message">The message of the property.</param>
+        /// <param name="helpKeyword">The help keyword.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
+        public PropertyInitialValueSetEventArgs(
+            string propertyName,
+            string propertyValue,
+            string propertySource,
+            string file,
+            int line,
+            int column,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low)
+            : base(subcategory: null, code: null, file: file, lineNumber: line, columnNumber: column, 0, 0, message, helpKeyword, senderName, importance)
+        {
+            PropertyName = propertyName;
+            PropertyValue = propertyValue;
+            PropertySource = propertySource;
+        }
+
         /// <summary>
         /// The name of the property.
         /// </summary>
@@ -59,6 +91,20 @@ public PropertyInitialValueSetEventArgs(
         /// </summary>
         public string PropertySource { get; set; }
 
+        public override string Message
+        {
+            get
+            {
+                if (RawMessage == null)
+                {
+                    string formattedLocation = File == null ? PropertySource : $"{File} ({LineNumber},{ColumnNumber})";
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyAssignment", PropertyName, PropertyValue, formattedLocation);
+                }
+
+                return RawMessage;
+            }
+        }
+
         internal override void WriteToStream(BinaryWriter writer)
         {
             base.WriteToStream(writer);
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 29ec2935e0b..d7477ee8caa 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -41,12 +41,47 @@ public PropertyReassignmentEventArgs(
             string message,
             string helpKeyword = null,
             string senderName = null,
-            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+            MessageImportance importance = MessageImportance.Low)
+            : base(message, helpKeyword, senderName, importance)
         {
-            this.PropertyName = propertyName;
-            this.PreviousValue = previousValue;
-            this.NewValue = newValue;
-            this.Location = location;
+            PropertyName = propertyName;
+            PreviousValue = previousValue;
+            NewValue = newValue;
+            Location = location;
+        }
+
+        /// <summary>
+        /// Creates an instance of the <see cref="PropertyReassignmentEventArgs"/> class.
+        /// </summary>
+        /// <param name="propertyName">The name of the property whose value was reassigned.</param>
+        /// <param name="previousValue">The previous value of the reassigned property.</param>
+        /// <param name="newValue">The new value of the reassigned property.</param>
+        /// <param name="location">The property location (XML, command line, etc).</param>
+        /// <param name="file">The file associated with the event.</param>
+        /// <param name="line">The line number (0 if not applicable).</param>
+        /// <param name="column">The column number (0 if not applicable).</param>
+        /// <param name="message">The message of the property.</param>
+        /// <param name="helpKeyword">The help keyword.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
+        public PropertyReassignmentEventArgs(
+            string propertyName,
+            string previousValue,
+            string newValue,
+            string location,
+            string file,
+            int line,
+            int column,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low)
+            : base(subcategory: null, code: null, file: file, lineNumber: line, columnNumber: column, 0, 0, message, helpKeyword, senderName, importance)
+        {
+            PropertyName = propertyName;
+            PreviousValue = previousValue;
+            NewValue = newValue;
+            Location = location;
         }
 
         /// <summary>
@@ -75,7 +110,8 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyReassignment", PropertyName, NewValue, PreviousValue, Location);
+                    string formattedLocation = File == null ? Location : $"{File} ({LineNumber},{ColumnNumber})";
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyReassignment", PropertyName, NewValue, PreviousValue, formattedLocation);
                 }
 
                 return RawMessage;
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 9180690cd73..4519271a8b3 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -392,29 +392,6 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
             }
         }
 
-        /// <summary>
-        /// Allows displaying the deprecation warning for BinaryFormatter in your current environment.
-        /// </summary>
-        public bool EnableWarningOnCustomBuildEvent
-        {
-            get
-            {
-                var value = Environment.GetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING");
-
-                if (value == null)
-                {
-                    // If variable is not set explicitly, for .NETCORE warning appears.
-#if RUNTIME_TYPE_NETCORE
-                    return true;
-#else
-                    return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10);
-#endif
-                }
-
-                return value == "1";
-            }
-        }
-
         public bool UnquoteTargetSwitchParameters
         {
             get
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index 781c8c33bc8..7980bdb5485 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -51,11 +51,25 @@ internal override void WriteToStream(BinaryWriter writer)
 
             writer.WriteOptionalString(PropertyName);
         }
+
         internal override void CreateFromStream(BinaryReader reader, int version)
         {
             base.CreateFromStream(reader, version);
 
             PropertyName = reader.ReadOptionalString();
         }
+
+        public override string Message
+        {
+            get
+            {
+                if (RawMessage == null)
+                {
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("UninitializedPropertyRead", PropertyName);
+                }
+
+                return RawMessage;
+            }
+        }
     }
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index aeddef7aba4..c12cd96ec57 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -835,6 +835,9 @@ public static ExitType Execute(
                         {
                             using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
                             {
+                                // globalProperties collection contains values only from CommandLine at this stage populated by ProcessCommandLineSwitches
+                                collection.PropertiesFromCommandLine = [.. globalProperties.Keys];
+
                                 Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
 
                                 if (getResultOutputFile.Length == 0)
@@ -1393,6 +1396,9 @@ internal static bool BuildProject(
                     useAsynchronousLogging: true,
                     reuseProjectRootElementCache: s_isServerNode);
 
+                // globalProperties collection contains values only from CommandLine at this stage populated by ProcessCommandLineSwitches
+                projectCollection.PropertiesFromCommandLine = [.. globalProperties.Keys];
+
                 if (toolsVersion != null && !projectCollection.ContainsToolset(toolsVersion))
                 {
                     ThrowInvalidToolsVersionInitializationException(projectCollection.Toolsets, toolsVersion);
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 650b62c2a1b..7c8994d4522 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -275,23 +275,6 @@ internal abstract class LogMessagePacketBase : INodePacket
         /// </summary>
         private static Dictionary<LoggingEventType, MethodInfo> s_writeMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
 
-        /// <summary>
-        /// Dictionary of assemblies we've added to the resolver.
-        /// </summary>
-        private static HashSet<string> s_customEventsLoaded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-
-#if FEATURE_APPDOMAIN
-        /// <summary>
-        /// The resolver used to load custom event types.
-        /// </summary>
-        private static TaskEngineAssemblyResolver s_resolver;
-#endif
-
-        /// <summary>
-        /// The object used to synchronize access to shared data.
-        /// </summary>
-        private static object s_lockObject = new Object();
-
         /// <summary>
         /// Delegate for translating targetfinished events.
         /// </summary>
@@ -421,25 +404,25 @@ public void Translate(ITranslator translator)
         /// </summary>
         internal void WriteToStream(ITranslator translator)
         {
-            if (_eventType != LoggingEventType.CustomEvent)
+            ErrorUtilities.VerifyThrow(_eventType != LoggingEventType.CustomEvent, "_eventType should not be a custom event");
+
+            MethodInfo methodInfo = null;
+            lock (s_writeMethodCache)
             {
-                MethodInfo methodInfo = null;
-                lock (s_writeMethodCache)
+                if (!s_writeMethodCache.TryGetValue(_eventType, out methodInfo))
                 {
-                    if (!s_writeMethodCache.TryGetValue(_eventType, out methodInfo))
-                    {
-                        Type eventDerivedType = _buildEvent.GetType();
-                        methodInfo = eventDerivedType.GetMethod("WriteToStream", BindingFlags.NonPublic | BindingFlags.Instance);
-                        s_writeMethodCache.Add(_eventType, methodInfo);
-                    }
+                    Type eventDerivedType = _buildEvent.GetType();
+                    methodInfo = eventDerivedType.GetMethod("WriteToStream", BindingFlags.NonPublic | BindingFlags.Instance);
+                    s_writeMethodCache.Add(_eventType, methodInfo);
                 }
+            }
 
-                int packetVersion = s_defaultPacketVersion;
+            int packetVersion = s_defaultPacketVersion;
 
-                // Make sure the other side knows what sort of serialization is coming
-                translator.Translate(ref packetVersion);
+            // Make sure the other side knows what sort of serialization is coming
+            translator.Translate(ref packetVersion);
 
-                bool eventCanSerializeItself = methodInfo != null;
+            bool eventCanSerializeItself = methodInfo != null;
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs
@@ -452,34 +435,22 @@ or ProjectEvaluationFinishedEventArgs
                 }
 #endif
 
-                translator.Translate(ref eventCanSerializeItself);
+            translator.Translate(ref eventCanSerializeItself);
 
-                if (eventCanSerializeItself)
-                {
-                    // 3.5 or later -- we have custom serialization methods, so let's use them.
-                    ArgsWriterDelegate writerMethod = (ArgsWriterDelegate)CreateDelegateRobust(typeof(ArgsWriterDelegate), _buildEvent, methodInfo);
-                    writerMethod(translator.Writer);
+            if (eventCanSerializeItself)
+            {
+                // 3.5 or later -- we have custom serialization methods, so let's use them.
+                ArgsWriterDelegate writerMethod = (ArgsWriterDelegate)CreateDelegateRobust(typeof(ArgsWriterDelegate), _buildEvent, methodInfo);
+                writerMethod(translator.Writer);
 
-                    if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
-                    {
-                        _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
-                    }
-                }
-                else
+                if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
                 {
-                    WriteEventToStream(_buildEvent, _eventType, translator);
+                    _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
                 }
             }
             else
             {
-#if FEATURE_ASSEMBLY_LOCATION
-                string assemblyLocation = _buildEvent.GetType().GetTypeInfo().Assembly.Location;
-                translator.Translate(ref assemblyLocation);
-#else
-                string assemblyName = _buildEvent.GetType().GetTypeInfo().Assembly.FullName;
-                translator.Translate(ref assemblyName);
-#endif
-                translator.TranslateDotNet(ref _buildEvent);
+                WriteEventToStream(_buildEvent, _eventType, translator);
             }
         }
 
@@ -488,89 +459,44 @@ or ProjectEvaluationFinishedEventArgs
         /// </summary>
         internal void ReadFromStream(ITranslator translator)
         {
-            if (LoggingEventType.CustomEvent != _eventType)
-            {
-                _buildEvent = GetBuildEventArgFromId();
+            ErrorUtilities.VerifyThrow(_eventType != LoggingEventType.CustomEvent, "_eventType should not be a custom event");
 
-                // The other side is telling us whether the event knows how to log itself, or whether we're going to have
-                // to do it manually
-                int packetVersion = s_defaultPacketVersion;
-                translator.Translate(ref packetVersion);
+            _buildEvent = GetBuildEventArgFromId();
 
-                bool eventCanSerializeItself = true;
-                translator.Translate(ref eventCanSerializeItself);
-
-                if (eventCanSerializeItself)
-                {
-                    MethodInfo methodInfo = null;
-                    lock (s_readMethodCache)
-                    {
-                        if (!s_readMethodCache.TryGetValue(_eventType, out methodInfo))
-                        {
-                            Type eventDerivedType = _buildEvent.GetType();
-                            methodInfo = eventDerivedType.GetMethod("CreateFromStream", BindingFlags.NonPublic | BindingFlags.Instance);
-                            s_readMethodCache.Add(_eventType, methodInfo);
-                        }
-                    }
+            // The other side is telling us whether the event knows how to log itself, or whether we're going to have
+            // to do it manually
+            int packetVersion = s_defaultPacketVersion;
+            translator.Translate(ref packetVersion);
 
-                    ArgsReaderDelegate readerMethod = (ArgsReaderDelegate)CreateDelegateRobust(typeof(ArgsReaderDelegate), _buildEvent, methodInfo);
+            bool eventCanSerializeItself = true;
+            translator.Translate(ref eventCanSerializeItself);
 
-                    readerMethod(translator.Reader, packetVersion);
-                    if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
-                    {
-                        _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
-                    }
-                }
-                else
-                {
-                    _buildEvent = ReadEventFromStream(_eventType, translator);
-                    ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
-                }
-            }
-            else
+            if (eventCanSerializeItself)
             {
-                string fileLocation = null;
-                translator.Translate(ref fileLocation);
-
-                bool resolveAssembly = false;
-                lock (s_lockObject)
+                MethodInfo methodInfo = null;
+                lock (s_readMethodCache)
                 {
-                    if (!s_customEventsLoaded.Contains(fileLocation))
+                    if (!s_readMethodCache.TryGetValue(_eventType, out methodInfo))
                     {
-                        resolveAssembly = true;
-                    }
-
-                    // If we are to resolve the assembly add it to the list of assemblies resolved
-                    if (resolveAssembly)
-                    {
-                        s_customEventsLoaded.Add(fileLocation);
+                        Type eventDerivedType = _buildEvent.GetType();
+                        methodInfo = eventDerivedType.GetMethod("CreateFromStream", BindingFlags.NonPublic | BindingFlags.Instance);
+                        s_readMethodCache.Add(_eventType, methodInfo);
                     }
                 }
 
-#if FEATURE_APPDOMAIN
-                if (resolveAssembly)
-                {
-                    s_resolver = new TaskEngineAssemblyResolver();
-                    s_resolver.InstallHandler();
-                    s_resolver.Initialize(fileLocation);
-                }
-#endif
+                ArgsReaderDelegate readerMethod = (ArgsReaderDelegate)CreateDelegateRobust(typeof(ArgsReaderDelegate), _buildEvent, methodInfo);
 
-                try
-                {
-                    translator.TranslateDotNet(ref _buildEvent);
-                }
-                finally
+                readerMethod(translator.Reader, packetVersion);
+                if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
                 {
-#if FEATURE_APPDOMAIN
-                    if (resolveAssembly)
-                    {
-                        s_resolver.RemoveHandler();
-                        s_resolver = null;
-                    }
-#endif
+                    _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
                 }
             }
+            else
+            {
+                _buildEvent = ReadEventFromStream(_eventType, translator);
+                ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
+            }
 
             _eventType = GetLoggingEventId(_buildEvent);
         }
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index a4a6c77b65b..d9209007dd5 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -136,7 +136,7 @@
     <value>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>
   </data>
   <data name="DeprecatedEventSerialization" xml:space="preserve">
-    <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>
+    <value>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>
   </data>
   <data name="FileLocation" xml:space="preserve">
     <value>{0} ({1},{2})</value>
@@ -364,4 +364,4 @@
   <data name="CollectionCopyToFailureProvidedArrayIsTooSmall" xml:space="preserve">
     <value>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</value>
   </data>
-</root>
\ No newline at end of file
+</root>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 6112e7fc577..cfe5a09adce 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Použití nezabezpečeného BinaryFormatteru během serializace vlastního typu události {0}. Tento způsob bude brzy zastaralý. Místo toho prosím použijte Extended*EventArgs. Další informace najdete zde: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Použití nezabezpečeného BinaryFormatteru během serializace vlastního typu události {0}. Tento způsob bude brzy zastaralý. Místo toho prosím použijte Extended*EventArgs. Další informace najdete zde: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index be05ce4a4ed..003bf3463a6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Verwendung eines unsicheren BinaryFormatter während der Serialisierung des benutzerdefinierten Ereignistyps '{0}'. Dies wird in Kürze eingestellt. Verwenden Sie stattdessen Extended*EventArgs. Weitere Informationen: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Verwendung eines unsicheren BinaryFormatter während der Serialisierung des benutzerdefinierten Ereignistyps '{0}'. Dies wird in Kürze eingestellt. Verwenden Sie stattdessen Extended*EventArgs. Weitere Informationen: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index f8c5d9b5028..69c5c5205ab 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Uso de BinaryFormatter no seguro durante la serialización del tipo de evento personalizado "{0}". Esto estará en desuso pronto. En su lugar, use Extended*EventArgs. Más información: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Uso de BinaryFormatter no seguro durante la serialización del tipo de evento personalizado "{0}". Esto estará en desuso pronto. En su lugar, use Extended*EventArgs. Más información: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 89b1346466e..e2b50513228 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Utilisation de BinaryFormatter non sécurisé lors de la sérialisation d’un type d’événement personnalisé '{0}'. Cette opération sera bientôt déconseillée. Utilisez Extended*EventArgs à la place. Plus d’informations : https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Utilisation de BinaryFormatter non sécurisé lors de la sérialisation d’un type d’événement personnalisé '{0}'. Cette opération sera bientôt déconseillée. Utilisez Extended*EventArgs à la place. Plus d’informations : https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 943424a181a..168c191f0eb 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Utilizzo di BinaryFormatter non sicuro durante la serializzazione del tipo di evento personalizzato '{0}'. Questa operazione verrà presto deprecata. Usare invece Extended*EventArgs. Altre informazioni: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Utilizzo di BinaryFormatter non sicuro durante la serializzazione del tipo di evento personalizzato '{0}'. Questa operazione verrà presto deprecata. Usare invece Extended*EventArgs. Altre informazioni: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index e392ac1eff6..d02c837c70b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">カスタム イベントの種類 '{0}' のシリアル化中のセキュリティで保護されていない BinaryFormatter の使用。これは間もなく非推奨になります。代わりに Extended*EventArgs を使用してください。詳細情報: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">カスタム イベントの種類 '{0}' のシリアル化中のセキュリティで保護されていない BinaryFormatter の使用。これは間もなく非推奨になります。代わりに Extended*EventArgs を使用してください。詳細情報: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index b03debaa45e..3986dbad56c 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">사용자 지정 이벤트 유형 '{0}'의 직렬화 중 보안되지 않은 BinaryFormatter 사용. 이 항목은 곧 지원 중단될 예정입니다. 대신 Extended*EventArgs를 사용하세요. 추가 정보: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">사용자 지정 이벤트 유형 '{0}'의 직렬화 중 보안되지 않은 BinaryFormatter 사용. 이 항목은 곧 지원 중단될 예정입니다. 대신 Extended*EventArgs를 사용하세요. 추가 정보: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 6731c418bbc..aab1556b889 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Użycie niezabezpieczonego formatu BinaryFormatter podczas serializacji niestandardowego typu zdarzenia „{0}”. Wkrótce ta funkcja będzie przestarzała. Zamiast tego należy użyć Extended*EventArgs. Więcej informacji: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Użycie niezabezpieczonego formatu BinaryFormatter podczas serializacji niestandardowego typu zdarzenia „{0}”. Wkrótce ta funkcja będzie przestarzała. Zamiast tego należy użyć Extended*EventArgs. Więcej informacji: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index f8cc9843098..a4b620eb1a1 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Uso de BinaryFormatter não seguro durante a serialização do tipo de evento personalizado '{0}'. Isso será obsoleto em breve. Em vez disso, use Extended*EventArgs. Mais informações: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Uso de BinaryFormatter não seguro durante a serialização do tipo de evento personalizado '{0}'. Isso será obsoleto em breve. Em vez disso, use Extended*EventArgs. Mais informações: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index bbffde258e5..4094d3e78ea 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Использование небезопасного BinaryFormatter во время сериализации настраиваемого типа события "{0}". Скоро этот параметр станет нерекомендуемым. Вместо этого используйте Extended*EventArgs. Дополнительные сведения: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">Использование небезопасного BinaryFormatter во время сериализации настраиваемого типа события "{0}". Скоро этот параметр станет нерекомендуемым. Вместо этого используйте Extended*EventArgs. Дополнительные сведения: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 72a139c0b26..b28d0591724 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">'{0}' özel olay türünü serileştirme işlemi sırasında güvenli olmayan BinaryFormatter kullanımı. Bu özellik yakında kullanımdan kaldırılacak. Lütfen bunun yerine Extended*EventArgs özelliğini kullanın. Daha fazla bilgi: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">'{0}' özel olay türünü serileştirme işlemi sırasında güvenli olmayan BinaryFormatter kullanımı. Bu özellik yakında kullanımdan kaldırılacak. Lütfen bunun yerine Extended*EventArgs özelliğini kullanın. Daha fazla bilgi: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 8be5cf61c86..48bf2e62153 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">在自定义事件类型“{0}”的序列化期间使用了不安全的 BinaryFormatter。这将很快被弃用。请改用 Extended*EventArgs。详细信息: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">在自定义事件类型“{0}”的序列化期间使用了不安全的 BinaryFormatter。这将很快被弃用。请改用 Extended*EventArgs。详细信息: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index e08a6eea736..7876a977471 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">自訂事件類型 '{0}' 序列化期間使用不安全的 BinaryFormatter。即將取代此項目。請改用 Extended*EventArgs。更多資訊: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="needs-review-translation">自訂事件類型 '{0}' 序列化期間使用不安全的 BinaryFormatter。即將取代此項目。請改用 Extended*EventArgs。更多資訊: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
