diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index faf9f3f8ccf..1d81e8ac1aa 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -4280,13 +4280,16 @@ public void GraphBuildShouldBeAbleToConstructGraphButSkipBuild()
 
             using (var buildSession = new Helpers.BuildManagerSession(_env))
             {
-                var graphResult = buildSession.BuildGraphSubmission(
-                    new GraphBuildRequestData(
-                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(graph.GraphRoots.First().ProjectInstance.FullPath) },
+                var requestData = new GraphBuildRequestData(
+                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(
+                            graph.GraphRoots.First().ProjectInstance.FullPath,
+                            new Dictionary<string, string>() { {"property1", "value1" } }) },
                         targetsToBuild: Array.Empty<string>(),
                         hostServices: null,
                         flags: BuildRequestDataFlags.None,
-                        graphBuildOptions: new GraphBuildOptions { Build = false }));
+                        graphBuildOptions: new GraphBuildOptions { Build = false });
+
+                var graphResult = buildSession.BuildGraphSubmission(requestData);
 
                 graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
                 logger = buildSession.Logger;
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 60c356dc515..c63606144c8 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using FluentAssertions;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
@@ -75,6 +76,7 @@ public void VerifyEventType()
             UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
             EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "file", 0, 0);
             GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
+            BuildSubmissionStartedEventArgs buildSubmissionStarted = new(new Dictionary<string, string> { { "Value1", "Value2" } }, ["Path1"], ["TargetName"], BuildRequestDataFlags.ReplaceExistingProjectInstance, 123);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -108,6 +110,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(uninitializedPropertyRead, LoggingEventType.UninitializedPropertyRead);
             VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
             VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
+            VerifyLoggingPacket(buildSubmissionStarted, LoggingEventType.BuildSubmissionStartedEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 7f855ca0350..2ed1f77f758 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -95,6 +95,45 @@ public void RoundtripBuildFinishedEventArgs()
                 e => e.Succeeded.ToString());
         }
 
+        [Fact]
+        public void RoundtripBuildSubmissionStartedEventArgs()
+        {
+            var globalVariables = new Dictionary<string, string>
+            {
+                {"Variable1", "Value1" },
+                {"Variable2", "" },
+                {"Variable3", null },
+            };
+            var entryPointProjects = new List<string>()
+            {
+                "project1",
+                "project2",
+                "",
+            };
+            var targetNames = new List<string>()
+            {
+                "target1",
+                "target2",
+                "",
+            };
+            var flag = Execution.BuildRequestDataFlags.FailOnUnresolvedSdk;
+            var submissionId = 1234;
+
+            BuildSubmissionStartedEventArgs args = new(
+                globalVariables,
+                entryPointProjects,
+                targetNames,
+                flag,
+                submissionId);
+
+            Roundtrip<BuildSubmissionStartedEventArgs>(args,
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetPropertiesString(e.EntryProjectsFullPath),
+                e => TranslationHelpers.GetPropertiesString(e.TargetNames),
+                e => e.Flags.ToString(),
+                e => e.SubmissionId.ToString());
+        }
+
         [Fact]
         public void RoundtripProjectStartedEventArgs()
         {
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index b1f5ce88f7d..b1a0b664c80 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -70,7 +70,7 @@ public void InvalidCacheFilesShouldLogError(byte[] cacheContents)
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
             _logger.FullLog.ShouldContain("MSB4256:");
-            _logger.AllBuildEvents.Count.ShouldBe(5);
+            _logger.AllBuildEvents.Count.ShouldBe(6);
             _logger.ErrorCount.ShouldBe(1);
         }
 
@@ -566,7 +566,7 @@ public void NonExistingInputResultsCacheShouldLogError()
 
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
-            _logger.AllBuildEvents.Count.ShouldBe(5);
+            _logger.AllBuildEvents.Count.ShouldBe(6);
             _logger.Errors.First().Message.ShouldContain("MSB4255:");
             _logger.Errors.First().Message.ShouldContain("FileDoesNotExist1");
             _logger.Errors.First().Message.ShouldContain("FileDoesNotExist2");
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index b4dbc09c40a..36254bf8544 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -38,3 +38,5 @@
 
 [assembly: Dependency("BuildXL.Utilities.Core", LoadHint.Sometimes)]
 [assembly: Dependency("BuildXL.Processes", LoadHint.Sometimes)]
+
+[assembly: TypeForwardedTo(typeof(Microsoft.Build.Execution.BuildRequestDataFlags))]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index b574216a0a0..52c61ccc9ab 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1375,10 +1375,24 @@ internal void ExecuteSubmission<TRequestData, TResultData>(
             where TRequestData : BuildRequestDataBase
             where TResultData : BuildResultBase
         {
-            // TODO: here we should add BuildRequestStarted https://github.com/dotnet/msbuild/issues/10145
-            // BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-            // ((IBuildComponentHost)this).LoggingService.LogBuildEvent()
-
+            // For the current submission we only know the SubmissionId and that it happened on scheduler node - all other BuildEventContext dimensions are unknown now.
+            BuildEventContext buildEventContext = new BuildEventContext(
+                submission.SubmissionId,
+                nodeId: 1,
+                BuildEventContext.InvalidProjectInstanceId,
+                BuildEventContext.InvalidProjectContextId,
+                BuildEventContext.InvalidTargetId,
+                BuildEventContext.InvalidTaskId);
+
+            BuildSubmissionStartedEventArgs submissionStartedEvent = new(
+                submission.BuildRequestDataBase.GlobalPropertiesLookup,
+                submission.BuildRequestDataBase.EntryProjectsFullPath,
+                submission.BuildRequestDataBase.TargetNames,
+                submission.BuildRequestDataBase.Flags,
+                submission.SubmissionId);
+            submissionStartedEvent.BuildEventContext = buildEventContext;
+
+            ((IBuildComponentHost)this).LoggingService.LogBuildEvent(submissionStartedEvent);
 
             if (submission is BuildSubmission buildSubmission)
             {
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index b9a221afbd9..5c69b4aebd0 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -6,88 +6,15 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
+using System.Runtime.CompilerServices;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
-    /// <summary>
-    /// Flags providing additional control over the build request
-    /// </summary>
-    [Flags]
-    public enum BuildRequestDataFlags
-    {
-        /// <summary>
-        /// No flags.
-        /// </summary>
-        None = 0,
-
-        /// <summary>
-        /// When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
-        /// </summary>
-        ReplaceExistingProjectInstance = 1 << 0,
-
-        /// <summary>
-        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
-        /// include <see cref="BuildResult.ProjectStateAfterBuild"/>.
-        /// </summary>
-        ProvideProjectStateAfterBuild = 1 << 1,
-
-        /// <summary>
-        /// When this flag is present and the project has previously been built on a node whose affinity is
-        /// incompatible with the affinity this request requires, we will ignore the project state (but not
-        /// target results) that were previously generated.
-        /// </summary>
-        /// <remarks>
-        /// This usually is not desired behavior.  It is only provided for those cases where the client
-        /// knows that the new build request does not depend on project state generated by a previous request.  Setting
-        /// this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
-        /// otherwise have to serialize the project state from one node to another, which may be
-        /// expensive depending on how much data the project previously generated.
-        ///
-        /// This flag has no effect on target results, so if a previous request already built a target, the new
-        /// request will not re-build that target (nor will any of the project state mutations which previously
-        /// occurred as a consequence of building that target be re-applied.)
-        /// </remarks>
-        IgnoreExistingProjectState = 1 << 2,
-
-        /// <summary>
-        /// When this flag is present, caches including the <see cref="ProjectRootElementCacheBase"/> will be cleared
-        /// after the build request completes.  This is used when the build request is known to modify a lot of
-        /// state such as restoring packages or generating parts of the import graph.
-        /// </summary>
-        ClearCachesAfterBuild = 1 << 3,
-
-        /// <summary>
-        /// When this flag is present, the top level target(s) in the build request will be skipped if those targets
-        /// are not defined in the Project to build. This only applies to this build request (if another target calls
-        /// the "missing target" at any other point this will still result in an error).
-        /// </summary>
-        SkipNonexistentTargets = 1 << 4,
-
-        /// <summary>
-        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
-        /// include a <see cref="BuildResult.ProjectStateAfterBuild"/> that includes ONLY the
-        /// explicitly-requested properties, items, and metadata.
-        /// </summary>
-        ProvideSubsetOfStateAfterBuild = 1 << 5,
-
-        /// <summary>
-        /// When this flag is present, projects loaded during build will ignore missing imports (<see cref="ProjectLoadSettings.IgnoreMissingImports"/> and <see cref="ProjectLoadSettings.IgnoreInvalidImports"/>).
-        /// This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
-        /// </summary>
-        IgnoreMissingEmptyAndInvalidImports = 1 << 6,
-
-        /// <summary>
-        /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
-        /// change the <see cref="IgnoreMissingEmptyAndInvalidImports" /> behavior to still fail when an SDK is missing
-        /// because those are more fatal.
-        /// </summary>
-        FailOnUnresolvedSdk = 1 << 7,
-    }
-
     /// <summary>
     /// BuildRequestData encapsulates all the data needed to submit a build request.
     /// </summary>
diff --git a/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
index 62a48e501ea..fddc32aa4a6 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
@@ -10,8 +10,12 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// </summary>
 public class BuildExecutionCheckRule
 {
-    public BuildExecutionCheckRule(string id, string title, string description, string messageFormat,
-        BuildExecutionCheckConfiguration defaultConfiguration)
+    public BuildAnalyzerRule(
+        string id, 
+        string title, 
+        string description, 
+        string messageFormat,
+        BuildAnalyzerConfiguration defaultConfiguration)
     {
         Id = id;
         Title = title;
diff --git a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
index 0d22fcf1ee3..ef72f421b19 100644
--- a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -9,17 +9,23 @@ namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
 internal sealed class NoEnvironmentVariablePropertyCheck : BuildExecutionCheck
 {
+    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
+                "BC0103",
+                "NoEnvironmentVariablePropertyCheck",
+                "No implicit property derived from an environment variable should be used during the build",
+                "Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.",
+                new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Suggestion });
+
+    private const string RuleId = "BC0103";
+
+    private const string VerboseEnvVariableOutputKey = "allow_displaying_environment_variable_value";
+
     /// <summary>
     /// Contains the list of reported environment variables.
     /// </summary>
     private readonly HashSet<EnvironmentVariableIdentityKey> _environmentVariablesReported = new HashSet<EnvironmentVariableIdentityKey>();
 
-    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
-        "BC0103",
-        "NoEnvironmentVariablePropertyCheck",
-        "No implicit property derived from an environment variable should be used during the build",
-        "Property is derived from environment variable: '{0}' with value: '{1}'. Properties should be passed explicitly using the /p option.",
-        new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Suggestion });
+    private bool _isVerboseEnvVarOutput;
 
     public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyCheck";
 
@@ -27,7 +33,11 @@ internal sealed class NoEnvironmentVariablePropertyCheck : BuildExecutionCheck
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
-        // No custom configuration
+        foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)
+        {
+            bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);
+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           
+        }
     }
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);
@@ -41,11 +51,20 @@ private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<Evaluate
                 EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);
                 if (!_environmentVariablesReported.Contains(identityKey))
                 {
-                    context.ReportResult(BuildCheckResult.Create(
-                        SupportedRule,
-                        ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),
-                        envVariableData.Key,
-                        envVariableData.Value.EnvVarValue));
+                    if (_isVerboseEnvVarOutput)
+                    {
+                        context.ReportResult(BuildCheckResult.Create(
+                            SupportedRule,
+                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),
+                            $"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'"));
+                    }
+                    else
+                    {
+                        context.ReportResult(BuildCheckResult.Create(
+                            SupportedRule,
+                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),
+                            $"'{envVariableData.Key}'"));
+                    }
 
                     _environmentVariablesReported.Add(identityKey);
                 }
@@ -53,6 +72,11 @@ private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<Evaluate
         }
     }
 
+    private static bool? GetVerboseEnvVarOutputConfig(CustomConfigurationData customConfigurationData, string ruleId) => customConfigurationData.RuleId.Equals(ruleId, StringComparison.InvariantCultureIgnoreCase)
+            && (customConfigurationData.ConfigurationData?.TryGetValue(VerboseEnvVariableOutputKey, out string? configVal) ?? false)
+            ? bool.Parse(configVal)
+            : null;
+
     internal class EnvironmentVariableIdentityKey(string environmentVariableName, string file, int line, int column) : IEquatable<EnvironmentVariableIdentityKey>
     {
         public string EnvironmentVariableName { get; } = environmentVariableName;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index ff1c4c8cf4d..1caad65e4df 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -138,12 +138,14 @@ public void ProcessCheckAcquisition(
 
         private static readonly (string[] ruleIds, bool defaultEnablement, BuildExecutionCheckFactory factory)[][] s_builtInFactoriesPerDataSource =
         [
+
             // BuildCheckDataSource.EventArgs
             [
                 ([SharedOutputPathCheck.SupportedRule.Id], SharedOutputPathCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathCheck>),
                 ([DoubleWritesCheck.SupportedRule.Id], DoubleWritesCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesCheck>),
                 ([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>)
             ],
+
             // BuildCheckDataSource.Execution
             []
         ];
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index 7762547528b..31e8cae7c7e 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -6,6 +6,7 @@
 using System.Linq;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Graph
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 22921695dea..394d752372b 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -40,5 +40,6 @@ public enum BinaryLogRecordKind
         TaskParameter,
         ResponseFileUsed,
         AssemblyLoad,
+        BuildSubmissionStarted,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index fb21e16522d..5ad623deb77 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -75,13 +75,15 @@ public sealed class BinaryLogger : ILogger
         //   - TaskParameterEventArgs: Added ParameterName and PropertyName properties
         // version 22:
         //    - extend EnvironmentVariableRead with location where environment variable was used.
+        // version 23:
+        //    - new record kind: BuildSubmissionStartedEventArgs
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
         internal const int ForwardCompatibilityMinimalVersion = 18;
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 22;
+        internal const int FileFormatVersion = 23;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index f5affd98478..9bbf41c3050 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -6,11 +6,13 @@
 using System.Collections.Generic;
 using System.IO;
 using System.IO.Compression;
+using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -294,6 +296,7 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
             {
                 BinaryLogRecordKind.BuildStarted => ReadBuildStartedEventArgs(),
                 BinaryLogRecordKind.BuildFinished => ReadBuildFinishedEventArgs(),
+                BinaryLogRecordKind.BuildSubmissionStarted => ReadBuildSubmissionStartedEventArgs(),
                 BinaryLogRecordKind.ProjectStarted => ReadProjectStartedEventArgs(),
                 BinaryLogRecordKind.ProjectFinished => ReadProjectFinishedEventArgs(),
                 BinaryLogRecordKind.TargetStarted => ReadTargetStartedEventArgs(),
@@ -617,6 +620,29 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadBuildSubmissionStartedEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+
+            IDictionary<string, string>? globalProperties = null;
+            globalProperties = ReadStringDictionary() ?? new Dictionary<string, string>();
+
+            var entryProjectsFullPath = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var targetNames = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var flags = (BuildRequestDataFlags)ReadInt32();
+            var submissionId = ReadInt32();
+
+            var e = new BuildSubmissionStartedEventArgs(
+                (IReadOnlyDictionary<string, string?>)globalProperties,
+                entryProjectsFullPath,
+                targetNames,
+                flags,
+                submissionId);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -1555,6 +1581,28 @@ private ITaskItem ReadTaskItem()
             return list;
         }
 
+        private IEnumerable<string>? ReadStringIEnumerable()
+        {
+            int count = ReadInt32();
+            if (count == 0)
+            {
+                return null;
+            }
+
+            var list = new string[count];
+
+            for (int i = 0; i < count; i++)
+            {
+                string? item = ReadDeduplicatedString();
+                if (item is not null)
+                {
+                    list[i] = item;
+                }
+            }
+
+            return list;
+        }
+
         private string ReadString()
         {
             string text = _binaryReader.ReadString();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 6ee4aff9d74..d2b6850df6b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.NET.StringTools;
 
@@ -183,6 +184,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     TargetFinished
                     ProjectStarted
                     ProjectFinished
+                    BuildSubmissionStarted
                     BuildStarted
                     BuildFinished
                     ProjectEvaluationStarted
@@ -210,6 +212,7 @@ private BinaryLogRecordKind WriteCore(BuildEventArgs e)
                 case BuildWarningEventArgs buildWarning: return Write(buildWarning);
                 case ProjectStartedEventArgs projectStarted: return Write(projectStarted);
                 case ProjectFinishedEventArgs projectFinished: return Write(projectFinished);
+                case BuildSubmissionStartedEventArgs buildSubmissionStarted: return Write(buildSubmissionStarted);
                 case BuildStartedEventArgs buildStarted: return Write(buildStarted);
                 case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
                 case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
@@ -336,6 +339,18 @@ private BinaryLogRecordKind Write(ProjectEvaluationFinishedEventArgs e)
             return BinaryLogRecordKind.ProjectEvaluationFinished;
         }
 
+        private BinaryLogRecordKind Write(BuildSubmissionStartedEventArgs e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: false);
+            Write(e.GlobalProperties);
+            WriteStringList(e.EntryProjectsFullPath);
+            WriteStringList(e.TargetNames);
+            Write((int)e.Flags);
+            Write(e.SubmissionId);
+
+            return BinaryLogRecordKind.BuildSubmissionStarted;
+        }
+
         private BinaryLogRecordKind Write(ProjectStartedEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
@@ -1044,6 +1059,16 @@ private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
             nameValueListBuffer.Clear();
         }
 
+        private void WriteStringList(IEnumerable<string> items)
+        {
+            int length = items.Count();
+            Write(length);
+            foreach (string entry in items)
+            {
+                WriteDeduplicatedString(entry);
+            }
+        }
+
         private void WriteNameValueList()
         {
             if (nameValueListBuffer.Count == 0)
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 2c1500a2685..19089f8ef85 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -177,10 +177,38 @@ public void SampleCheckIntegrationTest_CheckOnBinaryLogReplay(bool buildInOutOfP
         }
     }
 
+    [Theory]
+    [InlineData(null, "Property is derived from environment variable: 'TEST'. Properties should be passed explicitly using the /p option.")]
+    [InlineData(true, "Property is derived from environment variable: 'TEST' with value: 'FromEnvVariable'. Properties should be passed explicitly using the /p option.")]
+    [InlineData(false, "Property is derived from environment variable: 'TEST'. Properties should be passed explicitly using the /p option.")]
+    public void NoEnvironmentVariableProperty_Test(bool? customConfigEnabled, string expectedMessage)
+    {
+        List<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? customConfigData = null;
+
+        if (customConfigEnabled.HasValue)
+        {
+            customConfigData = new List<(string, (string, string))>()
+            {
+                ("BC0103", ("allow_displaying_environment_variable_value", customConfigEnabled.Value ? "true" : "false")),
+            };
+        }
+
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode: true,
+            out TransientTestFile projectFile,
+            new List<(string, string)>() { ("BC0103", "error") },
+            customConfigData);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check", out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+
+        output.ShouldContain(expectedMessage);
+    }
+
     [Theory]
     [InlineData("CheckCandidate", new[] { "CustomRule1", "CustomRule2" })]
     [InlineData("CheckCandidateWithMultipleChecksInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
-    public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedChecks = false)
+    public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedCheck = false)
     {
         using (var env = TestEnvironment.Create())
         {
@@ -267,7 +295,8 @@ private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attribut
     private void PrepareSampleProjectsAndConfig(
         bool buildInOutOfProcessNode,
         out TransientTestFile projectFile,
-        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity)
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig = null)
     {
         string testAssetsFolderName = "SampleCheckIntegrationTest";
         TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
@@ -279,7 +308,7 @@ private void PrepareSampleProjectsAndConfig(
         projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
         TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
 
-        _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, testAssetsFolderName));
+        _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, ruleToCustomConfig, testAssetsFolderName));
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
         // This discrepancy breaks path equality checks in MSBuild checks if we pass to MSBuild full path to the initial project.
@@ -297,10 +326,21 @@ string ReadAndAdjustProjectContent(string fileName) =>
                 .Replace("WorkFolderPath", workFolder.Path);
     }
 
-    private string ReadEditorConfig(IEnumerable<(string RuleId, string Severity)>? ruleToSeverity, string testAssetsFolderName)
+    private string ReadEditorConfig(
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig,
+        string testAssetsFolderName)
     {
         string configContent = File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, $"{EditorConfigFileName}test"));
 
+        PopulateRuleToSeverity(ruleToSeverity, ref configContent);
+        PopulateRuleToCustomConfig(ruleToCustomConfig, ref configContent);
+
+        return configContent;
+    }
+
+    private void PopulateRuleToSeverity(IEnumerable<(string RuleId, string Severity)>? ruleToSeverity, ref string configContent)
+    {
         if (ruleToSeverity != null && ruleToSeverity.Any())
         {
             foreach (var rule in ruleToSeverity)
@@ -308,7 +348,16 @@ private string ReadEditorConfig(IEnumerable<(string RuleId, string Severity)>? r
                 configContent = configContent.Replace($"build_check.{rule.RuleId}.Severity={rule.RuleId}Severity", $"build_check.{rule.RuleId}.Severity={rule.Severity}");
             }
         }
+    }
 
-        return configContent;
+    private void PopulateRuleToCustomConfig(IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig, ref string configContent)
+    {
+        if (ruleToCustomConfig != null && ruleToCustomConfig.Any())
+        {
+            foreach (var rule in ruleToCustomConfig)
+            {
+                configContent = configContent.Replace($"build_check.{rule.RuleId}.CustomConfig=dummy", $"build_check.{rule.RuleId}.{rule.CustomConfig.ConfigKey}={rule.CustomConfig.Value}");
+            }
+        }
     }
 }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index a041f00a358..3961ef049c3 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -45,24 +45,4 @@
     </None>
   </ItemGroup>
 
-  <ItemGroup>
-    <Compile Remove="TestAssets\SampleAnalyzerIntegrationTest\**" />
-    <EmbeddedResource Remove="TestAssets\SampleAnalyzerIntegrationTest\**" />
-    <None Remove="TestAssets\SampleAnalyzerIntegrationTest\**" />
-  </ItemGroup>
-
-  <ItemGroup>
-    <None Remove="TestAssets\SampleCheckIntegrationTest\.editorconfigcustomised" />
-    <None Remove="TestAssets\SampleCheckIntegrationTest\.editorconfigcustomised" />
-  </ItemGroup>
-
-  <ItemGroup>
-    <None Update="TestAssets\CheckCandidateWithMultipleChecksInjected\.editorconfigtest">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </None>
-    <None Update="TestAssets\CheckCandidate\.editorconfigtest">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </None>
-  </ItemGroup>
-
 </Project>
diff --git a/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
index c44457dddb5..7a66648c75f 100644
--- a/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
+++ b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
@@ -1,12 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Shouldly;
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
index d685e5d0eea..57d36981808 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
@@ -4,7 +4,9 @@ root=true
 build_check.BC0101.Severity=BC0101Severity
 
 build_check.BC0102.Severity=warning
+
 build_check.BC0103.Severity=warning
+build_check.BC0103.CustomConfig=dummy
 
 build_check.COND0543.Severity=Error
 build_check.COND0543.EvaluationCheckScope=CheckedProjectOnly
diff --git a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs b/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
new file mode 100644
index 00000000000..1db4853b515
--- /dev/null
+++ b/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
@@ -0,0 +1,66 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class BuildSubmissionStartedEventAgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            var globalVariables = new Dictionary<string, string?>
+            {
+                {"Variable1", "Value1" },
+                {"Variable2", "" },
+                {"Variable3", null },
+            };
+
+            var entryPointProjects = new List<string>()
+            {
+                "project1",
+                "project2",
+                "",
+            };
+            var targetNames = new List<string>()
+            {
+                "target1",
+                "target2",
+                "",
+            };
+            var flag = Execution.BuildRequestDataFlags.FailOnUnresolvedSdk;
+            var submissionId = 1234;
+
+            BuildSubmissionStartedEventArgs args = new(
+                globalVariables,
+                entryPointProjects,
+                targetNames,
+                flag,
+                submissionId);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            args.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            BuildSubmissionStartedEventArgs argDeserialized = new();
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+
+            argDeserialized.CreateFromStream(br, packetVersion);
+            argDeserialized.GlobalProperties.ShouldBe(globalVariables);
+            argDeserialized.EntryProjectsFullPath.ShouldBe(entryPointProjects);
+            argDeserialized.TargetNames.ShouldBe(targetNames);
+            argDeserialized.Flags.ShouldBe(flag);
+            argDeserialized.SubmissionId.ShouldBe(submissionId);
+        }
+    }
+} 
diff --git a/src/Framework/BuildRequestDataFlags.cs b/src/Framework/BuildRequestDataFlags.cs
new file mode 100644
index 00000000000..8a0c1f585f2
--- /dev/null
+++ b/src/Framework/BuildRequestDataFlags.cs
@@ -0,0 +1,87 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+// Note: Namespace is within Build.Execution for type forwarding to work correctly
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Flags providing additional control over the build request
+    /// </summary>
+    [Flags]
+    public enum BuildRequestDataFlags
+    {
+        /// <summary>
+        /// No flags.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
+        /// </summary>
+        ReplaceExistingProjectInstance = 1 << 0,
+
+        /// <summary>
+        /// When this flag is present, the "BuildResult" issued in response to this request will
+        /// include "BuildResult.ProjectStateAfterBuild".
+        /// </summary>
+        ProvideProjectStateAfterBuild = 1 << 1,
+
+        /// <summary>
+        /// When this flag is present and the project has previously been built on a node whose affinity is
+        /// incompatible with the affinity this request requires, we will ignore the project state (but not
+        /// target results) that were previously generated.
+        /// </summary>
+        /// <remarks>
+        /// This usually is not desired behavior.  It is only provided for those cases where the client
+        /// knows that the new build request does not depend on project state generated by a previous request.  Setting
+        /// this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
+        /// otherwise have to serialize the project state from one node to another, which may be
+        /// expensive depending on how much data the project previously generated.
+        ///
+        /// This flag has no effect on target results, so if a previous request already built a target, the new
+        /// request will not re-build that target (nor will any of the project state mutations which previously
+        /// occurred as a consequence of building that target be re-applied.)
+        /// </remarks>
+        IgnoreExistingProjectState = 1 << 2,
+
+        /// <summary>
+        /// When this flag is present, caches including the "ProjectRootElementCacheBase" will be cleared
+        /// after the build request completes.  This is used when the build request is known to modify a lot of
+        /// state such as restoring packages or generating parts of the import graph.
+        /// </summary>
+        ClearCachesAfterBuild = 1 << 3,
+
+        /// <summary>
+        /// When this flag is present, the top level target(s) in the build request will be skipped if those targets
+        /// are not defined in the Project to build. This only applies to this build request (if another target calls
+        /// the "missing target" at any other point this will still result in an error).
+        /// </summary>
+        SkipNonexistentTargets = 1 << 4,
+
+        /// <summary>
+        /// When this flag is present, the "BuildResult" issued in response to this request will
+        /// include a "BuildResult.ProjectStateAfterBuild" that includes ONLY the
+        /// explicitly-requested properties, items, and metadata.
+        /// </summary>
+        ProvideSubsetOfStateAfterBuild = 1 << 5,
+
+        /// <summary>
+        /// When this flag is present, projects loaded during build will ignore missing imports ("ProjectLoadSettings.IgnoreMissingImports" and "ProjectLoadSettings.IgnoreInvalidImports").
+        /// This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
+        /// </summary>
+        IgnoreMissingEmptyAndInvalidImports = 1 << 6,
+
+        /// <summary>
+        /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
+        /// change the "IgnoreMissingEmptyAndInvalidImports" behavior to still fail when an SDK is missing
+        /// because those are more fatal.
+        /// </summary>
+        FailOnUnresolvedSdk = 1 << 7,
+    }
+}
diff --git a/src/Framework/BuildSubmissionStartedEventArgs.cs b/src/Framework/BuildSubmissionStartedEventArgs.cs
new file mode 100644
index 00000000000..f77fdf8cfd0
--- /dev/null
+++ b/src/Framework/BuildSubmissionStartedEventArgs.cs
@@ -0,0 +1,121 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework
+{
+    public sealed class BuildSubmissionStartedEventArgs : BuildStatusEventArgs
+    {
+        /// <summary>
+        /// Constructor with default values.
+        /// </summary>
+        public BuildSubmissionStartedEventArgs()
+        {
+            GlobalProperties = new Dictionary<string, string?>();
+            EntryProjectsFullPath = Enumerable.Empty<string>();
+            TargetNames = Enumerable.Empty<string>();
+            Flags = BuildRequestDataFlags.None;
+            SubmissionId = 0;
+        }
+
+        public BuildSubmissionStartedEventArgs(
+            IReadOnlyDictionary<string, string?> globalProperties,
+            IEnumerable<string> entryProjectsFullPath,
+            IEnumerable<string> targetNames,
+            BuildRequestDataFlags flags,
+            int submissionId)
+            : base("", null, null, DateTime.UtcNow)
+        {
+            GlobalProperties = globalProperties;
+            EntryProjectsFullPath = entryProjectsFullPath;
+            TargetNames = targetNames;
+            Flags = flags;
+            SubmissionId = submissionId;
+        }
+
+        public IReadOnlyDictionary<string, string?> GlobalProperties { get; set; }
+
+        public IEnumerable<string> EntryProjectsFullPath { get; set; }
+
+        public IEnumerable<string> TargetNames { get; set; }
+
+        public BuildRequestDataFlags Flags { get; set; }
+
+        public int SubmissionId { get; set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.Write(GlobalProperties.Count);
+            foreach (var entry in GlobalProperties)
+            {
+                writer.Write((string)entry.Key);
+                writer.WriteOptionalString(entry.Value);
+            }
+
+            writer.Write(EntryProjectsFullPath.Count());
+            foreach(var entry in EntryProjectsFullPath)
+            {
+                writer.Write((string)entry);
+            }
+
+            writer.Write(TargetNames.Count());
+            foreach (var entry in TargetNames)
+            {
+                writer.Write((string)entry);
+            }
+
+            writer.Write((int)Flags);
+            writer.Write((int)SubmissionId);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            int numberOfProperties = reader.ReadInt32();
+            Dictionary<string, string?> globalProperties = new Dictionary<string, string?>(numberOfProperties);
+            for (int i = 0; i < numberOfProperties; i++)
+            {
+                string key = reader.ReadString();
+                string? value = reader.ReadOptionalString();
+
+                if (key != null)
+                {
+                    globalProperties[key] = value;
+                }
+            }
+
+            GlobalProperties = globalProperties;
+
+            int numberOfEntries = reader.ReadInt32();
+            var entries = new string[numberOfEntries];
+            for (int i = 0; i < numberOfEntries; i++)
+            {
+                entries[i] = reader.ReadString();
+            }
+
+            EntryProjectsFullPath = entries;
+
+            int numberOfTargets = reader.ReadInt32();
+            var targets = new string[numberOfTargets];
+            for (int i = 0; i < numberOfTargets; i++)
+            {
+                targets[i] = reader.ReadString();
+            }
+
+            TargetNames = targets;
+
+            Flags = (BuildRequestDataFlags)reader.ReadInt32();
+            SubmissionId = reader.ReadInt32();
+        }
+    }
+}
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index bb41a07dcbb..bfb896a685b 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -239,6 +239,11 @@ internal enum LoggingEventType : int
         /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>
         /// </summary>
         BuildCheckAcquisitionEvent = 39,
+
+        /// <summary>
+        /// Event is <see cref="BuildSubmissionStartedEventArgs"/>
+        /// </summary>
+        BuildSubmissionStartedEvent = 40,
     }
     #endregion
 
@@ -650,6 +655,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.BuildCheckAcquisitionEvent => new BuildCheckAcquisitionEventArgs(),
                 LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
+                LoggingEventType.BuildSubmissionStartedEvent => new BuildSubmissionStartedEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -789,6 +795,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.EnvironmentVariableReadEvent;
             }
+            else if (eventType == typeof(BuildSubmissionStartedEventArgs))
+            {
+                return LoggingEventType.BuildSubmissionStartedEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
diff --git a/src/Utilities.UnitTests/MuxLogger_Tests.cs b/src/Utilities.UnitTests/MuxLogger_Tests.cs
index ee3441facfc..db440177756 100644
--- a/src/Utilities.UnitTests/MuxLogger_Tests.cs
+++ b/src/Utilities.UnitTests/MuxLogger_Tests.cs
@@ -125,7 +125,10 @@ public void BuildWithMuxLoggerEquivalentToNormalLogger()
             mockLogger2.BuildFinishedEvents.Count.ShouldBeGreaterThan(0);
             mockLogger.BuildFinishedEvents.Count.ShouldBe(mockLogger2.BuildFinishedEvents.Count);
             mockLogger.BuildFinishedEvents[0].Succeeded.ShouldBe(mockLogger2.BuildFinishedEvents[0].Succeeded);
-            mockLogger.FullLog.ShouldBe(mockLogger2.FullLog);
+
+            // This test was changed to not compare new lines because of https://github.com/dotnet/msbuild/issues/10493
+            // It will need to be changed once we fix the root cause of the issue
+            mockLogger.FullLog.Replace(Environment.NewLine, "").ShouldBe(mockLogger2.FullLog.Replace(Environment.NewLine, ""));
         }
 
         /// <summary>
