diff --git a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
index 882753a8a50..4866a721238 100644
--- a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
@@ -180,7 +180,7 @@ public void ImportProperties()
         public void DeepClone()
         {
             CopyOnWritePropertyDictionary<MockValue> source = CreateInstance("a", "b", "c");
-            CopyOnWritePropertyDictionary<MockValue> clone = source.DeepClone();
+            CopyOnWritePropertyDictionary<MockValue> clone = (CopyOnWritePropertyDictionary<MockValue>)source.DeepClone();
 
             source.ShouldBe(clone);
             source.ShouldNotBeSameAs(clone);
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 9a9cc0eb4ca..c17a194274c 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -194,7 +194,7 @@ public void Metadata()
             item.MetadataCount.ShouldBe(s_builtInMetadataNames.Length + 2);
             item.DirectMetadataCount.ShouldBe(1);
 
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
             metadata.Count.ShouldBe(2);
             metadata["a"].EvaluatedValue.ShouldBe("override");
             metadata["b"].EvaluatedValue.ShouldBe("base");
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 826fbadef56..9657019dc00 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -231,7 +231,7 @@ public class BuildParameters : ITranslatable
         /// </summary>
         public BuildParameters()
         {
-            Initialize(Utilities.GetEnvironmentProperties(), new ProjectRootElementCache(false), null);
+            Initialize(Utilities.GetEnvironmentProperties(makeReadOnly: false), new ProjectRootElementCache(false), null);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index e32f6cd94d1..e5d09b99d8a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -457,7 +457,8 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
                             includeSplit /* before wildcard expansion */,
                             null,
                             null,
-                            originalItem.Location.File));
+                            originalItem.Location.File,
+                            useItemDefinitionsWithoutModification: false));
                     }
                 }
             }
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 76e975fe3c3..44e7fe20555 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -36,18 +36,18 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
-    internal sealed class CopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<CopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+    internal sealed class CopyOnWritePropertyDictionary<T> : ICopyOnWritePropertyDictionary<T>, IEquatable<CopyOnWritePropertyDictionary<T>>
         where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
     {
         private static readonly ImmutableDictionary<string, T> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, T>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
-        /// Backing dictionary
+        /// Backing dictionary.
         /// </summary>
         private ImmutableDictionary<string, T> _backing;
 
         /// <summary>
-        /// Creates empty dictionary
+        /// Creates empty dictionary.
         /// </summary>
         public CopyOnWritePropertyDictionary()
         {
@@ -55,7 +55,7 @@ public CopyOnWritePropertyDictionary()
         }
 
         /// <summary>
-        /// Cloning constructor, with deferred cloning semantics
+        /// Cloning constructor, with deferred cloning semantics.
         /// </summary>
         private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         {
@@ -63,12 +63,12 @@ private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         }
 
         /// <summary>
-        /// Accessor for the list of property names
+        /// Accessor for the list of property names.
         /// </summary>
         ICollection<string> IDictionary<string, T>.Keys => ((IDictionary<string, T>)_backing).Keys;
 
         /// <summary>
-        /// Accessor for the list of properties
+        /// Accessor for the list of properties.
         /// </summary>
         ICollection<T> IDictionary<string, T>.Values => ((IDictionary<string, T>)_backing).Values;
 
@@ -115,6 +115,16 @@ public T this[string name]
         /// </summary>
         public bool Contains(string name) => _backing.ContainsKey(name);
 
+        public string GetEscapedValue(string name)
+        {
+            if (_backing.TryGetValue(name, out T value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
         /// <summary>
         /// Empties the collection
         /// </summary>
@@ -134,7 +144,7 @@ public void Clear()
         /// </summary>
         IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
-        #region IEquatable<PropertyDictionary<T>> Members
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
 
         /// <summary>
         /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
@@ -180,6 +190,56 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
 
         #endregion
 
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
+
+        /// <summary>
+        /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
+        /// same values as the other, unequal otherwise.
+        /// </summary>
+        /// <param name="other">The dictionary to which this should be compared</param>
+        /// <returns>True if they are equivalent, false otherwise.</returns>
+        public bool Equals(ICopyOnWritePropertyDictionary<T> other)
+        {
+            if (other == null)
+            {
+                return false;
+            }
+
+            ImmutableDictionary<string, T> thisBacking = _backing;
+            IDictionary<string, T> otherDict = other;
+
+            if (other is CopyOnWritePropertyDictionary<T> otherCopyOnWritePropertyDictionary)
+            {
+                // If the backing collections are the same, we are equal.
+                // Note that with this check, we intentionally avoid the common reference
+                // comparison between 'this' and 'other'.
+                if (ReferenceEquals(thisBacking, otherCopyOnWritePropertyDictionary._backing))
+                {
+                    return true;
+                }
+
+                otherDict = otherCopyOnWritePropertyDictionary._backing;
+            }
+
+            if (thisBacking.Count != otherDict.Count)
+            {
+                return false;
+            }
+
+            foreach (T thisProp in thisBacking.Values)
+            {
+                if (!otherDict.TryGetValue(thisProp.Key, out T thatProp) ||
+                    !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        #endregion
+
         #region IDictionary<string,T> Members
 
         /// <summary>
@@ -274,7 +334,7 @@ public bool Remove(string name)
         /// Overwrites any property with the same name already in the collection.
         /// To remove a property, use Remove(...) instead.
         /// </summary>
-        internal void Set(T projectProperty)
+        public void Set(T projectProperty)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectProperty, nameof(projectProperty));
 
@@ -285,7 +345,7 @@ internal void Set(T projectProperty)
         /// Adds the specified properties to this dictionary.
         /// </summary>
         /// <param name="other">An enumerator over the properties to add.</param>
-        internal void ImportProperties(IEnumerable<T> other)
+        public void ImportProperties(IEnumerable<T> other)
         {
             _backing = _backing.SetItems(Items());
 
@@ -302,7 +362,7 @@ IEnumerable<KeyValuePair<string, T>> Items()
         /// Clone. As we're copy on write, this
         /// should be cheap.
         /// </summary>
-        internal CopyOnWritePropertyDictionary<T> DeepClone()
+        public ICopyOnWritePropertyDictionary<T> DeepClone()
         {
             return new CopyOnWritePropertyDictionary<T>(this);
         }
diff --git a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
new file mode 100644
index 00000000000..310476fa83b
--- /dev/null
+++ b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
@@ -0,0 +1,65 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// An interface that represents a dictionary of unordered property or metadata name/value pairs with copy-on-write semantics.
+    /// </summary>
+    /// <remarks>
+    /// The value that this adds over IDictionary&lt;string, T&gt; is:
+    ///     - supports copy on write
+    ///     - enforces that key = T.Name
+    ///     - default enumerator is over values
+    ///     - (marginal) enforces the correct key comparer
+    ///
+    /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
+    /// either not expose this collection or expose it through a readonly wrapper.
+    ///
+    /// This collection is safe for concurrent readers and a single writer.
+    /// </remarks>
+    /// <typeparam name="T">Property or Metadata class type to store</typeparam>
+    internal interface ICopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<ICopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+    {
+        /// <summary>
+        /// Returns true if a property with the specified name is present in the collection, otherwise false.
+        /// </summary>
+        bool Contains(string name);
+
+        /// <summary>
+        /// Add the specified property to the collection.
+        /// Overwrites any property with the same name already in the collection.
+        /// To remove a property, use Remove(...) instead.
+        /// </summary>
+        void Set(T projectProperty);
+
+        /// <summary>
+        /// Adds the specified properties to this dictionary.
+        /// </summary>
+        /// <param name="other">An enumerator over the properties to add.</param>
+        void ImportProperties(IEnumerable<T> other);
+
+        /// <summary>
+        /// Clone. As we're copy on write, this should be cheap.
+        /// </summary>
+        ICopyOnWritePropertyDictionary<T> DeepClone();
+
+        /// <summary>
+        /// <typeparamref name="T"/> must implement <see cref="IKeyed"/>, which means it contains an
+        /// EscapedValue. This method allows retrieving the EscapedValue of an object in the dictionary
+        /// directly.
+        /// </summary>
+        string GetEscapedValue(string name);
+    }
+}
diff --git a/src/Build/Collections/IMultiDictionary.cs b/src/Build/Collections/IMultiDictionary.cs
new file mode 100644
index 00000000000..1fece50dc23
--- /dev/null
+++ b/src/Build/Collections/IMultiDictionary.cs
@@ -0,0 +1,24 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Represents a dictionary that can hold more than one distinct value with the same key.
+    /// All keys must have at least one value: null values are currently rejected.
+    /// </summary>
+    /// <typeparam name="K">Type of key</typeparam>
+    /// <typeparam name="V">Type of value</typeparam>
+    internal interface IMultiDictionary<K, V>
+        where K : class
+        where V : class
+    {
+        IEnumerable<V> this[K key] { get; }
+    }
+}
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index b2fc7427261..ef8c02c8c8e 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="K">Type of key</typeparam>
     /// <typeparam name="V">Type of value</typeparam>
     [DebuggerDisplay("#Keys={KeyCount} #Values={ValueCount}")]
-    internal class MultiDictionary<K, V>
+    internal class MultiDictionary<K, V> : IMultiDictionary<K, V>
         where K : class
         where V : class
     {
@@ -86,7 +86,7 @@ internal MultiDictionary(IEqualityComparer<K> keyComparer)
         /// <summary>
         /// Enumerator over values that have the specified key.
         /// </summary>
-        internal IEnumerable<V> this[K key]
+        public IEnumerable<V> this[K key]
         {
             get
             {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 26be27d807b..c105e12083b 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -42,14 +42,14 @@ internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<Propert
         /// Backing dictionary
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private readonly IRetrievableEntryHashSet<T> _properties;
+        private readonly IRetrievableValuedEntryHashSet<T> _properties;
 
         /// <summary>
         /// Creates empty dictionary
         /// </summary>
         public PropertyDictionary()
         {
-            _properties = new RetrievableEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -57,7 +57,7 @@ public PropertyDictionary()
         /// </summary>
         internal PropertyDictionary(int capacity)
         {
-            _properties = new RetrievableEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -77,7 +77,7 @@ internal PropertyDictionary(IEnumerable<T> elements)
         /// </summary>
         internal PropertyDictionary(MSBuildNameIgnoreCaseComparer comparer)
         {
-            _properties = new RetrievableEntryHashSet<T>(comparer);
+            _properties = new RetrievableValuedEntryHashSet<T>(comparer);
         }
 
         /// <summary>
@@ -96,7 +96,7 @@ internal PropertyDictionary(int capacity, IEnumerable<T> elements)
         /// Initializes a new instance of the <see cref="PropertyDictionary{T}"/> class.
         /// </summary>
         /// <param name="propertiesHashSet">The collection of properties to use.</param>
-        internal PropertyDictionary(IRetrievableEntryHashSet<T> propertiesHashSet)
+        internal PropertyDictionary(IRetrievableValuedEntryHashSet<T> propertiesHashSet)
         {
             _properties = propertiesHashSet;
         }
@@ -324,6 +324,24 @@ public T Get(string keyString, int startIndex, int endIndex)
             return GetProperty(keyString, startIndex, endIndex);
         }
 
+        /// <summary>
+        /// Gets the unescaped value of a particular property.
+        /// </summary>
+        /// <param name="propertyName">The name of the property whose value is sought.</param>
+        /// <param name="unescapedValue">The out parameter by which a successfully retrieved value is returned.</param>
+        /// <returns>True if a property with a matching name was found. False otherwise.</returns>
+        public bool TryGetPropertyUnescapedValue(string propertyName, out string unescapedValue)
+        {
+            if (_properties.TryGetEscapedValue(propertyName, out string escapedValue) && escapedValue != null)
+            {
+                unescapedValue = EscapingUtilities.UnescapeAll(escapedValue);
+                return true;
+            }
+
+            unescapedValue = null;
+            return false;
+        }
+
         #region IDictionary<string,T> Members
 
         /// <summary>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
index 3100e7914a8..4d271575848 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
@@ -8,6 +8,12 @@
 
 namespace Microsoft.Build.Collections
 {
+    /// <summary>
+    /// Represents a hash set mapping string to <typeparamref name="T"/>, with the specialization that
+    /// value lookup supports using substrings of a provided key without requiring instantiating the substring
+    /// (in order to avoid the memory usage of string allocation).
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be <see cref="IKeyed"/>).</typeparam>
     internal interface IRetrievableEntryHashSet<T> :
         ICollection<T>,
         ISerializable,
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..e3b10556772
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
@@ -0,0 +1,34 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Like <see cref="IRetrievableEntryHashSet{T}"/>, this represents a hash set mapping string to <typeparamref name="T"/>
+    /// with the specialization that value lookup supports using substrings of a provided key without requiring instantiating
+    /// the substring (in order to avoid the memory usage of string allocation).
+    ///
+    /// This interface extends the functionality of <see cref="IRetrievableEntryHashSet{T}"/> by introducing the ability
+    /// to directly retrieve the Value of an instance of T instead of retrieving the instance of T itself. Implementations of
+    /// this interface can avoid the cost of allocating an instance of <typeparamref name="T"/> when the caller requests only
+    /// the Value.
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be
+    /// <see cref="IKeyed"/> and also <see cref="IValued"/>).</typeparam>
+    internal interface IRetrievableValuedEntryHashSet<T> : IRetrievableEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Gets the <see cref="IValued.EscapedValue"/> of the item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/>.
+        /// </summary>
+        /// <param name="key">The key of the item whose value is sought.</param>
+        /// <param name="escapedValue">The out parameter by which a successfully retrieved <see cref="IValued.EscapedValue"/> is returned.</param>
+        /// <returns>True if an item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/> was found. False otherwise.</returns>
+        bool TryGetEscapedValue(string key, out string escapedValue);
+    }
+}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
similarity index 99%
rename from src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
rename to src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
index e6160cec90f..dc8d96f9f7c 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
@@ -320,7 +320,7 @@ public bool TryGetValue(string key, out T item)
         /// Gets the item if any with the given name
         /// </summary>
         /// <param name="key">key to check for containment</param>
-        /// <returns>true if item contained; false if not</returns>
+        /// <returns>The item, if it was found. Otherwise, default(T).</returns>
         public T Get(string key)
         {
             return GetCore(key, 0, key?.Length ?? 0);
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..c45da4e12b6
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
@@ -0,0 +1,53 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <inheritdoc />
+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
+    [DebuggerDisplay("Count = {Count}")]
+#if FEATURE_SECURITY_PERMISSIONS
+    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
+#endif
+    internal class RetrievableValuedEntryHashSet<T> : RetrievableEntryHashSet<T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(IEqualityComparer<string> comparer)
+            : base(comparer)
+        {
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="suggestedCapacity">A value suggesting a good approximate minimum size for the initial collection.</param>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(int suggestedCapacity, IEqualityComparer<string> comparer)
+            : base(suggestedCapacity, comparer)
+        {
+        }
+
+        /// <inheritdoc />
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (TryGetValue(key, out T item) && item != null)
+            {
+                escapedValue = item.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 11dd0a1143d..cf70b8f41fa 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -887,6 +887,21 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
         /// Returns the property dictionary containing the properties representing the environment.
         /// </summary>
         internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
+        {
+            get
+            {
+                // Retrieves the environment properties.
+                // This is only done once, when the project collection is created. Any subsequent
+                // environment changes will be ignored. Child nodes will be passed this set
+                // of properties in their build parameters.
+                return new PropertyDictionary<ProjectPropertyInstance>(SharedReadOnlyEnvironmentProperties);
+            }
+        }
+
+        /// <summary>
+        /// Returns a shared immutable property dictionary containing the properties representing the environment.
+        /// </summary>
+        internal PropertyDictionary<ProjectPropertyInstance> SharedReadOnlyEnvironmentProperties
         {
             get
             {
@@ -898,7 +913,7 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties != null)
                     {
-                        return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                        return _environmentProperties;
                     }
                 }
 
@@ -906,9 +921,9 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties == null)
                     {
-                        _environmentProperties = Utilities.GetEnvironmentProperties();
+                        _environmentProperties = Utilities.GetEnvironmentProperties(makeReadOnly: true);
                     }
-                    return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                    return _environmentProperties;
                 }
             }
         }
diff --git a/src/Build/Instance/IImmutableInstanceProvider.cs b/src/Build/Instance/IImmutableInstanceProvider.cs
index a862a12cf13..4b39fc66288 100644
--- a/src/Build/Instance/IImmutableInstanceProvider.cs
+++ b/src/Build/Instance/IImmutableInstanceProvider.cs
@@ -9,6 +9,19 @@ namespace Microsoft.Build.Execution
     /// <typeparam name="T">The Instance type.</typeparam>
     internal interface IImmutableInstanceProvider<T>
     {
-        T ImmutableInstance { get; set; }
+        /// <summary>
+        /// Gets the Immutable Instance.
+        /// </summary>
+        T ImmutableInstance { get; }
+
+        /// <summary>
+        /// If the ImmutableInstance has not already been set, then this
+        /// method sets the ImmutableInstance to the requested value.
+        /// An already set ImmutableInstance is never replaced.
+        /// </summary>
+        /// <param name="instance">An instance that will be set as the immutable instance, provided that
+        /// the immutable instance has not already been set.</param>
+        /// <returns>The immutable instance, which may or may not be the supplied <paramref name="instance"/>.</returns>
+        T GetOrSetImmutableInstance(T instance);
     }
 }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
index ae164108704..f15fd45f63e 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
@@ -6,11 +6,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Data;
 using System.Runtime.Serialization;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Instance
@@ -18,20 +15,19 @@ namespace Microsoft.Build.Instance
     /// <summary>
     /// A specialized collection used when element data originates in an immutable Project.
     /// </summary>
-    internal sealed class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
         where T : class, IKeyed
     {
-        private readonly IDictionary<string, TCached> _projectElements;
-        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+        protected readonly IDictionary<string, TCached> _projectElements;
         private readonly ValuesCollection _values;
 
         public ImmutableElementCollectionConverter(
             IDictionary<string, TCached> projectElements,
-            IDictionary<(string, int, int), TCached> constrainedProjectElements)
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
         {
             _projectElements = projectElements;
-            _constrainedProjectElements = constrainedProjectElements;
-            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);
+            _values = new ValuesCollection(_projectElements, constrainedProjectElements, convertElement);
         }
 
         public T this[string key]
@@ -110,13 +106,16 @@ private sealed class ValuesCollection : ICollection<T>
         {
             private readonly IDictionary<string, TCached> _projectElements;
             private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+            private readonly Func<TCached, T> _getElementInstance;
 
             public ValuesCollection(
                 IDictionary<string, TCached> projectElements,
-                IDictionary<(string, int, int), TCached> constrainedProjectElements)
+                IDictionary<(string, int, int), TCached> constrainedProjectElements,
+                Func<TCached, T> getElementInstance)
             {
                 _projectElements = projectElements;
                 _constrainedProjectElements = constrainedProjectElements;
+                _getElementInstance = getElementInstance;
             }
 
             public int Count => _projectElements.Count;
@@ -155,7 +154,7 @@ public void CopyTo(T[] array, int arrayIndex, int count)
                 int endIndex = arrayIndex + count;
                 foreach (var item in _projectElements.Values)
                 {
-                    array[index] = GetElementInstance(item);
+                    array[index] = _getElementInstance(item);
                     ++index;
                     if (index >= endIndex)
                     {
@@ -171,7 +170,7 @@ public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)
                 int index = arrayIndex;
                 foreach (var item in _projectElements.Values)
                 {
-                    var itemInstance = GetElementInstance(item);
+                    var itemInstance = _getElementInstance(item);
                     array[index] = new KeyValuePair<string, T>(itemInstance.Key, itemInstance);
                     ++index;
                 }
@@ -181,7 +180,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -189,7 +188,7 @@ public IEnumerator<KeyValuePair<string, T>> GetKvpEnumerator()
             {
                 foreach (var kvp in _projectElements)
                 {
-                    T instance = GetElementInstance(kvp.Value);
+                    T instance = _getElementInstance(kvp.Value);
                     yield return new KeyValuePair<string, T>(kvp.Key, instance);
                 }
             }
@@ -200,7 +199,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -208,7 +207,7 @@ public T Get(string key)
             {
                 if (_projectElements.TryGetValue(key, out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -216,9 +215,14 @@ public T Get(string key)
 
             public T Get(string keyString, int startIndex, int length)
             {
+                if (_constrainedProjectElements == null)
+                {
+                    return Get(keyString);
+                }
+
                 if (_constrainedProjectElements.TryGetValue((keyString, startIndex, length), out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -232,19 +236,9 @@ public bool TryGetValue(string key, out T value)
                     return false;
                 }
 
-                value = GetElementInstance(element);
+                value = _getElementInstance(element);
                 return value != null;
             }
-
-            private T GetElementInstance(TCached element)
-            {
-                if (element is IImmutableInstanceProvider<T> instanceProvider)
-                {
-                    return instanceProvider.ImmutableInstance;
-                }
-
-                return null;
-            }
         }
     }
 }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
new file mode 100644
index 00000000000..b5579adf088
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
@@ -0,0 +1,251 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.CodeDom;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.Serialization;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    /// <summary>
+    /// A collection representing the set of Global ProjectPropertyInstance objects.
+    /// </summary>
+    /// <remarks>This class is used only when the containing ProjectInstance originates from an
+    /// immutable linked project source. It's specialized in order to reduce required allocations
+    /// by instead relying on the linked project source's collection of global properties
+    /// (the IDictionary _globalProperties) and the ProjectInstance's collection of all
+    /// properties (the PropertyDictionary _allProperties). When a property is requested,
+    /// _globalProperties is checked to determine whether the named property is actually
+    /// a global property and, if it is, then instance is retrieved from _allProperties.
+    /// </remarks>
+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>
+    {
+        private readonly IDictionary<string, string> _globalProperties;
+        private readonly PropertyDictionary<ProjectPropertyInstance> _allProperties;
+        private readonly ValuesCollection _values;
+
+        public ImmutableGlobalPropertiesCollectionConverter(
+            IDictionary<string, string> globalProperties,
+            PropertyDictionary<ProjectPropertyInstance> allProperties)
+        {
+            _globalProperties = globalProperties;
+            _allProperties = allProperties;
+            _values = new ValuesCollection(this);
+        }
+
+        public ProjectPropertyInstance this[string key]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_globalProperties.ContainsKey(key))
+                {
+                    return _allProperties[key];
+                }
+
+                return null;
+            }
+        }
+
+        public int Count => _globalProperties.Count;
+
+        public bool IsReadOnly => true;
+
+        public ICollection<string> Keys => _globalProperties.Keys;
+
+        public ICollection<ProjectPropertyInstance> Values => _values;
+
+        public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public void Add(string key, ProjectPropertyInstance value) => throw new NotSupportedException();
+
+        public void Add(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public bool Contains(ProjectPropertyInstance item) => _values.Contains(item);
+
+        public bool Contains(KeyValuePair<string, ProjectPropertyInstance> itemKvp) => _values.Contains(itemKvp.Value);
+
+        public bool ContainsKey(string key) => _globalProperties.ContainsKey(key);
+
+        public void CopyTo(ProjectPropertyInstance[] array) => _values.CopyTo(array, arrayIndex: 0);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);
+
+        public void CopyTo(KeyValuePair<string, ProjectPropertyInstance>[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _globalProperties.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    array[currentIndex] = new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                    ++currentIndex;
+                }
+            }
+        }
+
+        public ProjectPropertyInstance Get(string key)
+        {
+            return this[key];
+        }
+
+        public ProjectPropertyInstance Get(string key, int index, int length)
+        {
+            // The PropertyDictionary containing all of the properties can efficiently
+            // look up the requested property while honoring the specific index and length
+            // constraints. We then just have to verify that it's one of the global properties.
+            ProjectPropertyInstance actualProperty = _allProperties.Get(key, index, length);
+            if (actualProperty != null && _globalProperties.ContainsKey(actualProperty.Name))
+            {
+                return actualProperty;
+            }
+
+            return null;
+        }
+
+        public IEnumerator<ProjectPropertyInstance> GetEnumerator() => _values.GetEnumerator();
+
+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();
+
+        public void OnDeserialization(object sender) => throw new NotSupportedException();
+
+        public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public bool Remove(string key) => throw new NotSupportedException();
+
+        public bool Remove(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void TrimExcess()
+        {
+        }
+
+        public bool TryGetValue(string key, out ProjectPropertyInstance value)
+        {
+            ProjectPropertyInstance instance = Get(key);
+            value = instance;
+            return instance != null;
+        }
+
+        public void UnionWith(IEnumerable<ProjectPropertyInstance> other) => throw new NotSupportedException();
+
+        IEnumerator<KeyValuePair<string, ProjectPropertyInstance>> IEnumerable<KeyValuePair<string, ProjectPropertyInstance>>.GetEnumerator()
+        {
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    yield return new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                }
+            }
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();
+
+        private class ValuesCollection : ICollection<ProjectPropertyInstance>
+        {
+            private readonly ImmutableGlobalPropertiesCollectionConverter _parent;
+
+            public ValuesCollection(ImmutableGlobalPropertiesCollectionConverter parent)
+            {
+                _parent = parent;
+            }
+
+            public int Count => _parent._globalProperties.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public bool Contains(ProjectPropertyInstance item)
+            {
+                if (!_parent._globalProperties.ContainsKey(item.Name))
+                {
+                    return false;
+                }
+
+                ProjectPropertyInstance actualInstance = _parent._allProperties[item.Name];
+
+                if (actualInstance == null)
+                {
+                    return false;
+                }
+
+                return actualInstance.Equals(item);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex)
+            {
+                CopyTo(array, arrayIndex, _parent._globalProperties.Count);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count)
+            {
+                ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _parent._globalProperties.Count);
+
+                int currentIndex = arrayIndex;
+                int currentCount = 0;
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    if (currentCount >= count)
+                    {
+                        return;
+                    }
+
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        array[currentIndex] = instance;
+                        ++currentIndex;
+                        ++currentCount;
+                    }
+                }
+            }
+
+            public IEnumerator<ProjectPropertyInstance> GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
new file mode 100644
index 00000000000..1a1d499b0aa
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
@@ -0,0 +1,182 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableItemDefinitionsListConverter<TCached, T> : IList<T>
+        where T : IKeyed
+        where TCached : IKeyed
+    {
+        private readonly IList<TCached>? _itemList;
+        private readonly TCached? _itemTypeDefinition;
+        private readonly Func<TCached, T> _getInstance;
+
+        public ImmutableItemDefinitionsListConverter(
+            IList<TCached>? itemList,
+            TCached? itemTypeDefinition,
+            Func<TCached, T> getInstance)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(getInstance, nameof(getInstance));
+
+            _itemList = itemList;
+            _itemTypeDefinition = itemTypeDefinition;
+            _getInstance = getInstance;
+        }
+
+        public T this[int index]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_itemList == null)
+                {
+                    if (index != 0 || _itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                if (index > _itemList.Count)
+                {
+                    throw new IndexOutOfRangeException();
+                }
+
+                if (index == _itemList.Count)
+                {
+                    if (_itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                return _getInstance(_itemList[index]);
+            }
+        }
+
+        public int Count => (_itemList == null ? 0 : _itemList.Count) + (_itemTypeDefinition == null ? 0 : 1);
+
+        public bool IsReadOnly => true;
+
+        public void Add(T item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, T item) => throw new NotSupportedException();
+
+        public bool Remove(T item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(T item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(T[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), Count);
+
+            int currentIndex = arrayIndex;
+            void PutItemIntoArray(TCached item)
+            {
+                array[currentIndex] = _getInstance(item);
+                ++currentIndex;
+            }
+
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    PutItemIntoArray(item);
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                PutItemIntoArray(_itemTypeDefinition);
+            }
+        }
+
+        public IEnumerator<T> GetEnumerator() => GetEnumeratorImpl();
+
+        public int IndexOf(T item)
+        {
+            int currentIndex = 0;
+            if (_itemList != null)
+            {
+                foreach (var cachedItem in _itemList)
+                {
+                    if (IsMatchingItem(cachedItem, item))
+                    {
+                        return currentIndex;
+                    }
+
+                    ++currentIndex;
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                if (IsMatchingItem(_itemTypeDefinition, item))
+                {
+                    return currentIndex;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumeratorImpl();
+
+        private bool IsMatchingItem(TCached cachedItem, T item)
+        {
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.Key, item.Key))
+            {
+                T? foundItem = _getInstance(cachedItem);
+                if (foundItem is not null && foundItem.Equals(item))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private IEnumerator<T> GetEnumeratorImpl()
+        {
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    T? instance = _getInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                T? instance = _getInstance(_itemTypeDefinition);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
index 74919a57b97..de2d06522ae 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -19,29 +19,28 @@ namespace Microsoft.Build.Instance
     /// </summary>
     internal sealed class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>
         where T : class, IKeyed, IItem
+        where TCached : IKeyed, IItem
     {
         private readonly IDictionary<string, ICollection<TCached>> _itemsByType;
-        private readonly ICollection<T> _allItems;
-
-        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)
+        private readonly ICollection<TCached> _allCachedItems;
+        private readonly Func<TCached, T?> _getInstance;
+        private readonly Func<T, string?> _getItemType;
+
+        public ImmutableItemDictionary(
+            ICollection<TCached> allItems,
+            IDictionary<string, ICollection<TCached>> itemsByType,
+            Func<TCached, T?> getInstance,
+            Func<T, string?> getItemType)
         {
-            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
-
             if (allItems == null)
             {
                 throw new ArgumentNullException(nameof(allItems));
             }
 
-            var convertedItems = new HashSet<T>(allItems.Count);
-            foreach (var item in allItems)
-            {
-                T? instance = GetInstance(item);
-                if (instance != null)
-                {
-                    convertedItems.Add(instance);
-                }
-            }
-            _allItems = new ReadOnlyCollection<T>(convertedItems);
+            _allCachedItems = allItems;
+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
+            _getInstance = getInstance;
+            _getItemType = getItemType;
         }
 
         /// <inheritdoc />
@@ -54,12 +53,12 @@ public ICollection<T> this[string itemType]
                     return Array.Empty<T>();
                 }
 
-                return new ListConverter(itemType, _allItems, list);
+                return new ListConverter(itemType, list, _getInstance);
             }
         }
 
         /// <inheritdoc />
-        public int Count => _allItems.Count;
+        public int Count => _allCachedItems.Count;
 
         /// <inheritdoc />
         public ICollection<string> ItemTypes => _itemsByType.Keys;
@@ -77,7 +76,22 @@ public ICollection<T> this[string itemType]
         public void Clear() => throw new NotSupportedException();
 
         /// <inheritdoc />
-        public bool Contains(T projectItem) => _allItems.Contains(projectItem);
+        public bool Contains(T projectItem)
+        {
+            if (projectItem == null)
+            {
+                return false;
+            }
+
+            string? itemType = _getItemType(projectItem);
+            if (itemType == null)
+            {
+                return false;
+            }
+
+            ICollection<T> items = GetItems(itemType);
+            return items.Contains(projectItem);
+        }
 
         /// <inheritdoc />
         public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
@@ -90,31 +104,55 @@ public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallbac
                     continue;
                 }
 
-                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));
+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, kvp.Value, _getInstance));
             }
         }
 
         /// <inheritdoc />
         public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
         {
-            foreach (var item in _allItems)
+            foreach (var cachedItem in _allCachedItems)
             {
-                yield return selector(item);
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return selector(item);
+                }
             }
         }
 
         /// <inheritdoc />
-        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();
+        public IEnumerator<T> GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
-        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
         public ICollection<T> GetItems(string itemType)
         {
             if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))
             {
-                return new ListConverter(itemType, _allItems, items);
+                return new ListConverter(itemType, items, _getInstance);
             }
 
             return Array.Empty<T>();
@@ -138,27 +176,17 @@ public ICollection<T> GetItems(string itemType)
         /// <inheritdoc />
         public void Replace(T existingItem, T newItem) => throw new NotSupportedException();
 
-        private static T? GetInstance(TCached item)
-        {
-            if (item is IImmutableInstanceProvider<T> instanceProvider)
-            {
-                return instanceProvider.ImmutableInstance;
-            }
-
-            return null;
-        }
-
         private sealed class ListConverter : ICollection<T>
         {
             private readonly string _itemType;
-            private readonly ICollection<T> _allItems;
             private readonly ICollection<TCached> _list;
+            private readonly Func<TCached, T?> _getInstance;
 
-            public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCached> list)
+            public ListConverter(string itemType, ICollection<TCached> list, Func<TCached, T?> getInstance)
             {
                 _itemType = itemType;
-                _allItems = allItems;
                 _list = list;
+                _getInstance = getInstance;
             }
 
             public int Count => _list.Count;
@@ -173,8 +201,20 @@ public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCach
 
             public bool Contains(T item)
             {
-                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&
-                       _allItems.Contains(item);
+                return _list.Any(
+                    cachedItem =>
+                    {
+                        if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.EvaluatedIncludeEscaped, item.EvaluatedIncludeEscaped))
+                        {
+                            T? foundItem = _getInstance(cachedItem);
+                            if (foundItem is not null && foundItem.Equals(item))
+                            {
+                                return true;
+                            }
+                        }
+
+                        return false;
+                    });
             }
 
             public void CopyTo(T[] array, int arrayIndex)
@@ -184,7 +224,7 @@ public void CopyTo(T[] array, int arrayIndex)
                 int currentIndex = arrayIndex;
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         array[currentIndex] = instance;
@@ -197,7 +237,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
@@ -209,7 +249,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
new file mode 100644
index 00000000000..1b11db2341a
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
@@ -0,0 +1,43 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    internal class ImmutableLinkedMultiDictionaryConverter<K, VCached, V> : IMultiDictionary<K, V>
+        where K : class
+        where V : class
+        where VCached : class
+    {
+        private readonly Func<K, IEnumerable<VCached>> _getCachedValues;
+        private readonly Func<VCached, V> _getInstance;
+
+        public ImmutableLinkedMultiDictionaryConverter(Func<K, IEnumerable<VCached>> getCachedValues, Func<VCached, V> getInstance)
+        {
+            _getCachedValues = getCachedValues;
+            _getInstance = getInstance;
+        }
+
+        public IEnumerable<V> this[K key]
+        {
+            get
+            {
+                IEnumerable<VCached> cachedValues = _getCachedValues(key);
+                if (cachedValues != null)
+                {
+                    foreach (var cachedValue in cachedValues)
+                    {
+                        yield return _getInstance(cachedValue);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
new file mode 100644
index 00000000000..27610c71543
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
@@ -0,0 +1,72 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutablePropertyCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, ICopyOnWritePropertyDictionary<T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+        where TCached : class, IValued, IEquatable<TCached>
+    {
+        public ImmutablePropertyCollectionConverter(IDictionary<string, TCached> properties, Func<TCached, T> convertProperty)
+            : base(properties, constrainedProjectElements: null, convertProperty)
+        {
+        }
+
+        public bool Contains(string name) => ContainsKey(name);
+
+        public string? GetEscapedValue(string name)
+        {
+            if (_projectElements.TryGetValue(name, out TCached? value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
+        public ICopyOnWritePropertyDictionary<T> DeepClone() => this;
+
+        public void ImportProperties(IEnumerable<T> other) => throw new NotSupportedException();
+
+        public void Set(T projectProperty) => throw new NotSupportedException();
+
+        public bool Equals(ICopyOnWritePropertyDictionary<T>? other)
+        {
+            if (other == null || Count != other.Count)
+            {
+                return false;
+            }
+
+            if (other is ImmutablePropertyCollectionConverter<TCached, T> otherImmutableDict)
+            {
+                // When comparing to another CollectionConverter we compare the TCached values
+                // in order to avoid causing the instantiation of each T instance.
+                foreach (var propKvp in _projectElements)
+                {
+                    if (!otherImmutableDict._projectElements.TryGetValue(propKvp.Key, out TCached? otherProperty) ||
+                        !EqualityComparer<TCached>.Default.Equals(propKvp.Value, otherProperty))
+                    {
+                        return false;
+                    }
+                }
+            }
+            else
+            {
+                foreach (T thisProp in Values)
+                {
+                    if (!other.TryGetValue(thisProp.Key, out T? thatProp) ||
+                        !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
new file mode 100644
index 00000000000..89e12f7c0a1
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
@@ -0,0 +1,99 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableStringValuedListConverter<T> : IList<string>, IReadOnlyList<string>
+    {
+        private readonly IList<T> _itemList;
+        private readonly Func<T, string> _getStringValue;
+
+        public ImmutableStringValuedListConverter(IList<T> itemList, Func<T, string> getStringValue)
+        {
+            _itemList = itemList;
+            _getStringValue = getStringValue;
+        }
+
+        public string this[int index]
+        {
+            set => throw new NotSupportedException();
+            get => _getStringValue(_itemList[index]);
+        }
+
+        public int Count => _itemList.Count;
+
+        public bool IsReadOnly => true;
+
+        public void Add(string item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, string item) => throw new NotSupportedException();
+
+        public bool Remove(string item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(string item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(string[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _itemList.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var item in _itemList)
+            {
+                array[currentIndex] = _getStringValue(item);
+                ++currentIndex;
+            }
+        }
+
+        public IEnumerator<string> GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? stringValue = _getStringValue(item);
+                if (stringValue != null)
+                {
+                    yield return stringValue;
+                }
+            }
+        }
+
+        public int IndexOf(string item)
+        {
+            for (int i = 0; i < _itemList.Count; ++i)
+            {
+                T cachedItem = _itemList[i];
+                string stringValue = _getStringValue(cachedItem);
+                if (MSBuildNameIgnoreCaseComparer.Default.Equals(stringValue, item))
+                {
+                    return i;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? instance = _getStringValue(item);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
new file mode 100644
index 00000000000..5477ba57c28
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
@@ -0,0 +1,37 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    /// <inheritdoc />
+    internal sealed class ImmutableValuedElementCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+        where TCached : IValued
+    {
+        public ImmutableValuedElementCollectionConverter(
+            IDictionary<string, TCached> projectElements,
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
+            : base(projectElements, constrainedProjectElements, convertElement)
+        {
+        }
+
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (_projectElements.TryGetValue(key, out TCached value) && value != null)
+            {
+                escapedValue = value.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index c8bdd009a8f..1c3be29274f 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -23,6 +23,7 @@
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Instance;
+using Microsoft.Build.Instance.ImmutableProjectCollections;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -93,9 +94,9 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
 
         private List<string> _initialTargets;
 
-        private List<string> _importPaths;
+        private IList<string> _importPaths;
 
-        private List<string> _importPathsIncludingDuplicates;
+        private IList<string> _importPathsIncludingDuplicates;
 
         /// <summary>
         /// The global properties evaluation occurred with.
@@ -132,7 +133,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// Items organized by evaluatedInclude value
         /// </summary>
-        private MultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
+        private IMultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
 
         /// <summary>
         /// The project's root directory, for evaluation of relative paths and
@@ -435,41 +436,41 @@ private ProjectInstance(Project linkedProject, bool fastItemLookupNeeded)
             EvaluationId = linkedProject.EvaluationCounter;
 
             // ProjectProperties
-            InitializeImmutableProjectPropertyInstances(linkedProject.Properties);
-            var projectPropertiesConverter = GetImmutableElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(linkedProject.Properties);
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(projectPropertiesConverter);
+            _properties = GetImmutablePropertyDictionaryFromImmutableProject(linkedProject);
 
             // ProjectItemDefinitions
-            InitializeImmutableProjectItemDefinitionInstances(linkedProject.ItemDefinitions);
-            _itemDefinitions = GetImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(linkedProject.ItemDefinitions);
+            _itemDefinitions = GetImmutableItemDefinitionsHashSetFromImmutableProject(linkedProject);
 
             // ProjectItems
-            InitializeImmutableProjectItemInstances(linkedProject.Items);
-            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
-            _items = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(itemsByType, linkedProject.Items);
+            _items = GetImmutableItemsDictionaryFromImmutableProject(linkedProject, this);
 
             // ItemsByEvaluatedInclude
             if (fastItemLookupNeeded)
             {
-                _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
-                foreach (var item in linkedProject.Items)
-                {
-                    if (item is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                    {
-                        _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, immutableInstanceProvider.ImmutableInstance);
-                    }
-                }
+                _itemsByEvaluatedInclude = new ImmutableLinkedMultiDictionaryConverter<string, ProjectItem, ProjectItemInstance>(
+                                                linkedProject.GetItemsByEvaluatedInclude,
+                                                item => ConvertCachedProjectItemToInstance(linkedProject, this, item));
             }
 
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(linkedProject.GlobalPropertiesCount);
-            foreach (var property in linkedProject.GlobalPropertiesEnumerable)
-            {
-                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
-            }
+            // GlobalProperties
+            var globalPropertiesRetrievableHashSet = new ImmutableGlobalPropertiesCollectionConverter(linkedProject.GlobalProperties, _properties);
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalPropertiesRetrievableHashSet);
+
+            // EnvironmentVariableProperties
+            _environmentVariableProperties = linkedProject.ProjectCollection.SharedReadOnlyEnvironmentProperties;
 
-            CreateEnvironmentVariablePropertiesSnapshot(linkedProject.ProjectCollection.EnvironmentProperties);
-            CreateTargetsSnapshot(linkedProject.Targets, null, null, null, null);
-            CreateImportsSnapshot(linkedProject.Imports, linkedProject.ImportsIncludingDuplicates);
+            // Targets
+            _targets = linkedProject.Targets;
+            InitializeTargetsData(null, null, null, null);
+
+            // Imports
+            var importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.Imports, GetImportFullPath);
+            _importPaths = importsListConverter;
+            ImportPaths = importsListConverter;
+
+            importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.ImportsIncludingDuplicates, GetImportFullPath);
+            _importPathsIncludingDuplicates = importsListConverter;
+            ImportPathsIncludingDuplicates = importsListConverter;
 
             Toolset = linkedProject.ProjectCollection.GetToolset(linkedProject.ToolsVersion);
             SubToolsetVersion = linkedProject.SubToolsetVersion;
@@ -550,9 +551,9 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
             this.TaskRegistry = projectToInheritFrom.TaskRegistry;
             _isImmutable = projectToInheritFrom._isImmutable;
             _importPaths = projectToInheritFrom._importPaths;
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = projectToInheritFrom._importPathsIncludingDuplicates;
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
@@ -754,9 +755,9 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 _itemDefinitions = that._itemDefinitions;
                 _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
                 _importPaths = that._importPaths;
-                ImportPaths = _importPaths.AsReadOnly();
+                ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
                 _importPathsIncludingDuplicates = that._importPathsIncludingDuplicates;
-                ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+                ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
                 this.EvaluatedItemElements = that.EvaluatedItemElements;
 
@@ -899,9 +900,145 @@ public static ProjectInstance FromImmutableProjectSource(Project project, Projec
             return new ProjectInstance(project, fastItemLookupNeeded);
         }
 
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            ICollection<TCached> elementsCollection)
-            where T : class, IKeyed
+        private static IRetrievableEntryHashSet<ProjectItemDefinitionInstance> GetImmutableItemDefinitionsHashSetFromImmutableProject(Project linkedProject)
+        {
+            IDictionary<string, ProjectItemDefinition> linkedProjectItemDefinitions = linkedProject.ItemDefinitions;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectItemDefinitions,
+                out IDictionary<string, ProjectItemDefinition> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectItemDefinition> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedItemDefinitionToInstance);
+
+            return hashSet;
+        }
+
+        private static ImmutableItemDictionary<ProjectItem, ProjectItemInstance> GetImmutableItemsDictionaryFromImmutableProject(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance)
+        {
+            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
+            if (itemsByType == null)
+            {
+                throw new ArgumentException(nameof(linkedProject));
+            }
+
+            Func<ProjectItem, ProjectItemInstance> convertCachedItemToInstance =
+                projectItem => ConvertCachedProjectItemToInstance(linkedProject, owningProjectInstance, projectItem);
+
+            var itemDictionary = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(
+                linkedProject.Items,
+                itemsByType,
+                convertCachedItemToInstance,
+                projectItemInstance => projectItemInstance.ItemType);
+
+            return itemDictionary;
+        }
+
+        private static ProjectItemInstance ConvertCachedProjectItemToInstance(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance,
+            ProjectItem projectItem)
+        {
+            ProjectItemInstance result = null;
+            if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    var newInstance = InstantiateProjectItemInstanceFromImmutableProjectSource(
+                        linkedProject,
+                        owningProjectInstance,
+                        projectItem);
+
+                    result = instanceProvider.GetOrSetImmutableInstance(newInstance);
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectItemDefinitionInstance ConvertCachedItemDefinitionToInstance(ProjectItemDefinition projectItemDefinition)
+        {
+            ProjectItemDefinitionInstance result = null;
+
+            if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    IDictionary<string, ProjectMetadataInstance> metadata = null;
+                    if (projectItemDefinition.Metadata is IDictionary<string, ProjectMetadata> linkedMetadataDict)
+                    {
+                        metadata = new ImmutableElementCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(
+                                        linkedMetadataDict,
+                                        constrainedProjectElements: null,
+                                        ConvertCachedProjectMetadataToInstance);
+                    }
+
+                    result = instanceProvider.GetOrSetImmutableInstance(
+                        new ProjectItemDefinitionInstance(projectItemDefinition.ItemType, metadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectMetadataInstance ConvertCachedProjectMetadataToInstance(ProjectMetadata projectMetadata)
+        {
+            ProjectMetadataInstance result = null;
+
+            if (projectMetadata is IImmutableInstanceProvider<ProjectMetadataInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(new ProjectMetadataInstance(projectMetadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static PropertyDictionary<ProjectPropertyInstance> GetImmutablePropertyDictionaryFromImmutableProject(Project linkedProject)
+        {
+            ICollection<ProjectProperty> linkedProjectProperties = linkedProject.Properties;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectProperties,
+                out IDictionary<string, ProjectProperty> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectProperty> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableValuedElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedPropertyToInstance);
+
+            return new PropertyDictionary<ProjectPropertyInstance>(hashSet);
+        }
+
+        private static ProjectPropertyInstance ConvertCachedPropertyToInstance(ProjectProperty property)
+        {
+            ProjectPropertyInstance result = null;
+
+            if (property is IImmutableInstanceProvider<ProjectPropertyInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(InstantiateProjectPropertyInstance(property, isImmutable: true));
+                }
+            }
+
+            return result;
+        }
+
+        private static void VerifyCollectionImplementsRequiredDictionaryInterfaces<TCached>(
+            object elementsCollection,
+            out IDictionary<string, TCached> elementsDictionary,
+            out IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
         {
             // The elementsCollection we receive here is implemented in CPS as a special collection
             // that is both IDictionary<string, TCached> and also IDictionary<(string, int, int), TCached>.
@@ -912,25 +1049,14 @@ private static ImmutableElementCollectionConverter<TCached, T> GetImmutableEleme
             // represents the elementsCollection as an IRetrievableEntryHashSet<T>.
             // That IRetrievableEntryHashSet is then used either directly or as a backing source for
             // another collection wrapper (e.g. PropertyDictionary).
-            if (elementsCollection is not IDictionary<string, TCached> elementsDictionary ||
-                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            if (elementsCollection is not IDictionary<string, TCached> elementsDict ||
+                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDict)
             {
                 throw new ArgumentException(nameof(elementsCollection));
             }
 
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
-        }
-
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            IDictionary<string, TCached> elementsDictionary)
-            where T : class, IKeyed
-        {
-            if (elementsDictionary is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
-            {
-                throw new ArgumentException(nameof(elementsDictionary));
-            }
-
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+            elementsDictionary = elementsDict;
+            constrainedElementsDictionary = constrainedElementsDict;
         }
 
         /// <summary>
@@ -1765,10 +1891,12 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         /// </remarks>
         public string GetPropertyValue(string name)
         {
-            ProjectPropertyInstance property = _properties[name];
-            string value = (property == null) ? String.Empty : property.EvaluatedValue;
+            if (!_properties.TryGetPropertyUnescapedValue(name, out string unescapedValue))
+            {
+                unescapedValue = String.Empty;
+            }
 
-            return value;
+            return unescapedValue;
         }
 
         /// <summary>
@@ -2859,28 +2987,6 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
         }
 
-        private static void InitializeImmutableProjectItemDefinitionInstances(IDictionary<string, ProjectItemDefinition> projectItemDefinitions)
-        {
-            foreach (var projectItemDefinition in projectItemDefinitions.Values)
-            {
-                if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = new ProjectItemDefinitionInstance(projectItemDefinition);
-                }
-            }
-        }
-
-        private static void InitializeImmutableProjectPropertyInstances(ICollection<ProjectProperty> projectProperties)
-        {
-            foreach (var projectProperty in projectProperties)
-            {
-                if (projectProperty is IImmutableInstanceProvider<ProjectPropertyInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = InstantiateProjectPropertyInstance(projectProperty, isImmutable: true);
-                }
-            }
-        }
-
         private static ProjectPropertyInstance InstantiateProjectPropertyInstance(ProjectProperty property, bool isImmutable)
         {
             // Allow reserved property names, since this is how they are added to the project instance.
@@ -2932,9 +3038,9 @@ private void Initialize(
             _actualTargets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
             _targets = new ObjectModel.ReadOnlyDictionary<string, ProjectTargetInstance>(_actualTargets);
             _importPaths = new List<string>();
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = new List<string>();
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>((globalProperties == null) ? 0 : globalProperties.Count);
             _environmentVariableProperties = buildParameters.EnvironmentPropertiesInternal;
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
@@ -3051,8 +3157,16 @@ private void CreateTargetsSnapshot(
             // ProjectTargetInstances are immutable so only the dictionary must be cloned
             _targets = CreateCloneDictionary(targets);
 
-            this.DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
-            this.InitialTargets = defaultTargets == null ? new List<string>(0) : new List<string>(initialTargets);
+            InitializeTargetsData(defaultTargets, initialTargets, beforeTargets, afterTargets);
+        }
+
+        private void InitializeTargetsData(List<string> defaultTargets,
+            List<string> initialTargets,
+            IDictionary<string, List<TargetSpecification>> beforeTargets,
+            IDictionary<string, List<TargetSpecification>> afterTargets)
+        {
+            DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
+            InitialTargets = initialTargets == null ? new List<string>(0) : new List<string>(initialTargets);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(beforeTargets, StringComparer.OrdinalIgnoreCase);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(afterTargets, StringComparer.OrdinalIgnoreCase);
         }
@@ -3062,29 +3176,31 @@ private void CreateTargetsSnapshot(
         /// </summary>
         private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<ResolvedImport> importClosureWithDuplicates)
         {
-            _importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
+            var importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosure)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPaths.Add(resolvedImport.ImportedProject.FullPath);
+                    importPaths.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPaths = _importPaths.AsReadOnly();
+            _importPaths = importPaths;
+            ImportPaths = importPaths.AsReadOnly();
 
-            _importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
+            var importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosureWithDuplicates)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
+                    importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            _importPathsIncludingDuplicates = importPathsIncludingDuplicates;
+            ImportPathsIncludingDuplicates = importPathsIncludingDuplicates.AsReadOnly();
         }
 
         /// <summary>
@@ -3123,11 +3239,13 @@ private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache,
                 return;
             }
 
-            _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
+            var multiDictionary = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
             foreach (var item in items)
             {
-                _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
+                multiDictionary.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
             }
+
+            _itemsByEvaluatedInclude = multiDictionary;
         }
 
         /// <summary>
@@ -3149,22 +3267,9 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
             return projectItemToInstanceMap;
         }
 
-        private void InitializeImmutableProjectItemInstances(ICollection<ProjectItem> projectItems)
-        {
-            foreach (var projectItem in projectItems)
-            {
-                if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                {
-                    ProjectItemInstance instance = InstantiateProjectItemInstance(projectItem);
-                    immutableInstanceProvider.ImmutableInstance = instance;
-                }
-            }
-        }
-
         private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
         {
             List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
-
             if (item.InheritedItemDefinitions != null)
             {
                 inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
@@ -3178,7 +3283,6 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
             }
 
             CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
-
             if (item.DirectMetadata != null)
             {
                 directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
@@ -3187,16 +3291,87 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
                 directMetadata.ImportProperties(projectMetadataInstances);
             }
 
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            var instance = new ProjectItemInstance(
+                this,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: false);
+
+            return instance;
+        }
+
+        private static void GetEvaluatedIncludesFromProjectItem(
+            ProjectItem item,
+            out string evaluatedIncludeEscaped,
+            out string evaluatedIncludeBeforeWildcardExpansionEscaped)
+        {
             // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
-            var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+            evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
             evaluatedIncludeEscaped ??= item.EvaluatedInclude;
-            var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+            evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
             evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+        }
+
+        private static ProjectItemInstance InstantiateProjectItemInstanceFromImmutableProjectSource(
+            Project linkedProject,
+            ProjectInstance projectInstance,
+            ProjectItem item)
+        {
+            linkedProject.ItemDefinitions.TryGetValue(item.ItemType, out ProjectItemDefinition itemTypeDefinition);
+
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions =
+                new ImmutableItemDefinitionsListConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                    item.InheritedItemDefinitions,
+                    itemTypeDefinition,
+                    ConvertCachedItemDefinitionToInstance);
+
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
+            if (item.DirectMetadata is not null)
+            {
+                if (item.DirectMetadata is IDictionary<string, ProjectMetadata> metadataDict)
+                {
+                    directMetadata = new ImmutablePropertyCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(metadataDict, ConvertCachedProjectMetadataToInstance);
+                }
+                else
+                {
+                    directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                    directMetadata.ImportProperties(projectMetadataInstances);
+                }
+            }
 
-            ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            ProjectItemInstance instance = new ProjectItemInstance(
+                projectInstance,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: true);
             return instance;
         }
 
+        private static string GetImportFullPath(ResolvedImport import)
+        {
+            return import.ImportedProject.FullPath;
+        }
+
         /// <summary>
         /// Create ItemDefinitions snapshot
         /// </summary>
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index fa41b3882ec..2051107c8bd 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Instance;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -31,9 +32,8 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <summary>
         /// Collection of metadata that link the XML metadata and instance metadata
         /// Since evaluation has occurred, this is an unordered collection.
-        /// Is never null or empty.
         /// </summary>
-        private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _metadata;
+        private IDictionary<string, ProjectMetadataInstance> _metadata;
 
         /// <summary>
         /// Constructs an empty project item definition instance.
@@ -58,13 +58,25 @@ internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition)
         {
             if (itemDefinition.MetadataCount > 0)
             {
-                _metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-
+                var copyOnWriteMetadataDictionary = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                 IEnumerable<ProjectMetadataInstance> projectMetadataInstances = itemDefinition.Metadata.Select(originalMetadata => new ProjectMetadataInstance(originalMetadata));
-                _metadata.ImportProperties(projectMetadataInstances);
+                copyOnWriteMetadataDictionary.ImportProperties(projectMetadataInstances);
+
+                _metadata = copyOnWriteMetadataDictionary;
             }
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ProjectItemDefinitionInstance"/> class.
+        /// </summary>
+        /// <param name="itemType">The type of item this definition object represents.</param>
+        /// <param name="metadata">A (possibly null) collection of the metadata associated with this item definition.</param>
+        internal ProjectItemDefinitionInstance(string itemType, IDictionary<string, ProjectMetadataInstance> metadata)
+            : this(itemType)
+        {
+            _metadata = metadata;
+        }
+
         private ProjectItemDefinitionInstance()
         {
         }
@@ -95,7 +107,7 @@ public ICollection<ProjectMetadataInstance> Metadata
                     return ReadOnlyEmptyCollection<ProjectMetadataInstance>.Instance;
                 }
 
-                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata);
+                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata.Values);
             }
         }
 
@@ -110,21 +122,7 @@ public int MetadataCount
         /// <summary>
         /// Names of all metadata on this item definition
         /// </summary>
-        public IEnumerable<string> MetadataNames
-        {
-            get
-            {
-                if (_metadata == null)
-                {
-                    yield break;
-                }
-
-                foreach (ProjectMetadataInstance metadatum in _metadata)
-                {
-                    yield return metadatum.Name;
-                }
-            }
-        }
+        public IEnumerable<string> MetadataNames => _metadata == null ? Enumerable.Empty<string>() : _metadata.Keys;
 
         /// <summary>
         /// Implementation of IKeyed exposing the item type, so these
@@ -213,8 +211,9 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         {
             ProjectItemDefinitionElement element = parent.ContainingProject.CreateItemDefinitionElement(ItemType);
             parent.AppendChild(element);
-            foreach (ProjectMetadataInstance metadataInstance in _metadata)
+            foreach (var kvp in _metadata)
             {
+                ProjectMetadataInstance metadataInstance = kvp.Value;
                 element.AddMetadata(metadataInstance.Name, metadataInstance.EvaluatedValue);
             }
 
@@ -224,7 +223,7 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _itemType);
-            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization);
+            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization, CreateMetadataCollection);
         }
 
         internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITranslator translator)
@@ -236,5 +235,10 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
         }
 
         string IItemTypeDefinition.ItemType => _itemType;
+
+        private static IDictionary<string, ProjectMetadataInstance> CreateMetadataCollection(int capacity)
+        {
+            return new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+        }
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index cf6fc186770..5769a0fa12e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -77,7 +77,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// Mutability follows the project.
         /// </summary>
         internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, string definingFileEscaped)
-            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped)
+            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false)
         {
         }
 
@@ -94,9 +94,17 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// <remarks>
         /// Not public since the only creation scenario is setting on a project.
         /// </remarks>
-        internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        internal ProjectItemInstance(
+            ProjectInstance project,
+            string itemType,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
-            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped, useItemDefinitionsWithoutModification);
         }
 
         /// <summary>
@@ -121,7 +129,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
                 metadata.ImportProperties(directMetadataInstances);
             }
 
-            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false);
         }
 
         /// <summary>
@@ -615,7 +623,7 @@ internal static ProjectItemInstance FactoryForDeserialization(ITranslator transl
         /// Add a metadata with the specified names and values.
         /// Overwrites any metadata with the same name already in the collection.
         /// </summary>
-        internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
+        internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
         {
             _project.VerifyThrowNotImmutable();
 
@@ -682,33 +690,53 @@ internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent)
         /// Inherited item definition metadata may be null. It is assumed to ALREADY HAVE BEEN CLONED.
         /// Mutability follows the project.
         /// </summary>
-        private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUse, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        private void CommonConstructor(
+            ProjectInstance projectToUse,
+            string itemTypeToUse,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectToUse, "project");
             ErrorUtilities.VerifyThrowArgumentLength(itemTypeToUse, "itemType");
             XmlUtilities.VerifyThrowArgumentValidElementName(itemTypeToUse);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(itemTypeToUse), "OM_ReservedName", itemTypeToUse);
 
-            // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
-            List<ProjectItemDefinitionInstance> inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions;
+            if (itemDefinitions == null || !useItemDefinitionsWithoutModification)
+            {
+                // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
+                inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
 
-            ProjectItemDefinitionInstance itemDefinition;
-            if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                ProjectItemDefinitionInstance itemDefinition;
+                if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                {
+                    inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
+                    inheritedItemDefinitions.Add(itemDefinition);
+                }
+            }
+            else
             {
-                inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
-                inheritedItemDefinitions.Add(itemDefinition);
+                // In this case the caller specifying useItemDefinitionsWithoutModification is guaranteeing that
+                // the itemDefinitions collection contains all necessary definitions (including the definition
+                // associated with itemTypeToUse) and, for performance reasons, the provided (immutable) collection
+                // should be used as is.
+                inheritedItemDefinitions = itemDefinitions;
             }
 
             _project = projectToUse;
             _itemType = itemTypeToUse;
             _taskItem = new TaskItem(
-                                        includeEscaped,
-                                        includeBeforeWildcardExpansionEscaped,
-                                        directMetadata?.DeepClone(), // copy on write!
-                                        inheritedItemDefinitions,
-                                        _project.Directory,
-                                        _project.IsImmutable,
-                                        definingFileEscaped);
+                            includeEscaped,
+                            includeBeforeWildcardExpansionEscaped,
+                            directMetadata?.DeepClone(), // copy on write!
+                            inheritedItemDefinitions,
+                            _project.Directory,
+                            _project.IsImmutable,
+                            definingFileEscaped);
         }
 
         /// <summary>
@@ -751,7 +779,7 @@ internal sealed class TaskItem :
             /// Lazily created, as there are huge numbers of items generated in
             /// a build that have no metadata at all.
             /// </remarks>
-            private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
+            private ICopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
 
             /// <summary>
             /// Cached value of the fullpath metadata. All other metadata are computed on demand.
@@ -765,7 +793,7 @@ internal sealed class TaskItem :
             /// be item definitions inherited from items that were
             /// used to create this item.
             /// </summary>
-            private List<ProjectItemDefinitionInstance> _itemDefinitions;
+            private IList<ProjectItemDefinitionInstance> _itemDefinitions;
 
             /// <summary>
             /// Directory of the associated project. If this is available,
@@ -794,8 +822,8 @@ internal TaskItem(string includeEscaped, string definingFileEscaped)
             internal TaskItem(
                               string includeEscaped,
                               string includeBeforeWildcardExpansionEscaped,
-                              CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
-                              List<ProjectItemDefinitionInstance> itemDefinitions,
+                              ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+                              IList<ProjectItemDefinitionInstance> itemDefinitions,
                               string projectDirectory,
                               bool immutable,
                               string definingFileEscaped) // the actual project file (or import) that defines this item.
@@ -909,11 +937,11 @@ public ICollection MetadataNames
             {
                 get
                 {
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
 
                     List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);
 
-                    foreach (ProjectMetadataInstance metadatum in metadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadataCollection)
                     {
                         names.Add(metadatum.Name);
                     }
@@ -1058,11 +1086,11 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
             /// </summary>
             /// <param name="list">The source list to return metadata from.</param>
             /// <returns>An array of string key-value pairs representing metadata.</returns>
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
                 var result = new List<KeyValuePair<string, string>>(list.Count);
 
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1074,9 +1102,9 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnW
                 return result.ToArray();
             }
 
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1093,7 +1121,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWriteP
             /// This is a read-only collection. To modify the metadata, use <see cref="SetMetadata(string, string)"/>.
             /// Computed, not necessarily fast.
             /// </summary>
-            internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
+            internal ICopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
             {
                 get
                 {
@@ -1137,7 +1165,7 @@ IEnumerable<ProjectMetadataInstance> metaData()
                         // Finally any direct metadata win.
                         if (_directMetadata != null)
                         {
-                            foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                            foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                             {
                                 if (metadatum != null)
                                 {
@@ -1287,16 +1315,16 @@ public string GetMetadataEscaped(string metadataName)
                     ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
-                ProjectMetadataInstance metadatum;
                 if (_directMetadata != null)
                 {
-                    metadatum = _directMetadata[metadataName];
-                    if (metadatum != null)
+                    string escapedValue = _directMetadata.GetEscapedValue(metadataName);
+                    if (escapedValue != null)
                     {
-                        return metadatum.EvaluatedValueEscaped;
+                        return escapedValue;
                     }
                 }
 
+                ProjectMetadataInstance metadatum;
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
                 if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
@@ -1404,7 +1432,10 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                     }
                     else if (_itemDefinitions != null)
                     {
-                        destinationAsTaskItem._itemDefinitions.AddRange(_itemDefinitions);
+                        foreach (var itemDefinition in _itemDefinitions)
+                        {
+                            destinationAsTaskItem._itemDefinitions.Add(itemDefinition);
+                        }
                     }
                 }
                 else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
@@ -1428,7 +1459,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                 else
                 {
                     // OK, most likely the destination item was a Microsoft.Build.Utilities.TaskItem.
-                    foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                     {
                         // When copying metadata, we do NOT overwrite metadata already on the destination item.
                         string destinationValue = destinationItem.GetMetadata(metadatum.Name);
@@ -1460,7 +1491,7 @@ public IDictionary CloneCustomMetadata()
                 var metadata = MetadataCollection;
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(metadata.Count, MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in metadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadata)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValue;
                 }
@@ -1477,7 +1508,7 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             {
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValueEscaped;
                 }
@@ -1501,8 +1532,17 @@ void ITranslatable.Translate(ITranslator translator)
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _definingFileEscaped);
 
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
-                translator.TranslateDictionary(ref _directMetadata, ProjectMetadataInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
+
+                TranslatorHelpers.TranslateDictionary(
+                    translator,
+                    ref _directMetadata,
+                    ProjectMetadataInstance.FactoryForDeserialization,
+                    (capacity) => new CopyOnWritePropertyDictionary<ProjectMetadataInstance>());
 
                 if (_itemDefinitions?.Count == 0)
                 {
@@ -1580,7 +1620,8 @@ public bool Equals(TaskItem other)
                 // the set of metadata names on 'this', to avoid computing the full metadata collection
                 // of both 'this' and 'other'. Once we have the names for 'this', we enumerate 'other'
                 // and ensure the names we see there are set-equal to the names we produce here.
-                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                int capacity = _itemDefinitions?.Count ?? 0 + _directMetadata?.Count ?? 0;
+                var thisNames = new HashSet<string>(capacity, MSBuildNameIgnoreCaseComparer.Default);
 
                 if (_itemDefinitions is not null)
                 {
@@ -1592,20 +1633,20 @@ public bool Equals(TaskItem other)
 
                 if (_directMetadata is not null)
                 {
-                    foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                     {
                         thisNames.Add(metadatum.Name);
                     }
                 }
 
-                CopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
+                ICopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
 
                 if (otherMetadata.Count != thisNames.Count)
                 {
                     return false;
                 }
 
-                foreach (ProjectMetadataInstance metadatum in otherMetadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)otherMetadata)
                 {
                     string name = metadatum.Name;
 
@@ -1702,7 +1743,11 @@ private void ReadInternString(ITranslator translator, LookasideStringInterner in
             /// </summary>
             internal void TranslateWithInterning(ITranslator translator, LookasideStringInterner interner)
             {
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _includeEscaped);
 
@@ -1711,14 +1756,14 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                     WriteInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
                     WriteInternString(translator, interner, ref _definingFileEscaped);
 
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
 
                     // Intern the metadata
                     if (translator.TranslateNullable(temp))
                     {
                         int count = temp.Count;
                         translator.Writer.Write(count);
-                        foreach (ProjectMetadataInstance metadatum in temp)
+                        foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)temp)
                         {
                             int key = interner.Intern(metadatum.Name);
                             int value = interner.Intern(metadatum.EvaluatedValueEscaped);
@@ -1779,7 +1824,7 @@ internal ProjectMetadataInstance GetMetadataObject(string name)
             /// Add a metadata with the specified name and value.
             /// Overwrites any metadata with the same name already in the collection.
             /// </summary>
-            internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
+            internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
@@ -2051,7 +2096,7 @@ private ProjectItemInstance CreateItem(string includeEscaped, string includeBefo
                         itemDefinitionsClone.Add(sourceItemDefinition);
                     }
 
-                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject);
+                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject, useItemDefinitionsWithoutModification: false);
                 }
             }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d71ce74084b..04a1000d9cf 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -284,14 +284,6 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResultFactory.cs" />
     <Compile Include="BackEnd\Node\LoggingNodeConfiguration.cs" />
     <Compile Include="BackEnd\Shared\ConfigurationMetadata.cs" />
-    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
-    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
-    <Compile Include="Collections\LookasideStringInterner.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -401,6 +393,9 @@
     <Compile Include="BackEnd\TaskExecutionHost\TaskExecutionHost.cs" />
     <!-- #### COLLECTIONS ### -->
     <Compile Include="..\Shared\CollectionHelpers.cs" />
+    <Compile Include="Collections\ArrayDictionary.cs" />
+    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
+    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
@@ -410,17 +405,25 @@
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs" />
     <Compile Include="Collections\IConstrainableDictionary.cs" />
+    <Compile Include="Collections\ICopyOnWritePropertyDictionary.cs" />
     <Compile Include="Collections\IItemDictionary.cs" />
+    <Compile Include="Collections\IMultiDictionary.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
     <Compile Include="Collections\IValued.cs" />
+    <Compile Include="Collections\LookasideStringInterner.cs" />
     <Compile Include="Collections\PropertyDictionary.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
-    <!-- ######################## -->
+    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableValuedEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableValuedEntryHashSet.cs" />
     <Compile Include="Collections\WeakValueDictionary.cs" />
-    <Compile Include="Collections\ArrayDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
     <Compile Include="Construction\ProjectElementContainer.cs" />
@@ -535,7 +538,13 @@
     <!-- #### INSTANCE MODEL ### -->
     <Compile Include="Instance\IImmutableInstanceProvider.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableElementCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableGlobalPropertiesCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDefinitionsListConverter.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDictionary.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableLinkedMultiDictionaryConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutablePropertyCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableStringValuedListConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableValuedElementCollectionConverter.cs" />
     <Compile Include="Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="Instance\HostServices.cs" />
     <Compile Include="Instance\ProjectTargetInstanceChild.cs" />
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index c0165f577a5..4618292cc2d 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
+using System.Threading;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -234,18 +235,27 @@ public UsingTaskParameterGroupElement Create(UsingTaskParameterGroupElementLink
 
         #region Linked classes helpers
         // Using the pattern with overloaded classes that provide "Link" object so we ensure we do not increase the
-        // memory storage of original items (with the Link field) while it is small, some of the MSbuild items can be created
+        // memory storage of original items (with the Link field) while it is small, some of the MSBuild items can be created
         // in millions so it does adds up otherwise.
 
         private class LinkedProjectItem : ProjectItem, ILinkableObject, IImmutableInstanceProvider<ProjectItemInstance>
         {
+            private ProjectItemInstance _immutableInstance;
+
             internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemLink link)
                 : base(xml, project)
             {
                 Link = link;
             }
 
-            public ProjectItemInstance ImmutableInstance { get; set; }
+            public ProjectItemInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemInstance GetOrSetImmutableInstance(ProjectItemInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemLink Link { get; }
 
@@ -254,32 +264,54 @@ internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemL
 
         private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject, IImmutableInstanceProvider<ProjectItemDefinitionInstance>
         {
+            private ProjectItemDefinitionInstance _immutableInstance;
+
             internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project project, string itemType)
                 : base(project, itemType)
             {
                 Link = link;
             }
 
-            public ProjectItemDefinitionInstance ImmutableInstance { get; set; }
+            public ProjectItemDefinitionInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemDefinitionInstance GetOrSetImmutableInstance(ProjectItemDefinitionInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemDefinitionLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject
+        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject, IImmutableInstanceProvider<ProjectMetadataInstance>
         {
+            private ProjectMetadataInstance _immutableInstance;
+
             internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
                 : base(parent, link.Xml)
             {
                 Link = link;
             }
 
+            public ProjectMetadataInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectMetadataInstance GetOrSetImmutableInstance(ProjectMetadataInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
+
             internal override ProjectMetadataLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
         private class LinkedProjectProperty : ProjectProperty, ILinkableObject, IImmutableInstanceProvider<ProjectPropertyInstance>
         {
+            private ProjectPropertyInstance _immutableInstance;
+
             internal ProjectPropertyLink Link { get; }
             object ILinkableObject.Link => Link;
 
@@ -295,7 +327,14 @@ internal LinkedProjectProperty(Project project, ProjectPropertyLink link)
                 Link = link;
             }
 
-            public ProjectPropertyInstance ImmutableInstance { get; set;  }
+            public ProjectPropertyInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectPropertyInstance GetOrSetImmutableInstance(ProjectPropertyInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             public override string Name => Link.Name;
 
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 67b454cc023..e8bf893be60 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -462,11 +462,11 @@ private static bool UsingDifferentToolsVersionFromProjectFile(string toolsVersio
         /// Retrieves properties derived from the current
         /// environment variables.
         /// </summary>
-        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties()
+        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties(bool makeReadOnly)
         {
             IDictionary<string, string> environmentVariablesBag = CommunicationsUtilities.GetEnvironmentVariables();
 
-            PropertyDictionary<ProjectPropertyInstance> environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(environmentVariablesBag.Count + 2);
+            var envPropertiesHashSet = new RetrievableValuedEntryHashSet<ProjectPropertyInstance>(environmentVariablesBag.Count + 2, MSBuildNameIgnoreCaseComparer.Default);
 
             // We set the MSBuildExtensionsPath variables here because we don't want to make them official
             // reserved properties; we need the ability for people to override our default in their
@@ -483,11 +483,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                           ? Path.Combine(programFiles32, ReservedPropertyNames.extensionsPathSuffix)
                                           : programFiles32;
 #endif
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
 
 #if !FEATURE_INSTALLED_MSBUILD
             string extensionsPath64 = extensionsPath;
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
 #else
             // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a
             // 64-bit machine, and is empty on a 32-bit machine.
@@ -500,7 +500,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                                   FrameworkLocationHelper.programFiles64,
                                                   ReservedPropertyNames.extensionsPathSuffix)
                                               : FrameworkLocationHelper.programFiles64;
-                environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+                envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
             }
 #endif
 
@@ -523,13 +523,13 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 #endif
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
 
             // Windows XP and Windows Server 2003 don't define LocalAppData in their environment.
             // We'll set it here if the environment doesn't have it so projects can reliably
             // depend on $(LocalAppData).
             string localAppData = String.Empty;
-            ProjectPropertyInstance localAppDataProp = environmentProperties.GetProperty(ReservedPropertyNames.localAppData);
+            ProjectPropertyInstance localAppDataProp = envPropertiesHashSet.Get(ReservedPropertyNames.localAppData);
             if (localAppDataProp != null)
             {
                 localAppData = localAppDataProp.EvaluatedValue;
@@ -551,11 +551,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
 
             // Add MSBuildUserExtensionsPath at $(LocalAppData)\Microsoft\MSBuild
             string userExtensionsPath = Path.Combine(localAppData, ReservedPropertyNames.userExtensionsPathSuffix);
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
 
             foreach (KeyValuePair<string, string> environmentVariable in environmentVariablesBag)
             {
@@ -570,7 +570,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 {
                     ProjectPropertyInstance environmentProperty = ProjectPropertyInstance.Create(environmentVariableName, environmentVariable.Value);
 
-                    environmentProperties.Set(environmentProperty);
+                    envPropertiesHashSet.Add(environmentProperty);
                 }
                 else
                 {
@@ -579,6 +579,12 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 }
             }
 
+            if (makeReadOnly)
+            {
+                envPropertiesHashSet.MakeReadOnly();
+            }
+
+            var environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(envPropertiesHashSet);
             return environmentProperties;
         }
 
