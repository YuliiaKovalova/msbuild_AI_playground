diff --git a/.editorconfig b/.editorconfig
index 8cdbcb6d7ec..4a47432ae4f 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -390,8 +390,11 @@ dotnet_diagnostic.IDE0241.severity = suggestion
 # Struct can be made 'readonly'
 dotnet_diagnostic.IDE0250.severity = suggestion
 
+# Struct methods can be made 'readonly'
+dotnet_diagnostic.IDE0251.severity = suggestion
+
 # Null check can be simplified
 dotnet_diagnostic.IDE0270.severity = suggestion
 
 # naming rule violation
-dotnet_diagnostic.IDE1006.severity = suggestion
\ No newline at end of file
+dotnet_diagnostic.IDE1006.severity = suggestion
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f2e6b6e4753..2497ff6eb37 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -47,7 +47,7 @@ When `Clean`ing the output of a project, `CleanReferencedProjects` ensures that
 
 ## Targets required to be referenceable
 
-These targets should exist in a project to be compatible with the common targets' `ProjectReference`. Some are called only conditionally.
+These targets should exist in a project to be compatible with the common targets' `ProjectReference` (unless [marked with the `SkipNonexistentTargets='true'` metadatum](#targets-marked-with-skipnonexistenttargetstrue-metadatum)). Some are called only conditionally.
 
 These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
 
@@ -85,6 +85,10 @@ If implementing a project with an “outer” (determine what properties to pass
   * As of 15.7, this is _optional_. If a project does not contain a `GetCopyToOutputDirectoryItems` target, projects that reference it will not copy any of its outputs to their own output folders, but the build can succeed.
 * `Clean` should delete all outputs of the project.
   * It is not called during a normal build, only during "Clean" and "Rebuild".
+
+### Targets Marked With `SkipNonexistentTargets='true'` Metadatum
+`GetTargetFrameworks` and `GetTargetFrameworksWithPlatformForSingleTargetFramework` are skippable if nonexistent since some project types (for example, `wixproj` projects) may not define them. See [this comment](https://github.com/dotnet/msbuild/blob/cc55017f88688cbe3f9aa810cdf44273adea76ea/src/Tasks/Microsoft.Managed.After.targets#L74-L77) for more details.
+
 ## Other protocol requirements
 
 As with all MSBuild logic, targets can be added to do other work with `ProjectReference`s.
diff --git a/documentation/README.md b/documentation/README.md
index 082fab41bb3..2de997ba44e 100644
--- a/documentation/README.md
+++ b/documentation/README.md
@@ -39,6 +39,7 @@ The folder contains collection of docs and references for MSBuild, detailed info
 ### Problems?
 
 * [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
+* [Controling References Behavior](wiki/Controlling-Dependencies-Behavior.md)
 * [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
 * [Some gotchas around the Microsoft.Build.Framework project/assembly](wiki/Microsoft.Build.Framework.md)
 * [GAC and MSBuild](wiki/UnGAC.md)
@@ -50,16 +51,16 @@ The folder contains collection of docs and references for MSBuild, detailed info
 * [`ProjectReference`](ProjectReference-Protocol.md)
 * [MSBuild Server](MSBuild-Server.md)
 * [Low priority nodes](specs/low-priority-switch.md)
+* [Threading in MSBuild worker nodes](specs/threading.md)
+* [Nodes orchestration](wiki/Nodes-Orchestration.md)
 * [Project cache plugin](specs/project-cache.md)
 * [Support for remote host objects](specs/remote-host-object.md)
 * [Static graph](specs/static-graph.md)
 * [Single project isolated builds: implementation details](specs/single-project-isolated-builds.md)
 * [Task isolation](specs/task-isolation-and-dependencies.md)
-* [Threading in MSBuild worker nodes](specs/threading.md)
 * [Target maps](wiki/Target-Maps.md)
 * [Managing parallelism in MSBuild](specs/resource-management.md)
 * [SDK resolution](specs/sdk-resolvers-algorithm.md)
-* [Nodes orchestration](wiki/Nodes-Orchestration.md)
 
 ### Tasks
 
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
index e3f8b94670d..75b15fc5b82 100644
--- a/documentation/specs/single-project-isolated-builds.md
+++ b/documentation/specs/single-project-isolated-builds.md
@@ -1,54 +1,43 @@
-# Single project isolated builds: implementation details
+# Single Project Isolated Builds: Implementation Details
 
 <!-- workflow -->
 Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
 
-The input cache files contain the cached results of all the targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the BuildManager APIs) should build targets. Any referenced projects by the top level project should be provided from the input caches.
+The input cache files contain the cached `TargetResult`s of all targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the `BuildManager` APIs) should build targets; Any referenced projects by the top level project should be provided from the input caches.
 
-The output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.
-The output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.
+The output cache file tells MSBuild where to serialize the `TargetResult`s for a project's built targets and becomes an input cache for dependent projects.
 
 The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).
 
-## Input / Output cache implementation
+## Input / Output Cache Implementation
 <!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22).
-
-One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
+The cache files contain the serialized state of MSBuild's [`ConfigCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [`ResultsCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs), which have been traditionally used by the engine to cache build results. They ensure that a target is only built once per build submission. `ConfigCache` entries are instances of [`BuildRequestConfiguration`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25)s (a `(project path, global properties)` tuple), and `ResultsCache` entries are instances of [`BuildResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34)s, which contain [`TargetResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22)s. The `ConfigCache` entries and `ResultsCache` entries form a [bijection](https://en.wikipedia.org/wiki/Bijection).
 
 <!-- cache lifetime -->
-The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
+In a build, the input and output cache files have the same lifetime as the `ConfigCache` and  `ResultsCache`. The `ConfigCache` and  `ResultsCache` are owned by the [`BuildManager`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On command-line builds, the cache lifetime is the same as the entire process lifetime since `MSBuild.exe` uses one `BuildManager` with one `BeginBuild` / `EndBuild` session. When other processes (e.g. Visual Studio's `devenv.exe`) perform MSBuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
 
 <!-- constraints -->
 
-When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
-The following constraints are enforced during cache aggregation:
-- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)
-- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the "first one wins" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.
+When loading input cache files, MSBuild merges incoming instances of `ConfigCache`s and `ResultsCache`s into one instance of each with the help of the [`CacheAggregator`](https://github.com/dotnet/msbuild/blob/51df47643a8ee2715ac67fab8d652b25be070cd2/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L15), which enforces the following constraints:
+- No duplicate cache entries
+- Bijection:
+   - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+   - `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`
 
-The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
+Note that the output cache file contains a single `BuildResult` with the `TargetResult`s from the project specified to be built in the `BeginBuild` / `EndBuild` session, as any `BuildResult`s obtained through isolation exemption are excluded to prevent potential duplicate input cache entries; Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache).* In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
 
-## Isolation implementation
+## Isolation Implementation
 
-[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the `Scheduler` and  `TaskBuilder`. [`TaskBuilder.ExecuteInstantiatedTask`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in a `ProjectReference` item. [`Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
 
-### How isolation exemption complicates everything
-<!-- Potential cache scenarios caused by exemption -->
-Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.
+### Isolation Exemption
+The `Scheduler` [skips isolation constraints](static-graph.md#exempting-references-from-isolation-constraints) on project references via the:
 
-The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
+* `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
 
-The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:
-1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.
-2. a project can be both exempt and present in the graph at the same time. For example, given the graph `{A->B}`, both `A` and `B` are in the graph, but `A` can also mark `B` as exempt (meaning that `A` contains both a `ProjectReference` item to `B`, and a `GraphIsolationExemptReference` item to `B`). The fact that `B` is in the graph means that `A` will receive an input cache containing B's build results. There are two subcases here:
-   1.  `A` builds targets from `B` that already exist in the input cache file from `B`. In this case, all the builds of `B` will be cache hits, and no target results from `B` will make it into `A`'s output cache, since nothing new was built.
-   2.  `A` builds targets from `B` that do not exist in the input cache file from `B`. If `B` weren't exempt from isolation constraints, this scenario would lead to a build break, as cache misses are illegal under isolation. With `B` being exempt, the new builds of `B` will get included in `A`'s output cache. The results from `B`'s cache file won't get included in `A`'s output cache file, as they weren't built by `A`.
-3. A project, which is not in the graph, can be exempt by two parent/child projects from the graph. For example, given the graph `{A->B}`, both `A` and `B` can exempt project `D` (meaning that neither `A` nor `B` have a `ProjectReference` to `D`, but both `A` and `B` have a `GraphIsolationExemptReference` to `D`). The fact that `B` is in the graph means that `A` will receive an input cache containing `B`'s build results. Since `B` builds targets from `D`, it means that `B`'s output cache file also contains target results from `D`. There are two subcases here:
-   1. `A` builds targets from `D` that already exist in the input cache file from `B`. This is handled in the same way as the above case `2.1.`
-   2. `A` builds targets from `D` that do not exist in the input cache file from `B`, meaning that `A` builds additional targets from `D` which `B` didn't build. This is handled in the same way as teh above case `2.2.`
+* `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
 
-**Current issue:** if multiple nodes in the graph exempt the same project file, the build results of the exempt project will trickle up and conflict in the first parent that tries to merge them. Documented in issue [#4386](https://github.com/dotnet/msbuild/issues/4386).
+\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
\ No newline at end of file
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 1ad0c954695..49acebe57fe 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -360,7 +360,7 @@ namespace Microsoft.Build.Experimental.Graph
 ```
 
 ## Isolated builds
-Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any BuildResult objects for project references must be pre-computed and somehow provided as inputs to the referencing project.
+Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any `BuildResult` objects for project references must be precomputed and somehow provided as inputs to the referencing project.
 
 If a project uses the MSBuild task, the build result must be in MSBuild's build result cache instead of just-in-time executing targets on that referenced project. If it is not in the build result cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or the MSBuild task with a different set of global properties, this will be allowed to support multitargeting and other build dimensions implemented in a similar way.
 
@@ -369,7 +369,7 @@ Because referenced projects and their entry targets are guaranteed to be in the
 ### Isolated graph builds
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
+Furthermore, running in this mode enforces that each `(project, global properties)` pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
 
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
@@ -389,9 +389,9 @@ These incremental builds could be extended to the entire graph by keeping a proj
 Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
 #### APIs
-Cache file information is provided via [BuildParameters](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one BuildManager BeginBuild/EndBuild session.
+Cache file information is provided via [`BuildParameters`](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one `BuildManager` `BeginBuild`/`EndBuild` session.
 
-Isolation constraints are turned on via [BuildParameters.IsolateProjects](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used.
+Isolation constraints are turned on via [`BuildParameters.IsolateProjects`](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used, except when the `isolate:MessageUponIsolationViolation` switch is used.
 
 #### Command line
 Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
@@ -403,14 +403,21 @@ In certain situations one may want to exempt a reference from isolation constrai
 - exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
 - relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
 
-A project is exempt from isolation constraints by adding its full path to the `GraphIsolationExemptReference` item. For example, if project A.csproj references project B.csproj, the following snippet exempts B.csproj from isolation constraints while A.csproj is built:
-```xml
-<ItemGroup>
-  <GraphIsolationExemptReference Include="/Full/Path/To/B.csproj" />
-</ItemGroup>
-```
-
-A reference is exempt only in projects that add the reference in `GraphIsolationExemptReference`. If multiple projects need to exempt the same reference, all of them need to add the reference to `GraphIsolationExemptReference`.
+A project may be exempt from isolation constraints in two ways:
+
+<!-- List is encoded in HTML since XML code block
+and its following text won't be indented properly. -->
+<ul>
+<li>its full path is added to the <code>GraphIsolationExemptReference</code> item. For example, if project <code>A.csproj</code> references project <code>B.csproj</code>, the following snippet exempts <code>B.csproj</code> from isolation constraints while <code>A.csproj</code> is built:
+<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
+  <span class="hljs-tag">&lt;<span class="hljs-name">GraphIsolationExemptReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"/Full/Path/To/B.csproj"</span> /&gt;</span>
+<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
+</code></pre>
+If multiple projects need to exempt the same reference, all of them need to add the reference to <code>GraphIsolationExemptReference</code>.
+</li>
+<li> via the <code>isolate:MessageUponIsolationViolation</code> switch
+</li>
+</ul>
 
 For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 25f81f0eebe..f96cbb83e99 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -29,6 +29,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
 - [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
 - [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
+- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
diff --git a/documentation/wiki/Controlling-Dependencies-Behavior.md b/documentation/wiki/Controlling-Dependencies-Behavior.md
new file mode 100644
index 00000000000..ceafb75a2d1
--- /dev/null
+++ b/documentation/wiki/Controlling-Dependencies-Behavior.md
@@ -0,0 +1,264 @@
+# Controlling references behavior
+
+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.
+
+## .NET SDK projects and access to transitive references
+
+[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.
+
+This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.
+
+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.
+
+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.
+
+## Access to transitive project references
+
+Above described behavior can lead to easy unintentional breaking out of layering architecture separation. 
+
+This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.
+
+<a name="OnionArchSample"></a>*Example*:
+
+Let's imagine an `Onion Architecture` design:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> Domain[Domain Layer]
+```
+
+Service Layer definition:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" />
+  </ItemGroup>
+
+  <PropertyGroup>
+    <TargetFramework>net48</TargetFramework>
+    <LangVersion>10</LangVersion>
+    <!-- This prevents referencing types from transitive project references. -->
+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
+  </PropertyGroup>
+</Project>
+```
+
+```csharp
+namespace Service;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.
+    // private Domain.PersonTable _tbl;
+}
+```
+
+## Access to transitive package references
+
+The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).
+
+When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.
+
+*Example*:
+
+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]
+```
+
+We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.
+
+`Repository Layer`:
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This prevents the reference to be available to referencing types. -->
+    <PrivateAssets>compile</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+Unless opted out via `PrivateAssets=compile`, our `Service Layer` would have access to `newtonsoft.json`:
+
+```csharp
+namespace Service;
+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.
+//using Newtonsoft.Json;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+}
+```
+
+**Notes:**
+   `PrivateAssets` metadatum (and it's counterparts `IncludeAssets` and `ExcludeAssets`) is applicable to `PackageReference` and controls exposure of dependencies to the consuming projects, not the current project. It is currently not possible to prevent access to package references from within directly referencing project - this is purely decision of the package itself (as it can define it's dependencies as `PrivateAssets`).
+
+## Not copying dependencies to output
+
+By default the above mentioned dependency types are copied to the build output directory during the build. There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).
+
+Overriding this logic depends on the type of the dependency.
+
+### Not copying Assembly Reference
+
+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):
+
+```xml
+<ItemGroup>
+  <Reference Include="mydll">
+    <HintPath>..\somepath\mydll.dll</HintPath>
+    <!-- This indicates that the reference should not be copied to output folder. -->
+    <Private>false</Private>
+  </Reference>
+</ItemGroup>
+```
+
+### Not copying PackageReference
+
+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:
+
+**Not copying package dependency to the immediate output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->
+    <IncludeAssets>compile</IncludeAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency to the downstream dependants output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- The dependency is copied to output folder in current referencing project, 
+           but it's not copied to output folder of projects referencing current project. -->
+    <PrivateAssets>all</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency from the upstream dependencies:**
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->
+    <ExcludeAssets>all</ExcludeAssets>
+  </ProjectReference>
+</ItemGroup>
+```
+
+### Not copying ProjectReference
+
+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project output should not be copied to output folder. -->
+    <Private>false</Private>
+  </ProjectReference>
+</ItemGroup>
+```
+
+Same metadata and logic applies here as it is being inherited from the `Reference` Item definition and the logic treats it identicaly. 
+
+## ProjectReference without accessibility and copying to output
+
+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.
+
+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. 
+         This way we basically only indicate the build order.
+    -->
+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+  </ProjectReference>
+</ItemGroup>
+```
+
+**Note:** This technique has possibly unexpected behavior when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the output assembly (`.dll`) is still not copied and referenced (as the metadatum name implies) and hence the types defined within the project cannot be referenced, however other supplementary output (added as `content` or `none`) is copied to the current project output folder (for .NET Core this includes `deps.json`, `runtimeconfig.json` and mainly `<app>.exe`). In that case we can combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference). More details on this case [here](https://github.com/dotnet/msbuild/issues/4795#issuecomment-1442390297)
+
+## Forcing TargetFramework of a referenced multitargeted project
+
+Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/nuget/create-packages/multiple-target-frameworks-project-file). 
+
+Repository Layer:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'net48'">
+    <ProjectReference Include="..\Domain-net48\Domain-net48.csproj" />
+    <PackageReference Include="System.Text.Json" Version="7.0.2" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
+    <ProjectReference Include="..\Domain-netstd20\Domain-netstd20.csproj" />
+    <PackageReference Include="newtonsoft.json" Version="13.0.1">
+  </ItemGroup>
+</Project>
+```
+
+And it's going to be referenced by Service Layer:
+
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <OutputType>Exe</OutputType>
+    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj"  />
+  </ItemGroup>
+</Project>
+```
+
+Building the Service Layer will create output folders for `net7` and `net48`:
+
+```
+net48
+ |---- Repository.dll (targeted for net48)
+ |---- Domain-net48.dll
+ |---- System.Text.Json.dll
+
+net7
+ |---- Repository.dll (targeted for netstandard2.0)
+ |---- Domain-netstd20.dll
+ |---- Newtonsoft.Json.dll 
+```
+
+Should we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:
+
+```xml
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" SetTargetFramework="TargetFramework=netstandard2.0" />
+  </ItemGroup>
+```
+
+**Notes:** 
+
+`SetTargetFramework` is currently not honored by the NuGet client([nuget issue #12436](https://github.com/NuGet/Home/issues/12436)), so the output folder will contain binaries from nuget packages as if this metadata was not used. To workaround this the apropriate nuget needs to be directly referenced from the project enforcing reference framework via `SetTargetFramework`, or copied to output/publish folder via different means.
+
+
+`SetTargetFramework` will properly enforce the framework for the `ProjectReference` chain. Once the `TargetFramework` overriding is encountered it is passed down the reference chain and the `ProjectReference`s respect it during the `TargetFramework` resolution. Due to the nature of handling of [transitive references in .NET-SDK style projects](#net-sdk-projects-and-access-to-transitive-references) and the fact that NuGet client doesn't honor `SetTargetFramework`, the transitive references can get resolved and built for multiple `TargetFramework`s. This means the output folder will contain proper version of the direct dependency - Repository Layer. The transitive references might overbuild, and output folder of current project (Service Layer) might contain both versions of the transitive project dependency (Domain-net48.dll and Domain-netstd20.dll). This limitation can be workarounded by switching of the transitive project references via `DisableTransitiveProjectReferences` (same as shown in [Access to transitive project references](#access-to-transitive-project-references))
+
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index b9be0b3f59b..6f3abb1d467 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -24,7 +24,7 @@ Set `MSBUILDDEBUGENGINE` environment variable to `'1'` and (optionally) set `MSB
 `PowerShell:`
 ```
 > $env:MSBUILDDEBUGENGINE = 1
-> $env:MSBUILDDEBUGPATH= C:\MSBuildReproLogs
+> $env:MSBUILDDEBUGPATH="C:\MSBuildReproLogs"
 > & "devenv.exe" MySolution.sln
 ```
 
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index c1b6dfbf053..559d7bc11d1 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -1,5 +1,34 @@
 <UsageData>
   <IgnorePatterns>
-    <UsagePattern IdentityGlob="*/*" />
+    <UsagePattern IdentityGlob="Microsoft.SourceBuild.Intermediate.*/*" />
+
+    <!-- These dependencies are a result of building for netframework TFMs. These are filtered out 
+         in full source-build, and would be filtered out if msbuild was using an 8.0 arcade + 8.0 SDK -->
+         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies/*1.0.3*" />
+         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies.net472/*1.0.3*" />
+
+    <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
+         These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
+    <UsagePattern IdentityGlob="Microsoft.Bcl.AsyncInterfaces/*7.0.0*" />
+    <UsagePattern IdentityGlob="Microsoft.Win32.SystemEvents/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.CodeDom/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Drawing.Common/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*7.0.1*" />
+    <UsagePattern IdentityGlob="System.Security.Permissions/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encodings.Web/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Windows.Extensions/*7.0.0*" />
+
   </IgnorePatterns>
 </UsageData>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index e312a5bbfef..c7947f8261f 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,40 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
+  <ProductDependencies>
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="7.0.0-alpha.1.23219.1">
+      <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
+      <Sha>525b6c35cc5c5c9b80b47044be2e4e77858d505a</Sha>
+      <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
+    </Dependency>
+  </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23167.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23221.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>92c39a4f0bacef20812f63e2e1d3f7aa8776038d</Sha>
+      <Sha>3d9c9a4d3d893e903bb3295fd5b55b8e40699888</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-rc.149">
+    <Dependency Name="Microsoft.SourceLink.GitHub" Version="1.1.0-beta-21480-02" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+      <Uri>https://github.com/dotnet/sourcelink</Uri>
+      <Sha>8031e5220baf2acad991e661d8308b783d2acf3e</Sha>
+      <SourceBuild RepoName="sourcelink" ManagedOnly="true" />
+    </Dependency>
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.21431.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+      <Uri>https://github.com/dotnet/xliff-tasks</Uri>
+      <Sha>bc3233146e1fcd393ed471d5005333c83363e0fe</Sha>
+      <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
+    </Dependency>
+    <Dependency Name="NuGet.Build.Tasks" Version="6.7.0-preview.1.16">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>ca5029046d7b6e55f322c45abb7b342054543710</Sha>
+      <Sha>7eaba9f3f68b8df63d5dcf10e2a8ef3591164ddf</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-2.23171.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
       <Sha>48b13597fee9df5ecfbd0b8c0758b3f46bc1d440</Sha>
+      <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23167.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23221.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>92c39a4f0bacef20812f63e2e1d3f7aa8776038d</Sha>
+      <Sha>3d9c9a4d3d893e903bb3295fd5b55b8e40699888</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 7109c4f75a6..6454a1ac00d 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23167.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23221.7</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
     <MicrosoftNetCompilersToolsetVersion>4.6.0-2.23171.5</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.5.0-rc.149</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>6.7.0-preview.1.16</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 547d878da07..e5784440d0b 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -24,7 +24,7 @@ parameters:
   enablePublishBuildAssets: false
   enablePublishTestResults: false
   enablePublishUsingPipelines: false
-  disableComponentGovernance: false
+  disableComponentGovernance: ''
   mergeTestResults: false
   testRunTitle: ''
   testResultsFormat: ''
@@ -141,9 +141,13 @@ jobs:
         richNavLogOutputDirectory: $(Build.SourcesDirectory)/artifacts/bin
       continueOnError: true
 
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), ne(parameters.disableComponentGovernance, 'true')) }}:
-      - task: ComponentGovernanceComponentDetection@0
-        continueOnError: true
+  - template: /eng/common/templates/steps/component-governance.yml
+    parameters:
+      ${{ if eq(parameters.disableComponentGovernance, '') }}:
+        ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), eq(parameters.runAsPublic, 'false'), or(contains(variables['Build.SourceBranch'], 'internal/release'), eq(variables['Build.SourceBranch'], 'main'))) }}:
+          disableComponentGovernance: false
+        ${{ else }}:
+          disableComponentGovernance: true
 
   - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
     - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
diff --git a/eng/common/templates/steps/component-governance.yml b/eng/common/templates/steps/component-governance.yml
new file mode 100644
index 00000000000..babc2757d8d
--- /dev/null
+++ b/eng/common/templates/steps/component-governance.yml
@@ -0,0 +1,10 @@
+parameters:
+  disableComponentGovernance: false
+
+steps:
+- ${{ if eq(parameters.disableComponentGovernance, 'true') }}:
+  - script: "echo ##vso[task.setvariable variable=skipComponentGovernanceDetection]true"
+    displayName: Set skipComponentGovernanceDetection variable
+- ${{ if ne(parameters.disableComponentGovernance, 'true') }}:
+  - task: ComponentGovernanceComponentDetection@0
+    continueOnError: true
\ No newline at end of file
diff --git a/eng/sdl-tsa-vars.config b/eng/sdl-tsa-vars.config
new file mode 100644
index 00000000000..a6303401812
--- /dev/null
+++ b/eng/sdl-tsa-vars.config
@@ -0,0 +1,11 @@
+-SourceToolsList @("policheck","credscan")
+-TsaInstanceURL https://devdiv.visualstudio.com/
+-TsaProjectName DEVDIV
+-TsaNotificationEmail dotnetdevexcli@microsoft.com
+-TsaCodebaseAdmin REDMOND\marcpop
+-TsaBugAreaPath "DevDiv\NET Tools\MSBuild"
+-TsaIterationPath DevDiv
+-TsaRepositoryName DotNet-msbuild-Trusted
+-TsaCodebaseName DotNet-msbuild-Trusted
+-TsaOnboard $True
+-TsaPublish $True
diff --git a/global.json b/global.json
index 4bd9c24c01e..26528f8957e 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "7.0.200",
+    "dotnet": "7.0.203",
     "vs": {
       "version": "17.4.1"
     },
     "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23167.1"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23221.7"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index ac62b8e21d7..721a4521fdc 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -82,6 +82,30 @@ public void ReadNoChildren(string project)
             Assert.Equal(0, Helpers.Count(item.Metadata));
         }
 
+        [Fact]
+        public void ReadMetadataLocationPreserved()
+        {
+            string project = """
+                <Project>
+                    <Target Name='t'>
+                        <ItemGroup>
+                            <i Include='i' MetadataA='123' MetadataB='xyz' />
+                        </ItemGroup>
+                    </Target>
+                </Project>
+                """;
+
+            ProjectItemElement item = GetItemFromContent(project);
+            Assert.Equal(2, item.Metadata.Count);
+            ProjectMetadataElement metadatum1 = item.Metadata.First();
+            ProjectMetadataElement metadatum2 = item.Metadata.Skip(1).First();
+
+            Assert.Equal(4, metadatum1.Location.Line);
+            Assert.Equal(4, metadatum2.Location.Line);
+            Assert.Equal(27, metadatum1.Location.Column);
+            Assert.Equal(43, metadatum2.Location.Column);
+        }
+
         /// <summary>
         /// Read item with no include
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 4eb2b6a1307..9b0a1eae9bb 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -772,6 +771,121 @@ public void ItemsIncludeExcludePathsCombinations()
             }
         }
 
+        /// <summary>
+        /// Referring to an item outside of target leads to 'naturally expected' reference to the item being processed.
+        ///  No expansion occurs.
+        /// </summary>
+        [Fact]
+        public void ItemsRecursionOutsideTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                     <ItemGroup>
+                        <iout1 Include='a/b.foo' TargetPath='%(Filename)%(Extension)' />
+                        <iout1 Include='c/d.foo' TargetPath='%(Filename)%(Extension)' />
+                        <iout1 Include='g/h.foo' TargetPath='%(Filename)%(Extension)' />
+                      </ItemGroup>
+                      <Target Name='a'>
+                        <Message Text="iout1=[@(iout1)]" Importance='High' />
+                        <Message Text="iout1-target-paths=[@(iout1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            var projectFile = env.CreateFile("test.proj", ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogContains("iout1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogContains("iout1-target-paths=[b.foo;d.foo;h.foo]");
+        }
+
+        /// <summary>
+        /// Referring to an item within target leads to item expansion which might be unintended behavior - hence warning.
+        /// </summary>
+        [Fact]
+        public void ItemsRecursionWithinTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='a/b.foo' TargetPath='%(Filename)%(Extension)' />
+                          <iin1 Include='c/d.foo' TargetPath='%(Filename)%(Extension)' />
+                          <iin1 Include='g/h.foo' TargetPath='%(Filename)%(Extension)' />
+                        </ItemGroup>
+                        <Message Text="iin1=[@(iin1)]" Importance='High' />
+                        <Message Text="iin1-target-paths=[@(iin1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            string projFileName = "test.proj";
+            var projectFile = env.CreateFile(projFileName, ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogDoesntContain("iin1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogDoesntContain("iin1-target-paths=[b.foo;d.foo;h.foo]");
+            logger.AssertLogContains("iin1=[a/b.foo;c/d.foo;g/h.foo;g/h.foo]");
+            logger.AssertLogContains("iin1-target-paths=[;b.foo;b.foo;d.foo]");
+
+            logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Filename"));
+            logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Extension"));
+            logger.AssertMessageCount("MSB4120", 6);
+            // The location of the offending attribute (TargetPath) is transferred - for both metadatums (%(Filename) and %(Extension)) on correct locations in xml
+            logger.AssertMessageCount($"{projFileName}(4,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(5,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(6,34):", 2, false);
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(0, logger.ErrorCount);
+        }
+
+        /// <summary>
+        /// Referring to an unrelated item within target leads to expected expansion.
+        /// </summary>
+        [Fact]
+        public void UnrelatedItemsRecursionWithinTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <ItemGroup>
+                        <iout1 Include='a/b.foo'/>
+                        <iout1 Include='c/d.foo'/>
+                        <iout1 Include='g/h.foo'/>
+                      </ItemGroup>
+
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='@(iout1)' TargetPath='%(Filename)%(Extension)' />
+                        </ItemGroup>
+                        <Message Text="iin1=[@(iin1)]" Importance='High' />
+                        <Message Text="iin1-target-paths=[@(iin1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            var projectFile = env.CreateFile("test.proj", ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogContains("iin1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogContains("iin1-target-paths=[b.foo;d.foo;h.foo]");
+
+            logger.AssertLogDoesntContain("MSB4120");
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(0, logger.ErrorCount);
+        }
+
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 7748a189690..1e6b56edd0e 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -596,6 +596,31 @@ public void NullMetadataOnLegacyOutputItems()
             logger.AssertLogContains("[foo: ]");
         }
 
+        /// <summary>
+        /// If an item returned from a task has bare-minimum metadata implementation, we shouldn't crash.
+        /// </summary>
+        [Fact]
+        public void MinimalLegacyOutputItems()
+        {
+            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+
+            string projectContents = $"""
+                                     <Project>
+                                       <UsingTask TaskName="TaskThatReturnsMinimalItem" AssemblyFile="{customTaskPath}" />
+
+                                       <Target Name="Build">
+                                         <TaskThatReturnsMinimalItem>
+                                           <Output TaskParameter="MinimalTaskItemOutput" ItemName="Outputs"/>
+                                         </TaskThatReturnsMinimalItem>
+
+                                         <Message Text="[%(Outputs.Identity): %(Outputs.a)]" Importance="High" />
+                                       </Target>
+                                     </Project>
+                                     """;
+
+            MockLogger logger = ObjectModelHelpers.BuildProjectExpectSuccess(projectContents, _testOutput, LoggerVerbosity.Diagnostic);
+        }
+
         /// <summary>
         /// Regression test for https://github.com/dotnet/msbuild/issues/5080
         /// </summary>
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 10e697437e2..e16f3578b22 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -262,7 +262,8 @@ public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
 
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [RequiresSymbolicLinksFact]
@@ -321,10 +322,14 @@ public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
 
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs b/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs
new file mode 100644
index 00000000000..7f8eec32b2a
--- /dev/null
+++ b/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs
@@ -0,0 +1,48 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Engine.UnitTests;
+
+/// <summary>
+/// Task that emulates .NET 3.5 tasks.
+/// </summary>
+public sealed class TaskThatReturnsMinimalItem : ITask
+{
+    public IBuildEngine? BuildEngine { get; set; }
+    public ITaskHost? HostObject { get; set; }
+
+    [Output]
+    public ITaskItem MinimalTaskItemOutput { get => new MinimalTaskItem(); }
+
+    public bool Execute() => true;
+
+    /// <summary>
+    /// Minimal implementation of <see cref="ITaskItem"/> that uses a <see cref="Hashtable"/> for metadata,
+    /// like MSBuild 3 did.
+    /// </summary>
+    internal sealed class MinimalTaskItem : ITaskItem
+    {
+        public string ItemSpec { get => $"{nameof(MinimalTaskItem)}spec"; set => throw new NotImplementedException(); }
+
+        public ICollection MetadataNames => throw new NotImplementedException();
+
+        public int MetadataCount => throw new NotImplementedException();
+
+        public IDictionary CloneCustomMetadata()
+        {
+            Hashtable t = new();
+            t["key"] = "value";
+
+            return t;
+        }
+        public void CopyMetadataTo(ITaskItem destinationItem) => throw new NotImplementedException();
+        public string GetMetadata(string metadataName) => "value";
+        public void RemoveMetadata(string metadataName) => throw new NotImplementedException();
+        public void SetMetadata(string metadataName, string metadataValue) => throw new NotImplementedException();
+    }
+}
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index e10c700422b..693912475d0 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -229,11 +229,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 CommunicationsUtilities.Trace("Build finished.");
             }
 
-            if (NativeMethodsShared.IsWindows && _originalConsoleMode is not null)
-            {
-                IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
-                NativeMethodsShared.SetConsoleMode(stdOut, _originalConsoleMode.Value);
-            }
+            NativeMethodsShared.RestoreConsoleMode(_originalConsoleMode);
 
             return _exitResult;
         }
@@ -377,63 +373,13 @@ private void ReadPacketsLoop(CancellationToken cancellationToken)
 
         private void ConfigureAndQueryConsoleProperties()
         {
-            var (acceptAnsiColorCodes, outputIsScreen) = QueryIsScreenAndTryEnableAnsiColorCodes();
+            (var acceptAnsiColorCodes, var outputIsScreen, _originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
             int bufferWidth = QueryConsoleBufferWidth();
             ConsoleColor backgroundColor = QueryConsoleBackgroundColor();
 
             _consoleConfiguration = new TargetConsoleConfiguration(bufferWidth, acceptAnsiColorCodes, outputIsScreen, backgroundColor);
         }
 
-        private (bool acceptAnsiColorCodes, bool outputIsScreen) QueryIsScreenAndTryEnableAnsiColorCodes()
-        {
-            bool acceptAnsiColorCodes = false;
-            bool outputIsScreen = false;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                try
-                {
-                    IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
-                    if (NativeMethodsShared.GetConsoleMode(stdOut, out uint consoleMode))
-                    {
-                        bool success;
-                        if ((consoleMode & NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING) == NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING)
-                        {
-                            // Console is already in required state
-                            success = true;
-                        }
-                        else
-                        {
-                            _originalConsoleMode = consoleMode;
-                            consoleMode |= NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING;
-                            success = NativeMethodsShared.SetConsoleMode(stdOut, consoleMode);
-                        }
-
-                        if (success)
-                        {
-                            acceptAnsiColorCodes = true;
-                        }
-
-                        uint fileType = NativeMethodsShared.GetFileType(stdOut);
-                        // The std out is a char type(LPT or Console)
-                        outputIsScreen = fileType == NativeMethodsShared.FILE_TYPE_CHAR;
-                        acceptAnsiColorCodes &= outputIsScreen;
-                    }
-                }
-                catch (Exception ex)
-                {
-                    CommunicationsUtilities.Trace("MSBuild client warning: problem during enabling support for VT100: {0}.", ex);
-                }
-            }
-            else
-            {
-                // On posix OSes we expect console always supports VT100 coloring unless it is redirected
-                acceptAnsiColorCodes = outputIsScreen = !Console.IsOutputRedirected;
-            }
-
-            return (acceptAnsiColorCodes: acceptAnsiColorCodes, outputIsScreen: outputIsScreen);
-        }
-
         private int QueryConsoleBufferWidth()
         {
             int consoleBufferWidth = -1;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 3f7a58fdd83..1efec57dc44 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -128,6 +128,36 @@ internal void LogComment(MessageImportance importance, string messageResourceNam
             _loggingService.LogComment(_eventContext, importance, messageResourceName, messageArgs);
         }
 
+        /// <summary>
+        ///  Helper method to create a message build event from a string resource and some parameters
+        /// </summary>
+        /// <param name="importance">Importance level of the message</param>
+        /// <param name="file">The file in which the event occurred</param>
+        /// <param name="messageResourceName">string within the resource which indicates the format string to use</param>
+        /// <param name="messageArgs">string resource arguments</param>
+        internal void LogComment(MessageImportance importance, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        {
+            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+
+            _loggingService.LogBuildEvent(new BuildMessageEventArgs(
+                null,
+                null,
+                file.File,
+                file.Line,
+                file.Column,
+                file.EndLine,
+                file.EndColumn,
+                ResourceUtilities.GetResourceString(messageResourceName),
+                helpKeyword: null,
+                senderName: "MSBuild",
+                importance,
+                DateTime.UtcNow,
+                messageArgs)
+            {
+                BuildEventContext = _eventContext
+            });
+        }
+
         /// <summary>
         /// Helper method to create a message build event from a string
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index a4c66a74ce0..8e6b9ef1c0e 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1637,7 +1637,7 @@ ILogger UnwrapLoggerType(ILogger log)
         /// </remarks>
         private void UpdateMinimumMessageImportance(ILogger logger)
         {
-            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
+            var innerLogger = (logger is ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
 
             MessageImportance? minimumImportance = innerLogger switch
             {
@@ -1651,8 +1651,11 @@ private void UpdateMinimumMessageImportance(ILogger logger)
                 // The null logger has no effect on minimum verbosity.
                 Execution.BuildManager.NullLogger => null,
 
-                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to "any importance".
-                _ => MessageImportance.Low
+                // The live logger consumes only high priority messages.
+                _ => innerLogger.GetType().FullName == "Microsoft.Build.Logging.LiveLogger.LiveLogger"
+                    ? MessageImportance.High
+                    // If the logger is not on our allow list, there are no importance guarantees. Fall back to "any importance".
+                    : MessageImportance.Low,
             };
 
             if (minimumImportance != null)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 8dd00b2148b..096c90e5ff9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -184,7 +184,17 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    ExpanderOptions expanderOptions = ExpanderOptions.ExpandAll;
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) &&
+                        // If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
+                        bucket.BucketSequenceNumber == 0 &&
+                        // Referring to unqualified metadata of other item (transform) is fine.
+                        child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
+                    {
+                        expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
+                    }
+
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -612,7 +622,7 @@ private List<ProjectItemInstance> FindItemsMatchingMetadataSpecification(
         /// 1. The metadata table created for the bucket, may be null.
         /// 2. The metadata table derived from the item definition group, may be null.
         /// </summary>
-        private class NestedMetadataTable : IMetadataTable
+        private class NestedMetadataTable : IMetadataTable, IItemTypeDefinition
         {
             /// <summary>
             /// The table for all metadata added during expansion
@@ -722,6 +732,8 @@ internal void SetValue(string name, string value)
             {
                 _addTable[name] = value;
             }
+
+            string IItemTypeDefinition.ItemType => _itemType;
         }
     }
 }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 69da00e3955..705ca12979e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1396,8 +1396,8 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                                     newItem = new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output.ItemSpec), parameterLocationEscaped);
 
                                     newItem.SetMetadataOnTaskOutput(output.CloneCustomMetadata()
-                                        .Cast<KeyValuePair<string, string>>()
-                                        .Select(x => new KeyValuePair<string, string>(x.Key, EscapingUtilities.Escape(x.Value))));
+                                        .Cast<DictionaryEntry>()
+                                        .Select(x => new KeyValuePair<string, string>((string)x.Key, EscapingUtilities.Escape((string)x.Value))));
                                 }
                             }
 
diff --git a/src/Build/Collections/ConvertingEnumerable.cs b/src/Build/Collections/ConvertingEnumerable.cs
index b4b3e1d7058..e5933cd53dc 100644
--- a/src/Build/Collections/ConvertingEnumerable.cs
+++ b/src/Build/Collections/ConvertingEnumerable.cs
@@ -82,7 +82,7 @@ internal ConvertingEnumerator(IEnumerator<TFrom2> backingEnumerator, Func<TFrom2
             /// <summary>
             /// Get the current element, converted
             /// </summary>
-            public TTo2 Current
+            public readonly TTo2 Current
             {
                 get
                 {
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 4eb8f8edb91..6d8d7a394b6 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -742,7 +742,7 @@ internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards =
             /// <summary>
             /// Get enumerator
             /// </summary>
-            public IEnumerator<ProjectElement> GetEnumerator()
+            public readonly IEnumerator<ProjectElement> GetEnumerator()
             {
                 return _enumerator;
             }
@@ -808,7 +808,7 @@ object System.Collections.IEnumerator.Current
                 /// <summary>
                 /// Dispose. Do nothing.
                 /// </summary>
-                public void Dispose()
+                public readonly void Dispose()
                 {
                 }
 
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index a8ba5cd5c10..473f39c0476 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -100,13 +100,13 @@ public string Value
         /// Creates an unparented ProjectMetadataElement, wrapping an unparented XmlElement.
         /// Caller should then ensure the element is added to a parent.
         /// </summary>
-        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject)
+        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject, ElementLocation location = null)
         {
             XmlUtilities.VerifyThrowArgumentValidElementName(name);
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             ErrorUtilities.VerifyThrowInvalidOperation(!XMakeElements.ReservedItemNames.Contains(name), "CannotModifyReservedItemMetadata", name);
 
-            XmlElementWithLocation element = containingProject.CreateElement(name);
+            XmlElementWithLocation element = containingProject.CreateElement(name, location);
 
             return new ProjectMetadataElement(element, containingProject);
         }
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index b0ff4459c4a..626751e11cf 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1327,13 +1327,22 @@ public ProjectMetadataElement CreateMetadataElement(string name)
         /// Caller must add it to the location of choice in the project.
         /// </summary>
         public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue)
+        {
+            return this.CreateMetadataElement(name, unevaluatedValue, null);
+        }
+
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue, ElementLocation location)
         {
             if (Link != null)
             {
                 return RootLink.CreateMetadataElement(name, unevaluatedValue);
             }
 
-            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this);
+            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this, location);
 
             metadatum.Value = unevaluatedValue;
 
@@ -1785,14 +1794,23 @@ internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDicti
             return projectRootElement;
         }
 
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        internal ProjectMetadataElement CreateMetadataElement(XmlAttributeWithLocation attribute)
+        {
+            return CreateMetadataElement(attribute.Name, attribute.Value, attribute.Location);
+        }
+
         /// <summary>
         /// Creates a XmlElement with the specified name in the document
         /// containing this project.
         /// </summary>
-        internal XmlElementWithLocation CreateElement(string name)
+        internal XmlElementWithLocation CreateElement(string name, ElementLocation location = null)
         {
             ErrorUtilities.VerifyThrow(Link == null, "External project");
-            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace);
+            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace, location);
         }
 
         /// <summary>
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 7db7747eea1..09d2321cad4 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2558,7 +2558,7 @@ public static CumulativeRemoveElementData Create()
                     };
                 }
 
-                public void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
+                public readonly void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
                 {
                     IEnumerable<string> removeSpecFragmentStrings = removeSpec.FlattenFragmentsAsStrings();
                     var removeGlob = removeSpec.ToMSBuildGlob();
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 5cbad98cb06..cfffb456d72 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.Evaluation
     /// ProjectMetadataElement, and these can be added, removed, and modified.
     /// </remarks>
     [DebuggerDisplay("{_itemType} #Metadata={MetadataCount}")]
-    public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadata>, IProjectMetadataParent
+    public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadata>, IProjectMetadataParent, IItemTypeDefinition
     {
         /// <summary>
         /// Project that this item definition lives in.
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 9c064f5e68f..d7d81e88dc6 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -817,7 +817,7 @@ private MSBuildExtensionsPathReferenceKind(string value)
         /// <summary>
         /// Returns the corresponding property name - eg. "$(MSBuildExtensionsPath32)"
         /// </summary>
-        public string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
+        public readonly string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
 
         /// <summary>
         /// Tries to find a reference to MSBuildExtensionsPath* property in the given string
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index bbc34c86a57..88b0de71dbb 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Threading;
 using System.Xml;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -59,6 +60,13 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// </summary>
         private bool? _loadAsReadOnly;
 
+        /// <summary>
+        /// Location of the element to be created via 'CreateElement' call. So that we can
+        ///  receive and use location from the caller up the stack even if we are being called via
+        /// <see cref="XmlDocument"/> internal methods.
+        /// </summary>
+        private readonly AsyncLocal<ElementLocation> _elementLocation = new AsyncLocal<ElementLocation>();
+
         /// <summary>
         /// Constructor
         /// </summary>
@@ -180,6 +188,31 @@ public override void Load(string fullPath)
             }
         }
 
+        /// <summary>
+        /// Called during parse, to add an element.
+        /// </summary>
+        /// <remarks>
+        /// We create our own kind of element, that we can give location information to.
+        /// In order to pass the location through the callchain, that contains XmlDocument function
+        ///  that then calls back to our XmlDocumentWithLocation (so we cannot use call stack via passing via parameters),
+        ///  we use async local field, that simulates variable on call stack.
+        /// </remarks>
+        internal XmlElement CreateElement(string localName, string namespaceURI, ElementLocation location)
+        {
+            if (location != null)
+            {
+                this._elementLocation.Value = location;
+            }
+            try
+            {
+                return CreateElement(localName, namespaceURI);
+            }
+            finally
+            {
+                this._elementLocation.Value = null;
+            }
+        }
+
         /// <summary>
         /// Called during load, to add an element.
         /// </summary>
@@ -192,6 +225,10 @@ public override XmlElement CreateElement(string prefix, string localName, string
             {
                 return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _reader.LineNumber, _reader.LinePosition);
             }
+            else if (_elementLocation?.Value != null)
+            {
+                return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _elementLocation.Value.Line, _elementLocation.Value.Column);
+            }
 
             // Must be a subsequent edit; we can't provide location information
             return new XmlElementWithLocation(prefix, localName, namespaceURI, this);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 1478cc17550..459217b3389 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -88,6 +88,13 @@ internal enum ExpanderOptions
         /// </summary>
         Truncate = 0x40,
 
+        /// <summary>
+        /// Issues build message if item references unqualified or qualified metadata odf self - as this can lead to unintended expansion and
+        ///  cross-combination of other items.
+        /// More info: https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-batching#item-batching-on-self-referencing-metadata
+        /// </summary>
+        LogOnItemMetadataSelfReference = 0x80,
+
         /// <summary>
         /// Expand only properties and then item lists
         /// </summary>
@@ -203,7 +210,7 @@ public void Add(ReadOnlyMemory<char> span)
             /// concatenation of the string representation of the values, each additionally subjected
             /// to file path adjustment.
             /// </returns>
-            public object GetResult()
+            public readonly object GetResult()
             {
                 CheckDisposed();
                 if (_firstObject != null)
@@ -228,7 +235,7 @@ public void Dispose()
             /// <summary>
             /// Throws <see cref="ObjectDisposedException"/> if this concatenator is already disposed.
             /// </summary>
-            private void CheckDisposed() =>
+            private readonly void CheckDisposed() =>
                 ErrorUtilities.VerifyThrowObjectDisposed(!_disposed, nameof(SpanBasedConcatenator));
 
             /// <summary>
@@ -441,7 +448,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
-            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
+            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, loggingContext);
             result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
@@ -871,8 +878,9 @@ private static class MetadataExpander
             /// <param name="metadata">The metadata to be expanded.</param>
             /// <param name="options">Used to specify what to expand.</param>
             /// <param name="elementLocation">The location information for error reporting purposes.</param>
+            /// <param name="loggingContext">The logging context for this operation.</param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
-            internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
+            internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
             {
                 try
                 {
@@ -896,7 +904,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                     {
                         // if there are no item vectors in the string
                         // run a simpler Regex to find item metadata references
-                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
+                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
                         result = RegularExpressions.ItemMetadataPattern.Value.Replace(expression, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
                     }
                     else
@@ -915,7 +923,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         using SpanBasedStringBuilder finalResultBuilder = Strings.GetSpanBasedStringBuilder();
 
                         int start = 0;
-                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
+                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
 
                         if (itemVectorExpressions != null)
                         {
@@ -993,13 +1001,23 @@ private class MetadataMatchEvaluator
                 /// </summary>
                 private ExpanderOptions _options;
 
+                private IElementLocation _elementLocation;
+
+                private LoggingContext _loggingContext;
+
                 /// <summary>
                 /// Constructor taking a source of metadata.
                 /// </summary>
-                internal MetadataMatchEvaluator(IMetadataTable metadata, ExpanderOptions options)
+                internal MetadataMatchEvaluator(
+                    IMetadataTable metadata,
+                    ExpanderOptions options,
+                    IElementLocation elementLocation,
+                    LoggingContext loggingContext)
                 {
                     _metadata = metadata;
-                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate);
+                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate | ExpanderOptions.LogOnItemMetadataSelfReference);
+                    _elementLocation = elementLocation;
+                    _loggingContext = loggingContext;
 
                     ErrorUtilities.VerifyThrow(options != ExpanderOptions.Invalid, "Must be expanding metadata of some kind");
                 }
@@ -1030,6 +1048,17 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                        (!isBuiltInMetadata && ((_options & ExpanderOptions.ExpandCustomMetadata) != 0)))
                     {
                         metadataValue = _metadata.GetEscapedValue(itemType, metadataName);
+
+                        if ((_options & ExpanderOptions.LogOnItemMetadataSelfReference) != 0 &&
+                            _loggingContext != null &&
+                            !string.IsNullOrEmpty(metadataName) &&
+                            _metadata is IItemTypeDefinition itemMetadata &&
+                            (string.IsNullOrEmpty(itemType) || string.Equals(itemType, itemMetadata.ItemType, StringComparison.Ordinal)))
+                        {
+                            _loggingContext.LogComment(MessageImportance.High, new BuildEventFileInfo(_elementLocation),
+                                "ItemReferencingSelfInTarget", itemMetadata.ItemType, metadataName);
+                        }
+
                         if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
                         {
                             metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
@@ -3113,7 +3142,7 @@ private struct FunctionBuilder<T>
             /// </summary>
             public UsedUninitializedProperties UsedUninitializedProperties { get; set; }
 
-            internal Function<T> Build()
+            internal readonly Function<T> Build()
             {
                 return new Function<T>(
                     ReceiverType,
diff --git a/src/Build/Evaluation/IItemTypeDefinition.cs b/src/Build/Evaluation/IItemTypeDefinition.cs
new file mode 100644
index 00000000000..4d594e6ff39
--- /dev/null
+++ b/src/Build/Evaluation/IItemTypeDefinition.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Evaluation;
+
+internal interface IItemTypeDefinition
+{
+    /// <summary>
+    /// The item type to which this metadata applies.
+    /// </summary>
+    string ItemType { get; }
+}
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 89b2ffd1938..c45edf0764b 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -80,7 +80,7 @@ public ItemExpressionFragment(
 
             public override int MatchCount(string itemToMatch)
             {
-                return ReferencedItems.Count(v => v.ItemAsValueFragment.MatchCount(itemToMatch) > 0);
+                return ReferencedItems.Count(v => v.ItemAsValueFragment.IsMatch(itemToMatch));
             }
 
             public override bool IsMatch(string itemToMatch)
diff --git a/src/Build/Evaluation/ItemsAndMetadataPair.cs b/src/Build/Evaluation/ItemsAndMetadataPair.cs
index 3348d1b1662..9ff1f7c3354 100644
--- a/src/Build/Evaluation/ItemsAndMetadataPair.cs
+++ b/src/Build/Evaluation/ItemsAndMetadataPair.cs
@@ -40,7 +40,7 @@ internal ItemsAndMetadataPair(HashSet<string> items, Dictionary<string, Metadata
         /// </summary>
         internal HashSet<string> Items
         {
-            get
+            readonly get
             {
                 return _items;
             }
@@ -58,7 +58,7 @@ internal HashSet<string> Items
         /// </summary>
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get
+            readonly get
             {
                 return _metadata;
             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index e02ef565869..3d87cca546b 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -135,7 +135,7 @@ public ItemData(I item, ProjectItemElement originatingItemElement, int elementOr
                 _normalizedItemValue = normalizedItemValue;
             }
 
-            public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
+            public readonly ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
             {
                 // setting the factory's item element to the original item element that produced the item
                 // otherwise you get weird things like items that appear to have been produced by update elements
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index e622acbfdc5..5de3520dab8 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -324,7 +324,7 @@ private ProjectItemElement ParseProjectItemElement(XmlElementWithLocation elemen
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = item;
 
@@ -744,7 +744,7 @@ private ProjectItemDefinitionElement ParseProjectItemDefinitionXml(XmlElementWit
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = itemDefinition;
 
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 1e1248865be..39993e3a4fc 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -766,7 +766,7 @@ public ProjectGraphBuildRequest(ProjectGraphNode node, ImmutableList<string> tar
 
             public ImmutableList<string> RequestedTargets { get; }
 
-            public bool Equals(ProjectGraphBuildRequest other)
+            public readonly bool Equals(ProjectGraphBuildRequest other)
             {
                 if (Node != other.Node
                     || RequestedTargets.Count != other.RequestedTargets.Count)
@@ -786,12 +786,12 @@ public bool Equals(ProjectGraphBuildRequest other)
                 return true;
             }
 
-            public override bool Equals(object obj)
+            public override readonly bool Equals(object obj)
             {
                 return !(obj is null) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
             }
 
-            public override int GetHashCode()
+            public override readonly int GetHashCode()
             {
                 unchecked
                 {
diff --git a/src/Build/Graph/ProjectGraphEntryPoint.cs b/src/Build/Graph/ProjectGraphEntryPoint.cs
index 8e229b7bd61..6b0f4713494 100644
--- a/src/Build/Graph/ProjectGraphEntryPoint.cs
+++ b/src/Build/Graph/ProjectGraphEntryPoint.cs
@@ -61,7 +61,7 @@ internal static IEnumerable<ProjectGraphEntryPoint> CreateEnumerable(IEnumerable
             }
         }
 
-        internal IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
+        internal readonly IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
         {
             yield return this;
         }
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 9bde7d2db83..7a4bffd0290 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Execution
     /// Immutable.
     /// </summary>
     [DebuggerDisplay("{_itemType} #Metadata={MetadataCount}")]
-    public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadataInstance>, ITranslatable
+    public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadataInstance>, ITranslatable, IItemTypeDefinition
     {
         /// <summary>
         /// Item type, for example "Compile", that this item definition applies to
@@ -235,5 +235,7 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
 
             return instance;
         }
+
+        string IItemTypeDefinition.ItemType => _itemType;
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 9258eb5b33f..ab16a994eee 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -33,7 +33,8 @@ public class ProjectItemInstance :
         ITaskItem2,
         IMetadataTable,
         ITranslatable,
-        IMetadataContainer
+        IMetadataContainer,
+        IItemTypeDefinition
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -2137,7 +2138,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
             /// Also, more importantly, because typically the same regular metadata values can be shared by many items,
             /// and keeping item-specific metadata out of it could allow it to be implemented as a copy-on-write table.
             /// </summary>
-            private class BuiltInMetadataTable : IMetadataTable
+            private class BuiltInMetadataTable : IMetadataTable, IItemTypeDefinition
             {
                 /// <summary>
                 /// Item type
@@ -2195,6 +2196,8 @@ public string GetEscapedValueIfPresent(string requiredItemType, string name)
 
                     return value;
                 }
+
+                string IItemTypeDefinition.ItemType => _itemType;
             }
         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 5525799a483..c73282b3df1 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -160,6 +160,7 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Evaluation\IItemTypeDefinition.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 52faacfee31..5a8f8640a74 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1983,4 +1983,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="NodeReused" xml:space="preserve">
     <value>Reusing node {0} (PID: {1}).</value>
   </data>
-</root>
\ No newline at end of file
+  <data name="ItemReferencingSelfInTarget" xml:space="preserve">
+    <value>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</value>
+    <comment>{StrBegin="MSB4120: "}</comment>
+  </data>
+</root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 482f271ba03..0f52b70e2b8 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Ukončuje se proces s pid = {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 35576a9f7af..363edd349b7 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Die Übergabe eines MSBuildFileSystemBase-Dateisystems an EvaluationContext-Objekte, die mit "SharingPolicy.Isolated" erstellt wurden, wird nicht unterstützt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Der Prozess mit PID {0} wird beendet.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 3b491802de3..b614cd5d41a 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Terminando el proceso con el PID = {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index fbbb2252b81..c38b649d037 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Arrêt du processus ayant le PID = {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index a3a5cb9eca1..4c4932631a8 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Terminazione del processo con PID = {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index e45710015a8..0ab12ba89e3 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -154,6 +154,11 @@
         <target state="translated">SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">PID = {0} のプロセスを中止しています。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 78c2001194e..8101d90c436 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -154,6 +154,11 @@
         <target state="translated">SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">pid가 {0}인 프로세스를 종료하는 중입니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index bcc1dad73ba..334e24ff11e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Kasowanie procesu z identyfikatorem pid = {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index fcfbad3e5df..1231fa2b51b 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Os objetos EvaluationContext criados com SharingPolicy.Isolated não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Encerrando o processo com o PID = {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 3b33882791c..2858ea61d4b 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Завершение процесса с идентификатором {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 8822dee74ae..dda58e54d67 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -154,6 +154,11 @@
         <target state="translated">SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">PID = {0} işlemi sonlandırılıyor.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 198d36450b9..8a2d41f5a59 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -154,6 +154,11 @@
         <target state="translated">使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">正在终止进程，pid = {0}。</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 201836b008e..3bae314d441 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -154,6 +154,11 @@
         <target state="translated">使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">正在終止 pid = {0} 的處理序。</target>
diff --git a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
index acd3388da81..8fc5e75a7b5 100644
--- a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
@@ -63,7 +63,7 @@ public XmlElementChildIterator GetEnumerator()
                 return this;
             }
 
-            public XmlElementWithLocation Current
+            public readonly XmlElementWithLocation Current
             {
                 get
                 {
@@ -73,7 +73,7 @@ public XmlElementWithLocation Current
                 }
             }
 
-            private XmlElementWithLocation GetNextNode(XmlNode child)
+            private readonly XmlElementWithLocation GetNextNode(XmlNode child)
             {
                 while (child != null)
                 {
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index 15f8d543192..fe15c1e9287 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -425,13 +425,13 @@ internal ItemsAndMetadataPair(Hashtable items, Dictionary<string, MetadataRefere
 
         internal Hashtable Items
         {
-            get { return items; }
+            readonly get { return items; }
             set { items = value; }
         }
 
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get { return metadata; }
+            readonly get { return metadata; }
             set { metadata = value; }
         }
     }
diff --git a/src/Framework/BuildEngineResult.cs b/src/Framework/BuildEngineResult.cs
index 9bb2a0c0b08..4371726a8a3 100644
--- a/src/Framework/BuildEngineResult.cs
+++ b/src/Framework/BuildEngineResult.cs
@@ -42,7 +42,7 @@ public BuildEngineResult(bool result, List<IDictionary<string, ITaskItem[]>> tar
         /// <summary>
         /// Did the build pass or fail. True means the build succeeded, False means the build failed.
         /// </summary>
-        public bool Result
+        public readonly bool Result
         {
             get
             {
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
index 7dc7dbdaf86..6ba56e1a880 100644
--- a/src/Framework/ITaskItemExtensions.cs
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -35,7 +35,9 @@ public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this I
                 return enumerableMetadata;
             }
 
-            // In theory this should never be reachable.
+            // Fallback for
+            //  * ITaskItem implementations from MSBuild 3.5 from the GAC
+            //  * Custom ITaskItems that don't use Dictionary<string,string>
             var list = new KeyValuePair<string, string>[customMetadata.Count];
             int i = 0;
 
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 85fbdddd446..c71d9f49ff6 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -345,7 +345,7 @@ private struct PROCESS_BASIC_INFORMATION
         public UIntPtr UniqueProcessId;
         public UIntPtr InheritedFromUniqueProcessId;
 
-        public uint Size
+        public readonly uint Size
         {
             get
             {
@@ -1480,6 +1480,73 @@ internal static void VerifyThrowWin32Result(int result)
         }
     }
 
+#if !CLR2COMPATIBILITY
+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes()
+    {
+        if (Console.IsOutputRedirected)
+        {
+            // There's no ANSI terminal support is console output is redirected.
+            return (acceptAnsiColorCodes: false, outputIsScreen: false, originalConsoleMode: null);
+        }
+
+        bool acceptAnsiColorCodes = false;
+        bool outputIsScreen = false;
+        uint? originalConsoleMode = null;
+        if (IsWindows)
+        {
+            try
+            {
+                IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
+                if (GetConsoleMode(stdOut, out uint consoleMode))
+                {
+                    if ((consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING)
+                    {
+                        // Console is already in required state.
+                        acceptAnsiColorCodes = true;
+                    }
+                    else
+                    {
+                        originalConsoleMode = consoleMode;
+                        consoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                        if (SetConsoleMode(stdOut, consoleMode) && GetConsoleMode(stdOut, out consoleMode))
+                        {
+                            // We only know if vt100 is supported if the previous call actually set the new flag, older
+                            // systems ignore the setting.
+                            acceptAnsiColorCodes = (consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                        }
+                    }
+
+                    uint fileType = GetFileType(stdOut);
+                    // The std out is a char type (LPT or Console).
+                    outputIsScreen = fileType == FILE_TYPE_CHAR;
+                    acceptAnsiColorCodes &= outputIsScreen;
+                }
+            }
+            catch
+            {
+                // In the unlikely case that the above fails we just ignore and continue.
+            }
+        }
+        else
+        {
+            // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
+            acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
+            // It wasn't redirected as tested above so we assume output is screen/console
+            outputIsScreen = true; 
+        }
+        return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
+    }
+
+    internal static void RestoreConsoleMode(uint? originalConsoleMode)
+    {
+        if (IsWindows && originalConsoleMode is not null)
+        {
+            IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
+            _ = SetConsoleMode(stdOut, originalConsoleMode.Value);
+        }
+    }
+#endif // !CLR2COMPATIBILITY
+
     #endregion
 
     #region PInvoke
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index 43dc75bf28d..9f8f95ee9a6 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -101,7 +101,7 @@ public struct EvaluationLocation
         public EvaluationLocationKind Kind { get; }
 
         /// <nodoc/>
-        public bool IsEvaluationPass => File == null;
+        public readonly bool IsEvaluationPass => File == null;
 
         /// <nodoc/>
         public static EvaluationLocation CreateLocationForCondition(long? parentId, EvaluationPass evaluationPass, string evaluationDescription, string file,
@@ -183,7 +183,7 @@ public EvaluationLocation(EvaluationPass evaluationPass, string evaluationPassDe
         public static EvaluationLocation EmptyLocation { get; } = CreateEmptyLocation();
 
         /// <nodoc/>
-        public EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
+        public readonly EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
         {
             return new EvaluationLocation(this.Id, evaluationPass, passDescription ?? PassDefaultDescription[evaluationPass],
                 this.File, this.Line, this.ElementName, this.ElementDescription, this.Kind);
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 3ffb8e5046a..551114540e1 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -156,6 +156,31 @@ public void DistributedFileLoggerSwitchIdentificationTests(string distributedfil
             duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
+        [Theory]
+        [InlineData("ll")]
+        [InlineData("LL")]
+        [InlineData("livelogger")]
+        [InlineData("LiveLogger")]
+        [InlineData("LIVELOGGER")]
+        [InlineData("tl")]
+        [InlineData("TL")]
+        [InlineData("terminallogger")]
+        [InlineData("TerminalLogger")]
+        [InlineData("TERMINALLOGGER")]
+        public void LiveLoggerSwitchIdentificationTests(string livelogger)
+        {
+            CommandLineSwitches.ParameterizedSwitch parameterlessSwitch;
+            string duplicateSwitchErrorMessage;
+
+            CommandLineSwitches.IsParameterizedSwitch(livelogger, out parameterlessSwitch, out duplicateSwitchErrorMessage, out bool multipleParametersAllowed, out string missingParametersErrorMessage, out bool unquoteParameters, out bool emptyParametersAllowed).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.LiveLogger);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeTrue();
+            emptyParametersAllowed.ShouldBeTrue();
+        }
+
         [Theory]
         [InlineData("flp")]
         [InlineData("FLP")]
diff --git a/src/MSBuild.UnitTests/LiveLogger_Tests.cs b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
new file mode 100644
index 00000000000..b8f2fba7ec8
--- /dev/null
+++ b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
@@ -0,0 +1,217 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.LiveLogger;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class LiveLogger_Tests : IEventSource, IDisposable
+    {
+        private const int _nodeCount = 8;
+        private const int _terminalWidth = 80;
+        private const int _terminalHeight = 40;
+        private const string _eventSender = "Test";
+        private const string _projectFile = @"C:\src\project.proj";
+
+        private readonly MockTerminal _mockTerminal;
+        private readonly LiveLogger _liveLogger;
+
+        private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);
+        private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);
+
+        public LiveLogger_Tests()
+        {
+            _mockTerminal = new MockTerminal(_terminalWidth, _terminalHeight);
+            _liveLogger = new LiveLogger(_mockTerminal);
+
+            _liveLogger.Initialize(this, _nodeCount);
+        }
+
+        #region IEventSource implementation
+
+#pragma warning disable CS0067
+        public event BuildMessageEventHandler? MessageRaised;
+
+        public event BuildErrorEventHandler? ErrorRaised;
+
+        public event BuildWarningEventHandler? WarningRaised;
+
+        public event BuildStartedEventHandler? BuildStarted;
+
+        public event BuildFinishedEventHandler? BuildFinished;
+
+        public event ProjectStartedEventHandler? ProjectStarted;
+
+        public event ProjectFinishedEventHandler? ProjectFinished;
+
+        public event TargetStartedEventHandler? TargetStarted;
+
+        public event TargetFinishedEventHandler? TargetFinished;
+
+        public event TaskStartedEventHandler? TaskStarted;
+
+        public event TaskFinishedEventHandler? TaskFinished;
+
+        public event CustomBuildEventHandler? CustomEventRaised;
+
+        public event BuildStatusEventHandler? StatusEventRaised;
+
+        public event AnyEventHandler? AnyEventRaised;
+#pragma warning restore CS0067
+
+        #endregion
+
+        #region IDisposable implementation
+
+        public void Dispose()
+        {
+            _liveLogger.Shutdown();
+        }
+
+        #endregion
+
+        #region Event args helpers
+
+        private BuildEventContext MakeBuildEventContext()
+        {
+            return new BuildEventContext(1, 1, 1, 1);
+        }
+
+        private BuildStartedEventArgs MakeBuildStartedEventArgs()
+        {
+            return new BuildStartedEventArgs(null, null, _buildStartTime);
+        }
+
+        private BuildFinishedEventArgs MakeBuildFinishedEventArgs(bool succeeded)
+        {
+            return new BuildFinishedEventArgs(null, null, succeeded, _buildFinishTime);
+        }
+
+        private ProjectStartedEventArgs MakeProjectStartedEventArgs(string projectFile, string targetNames = "Build")
+        {
+            return new ProjectStartedEventArgs("", "", projectFile, targetNames, new Dictionary<string, string>(), new List<DictionaryEntry>())
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private ProjectFinishedEventArgs MakeProjectFinishedEventArgs(string projectFile, bool succeeded)
+        {
+            return new ProjectFinishedEventArgs(null, null, projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetStartedEventArgs MakeTargetStartedEventArgs(string projectFile, string targetName)
+        {
+            return new TargetStartedEventArgs("", "", targetName, projectFile, targetFile: projectFile)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetFinishedEventArgs MakeTargetFinishedEventArgs(string projectFile, string targetName, bool succeeded)
+        {
+            return new TargetFinishedEventArgs("", "", targetName, projectFile, targetFile: projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskStartedEventArgs MakeTaskStartedEventArgs(string projectFile, string taskName)
+        {
+            return new TaskStartedEventArgs("", "", projectFile, taskFile: projectFile, taskName)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskFinishedEventArgs MakeTaskFinishedEventArgs(string projectFile, string taskName, bool succeeded)
+        {
+            return new TaskFinishedEventArgs("", "", projectFile, taskFile: projectFile, taskName, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildWarningEventArgs MakeWarningEventArgs(string warning)
+        {
+            return new BuildWarningEventArgs("", "", "", 0, 0, 0, 0, warning, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildErrorEventArgs MakeErrorEventArgs(string error)
+        {
+            return new BuildErrorEventArgs("", "", "", 0, 0, 0, 0, error, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        #endregion
+
+        #region Build summary tests
+
+        private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additionalCallbacks)
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+            ProjectStarted?.Invoke(_eventSender, MakeProjectStartedEventArgs(_projectFile));
+
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+
+            additionalCallbacks();
+
+            TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
+            TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
+
+            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(_projectFile, succeeded));
+            BuildFinished?.Invoke(_eventSender, MakeBuildFinishedEventArgs(succeeded));
+        }
+
+        [Fact]
+        public void PrintsBuildSummary_Succeeded()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () => { });
+            _mockTerminal.GetLastLine().ShouldBe("Build succeeded in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_SucceededWithWarnings()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+            });
+            _mockTerminal.GetLastLine().ShouldBe("Build succeeded with warnings in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_Failed()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () => { });
+            _mockTerminal.GetLastLine().ShouldBe("Build failed in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_FailedWithErrors()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+            {
+                ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+            });
+            _mockTerminal.GetLastLine().ShouldBe("Build failed with errors in 5.0s");
+        }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 61f2c68c312..f7c8683c7af 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -45,6 +45,9 @@
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
+    <Compile Remove="LiveLogger_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
+    <Compile Remove="MockTerminal.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
+
     <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.Core.xsd">
       <Link>Microsoft.Build.Core.xsd</Link>
       <SubType>
diff --git a/src/MSBuild.UnitTests/MockTerminal.cs b/src/MSBuild.UnitTests/MockTerminal.cs
new file mode 100644
index 00000000000..915a1e15c8b
--- /dev/null
+++ b/src/MSBuild.UnitTests/MockTerminal.cs
@@ -0,0 +1,118 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using Microsoft.Build.Logging.LiveLogger;
+
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// A test implementation of <see cref="ITerminal"/>.
+    /// </summary>
+    internal sealed class MockTerminal : ITerminal
+    {
+        private readonly int _width;
+        private readonly int _height;
+
+        /// <summary>
+        /// Contains output lines written to the terminal.
+        /// </summary>
+        private List<string> _outputLines = new();
+
+        private StringBuilder _bufferedOutput = new();
+        private bool _isBuffering = false;
+
+        public MockTerminal(int width, int height)
+        {
+            _width = width;
+            _height = height;
+            _outputLines.Add("");
+        }
+
+        /// <summary>
+        /// Gets the last line written to the terminal.
+        /// </summary>
+        /// <remarks>
+        /// If the last character was \n, it returns characters between the second to last \n and last \n.
+        /// If the last character was not \n, it returns characters between the last \n and the end of the output.
+        /// </remarks>
+        public string GetLastLine()
+        {
+            string lastLine = _outputLines[^1];
+            if (lastLine.Length == 0 && _outputLines.Count > 1)
+            {
+                lastLine = _outputLines[^2];
+            }
+            return lastLine;
+        }
+
+        /// <summary>
+        /// Adds a string to <see cref="_outputLines"/>.
+        /// </summary>
+        private void AddOutput(string text)
+        {
+            if (_isBuffering)
+            {
+                _bufferedOutput.Append(text);
+            }
+            else
+            {
+                string[] lines = text.Split('\n');
+                _outputLines[^1] += lines[0];
+                for (int i = 1; i < lines.Length; i++)
+                {
+                    _outputLines.Add("");
+                    _outputLines[^1] += lines[i];
+                }
+            }
+        }
+
+        #region ITerminal implementation
+
+        public int Width => _width;
+        public int Height => _height;
+
+        public void BeginUpdate()
+        {
+            if (_isBuffering)
+            {
+                throw new InvalidOperationException();
+            }
+            _isBuffering = true;
+        }
+
+        public void EndUpdate()
+        {
+            if (!_isBuffering)
+            {
+                throw new InvalidOperationException();
+            }
+            _isBuffering = false;
+
+            AddOutput(_bufferedOutput.ToString());
+            _bufferedOutput.Clear();
+        }
+
+        public void Write(string text) => AddOutput(text);
+        public void Write(ReadOnlySpan<char> text) { AddOutput(text.ToString()); }
+        public void WriteColor(TerminalColor color, string text) => AddOutput(text);
+        public void WriteColorLine(TerminalColor color, string text) { AddOutput(text); AddOutput("\n"); }
+        public void WriteLine(string text) { AddOutput(text); AddOutput("\n"); }
+        public void WriteLineFitToWidth(ReadOnlySpan<char> text)
+        {
+            AddOutput(text.Slice(0, Math.Min(text.Length, _width - 1)).ToString());
+            AddOutput("\n");
+        }
+
+        #endregion
+
+        #region IDisposable implementation
+
+        public void Dispose()
+        { }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 5b6154726c8..5b2f7e67fb4 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -47,7 +47,6 @@ internal enum ParameterlessSwitch
             FileLogger8,
             FileLogger9,
             DistributedFileLogger,
-            LiveLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -90,6 +89,7 @@ internal enum ParameterizedSwitch
             FileLoggerParameters7,
             FileLoggerParameters8,
             FileLoggerParameters9,
+            LiveLogger,
             NodeReuse,
             Preprocess,
             Targets,
@@ -210,7 +210,6 @@ internal ParameterizedSwitchInfo(
             new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null),
             new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null),
             new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null),
-            new ParameterlessSwitchInfo(  new string[] { "livelogger", "ll", "fancylogger", "flg" }, ParameterlessSwitch.LiveLogger,            null),
 #if DEBUG
             new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null),
 #endif
@@ -247,6 +246,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.LiveLogger,          null,                           true,          null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false),
             new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false),
diff --git a/src/MSBuild/LiveLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
deleted file mode 100644
index f787c2949b3..00000000000
--- a/src/MSBuild/LiveLogger/ANSIBuilder.cs
+++ /dev/null
@@ -1,452 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal static class ANSIBuilder
-    {
-        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~]|(?:\]8;;.*?\x1b\\))";
-        // TODO: This should replace ANSIRegex once LiveLogger's API is internal
-        public static Regex ANSIRegexRegex = new Regex(ANSIRegex);
-        public static string ANSIRemove(string text)
-        {
-            return ANSIRegexRegex.Replace(text, "");
-        }
-
-        /// <summary>
-        /// Find a place to break a string after a number of visible characters, not counting VT-100 codes.
-        /// </summary>
-        /// <param name="text">String to split.</param>
-        /// <param name="position">Number of visible characters to split after.</param>
-        /// <returns>Index in <paramref name="text"/> that represents <paramref name="position"/> visible characters.</returns>
-        // TODO: This should be an optional parameter for ANSIBreakpoint(string text, int positioon, int initialPosition = 0)
-        public static int ANSIBreakpoint(string text, int position)
-        {
-            return ANSIBreakpoint(text, position, 0);
-        }
-        public static int ANSIBreakpoint(string text, int position, int initialPosition)
-        {
-            if (position >= text.Length)
-            {
-                return text.Length;
-            }
-            int nonAnsiIndex = 0;
-            Match nextMatch = ANSIRegexRegex.Match(text, initialPosition);
-            int logicalIndex = 0;
-            while (logicalIndex < text.Length && nonAnsiIndex != position)
-            {
-                // Jump over ansi codes
-                if (logicalIndex == nextMatch.Index && nextMatch.Length > 0)
-                {
-                    logicalIndex += nextMatch.Length;
-                    nextMatch = nextMatch.NextMatch();
-                }
-                // Increment non ansi index
-                nonAnsiIndex++;
-                logicalIndex++;
-            }
-            return logicalIndex;
-        }
-
-        public static List<string> ANSIWrap(string text, int maxLength)
-        {
-            ReadOnlySpan<char> textSpan = text.AsSpan();
-            List<string> result = new();
-            int breakpoint = ANSIBreakpoint(text, maxLength);
-            while (textSpan.Length > breakpoint)
-            {
-                result.Add(textSpan.Slice(0, breakpoint).ToString());
-                textSpan = textSpan.Slice(breakpoint);
-                breakpoint = ANSIBreakpoint(text, maxLength, breakpoint);
-            }
-            result.Add(textSpan.ToString());
-            return result;
-        }
-
-        public static class Alignment
-        {
-            public static string Center(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = (Console.BufferWidth - noFormatString.Length) / 2;
-                result += new string(' ', space);
-                result += text;
-                result += new string(' ', space);
-                return result;
-            }
-
-            public static string Right(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = Console.BufferWidth - noFormatString.Length;
-                result += new string(' ', space);
-                result += text;
-                return result;
-            }
-
-            public static string Left(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = Console.BufferWidth - noFormatString.Length;
-                result += text;
-                result += new string(' ', space);
-                return result;
-            }
-
-            public static string SpaceBetween(string leftText, string rightText, int width)
-            {
-                string result = String.Empty;
-                string leftNoFormatString = ANSIRemove(leftText);
-                string rightNoFormatString = ANSIRemove(rightText);
-                if (leftNoFormatString.Length + rightNoFormatString.Length >= width)
-                {
-                    return leftText + rightText;
-                }
-
-                int space = width - (leftNoFormatString.Length + rightNoFormatString.Length);
-                result += leftText;
-                result += new string(' ', space - 1);
-                result += rightText;
-                return result;
-            }
-        }
-
-        public static class Formatting
-        {
-            public enum ForegroundColor
-            {
-                Black = 30,
-                Red = 31,
-                Green = 32,
-                Yellow = 33,
-                Blue = 34,
-                Magenta = 35,
-                Cyan = 36,
-                White = 37,
-                Default = 39
-            };
-
-            public enum BackgroundColor
-            {
-                Black = 40,
-                Red = 41,
-                Green = 42,
-                Yellow = 43,
-                Blue = 44,
-                Magenta = 45,
-                Cyan = 46,
-                White = 47,
-                Default = 49
-            }
-
-            public static string Color(string text, ForegroundColor color)
-            {
-                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
-            }
-
-            public static string Color(string text, BackgroundColor color)
-            {
-                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
-            }
-
-            public static string Color(string text, BackgroundColor backgrdoundColor, ForegroundColor foregroundColor)
-            {
-                return String.Format("\x1b[{0};{1}m{2}\x1b[0m", (int)backgrdoundColor, (int)foregroundColor, text);
-            }
-
-            public static string Bold(string text)
-            {
-                return String.Format("\x1b[1m{0}\x1b[22m", text);
-            }
-
-            public static string Dim(string text)
-            {
-                return String.Format("\x1b[2m{0}\x1b[22m", text);
-            }
-
-            public static string Italic(string text)
-            {
-                return String.Format("\x1b[3m{0}\x1b[23m", text);
-            }
-
-            public static string Underlined(string text)
-            {
-                return String.Format("\x1b[4m{0}\x1b[24m", text);
-            }
-
-            public static string DoubleUnderlined(string text)
-            {
-                return String.Format("\x1b[21m{0}\x1b[24m", text);
-            }
-
-            public static string Inverse(string text)
-            {
-                return String.Format("\x1b[7m{0}\x1b[27m", text);
-            }
-
-            public static string Invisible(string text)
-            {
-                return String.Format("\x1b[8m{0}\x1b[28m", text);
-            }
-
-            public static string CrossedOut(string text)
-            {
-                return String.Format("\x1b[9m{0}\x1b[29m", text);
-            }
-
-            public static string Overlined(string text)
-            {
-                return String.Format("\x1b[53m{0}\x1b[55m", text);
-            }
-
-            public static string Hyperlink(string text, string rawUrl)
-            {
-                string url = rawUrl.Length > 0 ? new System.Uri(rawUrl).AbsoluteUri : rawUrl;
-                return $"\x1b]8;;{url}\x1b\\{text}\x1b]8;;\x1b\\";
-            }
-
-            public static string DECLineDrawing(string text)
-            {
-                return String.Format("\x1b(0{0}\x1b(B", text);
-            }
-        }
-
-        public static class Cursor
-        {
-            public enum CursorStyle
-            {
-                Default = 0,
-                BlockBlinking = 1,
-                BlockSteady = 2,
-                UnderlineBlinking = 3,
-                UnderlineSteady = 4,
-                BarBlinking = 5,
-                BarSteady = 6,
-            }
-
-            public static string Style(CursorStyle style)
-            {
-                return String.Format("\x1b[{0} q", (int)style);
-            }
-
-            public static string Up(int n = 1)
-            {
-                return String.Format("\x1b[{0}A", n);
-            }
-
-            public static string UpAndScroll(int n)
-            {
-                string result = "";
-                for (int i = 0; i < n; i++)
-                {
-                    result += "\x1bM";
-                }
-                return result;
-            }
-
-            public static string Down(int n = 1)
-            {
-                return String.Format("\x1b[{0}B", n);
-            }
-
-            public static string Forward(int n = 1)
-            {
-                return String.Format("\x1b[{0}C", n);
-            }
-
-            public static string Backward(int n = 1)
-            {
-                return String.Format("\x1b[{0}D", n);
-            }
-
-            public static string Home()
-            {
-                return String.Format("\x1b[H");
-            }
-
-            public static string Position(int row, int column)
-            {
-                return String.Format("\x1b[{0};{1}H", row, column);
-            }
-
-            public static string SavePosition()
-            {
-                return String.Format("\x1b[s");
-            }
-
-            public static string RestorePosition()
-            {
-                return String.Format("\x1b[u");
-            }
-
-            public static string Invisible()
-            {
-                return "\x1b[?25l";
-            }
-
-            public static string Visible()
-            {
-                return "\x1b[?25h";
-            }
-        }
-
-        public static class Tabulator
-        {
-            public static string SetStop()
-            {
-                return String.Format("\x1bH");
-            }
-
-            public static string ForwardTab(int n)
-            {
-                if (n == 0)
-                {
-                    return "";
-                }
-
-                return String.Format("\x1b[{0}I", n);
-            }
-
-            public static string BackwardTab(int n)
-            {
-                return String.Format("\x1b[{0}Z", n);
-            }
-
-            public static string UnsetStop()
-            {
-                return String.Format("\x1b[0g");
-            }
-
-            public static string UnserAlStops()
-            {
-                return String.Format("\x1b[3g");
-            }
-        }
-
-        public static class Viewport
-        {
-            public static string ScrollDown(int n)
-            {
-                return String.Format("\x1b[{0}T", n);
-            }
-
-            public static string ScrollUp(int n)
-            {
-                return String.Format("\x1b[{0}S", n);
-            }
-
-            public static string SetScrollingRegion(int start, int end)
-            {
-                return String.Format("\x1b[{0};{1}r", start, end);
-            }
-
-            public static string PrependLines(int n)
-            {
-                return String.Format("\x1b[{0}L", n);
-            }
-
-            public static string DeleteLines(int n)
-            {
-                return String.Format("\x1b[{0}M", n);
-            }
-        }
-
-        public static class Eraser
-        {
-            public static string DisplayCursorToEnd()
-            {
-                return String.Format("\x1b[0J");
-            }
-
-            public static string DisplayStartToCursor()
-            {
-                return String.Format("\x1b[1J");
-            }
-
-            public static string Display()
-            {
-                return String.Format("\x1b[2J");
-            }
-
-            public static string LineCursorToEnd()
-            {
-                return String.Format("\x1b[0K");
-            }
-
-            public static string LineStartToCursor()
-            {
-                return String.Format("\x1b[1K");
-            }
-
-            public static string Line()
-            {
-                return String.Format("\x1b[2k");
-            }
-        }
-
-        public static class Graphics
-        {
-            private static int spinnerCounter = 0;
-            public static string Spinner()
-            {
-                return Spinner(spinnerCounter++);
-            }
-
-            public static string Spinner(int n)
-            {
-                char[] chars = { '\\', '|', '/', '-' };
-                return chars[n % (chars.Length - 1)].ToString();
-            }
-
-            public static string ProgressBar(float percentage, int width = 10, char completedChar = '█', char remainingChar = '░')
-            {
-                return new string(completedChar, (int)Math.Floor(width * percentage)) + new string(remainingChar, width - (int)Math.Floor(width * percentage));
-            }
-
-            public static string Bell()
-            {
-                return String.Format("\x07");
-            }
-        }
-
-        public static class Buffer
-        {
-            public static string Fill()
-            {
-                return String.Format("\x1b#8");
-            }
-
-            public static string UseAlternateBuffer()
-            {
-                return "\x1b[?1049h";
-            }
-
-            public static string UseMainBuffer()
-            {
-                return "\x1b[?1049l";
-            }
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/AnsiCodes.cs b/src/MSBuild/LiveLogger/AnsiCodes.cs
new file mode 100644
index 00000000000..2b61583bbbe
--- /dev/null
+++ b/src/MSBuild/LiveLogger/AnsiCodes.cs
@@ -0,0 +1,88 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// A collection of standard ANSI/VT100 control codes.
+/// </summary>
+internal static class AnsiCodes
+{
+    /// <summary>
+    /// The control sequence introducer.
+    /// </summary>
+    public const string CSI = "\x1b[";
+
+    /// <summary>
+    /// Select graphic rendition.
+    /// </summary>
+    /// <remarks>\
+    /// Print <see cref="CSI"/>color-code<see cref="SetColor"/> to change text color.
+    /// </remarks>
+    public const string SetColor = ";1m";
+
+    /// <summary>
+    /// A shortcut to reset color back to normal.
+    /// </summary>
+    public const string SetDefaultColor = CSI + "m";
+
+    /// <summary>
+    /// Non-xterm extension to render a hyperlink.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="LinkPrefix"/>url<see cref="LinkInfix"/>text<see cref="LinkSuffix"/> to render a hyperlink.
+    /// </remarks>
+    public const string LinkPrefix = "\x1b]8;;";
+
+    /// <summary>
+    /// <see cref="LinkPrefix"/>
+    /// </summary>
+    public const string LinkInfix = "\x1b\\";
+
+    /// <summary>
+    /// <see cref="LinkPrefix"/>
+    /// </summary>
+    public const string LinkSuffix = "\x1b]8;;\x1b\\";
+
+    /// <summary>
+    /// Moves up the specified number of lines and puts cursor at the beginning of the line.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveUpToLineStart"/> to move N lines up.
+    /// </remarks>
+    public const string MoveUpToLineStart = "F";
+
+    /// <summary>
+    /// Moves forward (to the right) the specified number of characters.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveForward"/> to move N characters forward.
+    /// </remarks>
+    public const string MoveForward = "C";
+
+    /// <summary>
+    /// Clears everything from cursor to end of screen.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="EraseInDisplay"/> to clear.
+    /// </remarks>
+    public const string EraseInDisplay = "J";
+
+    /// <summary>
+    /// Clears everything from cursor to the end of the current line.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="EraseInLine"/> to clear.
+    /// </remarks>
+    public const string EraseInLine = "K";
+
+    /// <summary>
+    /// Hides the cursor.
+    /// </summary>
+    public const string HideCursor = "\x1b[?25l";
+
+    /// <summary>
+    /// Shows/restores the cursor.
+    /// </summary>
+    public const string ShowCursor = "\x1b[?25h";
+}
diff --git a/src/MSBuild/LiveLogger/BuildMessage.cs b/src/MSBuild/LiveLogger/BuildMessage.cs
new file mode 100644
index 00000000000..93a9cf26f94
--- /dev/null
+++ b/src/MSBuild/LiveLogger/BuildMessage.cs
@@ -0,0 +1,10 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Represents a piece of diagnostic output (message/warning/error).
+/// </summary>
+internal record struct BuildMessage(MessageSeverity Severity, string Message)
+{ }
diff --git a/src/MSBuild/LiveLogger/ITerminal.cs b/src/MSBuild/LiveLogger/ITerminal.cs
new file mode 100644
index 00000000000..6a2f1e67faa
--- /dev/null
+++ b/src/MSBuild/LiveLogger/ITerminal.cs
@@ -0,0 +1,82 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// An abstraction of a terminal, built specifically to fit the <see cref="LiveLogger"/> needs.
+/// </summary>
+internal interface ITerminal : IDisposable
+{
+    /// <summary>
+    /// Width of the terminal buffer.
+    /// </summary>
+    int Width { get; }
+
+    /// <summary>
+    /// Height of the terminal buffer.
+    /// </summary>
+    int Height { get; }
+
+    /// <summary>
+    /// Starts buffering the text passed via the <c>Write*</c> methods.
+    /// </summary>
+    /// <remarks>
+    /// Upon calling this method, the terminal should be buffering all output internally until <see cref="EndUpdate"/> is called.
+    /// </remarks>
+    void BeginUpdate();
+
+    /// <summary>
+    /// Flushes the text buffered between <see cref="BeginUpdate"/> was called and now into the output.
+    /// </summary>
+    void EndUpdate();
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void Write(string text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void Write(ReadOnlySpan<char> text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLine(string text);
+
+    /// <summary>
+    /// Writes a string to the output, truncating it if it wouldn't fit on one screen line.
+    /// Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLineFitToWidth(ReadOnlySpan<char> text);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColor(TerminalColor color, string text);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColorLine(TerminalColor color, string text);
+}
+
+/// <summary>
+/// Enumerates the text colors supported by <see cref="ITerminal"/>.
+/// </summary>
+internal enum TerminalColor
+{
+    Black = 30,
+    Red = 31,
+    Green = 32,
+    Yellow = 33,
+    Blue = 34,
+    Magenta = 35,
+    Cyan = 36,
+    White = 37,
+    Default = 39
+}
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 7068886ba69..5bcb21138d1 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -2,36 +2,127 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Threading.Tasks;
-using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Logging.LiveLogger
+using System.Text;
+using System.Threading;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+#if NETFRAMEWORK
+using Microsoft.IO;
+#else
+using System.IO;
+#endif
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// A logger which updates the console output "live" during the build.
+/// </summary>
+/// <remarks>
+/// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.
+/// </remarks>
+internal sealed class LiveLogger : INodeLogger
 {
-    internal class LiveLogger : ILogger
+    /// <summary>
+    /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
+    /// </summary>
+    internal record struct ProjectContext(int Id)
     {
-        private ConcurrentDictionary<int, ProjectNode> projects = new();
-
-        private bool succeeded;
-        private int startedProjects = 0;
-        private int finishedProjects = 0;
-        private ConcurrentDictionary<string, int> blockedProjects = new();
-
-        private Stopwatch? _stopwatch;
-
-        public LoggerVerbosity Verbosity { get; set; }
-        public string Parameters { get; set; }
+        public ProjectContext(BuildEventContext context)
+            : this(context.ProjectContextId)
+        { }
+    }
 
-        /// <summary>
-        /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
-        /// </summary>
-        /// <remarks>
-        /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
-        /// </remarks>
-        public static readonly string[] ConfigurableForwardingLoggerParameters =
+    /// <summary>
+    /// Encapsulates the per-node data shown in live node output.
+    /// </summary>
+    internal record NodeStatus(string Project, string? TargetFramework, string Target, Stopwatch Stopwatch)
+    {
+        public override string ToString()
         {
+            return string.IsNullOrEmpty(TargetFramework)
+                ? $"{Indentation}{Project} {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)"
+                : $"{Indentation}{Project} [{TargetFramework}] {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)";
+        }
+    }
+
+    /// <summary>
+    /// The indentation to use for all build output.
+    /// </summary>
+    private const string Indentation = "  ";
+
+    /// <summary>
+    /// Protects access to state shared between the logger callbacks and the rendering thread.
+    /// </summary>
+    private readonly object _lock = new();
+
+    /// <summary>
+    /// A cancellation token to signal the rendering thread that it should exit.
+    /// </summary>
+    private readonly CancellationTokenSource _cts = new();
+
+    /// <summary>
+    /// Tracks the status of all relevant projects seen so far.
+    /// </summary>
+    /// <remarks>
+    /// Keyed by an ID that gets passed to logger callbacks, this allows us to quickly look up the corresponding project.
+    /// </remarks>
+    private readonly Dictionary<ProjectContext, Project> _projects = new();
+
+    /// <summary>
+    /// Tracks the work currently being done by build nodes. Null means the node is not doing any work worth reporting.
+    /// </summary>
+    private NodeStatus?[] _nodes = Array.Empty<NodeStatus>();
+
+    /// <summary>
+    /// The timestamp of the <see cref="IEventSource.BuildStarted"/> event.
+    /// </summary>
+    private DateTime _buildStartTime;
+
+    /// <summary>
+    /// True if the build has encountered at least one error.
+    /// </summary>
+    private bool _buildHasErrors;
+
+    /// <summary>
+    /// True if the build has encountered at least one warning.
+    /// </summary>
+    private bool _buildHasWarnings;
+
+    /// <summary>
+    /// The project build context corresponding to the <c>Restore</c> initial target, or null if the build is currently
+    /// bot restoring.
+    /// </summary>
+    private ProjectContext? _restoreContext;
+
+    /// <summary>
+    /// The thread that performs periodic refresh of the console output.
+    /// </summary>
+    private Thread? _refresher;
+
+    /// <summary>
+    /// What is currently displaying in Nodes section as strings representing per-node console output.
+    /// </summary>
+    private NodesFrame _currentFrame = new(Array.Empty<NodeStatus>(), 0, 0);
+
+    /// <summary>
+    /// The <see cref="Terminal"/> to write console output to.
+    /// </summary>
+    private ITerminal Terminal { get; }
+
+    /// <summary>
+    /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
+    /// </summary>
+    /// <remarks>
+    /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
+    /// node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
+    /// Important: Note that LiveLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
+    /// so changing this list may impact the minimum message importance logging optimization.
+    /// </remarks>
+    public static readonly string[] ConfigurableForwardingLoggerParameters =
+    {
             "BUILDSTARTEDEVENT",
             "BUILDFINISHEDEVENT",
             "PROJECTSTARTEDEVENT",
@@ -42,302 +133,612 @@ internal class LiveLogger : ILogger
             "HIGHMESSAGEEVENT",
             "WARNINGEVENT",
             "ERROREVENT"
-        };
+    };
+
+    /// <summary>
+    /// Default constructor, used by the MSBuild logger infra.
+    /// </summary>
+    public LiveLogger()
+    {
+        Terminal = new Terminal();
+    }
+
+    /// <summary>
+    /// Internal constructor accepting a custom <see cref="ITerminal"/> for testing.
+    /// </summary>
+    internal LiveLogger(ITerminal terminal)
+    {
+        Terminal = terminal;
+    }
+
+    #region INodeLogger implementation
+
+    /// <inheritdoc/>
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }
+
+    /// <inheritdoc/>
+    public string Parameters { get => ""; set { } }
+
+    /// <inheritdoc/>
+    public void Initialize(IEventSource eventSource, int nodeCount)
+    {
+        _nodes = new NodeStatus[nodeCount];
+
+        Initialize(eventSource);
+    }
+
+    /// <inheritdoc/>
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.BuildStarted += BuildStarted;
+        eventSource.BuildFinished += BuildFinished;
+        eventSource.ProjectStarted += ProjectStarted;
+        eventSource.ProjectFinished += ProjectFinished;
+        eventSource.TargetStarted += TargetStarted;
+        eventSource.TargetFinished += TargetFinished;
+        eventSource.TaskStarted += TaskStarted;
+
+        eventSource.MessageRaised += MessageRaised;
+        eventSource.WarningRaised += WarningRaised;
+        eventSource.ErrorRaised += ErrorRaised;
+    }
+
+    /// <inheritdoc/>
+    public void Shutdown()
+    {
+        Terminal.Dispose();
+    }
+
+    #endregion
+
+    #region Logger callbacks
+
+    /// <summary>
+    /// The <see cref="IEventSource.BuildStarted"/> callback.
+    /// </summary>
+    private void BuildStarted(object sender, BuildStartedEventArgs e)
+    {
+        _refresher = new Thread(ThreadProc);
+        _refresher.Start();
+
+        _buildStartTime = e.Timestamp;
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.BuildFinished"/> callback.
+    /// </summary>
+    private void BuildFinished(object sender, BuildFinishedEventArgs e)
+    {
+        _cts.Cancel();
+        _refresher?.Join();
+
+        _projects.Clear();
 
-        public LiveLogger()
+        Terminal.BeginUpdate();
+        try
         {
-            Parameters = "";
+
+            Terminal.WriteLine("");
+            Terminal.Write("Build ");
+
+            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);
+
+            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;
+            Terminal.WriteLine($" in {duration:F1}s");
         }
+        finally
+        {
+            Terminal.EndUpdate();
+        }
+
+        _buildHasErrors = false;
+        _buildHasWarnings = false;
+    }
 
-        public void Initialize(IEventSource eventSource)
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectStarted"/> callback.
+    /// </summary>
+    private void ProjectStarted(object sender, ProjectStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
+        {
+            return;
+        }
+
+        ProjectContext c = new ProjectContext(buildEventContext);
+
+        if (_restoreContext is null)
         {
-            // Start the stopwatch as soon as the logger is initialized to capture
-            // any time before the BuildStarted event
-            _stopwatch = Stopwatch.StartNew();
-            // Register for different events. Make sure that ConfigurableForwardingLoggerParameters are in sync with them.
-            // Started and Finished events  
-            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
-            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
-            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
-            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
-            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
-            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
-
-            // Messages/Warnings/Errors
-            // BuildMessageEventHandler event handler below currently process only High importance events. 
-            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
-            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
-            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
-
-            // Cancelled
-            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);
-
-            Task.Run(() =>
+            if (e.GlobalProperties?.TryGetValue("TargetFramework", out string? targetFramework) != true)
             {
-                Render();
-            });
+                targetFramework = null;
+            }
+            _projects[c] = new(targetFramework);
         }
 
-        private void Render()
+        if (e.TargetNames == "Restore")
         {
-            // Initialize LiveLoggerBuffer
-            TerminalBuffer.Initialize();
-            // TODO: Fix. First line does not appear at top. Leaving empty line for now
-            TerminalBuffer.WriteNewLine(string.Empty);
+            _restoreContext = c;
+            _nodes[0] = new NodeStatus(e.ProjectFile!, null, "Restore", _projects[c].Stopwatch);
+        }
+    }
 
-            // Top line indicates the number of finished projects.
-            TerminalBuffer.FinishedProjects = this.finishedProjects;
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectFinished"/> callback.
+    /// </summary>
+    private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
+        {
+            return;
+        }
 
-            // First render
-            TerminalBuffer.Render();
-            int i = 0;
-            // Rerender periodically
-            while (!TerminalBuffer.IsTerminated)
+        // Mark node idle until something uses it again
+        if (_restoreContext is null)
+        {
+            lock (_lock)
             {
-                i++;
-                // Delay by 1/60 seconds
-                // Use task delay to avoid blocking the task, so that keyboard input is listened continously
-                Task.Delay((i / 60) * 1_000).ContinueWith((t) =>
+                _nodes[NodeIndexForContext(buildEventContext)] = null;
+            }
+        }
+
+        ProjectContext c = new(buildEventContext);
+
+        // First check if we're done restoring.
+        if (_restoreContext is ProjectContext restoreContext && c == restoreContext)
+        {
+            lock (_lock)
+            {
+                _restoreContext = null;
+
+                Stopwatch projectStopwatch = _projects[restoreContext].Stopwatch;
+                double duration = projectStopwatch.Elapsed.TotalSeconds;
+                projectStopwatch.Stop();
+
+                Terminal.BeginUpdate();
+                try
+                {
+                    EraseNodes();
+                    Terminal.WriteLine($"Restore complete ({duration:F1}s)");
+                    DisplayNodes();
+                }
+                finally
                 {
-                    TerminalBuffer.FinishedProjects = this.finishedProjects;
+                    Terminal.EndUpdate();
+                }
+                return;
+            }
+        }
+
+        // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.
+        if (_projects.TryGetValue(c, out Project? project) && (project.OutputPath is not null || project.BuildMessages is not null))
+        {
+            lock (_lock)
+            {
+                Terminal.BeginUpdate();
+                try
+                {
+                    EraseNodes();
+
+                    double duration = project.Stopwatch.Elapsed.TotalSeconds;
+                    ReadOnlyMemory<char>? outputPath = project.OutputPath;
 
-                    // Rerender projects only when needed
-                    foreach (var project in projects)
+                    Terminal.Write(Indentation);
+
+                    if (e.ProjectFile is not null)
+                    {
+                        ReadOnlySpan<char> projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile.AsSpan());
+                        Terminal.Write(projectFile);
+                        Terminal.Write(" ");
+                    }
+                    if (!string.IsNullOrEmpty(project.TargetFramework))
                     {
-                        project.Value.Log();
+                        Terminal.Write($"[{project.TargetFramework}] ");
                     }
 
-                    // Rerender buffer
-                    TerminalBuffer.Render();
-                });
-                // Handle keyboard input
-                if (Console.KeyAvailable)
-                {
-                    ConsoleKey key = Console.ReadKey().Key;
-                    switch (key)
+                    // Print 'failed', 'succeeded with warnings', or 'succeeded' depending on the build result and diagnostic messages
+                    // reported during build.
+                    bool haveErrors = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Error) == true;
+                    bool haveWarnings = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Warning) == true;
+                    PrintBuildResult(e.Succeeded, haveErrors, haveWarnings);
+
+                    _buildHasErrors |= haveErrors;
+                    _buildHasWarnings |= haveWarnings;
+
+                    // Print the output path as a link if we have it.
+                    if (outputPath is not null)
                     {
-                        case ConsoleKey.UpArrow:
-                            if (TerminalBuffer.TopLineIndex > 0)
+                        ReadOnlySpan<char> url = outputPath.Value.Span;
+                        try
+                        {
+                            // If possible, make the link point to the containing directory of the output.
+                            url = Path.GetDirectoryName(url);
+                        }
+                        catch
+                        {
+                            // Ignore any GetDirectoryName exceptions.
+                        }
+#if NETCOREAPP
+                        Terminal.WriteLine($" ({duration:F1}s) → {AnsiCodes.LinkPrefix}{url}{AnsiCodes.LinkInfix}{outputPath}{AnsiCodes.LinkSuffix}");
+#else
+                        Terminal.WriteLine($" ({duration:F1}s) → {AnsiCodes.LinkPrefix}{url.ToString()}{AnsiCodes.LinkInfix}{outputPath.ToString()}{AnsiCodes.LinkSuffix}");
+#endif
+                    }
+                    else
+                    {
+                        Terminal.WriteLine($" ({duration:F1}s)");
+                    }
+
+                    // Print diagnostic output under the Project -> Output line.
+                    if (project.BuildMessages is not null)
+                    {
+                        foreach (BuildMessage buildMessage in project.BuildMessages)
+                        {
+                            TerminalColor color = buildMessage.Severity switch
                             {
-                                TerminalBuffer.TopLineIndex--;
-                            }
-                            TerminalBuffer.ShouldRerender = true;
-                            break;
-                        case ConsoleKey.DownArrow:
-                            TerminalBuffer.TopLineIndex++;
-                            TerminalBuffer.ShouldRerender = true;
-                            break;
-                        default:
-                            break;
+                                MessageSeverity.Warning => TerminalColor.Yellow,
+                                MessageSeverity.Error => TerminalColor.Red,
+                                _ => TerminalColor.Default,
+                            };
+                            Terminal.WriteColorLine(color, $"{Indentation}{Indentation}{buildMessage.Message}");
+                        }
                     }
+
+                    DisplayNodes();
+                }
+                finally
+                {
+                    Terminal.EndUpdate();
                 }
             }
         }
+    }
 
-        private void UpdateFooter()
+    /// <summary>
+    /// The <see cref="IEventSource.TargetStarted"/> callback.
+    /// </summary>
+    private void TargetStarted(object sender, TargetStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (_restoreContext is null && buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
-            float percentage = startedProjects == 0 ? 0.0f : (float)finishedProjects / startedProjects;
-            TerminalBuffer.FooterText = ANSIBuilder.Alignment.SpaceBetween(
-                $"Build progress (approx.) [{ANSIBuilder.Graphics.ProgressBar(percentage)}]",
-                ANSIBuilder.Formatting.Italic(ANSIBuilder.Formatting.Dim("[Up][Down] Scroll")),
-                Console.BufferWidth);
+            project.Stopwatch.Start();
+
+            string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
+            NodeStatus nodeStatus = new(projectFile, project.TargetFramework, e.TargetName, project.Stopwatch);
+            lock (_lock)
+            {
+                _nodes[NodeIndexForContext(buildEventContext)] = nodeStatus;
+            }
         }
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.TargetFinished"/> callback. Unused.
+    /// </summary>
+    private void TargetFinished(object sender, TargetFinishedEventArgs e)
+    {
+    }
 
-        // Build
-        private void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
+    /// <summary>
+    /// The <see cref="IEventSource.TaskStarted"/> callback.
+    /// </summary>
+    private void TaskStarted(object sender, TaskStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (_restoreContext is null && buildEventContext is not null && e.TaskName == "MSBuild")
         {
+            // This will yield the node, so preemptively mark it idle
+            lock (_lock)
+            {
+                _nodes[NodeIndexForContext(buildEventContext)] = null;
+            }
+
+            if (_projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+            {
+                project.Stopwatch.Stop();
+            }
         }
+    }
 
-        private void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+    /// <summary>
+    /// The <see cref="IEventSource.MessageRaised"/> callback.
+    /// </summary>
+    private void MessageRaised(object sender, BuildMessageEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
         {
-            succeeded = e.Succeeded;
+            return;
         }
 
-        // Project
-        private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
+        string? message = e.Message;
+        if (message is not null && e.Importance == MessageImportance.High)
         {
-            startedProjects++;
-
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-
-            // If id does not exist...
-            projects.GetOrAdd(id, (_) =>
+            // Detect project output path by matching high-importance messages against the "$(MSBuildProjectName) -> ..."
+            // pattern used by the CopyFilesToOutputDirectory target.
+            int index = message.IndexOf(" -> ", StringComparison.Ordinal);
+            if (index > 0)
             {
-                // Add project
-                ProjectNode node = new(e)
+                var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());
+                if (!projectFileName.IsEmpty &&
+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&
+                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
                 {
-                    ShouldRerender = true,
-                };
-                UpdateFooter();
-
-                return node;
-            });
+                    ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);
+                    project.OutputPath = outputPath;
+                }
+            }
         }
+    }
 
-        private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
+    /// <summary>
+    /// The <see cref="IEventSource.WarningRaised"/> callback.
+    /// </summary>
+    private void WarningRaised(object sender, BuildWarningEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
+            string message = EventArgsFormatting.FormatEventMessage(e, false);
+            project.AddBuildMessage(MessageSeverity.Warning, $"⚠\uFE0E {message}");
+        }
+    }
 
-            // Update line
-            node.Finished = true;
-            node.ShouldRerender = true;
-            finishedProjects++;
-            UpdateFooter();
+    /// <summary>
+    /// The <see cref="IEventSource.ErrorRaised"/> callback.
+    /// </summary>
+    private void ErrorRaised(object sender, BuildErrorEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
+            string message = EventArgsFormatting.FormatEventMessage(e, false);
+            project.AddBuildMessage(MessageSeverity.Error, $"❌\uFE0E {message}");
         }
+    }
 
-        // Target
-        private void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
+    #endregion
+
+    #region Refresher thread implementation
+
+    /// <summary>
+    /// The <see cref="_refresher"/> thread proc.
+    /// </summary>
+    private void ThreadProc()
+    {
+        while (!_cts.IsCancellationRequested)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
+            Thread.Sleep(1_000 / 30); // poor approx of 30Hz
+
+            lock (_lock)
             {
-                return;
+                DisplayNodes();
             }
-            // Update
-            node.AddTarget(e);
-            // Log
-            node.ShouldRerender = true;
         }
 
-        private void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
+        EraseNodes();
+    }
+
+    /// <summary>
+    /// Render Nodes section.
+    /// It shows what all build nodes do.
+    /// </summary>
+    private void DisplayNodes()
+    {
+        NodesFrame newFrame = new NodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
+
+        // Do not render delta but clear everything if Terminal width or height have changed.
+        if (newFrame.Width != _currentFrame.Width || newFrame.Height != _currentFrame.Height)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.FinishedTargets++;
-            // Log
-            node.ShouldRerender = true;
+            EraseNodes();
         }
 
-        // Task
-        private void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
+        string rendered = newFrame.Render(_currentFrame);
+
+        // Hide the cursor to prevent it from jumping around as we overwrite the live lines.
+        Terminal.Write(AnsiCodes.HideCursor);
+        try
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddTask(e);
-            // Log
-            node.ShouldRerender = true;
+            // Move cursor back to 1st line of nodes.
+            Terminal.WriteLine($"{AnsiCodes.CSI}{_currentFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}");
+            Terminal.Write(rendered);
+        }
+        finally
+        {
+            Terminal.Write(AnsiCodes.ShowCursor);
+        }
 
-            if (e.TaskName.Equals("MSBuild"))
-            {
-                TerminalBufferLine? line = null; // TerminalBuffer.WriteNewLineAfterMidpoint($"{e.ProjectFile} is blocked by the MSBuild task.");
-                if (line is not null)
-                {
-                    blockedProjects[e.ProjectFile] = line.Id;
-                }
-            }
+        _currentFrame = newFrame;
+    }
+
+    /// <summary>
+    /// Erases the previously printed live node output.
+    /// </summary>
+    private void EraseNodes()
+    {
+        if (_currentFrame.NodesCount == 0)
+        {
+            return;
         }
+        Terminal.WriteLine($"{AnsiCodes.CSI}{_currentFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}");
+        Terminal.Write($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
+        _currentFrame.Clear();
+    }
+
+    /// <summary>
+    /// Capture states on nodes to be rendered on display.
+    /// </summary>
+    private sealed class NodesFrame
+    {
+        private readonly List<string> _nodeStrings = new();
+        private readonly StringBuilder _renderBuilder = new();
+
+        public int Width { get; }
+        public int Height { get; }
+        public int NodesCount { get; private set; }
 
-        // Raised messages, warnings and errors
-        private void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
+        public NodesFrame(NodeStatus?[] nodes, int width, int height)
         {
-            if (e is TaskCommandLineEventArgs)
-            {
-                return;
-            }
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddMessage(e);
-            // Log
-            node.ShouldRerender = true;
+            Width = width;
+            Height = height;
+            Init(nodes);
         }
 
-        private void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
+        public string NodeString(int index)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
+            if (index >= NodesCount)
             {
-                return;
+                throw new ArgumentOutOfRangeException(nameof(index));
             }
-            // Update
-            node.AddWarning(e);
-            // Log
-            node.ShouldRerender = true;
+
+            return _nodeStrings[index];
         }
 
-        private void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
+        private void Init(NodeStatus?[] nodes)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
+            int i = 0;
+            foreach (NodeStatus? n in nodes)
             {
-                return;
+                if (n is null)
+                {
+                    continue;
+                }
+                string str = n.ToString();
+
+                if (i < _nodeStrings.Count)
+                {
+                    _nodeStrings[i] = str;
+                }
+                else
+                {
+                    _nodeStrings.Add(str);
+                }
+                i++;
+
+                // We cant output more than what fits on screen
+                // -2 because cursor command F cant reach, in Windows Terminal, very 1st line, and last line is empty caused by very last WriteLine
+                if (i >= Height - 2)
+                {
+                    break;
+                }
             }
-            // Update
-            node.AddError(e);
-            // Log
-            node.ShouldRerender = true;
+
+            NodesCount = i;
         }
 
-        private void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eventArgs)
+        private ReadOnlySpan<char> FitToWidth(ReadOnlySpan<char> input)
         {
-            // Shutdown logger
-            Shutdown();
+            return input.Slice(0, Math.Min(input.Length, Width - 1));
         }
 
-        public void Shutdown()
+        /// <summary>
+        /// Render VT100 string to update from current to next frame.
+        /// </summary>
+        public string Render(NodesFrame previousFrame)
         {
-            TerminalBuffer.Terminate();
-            int errorCount = 0;
-            int warningCount = 0;
-            foreach (var project in projects)
+            StringBuilder sb = _renderBuilder;
+            sb.Clear();
+
+            int i = 0;
+            for (; i < NodesCount; i++)
             {
-                if (project.Value.AdditionalDetails.Count == 0)
+                var needed = FitToWidth(NodeString(i).AsSpan());
+
+                // Do we have previous node string to compare with?
+                if (previousFrame.NodesCount > i)
                 {
-                    continue;
-                }
+                    var previous = FitToWidth(previousFrame.NodeString(i).AsSpan());
 
-                Console.WriteLine(project.Value.ToANSIString());
-                errorCount += project.Value.ErrorCount;
-                warningCount += project.Value.WarningCount;
-                foreach (var message in project.Value.AdditionalDetails)
+                    if (!previous.SequenceEqual(needed))
+                    {
+                        int commonPrefixLen = previous.CommonPrefixLength(needed);
+                        if (commonPrefixLen == 0)
+                        {
+                            // whole string
+                            sb.Append(needed);
+                        }
+                        else
+                        {
+                            // set cursor to different char
+                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
+                            sb.Append(needed.Slice(commonPrefixLen));
+                            // Shall we clear rest of line
+                            if (needed.Length < previous.Length)
+                            {
+                                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
+                            }
+                        }
+                    }
+                }
+                else
                 {
-                    Console.WriteLine($"    └── {message.ToANSIString()}");
+                    // From now on we have to simply WriteLine
+                    sb.Append(needed);
                 }
-                Console.WriteLine();
+
+                // Next line
+                sb.AppendLine();
+            }
+
+            // clear no longer used lines
+            if (i < previousFrame.NodesCount)
+            {
+                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
             }
 
-            // Empty line
-            Console.WriteLine();
+            return sb.ToString();
+        }
 
-            Debug.Assert(_stopwatch is not null, $"Expected {nameof(_stopwatch)} to be initialized long before Shutdown()");
-            TimeSpan buildDuration = _stopwatch!.Elapsed;
+        public void Clear()
+        {
+            NodesCount = 0;
+        }
+    }
 
-            string prettyDuration = buildDuration.TotalHours > 1.0 ?
-                buildDuration.ToString(@"h\:mm\:ss") :
-                buildDuration.ToString(@"m\:ss");
+    #endregion
 
-            string status = succeeded ?
-                ANSIBuilder.Formatting.Color("succeeded", ANSIBuilder.Formatting.ForegroundColor.Green) :
-                ANSIBuilder.Formatting.Color("failed", ANSIBuilder.Formatting.ForegroundColor.Red);
+    #region Helpers
 
-            Console.WriteLine($"Build {status} in {prettyDuration}");
-            Console.WriteLine($"\t{warningCount} Warnings(s)");
-            Console.WriteLine($"\t{errorCount} Errors(s)");
-            Console.WriteLine();
+    /// <summary>
+    /// Print a build result summary to the output.
+    /// </summary>
+    /// <param name="succeeded">True if the build completed with success.</param>
+    /// <param name="hasError">True if the build has logged at least one error.</param>
+    /// <param name="hasWarning">True if the build has logged at least one warning.</param>
+    private void PrintBuildResult(bool succeeded, bool hasError, bool hasWarning)
+    {
+        if (!succeeded)
+        {
+            // If the build failed, we print one of three red strings.
+            string text = (hasError, hasWarning) switch
+            {
+                (true, _) => "failed with errors",
+                (false, true) => "failed with warnings",
+                _ => "failed",
+            };
+            Terminal.WriteColor(TerminalColor.Red, text);
+        }
+        else if (hasWarning)
+        {
+            Terminal.WriteColor(TerminalColor.Yellow, "succeeded with warnings");
         }
+        else
+        {
+            Terminal.WriteColor(TerminalColor.Green, "succeeded");
+        }
+    }
+
+    /// <summary>
+    /// Returns the <see cref="_nodes"/> index corresponding to the given <see cref="BuildEventContext"/>.
+    /// </summary>
+    private int NodeIndexForContext(BuildEventContext context)
+    {
+        // Node IDs reported by the build are 1-based.
+        return context.NodeId - 1;
     }
+
+    #endregion
 }
diff --git a/src/MSBuild/LiveLogger/MessageNode.cs b/src/MSBuild/LiveLogger/MessageNode.cs
deleted file mode 100644
index 7d6029e041d..00000000000
--- a/src/MSBuild/LiveLogger/MessageNode.cs
+++ /dev/null
@@ -1,103 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class MessageNode
-    {
-        // Use this to change the max lenngth (relative to screen size) of messages
-        private static int MAX_LENGTH = 3 * Console.BufferWidth;
-        public enum MessageType
-        {
-            HighPriorityMessage,
-            Warning,
-            Error,
-            ProjectOutputMessage
-        }
-        public string Message;
-        public TerminalBufferLine? Line;
-        public MessageType Type;
-        public string? Code;
-        public string? FilePath;
-        public int? LineNumber;
-        public int? ColumnNumber;
-        public string? ProjectOutputExecutablePath;
-        public MessageNode(LazyFormattedBuildEventArgs args)
-        {
-            Message = args.Message ?? string.Empty;
-            if (Message.Length > MAX_LENGTH)
-            {
-                Message = Message.Substring(0, MAX_LENGTH - 1) + "…";
-            }
-            // Get type
-            switch (args)
-            {
-                case BuildMessageEventArgs message:
-                    // Detect output messages
-                    var finalOutputMarker = " -> ";
-                    int i = message.Message!.IndexOf(finalOutputMarker, StringComparison.Ordinal);
-                    if (i > 0)
-                    {
-                        Type = MessageType.ProjectOutputMessage;
-                        ProjectOutputExecutablePath = message.Message!.Substring(i + finalOutputMarker.Length);
-                    }
-                    else
-                    {
-                        Type = MessageType.HighPriorityMessage;
-                        Code = message.Subcategory;
-                    }
-                    break;
-                case BuildWarningEventArgs warning:
-                    Type = MessageType.Warning;
-                    Code = warning.Code;
-                    FilePath = warning.File;
-                    LineNumber = warning.LineNumber;
-                    ColumnNumber = warning.ColumnNumber;
-                    break;
-                case BuildErrorEventArgs error:
-                    Type = MessageType.Error;
-                    Code = error.Code;
-                    FilePath = error.File;
-                    LineNumber = error.LineNumber;
-                    ColumnNumber = error.ColumnNumber;
-                    break;
-            }
-        }
-
-        public string ToANSIString()
-        {
-            switch (Type)
-            {
-                case MessageType.Warning:
-                    return $"⚠️ {ANSIBuilder.Formatting.Color(
-                        $"Warning {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
-                        ANSIBuilder.Formatting.ForegroundColor.Yellow)}";
-                case MessageType.Error:
-                    return $"❌ {ANSIBuilder.Formatting.Color(
-                        $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
-                        ANSIBuilder.Formatting.ForegroundColor.Red)}";
-                case MessageType.ProjectOutputMessage:
-                    return $"⚙️ {ANSIBuilder.Formatting.Hyperlink(ProjectOutputExecutablePath!, Path.GetDirectoryName(ProjectOutputExecutablePath)!)}";
-                case MessageType.HighPriorityMessage:
-                default:
-                    return $"ℹ️ {Code}{(Code is not null ? ": " : string.Empty)} {ANSIBuilder.Formatting.Italic(Message)}";
-            }
-        }
-
-        // TODO: Rename to Log after LiveLogger's API becomes internal
-        public void Log()
-        {
-            if (Line == null)
-            {
-                return;
-            }
-
-            Line.Text = $"    └── {ToANSIString()}";
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/MessageSeverity.cs b/src/MSBuild/LiveLogger/MessageSeverity.cs
new file mode 100644
index 00000000000..4b63a7317b2
--- /dev/null
+++ b/src/MSBuild/LiveLogger/MessageSeverity.cs
@@ -0,0 +1,9 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Enumerates the supported message severities.
+/// </summary>
+internal enum MessageSeverity { Warning, Error }
diff --git a/src/MSBuild/LiveLogger/Project.cs b/src/MSBuild/LiveLogger/Project.cs
new file mode 100644
index 00000000000..d5c414907b4
--- /dev/null
+++ b/src/MSBuild/LiveLogger/Project.cs
@@ -0,0 +1,52 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Represents a project being built.
+/// </summary>
+internal sealed class Project
+{
+    /// <summary>
+    /// Initialized a new <see cref="Project"/> with the given <paramref name="targetFramework"/>.
+    /// </summary>
+    /// <param name="targetFramework">The target framework of the project or null if not multi-targeting.</param>
+    public Project(string? targetFramework)
+    {
+        TargetFramework = targetFramework;
+    }
+
+    /// <summary>
+    /// A stopwatch to time the build of the project.
+    /// </summary>
+    public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();
+
+    /// <summary>
+    /// Full path to the primary output of the project, if known.
+    /// </summary>
+    public ReadOnlyMemory<char>? OutputPath { get; set; }
+
+    /// <summary>
+    /// The target framework of the project or null if not multi-targeting.
+    /// </summary>
+    public string? TargetFramework { get; }
+
+    /// <summary>
+    /// A lazily initialized list of build messages/warnings/errors raised during the build.
+    /// </summary>
+    public List<BuildMessage>? BuildMessages { get; private set; }
+
+    /// <summary>
+    /// Adds a build message of the given severity to <see cref="BuildMessages"/>.
+    /// </summary>
+    public void AddBuildMessage(MessageSeverity severity, string message)
+    {
+        BuildMessages ??= new List<BuildMessage>();
+        BuildMessages.Add(new BuildMessage(severity, message));
+    }
+}
diff --git a/src/MSBuild/LiveLogger/ProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
deleted file mode 100644
index 9561ead1647..00000000000
--- a/src/MSBuild/LiveLogger/ProjectNode.cs
+++ /dev/null
@@ -1,233 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal class ProjectNode
-    {
-        /// <summary>
-        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
-        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
-        /// Still work in progress...
-        /// </summary>
-        private static string GetUnambiguousPath(string path)
-        {
-            return Path.GetFileName(path);
-        }
-
-        public int Id;
-        public string ProjectPath;
-        public string TargetFramework;
-        public bool Finished;
-        public string? ProjectOutputExecutable;
-        // Line to display project info
-        public TerminalBufferLine? Line;
-        // Targets
-        public int FinishedTargets;
-        public TerminalBufferLine? CurrentTargetLine;
-        public TargetNode? CurrentTargetNode;
-        // Messages, errors and warnings
-        public List<MessageNode> AdditionalDetails = new();
-        // Count messages, warnings and errors
-        public int MessageCount = 0;
-        public int WarningCount = 0;
-        public int ErrorCount = 0;
-        // Bool if node should rerender
-        internal bool ShouldRerender = true;
-        public ProjectNode(ProjectStartedEventArgs args)
-        {
-            Id = args.ProjectId;
-            ProjectPath = args.ProjectFile!;
-            Finished = false;
-            FinishedTargets = 0;
-            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
-            {
-                TargetFramework = args.GlobalProperties["TargetFramework"];
-            }
-            else
-            {
-                TargetFramework = "";
-            }
-        }
-
-        public string ToANSIString()
-        {
-            ANSIBuilder.Formatting.ForegroundColor color = ANSIBuilder.Formatting.ForegroundColor.Default;
-            string icon = ANSIBuilder.Graphics.Spinner() + " ";
-
-            if (Finished && WarningCount + ErrorCount == 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Green;
-                icon = "✓";
-            }
-            else if (ErrorCount > 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Red;
-                icon = "X";
-            }
-            else if (WarningCount > 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Yellow;
-                icon = "✓";
-            }
-            return icon + " " + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), color) + " " + ANSIBuilder.Formatting.Inverse(TargetFramework);
-        }
-
-        // TODO: Rename to Render() after LiveLogger's API becomes internal
-        public void Log()
-        {
-            if (!ShouldRerender)
-            {
-                return;
-            }
-
-            ShouldRerender = false;
-            // Project details
-            string lineContents = ANSIBuilder.Alignment.SpaceBetween(ToANSIString(), $"({MessageCount} ℹ️, {WarningCount} ⚠️, {ErrorCount} ❌)", Console.BufferWidth - 1);
-            // Create or update line
-            if (Line is null)
-            {
-                Line = TerminalBuffer.WriteNewLineBeforeMidpoint(lineContents, false);
-            }
-            else
-            {
-                Line.Text = lineContents;
-            }
-
-            // For finished projects
-            if (Finished)
-            {
-                if (CurrentTargetLine is not null)
-                {
-                    TerminalBuffer.DeleteLine(CurrentTargetLine.Id);
-                }
-
-                bool foundErrorOrWarning = false;
-
-                foreach (MessageNode node in AdditionalDetails)
-                {
-                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
-                    {
-                        foundErrorOrWarning = true;
-                    }
-
-                    // Only delete high priority messages
-                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
-                    {
-                        continue;
-                    }
-
-                    if (node.Line is not null)
-                    {
-                        TerminalBuffer.DeleteLine(node.Line.Id);
-                    }
-                }
-
-                if (!foundErrorOrWarning && this.Line is not null)
-                {
-                    foreach (MessageNode node in AdditionalDetails)
-                    {
-                        int? id = node.Line?.Id;
-                        if (id is not null)
-                        {
-                            TerminalBuffer.DeleteLine(id.Value);
-                        }
-                    }
-
-                    TerminalBuffer.DeleteLine(this.Line.Id);
-                }
-            }
-
-            // Current target details
-            if (CurrentTargetNode is null)
-            {
-                return;
-            }
-
-            string currentTargetLineContents = $"    └── {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
-            if (CurrentTargetLine is null)
-            {
-                CurrentTargetLine = TerminalBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
-            }
-            else
-            {
-                CurrentTargetLine.Text = currentTargetLineContents;
-            }
-
-            // Messages, warnings and errors
-            foreach (MessageNode node in AdditionalDetails)
-            {
-                if (Finished && node.Type == MessageNode.MessageType.HighPriorityMessage)
-                {
-                    continue;
-                }
-
-                if (node.Line is null)
-                {
-                    node.Line = TerminalBuffer.WriteNewLineAfter(Line!.Id, "Message");
-                }
-
-                node.Log();
-            }
-        }
-
-        public TargetNode AddTarget(TargetStartedEventArgs args)
-        {
-            CurrentTargetNode = new TargetNode(args);
-            return CurrentTargetNode;
-        }
-        public TaskNode? AddTask(TaskStartedEventArgs args)
-        {
-            // Get target id
-            int targetId = args.BuildEventContext!.TargetId;
-            if (CurrentTargetNode?.Id == targetId)
-            {
-                return CurrentTargetNode.AddTask(args);
-            }
-            else
-            {
-                return null;
-            }
-        }
-        public MessageNode? AddMessage(BuildMessageEventArgs args)
-        {
-            if (args.Importance != MessageImportance.High)
-            {
-                return null;
-            }
-
-            MessageCount++;
-            MessageNode node = new MessageNode(args);
-            // Add output executable path
-            if (node.ProjectOutputExecutablePath is not null)
-            {
-                ProjectOutputExecutable = node.ProjectOutputExecutablePath;
-            }
-
-            AdditionalDetails.Add(node);
-            return node;
-        }
-        public MessageNode? AddWarning(BuildWarningEventArgs args)
-        {
-            WarningCount++;
-            MessageNode node = new MessageNode(args);
-            AdditionalDetails.Add(node);
-            TerminalBuffer.overallBuildState = TerminalBuffer.overallBuildState == OverallBuildState.Error ? OverallBuildState.Error : OverallBuildState.Warning;
-            return node;
-        }
-        public MessageNode? AddError(BuildErrorEventArgs args)
-        {
-            ErrorCount++;
-            MessageNode node = new MessageNode(args);
-            AdditionalDetails.Add(node);
-            TerminalBuffer.overallBuildState = OverallBuildState.Error;
-            return node;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TargetNode.cs b/src/MSBuild/LiveLogger/TargetNode.cs
deleted file mode 100644
index 06d61dd431a..00000000000
--- a/src/MSBuild/LiveLogger/TargetNode.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class TargetNode
-    {
-        public int Id;
-        public string TargetName;
-        public TaskNode? CurrentTaskNode;
-        public TargetNode(TargetStartedEventArgs args)
-        {
-            Id = args.BuildEventContext!.TargetId;
-            TargetName = args.TargetName;
-        }
-        public TaskNode AddTask(TaskStartedEventArgs args)
-        {
-            CurrentTaskNode = new TaskNode(args);
-            return CurrentTaskNode;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TaskNode.cs b/src/MSBuild/LiveLogger/TaskNode.cs
deleted file mode 100644
index 4e8d8118675..00000000000
--- a/src/MSBuild/LiveLogger/TaskNode.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class TaskNode
-    {
-        public int Id;
-        public string TaskName;
-        public TaskNode(TaskStartedEventArgs args)
-        {
-            Id = args.BuildEventContext!.TaskId;
-            TaskName = args.TaskName;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/Terminal.cs b/src/MSBuild/LiveLogger/Terminal.cs
new file mode 100644
index 00000000000..9b187391778
--- /dev/null
+++ b/src/MSBuild/LiveLogger/Terminal.cs
@@ -0,0 +1,158 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Text;
+#if NETFRAMEWORK
+using Microsoft.Build.Shared;
+#endif
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// An <see cref="ITerminal"/> implementation for ANSI/VT100 terminals.
+/// </summary>
+internal sealed class Terminal : ITerminal
+{
+    /// <summary>
+    /// The encoding read from <see cref="Console.OutputEncoding"/> when the terminal is instantiated.
+    /// </summary>
+    private readonly Encoding _originalOutputEncoding;
+
+    /// <summary>
+    /// A string buffer used with <see cref="BeginUpdate"/>/<see cref="EndUpdate"/>.
+    /// </summary>
+    private readonly StringBuilder _outputBuilder = new();
+
+    /// <summary>
+    /// True if <see cref="BeginUpdate"/> was called and <c>Write*</c> methods are buffering instead of directly printing.
+    /// </summary>
+    private bool _isBuffering = false;
+
+    /// <inheritdoc/>
+    public int Height => Console.BufferHeight;
+
+    /// <inheritdoc/>
+    public int Width => Console.BufferWidth;
+
+    public Terminal()
+    {
+        _originalOutputEncoding = Console.OutputEncoding;
+        Console.OutputEncoding = Encoding.UTF8;
+    }
+
+    /// <inheritdoc/>
+    public void BeginUpdate()
+    {
+        if (_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = true;
+    }
+
+    /// <inheritdoc/>
+    public void EndUpdate()
+    {
+        if (!_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = false;
+
+        Console.Write(_outputBuilder.ToString());
+        _outputBuilder.Clear();
+    }
+
+    /// <inheritdoc/>
+    public void Write(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+        }
+        else
+        {
+            Console.Write(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Write(ReadOnlySpan<char> text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+        }
+        else
+        {
+            Console.Out.Write(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLine(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.AppendLine(text);
+        }
+        else
+        {
+            Console.WriteLine(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLineFitToWidth(ReadOnlySpan<char> text)
+    {
+        ReadOnlySpan<char> truncatedText = text.Slice(0, Math.Min(text.Length, Width - 1));
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(truncatedText);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            Console.Out.WriteLine(truncatedText);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteColor(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder
+                .Append(AnsiCodes.CSI)
+                .Append((int)color)
+                .Append(AnsiCodes.SetColor)
+                .Append(text)
+                .Append(AnsiCodes.SetDefaultColor);
+        }
+        else
+        {
+            Write($"{AnsiCodes.CSI}{(int)color}{AnsiCodes.SetColor}{text}{AnsiCodes.SetDefaultColor}");
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteColorLine(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            WriteColor(color, text);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            WriteLine($"{AnsiCodes.CSI}{(int)color}{AnsiCodes.SetColor}{text}{AnsiCodes.SetDefaultColor}");
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Dispose()
+    {
+        Console.OutputEncoding = _originalOutputEncoding;
+    }
+}
diff --git a/src/MSBuild/LiveLogger/TerminalBuffer.cs b/src/MSBuild/LiveLogger/TerminalBuffer.cs
deleted file mode 100644
index d58b42c7689..00000000000
--- a/src/MSBuild/LiveLogger/TerminalBuffer.cs
+++ /dev/null
@@ -1,295 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Runtime.CompilerServices;
-using System.Text;
-using static System.Net.Mime.MediaTypeNames;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal class TerminalBufferLine
-    {
-        private static int Counter = 0;
-        private string _text = string.Empty;
-        public List<string> WrappedText { get; private set; } = new();
-        public int Id;
-        public bool ShouldWrapLines;
-        public string Text
-        {
-            get => _text;
-            set
-            {
-                // Set text value and get wrapped lines
-                _text = value;
-                if (ShouldWrapLines)
-                {
-                    WrappedText = ANSIBuilder.ANSIWrap(value, Console.BufferWidth);
-                }
-                else
-                {
-                    WrappedText = new List<string> { value };
-                }
-                // Buffer should rerender
-                TerminalBuffer.ShouldRerender = true;
-            }
-        }
-
-        public TerminalBufferLine()
-        {
-            Id = Counter++;
-            Text = string.Empty;
-            ShouldWrapLines = false;
-        }
-        public TerminalBufferLine(string text)
-            : this()
-        {
-            Text = text;
-        }
-        public TerminalBufferLine(string text, bool shouldWrapLines)
-            : this()
-        {
-            ShouldWrapLines = shouldWrapLines;
-            Text = text;
-        }
-    }
-
-    internal class TerminalBuffer
-    {
-        private const char errorSymbol = '❌';
-        private const char warningSymbol = '⚠';
-        private static List<TerminalBufferLine> Lines = new();
-        public static string FooterText = string.Empty;
-        public static int TopLineIndex = 0;
-        public static string Footer = string.Empty;
-        internal static bool IsTerminated = false;
-        internal static bool ShouldRerender = true;
-        internal static OverallBuildState overallBuildState = OverallBuildState.None;
-        internal static int FinishedProjects = 0;
-        private static int midLineId;
-        internal static int ScrollableAreaHeight
-        {
-            get
-            {
-                // Height of the buffer -3 (titlebar, footer, and footer line)
-                return Console.BufferHeight - 3;
-            }
-        }
-        public static void Initialize()
-        {
-            // Configure buffer, encoding and cursor
-            Console.OutputEncoding = Encoding.UTF8;
-            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
-            Console.Write(ANSIBuilder.Cursor.Invisible());
-            // TerminalBufferLine midLine = new(new string('-', Console.BufferWidth), true);
-            // WriteNewLine(midLine);
-            // midLineId = midLine.Id;
-            midLineId = -1;
-        }
-
-        public static void Terminate()
-        {
-            IsTerminated = true;
-            // Delete contents from alternate buffer before switching back to main buffer
-            Console.Write(
-                ANSIBuilder.Cursor.Home() +
-                ANSIBuilder.Eraser.DisplayCursorToEnd());
-            // Reset configuration for buffer and cursor, and clear screen
-            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            Console.Write(ANSIBuilder.Cursor.Visible());
-            Lines = new();
-        }
-
-        #region Rendering
-        public static void Render()
-        {
-            if (IsTerminated || !ShouldRerender)
-            {
-                return;
-            }
-
-            ShouldRerender = false;
-            ANSIBuilder.Formatting.ForegroundColor desiredColor =
-                overallBuildState == OverallBuildState.Error ? ANSIBuilder.Formatting.ForegroundColor.Red :
-                overallBuildState == OverallBuildState.Warning ? ANSIBuilder.Formatting.ForegroundColor.Yellow :
-                ANSIBuilder.Formatting.ForegroundColor.White;
-
-            string text = $"MSBuild - Build in progress - {FinishedProjects} finished projects";
-            text =
-                overallBuildState == OverallBuildState.Error ? $"{errorSymbol} {text} {errorSymbol}" :
-                overallBuildState == OverallBuildState.Warning ? $"{warningSymbol} {text} {warningSymbol}" :
-                text;
-
-            Console.Write(
-                // Write header
-                ANSIBuilder.Cursor.Home() +
-                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center(text)), ANSIBuilder.Formatting.BackgroundColor.Black, desiredColor) +
-                // Write footer
-                ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
-                    ANSIBuilder.Eraser.LineCursorToEnd() +
-                    new string('-', Console.BufferWidth) +
-                    Environment.NewLine +
-                    FooterText);
-
-            if (Lines.Count == 0)
-            {
-                return;
-            }
-
-            // Iterate over lines and display on terminal
-            string contents = string.Empty;
-            int accumulatedLineCount = 0;
-            int lineIndex = 0;
-            foreach (TerminalBufferLine line in Lines)
-            {
-                // Continue if accum line count + next lines < scrolling area
-                if (accumulatedLineCount + line.WrappedText.Count < TopLineIndex)
-                {
-                    accumulatedLineCount += line.WrappedText.Count;
-                    continue;
-                }
-
-                // Break if exceeds scrolling area
-                if (accumulatedLineCount - TopLineIndex > ScrollableAreaHeight)
-                {
-                    break;
-                }
-
-                foreach (string s in line.WrappedText)
-                {
-                    // Get line index relative to scroll area
-                    lineIndex = accumulatedLineCount - TopLineIndex;
-                    // Print if line in scrolling area
-                    if (lineIndex >= 0 && lineIndex < ScrollableAreaHeight)
-                    {
-                        contents += ANSIBuilder.Cursor.Position(lineIndex + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd() + s;
-                    }
-
-                    accumulatedLineCount++;
-                }
-            }
-            // Iterate for the rest of the screen
-            for (int i = lineIndex + 1; i < ScrollableAreaHeight; i++)
-            {
-                contents += ANSIBuilder.Cursor.Position(i + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd();
-            }
-            Console.Write(contents);
-        }
-        #endregion
-
-        #region Line identification
-        public static int GetLineIndexById(int lineId)
-        {
-            return Lines.FindIndex(x => x.Id == lineId);
-        }
-
-        public static TerminalBufferLine? GetLineById(int lineId)
-        {
-            int index = GetLineIndexById(lineId);
-            if (index == -1)
-            {
-                return null;
-            }
-
-            return Lines[index];
-        }
-        #endregion
-
-        #region Line create, update and delete
-        // Write new line
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text)
-        {
-            return WriteNewLineAfter(lineId, text, true);
-        }
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
-            return WriteNewLineAfter(lineId, line);
-        }
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, TerminalBufferLine line)
-        {
-            if (lineId != -1)
-            {
-                // Get line index
-                int lineIndex = GetLineIndexById(lineId);
-                if (lineIndex == -1)
-                {
-                    return null;
-                }
-                // Get line end index
-                Lines.Insert(lineIndex + 1, line);
-            }
-            else
-            {
-                Lines.Add(line);
-            }
-            return line;
-        }
-
-        public static TerminalBufferLine? WriteNewLineAfterMidpoint(string text, bool shouldWrapLines = false)
-        {
-            TerminalBufferLine line = new(text, shouldWrapLines);
-            return WriteNewLineAfter(midLineId, line);
-        }
-
-        public static TerminalBufferLine? WriteNewLineBeforeMidpoint(string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new(text, shouldWrapLines);
-            int lineIndex = GetLineIndexById(midLineId);
-            if (lineIndex == -1)
-            {
-                WriteNewLine(line);
-                return null;
-            }
-
-            Lines.Insert(lineIndex, line);
-
-            return line;
-        }
-
-        public static TerminalBufferLine? WriteNewLine(string text)
-        {
-            return WriteNewLine(text, true);
-        }
-        public static TerminalBufferLine? WriteNewLine(string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
-            return WriteNewLine(line);
-        }
-        public static TerminalBufferLine? WriteNewLine(TerminalBufferLine line)
-        {
-            return WriteNewLineAfter(Lines.Count > 0 ? Lines.Last().Id : -1, line);
-        }
-
-        // Update line
-        // TODO: Remove. Use line.Text instead
-        public static TerminalBufferLine? UpdateLine(int lineId, string text)
-        {
-            return null;
-        }
-
-        // Delete line
-        public static void DeleteLine(int lineId)
-        {
-            // Get line index
-            int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1)
-            {
-                return;
-            }
-            // Delete
-            Lines.RemoveAt(lineIndex);
-            ShouldRerender = true;
-        }
-        #endregion
-    }
-
-    internal enum OverallBuildState
-    {
-        None,
-        Warning,
-        Error,
-    }
-}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 345d27ecf51..2e320bdfc9a 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -156,6 +156,7 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
+    <Compile Include="..\Shared\StringExtensions.cs" />
     <Compile Include="AssemblyInfo.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 404db97ec3a..679f83d8d36 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1348,9 +1348,6 @@
   <data name="MSBuildDebugPath" Visibility="Public">
     <value>MSBuild logs and debug information will be at "{0}"</value>
   </data>
-  <data name="DeferredResponseFile" Visibility="Public">
-    <value>Included response file: {0}</value>
-  </data>
   <data name="SwitchErrorWithArguments" Visibility="Public">
     <value>{0}
     Full command line: '{1}'
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 5a648966672..db244d38b7f 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: Přepínač -noAutoResponse nelze zadat v souboru automatických odpovědí MSBuild.rsp ani v žádném jiném souboru odpovědí, na který se v souboru automatických odpovědí odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 4ab57937b4c..48a5797486c 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 4871d1f9a7c..bb62e3d2cb3 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta automática MSBuild.rsp ni en ningún archivo de respuesta al que el archivo de respuesta automática haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 67ae1d3883e..c0367b98145 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de spécifier le commutateur -noAutoResponse dans le fichier réponse automatique MSBuild.rsp, ni dans aucun autre fichier réponse référencé par le fichier réponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 8175525c4ef..69fdd84340c 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: non è possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 05e50c2172a..a5be53ec818 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 自動応答ファイルや、自動応答ファイルによって参照される応答ファイルに -noAutoResponse スイッチを指定することはできません。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index e6481c46726..1301551dbbf 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 자동 지시 파일과 자동 지시 파일에서 참조하는 모든 지시 파일에는 -noAutoResponse 스위치를 지정할 수 없습니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index f269e5729e4..ad89de51e2e 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: przełącznika -noAutoResponse nie można określić w pliku autoodpowiedzi MSBuild.rsp ani w żadnym pliku odpowiedzi, do którego odwołuje się plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index cead4b3c72d..6748b6a2266 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: A opção /noAutoResponse não pode ser especificada no arquivo de resposta automática MSBuild.rsp nem em qualquer arquivo de resposta usado como referência para o arquivo de resposta automática.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 967760d2803..cc0e700b31a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: ключ noAutoResponse не может быть указан в файле автоответа MSBuild.rsp или в любом другом файле ответа, на который файл автоответа ссылается.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 8ac625e24d7..1b5386bf3fd 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarı, MSBuild.rsp otomatik yanıt dosyasında ve bu dosyanın başvuruda bulunduğu herhangi bir yanıt dosyasında belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 8d3e40eec32..49cea80b9e3 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: 不能在 MSBuild.rsp 自动响应文件中或由该自动响应文件引用的任何响应文件中指定 -noAutoResponse 开关。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b297cd0ef3a..b44006c9790 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -28,11 +28,6 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse 參數不能在 MSBuild.rsp 自動回應檔中指定，也不能在自動回應檔所參考的任何回應檔中指定。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DeferredResponseFile">
-        <source>Included response file: {0}</source>
-        <target state="new">Included response file: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 11afd473017..0d0fa710bd2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -34,12 +34,11 @@
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
+using LiveLogger = Microsoft.Build.Logging.LiveLogger.LiveLogger;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Logging.LiveLogger;
-using System.Runtime.InteropServices;
 
 #nullable disable
 
@@ -967,6 +966,8 @@ public static ExitType Execute(
                 // Wait for any pending cancel, so that we get any remaining messages
                 s_cancelComplete.WaitOne();
 
+                NativeMethodsShared.RestoreConsoleMode(s_originalConsoleMode);
+
 #if FEATURE_GET_COMMANDLINE
                 MSBuildEventSource.Log.MSBuildExeStop(commandLine);
 #else
@@ -1092,7 +1093,12 @@ private static void ResetGatheringSwitchesState()
         /// <summary>
         /// List of messages to be sent to the logger when it is attached
         /// </summary>
-        private static List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+        private static readonly List<BuildManager.DeferredBuildMessage> s_globalMessagesToLogInBuildLoggers = new();
+
+        /// <summary>
+        /// The original console output mode if we changed it as part of initialization.
+        /// </summary>
+        private static uint? s_originalConsoleMode = null;
 
         /// <summary>
         /// Initializes the build engine, and starts the project building.
@@ -1348,6 +1354,8 @@ internal static bool BuildProject(
                         }
                     }
 
+                    List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
                     BuildResultCode? result = null;
@@ -1368,7 +1376,7 @@ internal static bool BuildProject(
                             messagesToLogInBuildLoggers.Add(
                                 new BuildManager.DeferredBuildMessage(
                                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                                        "DeferredResponseFile",
+                                        "PickedUpSwitchesFromAutoResponse",
                                         responseFilePath),
                                     MessageImportance.Low,
                                     responseFilePath));
@@ -1529,7 +1537,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
 
         private static List<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
         {
-            List<BuildManager.DeferredBuildMessage> messages = new()
+            List<BuildManager.DeferredBuildMessage> messages = new(s_globalMessagesToLogInBuildLoggers)
             {
                 new BuildManager.DeferredBuildMessage(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
@@ -2430,6 +2438,7 @@ private static bool ProcessCommandLineSwitches(
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
 
+                    bool liveLogger = ProcessLiveLoggerConfiguration(commandLineSwitches);
 
                     // figure out which loggers are going to listen to build events
                     string[][] groupedFileLoggerParameters = commandLineSwitches.GetFileLoggerParameters();
@@ -2440,7 +2449,7 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.LiveLogger],
+                        liveLogger,
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -2468,16 +2477,6 @@ private static bool ProcessCommandLineSwitches(
                         detailedSummary = true;
                     }
 
-                    // If we picked up switches from the autoresponse file, let the user know. This could be a useful
-                    // hint to a user that does not know that we are picking up the file automatically.
-                    // Since this is going to happen often in normal use, only log it in high verbosity mode.
-                    // Also, only log it to the console; logging to loggers would involve increasing the public API of
-                    // the Engine, and we don't want to do that.
-                    if (usingSwitchesFromAutoResponseFile && LoggerVerbosity.Diagnostic == verbosity)
-                    {
-                        Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("PickedUpSwitchesFromAutoResponse", autoResponseFileName));
-                    }
-
                     if (originalVerbosity == LoggerVerbosity.Diagnostic)
                     {
                         string equivalentCommandLine = commandLineSwitches.GetEquivalentCommandLineExceptProjectFile();
@@ -2507,6 +2506,75 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
+        private static bool ProcessLiveLoggerConfiguration(CommandLineSwitches commandLineSwitches)
+        {
+            string liveLoggerArg;
+
+            // Command line wins, so check it first
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LiveLogger))
+            {
+                // There's a switch set, but there might be more than one
+                string[] switches = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LiveLogger];
+
+                liveLoggerArg = switches[switches.Length - 1];
+
+                // if the switch was set but not to an explicit value, the value is "auto"
+                if (string.IsNullOrEmpty(liveLoggerArg))
+                {
+                    liveLoggerArg = "auto";
+                }
+            }
+            else
+            {
+                liveLoggerArg = Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER");
+
+                if (string.IsNullOrWhiteSpace(liveLoggerArg))
+                {
+                    return false;
+                }
+                else
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDLIVELOGGER was set to {liveLoggerArg}.", MessageImportance.Low));
+                }
+            }
+
+            // We now have a string. It can be "true" or "false" which means just that:
+            if (bool.TryParse(liveLoggerArg, out bool result))
+            {
+                return result;
+            }
+
+            // or it can be "auto", meaning "enable if we can"
+            if (!liveLoggerArg.Equals("auto", StringComparison.OrdinalIgnoreCase))
+            {
+                CommandLineSwitchException.Throw("InvalidLiveLoggerValue", liveLoggerArg);
+            }
+
+            return DoesEnvironmentSupportLiveLogger();
+
+            static bool DoesEnvironmentSupportLiveLogger()
+            {
+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+
+                if (!outputIsScreen)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
+                    return false;
+                }
+
+                // LiveLogger is not used if the terminal does not support ANSI/VT100 escape sequences.
+                if (!acceptAnsiColorCodes)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
+                    return false;
+                }
+                return true;
+            }
+        }
+
         private static CommandLineSwitches CombineSwitchesRespectingPriority(CommandLineSwitches switchesFromAutoResponseFile, CommandLineSwitches switchesNotFromAutoResponseFile, string commandLine)
         {
             // combine the auto-response file switches with the command line switches in a left-to-right manner, where the
@@ -3254,7 +3322,7 @@ private static ILogger[] ProcessLoggingSwitches(
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
-            bool liveLoggerCommandLineOptIn,
+            bool liveLoggerOptIn,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3288,9 +3356,7 @@ private static ILogger[] ProcessLoggingSwitches(
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
             // Choose default console logger
-            if (
-                (liveLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true" || Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER") == "true")
-                && DoesEnvironmentSupportLiveLogger())
+            if (liveLoggerOptIn)
             {
                 ProcessLiveLogger(noConsoleLogger, distributedLoggerRecords, cpuCount, loggers);
             }
@@ -3303,9 +3369,6 @@ private static ILogger[] ProcessLoggingSwitches(
 
             ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
 
-            // TOOD: Review
-            // ProcessLiveLogger(noConsoleLogger, loggers);
-
             verbosity = outVerbosity;
 
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
@@ -3471,27 +3534,6 @@ internal static void ProcessConsoleLoggerSwitch(
             }
         }
 
-        private static bool DoesEnvironmentSupportLiveLogger()
-        {
-            // If output is redirected
-            if (Console.IsOutputRedirected)
-            {
-                messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
-                return false;
-            }
-            // If terminal is dumb
-            if (
-                (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && string.IsNullOrEmpty(Environment.GetEnvironmentVariable("WT_SESSION")))
-                || Environment.GetEnvironmentVariable("TERM") == "dumb")
-            {
-                messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
-                return false;
-            }
-            return true;
-        }
-
         private static void ProcessLiveLogger(
             bool noConsoleLogger,
             List<DistributedLoggerRecord> distributedLoggerRecords,
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 36613d4cd52..0da65b8a868 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -796,7 +796,7 @@ private struct RecursionState
             /// <summary>
             /// True if a SearchData.DirectoryPattern is specified but we have not descended into a matching directory.
             /// </summary>
-            public bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
+            public readonly bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
         }
 
         /// <summary>
diff --git a/src/Shared/FileSystem/WindowsNative.cs b/src/Shared/FileSystem/WindowsNative.cs
index 63640a185be..8df4a0b2a2c 100644
--- a/src/Shared/FileSystem/WindowsNative.cs
+++ b/src/Shared/FileSystem/WindowsNative.cs
@@ -141,7 +141,7 @@ public EnumerateDirectoryResult(string directory, EnumerateDirectoryStatus statu
             /// <summary>
             /// Indicates if enumeration succeeded.
             /// </summary>
-            public bool Succeeded
+            public readonly bool Succeeded
             {
                 get { return Status == EnumerateDirectoryStatus.Success; }
             }
@@ -153,7 +153,7 @@ public bool Succeeded
             /// <remarks>
             /// This is a good <c>default:</c> case when switching on every possible <see cref="EnumerateDirectoryStatus"/>
             /// </remarks>
-            public NativeWin32Exception ThrowForUnknownError()
+            public readonly NativeWin32Exception ThrowForUnknownError()
             {
                 Debug.Assert(Status == EnumerateDirectoryStatus.UnknownError);
                 throw CreateExceptionForError();
@@ -173,7 +173,7 @@ public NativeWin32Exception ThrowForKnownError()
             /// <summary>
             /// Creates (but does not throw) an exception for this result. The result must not be successful.
             /// </summary>
-            public NativeWin32Exception CreateExceptionForError()
+            public readonly NativeWin32Exception CreateExceptionForError()
             {
                 Debug.Assert(Status != EnumerateDirectoryStatus.Success);
                 if (Status == EnumerateDirectoryStatus.UnknownError)
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
index 85e688acb50..ef5073b4835 100644
--- a/src/Shared/Pair.cs
+++ b/src/Shared/Pair.cs
@@ -44,7 +44,7 @@ public Pair(TKey key, TValue value)
         /// <summary>
         /// Key
         /// </summary>
-        internal TKey Key
+        internal readonly TKey Key
         {
             get { return _key; }
         }
@@ -52,7 +52,7 @@ internal TKey Key
         /// <summary>
         /// Value
         /// </summary>
-        internal TValue Value
+        internal readonly TValue Value
         {
             get { return _value; }
         }
diff --git a/src/Shared/StringExtensions.cs b/src/Shared/StringExtensions.cs
index 40485f659b3..4fcf361bac8 100644
--- a/src/Shared/StringExtensions.cs
+++ b/src/Shared/StringExtensions.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NETFRAMEWORK
+using System.IO;
+#endif
 using System.Text;
 
 #nullable disable
@@ -48,5 +51,46 @@ public static string Replace(this string aString, string oldValue, string newVal
 
             return builder.ToString();
         }
+
+#if NETFRAMEWORK
+        /// <summary>
+        /// Trivial implementation of CommonPrefixLength on spans of characters.
+        /// </summary>
+        public static int CommonPrefixLength(this ReadOnlySpan<char> span, ReadOnlySpan<char> other)
+        {
+            int commonPrefixLength = 0;
+            int length = Math.Min(span.Length, other.Length);
+
+            while (commonPrefixLength < length && span[commonPrefixLength] == other[commonPrefixLength])
+            {
+                commonPrefixLength++;
+            }
+            return commonPrefixLength;
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="StringBuilder"/>.
+        /// </summary>
+        public static StringBuilder Append(this StringBuilder sb, ReadOnlySpan<char> value)
+        {
+            return sb.Append(value.ToString());
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="TextWriter"/>.
+        /// </summary>
+        public static void Write(this TextWriter writer, ReadOnlySpan<char> buffer)
+        {
+            writer.Write(buffer.ToString());
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="TextWriter"/>.
+        /// </summary>
+        public static void WriteLine(this TextWriter writer, ReadOnlySpan<char> buffer)
+        {
+            writer.WriteLine(buffer.ToString());
+        }
+#endif
     }
 }
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 9a9bec6d5c9..c52765ccd49 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -282,8 +282,13 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                             bool logMessage = !(eventArgs is BuildFinishedEventArgs) || LogBuildFinished;
                             if (logMessage)
                             {
-                                _fullLog.AppendLine(eventArgs.Message);
-                                _testOutputHelper?.WriteLine(eventArgs.Message);
+                                string msg = eventArgs.Message;
+                                if (eventArgs is BuildMessageEventArgs m && m.LineNumber != 0)
+                                {
+                                    msg = $"{m.File}({m.LineNumber},{m.ColumnNumber}): {msg}";
+                                }
+                                _fullLog.AppendLine(msg);
+                                _testOutputHelper?.WriteLine(msg);
                             }
                             break;
                         }
@@ -496,9 +501,9 @@ internal void AssertLogDoesntContain(string contains)
         /// </summary>
         internal void AssertNoWarnings() => Assert.Equal(0, WarningCount);
 
-        internal void AssertMessageCount(string message, int expectedCount)
+        internal void AssertMessageCount(string message, int expectedCount, bool regexSearch = true)
         {
-            var matches = Regex.Matches(FullLog, message);
+            var matches = Regex.Matches(FullLog, regexSearch ? message : Regex.Escape(message));
             matches.Count.ShouldBe(expectedCount);
         }
     }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 31ce5b63c29..b5b4ad1b610 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1155,6 +1155,11 @@ internal static string GetOSPlatformAsString()
         /// </summary>
         internal static int Count(IEnumerable enumerable)
         {
+            if (enumerable is ICollection c)
+            {
+                return c.Count;
+            }
+
             int i = 0;
             foreach (object _ in enumerable)
             {
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index e37749e172c..27e32d603cb 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -32,9 +32,8 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 return oldElement;
             }
 
-            XmlElementWithLocation newElement = (xmlNamespace == null)
-                ? (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName)
-                : (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName, xmlNamespace);
+            XmlElementWithLocation newElement =
+                (XmlElementWithLocation)((XmlDocumentWithLocation)oldElement.OwnerDocument).CreateElement(newElementName, xmlNamespace ?? string.Empty, oldElement.Location);
 
             // Copy over all the attributes.
             foreach (XmlAttribute oldAttribute in oldElement.Attributes)
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 57789ab0700..4328bbc084e 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -57,7 +57,7 @@ public Enumerator(InternableString spanBuilder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
+            public readonly char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
 
             /// <summary>
             /// Moves to the next character.
@@ -88,7 +88,7 @@ public bool MoveNext()
         /// <summary>
         /// A convenience getter to ensure that we always operate on a non-null string.
         /// </summary>
-        private string FirstString => _firstString ?? string.Empty;
+        private readonly string FirstString => _firstString ?? string.Empty;
 
         /// <summary>
         /// Constructs a new InternableString wrapping the given string.
@@ -116,13 +116,13 @@ internal InternableString(SpanBasedStringBuilder builder)
         /// <summary>
         /// Gets the length of the string.
         /// </summary>
-        public int Length => (_builder == null ? FirstString.Length : _builder.Length);
+        public readonly int Length => (_builder == null ? FirstString.Length : _builder.Length);
 
         /// <summary>
         /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
         /// </summary>
         /// <returns>The enumerator.</returns>
-        public Enumerator GetEnumerator()
+        public readonly Enumerator GetEnumerator()
         {
             return new Enumerator(this);
         }
@@ -132,7 +132,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -163,7 +163,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public string ExpensiveConvertToString()
+        public readonly string ExpensiveConvertToString()
         {
             // Special case: if we hold just one string, we can directly return it.
             if (_firstString != null)
@@ -178,9 +178,9 @@ public string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
-            return Object.ReferenceEquals(str, _firstString);
+            return ReferenceEquals(str, _firstString);
         }
 
         /// <summary>
@@ -198,7 +198,7 @@ public override unsafe string ToString()
         /// Implements the simple yet very decently performing djb2 hash function (xor version).
         /// </summary>
         /// <returns>A stable hashcode of the string represented by this instance.</returns>
-        public override int GetHashCode()
+        public override readonly int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool isOddIndex = false;
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 413aad9fb88..7e657d56cdb 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -43,7 +43,7 @@ internal Enumerator(scoped ref InternableString str)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public ref readonly char Current
+            public readonly ref readonly char Current
             {
                 get
                 {
@@ -178,7 +178,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -210,7 +210,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public unsafe string ExpensiveConvertToString()
+        public readonly unsafe string ExpensiveConvertToString()
         {
             if (Length == 0)
             {
@@ -268,7 +268,7 @@ public unsafe string ExpensiveConvertToString()
 
                 // The invariant that Length is the sum of span lengths is critical in this unsafe method.
                 // Violating it may lead to memory corruption and, since this code tends to run under a lock,
-                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now, 
+                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now,
                 // before the corruption causes further problems.
                 if (destPtr != resultPtr + Length)
                 {
@@ -283,7 +283,7 @@ public unsafe string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
             if (_inlineSpan.Length == Length)
             {
@@ -317,7 +317,7 @@ public override string ToString()
         /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for
         /// a given string regardless of how it's split into spans (e.g. { "AB" } and { "A", "B" } have the same hash code).
         /// </remarks>
-        public override unsafe int GetHashCode()
+        public override readonly unsafe int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool hashedOddNumberOfCharacters = false;
diff --git a/src/StringTools/SpanBasedStringBuilder.Simple.cs b/src/StringTools/SpanBasedStringBuilder.Simple.cs
index 6090363a24f..a9c88b590c9 100644
--- a/src/StringTools/SpanBasedStringBuilder.Simple.cs
+++ b/src/StringTools/SpanBasedStringBuilder.Simple.cs
@@ -35,7 +35,7 @@ public Enumerator(StringBuilder builder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => _builder[_charIndex];
+            public readonly char Current => _builder[_charIndex];
 
             /// <summary>
             /// Moves to the next character.
diff --git a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
index 91f87bd654e..818a00a7fe4 100644
--- a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
@@ -19,7 +19,7 @@ internal struct AssemblyNameReference : IComparable<AssemblyNameReference>
         /// <summary>
         /// Display as string.
         /// </summary>
-        public override string ToString()
+        public override readonly string ToString()
         {
             return assemblyName + ", " + reference;
         }
@@ -27,7 +27,7 @@ public override string ToString()
         /// <summary>
         /// Compare by assembly name.
         /// </summary>
-        public int CompareTo(AssemblyNameReference other)
+        public readonly int CompareTo(AssemblyNameReference other)
         {
             return assemblyName.CompareTo(other.assemblyName);
         }
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index 9de8725cd65..f998d3be668 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -66,7 +66,7 @@ public AnalyzedTypesInfoKey(Guid guid, short major, short minor, int lcid, int i
                 this.index = index;
             }
 
-            public override string ToString()
+            public override readonly string ToString()
             {
                 return string.Format(CultureInfo.InvariantCulture, "{0}.{1}.{2}.{3}:{4}",
                     this.guid, this.wMajorVerNum,
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index f36e079ea3b..3c88dc06d8b 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1232,7 +1232,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         RootPath="$(TargetFrameworkRootPath)"
         TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)"
         BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)"
-        >
+        ContinueOnError="!$(BuildingProject)">
       <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories"/>
       <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths"/>
       <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''"/>
diff --git a/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
index 4e53459f155..8f98ab38e0a 100644
--- a/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
+++ b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
@@ -27,7 +27,7 @@ public RequiresSymbolicLinksFactAttribute()
             // In Windows, a process can create symlinks only if it has sufficient permissions.
             // We simply try to create one and if it fails we skip the test.
             string sourceFile = FileUtilities.GetTemporaryFile();
-            string destinationFile = FileUtilities.GetTemporaryFile();
+            string destinationFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.Create(sourceFile).Dispose();
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 06811207770..76d4dd912fb 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -846,10 +846,12 @@ public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int follo
         {
             using var env = TestEnvironment.Create(_output);
 
+            MockEngine engine = new();
+
             // Task under test:
             var task = new ToolTaskThatSleeps
             {
-                BuildEngine = new MockEngine(),
+                BuildEngine = engine,
                 InitialDelay = initialDelay,
                 FollowupDelay = followupDelay,
                 Timeout = timeout
@@ -861,6 +863,9 @@ public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int follo
             {
                 // Execute the task:
                 result = task.Execute();
+
+                _output.WriteLine(engine.Log);
+
                 task.RepeatCount.ShouldBe(i);
 
                 // The first execution may fail (timeout), but all following ones should succeed:
@@ -882,7 +887,7 @@ public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int follo
         private sealed class ToolTaskThatSleeps : ToolTask
         {
             // PowerShell command to sleep:
-            private readonly string _powerShellSleep = "-ExecutionPolicy RemoteSigned -Command \"Start-Sleep -Milliseconds {0}\"";
+            private readonly string _powerShellSleep = "-NoProfile -ExecutionPolicy RemoteSigned -Command \"Start-Sleep -Milliseconds {0}\"";
 
             // UNIX command to sleep:
             private readonly string _unixSleep = "-c \"sleep {0}\"";
