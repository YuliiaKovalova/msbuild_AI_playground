diff --git a/.gitignore b/.gitignore
index cc15003e7c1..e902f62318d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -218,5 +218,7 @@ Samples/MultiprocessBuild/PortableTask.dll
 
 #Stage1 build folder for when doing bootstrap builds
 stage1/
+.tools
 
-.tools
\ No newline at end of file
+# ETL traces    
+*.etl.zip
\ No newline at end of file
diff --git a/PerfViewData.etl.zip b/PerfViewData.etl.zip
deleted file mode 100644
index 823543440d2..00000000000
Binary files a/PerfViewData.etl.zip and /dev/null differ
diff --git a/eng/Packages.props b/eng/Packages.props
index 34ef37a4d0f..a7844e3b8a1 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -8,6 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
     <PackageReference Update="LargeAddressAware" Version="1.0.3" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="3.0.0-beta1-61516-01" />
@@ -35,9 +36,12 @@
     <PackageReference Update="System.Reflection.TypeExtensions" Version="4.1.0" />
     <PackageReference Update="System.Resources.Extensions" Version="4.6.0" />
     <PackageReference Update="System.Resources.Writer" Version="4.0.0" />
+    <PackageReference Update="System.Runtime.InteropServices" Version="4.3.0" />
     <PackageReference Update="System.Runtime.InteropServices.RuntimeInformation" Version="4.3.0" />
     <PackageReference Update="System.Runtime.Loader" Version="4.0.0" />
     <PackageReference Update="System.Runtime.Serialization.Primitives" Version="4.1.1" />
+    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="4.7.0" />
+    <PackageReference Update="System.Security.Cryptography.Xml" Version="4.7.0" />
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
     <PackageReference Update="System.Security.Principal.Windows" Version="4.7.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 410b0fc73a8..cc3fb5233ef 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -313,6 +313,34 @@ public FormatVersion() { }
         public string Version { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class GenerateApplicationManifest : Microsoft.Build.Tasks.GenerateManifestBase
+    {
+        public GenerateApplicationManifest() { }
+        public string ClrVersion { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem ConfigFile { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Dependencies { get { throw null; } set { } }
+        public string ErrorReportUrl { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] FileAssociations { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public bool HostInBrowser { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem IconFile { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] IsolatedComReferences { get { throw null; } set { } }
+        public string ManifestType { get { throw null; } set { } }
+        public string OSVersion { get { throw null; } set { } }
+        public string Product { get { throw null; } set { } }
+        public string Publisher { get { throw null; } set { } }
+        public bool RequiresMinimumFramework35SP1 { get { throw null; } set { } }
+        public string SuiteName { get { throw null; } set { } }
+        public string SupportUrl { get { throw null; } set { } }
+        public string TargetFrameworkProfile { get { throw null; } set { } }
+        public string TargetFrameworkSubset { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem TrustInfoFile { get { throw null; } set { } }
+        public bool UseApplicationTrust { get { throw null; } set { } }
+        protected override System.Type GetObjectType() { throw null; }
+        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected internal override bool ValidateInputs() { throw null; }
+    }
     public partial class GenerateBindingRedirects : Microsoft.Build.Tasks.TaskExtension
     {
         public GenerateBindingRedirects() { }
@@ -323,6 +351,57 @@ public GenerateBindingRedirects() { }
         public string TargetName { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class GenerateDeploymentManifest : Microsoft.Build.Tasks.GenerateManifestBase
+    {
+        public GenerateDeploymentManifest() { }
+        public bool CreateDesktopShortcut { get { throw null; } set { } }
+        public string DeploymentUrl { get { throw null; } set { } }
+        public bool DisallowUrlActivation { get { throw null; } set { } }
+        public string ErrorReportUrl { get { throw null; } set { } }
+        public bool Install { get { throw null; } set { } }
+        public bool MapFileExtensions { get { throw null; } set { } }
+        public string MinimumRequiredVersion { get { throw null; } set { } }
+        public string Product { get { throw null; } set { } }
+        public string Publisher { get { throw null; } set { } }
+        public string SuiteName { get { throw null; } set { } }
+        public string SupportUrl { get { throw null; } set { } }
+        public bool TrustUrlParameters { get { throw null; } set { } }
+        public bool UpdateEnabled { get { throw null; } set { } }
+        public int UpdateInterval { get { throw null; } set { } }
+        public string UpdateMode { get { throw null; } set { } }
+        public string UpdateUnit { get { throw null; } set { } }
+        protected override System.Type GetObjectType() { throw null; }
+        protected override bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
+        protected internal override bool ValidateInputs() { throw null; }
+    }
+    public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
+    {
+        protected GenerateManifestBase() { }
+        public string AssemblyName { get { throw null; } set { } }
+        public string AssemblyVersion { get { throw null; } set { } }
+        public string Description { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
+        public int MaxTargetPath { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
+        public string Platform { get { throw null; } set { } }
+        public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
+        public override bool Execute() { throw null; }
+        protected internal Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) { throw null; }
+        protected abstract System.Type GetObjectType();
+        protected abstract bool OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
+        protected abstract bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest);
+        protected internal virtual bool ValidateInputs() { throw null; }
+        protected internal virtual bool ValidateOutput() { throw null; }
+    }
     [Microsoft.Build.Framework.RequiredRuntimeAttribute("v2.0")]
     public sealed partial class GenerateResource : Microsoft.Build.Tasks.TaskExtension
     {
@@ -654,6 +733,30 @@ public ResolveKeySource() { }
         public bool SuppressAutoClosePasswordPrompt { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
+    {
+        public ResolveManifestFiles() { }
+        public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] OutputAssemblies { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputDeploymentManifestEntryPoint { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] OutputFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] PublishFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
+        public bool SigningManifests { get { throw null; } set { } }
+        public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public partial class ResolveNonMSBuildProjectOutput : Microsoft.Build.Tasks.ResolveProjectBase
     {
         public ResolveNonMSBuildProjectOutput() { }
@@ -867,6 +970,1023 @@ public ZipDirectory() { }
         public override bool Execute() { throw null; }
     }
 }
+namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
+{
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
+    public partial class BootstrapperBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
+    {
+        public BootstrapperBuilder() { }
+        public BootstrapperBuilder(string visualStudioVersion) { }
+        public string Path { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) { throw null; }
+        public string[] GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) { throw null; }
+        public static string XmlToConfigurationFile(System.Xml.XmlNode input) { throw null; }
+    }
+    public partial class BuildMessage : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
+    {
+        internal BuildMessage() { }
+        public int HelpId { get { throw null; } }
+        public string HelpKeyword { get { throw null; } }
+        public string Message { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get { throw null; } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
+    public enum BuildMessageSeverity
+    {
+        Error = 2,
+        Info = 0,
+        Warning = 1,
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
+    public partial class BuildResults : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
+    {
+        internal BuildResults() { }
+        public string[] ComponentFiles { get { throw null; } }
+        public string KeyFile { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get { throw null; } }
+        public bool Succeeded { get { throw null; } }
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
+    public partial class BuildSettings : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
+    {
+        public BuildSettings() { }
+        public string ApplicationFile { get { throw null; } set { } }
+        public string ApplicationName { get { throw null; } set { } }
+        public bool ApplicationRequiresElevation { get { throw null; } set { } }
+        public string ApplicationUrl { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get { throw null; } set { } }
+        public string ComponentsUrl { get { throw null; } set { } }
+        public bool CopyComponents { get { throw null; } set { } }
+        public int FallbackLCID { get { throw null; } set { } }
+        public int LCID { get { throw null; } set { } }
+        public string OutputPath { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get { throw null; } }
+        public string SupportUrl { get { throw null; } set { } }
+        public bool Validate { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
+    public enum ComponentsLocation
+    {
+        Absolute = 2,
+        HomeSite = 0,
+        Relative = 1,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBootstrapperBuilder
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        string Path { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Products { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(5)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings);
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBuildMessage
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        int HelpId { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string HelpKeyword { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string Message { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity Severity { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBuildResults
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string[] ComponentFiles { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string KeyFile { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        bool Succeeded { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IBuildSettings
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string ApplicationFile { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        string ApplicationName { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(13)]
+        bool ApplicationRequiresElevation { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string ApplicationUrl { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(11)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation ComponentsLocation { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        string ComponentsUrl { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(5)]
+        bool CopyComponents { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(7)]
+        int FallbackLCID { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(6)]
+        int LCID { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(8)]
+        string OutputPath { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(9)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection ProductBuilders { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(12)]
+        string SupportUrl { get; set; }
+        [System.Runtime.InteropServices.DispIdAttribute(10)]
+        bool Validate { get; set; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProduct
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(4)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        string Name { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        string ProductCode { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProductBuilder
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProductBuilderCollection
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder);
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    public partial interface IProductCollection
+    {
+        [System.Runtime.InteropServices.DispIdAttribute(1)]
+        int Count { get; }
+        [System.Runtime.InteropServices.DispIdAttribute(2)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index);
+        [System.Runtime.InteropServices.DispIdAttribute(3)]
+        Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode);
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
+    public partial class Product : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
+    {
+        public Product() { }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection Includes { get { throw null; } }
+        public string Name { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder ProductBuilder { get { throw null; } }
+        public string ProductCode { get { throw null; } }
+    }
+    public partial class ProductBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
+    {
+        internal ProductBuilder() { }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get { throw null; } }
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
+    public partial class ProductBuilderCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection, System.Collections.IEnumerable
+    {
+        internal ProductBuilderCollection() { }
+        public void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
+    [System.Runtime.InteropServices.GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
+    public partial class ProductCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection, System.Collections.IEnumerable
+    {
+        internal ProductCollection() { }
+        public int Count { get { throw null; } }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Item(int index) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode) { throw null; }
+    }
+}
+namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
+{
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class ApplicationIdentity
+    {
+        public ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) { }
+        public ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) { }
+        public override string ToString() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("ApplicationManifest")]
+    public sealed partial class ApplicationManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
+    {
+        public ApplicationManifest() { }
+        public ApplicationManifest(string targetFrameworkVersion) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ConfigFile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ErrorReportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection FileAssociations { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool HostInBrowser { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string IconFile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsClickOnceManifest { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public int MaxTargetPath { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string OSDescription { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string OSSupportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string OSVersion { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Product { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Publisher { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SuiteName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SupportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TargetFrameworkVersion { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo TrustInfo { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool UseApplicationTrust { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ConfigFile")]
+        public string XmlConfigFile { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlElementAttribute("EntryPointIdentity")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlEntryPointIdentity { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointParameters")]
+        public string XmlEntryPointParameters { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("EntryPointPath")]
+        public string XmlEntryPointPath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
+        public string XmlErrorReportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("FileAssociations")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[] XmlFileAssociations { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("HostInBrowser")]
+        public string XmlHostInBrowser { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IconFile")]
+        public string XmlIconFile { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsClickOnceManifest")]
+        public string XmlIsClickOnceManifest { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSBuild")]
+        public string XmlOSBuild { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSDescription")]
+        public string XmlOSDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSMajor")]
+        public string XmlOSMajor { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSMinor")]
+        public string XmlOSMinor { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSRevision")]
+        public string XmlOSRevision { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("OSSupportUrl")]
+        public string XmlOSSupportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
+        public string XmlProduct { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
+        public string XmlPublisher { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
+        public string XmlSuiteName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
+        public string XmlSupportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UseApplicationTrust")]
+        public string XmlUseApplicationTrust { get { throw null; } set { } }
+        public override void Validate() { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("AssemblyIdentity")]
+    public sealed partial class AssemblyIdentity
+    {
+        public AssemblyIdentity() { }
+        public AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { }
+        public AssemblyIdentity(string name) { }
+        public AssemblyIdentity(string name, string version) { }
+        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture) { }
+        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) { }
+        public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Culture { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsFrameworkAssembly { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsNeutralPlatform { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsStrongName { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Name { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ProcessorArchitecture { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string PublicKeyToken { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Type { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Version { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Culture")]
+        public string XmlCulture { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
+        public string XmlName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ProcessorArchitecture")]
+        public string XmlProcessorArchitecture { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("PublicKeyToken")]
+        public string XmlPublicKeyToken { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Type")]
+        public string XmlType { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
+        public string XmlVersion { get { throw null; } set { } }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromAssemblyName(string assemblyName) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromFile(string path) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManagedAssembly(string path) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromManifest(string path) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromNativeAssembly(string path) { throw null; }
+        public string GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) { throw null; }
+        public bool IsInFramework(string frameworkIdentifier, string frameworkVersion) { throw null; }
+        public override string ToString() { throw null; }
+        [System.FlagsAttribute]
+        public enum FullNameFlags
+        {
+            All = 3,
+            Default = 0,
+            ProcessorArchitecture = 1,
+            Type = 2,
+        }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("AssemblyManifest")]
+    public partial class AssemblyManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+    {
+        public AssemblyManifest() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ExternalProxyStubs { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("ExternalProxyStubs")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlExternalProxyStubs { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class AssemblyReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
+    {
+        public AssemblyReference() { }
+        public AssemblyReference(string path) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsPrerequisite { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType ReferenceType { get { throw null; } set { } }
+        protected internal override string SortName { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsNative")]
+        public string XmlIsNative { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsPrerequisite")]
+        public string XmlIsPrerequisite { get { throw null; } set { } }
+        public override string ToString() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class AssemblyReferenceCollection : System.Collections.IEnumerable
+    {
+        internal AssemblyReferenceCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference this[int index] { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Add(string path) { throw null; }
+        public void Clear() { }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference Find(string name) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference FindTargetPath(string targetPath) { throw null; }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) { }
+    }
+    public enum AssemblyReferenceType
+    {
+        ClickOnceManifest = 1,
+        ManagedAssembly = 2,
+        NativeAssembly = 3,
+        Unspecified = 0,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public abstract partial class BaseReference
+    {
+        protected internal BaseReference() { }
+        protected internal BaseReference(string path) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Group { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Hash { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsOptional { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ResolvedPath { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public long Size { get { throw null; } set { } }
+        protected internal abstract string SortName { get; }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SourcePath { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TargetPath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Group")]
+        public string XmlGroup { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Hash")]
+        public string XmlHash { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("HashAlg")]
+        public string XmlHashAlgorithm { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("IsOptional")]
+        public string XmlIsOptional { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Path")]
+        public string XmlPath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Size")]
+        public string XmlSize { get { throw null; } set { } }
+        public override string ToString() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class ComClass
+    {
+        public ComClass() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ClsId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Description { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ProgId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ThreadingModel { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TlbId { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Clsid")]
+        public string XmlClsId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
+        public string XmlDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
+        public string XmlProgId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ThreadingModel")]
+        public string XmlThreadingModel { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
+        public string XmlTlbId { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class CompatibleFramework
+    {
+        public CompatibleFramework() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Profile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SupportedRuntime { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Version { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Profile")]
+        public string XmlProfile { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SupportedRuntime")]
+        public string XmlSupportedRuntime { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
+        public string XmlVersion { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class CompatibleFrameworkCollection : System.Collections.IEnumerable
+    {
+        internal CompatibleFrameworkCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework this[int index] { get { throw null; } }
+        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) { }
+        public void Clear() { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    [System.Xml.Serialization.XmlRootAttribute("DeployManifest")]
+    public sealed partial class DeployManifest : Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
+    {
+        public DeployManifest() { }
+        public DeployManifest(string targetFrameworkMoniker) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection CompatibleFrameworks { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool CreateDesktopShortcut { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string DeploymentUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool DisallowUrlActivation { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ErrorReportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool Install { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool MapFileExtensions { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string MinimumRequiredVersion { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Product { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Publisher { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SuiteName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SupportUrl { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TargetFrameworkMoniker { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool TrustUrlParameters { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool UpdateEnabled { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public int UpdateInterval { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode UpdateMode { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit UpdateUnit { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("CompatibleFrameworks")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[] XmlCompatibleFrameworks { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("CreateDesktopShortcut")]
+        public string XmlCreateDesktopShortcut { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("DeploymentUrl")]
+        public string XmlDeploymentUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("DisallowUrlActivation")]
+        public string XmlDisallowUrlActivation { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
+        public string XmlErrorReportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Install")]
+        public string XmlInstall { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("MapFileExtensions")]
+        public string XmlMapFileExtensions { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("MinimumRequiredVersion")]
+        public string XmlMinimumRequiredVersion { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Product")]
+        public string XmlProduct { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
+        public string XmlPublisher { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
+        public string XmlSuiteName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
+        public string XmlSupportUrl { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("TrustUrlParameters")]
+        public string XmlTrustUrlParameters { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateEnabled")]
+        public string XmlUpdateEnabled { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateInterval")]
+        public string XmlUpdateInterval { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateMode")]
+        public string XmlUpdateMode { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("UpdateUnit")]
+        public string XmlUpdateUnit { get { throw null; } set { } }
+        public override void Validate() { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileAssociation
+    {
+        public FileAssociation() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string DefaultIcon { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Description { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Extension { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ProgId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("DefaultIcon")]
+        public string XmlDefaultIcon { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
+        public string XmlDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Extension")]
+        public string XmlExtension { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
+        public string XmlProgId { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileAssociationCollection : System.Collections.IEnumerable
+    {
+        internal FileAssociationCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation this[int index] { get { throw null; } }
+        public void Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) { }
+        public void Clear() { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileReference : Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
+    {
+        public FileReference() { }
+        public FileReference(string path) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] ComClasses { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool IsDataFile { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ProxyStubs { get { throw null; } }
+        protected internal override string SortName { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] TypeLibs { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("ComClasses")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] XmlComClasses { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("ProxyStubs")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlProxyStubs { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("TypeLibs")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] XmlTypeLibs { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("WriteableType")]
+        public string XmlWriteableType { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class FileReferenceCollection : System.Collections.IEnumerable
+    {
+        internal FileReferenceCollection() { }
+        public int Count { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference this[int index] { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { throw null; }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference Add(string path) { throw null; }
+        public void Clear() { }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference FindTargetPath(string targetPath) { throw null; }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+        public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public abstract partial class Manifest
+    {
+        protected internal Manifest() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Description { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference EntryPoint { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection FileReferences { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public System.IO.Stream InputStream { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool ReadOnly { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string SourcePath { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("AssemblyReferences")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[] XmlAssemblyReferences { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Description")]
+        public string XmlDescription { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlArrayAttribute("FileReferences")]
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[] XmlFileReferences { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Schema")]
+        public string XmlSchema { get { throw null; } set { } }
+        public void ResolveFiles() { }
+        public void ResolveFiles(string[] searchPaths) { }
+        public override string ToString() { throw null; }
+        public void UpdateFileInfo() { }
+        public void UpdateFileInfo(string targetFrameworkVersion) { }
+        public virtual void Validate() { }
+        protected void ValidatePlatform() { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public static partial class ManifestReader
+    {
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(System.IO.Stream input, bool preserveStream) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string path, bool preserveStream) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) { throw null; }
+        public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest ReadManifest(string manifestType, string path, bool preserveStream) { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public static partial class ManifestWriter
+    {
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { }
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) { }
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) { }
+        public static void WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class OutputMessage
+    {
+        internal OutputMessage() { }
+        public string Name { get { throw null; } }
+        public string Text { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType Type { get { throw null; } }
+        public string[] GetArguments() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class OutputMessageCollection : System.Collections.IEnumerable
+    {
+        internal OutputMessageCollection() { }
+        public int ErrorCount { get { throw null; } }
+        public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage this[int index] { get { throw null; } }
+        public int WarningCount { get { throw null; } }
+        public void Clear() { }
+        public System.Collections.IEnumerator GetEnumerator() { throw null; }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public enum OutputMessageType
+    {
+        Error = 2,
+        Info = 0,
+        Warning = 1,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class ProxyStub
+    {
+        public ProxyStub() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string BaseInterface { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string IID { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Name { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string NumMethods { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TlbId { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("BaseInterface")]
+        public string XmlBaseInterface { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Iid")]
+        public string XmlIID { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
+        public string XmlName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("NumMethods")]
+        public string XmlNumMethods { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
+        public string XmlTlbId { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public static partial class SecurityUtilities
+    {
+        public static void SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) { }
+        public static void SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) { }
+        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path) { }
+        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public sealed partial class TrustInfo
+    {
+        public TrustInfo() { }
+        public bool HasUnmanagedCodePermission { get { throw null; } }
+        public bool IsFullTrust { get { throw null; } }
+        public bool PreserveFullTrustPermissionSet { get { throw null; } set { } }
+        public string SameSiteAccess { get { throw null; } set { } }
+        public void Clear() { }
+        public void Read(System.IO.Stream input) { }
+        public void Read(string path) { }
+        public void ReadManifest(System.IO.Stream input) { }
+        public void ReadManifest(string path) { }
+        public override string ToString() { throw null; }
+        public void Write(System.IO.Stream output) { }
+        public void Write(string path) { }
+        public void WriteManifest(System.IO.Stream output) { }
+        public void WriteManifest(System.IO.Stream input, System.IO.Stream output) { }
+        public void WriteManifest(string path) { }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class TypeLib
+    {
+        public TypeLib() { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Flags { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string HelpDirectory { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string ResourceId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string TlbId { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Version { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Flags")]
+        public string XmlFlags { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("HelpDir")]
+        public string XmlHelpDirectory { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("ResourceId")]
+        public string XmlResourceId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
+        public string XmlTlbId { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Version")]
+        public string XmlVersion { get { throw null; } set { } }
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public enum UpdateMode
+    {
+        Background = 0,
+        Foreground = 1,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public enum UpdateUnit
+    {
+        Days = 1,
+        Hours = 0,
+        Weeks = 2,
+    }
+    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
+    public partial class WindowClass
+    {
+        public WindowClass() { }
+        public WindowClass(string name, bool versioned) { }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string Name { get { throw null; } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool Versioned { get { throw null; } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Name")]
+        public string XmlName { get { throw null; } set { } }
+        [System.ComponentModel.BrowsableAttribute(false)]
+        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.Xml.Serialization.XmlAttributeAttribute("Versioned")]
+        public string XmlVersioned { get { throw null; } set { } }
+    }
+}
 namespace Microsoft.Build.Tasks.Hosting
 {
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
@@ -1045,3 +2165,12 @@ public partial interface IVbcHostObjectFreeThreaded
         bool Compile();
     }
 }
+namespace System.Deployment.Internal.CodeSigning
+{
+    public sealed partial class RSAPKCS1SHA256SignatureDescription : System.Security.Cryptography.SignatureDescription
+    {
+        public RSAPKCS1SHA256SignatureDescription() { }
+        public override System.Security.Cryptography.AsymmetricSignatureDeformatter CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
+        public override System.Security.Cryptography.AsymmetricSignatureFormatter CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) { throw null; }
+    }
+}
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 392c88c6c77..52989661d31 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -890,7 +890,6 @@ public static IEnumerable<object[]> InsertMetadataElemenetAfterSiblingsTestData
                         <m>v</m>
                       </i>"
                 };
-
             }
         }
 
@@ -1014,7 +1013,6 @@ public static IEnumerable<object[]> InsertMetadataAttributeAfterSiblingsTestData
                         <b>value_b</b>
                       </i>"
                 };
-
             }
         }
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index 9e15aa96ecd..3f387d1481a 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -458,7 +458,6 @@ public void ReadInvalidUpdateWithIncludeAndExclude(string project)
         {
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(project)));
             }
            );
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 4f0e18bb982..86a44b3822f 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -532,7 +532,7 @@ public void ValidXmlXmlReaderCache()
         public void LoadCommonTargets()
         {
             ProjectCollection projectCollection = new ProjectCollection();
-            string toolsPath = projectCollection.Toolsets.Where(toolset => (string.Compare(toolset.ToolsVersion, ObjectModelHelpers.MSBuildDefaultToolsVersion, StringComparison.OrdinalIgnoreCase) == 0)).First().ToolsPath;
+            string toolsPath = projectCollection.Toolsets.Where(toolset => (string.Equals(toolset.ToolsVersion, ObjectModelHelpers.MSBuildDefaultToolsVersion, StringComparison.OrdinalIgnoreCase))).First().ToolsPath;
 
             string[] targets =
             {
@@ -905,7 +905,6 @@ public void ItemsEnumerator()
 
         public void SolutionCanNotBeOpened()
         {
-            
             Assert.Throws<InvalidProjectFileException>(() =>
             {
                 string solutionFile = null;
@@ -936,10 +935,7 @@ public void SolutionCanNotBeOpened()
                 }
                 finally
                 {
-                    if (security != null)
-                    {
-                        security.RemoveAccessRule(rule);
-                    }
+                    security?.RemoveAccessRule(rule);
 
                     File.Delete(solutionFile);
                     File.Delete(tempFileSentinel);
@@ -984,10 +980,7 @@ public void ProjectCanNotBeOpened()
                 }
                 finally
                 {
-                    if (security != null)
-                    {
-                        security.RemoveAccessRule(rule);
-                    }
+                    security?.RemoveAccessRule(rule);
 
                     File.Delete(projectFile);
                     Assert.False(File.Exists(projectFile));
@@ -1034,7 +1027,6 @@ public void SolutionCorrupt()
         [PlatformSpecific(TestPlatforms.Windows)]  //This test is platform specific for Windows
         public void ConcurrentProjectOpenAndCloseThroughProject()
         {
-
             int iterations = 500;
             string[] paths = ObjectModelHelpers.GetTempFiles(iterations);
 
@@ -1743,7 +1735,6 @@ private void AssertProjectFileAfterReload(
             bool reloadProjectFromMemory,
             Action<string, string, string> projectFileAssert)
         {
-
             using (var env = TestEnvironment.Create())
             {
                 var projectCollection = env.CreateProjectCollection().Collection;
@@ -1900,7 +1891,6 @@ private void AssertReload(
                 Assert.Equal(childrenCount, projectElement.AllChildren.Count());
             }
 
-
             if (xmlChanged)
             {
                 Assert.NotEqual(xml, projectElement.RawXml);
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 1ee4bde1de2..3172b22b806 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -900,7 +900,6 @@ public void ExcludeWithMissmatchingGlobCones(string includeString, string exclud
                 var testFiles = env.CreateTestProjectWithFiles(projectContents, files,relativePathFromRootToProject);
                 ObjectModelHelpers.AssertItems(expectedInclude, new Project(testFiles.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection).Items.ToList());
             }
-
         }
 
         [Theory(Skip = "https://github.com/Microsoft/msbuild/issues/1576")]
@@ -921,7 +920,6 @@ public void ExcludingRelativeItemToCurrentDirectoryShouldWorkWithAboveTheConeInc
                 var testFiles = env.CreateTestProjectWithFiles(projectContents, files, relativePathFromRootToProject);
                 ObjectModelHelpers.AssertItems(expectedInclude, new Project(testFiles.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection).Items.ToList());
             }
-
         }
 
         /// <summary>
@@ -959,7 +957,7 @@ public void CopyFromWithItemListExpressionClonesMetadata()
         /// Expression like @(x) should not clone metadata, even if the item type is different.
         /// It's obvious that it shouldn't clone it if the item type is the same.
         /// If it is different, it doesn't clone it for performance; even if the item definition metadata
-        /// changes later (this is design time), the inheritors of that item definition type 
+        /// changes later (this is design time), the inheritors of that item definition type
         /// (even those that have subsequently been transformed to a different itemtype) should see
         /// the changes, by design.
         /// Just to make sure we don't change that behavior, we test it here.
@@ -1342,7 +1340,7 @@ public void BuiltInMisqualifiedMetadataExpression()
         }
 
         /// <summary>
-        /// Metadata condition should work correctly with built-in metadata 
+        /// Metadata condition should work correctly with built-in metadata
         /// </summary>
         [Fact]
         public void BuiltInMetadataInMetadataCondition()
@@ -2080,7 +2078,7 @@ public void RemoveGlob()
                 );
 
             Assert.Equal(2, items.Count);
-            Assert.Equal(@"a.txt;b.cs", string.Join(";", items.Select(i => i.EvaluatedInclude))); ;
+            Assert.Equal(@"a.txt;b.cs", string.Join(";", items.Select(i => i.EvaluatedInclude))); 
         }
 
         [Fact]
@@ -2093,7 +2091,7 @@ public void RemoveItemReference()
                 );
 
             Assert.Equal(2, items.Count);
-            Assert.Equal(@"a;c", string.Join(";", items.Select(i => i.EvaluatedInclude))); ;
+            Assert.Equal(@"a;c", string.Join(";", items.Select(i => i.EvaluatedInclude))); 
         }
 
         [Theory]
@@ -2274,7 +2272,7 @@ public void RemoveWithItemReferenceOnIntrinsicMatchingMetadata()
         [Fact]
         public void RemoveWithPropertyReferenceInMatchOnMetadata()
         {
-            string content = 
+            string content =
                 @"<Project>
                     <PropertyGroup>
                         <Meta1>v0</Meta1>
@@ -2495,7 +2493,7 @@ public void UpdateShouldRespectCondition()
                               <i Update='c'>
                                   <m1 Condition='1 == 0'>from_false_metadata</m1>
                               </i>";
-            
+
             var project = ObjectModelHelpers.CreateInMemoryProject(ObjectModelHelpers.FormatProjectContentsWithItemGroupFragment(projectContents));
 
             var expectedInitial = new Dictionary<string, string>
@@ -2558,7 +2556,6 @@ public void UpdateWithConditionShouldNotApplyOnItemsIgnoringCondition()
             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdateFromUnconditionedElement, itemsIgnoringCondition[3]);
         }
 
-
         [Fact]
         public void LastUpdateWins()
         {
@@ -3354,7 +3351,7 @@ private static List<ProjectItem> GetItemsFromFragmentWithGlobs(string itemGroupF
 
         /// <summary>
         /// Get the item of type "i" using the item Xml fragment provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItemFromFragment(string fragment)
         {
@@ -3366,7 +3363,7 @@ private static ProjectItem GetOneItemFromFragment(string fragment)
 
         /// <summary>
         /// Get the item of type "i" in the project provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItem(string content)
         {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index ec57b9901ab..b31ffbe17bb 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections.Generic;
     using System.Runtime.CompilerServices;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index 0c1bf733a7e..aa285e5e98f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -57,7 +57,6 @@ public ElementLinkPair<CT> AppendNewLabeledChaildWithVerify<CT>(ObjectType where
         public ElementLinkPair<CT> AddNewChaildWithVerify<CT>(ObjectType where, string id, Func<T, string, CT> adder, Func<CT, string, bool> matcher)
             where CT : ProjectElement
         {
-
             var c1Where = adder(this.Get(where), id);
             Assert.NotNull(c1Where);
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index fc833a00f64..14ecdd51296 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -241,11 +241,10 @@ private static void Verify(SdkReference view, SdkReference real, ValidationConte
             if (view == null && real == null) return;
             Assert.NotNull(view);
             Assert.NotNull(real);
-            
+
             Assert.Equal(real.Name, view.Name);
             Assert.Equal(real.Version, view.Version);
             Assert.Equal(real.MinimumVersion, view.MinimumVersion);
-
         }
 
         private static void Verify(SdkResult view, SdkResult real, ValidationContext context = null)
@@ -291,7 +290,7 @@ public static void Verify(ProjectPair pair, ValidationContext context = null)
             if (pair == null) return;
             var real = pair.Real;
             var view = pair.View;
-            context = context ?? new ValidationContext();
+            context ??= new ValidationContext();
             context.Pair = pair;
 
 
@@ -321,7 +320,6 @@ public static void Verify(ProjectPair pair, ValidationContext context = null)
                 Verify(view.ImportsIncludingDuplicates, real.ImportsIncludingDuplicates, Verify, context);
             }
 
-            
             Verify(view.AllEvaluatedProperties, real.AllEvaluatedProperties, Verify, context);
             Verify(view.AllEvaluatedItemDefinitionMetadata, real.AllEvaluatedItemDefinitionMetadata, Verify, context);
             Verify(view.AllEvaluatedItems, real.AllEvaluatedItems, Verify, context);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
index 80e5f60cdc0..25ef9caa625 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -41,7 +40,6 @@ public MyTestCollectionGroup()
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedConstructionModify_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
             this.StdGroup.Local.Importing = true;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
index 7dc33150768..9be5ab30462 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
@@ -3,7 +3,6 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -109,7 +108,6 @@ public void ProjectExtensionsElementReadOnly()
             Assert.Equal(realXml["b"], viewXml["b"]);
             Assert.Equal("x", viewXml["a"]);
             Assert.Equal("y", viewXml["b"]);
-
         }
 
         [Fact]
@@ -285,7 +283,6 @@ public void ProjectTaskElementReadOnly()
         [Fact]
         public void ProjectUsingTaskElementReadOnly()
         {
-
             var preReal = this.StdGroup.RealXml;
             var preView = this.StdGroup.ViewXml;
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
index ddea5990734..3c225aec6db 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -26,7 +25,6 @@ public MyTestCollectionGroup() : base(2, 1) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedEvaluationModify_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
         }
@@ -105,7 +103,6 @@ public void ProjectModifyRenameAndSafeAs()
 
             // and finally just ensure that all is identical
             ViewValidation.Verify(viewProj, realProj);
-
         }
 
         [Fact]
@@ -130,7 +127,6 @@ public void ProjectItemModify()
             };
 
             /// test AddItems
-
             // add a new files in the view, ensure it is added correctly and also the real object will immediately reflect that add as well
             Assert.Null(pair.GetSingleItemWithVerify(ObjectType.View, "foo.cpp"));
             var fooView = pair.AddSingleItemWithVerify(ObjectType.View, "cpp", "foo.cpp");
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
index 355b0426ff8..5792411a2a7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
@@ -3,7 +3,6 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
index d541acdb12b..52face4ec61 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections.Generic;
     using System.Collections.Immutable;
@@ -22,7 +21,6 @@ public MyTestCollectionGroup() : base(2, 4) { }
         public TestCollectionGroup StdGroup { get; }
         public LinkedProjectCollection_Tests(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.Clear();
         }
@@ -34,7 +32,7 @@ public void EnumerationBasic()
             var pcRemote = this.StdGroup.Remote[0];
 
             var proj1Path = this.StdGroup.StdProjectFiles[0];
-            var proj2Path = this.StdGroup.StdProjectFiles[1]; ;
+            var proj2Path = this.StdGroup.StdProjectFiles[1]; 
 
             var proj1 = pcLocal.LoadProject(proj1Path);
             var proj2 = pcRemote.LoadProject(proj2Path);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
index 04012fbb73a..5fc916cfdd3 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-
     using System;
     using System.Collections;
     using System.Collections.Generic;
@@ -80,14 +79,13 @@ public void ResetBeforeTests()
         public MyTestCollectionGroup StdGroup { get; }
         public LinkedSpecialCasesScenarios(MyTestCollectionGroup group)
         {
-
             this.StdGroup = group;
             group.ResetBeforeTests();
         }
 
         private ProjectPair GetNewInMemoryProject(string path, string content = null)
         {
-            content = content ?? TestCollectionGroup.SampleProjectFile;
+            content ??= TestCollectionGroup.SampleProjectFile;
             var tempPath = this.StdGroup.Disk.GetAbsolutePath(path);
             var newReal = this.StdGroup.Target.LoadInMemoryWithSettings(content, ProjectLoadSettings.IgnoreMissingImports);
             newReal.Xml.FullPath = tempPath;
@@ -110,7 +108,7 @@ private void CloneAndAddInternal(ProjectRootElement sourceProject)
             xmlPair.View.Save();
             Assert.False(xmlPair.View.HasUnsavedChanges);
 
-            sourceProject = sourceProject ?? xmlPair.View;
+            sourceProject ??= xmlPair.View;
 
 
             // var existingItemGroup1 = sourceProject.QuerySingleChildrenWithValidation<ProjectItemGroupElement>((ig) => ig.Label == "Group1");
@@ -164,7 +162,7 @@ private void CopyFromInternal(ProjectRootElement sourceProject)
             xmlPair.View.Save();
             Assert.False(xmlPair.View.HasUnsavedChanges);
 
-            sourceProject = sourceProject ?? xmlPair.View;
+            sourceProject ??= xmlPair.View;
 
             var existingItemGroupList = sourceProject.AllChildren.OfType<ProjectItemGroupElement>().Where(((ig) => ig.Label == "Group1")).ToList();
             Assert.Single(existingItemGroupList);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
index e8e654a68ec..0c53fd5bed8 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/InheritanceImplementationHelpers.cs
@@ -21,7 +21,6 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     ///
     /// This approach with extension methods helps us put all implementation in one place, and only standard copy and pace "hookup" is needed for each classes.
     /// </summary>
-
     internal interface IProjectElementContainerLinkHelper
     {
         ProjectCollectionLinker Linker { get; }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
index ca4450dd0be..8080dd5afc7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
@@ -101,5 +101,4 @@ public TemplateProjectElementContainerLink(MockProjectElementContainerLinkRemote
         public override void RemoveChild(ProjectElement child) => CImpl.RemoveChild(child);
         #endregion
     }
-
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
index b0889847c6f..93a45d29468 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectMetadataElementLink.cs
@@ -25,7 +25,6 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         // ProjectMetadataElementLink support
         public string Value { get => MetadataXml.Value; set => MetadataXml.Value = value; }
         public void ChangeName(string newName) { MetadataXml.Name = newName; }
-
     }
 
     internal class MockProjectMetadataElementLink : ProjectMetadataElementLink, ILinkMock, IProjectElementLinkHelper
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
index b882f3fa9f4..8333d6cea58 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectPropertyElementLink.cs
@@ -25,7 +25,6 @@ public override ProjectElement CreateLinkedObject(IImportHolder holder)
         // ProjectPropertyElementLink support
         public string Value { get => PropertyXml.Value; set => PropertyXml.Value = value; }
         public void ChangeName(string newName) { PropertyXml.Name = newName; }
-
     }
 
     internal class MockProjectPropertyElementLink : ProjectPropertyElementLink, ILinkMock, IProjectElementLinkHelper
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
index 51f5cd16e8a..49138cbd4cd 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
@@ -131,6 +131,5 @@ public static MockProjectElementLinkRemoter ExportElement(this ProjectCollection
 
             return factory(exporter, xml);
         }
-
     }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index 235477ca636..253ceac7972 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -24,7 +24,6 @@ public override Project CreateLinkedObject(IImportHolder holder)
 
 
         ///  ProjectLink remoting
-
         public MockProjectElementLinkRemoter Xml => this.OwningCollection.ExportElement(this.Source.Xml);
 
         public bool ThrowInsteadOfSplittingItemElement { get => this.Source.ThrowInsteadOfSplittingItemElement; set => this.Source.ThrowInsteadOfSplittingItemElement = value; }
diff --git a/src/Build.OM.UnitTests/TransientIO.cs b/src/Build.OM.UnitTests/TransientIO.cs
index 020a2e07060..a4baa8399ca 100644
--- a/src/Build.OM.UnitTests/TransientIO.cs
+++ b/src/Build.OM.UnitTests/TransientIO.cs
@@ -88,7 +88,6 @@ public TransientIO GetSubFolder(string path)
             var subFolder = this.GetRelativePath(path);
             if (!this.Children.TryGetValue(subFolder, out var result))
             {
-
                 result  = new TransientIO(this, subFolder);
                 this.Children.Add(subFolder, result);
             }
@@ -131,6 +130,5 @@ public void Dispose()
             this.Clear();
             // this object still can be used ...
         }
-
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index c9e4fdd7302..93eeb2927b1 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -502,7 +502,7 @@ private void TestSkipIsolationConstraints(string glob, string referencePath, boo
 
             glob = $"$([MSBuild]::Escape('{glob}'))";
 
-            projectContents = projectContents ?? $@"
+            projectContents ??= $@"
 <Project>
     <ItemGroup>
         <{ItemTypeNames.GraphIsolationExemptReference} Include=`{glob};ShouldNotMatchAnything`/>
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index 8bd5360d434..ba2a1b00f57 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -67,7 +67,6 @@ public void CannotAddAfterAggregation()
                 });
                 e.Message.ShouldContain("Cannot add after aggregation");
             }
-
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index ac467d52435..e29c9374f82 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -483,7 +483,7 @@ public void RegisterDuplicateForwardingLoggerLogger()
             int countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -585,7 +585,7 @@ public void RegisterGoodDiscriptions()
             int countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -597,7 +597,7 @@ public void RegisterGoodDiscriptions()
             countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.BackEnd.Logging.CentralForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.BackEnd.Logging.CentralForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -1070,7 +1070,7 @@ private LoggerDescription CreateLoggerDescription(string loggerClassName, string
         {
             string eventsToForward = "CustomEvent";
 
-            if (forwardAllEvents == true)
+            if (forwardAllEvents)
             {
                 eventsToForward = "BuildStartedEvent;BuildFinishedEvent;ProjectStartedEvent;ProjectFinishedEvent;TargetStartedEvent;TargetFinishedEvent;TaskStartedEvent;TaskFinishedEvent;ErrorEvent;WarningEvent;HighMessageEvent;NormalMessageEvent;LowMessageEvent;CustomEvent;CommandLine";
             }
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 53f75663934..e39ca58c3df 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1128,7 +1128,7 @@ public void LogTelemetryNullEventName()
                 service.LogTelemetry(
                     buildEventContext: null,
                     eventName: null,
-                    properties: new Dictionary<string, string>());;
+                    properties: new Dictionary<string, string>());
             });
 
             Assert.Contains("eventName is null", exception.Message);
@@ -1163,7 +1163,6 @@ private void TestLogTelemetry(BuildEventContext buildEventContext, string eventN
                 Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties),
             };
 
-
             TelemetryEventArgs actualEventArgs = (TelemetryEventArgs)service.ProcessedBuildEvent;
 
             Assert.Equal(expectedEventArgs.EventName, actualEventArgs.EventName);
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index ed2b547c0af..388a44f149a 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -163,32 +163,17 @@ internal IRequestBuilder RequestBuilder
         /// </summary>
         public IBuildComponent GetComponent(BuildComponentType type)
         {
-            switch (type)
+            return type switch
             {
-                case BuildComponentType.ConfigCache:
-                    return (IBuildComponent)_configCache;
-
-                case BuildComponentType.LoggingService:
-                    return (IBuildComponent)_loggingService;
-
-                case BuildComponentType.RequestEngine:
-                    return (IBuildComponent)_requestEngine;
-
-                case BuildComponentType.TargetBuilder:
-                    return (IBuildComponent)_targetBuilder;
-
-                case BuildComponentType.ResultsCache:
-                    return (IBuildComponent)_resultsCache;
-
-                case BuildComponentType.RequestBuilder:
-                    return (IBuildComponent)_requestBuilder;
-
-                case BuildComponentType.SdkResolverService:
-                    return (IBuildComponent)_sdkResolverService;
-
-                default:
-                    throw new ArgumentException("Unexpected type " + type);
-            }
+                BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                BuildComponentType.RequestEngine => (IBuildComponent)_requestEngine,
+                BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
+                BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                _ => throw new ArgumentException("Unexpected type " + type),
+            };
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index ac5094dfb01..fd732589b22 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -69,10 +69,7 @@ public Scheduler_Tests()
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _scheduler = new Scheduler();
@@ -379,10 +376,7 @@ public void VerifyRequestOrderingDoesNotAffectNodeCreationCountWithInProcAndAnyR
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _host.BuildParameters.MaxNodeCount = 3;
@@ -543,10 +537,7 @@ public void VerifyNoOverCreationOfNodesWithBuildLoop()
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _host.BuildParameters.MaxNodeCount = 3;
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index f8597385549..5af65de88f9 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -1690,32 +1690,17 @@ public BuildParameters BuildParameters
             /// <returns>The component</returns>
             public IBuildComponent GetComponent(BuildComponentType type)
             {
-                switch (type)
+                return type switch
                 {
-                    case BuildComponentType.ConfigCache:
-                        return (IBuildComponent)_configCache;
-
-                    case BuildComponentType.LoggingService:
-                        return (IBuildComponent)_loggingService;
-
-                    case BuildComponentType.ResultsCache:
-                        return (IBuildComponent)_resultsCache;
-
-                    case BuildComponentType.RequestBuilder:
-                        return (IBuildComponent)_requestBuilder;
-
-                    case BuildComponentType.TaskBuilder:
-                        return (IBuildComponent)_taskBuilder;
-
-                    case BuildComponentType.TargetBuilder:
-                        return (IBuildComponent)_targetBuilder;
-
-                    case BuildComponentType.SdkResolverService:
-                        return (IBuildComponent)_sdkResolverService;
-
-                    default:
-                        throw new ArgumentException("Unexpected type " + type);
-                }
+                    BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                    BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                    BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                    BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                    BuildComponentType.TaskBuilder => (IBuildComponent)_taskBuilder,
+                    BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    _ => throw new ArgumentException("Unexpected type " + type),
+                };
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 7eedce9361e..54c1888e2dd 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -836,10 +836,7 @@ public void AfterTargetsShouldReportFailedBuild()
             // Since we're creating our own BuildManager, we need to make sure that the default 
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             string content = @"
 <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
@@ -897,10 +894,7 @@ public void AfterTargetsShouldReportFailedBuild()
                 {
                     NodeProviderInProc inProcNodeProvider = ((IBuildComponentHost)manager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
 
-                    if (inProcNodeProvider != null)
-                    {
-                        inProcNodeProvider.Dispose();
-                    }
+                    inProcNodeProvider?.Dispose();
                 }
             }
         }
@@ -1306,29 +1300,16 @@ public BuildParameters BuildParameters
             /// <returns>The component</returns>
             public IBuildComponent GetComponent(BuildComponentType type)
             {
-                switch (type)
+                return type switch
                 {
-                    case BuildComponentType.ConfigCache:
-                        return (IBuildComponent)_configCache;
-
-                    case BuildComponentType.LoggingService:
-                        return (IBuildComponent)_loggingService;
-
-                    case BuildComponentType.ResultsCache:
-                        return (IBuildComponent)_resultsCache;
-
-                    case BuildComponentType.RequestBuilder:
-                        return (IBuildComponent)_requestBuilder;
-
-                    case BuildComponentType.TaskBuilder:
-                        return (IBuildComponent)_taskBuilder;
-
-                    case BuildComponentType.SdkResolverService:
-                        return (IBuildComponent)_sdkResolverService;
-
-                    default:
-                        throw new ArgumentException("Unexpected type " + type);
-                }
+                    BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                    BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                    BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                    BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                    BuildComponentType.TaskBuilder => (IBuildComponent)_taskBuilder,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    _ => throw new ArgumentException("Unexpected type " + type),
+                };
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 6a9e26fbc0e..34522d98c12 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -1003,8 +1003,8 @@ private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetW
 
                     long symlinkWriteTimeTicks = symlinkWriteTime.ToFileTimeUtc();
 
-                    if (SetFileTime(handle, ref symlinkWriteTimeTicks, ref symlinkWriteTimeTicks,
-                            ref symlinkWriteTimeTicks) != true)
+                    if (!SetFileTime(handle, ref symlinkWriteTimeTicks, ref symlinkWriteTimeTicks,
+                            ref symlinkWriteTimeTicks))
                     {
                         Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
                     }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 99dbc5198e6..3fb73caa140 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -325,7 +325,7 @@ public void MSBuildLastTaskResult()
         }
 
         /// <summary>
-        /// Verifies that we can add "recursivedir" built-in metadata as target outputs. 
+        /// Verifies that we can add "recursivedir" built-in metadata as target outputs.
         /// This is to support wildcards in CreateItem. Allowing anything
         /// else could let the item get corrupt (inconsistent values for Filename and FullPath, for example)
         /// </summary>
@@ -408,7 +408,7 @@ public void OtherBuiltInMetadataErrors2()
         }
 
         /// <summary>
-        /// Verify that properties can be passed in to a task and out as items, despite the 
+        /// Verify that properties can be passed in to a task and out as items, despite the
         /// built-in metadata restrictions.
         /// </summary>
         [Fact]
@@ -468,7 +468,7 @@ public void IllegalFileCharsInItemsOutOfTask()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -493,7 +493,7 @@ public void NullMetadataOnOutputItems()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -551,7 +551,7 @@ public void SameAssemblyFromDifferentRelativePathsSharesAssemblyLoadContext()
 
 #if FEATURE_CODETASKFACTORY
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         public void NullMetadataOnOutputItems_InlineTask()
@@ -591,7 +591,7 @@ public void NullMetadataOnOutputItems_InlineTask()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "non-mono-tests")]
@@ -633,9 +633,9 @@ public void NullMetadataOnLegacyOutputItems_InlineTask()
 #endif
 
         /// <summary>
-        /// Validates that the defining project metadata is set (or not set) as expected in 
-        /// various task output-related operations, using a task built against the current 
-        /// version of MSBuild.  
+        /// Validates that the defining project metadata is set (or not set) as expected in
+        /// various task output-related operations, using a task built against the current
+        /// version of MSBuild.
         /// </summary>
         [Fact]
         public void ValidateDefiningProjectMetadataOnTaskOutputs()
@@ -645,9 +645,9 @@ public void ValidateDefiningProjectMetadataOnTaskOutputs()
         }
 
         /// <summary>
-        /// Validates that the defining project metadata is set (or not set) as expected in 
-        /// various task output-related operations, using a task built against V4 MSBuild, 
-        /// which didn't support the defining project metadata.  
+        /// Validates that the defining project metadata is set (or not set) as expected in
+        /// various task output-related operations, using a task built against V4 MSBuild,
+        /// which didn't support the defining project metadata.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -786,7 +786,7 @@ Task IRequestBuilderCallback.BlockOnTargetInProgress(int blockingRequestId, stri
  *********************************************************************************/
 
         /// <summary>
-        /// Helper method for validating the setting of defining project metadata on items 
+        /// Helper method for validating the setting of defining project metadata on items
         /// coming from task outputs
         /// </summary>
         private void ValidateDefiningProjectMetadataOnTaskOutputsHelper(string customTaskPath)
@@ -1116,7 +1116,7 @@ private class MockHost : MockLoggingService, IBuildComponentHost, IBuildComponen
 
             /// <summary>
             /// Constructor
-            /// 
+            ///
             /// UNDONE: Refactor this, and the other MockHosts, to use a common base implementation.  The duplication of the
             /// logging implementation alone is unfortunate.
             /// </summary>
@@ -1194,29 +1194,16 @@ LegacyThreadingData IBuildComponentHost.LegacyThreadingData
             /// <returns>The component</returns>
             public IBuildComponent GetComponent(BuildComponentType type)
             {
-                switch (type)
+                return type switch
                 {
-                    case BuildComponentType.ConfigCache:
-                        return (IBuildComponent)_configCache;
-
-                    case BuildComponentType.LoggingService:
-                        return (IBuildComponent)_loggingService;
-
-                    case BuildComponentType.ResultsCache:
-                        return (IBuildComponent)_resultsCache;
-
-                    case BuildComponentType.RequestBuilder:
-                        return (IBuildComponent)_requestBuilder;
-
-                    case BuildComponentType.TargetBuilder:
-                        return (IBuildComponent)_targetBuilder;
-
-                    case BuildComponentType.SdkResolverService:
-                        return (IBuildComponent)_sdkResolverService;
-
-                    default:
-                        throw new ArgumentException("Unexpected type " + type);
-                }
+                    BuildComponentType.ConfigCache => (IBuildComponent)_configCache,
+                    BuildComponentType.LoggingService => (IBuildComponent)_loggingService,
+                    BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
+                    BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
+                    BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    _ => throw new ArgumentException("Unexpected type " + type),
+                };
             }
 
             /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 3b383fe1a3f..5183dfd69b1 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -49,6 +49,5 @@ public void TaskNodesDieAfterBuild()
                 }
             }
         }
-
     }
 }
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 1e864a86580..7785cf334ff 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -334,7 +334,6 @@ public void TestItemsWithUnexpandableMetadata()
 </Project>", logger);
 
             sc.ToString().ShouldContain("\"a\\b\\%(Filename).c\"");
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index c6f15a9b190..89da8a06c20 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -417,7 +417,6 @@ public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
             Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
         }
 
-
         /// <summary>
         /// Test to make sure that even if the solution version corresponds to an existing sub-toolset version
         /// </summary>
@@ -501,7 +500,6 @@ public void SolutionPassesSubToolsetToChildProjects2()
                     EndGlobal
                 ";
 
-
             string solutionFileContentsDev11 = solutionFilePreambleV11 + solutionBodySingleProjectContents;
             string solutionFileContentsDev12 = solutionFilePreambleV12 + solutionBodySingleProjectContents;
 
@@ -620,7 +618,6 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
                 List<ILogger> loggers = new List<ILogger>(1);
                 loggers.Add(logger);
 
-
                 instances[0].Build(loggers);
                 logger.AssertLogContains(String.Format(".[{0}].", ObjectModelHelpers.MSBuildDefaultToolsVersion));
             }
@@ -630,7 +627,6 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
             }
         }
 
-
         /// <summary>
         /// Verify that we throw the appropriate error if the solution declares a dependency 
         /// on a project that doesn't exist.
@@ -1156,8 +1152,6 @@ public void Regress751742_SkipNonexistentProjects()
             }
         }
 
-
-
         /// <summary>
         /// Test that the in memory project created from a solution file exposes an MSBuild property which,
         /// if set when building a solution, will be specified as the ToolsVersion on the MSBuild task when
@@ -1206,7 +1200,7 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
                 {
                     foreach (ProjectTaskInstance childNode in target.Tasks)
                     {
-                        if (0 == String.Compare(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
                         {
                             string projectsParameter = childNode.GetParameter("Projects");
                             if (projectsParameter != "@(ProjectReference)")
@@ -1375,56 +1369,56 @@ public void TestDisambiguateProjectTargetName()
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
 
-            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
+            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
 
             // Check that the appropriate target is being passed to the child projects
             Assert.Null(buildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Clean", cleanTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Rebuild", rebuildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Publish", publishTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             // Check that the child projects in question are the members of the "ProjectReference" item group
             Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             // We should have only the four standard targets plus the two validation targets (ValidateSolutionConfiguration and ValidateToolsVersions).
@@ -1707,7 +1701,6 @@ public void TestPredictSolutionConfigurationName()
             Assert.Null(SolutionProjectGenerator.PredictActiveSolutionConfigurationName(solution, globalProperties));
         }
 
-
         /// <summary>
         /// Verifies that the SolutionProjectGenerator will correctly escape project file paths
         /// </summary>
@@ -1958,10 +1951,7 @@ public void BadFrameworkMonkierExpectBuildToFail()
                 // Since we're creating our own BuildManager, we need to make sure that the default 
                 // one has properly relinquished the inproc node
                 NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-                if (nodeProviderInProc != null)
-                {
-                    nodeProviderInProc.Dispose();
-                }
+                nodeProviderInProc?.Dispose();
 
                 File.WriteAllText(projectFilePath, solutionFileContents.Replace('\'', '"'));
                 MockLogger logger = new MockLogger(output);
@@ -1972,7 +1962,6 @@ public void BadFrameworkMonkierExpectBuildToFail()
                 parameters.ShutdownInProcNodeOnBuildFinish = true;
                 buildManager = new BuildManager();
 
-
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties["Configuration"] = "Release";
 
@@ -2050,10 +2039,7 @@ public void BadFrameworkMonkierExpectBuildToFail2()
                 // Since we're creating our own BuildManager, we need to make sure that the default 
                 // one has properly relinquished the inproc node
                 NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-                if (nodeProviderInProc != null)
-                {
-                    nodeProviderInProc.Dispose();
-                }
+                nodeProviderInProc?.Dispose();
 
                 File.WriteAllText(projectFilePath, solutionFileContents.Replace('\'', '"'));
                 MockLogger logger = new MockLogger(output);
@@ -2064,7 +2050,6 @@ public void BadFrameworkMonkierExpectBuildToFail2()
                 parameters.ShutdownInProcNodeOnBuildFinish = true;
                 buildManager = new BuildManager();
 
-
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties["Configuration"] = "Release";
 
@@ -2194,26 +2179,26 @@ public void CustomTargetNamesAreInInMetaproj()
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
@@ -2282,7 +2267,6 @@ public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference)
                 Assert.Equal(12, instances[0].TargetsCount);
             }
 
-
             instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
 
             Assert.Single(instances);
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 36d885c22fd..be35abeaf4e 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -266,7 +266,6 @@ public void VerifyTasksFilesAreInSortedOrder()
                 Assert.Equal(foundFiles[i], sortedTasksExpectedPaths[i]);
             }
 
-
             Assert.Equal(sortedOverrideExpectedPaths.Count, foundoverrideFiles.Length);
             for (int i = 0; i < foundoverrideFiles.Length; i++)
             {
@@ -942,7 +941,7 @@ private string[] getFiles(string path, string pattern)
             matches.RemoveAll(
                 delegate (string candidate)
                 {
-                    bool sameFolder = (0 == String.Compare(Path.GetDirectoryName(candidate),
+                    bool sameFolder = (String.Equals(Path.GetDirectoryName(candidate),
                                                            pathWithoutTrailingSlash,
                                                            StringComparison.OrdinalIgnoreCase));
                     return !sameFolder || !Regex.IsMatch(Path.GetFileName(candidate), finalPattern);
diff --git a/src/Build.UnitTests/EndToEndCondition_Tests.cs b/src/Build.UnitTests/EndToEndCondition_Tests.cs
index 36c2a3380aa..488441d6817 100644
--- a/src/Build.UnitTests/EndToEndCondition_Tests.cs
+++ b/src/Build.UnitTests/EndToEndCondition_Tests.cs
@@ -72,6 +72,5 @@ public void FalseComparisonsInvolvingMSBuildToolsVersion(string condition)
 
             result.OverallResult.ShouldBe(BuildResultCode.Success);
         }
-
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
index 3aeffe5ff37..c05f8d2b76e 100644
--- a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
@@ -81,7 +81,7 @@ private static void AssertLoggingEvents(
                 var projectFile = env.CreateFile().Path;
                 File.WriteAllText(projectFile, projectContents);
 
-                firstEvaluationLogger = firstEvaluationLogger ?? new MockLogger();
+                firstEvaluationLogger ??= new MockLogger();
                 collection.RegisterLogger(firstEvaluationLogger);
 
                 var project = new Project(projectFile, null, null, collection);
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 3d16f82ecf3..c144e3651c0 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -2463,7 +2463,7 @@ public void MSBuildExtensionsPath64Default()
 
             if (!string.IsNullOrEmpty(expected))
             {
-                expected = expected + @"\MSBuild";
+                expected += @"\MSBuild";
             }
 
             Project project = new Project();
@@ -4538,7 +4538,6 @@ public void VerifyPropertyTrackingLoggingDefault()
                         .AllBuildEvents
                         .OfType<PropertyInitialValueSetEventArgs>()
                         .ShouldBeEmpty();
-
                 });
         }
 
@@ -4568,7 +4567,6 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                         .AllBuildEvents
                         .OfType<PropertyInitialValueSetEventArgs>()
                         .ShouldBeEmpty();
-
                 });
         }
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index fff798db3a8..ba561084f8f 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3821,7 +3821,7 @@ public void Medley()
                     caughtException = true;
                 }
                 Assert.True(
-                        (success == false || caughtException == true),
+                        (!success || caughtException),
                         "FAILURE: Expected '" + errorTests[i] + "' to not parse or not be evaluated but it evaluated to '" + result + "'"
                     );
             }
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 2903374e8e0..660f95455c2 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -481,7 +481,7 @@ private static void VerifyAgainstCanonicalResults(string test, HashSet<string> a
             {
                 foreach (string result in actual)
                 {
-                    if (expected == null || !expected.Contains(result))
+                    if (expected?.Contains(result) != true)
                     {
                         messages.Add("Found <" + result + "> in <" + test + "> but it wasn't expected");
                     }
@@ -492,7 +492,7 @@ private static void VerifyAgainstCanonicalResults(string test, HashSet<string> a
             {
                 foreach (string expect in expected)
                 {
-                    if (actual == null || !actual.Contains(expect))
+                    if (actual?.Contains(expect) != true)
                     {
                         messages.Add("Did not find <" + expect + "> in <" + test + ">");
                     }
@@ -530,7 +530,7 @@ private static void VerifyAgainstCanonicalResults(string test, IDictionary actua
             {
                 foreach (DictionaryEntry result in actual)
                 {
-                    if (expected == null || !expected.Contains(result.Key))
+                    if (expected?.Contains(result.Key) != true)
                     {
                         messages.Add("Found <" + result.Key + "> in <" + test + "> but it wasn't expected");
                     }
@@ -541,7 +541,7 @@ private static void VerifyAgainstCanonicalResults(string test, IDictionary actua
             {
                 foreach (DictionaryEntry expect in expected)
                 {
-                    if (actual == null || !actual.Contains(expect.Key))
+                    if (actual?.Contains(expect.Key) != true)
                     {
                         messages.Add("Did not find <" + expect.Key + "> in <" + test + ">");
                     }
@@ -668,7 +668,6 @@ public void ExtractItemVectorExpressionsSingleExpression2()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo, ';')";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -686,7 +685,6 @@ public void ExtractItemVectorExpressionsSingleExpression3()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo->'%(Fullpath)')";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -723,7 +721,6 @@ public void ExtractItemVectorExpressionsSingleExpression5()
             List<ExpressionShredder.ItemExpressionCapture> expressions;
             ExpressionShredder.ItemExpressionCapture capture;
 
-
             expression = "@(Foo->Bar(a,b))";
             expressions = ExpressionShredder.GetReferencedItemExpressions(expression);
             capture = expressions[0];
@@ -1092,7 +1089,6 @@ public void ExtractItemVectorExpressionsMultipleExpression4()
             Assert.Equal("\"()\", $(Boo), `)(\"`", capture.Captures[1].FunctionArguments);
         }
 
-
         [Fact]
         public void ExtractItemVectorExpressionsMultipleExpression5()
         {
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index f9aa33d6321..f0564b0dcba 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -76,7 +76,7 @@ public void FragmentGlobsWorkAfterStateIsPartiallyInitializedByOtherOperations()
 
         private ProjectInstanceItemSpec CreateItemSpecFrom(string itemSpec, ProjectInstanceExpander expander, IElementLocation location = null)
         {
-            location = location ?? MockElementLocation.Instance;
+            location ??= MockElementLocation.Instance;
 
             return new ProjectInstanceItemSpec(itemSpec, expander, location, Path.GetDirectoryName(location.File));
         }
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index 659ce98e4bc..ed3030d0aa9 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -6,17 +6,20 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Text;
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Unittest;
 using Shouldly;
 using Xunit;
-using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using SdkResolverContext = Microsoft.Build.Framework.SdkResolverContext;
+using SdkResult = Microsoft.Build.Framework.SdkResult;
+using SdkResultFactory = Microsoft.Build.Framework.SdkResultFactory;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
 {
@@ -70,6 +73,11 @@ public class ProjectSdkImplicitImport_Tests : IDisposable
         private string _sdkPropsContent = "<Project><PropertyGroup><InitialImportProperty>Hello</InitialImportProperty></PropertyGroup></Project>";
         private string _sdkTargetsContent = "<Project><PropertyGroup><FinalImportProperty>World</FinalImportProperty></PropertyGroup></Project>";
         private string _projectInnerContents = @"<PropertyGroup><UsedToTestIfImplicitImportsAreInTheCorrectLocation>null</UsedToTestIfImplicitImportsAreInTheCorrectLocation></PropertyGroup>";
+        private const string SdkNamePropertyName = "MyTestSdkName";
+        private const string SdkNameProperty = "$(" + SdkNamePropertyName + ")";
+        private const string SdkVersionPropertyName = "MyTestSdkVersion";
+        private const string SdkVersionProperty = "$(" + SdkVersionPropertyName + ")";
+        private const string SdkExpectedVersion = "42.42.42-local";
 
         public ProjectSdkImplicitImport_Tests()
         {
@@ -230,7 +238,6 @@ public void ProjectWithSdkImportsIsCloneable(string projectFormatString)
             ProjectRootElement project = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
 
             project.DeepClone();
-
         }
 
         [Theory]
@@ -267,7 +274,6 @@ public void ProjectWithSdkImportsIsRemoveable(string projectFormatString)
             clone.DeepCopyFrom(project);
 
             clone.RemoveAllChildren();
-
         }
 
         /// <summary>
@@ -534,6 +540,257 @@ public void ImplicitImportsShouldHaveParsedSdkInfo(
             }
         }
 
+        internal class SdkPropertiesAreExpandedDataTemplate
+        {
+            public SdkPropertiesAreExpandedDataTemplate(string template, bool expectedMinimumVersionIsNull)
+            {
+                Template = template ?? throw new ArgumentNullException(nameof(template));
+                ExpectedMinimumVersion = expectedMinimumVersionIsNull ? null : string.Empty;
+            }
+
+            public string Template { get; }
+            public string ExpectedMinimumVersion { get; }
+
+            public override string ToString()
+            {
+                return Template switch
+                {
+                    ProjectTemplateSdkAsAttributeWithVersion => nameof(ProjectTemplateSdkAsAttributeWithVersion),
+                    ProjectTemplateSdkAsElementWithVersion => nameof(ProjectTemplateSdkAsElementWithVersion),
+                    ProjectTemplateSdkAsExplicitImportWithVersion => nameof(ProjectTemplateSdkAsExplicitImportWithVersion),
+                    _ => "<unknown>"
+                };
+            }
+        }
+
+        internal class SdkPropertiesAreExpandedCase
+        {
+            public SdkPropertiesAreExpandedCase(SdkReferencePropertyExpansionMode? mode,
+                SdkPropertiesAreExpandedDataTemplate template, bool setName, bool setVersion, bool expectedSuccess)
+            {
+                Mode = mode;
+                Template = template ?? throw new ArgumentNullException(nameof(template));
+                ExpectedSuccess = expectedSuccess;
+                SetNameProperty = setName;
+                SetVersionProperty = setVersion;
+            }
+
+            public SdkReferencePropertyExpansionMode? Mode { get; }
+            public SdkPropertiesAreExpandedDataTemplate Template { get; }
+            public string TemplateName { get; set; } = SdkName;
+            public string TemplateVersion { get; set; } = SdkExpectedVersion;
+            public bool SetNameProperty { get; }
+            public bool SetVersionProperty { get; }
+            public bool ExpectedSuccess { get; }
+
+            public override string ToString()
+            {
+                var result = new StringBuilder(256);
+                if (Mode.HasValue)
+                    result.Append(Mode);
+                else
+                    result.Append($"{nameof(Mode)}: <null>");
+
+                result.Append($", {Template}, {nameof(TemplateName)}: {TemplateName}, {nameof(TemplateVersion)}: {TemplateVersion}");
+
+                if (SetNameProperty)
+                    result.Append(", SetName");
+                if (SetVersionProperty)
+                    result.Append(", SetVersion");
+                if (ExpectedSuccess)
+                    result.Append(", ExpectedSuccess");
+
+                return result.ToString();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(SdkPropertiesAreExpandedData))]
+        internal void SdkPropertiesAreExpanded(SdkPropertiesAreExpandedCase data)
+        {
+            _env.SetEnvironmentVariable("MSBuildSDKsPath", _testSdkRoot);
+            _env.SetEnvironmentVariable("MSBUILD_SDKREFERENCE_PROPERTY_EXPANSION_MODE", data.Mode.ToString());
+
+            File.WriteAllText(_sdkPropsPath, _sdkPropsContent);
+            File.WriteAllText(_sdkTargetsPath, _sdkTargetsContent);
+
+            var projectContents = string.Format(
+                data.Template.Template,
+                data.TemplateName,
+                _projectInnerContents,
+                data.TemplateVersion,
+                null
+            );
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(
+                new MockExpandedSdkResolver(_testSdkDirectory)
+            );
+
+            void AddProperty(string name, string value) =>
+                (projectOptions.GlobalProperties ??= new Dictionary<string, string>()).Add(name, value);
+
+            if (data.SetNameProperty)
+                AddProperty(SdkNamePropertyName, SdkName);
+
+            if (data.SetVersionProperty)
+                AddProperty(SdkVersionPropertyName, SdkExpectedVersion);
+
+            using var xmlReader = XmlReader.Create(new StringReader(projectContents));
+
+            if (!data.ExpectedSuccess)
+                projectOptions.LoadSettings |= ProjectLoadSettings.IgnoreMissingImports;
+
+            var project = Project.FromXmlReader(xmlReader, projectOptions);
+
+            if (data.ExpectedSuccess)
+            {
+                var expectedSdkPath = Path.GetDirectoryName(_sdkPropsPath);
+
+                // self-consistency check
+                expectedSdkPath.ShouldBe(Path.GetDirectoryName(_sdkTargetsPath));
+
+                var expectedSdkReferenceRaw = new SdkReference(
+                    data.TemplateName,
+                    data.TemplateVersion,
+                    data.Template.ExpectedMinimumVersion
+                );
+
+                var expectedSdkReference = new SdkReference(
+                    SdkName,
+                    SdkExpectedVersion,
+                    data.Template.ExpectedMinimumVersion
+                );
+
+                project.Imports.Count.ShouldBe(2);
+
+                foreach (var import in project.Imports)
+                {
+                    import.ImportingElement.SdkReference.ShouldBe(expectedSdkReferenceRaw);
+                    import.SdkResult.Success.ShouldBeTrue();
+                    import.SdkResult.SdkReference.ShouldBe(expectedSdkReference);
+                    import.SdkResult.Path.ShouldBe(expectedSdkPath);
+                    import.SdkResult.Version.ShouldBe(expectedSdkReference.Version);
+                }
+            }
+            else
+            {
+                project.Imports.Count.ShouldBe(0);
+            }
+        }
+
+        public static IEnumerable<object[]> SdkPropertiesAreExpandedData
+        {
+            get
+            {
+                static IEnumerable<SdkReferencePropertyExpansionMode?> Modes()
+                {
+                    yield return null;
+                    yield return SdkReferencePropertyExpansionMode.NoExpansion;
+                    yield return SdkReferencePropertyExpansionMode.DefaultExpand;
+                    yield return SdkReferencePropertyExpansionMode.ExpandUnescape;
+                    yield return SdkReferencePropertyExpansionMode.ExpandLeaveEscaped;
+                }
+
+                static IEnumerable<(SdkPropertiesAreExpandedDataTemplate, bool setName, bool setVersion)> Templates()
+                {
+                    var templates = new[]
+                    {
+                        new SdkPropertiesAreExpandedDataTemplate(
+                            ProjectTemplateSdkAsAttributeWithVersion, true
+                        ),
+                        new SdkPropertiesAreExpandedDataTemplate(
+                            ProjectTemplateSdkAsElementWithVersion, false
+                        ),
+                        new SdkPropertiesAreExpandedDataTemplate(
+                            ProjectTemplateSdkAsExplicitImportWithVersion, false
+                        )
+                    };
+
+                    foreach (var template in templates)
+                    {
+                        yield return (template, false, false);
+                        yield return (template, false, true);
+                        yield return (template, true, false);
+                        yield return (template, true, true);
+                    }
+                }
+
+                foreach (var mode in Modes())
+                {
+                    var shouldExpand = mode != SdkReferencePropertyExpansionMode.NoExpansion;
+
+                    foreach (var (template, setName, setVersion) in Templates())
+                    {
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(mode, template, setName, setVersion, true)
+                        };
+
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(
+                                mode, template, setName, setVersion, shouldExpand && setName
+                            )
+                            {
+                                TemplateName = SdkNameProperty
+                            }
+                        };
+
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(
+                                mode, template, setName, setVersion, shouldExpand && setVersion
+                            )
+                            {
+                                TemplateVersion = SdkVersionProperty
+                            }
+                        };
+
+                        yield return new object[]
+                        {
+                            new SdkPropertiesAreExpandedCase(
+                                mode, template, setName, setVersion, shouldExpand && setName && setVersion
+                            )
+                            {
+                                TemplateName = SdkNameProperty,
+                                TemplateVersion = SdkVersionProperty
+                            }
+                        };
+                    }
+                }
+            }
+        }
+
+        private sealed class MockExpandedSdkResolver : SdkResolver
+        {
+            private const string ResolverName = nameof(MockExpandedSdkResolver);
+            private const string ErrorName = ResolverName + "/Error/" + nameof(SdkReference.Name);
+            private const string ErrorVersion = ResolverName + "/Error/" + nameof(SdkReference.Version);
+
+            public MockExpandedSdkResolver(string resolvedPath)
+            {
+                ResolvedPath = resolvedPath;
+            }
+
+            public override string Name => ResolverName;
+
+            public override int Priority => 1;
+
+            public string ResolvedPath { get; }
+
+            public override SdkResult Resolve(SdkReference sdk, SdkResolverContext resolverContext,
+                                              SdkResultFactory factory)
+            {
+                return sdk.Name switch
+                {
+                    SdkName when sdk.Version == SdkExpectedVersion =>
+                    factory.IndicateSuccess(ResolvedPath, SdkExpectedVersion),
+                    SdkName => factory.IndicateFailure(new[] {ErrorVersion}),
+                    _ => factory.IndicateFailure(new[] {ErrorName})
+                };
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index 562516cb812..ed87a86ab7b 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -468,7 +468,6 @@ public void SdkResolverCanReturnSpecialCharacters()
 
             _logger.ErrorCount.ShouldBe(0);
             _logger.WarningCount.ShouldBe(0);
-
         }
 
         public void Dispose()
diff --git a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
index dec5777d189..93667018055 100644
--- a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
@@ -413,7 +413,6 @@ public void Dispose()
             {
                 if (File.Exists(file)) File.Delete(file);
             }
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 7358498e544..0fefab60bc5 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -13,8 +13,6 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 
-
-
 using EventSourceSink = Microsoft.Build.BackEnd.Logging.EventSourceSink;
 using Project = Microsoft.Build.Evaluation.Project;
 using Xunit;
@@ -66,7 +64,6 @@ public void BasicNoExistingFile()
                 SetUpFileLoggerAndLogMessage("logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "message here");
 
-
                 byte[] content = ReadRawBytes(log);
                 Assert.Equal((byte)109, content[0]); // 'm'
             }
diff --git a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
index e839f35708a..e44014ce596 100644
--- a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
+++ b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
@@ -355,7 +355,6 @@ public void UncPatternTrailingSlash()
 
             FileUtilitiesRegex.IsUncPattern(winDirectory).ShouldBe(false);
             FileUtilitiesRegex.IsUncPattern(unixDirectory).ShouldBe(false);
-
         }
 
         [Fact]
@@ -366,7 +365,6 @@ public void StartWithUncPatternTrailingSlash_LegacyRegex()
 
             StartsWithUncPattern.IsMatch(winDirectory).ShouldBeTrue();
             StartsWithUncPattern.IsMatch(unixDirectory).ShouldBeTrue();
-
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 6ae0368da58..8ffc859accd 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -204,7 +204,7 @@ public void GraphConstructionCanLoadEntryPointsFromSolution(
             AssertSolutionBasedGraph(edges, currentSolutionConfiguration, solutionConfigurations);
         }
 
-        [Theory]
+        [Theory(Skip = "hangs in CI, can't repro locally: https://github.com/dotnet/msbuild/issues/5453")]
         [MemberData(nameof(GraphsWithUniformSolutionConfigurations))]
         public void SolutionBasedGraphCanMatchProjectSpecificConfigurations(
             Dictionary<int, int[]> edges,
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 4cde1fc90bc..844c88dc8a8 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -77,7 +77,7 @@ public static void AssertOuterBuildAsNonRoot(
 
         public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             IsNotMultitargeting(node).ShouldBeTrue();
             node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 45734a1188c..a0b6ad62da7 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -1516,7 +1516,7 @@ private static void AssertOuterBuildAsRoot(
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index aab69e7f57c..73013170d5e 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -422,7 +422,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
             // (current node, expected output dictionary) -> actual expected output for current node
             Func<ProjectGraphNode, ExpectedNodeBuildOutput, string[]> expectedOutputProducer = null)
         {
-            expectedOutputProducer = expectedOutputProducer ?? ((node, expectedOutputs) => expectedOutputs[node]);
+            expectedOutputProducer ??= ((node, expectedOutputs) => expectedOutputs[node]);
 
             var results = new Dictionary<string, (BuildResult Result, MockLogger Logger)>(topoSortedNodes.Count);
 
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 2a5495dc0ee..0bd541928cd 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -271,7 +271,6 @@ public void TestNonContradictoryAffinityAllowed()
         /// <summary>
         /// Test which ensures that setting a host object for a project with an out-of-proc affinity throws.
         /// </summary>
-
         [Fact]
         public void TestContraditcoryHostObjectCausesException_OutOfProc()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index 6743baf1a8d..6b294012cbb 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -285,7 +285,6 @@ public void UsingExplicitToolsVersionShouldBeFalseWhenNoToolsetIsReferencedInPro
                 );
 
             projectInstance.UsingDifferentToolsVersionFromProjectFile.ShouldBeFalse();
-
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
index 103589548de..808c0edc4a7 100644
--- a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
@@ -66,7 +66,7 @@ public void ProjectTaskInstanceCanSerializeViaTranslator(
             IDictionary<string, (string, MockElementLocation)> parameters,
             List<ProjectTaskInstanceChild> outputs)
         {
-            parameters = parameters ?? new Dictionary<string, (string, MockElementLocation)>();
+            parameters ??= new Dictionary<string, (string, MockElementLocation)>();
 
             var parametersCopy = new Dictionary<string, (string, ElementLocation)>(parameters.Count);
             foreach (var param in parameters)
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
index fbb708842c8..d1c62096ca6 100644
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
@@ -62,7 +62,6 @@ public static IEnumerable<object[]> GetProfilerResults()
                 {EvaluationLocation.CreateLocationForGlob(null, EvaluationPass.InitialProperties, "1", "myFile", 42, "glob description"),
                 new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2)}
             }) };
-
         }
     }
 }
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 3b87e2044a5..233957ac6c2 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -112,7 +112,7 @@ public string BuildSolution()
                     Guid.NewGuid()
                         .ToString("B")));
 
-            if (SolutionDependencies != null && SolutionDependencies.Length > 0)
+            if (SolutionDependencies?.Length > 0)
             {
                 foreach (var (parent, dependency) in SolutionDependencies)
                 {
@@ -123,7 +123,7 @@ public string BuildSolution()
                 }
             }
 
-            if (SolutionDependenciesProjectNameToGuids!= null && SolutionDependenciesProjectNameToGuids.Length > 0)
+            if (SolutionDependenciesProjectNameToGuids?.Length > 0)
             {
                 foreach (var (parent, dependencyGuids) in SolutionDependenciesProjectNameToGuids)
                 {
@@ -132,7 +132,7 @@ public string BuildSolution()
                 }
             }
 
-            ProjectConfigurations = ProjectConfigurations ?? projectInfos.ToDictionary(
+            ProjectConfigurations ??= projectInfos.ToDictionary(
                 p => p.Key,
                 p => SolutionConfigurationPlatforms.ToDictionary(
                     sc => sc,
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index f6c62d77ccd..2219cc6bb72 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -64,26 +64,6 @@ public void GetTextFromTextNodeWithXmlComment7()
             // Should get XML; note space after x added
             Assert.Equal("<!-- bar; baz; --><!-- bar --><x />", xmlContents);
         }
-
-        [Fact]
-        public void HandshakesDiffer()
-        {
-            int numHandshakeOptions = (int)Math.Pow(2, Enum.GetNames(typeof(HandshakeOptions)).Length - 1);
-            Dictionary<long, int> handshakes = new Dictionary<long, int>();
-            for (int i = 0; i < numHandshakeOptions; i++)
-            {
-                long nextKey = CommunicationsUtilities.GetHostHandshake((HandshakeOptions)i);
-                if (handshakes.TryGetValue(nextKey, out int collision))
-                {
-                    _output.WriteLine("There was a collision between {0} and {1}.", collision, i);
-                }
-                else
-                {
-                    handshakes.Add(nextKey, i);
-                }
-            }
-            handshakes.Count.ShouldBe(numHandshakeOptions, "two or more combinations of handshake options hashed to the same value");
-        }
     }
 
     public class UtilitiesTestReadOnlyLoad : UtilitiesTest
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 6cde0e901df..9f5b6fa7f06 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -276,7 +276,6 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -296,7 +295,6 @@ public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -319,7 +317,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -340,7 +337,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
@@ -361,7 +357,6 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 144ded7db93..c8a2838afbb 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -816,10 +816,7 @@ public void EndBuild()
                     Reset();
                     _buildManagerState = BuildManagerState.Idle;
 
-                    if (_threadException != null)
-                    {
-                        _threadException.Throw();
-                    }
+                    _threadException?.Throw();
 
                     if (BuildParameters.DumpOpportunisticInternStats)
                     {
@@ -1294,7 +1291,7 @@ private void HandleExecuteSubmissionException(BuildSubmission submission, Except
         {
             if (ex is InvalidProjectFileException projectException)
             {
-                if (projectException.HasBeenLogged != true)
+                if (!projectException.HasBeenLogged)
                 {
                     BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                     ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
@@ -1321,7 +1318,7 @@ private void HandleExecuteSubmissionException(GraphBuildSubmission submission, E
         {
             if (ex is InvalidProjectFileException projectException)
             {
-                if (projectException.HasBeenLogged != true)
+                if (!projectException.HasBeenLogged)
                 {
                     BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                     ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
@@ -1373,7 +1370,7 @@ private void IssueBuildSubmissionToScheduler(BuildSubmission submission, bool al
                 InvalidProjectFileException projectException = ex as InvalidProjectFileException;
                 if (projectException != null)
                 {
-                    if (projectException.HasBeenLogged != true)
+                    if (!projectException.HasBeenLogged)
                     {
                         BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                         ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, projectException);
@@ -1529,7 +1526,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     foreach (var innerException in aggregateException.InnerExceptions)
                     {
                         var projectException = (InvalidProjectFileException) innerException;
-                        if (projectException.HasBeenLogged != true)
+                        if (!projectException.HasBeenLogged)
                         {
                             BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                             ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, projectException);
@@ -2367,7 +2364,7 @@ private static I ExpectPacketType<I>(INodePacket packet, NodePacketType expected
         /// </summary>
         private void SetOverallResultIfWarningsAsErrors(BuildResult result)
         {
-            if (result != null && result.OverallResult == BuildResultCode.Success)
+            if (result?.OverallResult == BuildResultCode.Success)
             {
                 ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 8446b48cae0..57a7c8995b2 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -192,7 +192,7 @@ public void WaitForConfiguration(BuildRequestConfiguration configuration)
         {
             ErrorUtilities.VerifyThrow(configuration.WasGeneratedByNode, "Configuration has already been resolved.");
 
-            _unresolvedConfigurationsToIssue = _unresolvedConfigurationsToIssue ?? new List<BuildRequestConfiguration>();
+            _unresolvedConfigurationsToIssue ??= new List<BuildRequestConfiguration>();
             _unresolvedConfigurationsToIssue.Add(configuration);
         }
 
@@ -230,7 +230,7 @@ public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId)
         {
             lock (GlobalLock)
             {
-                if (_unresolvedConfigurations == null || !_unresolvedConfigurations.ContainsKey(unresolvedConfigId))
+                if (_unresolvedConfigurations?.ContainsKey(unresolvedConfigId) != true)
                 {
                     return false;
                 }
@@ -369,7 +369,7 @@ public void ReportResult(BuildResult result)
                 if (addResults)
                 {
                     // Update the local results record
-                    _outstandingResults = _outstandingResults ?? new Dictionary<int, BuildResult>();
+                    _outstandingResults ??= new Dictionary<int, BuildResult>();
                     ErrorUtilities.VerifyThrow(!_outstandingResults.ContainsKey(result.NodeRequestId), "Request already contains results.");
                     _outstandingResults.Add(result.NodeRequestId, result);
                 }
@@ -508,7 +508,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
 
                 if (newRequest.IsConfigurationResolved)
                 {
-                    _outstandingRequests = _outstandingRequests ?? new Dictionary<int, BuildRequest>();
+                    _outstandingRequests ??= new Dictionary<int, BuildRequest>();
 
                     ErrorUtilities.VerifyThrow(!_outstandingRequests.ContainsKey(newRequest.NodeRequestId), "Already waiting for local request {0}", newRequest.NodeRequestId);
                     _outstandingRequests.Add(newRequest.NodeRequestId, newRequest);
@@ -516,7 +516,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
                 else
                 {
                     ErrorUtilities.VerifyThrow(addToIssueList, "Requests with unresolved configurations should always be added to the issue list.");
-                    _unresolvedConfigurations = _unresolvedConfigurations ?? new Dictionary<int, List<BuildRequest>>();
+                    _unresolvedConfigurations ??= new Dictionary<int, List<BuildRequest>>();
 
                     if (!_unresolvedConfigurations.ContainsKey(newRequest.ConfigurationId))
                     {
@@ -528,7 +528,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
 
                 if (addToIssueList)
                 {
-                    _requestsToIssue = _requestsToIssue ?? new List<BuildRequest>();
+                    _requestsToIssue ??= new List<BuildRequest>();
                     _requestsToIssue.Add(newRequest);
                 }
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
index dfc0b880b02..176c2bd91e2 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
@@ -24,6 +24,7 @@ internal class FullyQualifiedBuildRequest
         /// <param name="config">The configuration to use for the request.</param>
         /// <param name="targets">The set of targets to build.</param>
         /// <param name="resultsNeeded">Whether or not to wait for the results of this request.</param>
+        /// <param name="skipStaticGraphIsolationConstraints">Whether to skip the constraints of static graph isolation.</param>
         /// <param name="flags">Flags specified for the build request.</param>
         public FullyQualifiedBuildRequest(
             BuildRequestConfiguration config,
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index 2645a3feba6..7fe7868a587 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -72,7 +72,7 @@ public BuildRequestConfiguration this[int configId]
         /// <param name="config">The configuration to add.</param>
         public void AddConfiguration(BuildRequestConfiguration config)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(config, "config");
+            ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             ErrorUtilities.VerifyThrow(config.ConfigurationId != 0, "Invalid configuration ID");
 
             lock (_lockObject)
@@ -106,7 +106,7 @@ public void RemoveConfiguration(int configId)
         /// <returns>A matching configuration if one exists, null otherwise.</returns>
         public BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(config, "config");
+            ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             return GetMatchingConfiguration(new ConfigurationMetadata(config));
         }
 
@@ -117,7 +117,7 @@ public BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfigurat
         /// <returns>A matching configuration if one exists, null otherwise.</returns>
         public BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(configMetadata, "configMetadata");
+            ErrorUtilities.VerifyThrowArgumentNull(configMetadata, nameof(configMetadata));
             lock (_lockObject)
             {
                 int configId;
@@ -328,7 +328,7 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
         /// <param name="host">The build component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 64db389a8ed..cfbcaff2aeb 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -230,10 +230,7 @@ public void ClearResultsForConfiguration(int configurationId)
                 BuildResult removedResult;
                 _resultsByConfiguration.TryRemove(configurationId, out removedResult);
 
-                if (removedResult != null)
-                {
-                    removedResult.ClearCachedFiles();
-                }
+                removedResult?.ClearCachedFiles();
             }
         }
 
@@ -277,7 +274,7 @@ public void WriteResultsToDisk()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 45b9dc30bf0..956a7f080f6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -100,7 +100,7 @@ internal class NodeEndpointInProc : INodeEndpoint
         /// <param name="host">The component host.</param>
         private NodeEndpointInProc(EndpointMode commMode, IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
 
             _status = LinkStatus.Inactive;
             _mode = commMode;
@@ -161,7 +161,7 @@ public LinkStatus LinkStatus
         /// <param name="factory">Unused</param>
         public void Listen(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrowInternalNull(factory, "factory");
+            ErrorUtilities.VerifyThrowInternalNull(factory, nameof(factory));
             _packetFactory = factory;
 
             // Initialize our thread in async mode so we are ready when the Node-side endpoint "connects".
@@ -179,7 +179,7 @@ public void Listen(INodePacketFactory factory)
         /// <param name="factory">Unused</param>
         public void Connect(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrowInternalNull(factory, "factory");
+            ErrorUtilities.VerifyThrowInternalNull(factory, nameof(factory));
             _packetFactory = factory;
 
             // Set up asynchronous packet pump, if necessary.
@@ -324,7 +324,7 @@ private void ChangeLinkStatus(LinkStatus newStatus)
         /// <param name="packet">The packet to be transmitted.</param>
         private void EnqueuePacket(INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(_mode == EndpointMode.Asynchronous, "EndPoint mode is synchronous, should be asynchronous");
             ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
             ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index a30017ca426..132cb665bb1 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
@@ -31,13 +32,14 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
         /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         /// <param name="host">The component host.</param>
         /// <param name="enableReuse">Whether this node may be reused for a later build.</param>
+        /// <param name="lowPriority">Whether this node is low priority.</param>
         internal NodeEndpointOutOfProc(
             string pipeName, 
             IBuildComponentHost host,
             bool enableReuse,
             bool lowPriority)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             _componentHost = host;
             _enableReuse = enableReuse;
             _lowPriority = lowPriority;
@@ -50,17 +52,9 @@ internal NodeEndpointOutOfProc(
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override long GetHostHandshake()
+        protected override Handshake GetHandshake()
         {
-            return NodeProviderOutOfProc.GetHostHandshake(_enableReuse, _lowPriority);
-        }
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected override long GetClientHandshake()
-        {
-            return NodeProviderOutOfProc.GetClientHandshake(_enableReuse, _lowPriority);
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess, nodeReuse: _enableReuse, lowPriority: _lowPriority));
         }
 
         #region Structs
diff --git a/src/Build/BackEnd/Components/Communications/NodeInfo.cs b/src/Build/BackEnd/Components/Communications/NodeInfo.cs
index b621994a31f..d94cccba51c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeInfo.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeInfo.cs
@@ -87,19 +87,13 @@ public bool HasConfiguration(int configId)
         /// </summary>
         internal bool CanServiceRequestWithAffinity(NodeAffinity nodeAffinity)
         {
-            switch (nodeAffinity)
+            return nodeAffinity switch
             {
-                case NodeAffinity.Any:
-                    return true;
-
-                case NodeAffinity.InProc:
-                    return _providerType == NodeProviderType.InProc;
-
-                case NodeAffinity.OutOfProc:
-                    return _providerType != NodeProviderType.InProc;
-            }
-
-            return true;
+                NodeAffinity.Any => true,
+                NodeAffinity.InProc => _providerType == NodeProviderType.InProc,
+                NodeAffinity.OutOfProc => _providerType != NodeProviderType.InProc,
+                _ => true,
+            };
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index e0c45681ff0..602a5d790ec 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -157,15 +157,9 @@ public void ShutdownConnectedNodes(bool enableReuse)
 
             _nodesShutdown = true;
 
-            if (null != _inProcNodeProvider)
-            {
-                _inProcNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _inProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
 
-            if (null != _outOfProcNodeProvider)
-            {
-                _outOfProcNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _outOfProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
         /// <summary>
@@ -174,10 +168,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         public void ShutdownAllNodes()
         {
             // don't worry about inProc
-            if (null != _outOfProcNodeProvider)
-            {
-                _outOfProcNodeProvider.ShutdownAllNodes();
-            }
+            _outOfProcNodeProvider?.ShutdownAllNodes();
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 8bfc4cd604e..49cca2f7e4d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -151,7 +151,7 @@ public void ShutdownComponent()
         public void SendData(int nodeId, INodePacket packet)
         {
             ErrorUtilities.VerifyThrowArgumentOutOfRange(nodeId == _inProcNodeId, "node");
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
 
             if (null == _inProcNode)
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 63ca1cadc74..5fd62ffed9b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -63,19 +63,10 @@ public int AvailableNodes
         /// </summary>
         /// <param name="enableNodeReuse">Is reuse of build nodes allowed?</param>
         /// <param name="enableLowPriority">Is the build running at low priority?</param>
-        internal static long GetHostHandshake(bool enableNodeReuse, bool enableLowPriority)
+        internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
             CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
-            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
-        }
-
-        /// <summary>
-        /// Magic number sent by the client to the host during the handshake.
-        /// Munged version of the host handshake.
-        /// </summary>
-        internal static long GetClientHandshake(bool enableNodeReuse, bool enableLowPriority)
-        {
-            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
         }
 
         /// <summary>
@@ -83,7 +74,7 @@ internal static long GetClientHandshake(bool enableNodeReuse, bool enableLowPrio
         /// </summary>
         public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
             if (_nodeContexts.Count == ComponentHost.BuildParameters.MaxNodeCount)
             {
@@ -100,8 +91,8 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             // Make it here.
             CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
 
-            long hostHandShake = NodeProviderOutOfProc.GetHostHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority);
-            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandShake, NodeProviderOutOfProc.GetClientHandshake(ComponentHost.BuildParameters.EnableNodeReuse, ComponentHost.BuildParameters.LowPriority), NodeContextTerminated);
+            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
 
             if (null != context)
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 5c14d78a545..cae8c0b3b5e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -76,7 +76,7 @@ protected IBuildComponentHost ComponentHost
         /// <param name="packet">The packet to send.</param>
         protected void SendData(NodeContext context, INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             context.SendData(packet);
         }
 
@@ -92,19 +92,14 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
 
             foreach (NodeContext nodeContext in contextsToShutDown)
             {
-                if (null != nodeContext)
-                {
-                    nodeContext.SendData(new NodeBuildComplete(enableReuse));
-                }
+                nodeContext?.SendData(new NodeBuildComplete(enableReuse));
             }
         }
 
         /// <summary>
         /// Shuts down all of the managed nodes permanently.
         /// </summary>
-        /// <param name="hostHandshake">host handshake key</param>
-        /// <param name="hostHandshakeWithLowPriority">host handshake key with low priority added</param>
-        /// <param name="clientHandshake">client handshake key</param>
+        /// <param name="nodeReuse">Whether to reuse the node</param>
         /// <param name="terminateNode">Delegate used to tell the node provider that a context has terminated</param>
         protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate terminateNode)
         {
@@ -126,12 +121,12 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, false), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, false));
+                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
 
                 if (null == nodeStream)
                 {
                     // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHostHandshake(nodeReuse, true), NodeProviderOutOfProc.GetClientHandshake(nodeReuse, true));
+                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
                 }
 
                 if (null != nodeStream)
@@ -149,7 +144,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
         /// Finds or creates a child process which can act as a node.
         /// </summary>
         /// <returns>The pipe stream representing the node.</returns>
-        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, long hostHandshake, long clientHandshake, NodeContextTerminateDelegate terminateNode)
+        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextTerminateDelegate terminateNode)
         {
 #if DEBUG
             if (Execution.BuildManager.WaitForDebugger)
@@ -189,7 +184,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     }
 
                     // Get the full context of this inspection so that we can always skip this process when we have the same taskhost context
-                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, clientHandshake, nodeProcess.Id);
+                    string nodeLookupKey = GetProcessesToIgnoreKey(hostHandshake, nodeProcess.Id);
                     if (_processesToIgnore.Contains(nodeLookupKey))
                     {
                         continue;
@@ -199,7 +194,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     _processesToIgnore.Add(nodeLookupKey);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake, clientHandshake);
+                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake);
                     if (nodeStream != null)
                     {
                         // Connection successful, use this node.
@@ -243,14 +238,14 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
 
                 // Create the node process
                 int msbuildProcessId = LaunchNode(msbuildLocation, commandLineArgs);
-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, clientHandshake, msbuildProcessId));
+                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcessId));
 
                 // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
                 // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
                 // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
                 // Now try to connect to it.
-                Stream nodeStream = TryConnectToProcess(msbuildProcessId, TimeoutForNewNodeCreation, hostHandshake, clientHandshake);
+                Stream nodeStream = TryConnectToProcess(msbuildProcessId, TimeoutForNewNodeCreation, hostHandshake);
                 if (nodeStream != null)
                 {
                     // Connection successful, use this node.
@@ -293,9 +288,9 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
         /// Generate a string from task host context and the remote process to be used as key to lookup processes we have already
         /// attempted to connect to or are already connected to
         /// </summary>
-        private string GetProcessesToIgnoreKey(long hostHandshake, long clientHandshake, int nodeProcessId)
+        private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId)
         {
-            return hostHandshake.ToString(CultureInfo.InvariantCulture) + "|" + clientHandshake.ToString(CultureInfo.InvariantCulture) + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
+            return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
         }
 
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -322,7 +317,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         /// <summary>
         /// Attempts to connect to the specified process.
         /// </summary>
-        private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHandshake, long clientHandshake)
+        private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
             string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
@@ -348,26 +343,26 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHand
                     // remote node could set the owner to something else would also let it change owners on other objects, so
                     // this would be a security flaw upstream of us.
                     ValidateRemotePipeSecurityOnWindows(nodeStream);
-
                 }
 #endif
 
-                CommunicationsUtilities.Trace("Writing handshake to pipe {0}", pipeName);
-                nodeStream.WriteLongForHandshake(hostHandshake);
+                int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+                for (int i = 0; i < handshakeComponents.Length; i++)
+                {
+                    CommunicationsUtilities.Trace("Writing handshake part {0} to pipe {1}", i, pipeName);
+                    nodeStream.WriteIntForHandshake(handshakeComponents[i]);
+                }
+
+                // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
+                nodeStream.WriteEndOfHandshakeSignal();
 
                 CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
+
 #if NETCOREAPP2_1 || MONO
-                long handshake = nodeStream.ReadLongForHandshake(timeout);
+                nodeStream.ReadEndOfHandshakeSignal(true, timeout);
 #else
-                long handshake = nodeStream.ReadLongForHandshake();
+                nodeStream.ReadEndOfHandshakeSignal(true);
 #endif
-
-                if (handshake != clientHandshake)
-                {
-                    CommunicationsUtilities.Trace("Handshake failed. Received {0} from client not {1}. Probably the client is a different MSBuild build.", handshake, clientHandshake);
-                    throw new InvalidOperationException();
-                }
-
                 // We got a connection.
                 CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
                 return nodeStream;
@@ -382,10 +377,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHand
                 CommunicationsUtilities.Trace("Failed to connect to pipe {0}. {1}", pipeName, e.Message.TrimEnd());
 
                 // If we don't close any stream, we might hang up the child
-                if (nodeStream != null)
-                {
-                    nodeStream.Dispose();
-                }
+                nodeStream?.Dispose();
             }
 
             return null;
@@ -397,7 +389,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHand
         private int LaunchNode(string msbuildLocation, string commandLineArgs)
         {
             // Should always have been set already.
-            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, "msbuildLocation");
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
 
             if (!FileSystems.Default.FileExists(msbuildLocation))
             {
@@ -430,12 +422,12 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
                     startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
                     startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
                     startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
-                    creationFlags = creationFlags | BackendNativeMethods.CREATENOWINDOW;
+                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
                 }
             }
             else
             {
-                creationFlags = creationFlags | BackendNativeMethods.CREATE_NEW_CONSOLE;
+                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
             }
 
             BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new BackendNativeMethods.SECURITY_ATTRIBUTES();
@@ -459,7 +451,6 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
 
             if (!NativeMethodsShared.IsWindows)
             {
-
                 ProcessStartInfo processStartInfo = new ProcessStartInfo();
                 processStartInfo.FileName = exeName;
                 processStartInfo.Arguments = commandLineArgs;
@@ -830,7 +821,7 @@ private bool ProcessHeaderBytesRead(int bytesRead)
                     try
                     {
                         Process childProcess = Process.GetProcessById(_processId);
-                        if (childProcess == null || childProcess.HasExited)
+                        if (childProcess?.HasExited != false)
                         {
                             CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _processId);
                         }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 44a2de9a749..02f10d70aa4 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -200,16 +200,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         /// </summary>
         public void ShutdownAllNodes()
         {
-            bool nodeReuse = ComponentHost.BuildParameters.EnableNodeReuse;
-
-            // To avoid issues with mismatched priorities not shutting
-            // down all the nodes on exit, we will attempt to shutdown
-            // all matching notes with and without the priroity bit set.
-            // So precompute both versions of the handshake now.
-            long hostHandshake = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: false);
-            long hostHandshakeWithLow = NodeProviderOutOfProc.GetHostHandshake(nodeReuse, enableLowPriority: true);
-
-            ShutdownAllNodes(nodeReuse, NodeContextTerminated);
+            ShutdownAllNodes(ComponentHost.BuildParameters.EnableNodeReuse, NodeContextTerminated);
         }
         #endregion
 
@@ -505,7 +496,7 @@ internal void DisconnectFromHost(HandshakeOptions hostContext)
         /// </summary>
         internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
             if (AvailableNodes == 0)
@@ -535,8 +526,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                                         commandLineArgs,
                                         (int)hostContext,
                                         this,
-                                        CommunicationsUtilities.GetHostHandshake(hostContext),
-                                        CommunicationsUtilities.GetClientHandshake(hostContext),
+                                        new Handshake(hostContext),
                                         NodeContextTerminated
                                     );
 
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 835e24a7c6a..5ec101d68a5 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -74,10 +74,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         {
             ErrorUtilities.VerifyThrow(!_componentShutdown, "We should never be calling ShutdownNodes after ShutdownComponent has been called");
 
-            if (null != _outOfProcTaskHostNodeProvider)
-            {
-                _outOfProcTaskHostNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _outOfProcTaskHostNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
         /// <summary>
@@ -85,10 +82,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (null != _outOfProcTaskHostNodeProvider)
-            {
-                _outOfProcTaskHostNodeProvider.ShutdownAllNodes();
-            }
+            _outOfProcTaskHostNodeProvider?.ShutdownAllNodes();
         }
         #endregion
 
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 6e18d9ec4ef..4e57c5f2ae1 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     internal delegate IBuildComponent BuildComponentFactoryDelegate(BuildComponentType type);
 
     /// <summary>
-    /// An enumeration of all component types recognized by the system    
+    /// An enumeration of all component types recognized by the system
     /// </summary>
     internal enum BuildComponentType
     {
@@ -95,7 +95,7 @@ internal enum BuildComponentType
         RequestBuilder,
 
         /// <summary>
-        /// The component responsible for building targets.        
+        /// The component responsible for building targets.
         /// </summary>
         TargetBuilder,
 
diff --git a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
index 4d7f258974e..7bfc4b0670c 100644
--- a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
+++ b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
@@ -114,10 +114,7 @@ private void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent
             // If no central logger was registered with the system
             // there will not be a build event redirector as there is 
             // nowhere to forward the events to.
-            if (BuildEventRedirector != null)
-            {
-                BuildEventRedirector.ForwardEvent(buildEvent);
-            }
+            BuildEventRedirector?.ForwardEvent(buildEvent);
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
index 3e38bab3cb8..a44a9aec7b8 100644
--- a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
+++ b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
@@ -23,7 +23,7 @@ public class ForwardingLoggerRecord
         public ForwardingLoggerRecord(ILogger centralLogger, LoggerDescription forwardingLoggerDescription)
         {
             // The logging service allows a null central logger, so we don't check for it here.
-            ErrorUtilities.VerifyThrowArgumentNull(forwardingLoggerDescription, "forwardingLoggerDescription");
+            ErrorUtilities.VerifyThrowArgumentNull(forwardingLoggerDescription, nameof(forwardingLoggerDescription));
 
             this.CentralLogger = centralLogger;
             this.ForwardingLoggerDescription = forwardingLoggerDescription;
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 04b7ac6c238..02fdef8be56 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -202,14 +202,14 @@ bool IncludeTaskInputs
         /// <summary>
         /// Adds a set of warning codes to treat as low importance messages for the specified project instance ID.
         /// </summary>
-        /// <param name="projectInstanceId">A <see cref="BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
+        /// <param name="buildEventContext">A <see cref="BuildEventContext"/> to associate with the list of warning codes.</param>
         /// <param name="codes">The list of warning codes to treat as low importance messsages.</param>
         void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<string> codes);
 
         /// <summary>
         /// Adds a set of warning codes to treat as errors for the specified project instance ID.
         /// </summary>
-        /// <param name="projectInstanceId">A <see cref="BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
+        /// <param name="buildEventContext">A <see cref="BuildEventContext"/> to associate with the list of warning codes.</param>
         /// <param name="codes">The list of warning codes to treat as errors.</param>
         void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes);
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 2ba4ef2be8c..f32379d29c4 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -37,8 +37,8 @@ internal class LoggingContext
         /// <param name="eventContext">The event context</param>
         public LoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingService, "loggingService");
-            ErrorUtilities.VerifyThrowArgumentNull(eventContext, "eventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingService, nameof(loggingService));
+            ErrorUtilities.VerifyThrowArgumentNull(eventContext, nameof(eventContext));
 
             _loggingService = loggingService;
             _eventContext = eventContext;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2c56e6ead22..0f36fed3f96 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -121,7 +121,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         private bool _onlyLogCriticalEvents;
 
         /// <summary>
-        /// Contains a dictionary of loggerId's and the sink which the logger (of the given Id) is expecting to consume its messages 
+        /// Contains a dictionary of loggerId's and the sink which the logger (of the given Id) is expecting to consume its messages
         /// </summary>
         private Dictionary<int, IBuildEventSink> _eventSinkDictionary;
 
@@ -137,7 +137,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         private List<LoggerDescription> _loggerDescriptions;
 
         /// <summary>
-        /// The event source to which filters will listen to to get the build events which are logged to the logging service through the 
+        /// The event source to which filters will listen to get the build events which are logged to the logging service through the
         /// logging helper methods. Ie LogMessage and LogMessageEvent
         /// </summary>
         private EventSourceSink _filterEventSource;
@@ -245,7 +245,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
 
         /// <summary>
         /// By default our logMode is Asynchronous. We do this
-        /// because we are hoping it will make the system 
+        /// because we are hoping it will make the system
         /// more responsive when there are a large number of logging messages
         /// </summary>
         private LoggerMode _logMode = LoggerMode.Asynchronous;
@@ -444,7 +444,7 @@ public int MaxCPUCount
 
         /// <summary>
         /// The list of descriptions which describe how to create forwarding loggers on a node.
-        /// This is used by the node provider to get a list of registered descriptions so that 
+        /// This is used by the node provider to get a list of registered descriptions so that
         /// they can be transmitted to child nodes.
         /// </summary>
         public ICollection<LoggerDescription> LoggerDescriptions => _loggerDescriptions;
@@ -455,7 +455,7 @@ public int MaxCPUCount
         public ICollection<ILogger> Loggers => _loggers;
 
         /// <summary>
-        /// What type of logging mode is the logger running under. 
+        /// What type of logging mode is the logger running under.
         /// Is it Synchronous or Asynchronous
         /// </summary>
         public LoggerMode LoggingMode => _logMode;
@@ -483,7 +483,7 @@ public ISet<string> WarningsAsMessages
         /// </summary>
         public bool IncludeEvaluationMetaprojects
         {
-            get => (_includeEvaluationMetaprojects = _includeEvaluationMetaprojects ?? _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationMetaprojects)).Value;
+            get => _includeEvaluationMetaprojects ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationMetaprojects);
             set => _includeEvaluationMetaprojects = value;
         }
 
@@ -492,7 +492,7 @@ public bool IncludeEvaluationMetaprojects
         /// </summary>
         public bool IncludeEvaluationProfile
         {
-            get => (_includeEvaluationProfile = _includeEvaluationProfile ??_eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationProfiles)).Value;
+            get => _includeEvaluationProfile ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationProfiles);
             set => _includeEvaluationProfile = value;
         }
 
@@ -501,7 +501,7 @@ public bool IncludeEvaluationProfile
         /// </summary>
         public bool IncludeTaskInputs
         {
-            get => (_includeTaskInputs = _includeTaskInputs ?? _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeTaskInputs)).Value;
+            get => _includeTaskInputs ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeTaskInputs);
             set => _includeTaskInputs = value;
         }
 
@@ -519,7 +519,7 @@ public bool HasBuildSubmissionLoggedErrors(int submissionId)
             }
 
             // Determine if any of the event sinks have logged an error with this submission ID
-            return _buildSubmissionIdsThatHaveLoggedErrors != null && _buildSubmissionIdsThatHaveLoggedErrors.Contains(submissionId);
+            return _buildSubmissionIdsThatHaveLoggedErrors?.Contains(submissionId) == true;
         }
 
         public void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes)
@@ -723,10 +723,7 @@ public void ShutdownComponent()
                     }
 
                     // 3. Null out sinks and the filter event source so that no more events can get to the central loggers
-                    if (_filterEventSource != null)
-                    {
-                        _filterEventSource.ShutDown();
-                    }
+                    _filterEventSource?.ShutDown();
 
                     foreach (IBuildEventSink sink in _eventSinkDictionary.Values)
                     {
@@ -779,7 +776,7 @@ public void PacketReceived(int node, INodePacket packet)
             // PERF: Not using VerifyThrow to avoid allocations for enum.ToString (boxing of NodePacketType) in the non-error case.
             if (packet.Type != NodePacketType.LogMessage)
             {
-                ErrorUtilities.ThrowInternalError("Expected packet type \"{0}\" but instead got packet type \"{1}\".", NodePacketType.LogMessage.ToString(), packet.Type.ToString());
+                ErrorUtilities.ThrowInternalError("Expected packet type \"{0}\" but instead got packet type \"{1}\".", nameof(NodePacketType.LogMessage), packet.Type.ToString());
             }
 
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
@@ -873,11 +870,11 @@ public void UnregisterAllLoggers()
         }
 
         /// <summary>
-        /// Register a distributed logger. This involves creating a new eventsource sink 
-        /// and associating this with the central logger. In addition the sinkId needs 
-        /// to be put in the loggerDescription so that nodes know what they need to 
+        /// Register a distributed logger. This involves creating a new eventsource sink
+        /// and associating this with the central logger. In addition the sinkId needs
+        /// to be put in the loggerDescription so that nodes know what they need to
         /// tag onto the event so that the message goes to the correct logger.
-        /// 
+        ///
         /// The central logger is initialized before the distributed logger
         /// </summary>
         /// <param name="centralLogger">Central logger to receive messages from the forwarding logger, This logger cannot have been registered before</param>
@@ -1000,7 +997,7 @@ public void InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, I
         /// <summary>
         /// Will Log a build Event. Will also take into account OnlyLogCriticalEvents when determining
         /// if to drop the event or to log it.
-        /// 
+        ///
         /// Only the following events will be logged if OnlyLogCriticalEvents is true:
         /// CustomEventArgs
         /// BuildErrorEventArgs
@@ -1056,7 +1053,7 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
 
         /// <summary>
         /// This method will becalled from multiple threads in asynchronous mode.
-        /// 
+        ///
         /// Determine where to send the buildevent either to the filters or to a specific sink.
         /// When in Asynchronous mode the event should to into the logging queue (as long as we are initialized).
         /// In Synchronous mode the event should be routed to the correct sink or logger right away
@@ -1109,7 +1106,7 @@ internal void WaitForThreadToProcessEvents()
         /// </summary>
         internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         {
-            if (loggingPacket != null && loggingPacket.NodeBuildEvent != null && _componentHost != null)
+            if (loggingPacket?.NodeBuildEvent != null && _componentHost != null)
             {
                 var projectStartedEventArgs = loggingPacket.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
                 if (projectStartedEventArgs != null && _configCache.Value != null)
@@ -1196,10 +1193,7 @@ private void ShutdownLogger(ILogger logger)
         {
             try
             {
-                if (logger != null)
-                {
-                    logger.Shutdown();
-                }
+                logger?.Shutdown();
             }
             catch (LoggerException)
             {
@@ -1372,7 +1366,7 @@ private void RouteBuildEvent(object loggingEvent)
         }
 
         /// <summary>
-        /// Route the build event to the correct filter or sink depending on what the sinId is in the build event. 
+        /// Route the build event to the correct filter or sink depending on what the sinId is in the build event.
         /// </summary>
         private void RouteBuildEvent(KeyValuePair<int, BuildEventArgs> nodeEvent)
         {
@@ -1491,10 +1485,10 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
         }
 
         /// <summary>
-        /// When an exception is raised in the logging thread, we do not want the application to terminate right away. 
+        /// When an exception is raised in the logging thread, we do not want the application to terminate right away.
         /// Whidbey and orcas msbuild have the logger exceptions occurring on the engine thread so that the host can
         /// catch and deal with these exceptions as they may occur somewhat frequently due to user generated loggers.
-        /// This method will raise the exception on a delegate to which the engine is registered to. This delegate will 
+        /// This method will raise the exception on a delegate to which the engine is registered to. This delegate will
         /// send the exception to the engine so that it can be raised on the engine thread.
         /// </summary>
         /// <param name="ex">Exception to raise to event handlers</param>
@@ -1563,7 +1557,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
         {
             // This only applies if the user specified /nowarn at the command-line or added the warning code through the object model
             //
-            if (WarningsAsMessages != null && WarningsAsMessages.Contains(warningEvent.Code))
+            if (WarningsAsMessages?.Contains(warningEvent.Code) == true)
             {
                 return true;
             }
@@ -1574,7 +1568,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
             {
                 if (_warningsAsMessagesByProject.TryGetValue(GetWarningsAsErrorOrMessageKey(warningEvent), out ISet<string> codesByProject))
                 {
-                    return codesByProject != null && codesByProject.Contains(warningEvent.Code);
+                    return codesByProject?.Contains(warningEvent.Code) == true;
                 }
             }
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index d1bf9031adb..ef60a082609 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -447,7 +447,7 @@ public void LogBuildStarted()
 
                 IDictionary<string, string> environmentProperties = null;
 
-                if (_componentHost != null && _componentHost.BuildParameters != null)
+                if (_componentHost?.BuildParameters != null)
                 {
                     environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
                 }
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 883059b0406..409c75b14be 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -101,7 +101,7 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 items = new ProjectItemInstanceEnumeratorProxy(projectItemsEnumerator);
             }
 
-            if (projectProperties != null && propertiesToSerialize != null && propertiesToSerialize.Length > 0 && !LoggingService.SerializeAllProperties)
+            if (projectProperties != null && propertiesToSerialize?.Length > 0 && !LoggingService.SerializeAllProperties)
             {
                 PropertyDictionary<ProjectPropertyInstance> projectPropertiesToSerialize = new PropertyDictionary<ProjectPropertyInstance>();
                 foreach (string propertyToGet in propertiesToSerialize)
@@ -171,7 +171,7 @@ internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, Proj
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
         /// </remarks>
@@ -221,7 +221,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
         /// </remarks>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index eac4bf5351c..f0485c1d0eb 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -127,12 +127,12 @@ ElementLocation elementLocation
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             List<ItemBucket> buckets = null;
-            if (consumedMetadataReferences != null && consumedMetadataReferences.Count > 0)
+            if (consumedMetadataReferences?.Count > 0)
             {
                 // Add any item types that we were explicitly told to assume.
                 if (implicitBatchableItemType != null)
                 {
-                    consumedItemReferences = consumedItemReferences ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                    consumedItemReferences ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferences.Add(implicitBatchableItemType);
                 }
 
@@ -232,7 +232,7 @@ ElementLocation elementLocation
                     // in the tag anywhere.  Adding it to this list allows us (down below in this
                     // method) to check that every item in this list has a value for each 
                     // unqualified metadata reference.
-                    consumedItemReferenceNames = consumedItemReferenceNames ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                    consumedItemReferenceNames ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferenceNames.Add(consumedMetadataReference.ItemName);
                 }
             }
@@ -395,7 +395,7 @@ ElementLocation elementLocation
 
                 if (
                         (metadataItemName != null) &&
-                        (0 != String.Compare(item.ItemType, metadataItemName, StringComparison.OrdinalIgnoreCase))
+                        (!String.Equals(item.ItemType, metadataItemName, StringComparison.OrdinalIgnoreCase))
                     )
                 {
                     itemMetadataValues[metadataQualifiedName] = String.Empty;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
index 38b986e050f..c278aa84730 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
@@ -28,6 +28,7 @@ namespace Microsoft.Build.BackEnd
     /// <param name="issuingEntry">The build request entry which is being blocked.</param>
     /// <param name="blockingGlobalRequestId">The request on which we are blocked.</param>
     /// <param name="blockingTarget">The target on which we are blocked.</param>
+    /// <param name="partialBuildResult">The partial build result on which we are blocked.</param>
     internal delegate void BuildRequestBlockedDelegate(BuildRequestEntry issuingEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index f528cadbfaf..844924e7625 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -215,7 +215,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 LoggingContext.BuildEventContext,
                 FileSystems.Default);
 
-            if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd != null && itemsToAdd.Count > 0)
+            if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
                 var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
                     ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
@@ -235,6 +235,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
         /// </summary>
         /// <param name="child">The item specification to evaluate and remove.</param>
         /// <param name="bucket">The batching bucket.</param>
+        /// <param name="matchOnMetadata">Metadata matching.</param>
+        /// <param name="matchingOptions">Options matching.</param>
         private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, HashSet<string> matchOnMetadata, MatchOnMetadataOptions matchingOptions)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index d9639592e03..2e0e396a553 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -236,7 +236,7 @@ public async Task<bool> ExecuteInternal()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators?.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
@@ -484,7 +484,7 @@ bool runEachTargetSeparately
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
             var targetLists = new List<string[]>();
-            if ((runEachTargetSeparately) && (targets != null) && (targets.Length > 0))
+            if ((runEachTargetSeparately) && (targets?.Length > 0))
             {
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index da88294d849..8a95d148769 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -89,8 +89,8 @@ internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvide
         /// </summary>
         internal Lookup(ItemDictionary<ProjectItemInstance> projectItems, PropertyDictionary<ProjectPropertyInstance> properties)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectItems, "projectItems");
-            ErrorUtilities.VerifyThrowInternalNull(properties, "properties");
+            ErrorUtilities.VerifyThrowInternalNull(projectItems, nameof(projectItems));
+            ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
 
             Lookup.Scope scope = new Lookup.Scope(this, "Lookup()", projectItems, properties);
             _lookupScopes.AddFirst(scope);
@@ -378,13 +378,13 @@ private void MergeScopeIntoLastScope()
             // adds to the world
             if (PrimaryAddTable != null)
             {
-                SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                 SecondaryTable.ImportItems(PrimaryAddTable);
             }
 
             if (PrimaryRemoveTable != null)
             {
-                SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                 SecondaryTable.RemoveItems(PrimaryRemoveTable);
             }
 
@@ -392,14 +392,14 @@ private void MergeScopeIntoLastScope()
             {
                 foreach (KeyValuePair<string, Dictionary<ProjectItemInstance, MetadataModifications>> entry in PrimaryModifyTable)
                 {
-                    SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                    SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                     ApplyModificationsToTable(SecondaryTable, entry.Key, entry.Value);
                 }
             }
 
             if (PrimaryPropertySets != null)
             {
-                SecondaryProperties = SecondaryProperties ?? new PropertyDictionary<ProjectPropertyInstance>(PrimaryPropertySets.Count);
+                SecondaryProperties ??= new PropertyDictionary<ProjectPropertyInstance>(PrimaryPropertySets.Count);
                 SecondaryProperties.ImportProperties(PrimaryPropertySets);
             }
         }
@@ -450,7 +450,7 @@ public ProjectPropertyInstance GetProperty(string name, int startIndex, int endI
         /// </summary>
         public ProjectPropertyInstance GetProperty(string name)
         {
-            ErrorUtilities.VerifyThrowInternalLength(name, "name");
+            ErrorUtilities.VerifyThrowInternalLength(name, nameof(name));
 
             return GetProperty(name, 0, name.Length - 1);
         }
@@ -479,7 +479,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> adds = scope.Adds[itemType];
                     if (adds.Count != 0)
                     {
-                        allAdds = allAdds ?? new List<ProjectItemInstance>(adds.Count);
+                        allAdds ??= new List<ProjectItemInstance>(adds.Count);
                         allAdds.AddRange(adds);
                     }
                 }
@@ -490,7 +490,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> removes = scope.Removes[itemType];
                     if (removes.Count != 0)
                     {
-                        allRemoves = allRemoves ?? new List<ProjectItemInstance>(removes.Count);
+                        allRemoves ??= new List<ProjectItemInstance>(removes.Count);
                         allRemoves.AddRange(removes);
                     }
                 }
@@ -503,7 +503,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     {
                         if (modifies.Count != 0)
                         {
-                            allModifies = allModifies ?? new Dictionary<ProjectItemInstance, MetadataModifications>(modifies.Count);
+                            allModifies ??= new Dictionary<ProjectItemInstance, MetadataModifications>(modifies.Count);
 
                             // We already have some modifies for this type
                             foreach (KeyValuePair<ProjectItemInstance, MetadataModifications> modify in modifies)
@@ -538,7 +538,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
             {
                 // We can just hand out this group verbatim -
                 // that avoids any importing
-                groupFound = groupFound ?? Array.Empty<ProjectItemInstance>();
+                groupFound ??= Array.Empty<ProjectItemInstance>();
 
                 return groupFound;
             }
@@ -593,7 +593,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
         /// </summary>
         internal void PopulateWithItems(string itemType, ICollection<ProjectItemInstance> group)
         {
-            PrimaryTable = PrimaryTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryTable ??= new ItemDictionary<ProjectItemInstance>();
             ICollection<ProjectItemInstance> existing = PrimaryTable[itemType];
             ErrorUtilities.VerifyThrow(existing.Count == 0, "Cannot add an itemgroup of this type.");
 
@@ -613,7 +613,7 @@ internal void PopulateWithItems(string itemType, ICollection<ProjectItemInstance
         /// </summary>
         internal void PopulateWithItem(ProjectItemInstance item)
         {
-            PrimaryTable = PrimaryTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryTable.Add(item);
         }
 
@@ -626,7 +626,7 @@ internal void SetProperty(ProjectPropertyInstance property)
             MustNotBeOuterScope();
 
             // Put in the set table
-            PrimaryPropertySets = PrimaryPropertySets ?? new PropertyDictionary<ProjectPropertyInstance>();
+            PrimaryPropertySets ??= new PropertyDictionary<ProjectPropertyInstance>();
             PrimaryPropertySets.Set(property);
         }
 
@@ -651,7 +651,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst
             }
 
             // Put them in the add table
-            PrimaryAddTable = PrimaryAddTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryAddTable ??= new ItemDictionary<ProjectItemInstance>();
             IEnumerable<ProjectItemInstance> itemsToAdd = group;
             if (doNotAddDuplicates)
             {
@@ -684,7 +684,7 @@ internal void AddNewItem(ProjectItemInstance item)
 #endif
 
             // Put in the add table
-            PrimaryAddTable = PrimaryAddTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryAddTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryAddTable.Add(item);
         }
 
@@ -710,7 +710,7 @@ internal void RemoveItem(ProjectItemInstance item)
             item = RetrieveOriginalFromCloneTable(item);
 
             // Put in the remove table
-            PrimaryRemoveTable = PrimaryRemoveTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryRemoveTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryRemoveTable.Add(item);
 
             // No need to remove this item from the primary add table if it's 
@@ -753,7 +753,7 @@ internal void ModifyItems(string itemType, ICollection<ProjectItemInstance> grou
 
             // We don't need to check whether the item is in the add table vs. the main table; either
             // way the modification will be applied.
-            PrimaryModifyTable = PrimaryModifyTable ?? new ItemTypeToItemsMetadataUpdateDictionary(MSBuildNameIgnoreCaseComparer.Default);
+            PrimaryModifyTable ??= new ItemTypeToItemsMetadataUpdateDictionary(MSBuildNameIgnoreCaseComparer.Default);
             Dictionary<ProjectItemInstance, MetadataModifications> modifiesOfType;
             if (!PrimaryModifyTable.TryGetValue(itemType, out modifiesOfType))
             {
@@ -790,7 +790,7 @@ private void ApplyModifies(ItemDictionary<ProjectItemInstance> result, Dictionar
             // FUTURE - don't need to clone here for non intrinsic tasks, but at present, they don't do modifies
 
             // Store the clone, in case we're asked to modify or remove it later (we will record it against the real item)
-            _cloneTable = _cloneTable ?? new Dictionary<ProjectItemInstance, ProjectItemInstance>();
+            _cloneTable ??= new Dictionary<ProjectItemInstance, ProjectItemInstance>();
 
             foreach (var modify in allModifies)
             {
@@ -930,7 +930,7 @@ private void MergeModificationsIntoModificationTable(Dictionary<ProjectItemInsta
         /// </summary>
         private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, ProjectItemInstance item)
         {
-            if (table != null && table.ItemTypes.Contains(item.ItemType))
+            if (table?.ItemTypes.Contains(item.ItemType) == true)
             {
                 ICollection<ProjectItemInstance> tableOfItemsOfSameType = table[item.ItemType];
                 if (tableOfItemsOfSameType != null)
@@ -945,7 +945,7 @@ private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, Project
         /// </summary>
         private void MustNotBeInTable(ItemTypeToItemsMetadataUpdateDictionary table, ProjectItemInstance item)
         {
-            if (table != null && table.ContainsKey(item.ItemType))
+            if (table?.ContainsKey(item.ItemType) == true)
             {
                 ItemsMetadataUpdateDictionary tableOfItemsOfSameType = table[item.ItemType];
                 if (tableOfItemsOfSameType != null)
@@ -1271,7 +1271,7 @@ public bool Remove
             /// </summary>
             public bool KeepValue
             {
-                get { return (_remove == false && _newValue == null); }
+                get { return (!_remove && _newValue == null); }
             }
 
             /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index c34edb8c8e7..3600d3ac675 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -170,7 +170,7 @@ internal bool HasActiveBuildRequest
             {
                 VerifyIsNotZombie();
 
-                return (_requestTask != null && !_requestTask.IsCompleted) || (_componentHost.LegacyThreadingData.MainThreadSubmissionId != -1);
+                return (_requestTask?.IsCompleted == false) || (_componentHost.LegacyThreadingData.MainThreadSubmissionId != -1);
             }
         }
 
@@ -181,8 +181,8 @@ internal bool HasActiveBuildRequest
         /// <param name="entry">The entry to build.</param>
         public void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry entry)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "loggingContext");
-            ErrorUtilities.VerifyThrowArgumentNull(entry, "entry");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
             ErrorUtilities.VerifyThrow(null != _componentHost, "Host not set.");
             ErrorUtilities.VerifyThrow(_targetBuilder == null, "targetBuilder not null");
             ErrorUtilities.VerifyThrow(_nodeLoggingContext == null, "nodeLoggingContext not null");
@@ -308,10 +308,10 @@ public void WaitForCancelCompletion()
         public async Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDictionary<ProjectPropertyInstance>[] properties, string[] toolsVersions, string[] targets, bool waitForResults, bool skipNonexistentTargets = false)
         {
             VerifyIsNotZombie();
-            ErrorUtilities.VerifyThrowArgumentNull(projectFiles, "projectFiles");
-            ErrorUtilities.VerifyThrowArgumentNull(properties, "properties");
-            ErrorUtilities.VerifyThrowArgumentNull(targets, "targets");
-            ErrorUtilities.VerifyThrowArgumentNull(toolsVersions, "toolsVersions");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFiles, nameof(projectFiles));
+            ErrorUtilities.VerifyThrowArgumentNull(properties, nameof(properties));
+            ErrorUtilities.VerifyThrowArgumentNull(targets, nameof(targets));
+            ErrorUtilities.VerifyThrowArgumentNull(toolsVersions, nameof(toolsVersions));
             ErrorUtilities.VerifyThrow(_componentHost != null, "No host object set");
             ErrorUtilities.VerifyThrow(projectFiles.Length == properties.Length, "Properties and project counts not the same");
             ErrorUtilities.VerifyThrow(projectFiles.Length == toolsVersions.Length, "Tools versions and project counts not the same");
@@ -469,7 +469,7 @@ public void ExitMSBuildCallbackState()
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             ErrorUtilities.VerifyThrow(_componentHost == null, "RequestBuilder already initialized.");
             _componentHost = host;
         }
@@ -582,7 +582,7 @@ private void StartBuilderThread()
                         // to null between the null check and asking the LegacyThreadingData for the Task.
                         IBuildComponentHost componentHostSnapshot = _componentHost;
 
-                        if (componentHostSnapshot != null && componentHostSnapshot.LegacyThreadingData != null)
+                        if (componentHostSnapshot?.LegacyThreadingData != null)
                         {
                             return componentHostSnapshot.LegacyThreadingData.GetLegacyThreadInactiveTask(_requestEntry.Request.SubmissionId);
                         }
@@ -990,7 +990,7 @@ private void RaiseOnBlockedRequest(int blockingGlobalRequestId, string blockingT
         /// This method is called to reset the current directory to the one appropriate for this project.  It should be called any time
         /// the project is resumed.
         /// If the directory does not exist, does nothing.
-        /// This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project. 
+        /// This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project.
         /// No errors are masked by doing this: errors loading the project from disk are reported at load time, if necessary.
         /// </summary>
         private void SetProjectCurrentDirectory()
@@ -1293,7 +1293,7 @@ private ISet<string> ParseWarningCodes(string warnings)
             {
                 return null;
             }
-            
+
             return new HashSet<string>(ExpressionShredder.SplitSemiColonSeparatedList(warnings), StringComparer.OrdinalIgnoreCase);
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index fef4a4d0676..d105588c94d 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -26,11 +26,11 @@ namespace Microsoft.Build.BackEnd
     /// pushed onto the stack.  The main loop for the Target Builder simply evaluates the top item on the stack to determine
     /// which action to take.  These actions comprise the target state machine, as represented by the states of the
     /// TargetEntry object.
-    /// 
+    ///
     /// When a target completes, all of its outputs are available in the Lookup contained in the TargetEntry.  In fact, everything that it changed
     /// in the global state is available by virtue of its Lookup being merged with the current Target's lookup.
-    /// 
-    /// For CallTarget tasks, this behavior is not the same.  Rather the Lookup from a CallTarget call does not get merged until the calling 
+    ///
+    /// For CallTarget tasks, this behavior is not the same.  Rather the Lookup from a CallTarget call does not get merged until the calling
     /// Target has completed.  This is considered erroneous behavior and 'normal' version of CallTarget will be implemented which does not exhibit
     /// this.
     /// </remarks>
@@ -100,10 +100,10 @@ internal class TargetBuilder : ITargetBuilder, ITargetBuilderCallback, IBuildCom
         public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, string[] targetNames, Lookup baseLookup, CancellationToken cancellationToken)
         {
             ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "projectLoggingContext");
-            ErrorUtilities.VerifyThrowArgumentNull(entry, "entry");
+            ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
             ErrorUtilities.VerifyThrowArgumentNull(callback, "requestBuilderCallback");
-            ErrorUtilities.VerifyThrowArgumentNull(targetNames, "targetNames");
-            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, "baseLookup");
+            ErrorUtilities.VerifyThrowArgumentNull(targetNames, nameof(targetNames));
+            ErrorUtilities.VerifyThrowArgumentNull(baseLookup, nameof(baseLookup));
             ErrorUtilities.VerifyThrow(targetNames.Length > 0, "List of targets must be non-empty");
             ErrorUtilities.VerifyThrow(_componentHost != null, "InitializeComponent must be called before building targets.");
 
@@ -201,7 +201,6 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
             return resultsToReport;
         }
 
-
         #region IBuildComponent Members
 
         /// <summary>
@@ -210,7 +209,7 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             _componentHost = host;
         }
 
@@ -589,9 +588,9 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
         }
 
         /// <summary>
-        /// When a target build fails, we don't just stop building that target; we also pop all of the other dependency targets of its 
-        /// parent target off the stack. Extract that logic into a standalone method so that it can be used when dealing with targets that 
-        /// are skipped-unsuccessful as well as first-time failures. 
+        /// When a target build fails, we don't just stop building that target; we also pop all of the other dependency targets of its
+        /// parent target off the stack. Extract that logic into a standalone method so that it can be used when dealing with targets that
+        /// are skipped-unsuccessful as well as first-time failures.
         /// </summary>
         private void PopDependencyTargetsOnTargetFailure(TargetEntry topEntry, TargetResult targetResult, ref bool stopProcessingStack)
         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index a8a180adb6e..1a68631a166 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -32,7 +32,7 @@ internal enum TargetEntryState
     {
         /// <summary>
         /// The target's dependencies need to be evaluated and pushed onto the target stack.
-        /// 
+        ///
         /// Transitions:
         /// Execution, ErrorExecution
         /// </summary>
@@ -40,7 +40,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target is ready to execute its tasks, batched as needed.
-        /// 
+        ///
         /// Transitions:
         /// ErrorExecution, Completed
         /// </summary>
@@ -48,7 +48,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target is ready to provide error tasks.
-        /// 
+        ///
         /// Transitions:
         /// None
         /// </summary>
@@ -56,7 +56,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target has finished building.  All of the results are in the Lookup.
-        /// 
+        ///
         /// Transitions:
         /// None
         /// </summary>
@@ -163,11 +163,11 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
         internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, "requestEntry");
-            ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, "targetBuilderCallback");
+            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
+            ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, nameof(targetBuilderCallback));
             ErrorUtilities.VerifyThrowArgumentNull(targetSpecification, "targetName");
             ErrorUtilities.VerifyThrowArgumentNull(baseLookup, "lookup");
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
 
             _requestEntry = requestEntry;
             _targetBuilderCallback = targetBuilderCallback;
@@ -243,7 +243,7 @@ internal TargetResult Result
         }
 
         /// <summary>
-        /// Retrieves the Lookup this target was initialized with, including any modifications which have 
+        /// Retrieves the Lookup this target was initialized with, including any modifications which have
         /// been made to it while running.
         /// </summary>
         internal Lookup Lookup
@@ -432,7 +432,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 string projectFullPath = requestEntry.RequestConfiguration.ProjectFullPath;
 
                 string parentTargetName = null;
-                if (ParentEntry != null && ParentEntry.Target != null)
+                if (ParentEntry?.Target != null)
                 {
                     parentTargetName = ParentEntry.Target.Name;
                 }
@@ -531,7 +531,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                 entryForInference = null;
                                 entryForExecution.LeaveScope();
                                 entryForExecution = null;
-                                targetSuccess = (bucketResult != null) && (bucketResult.ResultCode == WorkUnitResultCode.Success);
+                                targetSuccess = (bucketResult?.ResultCode == WorkUnitResultCode.Success);
                                 break;
 
                             case DependencyAnalysisResult.SkipNoInputs:
@@ -547,15 +547,9 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         // the log is confusing.
                         targetLoggingContext.LogInvalidProjectFileError(e);
 
-                        if (null != entryForInference)
-                        {
-                            entryForInference.LeaveScope();
-                        }
+                        entryForInference?.LeaveScope();
 
-                        if (null != entryForExecution)
-                        {
-                            entryForExecution.LeaveScope();
-                        }
+                        entryForExecution?.LeaveScope();
 
                         aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
                     }
@@ -653,11 +647,11 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 }
                 finally
                 {
-                    if (targetLoggingContext != null)
-                    {
+                       
+                    
                         // log the last target finished since we now have the target outputs. 
-                        targetLoggingContext.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems != null && targetOutputItems.Count > 0 ? targetOutputItems : null);
-                    }
+                        targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
+                    
                 }
 
                 _targetResult = new TargetResult(targetOutputItems.ToArray(), aggregateResult);
@@ -859,7 +853,7 @@ private async Task<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, Targe
         }
 
         /// <summary>
-        /// Gets the task execution mode based 
+        /// Gets the task execution mode based
         /// </summary>
         /// <param name="analysis">The result of the up-to-date check.</param>
         /// <returns>The mode to be used to execute tasks.</returns>
@@ -880,7 +874,7 @@ private TaskExecutionMode GetTaskExecutionMode(DependencyAnalysisResult analysis
             if ((analysis == DependencyAnalysisResult.FullBuild) ||
                 (analysis == DependencyAnalysisResult.IncrementalBuild))
             {
-                executionMode = executionMode | TaskExecutionMode.ExecuteTaskAndGatherOutputs;
+                executionMode |= TaskExecutionMode.ExecuteTaskAndGatherOutputs;
             }
 
             return executionMode;
@@ -898,7 +892,7 @@ private void VerifyState(TargetEntryState actual, TargetEntryState expected)
 
         /// <summary>
         /// Gets the list of parameters which are batchable for a target
-        /// PERF: (Refactor) This used to be a method on the target, and it would 
+        /// PERF: (Refactor) This used to be a method on the target, and it would
         /// cache its values so this would only be computed once for each
         /// target.  We should consider doing something similar for perf reasons.
         /// </summary>
@@ -917,7 +911,7 @@ private List<string> GetBatchableParametersForTarget()
                 batchableTargetParameters.Add(_target.Outputs);
             }
 
-            if (_target.Returns != null && _target.Returns.Length > 0)
+            if (!string.IsNullOrEmpty(_target.Returns))
             {
                 batchableTargetParameters.Add(_target.Returns);
             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index 44bac11a478..a2efa711584 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -26,8 +26,8 @@ internal class TargetSpecification : ITranslatable
         /// <param name="referenceLocation">The location from which it was referred.</param>
         internal TargetSpecification(string targetName, ElementLocation referenceLocation)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(referenceLocation, "referenceLocation");
+            ErrorUtilities.VerifyThrowArgumentLength(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(referenceLocation, nameof(referenceLocation));
 
             this._targetName = targetName;
             this._referenceLocation = referenceLocation;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index c141a8cf4a4..f3aff939396 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -235,7 +235,7 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                 // 1) they do not reference any item vector
                 // 2) they reference item vectors that are not referenced by any input item
                 if ((discreteItemsInTargetOutputs.Count > 0) ||
-                    ((itemVectorsReferencedOnlyInTargetOutputs != null) && (itemVectorsReferencedOnlyInTargetOutputs.Count > 0)))
+                    ((itemVectorsReferencedOnlyInTargetOutputs?.Count > 0)))
                 {
                     result = PerformDependencyAnalysisIfDiscreteOutputs(
                                 itemVectorsInTargetInputs, itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs,
@@ -460,7 +460,6 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfNoInputs()
                 _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletely", _targetToAnalyze.Name);
                 _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletelyNoInputsSpecified");
 
-
                 // otherwise, do a full build
                 result = DependencyAnalysisResult.FullBuild;
             }
@@ -1074,7 +1073,6 @@ internal static bool IsAnyOutOfDate<T>(out DependencyAnalysisLogDetail dependenc
             return false;
         }
 
-
         /// <summary>
         /// Record the unique input and output files so that the "up to date" message
         /// can list them in the log later.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 23a6fc8d5aa..9c3341db46f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -48,7 +48,7 @@ internal enum ContinueOnError
 
     /// <summary>
     /// The TaskBuilder is one of two components related to building tasks, the other being the TaskExecutionHost.  The TaskBuilder is
-    /// responsible for all parts dealing with the XML/task declaration.  It determines if the task is intrinsic or extrinsic, 
+    /// responsible for all parts dealing with the XML/task declaration.  It determines if the task is intrinsic or extrinsic,
     /// looks up the task in the task registry, determines the task parameters and requests them to be set, and requests outputs
     /// when task execution has been completed.  It is not responsible for reflection over the task instance or anything which
     /// requires dealing with the task instance directly - those actions are handled by the TaskExecutionHost.
@@ -77,7 +77,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
 
         /// <summary>
         /// The task instance for extrinsic tasks
-        /// </summary> 
+        /// </summary>
         private ProjectTaskInstance _taskNode;
 
         /// <summary>
@@ -87,7 +87,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
 
         /// <summary>
         /// indicates whether to ignore task execution failures
-        /// </summary> 
+        /// </summary>
         private ContinueOnError _continueOnError;
 
         /// <summary>
@@ -135,7 +135,7 @@ internal TaskBuilder()
         /// <param name="cancellationToken">The <see cref="CancellationToken"/> to use when executing the task.</param>
         /// <returns>The result of running the task batch.</returns>
         /// <remarks>
-        /// The ExecuteTask method takes a task as specified by XML and executes it.  This procedure is comprised 
+        /// The ExecuteTask method takes a task as specified by XML and executes it.  This procedure is comprised
         /// of the following steps:
         /// 1. Loading the Task from its containing assembly by looking it up in the task registry
         /// 2. Determining if the task is batched.  If it is, create the batches and execute each as if it were a non-batched task
@@ -205,10 +205,7 @@ public void ShutdownComponent()
                 _componentHost = null;
 
                 IDisposable disposable = _taskExecutionHost as IDisposable;
-                if (disposable != null)
-                {
-                    disposable.Dispose();
-                }
+                disposable?.Dispose();
 
                 _taskExecutionHost = null;
             }
@@ -284,12 +281,12 @@ private List<string> CreateListOfParameterValues()
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
         private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(lookup, "lookup");
+            ErrorUtilities.VerifyThrowArgumentNull(lookup, nameof(lookup));
 
             WorkUnitResult taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null);
             TaskHost taskHost = null;
@@ -334,7 +331,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                         break;
                     }
                 }
-                
+
                 taskResult = aggregateResult;
             }
             finally
@@ -342,10 +339,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 _taskExecutionHost.CleanupForTask();
 
 #if FEATURE_APPDOMAIN
-                if (taskHost != null)
-                {
-                    taskHost.MarkAsInactive();
-                }
+                taskHost?.MarkAsInactive();
 #endif
 
                 // Now all task batches are done, apply all item adds to the outer 
@@ -366,7 +360,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
         /// <summary>
         /// Execute a single bucket
         /// </summary>
-        /// <returns>true if execution succeeded</returns>        
+        /// <returns>true if execution succeeded</returns>
         private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary<string, string> lookupHash)
         {
             // On Intrinsic tasks, we do not allow batchable params, therefore metadata is excluded.
@@ -518,7 +512,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
         }
 
         /// <summary>
-        /// Returns the set of parameters that can contribute to a task's identity, and their values for this particular task.  
+        /// Returns the set of parameters that can contribute to a task's identity, and their values for this particular task.
         /// </summary>
         private IDictionary<string, string> GatherTaskIdentityParameters(Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
@@ -545,14 +539,13 @@ private IDictionary<string, string> GatherTaskIdentityParameters(Expander<Projec
             return taskIdentityParameters;
         }
 
-
 #if FEATURE_APARTMENT_STATE
         /// <summary>
         /// Executes the task using an STA thread.
         /// </summary>
         /// <comment>
-        /// STA thread launching also being used in XMakeCommandLine\OutOfProcTaskAppDomainWrapperBase.cs, InstantiateAndExecuteTaskInSTAThread method.  
-        /// Any bug fixes made to this code, please ensure that you also fix that code.  
+        /// STA thread launching also being used in XMakeCommandLine\OutOfProcTaskAppDomainWrapperBase.cs, InstantiateAndExecuteTaskInSTAThread method.
+        /// Any bug fixes made to this code, please ensure that you also fix that code.
         /// </comment>
         [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Exception is caught and rethrown in the correct thread.")]
         private WorkUnitResult ExecuteTaskInSTAThread(ItemBucket bucket, TaskLoggingContext taskLoggingContext, IDictionary<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask)
@@ -597,10 +590,7 @@ private WorkUnitResult ExecuteTaskInSTAThread(ItemBucket bucket, TaskLoggingCont
                 taskRunnerFinished = null;
             }
 
-            if (exceptionFromExecution != null)
-            {
-                exceptionFromExecution.Throw();
-            }
+            exceptionFromExecution?.Throw();
 
             return taskResult;
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 81e53c7ba6b..3e2f83c917a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -37,7 +37,7 @@ internal class TaskHost :
         IBuildEngine7
     {
         /// <summary>
-        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set. 
+        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
         /// </summary>
         private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
@@ -114,9 +114,9 @@ internal class TaskHost :
         /// <param name="targetBuilderCallback">An <see cref="ITargetBuilderCallback"/> to use to invoke targets and build projects.</param>
         public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, ElementLocation taskLocation, ITargetBuilderCallback targetBuilderCallback)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
-            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, "requestEntry");
-            ErrorUtilities.VerifyThrowInternalNull(taskLocation, "taskLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
+            ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
+            ErrorUtilities.VerifyThrowInternalNull(taskLocation, nameof(taskLocation));
 
             _host = host;
             _requestEntry = requestEntry;
@@ -131,7 +131,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
         /// Returns true in the multiproc case
         /// </summary>
         /// <comment>
-        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.  
+        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.
         /// </comment>
         public bool IsRunningMultipleNodes
         {
@@ -320,7 +320,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         #region IBuildEngine3 Members
 
         /// <summary>
-        /// Builds multiple project files in parallel. 
+        /// Builds multiple project files in parallel.
         /// Thread safe.
         /// </summary>
         /// <param name="projectFileNames">The list of projects to build</param>
@@ -388,7 +388,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -459,7 +459,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -500,7 +500,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -541,7 +541,7 @@ public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
                 if (!_activeProxy)
                 {
@@ -632,7 +632,7 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie
         {
             lock (_callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(eventName, "eventName");
+                ErrorUtilities.VerifyThrowArgumentNull(eventName, nameof(eventName));
 
                 if (!_activeProxy)
                 {
@@ -683,8 +683,8 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         /// </summary>
         public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
             VerifyActiveProxy();
 
             BuildEngineResult result;
@@ -726,7 +726,7 @@ public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileN
 #if FEATURE_APPDOMAIN
         /// <inheritdoc />
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
@@ -811,10 +811,7 @@ internal void MarkAsInactive()
                 {
                     ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
 
-                    if (lease != null)
-                    {
-                        lease.Unregister(_sponsor);
-                    }
+                    lease?.Unregister(_sponsor);
 
                     _sponsor.Close();
                     _sponsor = null;
@@ -851,8 +848,8 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// <returns>A Task returning a structure containing the result of the build, success or failure and the list of target outputs per project</returns>
         private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<String>[] undefineProperties, string[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets = false)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
             VerifyActiveProxy();
 
             List<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = null;
@@ -934,10 +931,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                     // Now walk through the results, and report that subset which was asked for.
                     for (int i = 0; i < results.Length; i++)
                     {
-                        if (targetOutputsPerProject != null)
-                        {
-                            targetOutputsPerProject.Add(new Dictionary<string, ITaskItem[]>(StringComparer.OrdinalIgnoreCase));
-                        }
+                        targetOutputsPerProject?.Add(new Dictionary<string, ITaskItem[]>(StringComparer.OrdinalIgnoreCase));
 
                         foreach (KeyValuePair<string, TargetResult> resultEntry in results[i].ResultsByTarget)
                         {
@@ -972,7 +966,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                         }
                     }
 
-                    ErrorUtilities.VerifyThrow(results.Length == projectFileNames.Length || overallSuccess == false, "The number of results returned {0} cannot be less than the number of project files {1} unless one of the results indicated failure.", results.Length, projectFileNames.Length);
+                    ErrorUtilities.VerifyThrow(results.Length == projectFileNames.Length || !overallSuccess, "The number of results returned {0} cannot be less than the number of project files {1} unless one of the results indicated failure.", results.Length, projectFileNames.Length);
                 }
 
                 BuildRequestsSucceeded = overallSuccess;
@@ -987,7 +981,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
         /// </summary>
         private void VerifyActiveProxy()
         {
-            ErrorUtilities.VerifyThrow(_activeProxy == true, "Attempted to use an inactive task host.");
+            ErrorUtilities.VerifyThrow(_activeProxy, "Attempted to use an inactive task host.");
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 3bd3b5969da..b9dc833cdf9 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -125,8 +125,8 @@ internal class SchedulableRequest
         /// </summary>
         public SchedulableRequest(SchedulingData collection, BuildRequest request, SchedulableRequest parent)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(collection, "collection");
-            ErrorUtilities.VerifyThrowArgumentNull(request, "request");
+            ErrorUtilities.VerifyThrowArgumentNull(collection, nameof(collection));
+            ErrorUtilities.VerifyThrowArgumentNull(request, nameof(request));
             ErrorUtilities.VerifyThrow((parent == null) || (parent._schedulingData == collection), "Parent request does not belong to the same collection.");
 
             _schedulingData = collection;
@@ -305,7 +305,7 @@ public TimeSpan GetTimeSpentInState(SchedulableRequestState desiredState)
         public void Yield(string[] activeTargets)
         {
             VerifyState(SchedulableRequestState.Executing);
-            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, "activeTargets");
+            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             _activeTargetsWhenBlocked = activeTargets;
             ChangeToState(SchedulableRequestState.Yielding);
         }
@@ -325,12 +325,12 @@ public void Reacquire()
         /// </summary>
         /// <param name="blockingRequest">The request which is blocking this one.</param>
         /// <param name="activeTargets">The list of targets this request was currently building at the time it became blocked.</param>
-        /// <param name="blockerBlockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
+        /// <param name="blockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
         public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTargets, string blockingTarget = null)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
-            ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, "blockingRequest");
-            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, "activeTargets");
+            ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, nameof(blockingRequest));
+            ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             ErrorUtilities.VerifyThrow(BlockingTarget == null, "Cannot block again if we're already blocked on a target");
 
             // Note that the blocking request will typically be our parent UNLESS it is a request we blocked on because it was executing a target we wanted to execute.
@@ -366,7 +366,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
         public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
-            ErrorUtilities.VerifyThrowArgumentNull(result, "result");
+            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
             DisconnectRequestWeAreBlockedBy(key);
@@ -379,7 +379,7 @@ public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         public void UnblockWithResult(BuildResult result)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
-            ErrorUtilities.VerifyThrowArgumentNull(result, "result");
+            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
             DisconnectRequestWeAreBlockedBy(key);
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index d34a2df0426..acd599a952e 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -33,9 +33,9 @@ internal class Scheduler : IScheduler
         internal const int InvalidNodeId = -1;
 
         /// <summary>
-        /// ID used to indicate that the results for a particular configuration may at one point 
-        /// have resided on this node, but currently do not and will need to be transferred back 
-        /// in order to be used.  
+        /// ID used to indicate that the results for a particular configuration may at one point
+        /// have resided on this node, but currently do not and will need to be transferred back
+        /// in order to be used.
         /// </summary>
         internal const int ResultsTransferredId = -2;
 
@@ -50,8 +50,8 @@ internal class Scheduler : IScheduler
         internal const int VirtualNode = 0;
 
         /// <summary>
-        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the default multiplier for the amount by which 
-        /// the count of configurations on any one node can exceed the average configuration count is 1.1 -- 
+        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the default multiplier for the amount by which
+        /// the count of configurations on any one node can exceed the average configuration count is 1.1 --
         /// + 10%.
         /// </summary>
         private const double DefaultCustomSchedulerForSQLConfigurationLimitMultiplier = 1.1;
@@ -81,13 +81,13 @@ internal class Scheduler : IScheduler
         private Dictionary<int, NodeInfo> _availableNodes;
 
         /// <summary>
-        /// The number of inproc nodes that can be created without hitting the 
+        /// The number of inproc nodes that can be created without hitting the
         /// node limit.
         /// </summary>
         private int _currentInProcNodeCount = 0;
 
         /// <summary>
-        /// The number of out-of-proc nodes that can be created without hitting the 
+        /// The number of out-of-proc nodes that can be created without hitting the
         /// node limit.
         /// </summary>
         private int _currentOutOfProcNodeCount = 0;
@@ -135,9 +135,9 @@ internal class Scheduler : IScheduler
         private string _debugDumpPath;
 
         /// <summary>
-        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the user may also choose to set 
-        /// MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER to the value by which they want 
-        /// the max configuration count for any one node to exceed the average configuration count.  
+        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the user may also choose to set
+        /// MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER to the value by which they want
+        /// the max configuration count for any one node to exceed the average configuration count.
         /// If that env var is not set, or is set to an invalid value (negative, less than 1, non-numeric)
         /// then we use the default value instead.
         /// </summary>
@@ -198,8 +198,8 @@ public Scheduler()
         #region Delegates
 
         /// <summary>
-        /// In the circumstance where we want to specify the scheduling algorithm via the secret environment variable 
-        /// MSBUILDCUSTOMSCHEDULING, the scheduling algorithm used will be assigned to a delegate of this type. 
+        /// In the circumstance where we want to specify the scheduling algorithm via the secret environment variable
+        /// MSBUILDCUSTOMSCHEDULING, the scheduling algorithm used will be assigned to a delegate of this type.
         /// </summary>
         internal delegate void AssignUnscheduledRequestsDelegate(List<ScheduleResponse> responses, HashSet<int> idleNodes);
 
@@ -742,8 +742,8 @@ private void AssignUnscheduledRequestsToNodes(List<ScheduleResponse> responses,
         }
 
         /// <summary>
-        /// Reads in the scheduling plan if one exists and has not previously been read; returns true if the scheduling plan 
-        /// both exists and is valid, or false otherwise. 
+        /// Reads in the scheduling plan if one exists and has not previously been read; returns true if the scheduling plan
+        /// both exists and is valid, or false otherwise.
         /// </summary>
         private bool GetSchedulingPlanAndAlgorithm()
         {
@@ -1164,13 +1164,13 @@ private void AssignUnscheduledRequestsFIFO(List<ScheduleResponse> responses, Has
         }
 
         /// <summary>
-        /// Custom scheduler for the SQL folks to solve a performance problem with their builds where they end up with a few long-running 
-        /// requests on all but one node, and then a very large number of short-running requests on that one node -- which is by design for 
-        /// our current scheduler, but makes it so that later in the build, when these configurations are re-entered with new requests, the 
-        /// build becomes essentially serial because so many of the configurations are tied to that one node.  
-        /// 
-        /// Fixes that problem by intentionally choosing to refrain from assigning new configurations to idle nodes if those idle nodes already 
-        /// have more than their fair share of the existing configurations assigned to them. 
+        /// Custom scheduler for the SQL folks to solve a performance problem with their builds where they end up with a few long-running
+        /// requests on all but one node, and then a very large number of short-running requests on that one node -- which is by design for
+        /// our current scheduler, but makes it so that later in the build, when these configurations are re-entered with new requests, the
+        /// build becomes essentially serial because so many of the configurations are tied to that one node.
+        ///
+        /// Fixes that problem by intentionally choosing to refrain from assigning new configurations to idle nodes if those idle nodes already
+        /// have more than their fair share of the existing configurations assigned to them.
         /// </summary>
         private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
@@ -1247,8 +1247,8 @@ private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleRe
         /// </summary>
         private void AssignUnscheduledRequestToNode(SchedulableRequest request, int nodeId, List<ScheduleResponse> responses)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(request, "request");
-            ErrorUtilities.VerifyThrowArgumentNull(responses, "responses");
+            ErrorUtilities.VerifyThrowArgumentNull(request, nameof(request));
+            ErrorUtilities.VerifyThrowArgumentNull(responses, nameof(responses));
             ErrorUtilities.VerifyThrow(nodeId != InvalidNodeId, "Invalid node id specified.");
 
             // Currently we cannot move certain kinds of traversals (notably solution metaprojects) to other nodes because 
@@ -1287,21 +1287,12 @@ private bool AtSchedulingLimit()
                 return false;
             }
 
-            int limit = 0;
-            switch (_componentHost.BuildParameters.MaxNodeCount)
+            int limit = _componentHost.BuildParameters.MaxNodeCount switch
             {
-                case 1:
-                    limit = 1;
-                    break;
-
-                case 2:
-                    limit = _componentHost.BuildParameters.MaxNodeCount + 1 + _nodeLimitOffset;
-                    break;
-
-                default:
-                    limit = _componentHost.BuildParameters.MaxNodeCount + 2 + _nodeLimitOffset;
-                    break;
-            }
+                1 => 1,
+                2 => _componentHost.BuildParameters.MaxNodeCount + 1 + _nodeLimitOffset,
+                _ => _componentHost.BuildParameters.MaxNodeCount + 2 + _nodeLimitOffset,
+            };
 
             // We're at our limit of schedulable requests if: 
             // (1) MaxNodeCount requests are currently executing
@@ -1328,14 +1319,14 @@ private bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
 
         /// <summary>
         /// Adds CreateNode responses to satisfy all the affinities in the list of requests, with the following constraints:
-        /// 
+        ///
         /// a) Issue no more than one response to create an inproc node, and aggressively issues as many requests for an out-of-proc node
-        ///    as there are requests to assign to them. 
-        ///    
+        ///    as there are requests to assign to them.
+        ///
         /// b) Don't exceed the max node count, *unless* there isn't even one node of the necessary affinity yet. (That means that even if there's a max
-        ///    node count of e.g., 3, and we have already created 3 out of proc nodes, we will still create an inproc node if affinity requires it; if 
+        ///    node count of e.g., 3, and we have already created 3 out of proc nodes, we will still create an inproc node if affinity requires it; if
         ///    we didn't, the build would jam.)
-        ///    
+        ///
         /// Returns true if there is a pending response to create a new node.
         /// </summary>
         private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerable<SchedulableRequest> requests)
@@ -1486,8 +1477,8 @@ private void MarkRequestAborted(SchedulableRequest request)
         /// </summary>
         private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRequest, BuildRequestBlocker blocker)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(blockedRequest, "blockedRequest");
-            ErrorUtilities.VerifyThrowArgumentNull(blocker, "blocker");
+            ErrorUtilities.VerifyThrowArgumentNull(blockedRequest, nameof(blockedRequest));
+            ErrorUtilities.VerifyThrowArgumentNull(blocker, nameof(blocker));
 
             // We are blocked on an in-progress request building a target whose results we need.
             SchedulableRequest blockingRequest = _schedulingData.GetScheduledRequest(blocker.BlockingRequestId);
@@ -1545,8 +1536,8 @@ private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequ
         /// </summary>
         private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest, BuildRequestBlocker blocker, List<ScheduleResponse> responses)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(blocker, "blocker");
-            ErrorUtilities.VerifyThrowArgumentNull(responses, "responses");
+            ErrorUtilities.VerifyThrowArgumentNull(blocker, nameof(blocker));
+            ErrorUtilities.VerifyThrowArgumentNull(responses, nameof(responses));
 
             // The request is waiting on new requests.
             bool abortRequestBatch = false;
@@ -1659,10 +1650,7 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                         BuildRequest requestToAdd = requestsToAdd.Pop();
                         SchedulableRequest blockingRequest = _schedulingData.CreateRequest(requestToAdd, parentRequest);
 
-                        if (parentRequest != null)
-                        {
-                            parentRequest.BlockByRequest(blockingRequest, blocker.TargetsInProgress);
-                        }
+                        parentRequest?.BlockByRequest(blockingRequest, blocker.TargetsInProgress);
                     }
                 }
             }
@@ -1688,7 +1676,7 @@ private void ResumeReadyRequestIfAny(int nodeId, List<ScheduleResponse> response
         }
 
         /// <summary>
-        /// Attempts to get results from the cache for this request.  If results are available, reports them to the 
+        /// Attempts to get results from the cache for this request.  If results are available, reports them to the
         /// correct node.  If that action causes the parent to become ready and its node is idle, the parent is
         /// resumed.
         /// </summary>
@@ -1976,8 +1964,8 @@ private NodeAffinity GetNodeAffinityForRequest(BuildRequest request)
         }
 
         /// <summary>
-        /// Iterates through the set of available nodes and checks whether any of them is 
-        /// capable of servicing this request or any of the requests that it is blocked 
+        /// Iterates through the set of available nodes and checks whether any of them is
+        /// capable of servicing this request or any of the requests that it is blocked
         /// by (regardless of whether they are currently available to do so).
         /// </summary>
         private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
@@ -2016,7 +2004,7 @@ private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
         /// assigns a new request id.
         /// </summary>
         /// <remarks>
-        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the 
+        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the
         /// requests to find a matching one.  A HashSet with proper equality semantics and a good hash code for the BuildRequest
         /// would speed this considerably, especially for large numbers of projects in a build.
         /// </remarks>
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 4ea8954c988..3f541b05568 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
-
     internal sealed class CachingSdkResolverService: SdkResolverService
     {
         /// <summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 96a9aba7954..0c52dddff33 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -121,7 +121,6 @@ private void HandleRequest(int node, SdkResolverRequest request)
 
                         // Create the thread which processes requests
                         _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);
-                        
                     }
                 }
             }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index c3a86600cde..1f9eb065df4 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -47,6 +47,7 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
         ///     Root\SdkResolver\(ResolverName)\(ResolverName).dll.
         /// </summary>
         /// <param name="rootFolder"></param>
+        /// <param name="location"></param>
         /// <returns></returns>
         internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
         {
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 9afca3f4c4c..dd0ca202dc1 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -31,20 +31,13 @@ internal static SdkResolverManifest Load(string filePath)
             {
                 while (reader.Read())
                 {
-                    switch (reader.NodeType)
+                    if (reader.NodeType == XmlNodeType.Element && reader.Name == "SdkResolver")
                     {
-                        case XmlNodeType.Element:
-                            switch (reader.Name)
-                            {
-                                case "SdkResolver":
-                                    return ParseSdkResolverElement(reader);
-
-                                default:
-                                    throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
-                            }
-
-                        default:
-                            throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
+                        return ParseSdkResolverElement(reader);
+                    }
+                    else
+                    {
+                        throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
                     }
                 }
             }
@@ -62,15 +55,11 @@ private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)
                 {
                     case XmlNodeType.Element:
                         {
-                            switch (reader.Name)
+                            manifest.Path = reader.Name switch
                             {
-                                case "Path":
-                                    manifest.Path = reader.ReadElementContentAsString();
-                                    break;
-
-                                default:
-                                    throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
-                            }
+                                "Path" => reader.ReadElementContentAsString(),
+                                _ => throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name)),
+                            };
                         }
                         break;
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index bb66cd23cd0..55add7055bb 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -43,7 +43,6 @@ public SdkResult(SdkReference sdkReference, string path, string version, IEnumer
 
         public SdkResult()
         {
-
         }
 
         public SdkResult(SdkReference sdkReference, IEnumerable<string> paths, string version, IDictionary<string, string> propertiesToAdd,
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 2afdf5f88a6..4d170a3853c 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -161,7 +161,7 @@ public OutOfProcNode()
             ((IBuildComponentHost) this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
 
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
-            
+
             if (s_projectRootElementCacheBase == null)
             {
                 s_projectRootElementCacheBase = new ProjectRootElementCache(true /* automatically reload any changes from disk */);
@@ -729,7 +729,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             try
             {
                 // If there are no node loggers to initialize dont do anything
-                if (configuration.LoggerDescriptions != null && configuration.LoggerDescriptions.Length > 0)
+                if (configuration.LoggerDescriptions?.Length > 0)
                 {
                     _loggingService.InitializeNodeLoggers(configuration.LoggerDescriptions, sink, configuration.NodeId);
                 }
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index ab48153c24a..3d72ed52c91 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -115,7 +115,7 @@ public BuildRequest(
             bool skipStaticGraphIsolationConstraints = false)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
-            ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, "parentBuildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, nameof(parentBuildEventContext));
 
             _submissionId = submissionId;
             _configurationId = configurationId;
@@ -293,7 +293,6 @@ public RequestedProjectState RequestedProjectState
             set => _requestedProjectState = value;
         }
 
-
         /// <summary>
         /// The route for host-aware tasks back to the host
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 301a9246a07..e5d4460efd7 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -263,7 +263,7 @@ internal BuildRequestConfiguration()
 
         /// <summary>
         /// When reset caches is false we need to only keep around the configurations which are being asked for during the design time build.
-        /// Other configurations need to be cleared. If this configuration is marked as ExplicitlyLoadedConfiguration then it should not be cleared when 
+        /// Other configurations need to be cleared. If this configuration is marked as ExplicitlyLoadedConfiguration then it should not be cleared when
         /// Reset Caches is false.
         /// </summary>
         public bool ExplicitlyLoaded { get; set; }
@@ -276,7 +276,7 @@ internal BuildRequestConfiguration()
         /// <summary>
         /// Flag indicating whether or not the configuration has been loaded before.
         /// </summary>
-        public bool IsLoaded => _project != null && _project.IsLoaded;
+        public bool IsLoaded => _project?.IsLoaded == true;
 
         /// <summary>
         /// Flag indicating if the configuration is cached or not.
diff --git a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
index ffb073df4f4..74f3a81a22a 100644
--- a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
@@ -44,7 +44,7 @@ internal BuildRequestUnblocker(ITranslator translator)
         /// </summary>
         internal BuildRequestUnblocker(int globalRequestIdToResume)
         {
-            ErrorUtilities.VerifyThrowArgumentOutOfRange(globalRequestIdToResume != BuildRequest.InvalidGlobalRequestId, "globalRequestIdToResume");
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(globalRequestIdToResume != BuildRequest.InvalidGlobalRequestId, nameof(globalRequestIdToResume));
             _blockedGlobalRequestId = globalRequestIdToResume;
         }
 
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 465f2b21122..ec0d6b998c9 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -502,7 +502,7 @@ public void MergeResults(BuildResult results)
             }
 
             // If there is an exception and we did not previously have one, add it in.
-            _requestException = _requestException ?? results.Exception;
+            _requestException ??= results.Exception;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index a22c5e63346..a90150fdfa5 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -392,7 +392,7 @@ static ItemsStore()
             /// </summary>
             public ItemsStore(TaskItem[] items)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(items, "items");
+                ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
                 _uncompressedItems = items;
                 _itemsCount = items.Length;
             }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 81183622bb9..27ad473350a 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -257,12 +257,12 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
 
             if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
             {
-                requirements = requirements | TaskRequirements.RequireSTAThread;
+                requirements |= TaskRequirements.RequireSTAThread;
             }
 
             if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
             {
-                requirements = requirements | TaskRequirements.RequireSeparateAppDomain;
+                requirements |= TaskRequirements.RequireSeparateAppDomain;
 
                 // we're going to be remoting across the appdomain boundary, so
                 // create the list that we'll use to disconnect the taskitems once we're done
@@ -1480,7 +1480,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         // if individual items in the array are null, ignore them
                         if (output != null)
                         {
-                            joinedOutputs = joinedOutputs ?? new StringBuilder();
+                            joinedOutputs ??= new StringBuilder();
 
                             if (joinedOutputs.Length > 0)
                             {
@@ -1556,7 +1556,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         // if individual outputs in the array are null, ignore them
                         if (output != null)
                         {
-                            joinedOutputs = joinedOutputs ?? new StringBuilder();
+                            joinedOutputs ??= new StringBuilder();
 
                             if (joinedOutputs.Length > 0)
                             {
diff --git a/src/Build/Collections/LookasideStringInterner.cs b/src/Build/Collections/LookasideStringInterner.cs
index a71f382b43f..01f8a0928ab 100644
--- a/src/Build/Collections/LookasideStringInterner.cs
+++ b/src/Build/Collections/LookasideStringInterner.cs
@@ -11,9 +11,9 @@ namespace Microsoft.Build.Collections
     /// A simple string interner designed for IPC.
     /// </summary>
     /// <remarks>
-    /// This interner works by providing a way to convert strings to integer IDs.  When used as a form of compression, 
+    /// This interner works by providing a way to convert strings to integer IDs.  When used as a form of compression,
     /// clients will intern their strings and record the set of IDs returned, then transmit those IDs instead of the
-    /// original strings.  The interner itself is also transmitted ahead of time, with the IDs, allowing 
+    /// original strings.  The interner itself is also transmitted ahead of time, with the IDs, allowing
     /// reconstruction of the original strings.  This ensures each string is transmitted exactly once.
     /// </remarks>
     internal class LookasideStringInterner : ITranslatable
@@ -52,7 +52,7 @@ public LookasideStringInterner(StringComparer comparer, int defaultCollectionSiz
         /// Constructor to be used during deserialization.
         /// </summary>
         /// <remarks>
-        /// Intern cannot be used on this interner if it came from serialization, since we do 
+        /// Intern cannot be used on this interner if it came from serialization, since we do
         /// not reconstruct the interning dictionary.
         /// </remarks>
         public LookasideStringInterner(ITranslator translator)
@@ -98,17 +98,12 @@ public int Intern(string str)
         /// <returns>The corresponding string.</returns>
         public string GetString(int index)
         {
-            switch (index)
+            return index switch
             {
-                case NullStringIndex:
-                    return null;
-
-                case EmptyStringIndex:
-                    return String.Empty;
-
-                default:
-                    return _strings[index];
-            }
+                NullStringIndex => null,
+                EmptyStringIndex => String.Empty,
+                _ => _strings[index],
+            };
         }
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 86aa1e507d1..757a5a8e3bf 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -284,7 +284,7 @@ public bool Equals(PropertyDictionary<T> other)
                 foreach (T leftProp in this)
                 {
                     T rightProp = other[leftProp.Key];
-                    if (rightProp == null || !rightProp.Equals(leftProp))
+                    if (rightProp?.Equals(leftProp) != true)
                     {
                         return false;
                     }
diff --git a/src/Build/Collections/ReadOnlyConvertingDictionary.cs b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
index 9b5766c94bd..33bfb114787 100644
--- a/src/Build/Collections/ReadOnlyConvertingDictionary.cs
+++ b/src/Build/Collections/ReadOnlyConvertingDictionary.cs
@@ -32,8 +32,8 @@ internal class ReadOnlyConvertingDictionary<K, V, N> : IDictionary<K, N>
         /// </summary>
         internal ReadOnlyConvertingDictionary(IDictionary<K, V> backing, Func<V, N> converter)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(backing, "backing");
-            ErrorUtilities.VerifyThrowArgumentNull(converter, "converter");
+            ErrorUtilities.VerifyThrowArgumentNull(backing, nameof(backing));
+            ErrorUtilities.VerifyThrowArgumentNull(converter, nameof(converter));
 
             _backing = backing;
             _converter = converter;
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 2ad4638c0a8..5ad26fa69db 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -170,7 +170,7 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
         {
             if (collection == null)
             {
-                throw new ArgumentNullException("collection");
+                throw new ArgumentNullException(nameof(collection));
             }
 
             Contract.EndContractBlock();
@@ -342,10 +342,10 @@ public T Get(string key)
         public T Get(string key, int index, int length)
         {
             if (length < 0)
-                throw new ArgumentOutOfRangeException("length");
+                throw new ArgumentOutOfRangeException(nameof(length));
 
             if (index < 0 || index > (key == null ? 0 : key.Length) - length)
-                throw new ArgumentOutOfRangeException("index");
+                throw new ArgumentOutOfRangeException(nameof(index));
 
             if (_constrainedComparer == null)
                 throw new InvalidOperationException("Cannot do a constrained lookup on this collection.");
@@ -517,7 +517,7 @@ public virtual void GetObjectData(SerializationInfo info, StreamingContext conte
         {
             if (info == null)
             {
-                throw new ArgumentNullException("info");
+                throw new ArgumentNullException(nameof(info));
             }
 
             // need to serialize version to avoid problems with serializing while enumerating
@@ -619,7 +619,7 @@ public void UnionWith(IEnumerable<T> other)
         {
             if (other == null)
             {
-                throw new ArgumentNullException("other");
+                throw new ArgumentNullException(nameof(other));
             }
             Contract.EndContractBlock();
 
@@ -1005,20 +1005,20 @@ public void CopyTo(T[] array, int arrayIndex, int count)
         {
             if (array == null)
             {
-                throw new ArgumentNullException("array");
+                throw new ArgumentNullException(nameof(array));
             }
             Contract.EndContractBlock();
 
             // check array index valid index into array
             if (arrayIndex < 0)
             {
-                throw new ArgumentOutOfRangeException("arrayIndex");
+                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
             }
 
             // also throw if count less than 0
             if (count < 0)
             {
-                throw new ArgumentOutOfRangeException("count");
+                throw new ArgumentOutOfRangeException(nameof(count));
             }
 
             // will array, starting at arrayIndex, be able to hold elements? Note: not
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index 7051dcef8bd..6193363093d 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -206,7 +206,7 @@ public int Scavenge()
 
                 if (!entry.Value.TryGetTarget(out _))
                 {
-                    remove = remove ?? new List<K>();
+                    remove ??= new List<K>();
                     remove.Add(entry.Key);
                 }
             }
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index 44c8458b111..129e9ae3f35 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -392,7 +392,6 @@ public virtual void CopyFrom(ProjectElement element)
             }
             else
             {
-
                 // Copy over the attributes from the template element.
                 foreach (XmlAttribute attribute in element.XmlElement.Attributes)
                 {
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 2c74f13933f..b55ba655ff4 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -481,7 +481,7 @@ internal void AddToXml(ProjectElement child)
                 // Therefore, we need to traverse both directions to find the first sibling of the same type as the one being added.
                 // If none is found, then the node being added is inserted as the only node of its kind
 
-                bool SiblingIsExplicitElement(ProjectElement _) => _.ExpressedAsAttribute == false;
+                bool SiblingIsExplicitElement(ProjectElement _) => !_.ExpressedAsAttribute;
 
                 if (TrySearchLeftSiblings(child.PreviousSibling, SiblingIsExplicitElement, out ProjectElement referenceSibling))
                 {
@@ -491,8 +491,7 @@ internal void AddToXml(ProjectElement child)
                     {
                         //  Try to match the surrounding formatting by checking the whitespace that precedes the node we inserted
                         //  after, and inserting the same whitespace between the previous node and the one we added
-                        if (referenceSibling.XmlElement.PreviousSibling != null &&
-                            referenceSibling.XmlElement.PreviousSibling.NodeType == XmlNodeType.Whitespace)
+                        if (referenceSibling.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
                             var newWhitespaceNode = XmlDocument.CreateWhitespace(referenceSibling.XmlElement.PreviousSibling.Value);
                             XmlElement.InsertAfter(newWhitespaceNode, referenceSibling.XmlElement);
@@ -508,8 +507,7 @@ internal void AddToXml(ProjectElement child)
                     {
                         //  Try to match the surrounding formatting by checking the whitespace that precedes where we inserted
                         //  the new node, and inserting the same whitespace between the node we added and the one after it.
-                        if (child.XmlElement.PreviousSibling != null &&
-                            child.XmlElement.PreviousSibling.NodeType == XmlNodeType.Whitespace)
+                        if (child.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
                             var newWhitespaceNode = XmlDocument.CreateWhitespace(child.XmlElement.PreviousSibling.Value);
                             XmlElement.InsertBefore(newWhitespaceNode, referenceSibling.XmlElement);
@@ -579,7 +577,7 @@ internal void RemoveFromXml(ProjectElement child)
                 {
                     //  If we are trying to preserve formatting of the file, then also remove any whitespace
                     //  that came before the node we removed.
-                    if (previousSibling != null && previousSibling.NodeType == XmlNodeType.Whitespace)
+                    if (previousSibling?.NodeType == XmlNodeType.Whitespace)
                     {
                         XmlElement.RemoveChild(previousSibling);
                     }
diff --git a/src/Build/Construction/ProjectExtensionsElement.cs b/src/Build/Construction/ProjectExtensionsElement.cs
index 10483bb6349..26bb1f9d0f0 100644
--- a/src/Build/Construction/ProjectExtensionsElement.cs
+++ b/src/Build/Construction/ProjectExtensionsElement.cs
@@ -114,7 +114,7 @@ public string this[string name]
 
             set
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
                 ErrorUtilities.VerifyThrowArgumentNull(value, "value");
 
                 if (Link != null)
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 287b965ab35..9d86a4731dd 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -142,7 +142,6 @@ public class ProjectRootElement : ProjectElementContainer
         /// </summary>
         private string _dirtyParameter = String.Empty;
 
-
         internal ProjectRootElementLink RootLink => (ProjectRootElementLink)Link;
 
         /// <summary>
@@ -748,7 +747,6 @@ public static ProjectRootElement Create(ProjectCollection projectCollection, New
             return Create(projectCollection.ProjectRootElementCache, projectFileOptions);
         }
 
-
         /// <summary>
         /// Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
         /// Uses the global project collection.
@@ -983,8 +981,8 @@ public ProjectItemElement AddItem(string itemType, string include)
         /// </remarks>
         public ProjectItemElement AddItem(string itemType, string include, IEnumerable<KeyValuePair<string, string>> metadata)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
-            ErrorUtilities.VerifyThrowArgumentLength(include, "include");
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowArgumentLength(include, nameof(include));
 
             ProjectItemGroupElement itemGroupToAddTo = null;
 
@@ -1005,7 +1003,7 @@ public ProjectItemElement AddItem(string itemType, string include, IEnumerable<K
                     itemGroupToAddTo = itemGroup;
                 }
 
-                if (itemGroupToAddTo != null && itemGroupToAddTo.Count > 0)
+                if (itemGroupToAddTo?.Count > 0)
                 {
                     break;
                 }
@@ -2033,6 +2031,7 @@ bool preserveFormatting
         /// </summary>
         /// <param name="fullPath">The full path to the document to load.</param>
         /// <param name="preserveFormatting"><code>true</code> to preserve the formatting of the document, otherwise <code>false</code>.</param>
+        /// <param name="loadAsReadOnly">Whether to load the file in read-only mode.</param>
         private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveFormatting, bool loadAsReadOnly)
         {
             ErrorUtilities.VerifyThrowInternalRooted(fullPath);
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index c1b1f309d1a..8bbebd63f45 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -114,7 +114,7 @@ public string Name
         }
 
         /// <summary>
-        /// Gets or sets the Inputs value. 
+        /// Gets or sets the Inputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -134,7 +134,7 @@ public string Inputs
         }
 
         /// <summary>
-        /// Gets or sets the Outputs value. 
+        /// Gets or sets the Outputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -154,7 +154,7 @@ public string Outputs
         }
 
         /// <summary>
-        /// Gets or sets the TrimDuplicateOutputs value. 
+        /// Gets or sets the TrimDuplicateOutputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -182,7 +182,7 @@ public string KeepDuplicateOutputs
         }
 
         /// <summary>
-        /// Gets or sets the DependsOnTargets value. 
+        /// Gets or sets the DependsOnTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -202,7 +202,7 @@ public string DependsOnTargets
         }
 
         /// <summary>
-        /// Gets or sets the BeforeTargets value. 
+        /// Gets or sets the BeforeTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -222,7 +222,7 @@ public string BeforeTargets
         }
 
         /// <summary>
-        /// Gets or sets the AfterTargets value. 
+        /// Gets or sets the AfterTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -242,10 +242,10 @@ public string AfterTargets
         }
 
         /// <summary>
-        /// Gets or sets the Returns value. 
-        /// Returns null if the attribute is not present -- empty string is an allowable 
-        /// value for both getting and setting. 
-        /// Removes the attribute only if the value is set to null. 
+        /// Gets or sets the Returns value.
+        /// Returns null if the attribute is not present -- empty string is an allowable
+        /// value for both getting and setting.
+        /// Removes the attribute only if the value is set to null.
         /// </summary>
         public string Returns
         {
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index f09324cbbc0..424aa432fdf 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -48,7 +48,7 @@ internal ProjectTaskElement(ProjectTaskElementLink link)
         internal ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
         }
 
         /// <summary>
@@ -60,7 +60,7 @@ private ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement
         }
 
         /// <summary>
-        /// Gets or sets the continue on error value. 
+        /// Gets or sets the continue on error value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -80,7 +80,7 @@ public string ContinueOnError
         }
 
         /// <summary>
-        /// Gets or sets the runtime value for the task. 
+        /// Gets or sets the runtime value for the task.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -100,7 +100,7 @@ public string MSBuildRuntime
         }
 
         /// <summary>
-        /// Gets or sets the architecture value for the task. 
+        /// Gets or sets the architecture value for the task.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -226,8 +226,8 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
         }
 
         /// <summary>
-        /// Convenience method to add an Output Item to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add an Output Item to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputItem(string taskParameter, string itemType)
         {
@@ -238,8 +238,8 @@ public ProjectOutputElement AddOutputItem(string taskParameter, string itemType)
         }
 
         /// <summary>
-        /// Convenience method to add a conditioned Output Item to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add a conditioned Output Item to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition)
         {
@@ -256,8 +256,8 @@ public ProjectOutputElement AddOutputItem(string taskParameter, string itemType,
         }
 
         /// <summary>
-        /// Convenience method to add an Output Property to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add an Output Property to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName)
         {
@@ -268,8 +268,8 @@ public ProjectOutputElement AddOutputProperty(string taskParameter, string prope
         }
 
         /// <summary>
-        /// Convenience method to add a conditioned Output Property to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add a conditioned Output Property to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition)
         {
@@ -377,7 +377,7 @@ public void RemoveAllParameters()
                 {
                     if (!XMakeAttributes.IsSpecialTaskAttribute(attribute.Name))
                     {
-                        toRemove = toRemove ?? new List<XmlAttribute>();
+                        toRemove ??= new List<XmlAttribute>();
                         toRemove.Add(attribute);
                     }
                 }
diff --git a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
index 89173d16092..0700c134ddb 100644
--- a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
@@ -10,7 +10,6 @@ namespace Microsoft.Build.Construction
     /// </summary>
     public sealed class ProjectConfigurationInSolution
     {
-
         /// <summary>
         /// Constructor
         /// </summary>
@@ -52,7 +51,7 @@ internal ProjectConfigurationInSolution(string configurationName, string platfor
         /// </summary>
         private static string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
-            if (string.Compare(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
             {
                 return "AnyCPU";
             }
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 2c6235654ee..9bd2f1723a1 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -282,14 +282,14 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                     }
                 }
 
-                if (mainProjectElement != null && mainProjectElement.LocalName == "Project")
+                if (mainProjectElement?.LocalName == "Project")
                 {
                     // MSBuild supports project files with an empty (supported in Visual Studio 2017) or the default MSBuild
                     // namespace.
                     bool emptyNamespace = string.IsNullOrEmpty(mainProjectElement.NamespaceURI);
-                    bool defaultNamespace = String.Compare(mainProjectElement.NamespaceURI,
+                    bool defaultNamespace = String.Equals(mainProjectElement.NamespaceURI,
                                                 XMakeAttributes.defaultXmlNamespace,
-                                                StringComparison.OrdinalIgnoreCase) == 0;
+                                                StringComparison.OrdinalIgnoreCase);
                     bool projectElementInvalid = ElementContainsInvalidNamespaceDefitions(mainProjectElement);
 
                     // If the MSBuild namespace is declared, it is very likely an MSBuild project that should be built.
@@ -434,7 +434,7 @@ internal static string DisambiguateProjectTargetName(string uniqueProjectName)
             // entry point targets
             foreach (string projectName in projectNamesToDisambiguate)
             {
-                if (String.Compare(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase))
                 {
                     // Prepend "Solution:" so that the collision is resolved, but the
                     // log of the solution project still looks reasonable.
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 5d3e7d5f5f8..ba79cd99cc5 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -232,7 +232,7 @@ internal string FullPath
 
         internal bool ProjectShouldBuild(string projectFile)
         {
-            return _solutionFilter == null || _solutionFilter.Contains(projectFile);
+            return _solutionFilter?.Contains(projectFile) != false;
         }
 
         /// <summary>
@@ -609,7 +609,6 @@ internal void ParseSolution()
                     new BuildEventFileInfo(FullPath),
                     "SolutionParseDuplicateProject",
                     uniqueName);
-
             }
         } // ParseSolutionFile()
 
@@ -757,7 +756,7 @@ private void ParseProject(string firstLine)
                     // We have a ProjectDependencies section.  Each subsequent line should identify
                     // a dependency.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
@@ -777,7 +776,7 @@ private void ParseProject(string firstLine)
                     // projects, and contains properties that we'll need in order to call the 
                     // AspNetCompiler task.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         Match match = s_crackPropertyLine.Value.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
@@ -1131,7 +1130,7 @@ string propertyValue
             else
             {
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
-                if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
 
@@ -1159,7 +1158,7 @@ string propertyValue
                         }
                     }
                 }
-                else if (String.Compare(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase))
                 {
                     //Website project need to back support 3.5 msbuild parser for the Blend (it is not move to .Net4.0 yet.)
                     //However, 3.5 version of Solution parser can't handle a equal sign in the value.  
@@ -1223,29 +1222,29 @@ ProjectInSolution proj
             ValidateProjectRelativePath(proj);
 
             // Figure out what type of project this is.
-            if ((String.Compare(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsCsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsVbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase) == 0))
+            if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsCsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsVbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
             }
-            else if (String.Compare(projectTypeGuid, sharedProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, sharedProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SharedProject;
             }
-            else if (String.Compare(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SolutionFolder;
             }
             // MSBuild format VC projects have the same project type guid as old style VC projects.
             // If it's not an old-style VC project, we'll assume it's MSBuild format
-            else if (String.Compare(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 if (String.Equals(proj.Extension, ".vcproj", StringComparison.OrdinalIgnoreCase))
                 {
@@ -1261,12 +1260,12 @@ ProjectInSolution proj
                     proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
                 }
             }
-            else if (String.Compare(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebProject;
                 ContainsWebProjects = true;
             }
-            else if (String.Compare(projectTypeGuid, wdProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, wdProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebDeploymentProject;
                 ContainsWebDeploymentProjects = true;
@@ -1352,7 +1351,7 @@ internal void ParseSolutionConfigurations()
                 string fullConfigurationName = configurationNames[0].Trim();
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
-                if (0 == String.Compare(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
                 {
                     continue;
                 }
@@ -1493,7 +1492,7 @@ public string GetDefaultConfigurationName()
             // Pick the Debug configuration as default if present
             foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultConfigurationName = solutionConfiguration.ConfigurationName;
                     break;
@@ -1526,13 +1525,13 @@ public string GetDefaultPlatformName()
             // Pick the Mixed Platforms platform as default if present
             foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultPlatformName = solutionConfiguration.PlatformName;
                     break;
                 }
                 // We would like this to be chosen if Mixed platforms does not exist.
-                else if (string.Compare(solutionConfiguration.PlatformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (string.Equals(solutionConfiguration.PlatformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultPlatformName = solutionConfiguration.PlatformName;
                 }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index b1f32e3a5d0..b648a919617 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -101,7 +101,7 @@ internal class SolutionProjectGenerator
         private readonly SolutionFile _solutionFile;
 
         /// <summary>
-        /// The global properties passed under which the project should be opened. 
+        /// The global properties passed under which the project should be opened.
         /// </summary>
         private readonly IDictionary<string, string> _globalProperties;
 
@@ -111,7 +111,7 @@ internal class SolutionProjectGenerator
         private readonly string _toolsVersionOverride;
 
         /// <summary>
-        /// The context of this build (used for logging purposes). 
+        /// The context of this build (used for logging purposes).
         /// </summary>
         private readonly BuildEventContext _projectBuildEventContext;
 
@@ -168,7 +168,7 @@ private SolutionProjectGenerator(
         }
 
         /// <summary>
-        /// This method generates an MSBuild project file from the list of projects and project dependencies 
+        /// This method generates an MSBuild project file from the list of projects and project dependencies
         /// that have been collected from the solution file.
         /// </summary>
         /// <param name="solution">The parser which contains the solution file.</param>
@@ -321,7 +321,7 @@ params object[] args
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         internal static string PredictActiveSolutionConfigurationName(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
@@ -376,7 +376,7 @@ private static string DetermineWrapperProjectToolsVersion(string toolsVersionOve
 
 #if FEATURE_ASPNET_COMPILER
         /// <summary>
-        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced 
+        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced
         /// assemblies for the complete list of dependencies, PDBs, satellites, etc.  The invoke
         /// the Copy task to copy all these files (or at least the ones that RAR determined should
         /// be copied local) into the web project's bin directory.
@@ -439,10 +439,10 @@ string conditionDescribingValidConfigurations
         }
 
         /// <summary>
-        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of 
-        /// a web project.  These .REFRESH files are just text files that contain absolute or 
-        /// relative paths to the referenced assemblies.  The goal of these tasks is to 
-        /// search all *.REFRESH files and extract fully-qualified absolute paths for 
+        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of
+        /// a web project.  These .REFRESH files are just text files that contain absolute or
+        /// relative paths to the referenced assemblies.  The goal of these tasks is to
+        /// search all *.REFRESH files and extract fully-qualified absolute paths for
         /// each of the references.
         /// </summary>
         private static void AddTasksToResolveAutoRefreshFileReferences
@@ -853,7 +853,6 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             ProjectImportElement importAfter = traversalProject.CreateImportElement(@"$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter\*");
             importAfter.Condition = @"'$(ImportByWildcardBeforeSolution)' != 'false' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\SolutionFile\ImportAfter')"; // Avoids wildcard perf problem
 
-
             /* The code below adds the following XML:
 
             - TOP -
@@ -995,7 +994,7 @@ private void EmitMetaproject(ProjectRootElement metaproject, string path)
             {
                 metaproject.Save(path);
             }
-            if (_loggingService.IncludeEvaluationMetaprojects == true)
+            if (_loggingService.IncludeEvaluationMetaprojects)
             {
                 var xml = new StringBuilder();
                 using (var writer = new StringWriter(xml))
@@ -1141,35 +1140,35 @@ private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolutio
         }
 
         /// <summary>
-        /// Produces a set of targets which allows the MSBuild scheduler to schedule projects in the order automatically by 
+        /// Produces a set of targets which allows the MSBuild scheduler to schedule projects in the order automatically by
         /// following their dependencies without enforcing build levels.
         /// </summary>
         /// <remarks>
         /// We want MSBuild to be able to parallelize the builds of these projects where possible and still honor references.
         /// Since the project files referenced by the solution do not (necessarily) themselves contain actual project references
         /// to the projects they depend on, we need to synthesize this relationship ourselves.  This is done by creating a target
-        /// which first invokes the project's dependencies, then invokes the actual project itself.  However, invoking the 
-        /// dependencies must also invoke their dependencies and so on down the line.  
-        /// 
+        /// which first invokes the project's dependencies, then invokes the actual project itself.  However, invoking the
+        /// dependencies must also invoke their dependencies and so on down the line.
+        ///
         /// Additionally, we do not wish to create a separate MSBuild project to contain this target yet we want to parallelize
         /// calls to these targets.  The way to do this is to pass in different global properties to the same project in the same
         /// MSBuild call.  MSBuild easily allows this using the AdditionalProperties metadata which can be specified on an Item.
-        /// 
+        ///
         /// Assuming the solution project we are generating is called "foo.proj", we can accomplish this parallelism as follows:
         /// <ItemGroup>
         ///     <ProjectReference Include="Project0"/>
         ///     <ProjectReference Include="Project1"/>
         ///     <ProjectReference Include="Project2"/>
         /// </ItemGroup>
-        /// 
+        ///
         /// We now have expressed the top level reference to all projects as @(SolutionReference) and each project's
         /// set of references as @(PROJECTNAMEReference).  We construct our target as:
-        /// 
+        ///
         /// <Target Name="Build">
         ///     <MSBuild Projects="@(ProjectReference)" Targets="Build" />
         ///     <MSBuild Projects="actualProjectName" Targets="Build" />
         /// </Target>
-        /// 
+        ///
         /// The first MSBuild call re-invokes the solution project instructing it to build the reference projects for the
         /// current project.  The second MSBuild call invokes the actual project itself.  Because all reference projects have
         /// the same additional properties, MSBuild will only build the first one it comes across and the rest will be
@@ -1740,7 +1739,7 @@ string solutionFile
 
         /// <summary>
         /// When adding a target to build a web project, we want to put a Condition on the Target node that
-        /// effectively says "Only build this target if the web project is active (marked for building) in the 
+        /// effectively says "Only build this target if the web project is active (marked for building) in the
         /// current solution configuration.
         /// </summary>
         private string ComputeTargetConditionForWebProject(ProjectInSolution project)
@@ -1764,8 +1763,8 @@ private string ComputeTargetConditionForWebProject(ProjectInSolution project)
                         condition.Append(")");
                     }
                 }
-                else if (String.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0 ||
-                         String.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) ||
+                         String.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     // we don't have a project configuration that matches the solution configuration but
                     // the solution configuration is called "Release" or "Debug" which are standard AspNetConfigurations
@@ -2105,7 +2104,7 @@ private string DetermineChildProjectToolsVersion(string wrapperProjectToolsVersi
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         private string PredictActiveSolutionConfigurationName()
@@ -2115,7 +2114,7 @@ private string PredictActiveSolutionConfigurationName()
 
         /// <summary>
         /// Loads each MSBuild project in this solution and looks for its project-to-project references so that
-        /// we know what build order we should use when building the solution. 
+        /// we know what build order we should use when building the solution.
         /// </summary>
         private void ScanProjectDependencies(string childProjectToolsVersion, string fullSolutionConfigurationName)
         {
@@ -2255,12 +2254,12 @@ private void AddPropertyGroupForSolutionConfiguration(ProjectRootElement travers
         /// <summary>
         /// Creates the default Venus configuration property based on the selected solution configuration.
         /// Unfortunately, Venus projects only expose one project configuration in the IDE (Debug) although
-        /// they allow building Debug and Release from command line. This means that if we wanted to use 
+        /// they allow building Debug and Release from command line. This means that if we wanted to use
         /// the project configuration from the active solution configuration for Venus projects, we'd always
         /// end up with Debug and there'd be no way to build the Release configuration. To work around this,
         /// we use a special mechanism for choosing ASP.NET project configuration: we set it to Release if
-        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution 
-        /// configuration. The property is also settable from the command line, in which case it takes 
+        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution
+        /// configuration. The property is also settable from the command line, in which case it takes
         /// precedence over this algorithm.
         /// </summary>
         private static void AddVenusConfigurationDefaults(ProjectRootElement traversalProject)
@@ -2312,7 +2311,7 @@ private void AddGlobalProperties(ProjectRootElement traversalProject)
 
         /// <summary>
         /// Special hack for web projects. It can happen that there is no Release configuration for solutions
-        /// containing web projects, yet we still want to be able to build the Release configuration for 
+        /// containing web projects, yet we still want to be able to build the Release configuration for
         /// those projects. Since the ASP.NET project configuration defaults to the solution configuration,
         /// we allow Release even if it doesn't actually exist in the solution.
         /// </summary>
@@ -2323,7 +2322,7 @@ private void AddFakeReleaseSolutionConfigurationIfNecessary()
                 bool solutionHasReleaseConfiguration = false;
                 foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionFile.SolutionConfigurations)
                 {
-                    if (string.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase))
                     {
                         solutionHasReleaseConfiguration = true;
                         break;
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 02bba78e5d9..a0c4d6aa161 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -90,9 +90,9 @@ public class Project : ILinkableObject
         /// - <see cref="ProjectItem.RemoveMetadata"/>
         /// - <see cref="ProjectItem.SetMetadataValue(string,string)"/>
         /// - <see cref="ProjectItem.SetMetadataValue(string,string, bool)"/>
-        /// 
+        ///
         /// When this property is set to true, the previous item operations throw an <exception cref="InvalidOperationException"></exception>
-        /// instead of expanding the item element. 
+        /// instead of expanding the item element.
         /// </summary>
         public bool ThrowInsteadOfSplittingItemElement
         {
@@ -390,7 +390,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -407,7 +407,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -425,7 +425,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -572,7 +572,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Whether this project is dirty such that it needs reevaluation.
         /// This may be because its underlying XML has changed (either through this project or another)
-        /// either the XML of the main project or an imported file; 
+        /// either the XML of the main project or an imported file;
         /// or because its toolset may have changed.
         /// </summary>
         public bool IsDirty => implementation.IsDirty;
@@ -583,8 +583,8 @@ private enum BuildEnabledSetting
         /// </summary>
         /// <remarks>
         /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-        /// 
-        /// In order to easily tell when we're dirtied, setting and removing global properties is done with 
+        ///
+        /// In order to easily tell when we're dirtied, setting and removing global properties is done with
         /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
         /// </remarks>
         public IDictionary<string, string> GlobalProperties => implementation.GlobalProperties;
@@ -594,7 +594,7 @@ private enum BuildEnabledSetting
         /// This is an ordered collection.
         /// </summary>
         /// <comments>
-        /// data.ItemTypes is a KeyCollection, so it doesn't need any 
+        /// data.ItemTypes is a KeyCollection, so it doesn't need any
         /// additional read-only protection
         /// </comments>
         public ICollection<string> ItemTypes => implementation.ItemTypes;
@@ -608,17 +608,17 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Collection of possible values implied for properties contained in the conditions found on properties,
         /// property groups, imports, and whens.
-        /// 
+        ///
         /// For example, if the following conditions existed on properties in a project:
-        /// 
+        ///
         /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
         /// Condition="'$(Configuration)' == 'Release'"
-        /// 
+        ///
         /// the table would be populated with
-        /// 
+        ///
         /// { "Configuration", { "Debug", "Release" }}
         /// { "Platform", { "x86" }}
-        /// 
+        ///
         /// This is used by Visual Studio to determine the configurations defined in the project.
         /// </summary>
         public IDictionary<string, List<string>> ConditionedProperties => implementation.ConditionedProperties;
@@ -639,7 +639,7 @@ private enum BuildEnabledSetting
         /// Items in this project, ordered within groups of item types,
         /// including items whose conditions evaluated to false, or that were
         /// contained within item groups who themselves had conditioned evaluated to false.
-        /// This is useful for hosts that wish to display all items, even if they might not be part 
+        /// This is useful for hosts that wish to display all items, even if they might not be part
         /// of the build in the current configuration.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
@@ -672,7 +672,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// It does not include any properties added since the last evaluation.
         /// </summary>
@@ -681,7 +681,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// It does not include any item definition metadata added since the last evaluation.
         /// </summary>
@@ -689,7 +689,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// Items encountered during evaluation. These are read during the third evaluation pass.
-        /// Unlike those returned by the Items property, these are ordered with respect to all other items 
+        /// Unlike those returned by the Items property, these are ordered with respect to all other items
         /// encountered during evaluation, not just ordered with respect to items of the same item type.
         /// In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
         /// can use this property.
@@ -712,7 +712,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-        /// the toolset properties for this project.  
+        /// the toolset properties for this project.
         /// </summary>
         public string SubToolsetVersion => implementation.SubToolsetVersion;
 
@@ -737,7 +737,7 @@ public string FullPath
 
         /// <summary>
         /// Whether ReevaluateIfNecessary is temporarily disabled.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to the project, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         public bool SkipEvaluation
@@ -767,10 +767,10 @@ public bool DisableMarkDirty
         /// control which projects it allows to run targets/tasks.  By default, for a newly
         /// created project, we will use whatever setting is in the parent project collection.
         /// When build is disabled, the Build method on this class will fail. However if
-        /// the host has already created a ProjectInstance, it can still build it. (It is 
+        /// the host has already created a ProjectInstance, it can still build it. (It is
         /// free to put a similar check around where it does this.)
         /// </summary>
-        public bool IsBuildEnabled 
+        public bool IsBuildEnabled
         {
             [DebuggerStepThrough]
             get => implementation.IsBuildEnabled;
@@ -794,19 +794,19 @@ public bool IsBuildEnabled
         /// The ID of the last evaluation for this Project.
         /// A project is always evaluated upon construction and can subsequently get evaluated multiple times via
         /// <see cref="Project.ReevaluateIfNecessary()" />
-        /// 
+        ///
         /// It is an arbitrary number that changes when this project reevaluates.
         /// Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
         /// their previously stored value to find out, and if so perhaps decide to update their own state.
         /// Note that the number may not increase monotonically.
-        /// 
+        ///
         /// This number corresponds to the <seealso cref="BuildEventContext.EvaluationId"/> and can be used to connect
         /// evaluation logging events back to the Project instance.
         /// </summary>
         public int LastEvaluationId => implementation.LastEvaluationId;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         internal ISet<string> GlobalPropertiesToTreatAsLocal => implementationInternal.GlobalPropertiesToTreatAsLocal;
 
@@ -840,21 +840,21 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// Finds all the globs specified in item includes.
         /// </summary>
         /// <example>
-        /// 
+        ///
         /// <code>
         ///<P>*.txt</P>
-        /// 
+        ///
         ///<Bar Include="bar"/> (both outside and inside project cone)
         ///<Zar Include="C:\**\*.foo"/> (both outside and inside project cone)
         ///<Foo Include="*.a;*.b" Exclude="3.a"/>
         ///<Foo Remove="2.a" />
         ///<Foo Include="**\*.b" Exclude="1.b;**\obj\*.b;**\bar\*.b"/>
-        ///<Foo Include="$(P)"/> 
+        ///<Foo Include="$(P)"/>
         ///<Foo Include="*.a;@(Bar);3.a"/> (If Bar has globs, they will have been included when querying Bar ProjectItems for globs)
         ///<Foo Include="*.cs" Exclude="@(Bar)"/>
         ///</code>
-        /// 
-        ///Example result: 
+        ///
+        ///Example result:
         ///[
         ///GlobResult(glob: "C:\**\*.foo", exclude: []),
         ///GlobResult(glob: ["*.a", "*.b"], exclude=["3.a"], remove=["2.a"]),
@@ -867,13 +867,13 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// <remarks>
         /// <see cref="GlobResult.MsBuildGlob"/> is a <see cref="IMSBuildGlob"/> that combines all globs in the include element and ignores
         /// all the fragments in the exclude attribute and all the fragments in all Remove elements that apply to the include element.
-        /// 
+        ///
         /// Users can construct a composite glob that incorporates all the globs in the Project:
         /// <code>
         /// var uberGlob = new CompositeGlob(project.GetAllGlobs().Select(r => r.MSBuildGlob).ToArray());
         /// uberGlob.IsMatch("foo.cs");
         /// </code>
-        /// 
+        ///
         /// </remarks>
         /// <returns>
         /// List of <see cref="GlobResult"/>.
@@ -907,6 +907,7 @@ public List<GlobResult> GetAllGlobs(string itemType)
         /// <summary>
         /// See <see cref="GetAllGlobs(string)"/>
         /// </summary>
+        /// <param name="itemType">type of the item</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -922,7 +923,7 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// - elements that would update the string (not yet implemented)
         /// - elements that would remove the string (not yet implemented)
         /// </summary>
-        /// 
+        ///
         /// <example>
         /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
         /// <code>
@@ -935,28 +936,28 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         ///     <P>a.cs;*.cs;@(A)</P>
         /// </PropertyGroup>
         /// </code>
-        /// 
+        ///
         /// </example>
-        /// 
+        ///
         /// <remarks>
         /// This method and its overloads are useful for clients that need to inspect all the item elements
         /// that might refer to a specific item instance. For example, Visual Studio uses it to inspect
         /// projects with globs. Upon a file system or IDE file artifact change, VS calls this method to find all the items
         /// that might refer to the detected file change (e.g. 'which item elements refer to "Program.cs"?').
         /// It uses such information to know which elements it should edit to reflect the user or file system changes.
-        /// 
+        ///
         /// Literal string matching tries to first match the strings. If the check fails, it then tries to match
         /// the strings as if they represented files: it normalizes both strings as files relative to the current project directory
         ///
         /// GetItemProvenance suffers from some sources of inaccuracy:
         /// - it is performed after evaluation, thus is insensitive to item data flow when item references are present
         /// (it sees items as they are at the end of evaluation)
-        /// 
+        ///
         /// This API and its return types are prone to change.
         /// </remarks>
-        /// 
+        ///
         /// <param name="itemToMatch">The string to perform matching against</param>
-        /// 
+        ///
         /// <returns>
         /// A list of <see cref="ProvenanceResult"/>, sorted in project evaluation order.
         /// </returns>
@@ -968,6 +969,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch)
         /// <summary>
         /// See <see cref="GetItemProvenance(string)"/>
         /// </summary>
+        /// <param name="itemToMatch">The string to perform matching against</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -990,6 +992,8 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         /// <summary>
         /// See <see cref="GetItemProvenance(string, string)"/>
         /// </summary>
+        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemType">The type of the item to perform matching against</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -1002,7 +1006,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         /// <summary>
         /// Overload of <see cref="GetItemProvenance(string)"/>
         /// </summary>
-        /// <param name="item"> 
+        /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
         /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
         /// The element that produced this <paramref name="item"/> is included in the results.
@@ -1015,6 +1019,11 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         /// <summary>
         /// See <see cref="GetItemProvenance(ProjectItem)"/>
         /// </summary>
+        /// <param name="item">
+        /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
+        /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
+        /// The element that produced this <paramref name="item"/> is included in the results.
+        /// </param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -1025,7 +1034,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationCont
         }
 
         /// <summary>
-        /// Gets the escaped value of the provided metadatum. 
+        /// Gets the escaped value of the provided metadatum.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectMetadata metadatum)
         {
@@ -1035,7 +1044,7 @@ public static string GetMetadataValueEscaped(ProjectMetadata metadatum)
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetMetadataValueEscaped(ProjectItem item, string name)
@@ -1046,7 +1055,7 @@ public static string GetMetadataValueEscaped(ProjectItem item, string name)
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item definition. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item definition.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectItemDefinition item, string name)
         {
@@ -1068,7 +1077,7 @@ public static string GetPropertyValueEscaped(ProjectProperty property)
 
         /// <summary>
         /// Returns an iterator over the "logical project". The logical project is defined as
-        /// the unevaluated project obtained from the single MSBuild file that is the result 
+        /// the unevaluated project obtained from the single MSBuild file that is the result
         /// of inlining the text of all imports of the original MSBuild project manifest file.
         /// </summary>
         public IEnumerable<ProjectElement> GetLogicalProject()
@@ -1087,7 +1096,7 @@ public ProjectProperty GetProperty(string name)
         }
 
         /// <summary>
-        /// Get the unescaped value of a property in this project, or 
+        /// Get the unescaped value of a property in this project, or
         /// an empty string if it does not exist.
         /// </summary>
         /// <remarks>
@@ -1196,7 +1205,7 @@ public IList<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude
         /// Use AddItem or RemoveItem to modify items in this project.
         /// </summary>
         /// <comments>
-        /// data.GetItems returns a read-only collection, so no need to re-wrap it here. 
+        /// data.GetItems returns a read-only collection, so no need to re-wrap it here.
         /// </comments>
         public ICollection<ProjectItem> GetItems(string itemType)
         {
@@ -1209,7 +1218,7 @@ public ICollection<ProjectItem> GetItems(string itemType)
         /// This is a read-only list: use AddItem or RemoveItem to modify items in this project.
         /// </summary>
         /// <comments>
-        /// ItemDictionary[] returns a read only collection, so no need to wrap it. 
+        /// ItemDictionary[] returns a read only collection, so no need to wrap it.
         /// </comments>
         public ICollection<ProjectItem> GetItemsIgnoringCondition(string itemType)
         {
@@ -1309,6 +1318,7 @@ public string ExpandString(string unexpandedValue)
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
         /// </summary>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance()
         {
             return CreateProjectInstance(ProjectInstanceSettings.None, null);
@@ -1318,9 +1328,11 @@ public ProjectInstance CreateProjectInstance()
         /// Returns an instance based on this project, but completely disconnected.
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
-        /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to 
+        /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to
         /// access concurrently from multiple threads.
         /// </summary>
+        /// <param name="settings">The project instance creation settings</param>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
@@ -1329,8 +1341,9 @@ public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         /// <summary>
         /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>
         /// </summary>
+        /// <param name="settings">The project instance creation settings</param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
-        /// <returns></returns>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
@@ -1414,7 +1427,7 @@ public void Save(TextWriter writer)
         }
 
         /// <summary>
-        /// Saves a "logical" or "preprocessed" project file, that includes all the imported 
+        /// Saves a "logical" or "preprocessed" project file, that includes all the imported
         /// files as if they formed a single file.
         /// </summary>
         public void SaveLogicalProject(TextWriter writer)
@@ -1551,6 +1564,9 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<Fo
         /// <summary>
         /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>
         /// </summary>
+        /// <param name="targets"></param>
+        /// <param name="loggers"></param>
+        /// <param name="remoteLoggers"></param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
         {
@@ -1576,10 +1592,10 @@ internal bool UsesProjectRootElement(ProjectRootElement xmlRootElement)
         /// A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
         /// Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
         /// sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
-        /// 
+        ///
         /// For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
         /// item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
-        /// 
+        ///
         /// This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
         /// For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
         /// Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
@@ -1622,7 +1638,7 @@ internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement)
         }
 
         /// <summary>
-        /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
+        /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the
         /// item we wish to add, and does not have a condition or an exclude.
         /// Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
         /// Returns true if it is suitable, otherwise false.
@@ -1637,7 +1653,7 @@ internal bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItem
 
         /// <summary>
         /// Before an item changes its item type, it must be removed from
-        /// our datastructures, which key off item type. 
+        /// our datastructures, which key off item type.
         /// This should be called ONLY by ProjectItems, in this situation.
         /// </summary>
         internal void RemoveItemBeforeItemTypeChange(ProjectItem item)
@@ -1718,7 +1734,7 @@ internal void VerifyThrowInvalidOperationNotZombie()
         /// <summary>
         /// Verify that the provided object location is in the same file as the project.
         /// If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
-        /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
+        /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the
         /// main project, but for some reason was actually read in from an imported targets file.
         /// </summary>
         internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml)
@@ -1727,11 +1743,9 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
-
         /// <summary>
         /// Internal project evaluation implementation
         /// </summary>
-        /// <remarks>
         private class ProjectImpl : ProjectLink, IProjectLinkInternal
         {
             /// <summary>
@@ -1783,14 +1797,13 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             private RenameHandlerDelegate _renameHandler;
 
             /// <summary>
-            /// 
+            ///
             /// </summary>
             /// <param name="owner">The owning project object</param>
             /// <param name="xml">ProjectRootElement to use</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
             /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1815,7 +1828,6 @@ public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, st
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
             /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1839,7 +1851,7 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             }
 
             /// <summary>
-            /// Construct over an existing project file, evaluating with the specified global properties and 
+            /// Construct over an existing project file, evaluating with the specified global properties and
             /// using the tools version provided, either or both of which may be null.
             /// Project is added to the global project collection.
             /// Throws InvalidProjectFileException if the evaluation fails.
@@ -1851,7 +1863,6 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             /// <param name="globalProperties">The global properties. May be null.</param>
             /// <param name="toolsVersion">The tools version. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1904,9 +1915,9 @@ public ProjectImpl(Project owner, string projectFile, IDictionary<string, string
             /// - <see cref="ProjectItem.RemoveMetadata"/>
             /// - <see cref="ProjectItem.SetMetadataValue(string,string)"/>
             /// - <see cref="ProjectItem.SetMetadataValue(string,string, bool)"/>
-            /// 
+            ///
             /// When this property is set to true, the previous item operations throw an <exception cref="InvalidOperationException"></exception>
-            /// instead of expanding the item element. 
+            /// instead of expanding the item element.
             /// </summary>
             public override bool ThrowInsteadOfSplittingItemElement { get; set; }
 
@@ -1955,7 +1966,7 @@ public bool IsZombified
             /// <summary>
             /// Whether this project is dirty such that it needs reevaluation.
             /// This may be because its underlying XML has changed (either through this project or another)
-            /// either the XML of the main project or an imported file; 
+            /// either the XML of the main project or an imported file;
             /// or because its toolset may have changed.
             /// </summary>
             public override bool IsDirty
@@ -2023,8 +2034,8 @@ public override bool IsDirty
             /// </summary>
             /// <remarks>
             /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-            /// 
-            /// In order to easily tell when we're dirtied, setting and removing global properties is done with 
+            ///
+            /// In order to easily tell when we're dirtied, setting and removing global properties is done with
             /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
             /// </remarks>
             public override IDictionary<string, string> GlobalProperties
@@ -2052,7 +2063,7 @@ public override IDictionary<string, string> GlobalProperties
             /// This is an ordered collection.
             /// </summary>
             /// <comments>
-            /// data.ItemTypes is a KeyCollection, so it doesn't need any 
+            /// data.ItemTypes is a KeyCollection, so it doesn't need any
             /// additional read-only protection
             /// </comments>
             public override ICollection<string> ItemTypes => _data.ItemTypes;
@@ -2066,17 +2077,17 @@ public override IDictionary<string, string> GlobalProperties
             /// <summary>
             /// Collection of possible values implied for properties contained in the conditions found on properties,
             /// property groups, imports, and whens.
-            /// 
+            ///
             /// For example, if the following conditions existed on properties in a project:
-            /// 
+            ///
             /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
             /// Condition="'$(Configuration)' == 'Release'"
-            /// 
+            ///
             /// the table would be populated with
-            /// 
+            ///
             /// { "Configuration", { "Debug", "Release" }}
             /// { "Platform", { "x86" }}
-            /// 
+            ///
             /// This is used by Visual Studio to determine the configurations defined in the project.
             /// </summary>
             public override IDictionary<string, List<string>> ConditionedProperties
@@ -2109,7 +2120,7 @@ public override IDictionary<string, List<string>> ConditionedProperties
             /// Items in this project, ordered within groups of item types,
             /// including items whose conditions evaluated to false, or that were
             /// contained within item groups who themselves had conditioned evaluated to false.
-            /// This is useful for hosts that wish to display all items, even if they might not be part 
+            /// This is useful for hosts that wish to display all items, even if they might not be part
             /// of the build in the current configuration.
             /// </summary>
             [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
@@ -2200,7 +2211,7 @@ public override IDictionary<string, ProjectTargetInstance> Targets
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// It does not include any properties added since the last evaluation.
             /// </summary>
@@ -2222,7 +2233,7 @@ public override ICollection<ProjectProperty> AllEvaluatedProperties
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// It does not include any item definition metadata added since the last evaluation.
             /// </summary>
@@ -2243,7 +2254,7 @@ public override ICollection<ProjectMetadata> AllEvaluatedItemDefinitionMetadata
 
             /// <summary>
             /// Items encountered during evaluation. These are read during the third evaluation pass.
-            /// Unlike those returned by the Items property, these are ordered with respect to all other items 
+            /// Unlike those returned by the Items property, these are ordered with respect to all other items
             /// encountered during evaluation, not just ordered with respect to items of the same item type.
             /// In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
             /// can use this property.
@@ -2279,7 +2290,7 @@ public override ICollection<ProjectItem> AllEvaluatedItems
 
             /// <summary>
             /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public override string SubToolsetVersion => _data.SubToolsetVersion;
 
@@ -2304,7 +2315,7 @@ public string FullPath
 
             /// <summary>
             /// Whether ReevaluateIfNecessary is temporarily disabled.
-            /// This is useful when the host expects to make a number of reads and writes 
+            /// This is useful when the host expects to make a number of reads and writes
             /// to the project, and wants to temporarily sacrifice correctness for performance.
             /// </summary>
             public override bool SkipEvaluation { get; set; }
@@ -2322,7 +2333,7 @@ public string FullPath
             /// control which projects it allows to run targets/tasks.  By default, for a newly
             /// created project, we will use whatever setting is in the parent project collection.
             /// When build is disabled, the Build method on this class will fail. However if
-            /// the host has already created a ProjectInstance, it can still build it. (It is 
+            /// the host has already created a ProjectInstance, it can still build it. (It is
             /// free to put a similar check around where it does this.)
             /// </summary>
             public override bool IsBuildEnabled
@@ -2365,19 +2376,19 @@ public override bool IsBuildEnabled
             /// The ID of the last evaluation for this Project.
             /// A project is always evaluated upon construction and can subsequently get evaluated multiple times via
             /// <see cref="ProjectLink.ReevaluateIfNecessary" />
-            /// 
+            ///
             /// It is an arbitrary number that changes when this project reevaluates.
             /// Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
             /// their previously stored value to find out, and if so perhaps decide to update their own state.
             /// Note that the number may not increase monotonically.
-            /// 
+            ///
             /// This number corresponds to the <seealso cref="BuildEventContext.EvaluationId"/> and can be used to connect
             /// evaluation logging events back to the Project instance.
             /// </summary>
             public override int LastEvaluationId => _data.EvaluationId;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _data.GlobalPropertiesToTreatAsLocal;
 
@@ -2386,7 +2397,6 @@ public override bool IsBuildEnabled
             /// </summary>
             internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
-
             /// <summary>
             /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>
             /// </summary>
@@ -2402,6 +2412,7 @@ public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext
             /// <summary>
             /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2582,6 +2593,7 @@ private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dict
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemToMatch">The string to perform matching against</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2594,6 +2606,8 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, Eva
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2606,6 +2620,11 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>
             /// </summary>
+            /// /// <param name="item"> 
+            /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
+            /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
+            /// The element that produced this <paramref name="item"/> is included in the results.
+            /// </param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2626,7 +2645,7 @@ public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, Evalu
             /// Some project APIs need to do analysis that requires the Evaluator to record more data than usual as it evaluates.
             /// This method checks if the Evaluator was run with the extra required settings and if not, does a re-evaluation.
             /// If a re-evaluation was necessary, it saves this information so a next call does not re-evaluate.
-            /// 
+            ///
             /// Using this method avoids storing extra data in memory when its not needed.
             /// </summary>
             /// <param name="evaluationContext"></param>
@@ -2634,7 +2653,7 @@ private List<ProjectItemElement> GetEvaluatedItemElements(EvaluationContext eval
             {
                 if (!_loadSettings.HasFlag(ProjectLoadSettings.RecordEvaluatedItemElements))
                 {
-                    _loadSettings = _loadSettings | ProjectLoadSettings.RecordEvaluatedItemElements;
+                    _loadSettings |= ProjectLoadSettings.RecordEvaluatedItemElements;
                     Reevaluate(LoggingService, _loadSettings, evaluationContext);
                 }
 
@@ -2728,7 +2747,7 @@ ProvenanceResult SingleItemSpecProvenance(string itemSpec, IElementLocation elem
             /// Since:
             ///     - we have no proper AST and interpreter for itemspecs that we can do analysis on
             ///     - GetItemProvenance needs to have correct counts for exclude strings (as correct as it can get while doing it after evaluation)
-            /// 
+            ///
             /// The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive
             /// </summary>
             private static int ItemMatchesInItemSpecString(string itemToMatch, string itemSpec, IElementLocation elementLocation, string projectDirectory, Expander<ProjectProperty, ProjectItem> expander, out Provenance provenance)
@@ -2782,7 +2801,7 @@ private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec
 
             /// <summary>
             /// Returns an iterator over the "logical project". The logical project is defined as
-            /// the unevaluated project obtained from the single MSBuild file that is the result 
+            /// the unevaluated project obtained from the single MSBuild file that is the result
             /// of inlining the text of all imports of the original MSBuild project manifest file.
             /// </summary>
             public override IEnumerable<ProjectElement> GetLogicalProject()
@@ -2824,7 +2843,7 @@ public override ProjectProperty GetProperty(string name)
             }
 
             /// <summary>
-            /// Get the unescaped value of a property in this project, or 
+            /// Get the unescaped value of a property in this project, or
             /// an empty string if it does not exist.
             /// </summary>
             /// <remarks>
@@ -2859,12 +2878,11 @@ public override ProjectProperty SetProperty(string name, string unevaluatedValue
 
                 ProjectProperty property = _data.Properties[name];
 
-                ErrorUtilities.VerifyThrowInvalidOperation(property == null || !property.IsReservedProperty, "OM_ReservedName", name);
-                ErrorUtilities.VerifyThrowInvalidOperation(property == null || !property.IsGlobalProperty, "OM_GlobalProperty", name);
+                ErrorUtilities.VerifyThrowInvalidOperation(property?.IsReservedProperty != true, "OM_ReservedName", name);
+                ErrorUtilities.VerifyThrowInvalidOperation(property?.IsGlobalProperty != true, "OM_GlobalProperty", name);
 
                 // If there's an existing regular property, we can reuse it, unless it's not attached to its XML any more
-                if (property != null &&
-                    !property.IsEnvironmentProperty &&
+                if (property?.IsEnvironmentProperty == false &&
                     property.Xml.Parent?.Parent != null &&
                     ReferenceEquals(property.Xml.ContainingProject, Xml))
                 {
@@ -3032,7 +3050,7 @@ public override IList<ProjectItem> AddItemFast(string itemType, string unevaluat
             /// Use AddItem or RemoveItem to modify items in this project.
             /// </summary>
             /// <comments>
-            /// data.GetItems returns a read-only collection, so no need to re-wrap it here. 
+            /// data.GetItems returns a read-only collection, so no need to re-wrap it here.
             /// </comments>
             public override ICollection<ProjectItem> GetItems(string itemType)
             {
@@ -3046,7 +3064,7 @@ public override ICollection<ProjectItem> GetItems(string itemType)
             /// This is a read-only list: use AddItem or RemoveItem to modify items in this project.
             /// </summary>
             /// <comments>
-            /// ItemDictionary[] returns a read only collection, so no need to wrap it. 
+            /// ItemDictionary[] returns a read only collection, so no need to wrap it.
             /// </comments>
             public override ICollection<ProjectItem> GetItemsIgnoringCondition(string itemType)
             {
@@ -3195,10 +3213,10 @@ public override string ExpandString(string unexpandedValue)
                 return result;
             }
 
-
             /// <summary>
             /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>
             /// </summary>
+            /// <param name="settings">Project instance creation settings</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             /// <returns></returns>
             public override ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
@@ -3236,7 +3254,7 @@ public override void ReevaluateIfNecessary(EvaluationContext evaluationContext)
             }
 
             /// <summary>
-            /// Saves a "logical" or "preprocessed" project file, that includes all the imported 
+            /// Saves a "logical" or "preprocessed" project file, that includes all the imported
             /// files as if they formed a single file.
             /// </summary>
             public override void SaveLogicalProject(TextWriter writer)
@@ -3253,6 +3271,9 @@ public override void SaveLogicalProject(TextWriter writer)
             /// <summary>
             /// See <see cref="ProjectLink.Build"/>
             /// </summary>
+            /// <param name="targets">targets to build</param>
+            /// <param name="loggers">List of loggers</param>
+            /// <param name="remoteLoggers">remote loggers for multi proc logging</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
             {
@@ -3303,10 +3324,10 @@ public bool UsesProjectRootElement(ProjectRootElement xmlRootElement)
             /// A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
             /// Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
             /// sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
-            /// 
+            ///
             /// For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
             /// item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
-            /// 
+            ///
             /// This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
             /// For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
             /// Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
@@ -3349,7 +3370,7 @@ internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement)
             }
 
             /// <summary>
-            /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
+            /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the
             /// item we wish to add, and does not have a condition or an exclude.
             /// Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
             /// Returns true if it is suitable, otherwise false.
@@ -3364,7 +3385,7 @@ public bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXm
                     return false;
                 }
 
-                if ((metadata != null && metadata.Any()) || candidateExistingItemXml.Count > 0)
+                if ((metadata?.Any() == true) || candidateExistingItemXml.Count > 0)
                 {
                     // Don't try to make sure the metadata are the same.
                     return false;
@@ -3396,7 +3417,7 @@ public bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXm
 
             /// <summary>
             /// Before an item changes its item type, it must be removed from
-            /// our datastructures, which key off item type. 
+            /// our datastructures, which key off item type.
             /// This should be called ONLY by ProjectItems, in this situation.
             /// </summary>
             public void RemoveItemBeforeItemTypeChange(ProjectItem item)
@@ -3493,7 +3514,7 @@ public override void Unload()
             /// <summary>
             /// Verify that the provided object location is in the same file as the project.
             /// If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
-            /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
+            /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the
             /// main project, but for some reason was actually read in from an imported targets file.
             /// </summary>
             internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml)
@@ -3605,7 +3626,7 @@ private void ReevaluateIfNecessary(
 
             /// <summary>
             /// Creates a project instance based on this project using the specified logging service.
-            /// </summary>  
+            /// </summary>
             private ProjectInstance CreateProjectInstance(
                 ILoggingService loggingServiceForEvaluation,
                 ProjectInstanceSettings settings,
@@ -3732,12 +3753,12 @@ private void ProjectRootElement_ProjectXmlChangedHandler(object sender, ProjectX
             /// <summary>
             /// Tries to find a ProjectItemElement already in the project file XML that has a wildcard that would match the
             /// item we wish to add, does not have a condition or an exclude, and is within an itemgroup without a condition.
-            /// 
+            ///
             /// For perf reasons, this method does several jobs in one.
             /// If it finds a suitable existing item element, it returns that as the out parameter, otherwise the out parameter returns null.
             /// Otherwise, if it finds an item element suitable to be just below our new element, it returns that.
             /// Otherwise, if it finds an item group at least that's suitable to put our element in somewhere, it returns that.
-            /// 
+            ///
             /// Returns null if the include of the item being added itself has wildcards, or semicolons, as the case is too difficult.
             /// </summary>
             private ProjectElement GetAnySuitableExistingItemXml(string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata, out ProjectItemElement suitableExistingItemXml)
@@ -3749,7 +3770,7 @@ private ProjectElement GetAnySuitableExistingItemXml(string itemType, string une
                     return null;
                 }
 
-                if (metadata != null && metadata.Any())
+                if (metadata?.Any() == true)
                 {
                     // Don't bother trying to match up metadata
                     return null;
@@ -3920,7 +3941,7 @@ internal class Data : IItemProvider<ProjectItem>, IPropertyProvider<ProjectPrope
             private static WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -3971,7 +3992,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _globalPropertiesToTreatAsLocal ?? (_globalPropertiesToTreatAsLocal =
                                                                       new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default));
@@ -4008,13 +4029,13 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
 
             /// <summary>
             /// The externally specified sub-toolset version that, combined with the ToolsVersion, is used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public string ExplicitSubToolsetVersion { get; }
 
             /// <summary>
             /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public string SubToolsetVersion { get; private set; }
 
@@ -4044,17 +4065,17 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Collection of possible values implied for properties contained in the conditions found on properties,
             /// property groups, imports, and whens.
-            /// 
+            ///
             /// For example, if the following conditions existed on properties in a project:
-            /// 
+            ///
             /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
             /// Condition="'$(Configuration)' == 'Release'"
-            /// 
+            ///
             /// the table would be populated with
-            /// 
+            ///
             /// { "Configuration", { "Debug", "Release" }}
             /// { "Platform", { "x86" }}
-            /// 
+            ///
             /// This is used by Visual Studio to determine the configurations defined in the project.
             /// </summary>
             public Dictionary<string, List<string>> ConditionedProperties { get; private set; }
@@ -4077,7 +4098,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// Read only collection.
             /// </summary>
             /// <comments>
-            /// item.ItemTypes is a KeyCollection, so it doesn't need any 
+            /// item.ItemTypes is a KeyCollection, so it doesn't need any
             /// additional read-only protection
             /// </comments>
             public ICollection<string> ItemTypes => Items.ItemTypes;
@@ -4085,7 +4106,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// It does not include any properties added since the last evaluation.
             /// </summary>
@@ -4094,7 +4115,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// It does not include any item definition metadata added since the last evaluation.
             /// </summary>
@@ -4287,7 +4308,7 @@ public void AddItemIgnoringCondition(ProjectItem item)
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// </summary>
             public void AddToAllEvaluatedPropertiesList(ProjectProperty property)
@@ -4299,7 +4320,7 @@ public void AddToAllEvaluatedPropertiesList(ProjectProperty property)
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// </summary>
             public void AddToAllEvaluatedItemDefinitionMetadataList(ProjectMetadata itemDefinitionMetadatum)
@@ -4392,7 +4413,7 @@ public void AddTarget(ProjectTargetInstance target)
             /// <remarks>
             /// This may include imported files that ended up contributing nothing to the evaluated project.
             /// These might otherwise have no strong references to them at all.
-            /// If they are dirtied, though, they might affect the evaluated project; and that's why we record them. 
+            /// If they are dirtied, though, they might affect the evaluated project; and that's why we record them.
             /// Mostly these will be common imports, so they'll be shared anyway.
             /// </remarks>
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
@@ -4518,7 +4539,7 @@ internal ICollection<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInc
             }
 
             /// <summary>
-            /// Get the value of a property in this project, or 
+            /// Get the value of a property in this project, or
             /// an empty string if it does not exist.
             /// Returns the unescaped value.
             /// </summary>
@@ -4593,7 +4614,7 @@ public GlobResult(ProjectItemElement itemElement, IEnumerable<string> includeGlo
     public enum Provenance
     {
         /// <summary>
-        /// Undefined is the bottom element and should not appear in actual results 
+        /// Undefined is the bottom element and should not appear in actual results
         /// </summary>
         Undefined = 0,
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 06be3f47ec0..4b9c602b48b 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -208,7 +208,7 @@ public void Dispose()
 
         /// <summary>
         /// Whether reevaluation is temporarily disabled on projects in this collection.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to projects, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         private bool _skipEvaluation;
@@ -227,7 +227,7 @@ public void Dispose()
         private int _maxNodeCount;
 
         /// <summary>
-        /// Instantiates a project collection with no global properties or loggers that reads toolset 
+        /// Instantiates a project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
         /// </summary>
         public ProjectCollection()
@@ -406,7 +406,7 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
 
         /// <summary>
         /// Retrieves the global project collection object.
-        /// This is a singleton project collection with no global properties or loggers that reads toolset 
+        /// This is a singleton project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
         /// May throw InvalidToolsetDefinitionException.
         /// Thread safe.
@@ -473,7 +473,6 @@ public static string DisplayVersion
                     s_assemblyDisplayVersion = plusIndex < 0
                                                     ? fullInformationalVersion
                                                     : fullInformationalVersion.Substring(startIndex: 0, length: plusIndex + 10);
-
                 }
 
                 return s_assemblyDisplayVersion;
@@ -483,7 +482,7 @@ public static string DisplayVersion
         /// <summary>
         /// The default tools version of this project collection. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
-        /// This value is gotten from the .exe.config file, or else in the registry, 
+        /// This value is gotten from the .exe.config file, or else in the registry,
         /// or if neither specify a default tools version then it is hard-coded to the tools version "2.0".
         /// Setter throws InvalidOperationException if a toolset with the provided tools version has not been defined.
         /// Always defined.
@@ -532,8 +531,8 @@ public string DefaultToolsVersion
         /// </summary>
         /// <remarks>
         /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-        /// 
-        /// To be consistent with Project, setting and removing global properties is done with 
+        ///
+        /// To be consistent with Project, setting and removing global properties is done with
         /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
         /// </remarks>
         public IDictionary<string, string> GlobalProperties
@@ -740,7 +739,7 @@ public HostServices HostServices
 
         /// <summary>
         /// Whether reevaluation is temporarily disabled on projects in this collection.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to projects, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         public bool SkipEvaluation
@@ -809,7 +808,6 @@ public bool DisableMarkDirty
             }
         }
 
-
         /// <summary>
         /// Global collection id.
         /// Can be used for external providers to optimize the cross-site link exchange
@@ -820,7 +818,6 @@ public bool DisableMarkDirty
         /// External project support.
         /// Establish a remote project link for this collection.
         /// </summary>
-
         internal ExternalProjectsProvider Link
         {
             get => _link;
@@ -852,7 +849,7 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
             get
             {
                 var clone = new PropertyDictionary<ProjectPropertyInstance>();
-                
+
                 using (_locker.EnterUpgradeableReadLock())
                 {
                     foreach (ProjectPropertyInstance property in _globalProperties)
@@ -965,7 +962,7 @@ public static string Unescape(string escapedString)
         }
 
         /// <summary>
-        /// Returns true if there is a toolset defined for the specified 
+        /// Returns true if there is a toolset defined for the specified
         /// tools version, otherwise false.
         /// </summary>
         public bool ContainsToolset(string toolsVersion) => GetToolset(toolsVersion) != null;
@@ -1045,7 +1042,7 @@ public Toolset GetToolset(string toolsVersion)
         }
 
         /// <summary>
-        /// Figure out what ToolsVersion to use to actually build the project with. 
+        /// Figure out what ToolsVersion to use to actually build the project with.
         /// </summary>
         /// <param name="explicitToolsVersion">The user-specified ToolsVersion (through e.g. /tv: on the command line). May be null</param>
         /// <param name="toolsVersionFromProject">The ToolsVersion from the project file. May be null</param>
@@ -1090,7 +1087,6 @@ internal ICollection<Project> GetLoadedProjects(bool includeExternal, string ful
             return loaded;
         }
 
-
         /// <summary>
         /// Loads a project with the specified filename, using the collection's global properties and tools version.
         /// If a matching project is already loaded, it will be returned, otherwise a new project will be loaded.
@@ -1756,8 +1752,8 @@ internal void ResetToolsetsForTests(ToolsetRegistryReader registryReaderForTests
 #endif
 
         /// <summary>
-        /// Populate Toolsets with a dictionary of (toolset version, Toolset) 
-        /// using information from the registry and config file, if any.  
+        /// Populate Toolsets with a dictionary of (toolset version, Toolset)
+        /// using information from the registry and config file, if any.
         /// </summary>
         private void InitializeToolsetCollection(
 #if FEATURE_WIN32_REGISTRY
@@ -2364,7 +2360,7 @@ private class LoadedProjectCollection : IEnumerable<Project>
             /// with different global properties and/or tools version.
             /// </summary>
             /// <remarks>
-            /// If hosts tend to load lots of projects with the same path, the value will have to be 
+            /// If hosts tend to load lots of projects with the same path, the value will have to be
             /// changed to a more efficient type of collection.
             ///
             /// Lock on this object. Concurrent load must be thread safe.
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 4fd40b3fe7f..048d9dbddde 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -127,12 +127,12 @@ internal ProjectItem(
                              List<ProjectItemDefinition> inheritedItemDefinitionsCloned
                             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
 
             // Orcas accidentally allowed empty includes if they resulted from expansion: we preserve that bug
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeEscaped, "evaluatedIncludeEscaped");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeBeforeWildcardExpansionEscaped, "evaluatedIncludeBeforeWildcardExpansionEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeEscaped, nameof(evaluatedIncludeEscaped));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedIncludeBeforeWildcardExpansionEscaped, nameof(evaluatedIncludeBeforeWildcardExpansionEscaped));
 
             _xml = xml;
             _project = project;
@@ -400,7 +400,7 @@ public ProjectMetadata GetMetadata(string name)
                 return Link.GetMetadata(name);
             }
 
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             ProjectMetadata result = null;
 
@@ -441,7 +441,7 @@ public bool HasMetadata(string name)
                 return Link.HasMetadata(name);
             }
 
-            if (_directMetadata != null && _directMetadata.Contains(name))
+            if (_directMetadata?.Contains(name) == true)
             {
                 return true;
             }
@@ -466,7 +466,7 @@ public bool HasMetadata(string name)
         /// </summary>
         string IItem.GetMetadataValueEscaped(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             string value = null;
 
@@ -521,7 +521,7 @@ ProjectMetadata IItem<ProjectMetadata>.GetMetadata(string name)
         /// </summary>
         ProjectMetadata IItem<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude)
         {
-            _directMetadata = _directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+            _directMetadata ??= new PropertyDictionary<ProjectMetadata>();
 
             ProjectMetadata predecessor = GetMetadata(metadataElement.Name);
 
@@ -573,7 +573,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
             XmlUtilities.VerifyThrowArgumentValidElementName(name);
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             ErrorUtilities.VerifyThrowInvalidOperation(!XMakeElements.ReservedItemNames.Contains(name), "CannotModifyReservedItemMetadata", name);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (!propagateMetadataToSiblingItems)
             {
@@ -582,7 +582,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
             ProjectMetadata metadatum;
 
-            if (_directMetadata != null && _directMetadata.Contains(name))
+            if (_directMetadata?.Contains(name) == true)
             {
                 metadatum = _directMetadata[name];
                 metadatum.UnevaluatedValue = unevaluatedValue;
@@ -598,7 +598,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
             if (!propagateMetadataToSiblingItems)
             {
-                _directMetadata = _directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+                _directMetadata ??= new PropertyDictionary<ProjectMetadata>();
                 _directMetadata.Set(metadatum);
             }
             else
@@ -607,7 +607,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
                 foreach (var siblingItem in siblingItems)
                 {
-                    siblingItem._directMetadata = siblingItem._directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+                    siblingItem._directMetadata ??= new PropertyDictionary<ProjectMetadata>();
                     siblingItem._directMetadata.Set(metadatum.DeepClone());
                 }
             }
@@ -628,10 +628,10 @@ public bool RemoveMetadata(string name)
                 return Link.RemoveMetadata(name);
             }
 
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             ProjectMetadata metadatum = (_directMetadata == null) ? null : _directMetadata[name];
 
@@ -681,7 +681,7 @@ public void Rename(string name)
             }
 
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (String.Equals(UnevaluatedInclude, name, StringComparison.Ordinal))
             {
@@ -777,7 +777,7 @@ internal void ChangeItemType(string newItemType)
         {
             ErrorUtilities.VerifyThrowArgumentLength(newItemType, "ItemType");
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (String.Equals(ItemType, newItemType, StringComparison.Ordinal))
             {
@@ -1060,14 +1060,14 @@ private ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedI
 
                 if (source._inheritedItemDefinitions != null)
                 {
-                    inheritedItemDefinitionsClone = inheritedItemDefinitionsClone ?? new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
+                    inheritedItemDefinitionsClone ??= new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
                     inheritedItemDefinitionsClone.AddRange(source._inheritedItemDefinitions);
                 }
 
                 ProjectItemDefinition sourceItemDefinition;
                 if (_project.ItemDefinitions.TryGetValue(source.ItemType, out sourceItemDefinition))
                 {
-                    inheritedItemDefinitionsClone = inheritedItemDefinitionsClone ?? new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
+                    inheritedItemDefinitionsClone ??= new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
                     inheritedItemDefinitionsClone.Add(sourceItemDefinition);
                 }
 
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 08ca675b7a0..b05aa0bd826 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -54,8 +54,8 @@ public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<Pro
         /// </remarks>
         internal ProjectItemDefinition(Project project, string itemType)
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentLength(itemType, "itemType");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentLength(itemType, nameof(itemType));
 
             _project = project;
             _itemType = itemType;
@@ -173,7 +173,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
 
             ProjectMetadataElement metadatumXml = itemDefinition.AddMetadata(name, unevaluatedValue);
 
-            _metadata = _metadata ?? new PropertyDictionary<ProjectMetadata>();
+            _metadata ??= new PropertyDictionary<ProjectMetadata>();
 
             string evaluatedValueEscaped = _project.ExpandMetadataValueBestEffortLeaveEscaped(this, unevaluatedValue, metadatumXml.Location);
 
@@ -192,7 +192,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
         /// </summary>
         ProjectMetadata IItemDefinition<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, ProjectMetadata predecessor)
         {
-            _metadata = _metadata ?? new PropertyDictionary<ProjectMetadata>();
+            _metadata ??= new PropertyDictionary<ProjectMetadata>();
 
             ProjectMetadata metadatum = new ProjectMetadata(this, metadataElement, evaluatedValue, predecessor);
             _metadata.Set(metadatum);
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 2408a1e6c18..8a43ad70ff4 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -56,8 +56,8 @@ public class ProjectMetadata : IKeyed, IValued, IEquatable<ProjectMetadata>, IMe
         /// </summary>
         internal ProjectMetadata(object parent, ProjectMetadataElement xml)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
 
             _parent = (IProjectMetadataParent)parent;
             _xml = xml;
@@ -69,9 +69,9 @@ internal ProjectMetadata(object parent, ProjectMetadataElement xml)
         /// </summary>
         internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parent, "parent");
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, "evaluatedValueEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, nameof(evaluatedValueEscaped));
 
             _parent = parent;
             _xml = xml;
@@ -132,7 +132,7 @@ public string UnevaluatedValue
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "value");
                 Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-                ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null && _xml.Parent.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+                ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
                 if (String.Equals(_xml.Value, value, StringComparison.Ordinal))
                 {
@@ -143,7 +143,6 @@ public string UnevaluatedValue
 
                 if (_evaluatedValueEscaped != null)
                 {
-
                     // Clear out the current value of this metadata, so the new value can't refer to the old one.
                     // The expansion call below otherwise passes in the parent item's metadata - including this one's
                     // current value.
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 5cb358fae95..bd1d5792852 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// An evaluated design-time property 
+    /// An evaluated design-time property
     /// </summary>
     [DebuggerDisplay("{Name}={EvaluatedValue} [{UnevaluatedValue}]")]
     public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<ProjectProperty>
@@ -33,7 +33,7 @@ public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<P
 
         internal ProjectProperty(Project project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
             _project = project;
         }
 
@@ -42,8 +42,8 @@ internal ProjectProperty(Project project)
         /// </summary>
         internal ProjectProperty(Project project, string evaluatedValueEscaped)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
-            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, "evaluatedValueEscaped");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowArgumentNull(evaluatedValueEscaped, nameof(evaluatedValueEscaped));
 
             _project = project;
             _evaluatedValueEscaped = evaluatedValueEscaped;
@@ -57,7 +57,7 @@ internal ProjectProperty(Project project, string evaluatedValueEscaped)
         /// </summary>
         /// <comment>
         /// If this could be set, it would be necessary to have a callback
-        /// so that the containing collections could be updated, as they use the name as 
+        /// so that the containing collections could be updated, as they use the name as
         /// their key.
         /// </comment>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -232,7 +232,7 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         #endregion
 
         /// <summary>
-        /// Creates a property without backing XML. 
+        /// Creates a property without backing XML.
         /// Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
@@ -278,7 +278,7 @@ internal void UpdateEvaluatedValue(string evaluatedValueEscaped)
         /// <remarks>
         /// The reason we do this and not just look at project.GlobalProperties is
         /// that when the project is being loaded, the GlobalProperties collection is already populated.  When we do our
-        /// evaluation, we may attempt to add some properties, such as environment variables, to the master Properties 
+        /// evaluation, we may attempt to add some properties, such as environment variables, to the master Properties
         /// collection.  As GlobalProperties are supposed to override these and thus be added last, we can't check against
         /// the GlobalProperties collection as they are being added.  The correct behavior is to always check against the
         /// collection which is accumulating properties as we go, which is the Properties collection.  Once the project has
@@ -291,7 +291,7 @@ internal void UpdateEvaluatedValue(string evaluatedValueEscaped)
         private static bool ProjectHasMatchingGlobalProperty(Project project, string propertyName)
         {
             ProjectProperty property = project.GetProperty(propertyName);
-            if (property != null && property.IsGlobalProperty && !project.GlobalPropertiesToTreatAsLocal.Contains(propertyName))
+            if (property?.IsGlobalProperty == true && !project.GlobalPropertiesToTreatAsLocal.Contains(propertyName))
             {
                 return true;
             }
@@ -319,7 +319,7 @@ private class ProjectPropertyXmlBacked : ProjectProperty
             internal ProjectPropertyXmlBacked(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped)
                 : base(project, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+                ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
                 ErrorUtilities.VerifyThrowInvalidOperation(!ProjectHasMatchingGlobalProperty(project, xml.Name), "OM_GlobalProperty", xml.Name);
 
                 _xml = xml;
@@ -331,7 +331,7 @@ internal ProjectPropertyXmlBacked(Project project, ProjectPropertyElement xml, s
             /// </summary>
             /// <comment>
             /// If this could be set, it would be necessary to have a callback
-            /// so that the containing collections could be updated, as they use the name as 
+            /// so that the containing collections could be updated, as they use the name as
             /// their key.
             /// </comment>
             [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -348,7 +348,7 @@ public override string Name
             /// </summary>
             /// <remarks>
             /// The containing project will be dirtied by the XML modification.
-            /// If there is no XML backing, the evaluated value returned is the value of the property that has been 
+            /// If there is no XML backing, the evaluated value returned is the value of the property that has been
             /// escaped as necessary.
             /// </remarks>
             public override string UnevaluatedValue
@@ -362,7 +362,7 @@ public override string UnevaluatedValue
                 set
                 {
                     Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-                    ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+                    ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
                     _xml.Value = value;
 
@@ -464,7 +464,7 @@ private class ProjectPropertyXmlBackedWithPredecessor : ProjectPropertyXmlBacked
             internal ProjectPropertyXmlBackedWithPredecessor(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped, ProjectProperty predecessor)
                 : base(project, xml, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(predecessor, "predecessor");
+                ErrorUtilities.VerifyThrowArgumentNull(predecessor, nameof(predecessor));
 
                 _predecessor = predecessor;
             }
@@ -496,7 +496,7 @@ private class ProjectPropertyNotXmlBacked : ProjectProperty
             private readonly string _name;
 
             /// <summary>
-            /// Creates a property without backing XML. 
+            /// Creates a property without backing XML.
             /// Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
             /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
             /// All other properties originate in XML, and should have a backing XML object.
@@ -504,7 +504,7 @@ private class ProjectPropertyNotXmlBacked : ProjectProperty
             internal ProjectPropertyNotXmlBacked(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
                 : base(project, evaluatedValueEscaped)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+                ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
                 ErrorUtilities.VerifyThrowInvalidOperation(isGlobalProperty || !ProjectHasMatchingGlobalProperty(project, name), "OM_GlobalProperty", name);
                 ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(name), "OM_ReservedName", name);
                 ErrorUtilities.VerifyThrowArgument(mayBeReserved || !ReservedPropertyNames.IsReservedProperty(name), "OM_ReservedName", name);
@@ -518,7 +518,7 @@ internal ProjectPropertyNotXmlBacked(Project project, string name, string evalua
             /// </summary>
             /// <comment>
             /// If this could be set, it would be necessary to have a callback
-            /// so that the containing collections could be updated, as they use the name as 
+            /// so that the containing collections could be updated, as they use the name as
             /// their key.
             /// </comment>
             [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -535,7 +535,7 @@ public override string Name
             /// </summary>
             /// <remarks>
             /// The containing project will be dirtied.
-            /// As there is no XML backing, the evaluated value returned is the value of the property that has been 
+            /// As there is no XML backing, the evaluated value returned is the value of the property that has been
             /// escaped as necessary.
             /// </remarks>
             public override string UnevaluatedValue
@@ -628,10 +628,5 @@ public override bool IsImported
                 get { return false; }
             }
         }
-
-
-        /// <summary>
-        /// External projects support
-        /// </summary>
     }
 }
diff --git a/src/Build/Definition/SubToolset.cs b/src/Build/Definition/SubToolset.cs
index aecc042c249..66578f1baa2 100644
--- a/src/Build/Definition/SubToolset.cs
+++ b/src/Build/Definition/SubToolset.cs
@@ -35,7 +35,7 @@ public class SubToolset : ITranslatable
         /// </summary>
         internal SubToolset(string subToolsetVersion, PropertyDictionary<ProjectPropertyInstance> properties)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, "subToolsetVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, nameof(subToolsetVersion));
 
             _subToolsetVersion = subToolsetVersion;
             _properties = properties;
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 351c8f749bc..411beb3a741 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -43,89 +43,89 @@ public class Toolset : ITranslatable
     {
         /// <summary>
         /// these files list all default tasks and task assemblies that do not need to be explicitly declared by projects
-        /// </summary> 
+        /// </summary>
         private const string DefaultTasksFilePattern = "*.tasks";
 
         /// <summary>
         /// these files list all Override tasks and task assemblies that do not need to be explicitly declared by projects
-        /// </summary> 
+        /// </summary>
         private const string OverrideTasksFilePattern = "*.overridetasks";
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
-        /// Regkey that we check to see whether Dev10 is installed.  This should exist if any SKU of Dev10 is installed, 
-        /// but is not removed even when the last version of Dev10 is uninstalled, due to 10.0\bsln sticking around. 
+        /// Regkey that we check to see whether Dev10 is installed.  This should exist if any SKU of Dev10 is installed,
+        /// but is not removed even when the last version of Dev10 is uninstalled, due to 10.0\bsln sticking around.
         /// </summary>
         private const string Dev10OverallInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Ultimate is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Ultimate is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10UltimateInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vstscore";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Premium is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Premium is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10PremiumInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vstdcore";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Professional is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Professional is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10ProfessionalInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\procore";
 
         /// <summary>
-        /// Regkey that we check to see whether C# Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether C# Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VCSExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vcs\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VB Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VB Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VBExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vb\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VC Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VC Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VCExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vc\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VWD Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VWD Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VWDExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vns\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether LightSwitch 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether LightSwitch 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10LightSwitchInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vslscore";
 
         /// <summary>
-        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
-        /// the current machine, false otherwise. 
+        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on
+        /// the current machine, false otherwise.
         /// </summary>
         private static bool? s_dev10IsInstalled = null;
 #endif // FEATURE_WIN32_REGISTRY
 
         /// <summary>
         /// Name of the tools version
-        /// </summary> 
+        /// </summary>
         private string _toolsVersion;
 
         /// <summary>
         /// The MSBuildBinPath (and ToolsPath) for this tools version
-        /// </summary> 
+        /// </summary>
         private string _toolsPath;
 
         /// <summary>
         /// The properties defined by the toolset.
-        /// </summary> 
+        /// </summary>
         private PropertyDictionary<ProjectPropertyInstance> _properties;
 
         /// <summary>
@@ -150,22 +150,22 @@ public class Toolset : ITranslatable
 
         /// <summary>
         /// indicates if the default tasks file has already been scanned
-        /// </summary> 
+        /// </summary>
         private bool _defaultTasksRegistrationAttempted;
 
         /// <summary>
         /// indicates if the override tasks file has already been scanned
-        /// </summary> 
+        /// </summary>
         private bool _overrideTasksRegistrationAttempted;
 
         /// <summary>
         /// holds all the default tasks we know about and the assemblies they exist in
-        /// </summary> 
+        /// </summary>
         private TaskRegistry _defaultTaskRegistry;
 
         /// <summary>
         /// holds all the override tasks we know about and the assemblies they exist in
-        /// </summary> 
+        /// </summary>
         private TaskRegistry _overrideTaskRegistry;
 
         /// <summary>
@@ -194,13 +194,13 @@ public class Toolset : ITranslatable
         private PropertyDictionary<ProjectPropertyInstance> _propertyBag;
 
         /// <summary>
-        /// SubToolsets that map to this toolset. 
+        /// SubToolsets that map to this toolset.
         /// </summary>
         private Dictionary<string, SubToolset> _subToolsets;
 
         /// <summary>
-        /// If no sub-toolset is specified, this is the default sub-toolset version.  Null == no default 
-        /// sub-toolset, just use the base toolset. 
+        /// If no sub-toolset is specified, this is the default sub-toolset version.  Null == no default
+        /// sub-toolset, just use the base toolset.
         /// </summary>
         private string _defaultSubToolsetVersion;
 
@@ -273,10 +273,10 @@ public Toolset(string toolsVersion, string toolsPath, IDictionary<string, string
         /// <param name="defaultOverrideToolsVersion">ToolsVersion to use as the default ToolsVersion for this version of MSBuild.</param>
         internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, string msbuildOverrideTasksPath, string defaultOverrideToolsVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, "toolsPath");
-            ErrorUtilities.VerifyThrowArgumentNull(environmentProperties, "environmentProperties");
-            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalProperties");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, nameof(toolsPath));
+            ErrorUtilities.VerifyThrowArgumentNull(environmentProperties, nameof(environmentProperties));
+            ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
 
             _toolsVersion = toolsVersion;
             this.ToolsPath = toolsPath;
@@ -284,7 +284,6 @@ internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<Proje
             _environmentProperties = environmentProperties;
             _overrideTasksPath = msbuildOverrideTasksPath;
             _defaultOverrideToolsVersion = defaultOverrideToolsVersion;
-            
         }
 
         /// <summary>
@@ -353,8 +352,8 @@ internal Toolset(
         internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary<ProjectPropertyInstance> buildProperties, ProjectCollection projectCollection, DirectoryGetFiles getFiles, LoadXmlFromPath loadXmlFromPath, string msbuildOverrideTasksPath, DirectoryExists directoryExists)
             : this(toolsVersion, toolsPath, buildProperties, projectCollection.EnvironmentProperties, projectCollection.GlobalPropertiesCollection, null, msbuildOverrideTasksPath, null)
         {
-            ErrorUtilities.VerifyThrowInternalNull(getFiles, "getFiles");
-            ErrorUtilities.VerifyThrowInternalNull(loadXmlFromPath, "loadXmlFromPath");
+            ErrorUtilities.VerifyThrowInternalNull(getFiles, nameof(getFiles));
+            ErrorUtilities.VerifyThrowInternalNull(loadXmlFromPath, nameof(loadXmlFromPath));
 
             _directoryExists = directoryExists;
             _getFiles = getFiles;
@@ -465,16 +464,16 @@ public IDictionary<string, SubToolset> SubToolsets
         }
 
         /// <summary>
-        /// Returns the default sub-toolset version for this sub-toolset.  Heuristic used is: 
-        /// 1) If Visual Studio 2010 is installed and our ToolsVersion is "4.0", use the base toolset, and return 
-        ///    a sub-toolset version of "10.0", to be set as a publicly visible property so that e.g. targets can 
-        ///    consume it.  This is to handle the fact that Visual Studio 2010 did not have any concept of sub-toolsets. 
-        /// 2) Otherwise, use the highest-versioned sub-toolset found.  Sub-toolsets with numbered versions will 
-        ///    be ordered numerically; any additional sub-toolsets will be prepended to the beginning of the list in 
-        ///    the order found. We use the highest-versioned sub-toolset because, in the absence of any other information, 
-        ///    we assume that higher-versioned tools will be more likely to be able to generate something more correct.  
-        /// 
-        /// Will return null if there is no sub-toolset available (and Dev10 is not installed). 
+        /// Returns the default sub-toolset version for this sub-toolset.  Heuristic used is:
+        /// 1) If Visual Studio 2010 is installed and our ToolsVersion is "4.0", use the base toolset, and return
+        ///    a sub-toolset version of "10.0", to be set as a publicly visible property so that e.g. targets can
+        ///    consume it.  This is to handle the fact that Visual Studio 2010 did not have any concept of sub-toolsets.
+        /// 2) Otherwise, use the highest-versioned sub-toolset found.  Sub-toolsets with numbered versions will
+        ///    be ordered numerically; any additional sub-toolsets will be prepended to the beginning of the list in
+        ///    the order found. We use the highest-versioned sub-toolset because, in the absence of any other information,
+        ///    we assume that higher-versioned tools will be more likely to be able to generate something more correct.
+        ///
+        /// Will return null if there is no sub-toolset available (and Dev10 is not installed).
         /// </summary>
         public string DefaultSubToolsetVersion
         {
@@ -521,11 +520,11 @@ public string DefaultSubToolsetVersion
         }
 
         /// <summary>
-        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
-        /// the current machine, false otherwise. 
+        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on
+        /// the current machine, false otherwise.
         /// </summary>
         /// <comments>
-        /// Internal so that unit tests can use it too. 
+        /// Internal so that unit tests can use it too.
         /// </comments>
         internal static bool Dev10IsInstalled
         {
@@ -632,13 +631,13 @@ void ITranslatable.Translate(ITranslator translator)
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 2. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
+        /// 1. If "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 2. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
         /// </summary>
         public string GenerateSubToolsetVersion()
         {
@@ -648,17 +647,17 @@ public string GenerateSubToolsetVersion()
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow", MessageId = "solutionVersion-1", Justification = "Method called in restricted places. Checks done by the callee and inside the method.")]
         public string GenerateSubToolsetVersion(IDictionary<string, string> overrideGlobalProperties, int solutionVersion)
@@ -667,9 +666,9 @@ public string GenerateSubToolsetVersion(IDictionary<string, string> overrideGlob
         }
 
         /// <summary>
-        /// Given a property name and a sub-toolset version, searches for that property first in the 
-        /// sub-toolset, then falls back to the base toolset if necessary, and returns the property 
-        /// if it was found. 
+        /// Given a property name and a sub-toolset version, searches for that property first in the
+        /// sub-toolset, then falls back to the base toolset if necessary, and returns the property
+        /// if it was found.
         /// </summary>
         public ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion)
         {
@@ -751,17 +750,17 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         internal string GenerateSubToolsetVersion(PropertyDictionary<ProjectPropertyInstance> overrideGlobalProperties)
         {
@@ -784,17 +783,17 @@ internal string GenerateSubToolsetVersion(PropertyDictionary<ProjectPropertyInst
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         {
@@ -835,7 +834,7 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         }
 
         /// <summary>
-        /// Return a task registry stub for the tasks in the *.tasks file for this toolset         
+        /// Return a task registry stub for the tasks in the *.tasks file for this toolset
         /// </summary>
         /// <param name="loggingServices">The logging services used to log during task registration.</param>
         /// <param name="buildEventContext">The build event context used to log during task registration.</param>
@@ -863,7 +862,7 @@ internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<st
         }
 
         /// <summary>
-        /// Return a task registry for the override tasks in the *.overridetasks file for this toolset         
+        /// Return a task registry for the override tasks in the *.overridetasks file for this toolset
         /// </summary>
         /// <param name="loggingServices">The logging services used to log during task registration.</param>
         /// <param name="buildEventContext">The build event context used to log during task registration.</param>
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 6f98ee8108f..1977f876ec0 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -61,7 +61,7 @@ internal ToolsetConfigurationReader(PropertyDictionary<ProjectPropertyInstance>
         internal ToolsetConfigurationReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, Func<Configuration> readApplicationConfiguration)
             : base(environmentProperties, globalProperties)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(readApplicationConfiguration, "readApplicationConfiguration");
+            ErrorUtilities.VerifyThrowArgumentNull(readApplicationConfiguration, nameof(readApplicationConfiguration));
             _readApplicationConfiguration = readApplicationConfiguration;
             _projectImportSearchPathsCache = new Dictionary<string, Dictionary<string, ProjectImportPathMatch>>(StringComparer.OrdinalIgnoreCase);
         }
@@ -82,7 +82,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
                             toolset.ElementInformation.LineNumber,
                             0);
 
-                        if (toolset.toolsVersion != null && toolset.toolsVersion.Length == 0)
+                        if (toolset.toolsVersion?.Length == 0)
                         {
                             InvalidToolsetDefinitionException.Throw(
                                 "InvalidToolsetValueInConfigFileValue",
@@ -106,7 +106,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
         protected override string MSBuildOverrideTasksPath => ConfigurationSection?.MSBuildOverrideTasksPath;
 
         /// <summary>
-        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the tools version that should be used by 
+        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the tools version that should be used by
         /// default to build projects with this version of MSBuild.
         /// </summary>
         protected override string DefaultOverrideToolsVersion => ConfigurationSection?.DefaultOverrideToolsVersion;
@@ -159,7 +159,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
             {
                 ElementLocation location = ElementLocation.Create(propertyElement.ElementInformation.Source, propertyElement.ElementInformation.LineNumber, 0);
 
-                if (propertyElement.Name != null && propertyElement.Name.Length == 0)
+                if (propertyElement.Name?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location.LocationString);
                 }
@@ -171,7 +171,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
         /// <summary>
         /// Provides an enumerator over the set of sub-toolset names available to a particular
         /// tools version.  MSBuild config files do not currently support sub-toolsets, so
-        /// we return nothing. 
+        /// we return nothing.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <returns>An enumeration of the sub-toolsets that belong to that tools version.</returns>
@@ -181,9 +181,9 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
         }
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. In the ToolsetConfigurationReader case, breaks 
-        /// immediately because we do not currently support sub-toolsets in the configuration file. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version. In the ToolsetConfigurationReader case, breaks
+        /// immediately because we do not currently support sub-toolsets in the configuration file.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
diff --git a/src/Build/Definition/ToolsetPropertyDefinition.cs b/src/Build/Definition/ToolsetPropertyDefinition.cs
index 5116370d075..356e311b827 100644
--- a/src/Build/Definition/ToolsetPropertyDefinition.cs
+++ b/src/Build/Definition/ToolsetPropertyDefinition.cs
@@ -40,11 +40,11 @@ internal class ToolsetPropertyDefinition
         /// <param name="source">The property source</param>
         public ToolsetPropertyDefinition(string name, string value, IElementLocation source)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(source, "source");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(source, nameof(source));
 
             // value can be the empty string but not null
-            ErrorUtilities.VerifyThrowArgumentNull(value, "value");
+            ErrorUtilities.VerifyThrowArgumentNull(value, nameof(value));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 1bd0cee26d6..3c140fc14b9 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -150,7 +150,7 @@ ToolsetDefinitionLocations locations
                 if (NativeMethodsShared.IsWindows || registryReader != null)
                 {
                     // If we haven't been provided a registry reader (i.e. unit tests), create one
-                    registryReader = registryReader ?? new ToolsetRegistryReader(environmentProperties, globalProperties);
+                    registryReader ??= new ToolsetRegistryReader(environmentProperties, globalProperties);
 
                     // We do not accumulate properties when reading them from the registry, because the order
                     // in which values are returned to us is essentially random: so we disallow one property
@@ -626,7 +626,7 @@ private static void AppendStandardProperties(
         /// <param name="expander">The expander used to expand the value of the properties.  Ref because if we are accumulating the properties, we need to re-create the expander to account for the new property value.</param>
         private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, PropertyDictionary<ProjectPropertyInstance> properties, PropertyDictionary<ProjectPropertyInstance> globalProperties, PropertyDictionary<ProjectPropertyInstance> initialProperties, bool accumulateProperties, ref string toolsPath, ref string binPath, ref Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
-            if (0 == String.Compare(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
             {
                 toolsPath = ExpandPropertyUnescaped(property, expander);
                 toolsPath = ExpandRelativePathsRelativeToExeLocation(toolsPath);
@@ -641,7 +641,7 @@ private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, Property
                     );
                 }
             }
-            else if (0 == String.Compare(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
             {
                 binPath = ExpandPropertyUnescaped(property, expander);
                 binPath = ExpandRelativePathsRelativeToExeLocation(binPath);
@@ -756,7 +756,6 @@ private string ExpandRelativePathsRelativeToExeLocation(string path)
     /// </summary>
     internal struct MSBuildExtensionsPathReferenceKind
     {
-
         /// <summary>
         /// MSBuildExtensionsPathReferenceKind instance for property named "MSBuildExtensionsPath"
         /// </summary>
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index d1437e00e62..7a083fbebbd 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -43,12 +43,12 @@ internal class ToolsetRegistryReader : ToolsetReader
     {
         /// <summary>
         /// Registry location for storing tools version dependent data for msbuild
-        /// </summary> 
+        /// </summary>
         private const string MSBuildRegistryPath = @"SOFTWARE\Microsoft\MSBuild";
 
         /// <summary>
         /// Cached registry wrapper at root of the msbuild entries
-        /// </summary> 
+        /// </summary>
         private RegistryKeyWrapper _msbuildRegistryWrapper;
 
         /// <summary>
@@ -65,7 +65,7 @@ internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> envir
         internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, RegistryKeyWrapper msbuildRegistryWrapper)
             : base(environmentProperties, globalProperties)
         {
-            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, "msbuildRegistryWrapper");
+            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
 
             _msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
@@ -196,10 +196,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
             }
         }
 
@@ -227,23 +224,20 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
             }
         }
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
         /// <returns>An enumeration of property definitions.</returns>
         protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, "subToolsetVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(subToolsetVersion, nameof(subToolsetVersion));
 
             RegistryKeyWrapper toolsVersionWrapper = null;
             RegistryKeyWrapper subToolsetWrapper = null;
@@ -275,15 +269,9 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyD
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
 
-                if (subToolsetWrapper != null)
-                {
-                    subToolsetWrapper.Dispose();
-                }
+                subToolsetWrapper?.Dispose();
             }
         }
 
@@ -305,7 +293,7 @@ private static ToolsetPropertyDefinition CreatePropertyFromRegistry(RegistryKeyW
         {
             string propertyValue = null;
 
-            if (propertyName != null && propertyName.Length == 0)
+            if (propertyName?.Length == 0)
             {
                 InvalidToolsetDefinitionException.Throw("PropertyNameInRegistryHasZeroLength", toolsetWrapper.Name);
             }
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 39a9163d490..64c0845539c 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -253,7 +253,7 @@ private class RegularElementLocation : ElementLocation
             /// </summary>
             internal RegularElementLocation(string file, int line, int column)
             {
-                ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(file, "file");
+                ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(file, nameof(file));
                 ErrorUtilities.VerifyThrow(line > -1 && column > -1, "Use zero for unknown");
 
                 this.file = file ?? String.Empty;
diff --git a/src/Build/ElementLocation/RegistryLocation.cs b/src/Build/ElementLocation/RegistryLocation.cs
index d8ca9c82d5a..3e37a72f01c 100644
--- a/src/Build/ElementLocation/RegistryLocation.cs
+++ b/src/Build/ElementLocation/RegistryLocation.cs
@@ -29,7 +29,7 @@ internal class RegistryLocation : IElementLocation, ITranslatable
         /// </summary>
         internal RegistryLocation(string registryPath)
         {
-            ErrorUtilities.VerifyThrowInternalLength(registryPath, "registryPath");
+            ErrorUtilities.VerifyThrowInternalLength(registryPath, nameof(registryPath));
 
             this.registryPath = registryPath;
         }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index ca0a8f26a77..d1872605c82 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -91,11 +91,11 @@ bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
-
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(helpKeyword), "Must specify the help keyword for the IDE.");
+            
             this.e = e;
             this.errorCode = errorCode;
             this.helpKeyword = helpKeyword;
@@ -105,7 +105,7 @@ bool initializationException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 2704ce62392..e051cb42772 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -186,8 +186,8 @@ internal InvalidProjectFileException
             Exception innerException
         ) : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLength(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
 
             // Try to helpfully provide a full path if possible, but do so robustly.
             // This exception might be because the path was invalid!
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 9da2579231f..d638be88d6f 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -56,7 +56,7 @@ public InvalidToolsetDefinitionException(string message, Exception innerExceptio
         protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             errorCode = info.GetString("errorCode");
         }
@@ -95,7 +95,7 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             base.GetObjectData(info, context);
 
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 1c7b12afd74..87e5b423c79 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -222,10 +222,10 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             where P : class, IProperty
             where I : class, IItem
         {
-            ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-            ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
-            ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, "evaluationDirectory");
-            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, "buildEventContext");
+            ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
+            ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, nameof(evaluationDirectory));
+            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, nameof(buildEventContext));
 
             // An empty condition is equivalent to a "true" condition.
             if (condition.Length == 0)
@@ -234,7 +234,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             }
 
             // If the condition wasn't empty, there must be a location for it
-            ErrorUtilities.VerifyThrowArgumentNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(elementLocation, nameof(elementLocation));
 
             // Get the expression tree cache for the current parsing options.
             var cachedExpressionTreesForCurrentOptions = s_cachedExpressionTrees.GetOrAdd(
@@ -420,10 +420,10 @@ internal ConditionEvaluationState
                 ProjectRootElementCacheBase projectRootElementCache = null
                 )
             {
-                ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-                ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
-                ErrorUtilities.VerifyThrowArgumentNull(evaluationDirectory, "evaluationDirectory");
-                ErrorUtilities.VerifyThrowArgumentNull(elementLocation, "elementLocation");
+                ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+                ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
+                ErrorUtilities.VerifyThrowArgumentNull(evaluationDirectory, nameof(evaluationDirectory));
+                ErrorUtilities.VerifyThrowArgumentNull(elementLocation, nameof(elementLocation));
 
                 Condition = condition;
                 _expander = expander;
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 8ab1d5a2d65..7331feccb1e 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -29,7 +29,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (String.Compare(_functionName, "exists", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -67,7 +67,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     return false;
                 }
             }
-            else if (String.Compare(_functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(_functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -155,7 +155,6 @@ private List<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode
                 argument = FileUtilities.FixFilePath(argument);
             }
 
-
             IList<TaskItem> expanded = state.ExpandIntoTaskItems(argument);
             var expandedCount = expanded.Count;
 
diff --git a/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs b/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
index 2e58501c88b..0b3ba717d50 100644
--- a/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
@@ -15,6 +15,9 @@ internal sealed class LessThanExpressionNode : NumericComparisonExpressionNode
         /// <summary>
         /// Compare numerically
         /// </summary>
+        /// <param name="left">left input</param>
+        /// <param name="right">right input</param>
+        /// <returns>true if right is higher than left, false otherwise</returns>
         protected override bool Compare(double left, double right)
         {
             return left < right;
@@ -23,7 +26,9 @@ protected override bool Compare(double left, double right)
         /// <summary>
         /// Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
         /// </summary>
-        /// <returns></returns>
+        /// <param name="left">left version</param>
+        /// <param name="right">right version</param>
+        /// <returns>true if right version is higher than left, false otherwise</returns>
         protected override bool Compare(Version left, Version right)
         {
             return left < right;
@@ -32,6 +37,9 @@ protected override bool Compare(Version left, Version right)
         /// <summary>
         /// Compare mixed numbers and Versions
         /// </summary>
+        /// <param name="left">left version</param>
+        /// <param name="right">right number</param>
+        /// <returns>true if right is higher than major version of left, false otherwise</returns>
         protected override bool Compare(Version left, double right)
         {
             if (left.Major != right)
@@ -47,6 +55,9 @@ protected override bool Compare(Version left, double right)
         /// <summary>
         /// Compare mixed numbers and Versions
         /// </summary>
+        /// <param name="left">left number</param>
+        /// <param name="right">right version</param>
+        /// <returns>true if the major version of right is higher than left, false otherwise</returns>
         protected override bool Compare(double left, Version right)
         {
             if (right.Major != left)
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 045fa92f794..918e188ff85 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -80,15 +80,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// </summary>
         internal override void ResetState()
         {
-            if (LeftChild != null)
-            {
-                LeftChild.ResetState();
-            }
+            LeftChild?.ResetState();
 
-            if (RightChild != null)
-            {
-                RightChild.ResetState();
-            }
+            RightChild?.ResetState();
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 6e53b876075..3255b2b6d8a 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -131,7 +131,6 @@ private GenericExpressionNode Expr(string expression)
                 node = ExprPrime(expression, node);
             }
 
-
             #region REMOVE_COMPAT_WARNING
             // Check for potential change in behavior
             if (LoggingServices != null && !_warnedForExpression &&
@@ -237,7 +236,6 @@ private GenericExpressionNode RelationalExpr(string expression)
             }
         }
 
-
         private OperatorExpressionNode RelationalOperation(string expression)
         {
             OperatorExpressionNode node = null;
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 442822690b5..a0fabb89403 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -134,7 +134,7 @@ internal bool Advance()
             if (_errorState)
                 return false;
 
-            if (_lookahead != null && _lookahead.IsToken(Token.TokenType.EndOfInput))
+            if (_lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
                 return true;
 
             SkipWhiteSpace();
@@ -627,11 +627,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction(int start)
         {
             SkipSimpleStringChars();
-            if (0 == string.Compare(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.And;
             }
-            else if (0 == string.Compare(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.Or;
             }
diff --git a/src/Build/Evaluation/Conditionals/Token.cs b/src/Build/Evaluation/Conditionals/Token.cs
index 5887eb2085e..4ff4196dc1c 100644
--- a/src/Build/Evaluation/Conditionals/Token.cs
+++ b/src/Build/Evaluation/Conditionals/Token.cs
@@ -81,7 +81,7 @@ internal Token(TokenType type, string tokenString, bool expandable)
                 "Unexpected token type"
                 );
 
-            ErrorUtilities.VerifyThrowInternalNull(tokenString, "tokenString");
+            ErrorUtilities.VerifyThrowInternalNull(tokenString, nameof(tokenString));
 
             _tokenType = type;
             _tokenString = tokenString;
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b38d2ee912d..f003734dab7 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -29,12 +29,13 @@
 using Constants = Microsoft.Build.Internal.Constants;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using SdkReferencePropertyExpansionMode = Microsoft.Build.Utilities.EscapeHatches.SdkReferencePropertyExpansionMode;
 
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
     /// Evaluates a ProjectRootElement, updating the fresh Project.Data passed in.
-    /// Handles evaluating conditions, expanding expressions, and building up the 
+    /// Handles evaluating conditions, expanding expressions, and building up the
     /// lists of applicable properties, items, and itemdefinitions, as well as gathering targets and tasks
     /// and creating a TaskRegistry from the using tasks.
     /// </summary>
@@ -88,7 +89,7 @@ internal class Evaluator<P, I, M, D>
         private readonly List<Pair<string, ProjectUsingTaskElement>> _usingTaskElements;
 
         /// <summary>
-        /// List of ProjectTargetElement's traversing into imports. 
+        /// List of ProjectTargetElement's traversing into imports.
         /// Gathered during the first pass to avoid traversing again.
         /// </summary>
         private readonly List<ProjectTargetElement> _targetElements;
@@ -99,14 +100,14 @@ internal class Evaluator<P, I, M, D>
         private readonly Dictionary<string, ProjectImportElement> _importsSeen;
 
         /// <summary>
-        /// Depth first collection of InitialTargets strings declared in the main 
+        /// Depth first collection of InitialTargets strings declared in the main
         /// Project and all its imported files, split on semicolons.
         /// </summary>
         private readonly List<string> _initialTargetsList;
 
         /// <summary>
-        /// Dictionary of project full paths and a boolean that indicates whether at least one 
-        /// of their targets has the "Returns" attribute set.  
+        /// Dictionary of project full paths and a boolean that indicates whether at least one
+        /// of their targets has the "Returns" attribute set.
         /// </summary>
         private readonly Dictionary<ProjectRootElement, NGen<bool>> _projectSupportsReturnsAttribute;
 
@@ -139,7 +140,7 @@ internal class Evaluator<P, I, M, D>
         /// The current build submission ID.
         /// </summary>
         private readonly int _submissionId;
-        
+
         private readonly EvaluationContext _evaluationContext;
 
         /// <summary>
@@ -323,7 +324,7 @@ internal static void Evaluate(
         /// </summary>
         internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, "unevaluatedIncludeEscaped");
+            ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, nameof(unevaluatedIncludeEscaped));
 
             List<I> items = new List<I>();
             itemFactory.ItemElement = itemElement;
@@ -647,7 +648,7 @@ private void Evaluate()
                 }
 
                 SetAllProjectsProperty();
-                
+
                 List<string> initialTargets = new List<string>(_initialTargetsList.Count);
                 foreach (var initialTarget in _initialTargetsList)
                 {
@@ -966,7 +967,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
                         string target = EscapingUtilities.UnescapeAll(temp[i].Trim());
                         if (target.Length > 0)
                         {
-                            _data.DefaultTargets = _data.DefaultTargets ?? new List<string>(temp.Count);
+                            _data.DefaultTargets ??= new List<string>(temp.Count);
                             _data.DefaultTargets.Add(target);
                         }
                     }
@@ -980,7 +981,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
         private void EvaluatePropertyGroupElement(ProjectPropertyGroupElement propertyGroupElement)
         {
             using (_evaluationProfiler.TrackElement(propertyGroupElement))
-            { 
+            {
                 if (EvaluateConditionCollectingConditionedProperties(propertyGroupElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                 {
                     foreach (ProjectPropertyElement propertyElement in propertyGroupElement.Properties)
@@ -1135,7 +1136,7 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
         }
 
         /// <summary>
-        /// Set the built-in properties, most of which are read-only 
+        /// Set the built-in properties, most of which are read-only
         /// </summary>
         private ICollection<P> AddBuiltInProperties()
         {
@@ -1474,7 +1475,7 @@ private void EvaluateImportElement(string directoryOfImportingFile, ProjectImpor
                 foreach (ProjectRootElement importedProjectRootElement in importedProjectRootElements)
                 {
                     _data.RecordImport(importElement, importedProjectRootElement, importedProjectRootElement.Version, sdkResult);
-                    
+
                     PerformDepthFirstPass(importedProjectRootElement);
                 }
             }
@@ -1506,7 +1507,7 @@ private void EvaluateImportGroupElement(string directoryOfImportingFile, Project
         /// </summary>
         /// <remarks>
         /// We enter here in both the property and item passes, since Chooses can contain both.
-        /// However, we only evaluate the When conditions on the first pass, so we only pulse 
+        /// However, we only evaluate the When conditions on the first pass, so we only pulse
         /// those states on that pass. On the other pass, it's as if they're not there.
         /// </remarks>
         private void EvaluateChooseElement(ProjectChooseElement chooseElement)
@@ -1575,7 +1576,7 @@ private bool EvaluateWhenOrOtherwiseChildren(IEnumerable<ProjectElement> childre
         /// <summary>
         /// Expands and loads project imports.
         /// <remarks>
-        /// Imports may contain references to "projectImportSearchPaths" defined in the app.config 
+        /// Imports may contain references to "projectImportSearchPaths" defined in the app.config
         /// toolset section. If this is the case, this method will search for the imported project
         /// in those additional paths if the default fails.
         /// </remarks>
@@ -1642,7 +1643,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
             var pathsToSearch = new string[fallbackSearchPathMatch.SearchPaths.Count + 1];
             pathsToSearch[0] = prop?.EvaluatedValue;                       // The actual value of the property, with no fallbacks
             fallbackSearchPathMatch.SearchPaths.CopyTo(pathsToSearch, 1);  // The list of fallbacks, in order
-            
+
             string extensionPropertyRefAsString = fallbackSearchPathMatch.MsBuildPropertyFormat;
 
             _evaluationLoggingContext.LogComment(MessageImportance.Low, "SearchPathsForMSBuildExtensionsPath",
@@ -1779,7 +1780,8 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
 
             string project = importElement.Project;
 
-            if (importElement.SdkReference != null)
+            SdkReference sdkReference = importElement.SdkReference;
+            if (sdkReference != null)
             {
                 // Try to get the path to the solution and project being built. The solution path is not directly known
                 // in MSBuild. It is passed in as a property either by the VS project system or by MSBuild's solution
@@ -1790,8 +1792,58 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                 if (solutionPath == "*Undefined*") solutionPath = null;
                 var projectPath = _data.GetProperty(ReservedPropertyNames.projectFullPath)?.EvaluatedValue;
 
+                CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;
+
+                static bool HasProperty(string value, CompareInfo compareInfo) =>
+                    value != null && compareInfo.IndexOf(value, "$(") != -1;
+
+                if (HasProperty(sdkReference.Name, compareInfo) ||
+                    HasProperty(sdkReference.Version, compareInfo) ||
+                    HasProperty(sdkReference.MinimumVersion, compareInfo))
+                {
+                    SdkReferencePropertyExpansionMode mode =
+                        Traits.Instance.EscapeHatches.SdkReferencePropertyExpansion ??
+                        SdkReferencePropertyExpansionMode.DefaultExpand;
+
+                    if (mode != SdkReferencePropertyExpansionMode.NoExpansion)
+                    {
+                        if (mode == SdkReferencePropertyExpansionMode.DefaultExpand)
+                            mode = SdkReferencePropertyExpansionMode.ExpandUnescape;
+
+                        static string EvaluateProperty(string value, IElementLocation location,
+                            Expander<P, I> expander, SdkReferencePropertyExpansionMode mode)
+                        {
+                            if (value == null)
+                                return null;
+
+                            const ExpanderOptions Options = ExpanderOptions.ExpandProperties;
+
+                            switch (mode)
+                            {
+                                case SdkReferencePropertyExpansionMode.ExpandUnescape:
+                                    return expander.ExpandIntoStringAndUnescape(value, Options, location);
+                                case SdkReferencePropertyExpansionMode.ExpandLeaveEscaped:
+                                    return expander.ExpandIntoStringLeaveEscaped(value, Options, location);
+                                case SdkReferencePropertyExpansionMode.NoExpansion:
+                                case SdkReferencePropertyExpansionMode.DefaultExpand:
+                                default:
+                                    ErrorUtilities.ThrowArgumentOutOfRange(nameof(mode));
+                                    return value;
+                            }
+                        }
+
+                        IElementLocation sdkReferenceOrigin = importElement.SdkLocation;
+
+                        sdkReference = new SdkReference(
+                            EvaluateProperty(sdkReference.Name, sdkReferenceOrigin, _expander, mode),
+                            EvaluateProperty(sdkReference.Version, sdkReferenceOrigin, _expander, mode),
+                            EvaluateProperty(sdkReference.MinimumVersion, sdkReferenceOrigin, _expander, mode)
+                        );
+                    }
+                }
+
                 // Combine SDK path with the "project" relative path
-                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, importElement.SdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio);
+                sdkResult = _sdkResolverService.ResolveSdk(_submissionId, sdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio);
 
                 if (!sdkResult.Success)
                 {
@@ -1801,7 +1853,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                             importElement.Location.Line,
                             importElement.Location.Column,
                             ResourceUtilities.GetResourceString("CouldNotResolveSdk"),
-                            importElement.SdkReference.ToString())
+                            sdkReference.ToString())
                         {
                             BuildEventContext = _evaluationLoggingContext.BuildEventContext,
                             UnexpandedProject = importElement.Project,
@@ -1817,7 +1869,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                         return;
                     }
 
-                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", importElement.SdkReference.ToString());
+                    ProjectErrorUtilities.ThrowInvalidProject(importElement.SdkLocation, "CouldNotResolveSdk", sdkReference.ToString());
                 }
 
                 if (sdkResult.Path == null)
@@ -1841,8 +1893,8 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                     }
                 }
 
-                if ((sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any()) ||
-                    (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any()))
+                if ((sdkResult.PropertiesToAdd?.Any() == true) ||
+                    (sdkResult.ItemsToAdd?.Any() == true))
                 {
                     //  Inserting at the beginning will mean that the properties or items from the SdkResult will be evaluated before
                     //  any projects from paths returned by the SDK Resolver.
@@ -1907,7 +1959,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
                 ProjectRootElement project = ProjectRootElement.Create();
                 project.FullPath = projectPath;
 
-                if (sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any())
+                if (sdkResult.PropertiesToAdd?.Any() == true)
                 {
                     var propertyGroup = project.AddPropertyGroup();
                     foreach (var propertyNameAndValue in sdkResult.PropertiesToAdd)
@@ -1916,7 +1968,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
                     }
                 }
 
-                if (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any())
+                if (sdkResult.ItemsToAdd?.Any() == true)
                 {
                     var itemGroup = project.AddItemGroup();
                     foreach (var item in sdkResult.ItemsToAdd)
@@ -1951,7 +2003,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
         /// <summary>
         /// Load and parse the specified project import, which may have wildcards,
         /// into one or more ProjectRootElements.
-        /// Caches the parsed import into the provided collection, so future 
+        /// Caches the parsed import into the provided collection, so future
         /// requests can be satisfied without re-parsing it.
         /// </summary>
         private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(string directoryOfImportingFile, ProjectImportElement importElement, string unescapedExpression,
@@ -2197,7 +2249,6 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                                     _evaluationLoggingContext.LogBuildEvent(eventArgs);
                                 }
 
-
                                 continue;
                             }
 
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index d06978d9b77..43f3ef3c662 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -267,7 +267,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
                 return String.Empty;
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
             result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
@@ -288,7 +288,7 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
                 return String.Empty;
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string metaExpanded = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
             return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
@@ -336,7 +336,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
                 return Array.Empty<T>();
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             expression = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
             expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
@@ -410,7 +410,7 @@ internal IList<T> ExpandSingleItemVectorExpressionIntoItems<T>(string expression
                 return Array.Empty<T>();
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             return ItemExpander.ExpandSingleItemVectorExpressionIntoItems(this, expression, _items, itemFactory, options, includeNullItems, out isTransformExpression, elementLocation);
         }
@@ -573,14 +573,14 @@ private static void AddArgument(List<string> arguments, ReuseableStringBuilder a
             // If we don't have something that can be treated as an argument
             // then we should treat it as a null so that passing nulls
             // becomes possible through an empty argument between commas.
-            ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, "argumentBuilder");
+            ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
 
             // we reached the end of an argument, add the builder's final result
             // to our arguments. 
             string argValue = OpportunisticIntern.InternableToString(argumentBuilder).Trim();
 
             // We support passing of null through the argument constant value null
-            if (String.Compare("null", argValue, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
             {
                 arguments.Add(null);
             }
@@ -706,6 +706,7 @@ private static class MetadataExpander
             /// <param name="expression">The expression containing item metadata references</param>
             /// <param name="metadata"></param>
             /// <param name="options"></param>
+            /// <param name="elementLocation"></param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
             internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
             {
@@ -746,7 +747,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         // The most common case is where the transform is the whole expression
                         // Also if there were no valid item vector expressions found, then go ahead and do the replacement on
                         // the whole expression (which is what Orcas did).
-                        if (itemVectorExpressions != null && itemVectorExpressions.Count == 1 && itemVectorExpressions[0].Value == expression && itemVectorExpressions[0].Separator == null)
+                        if (itemVectorExpressions?.Count == 1 && itemVectorExpressions[0].Value == expression && itemVectorExpressions[0].Separator == null)
                         {
                             return expression;
                         }
@@ -1844,8 +1845,7 @@ out List<Pair<string, S>> itemsFromCapture
                 if (itemsOfType.Count == 0)
                 {
                     // .. but only if there isn't a function "Count()", since that will want to return something (zero) for an empty list
-                    if (expressionCapture.Captures == null ||
-                        !expressionCapture.Captures.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)))
+                    if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
                         itemsFromCapture = new List<Pair<string, S>>();
                         return false;
@@ -2253,7 +2253,7 @@ internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IEl
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string relativePath = arguments[0];
 
@@ -2421,7 +2421,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
 
@@ -2529,7 +2529,7 @@ internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IE
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     foreach (Pair<string, S> item in itemsOfType)
                     {
@@ -2552,7 +2552,7 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                         // the caller to possibly do correlation.
 
                         // We pass in the existing item so we can copy over its metadata
-                        if (include != null && include.Length > 0)
+                        if (!string.IsNullOrEmpty(include))
                         {
                             yield return new Pair<string, S>(include, item.Value);
                         }
@@ -2628,7 +2628,7 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
 
@@ -2651,7 +2651,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
 
                         // GetMetadataValueEscaped returns empty string for missing metadata,
                         // but IItem specifies it should return null
-                        if (metadataValue != null && metadataValue.Length > 0)
+                        if (!string.IsNullOrEmpty(metadataValue))
                         {
                             // return a result through the enumerator
                             yield return new Pair<string, S>(item.Key, item.Value);
@@ -2665,7 +2665,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
@@ -2701,7 +2701,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 57ac51c9724..a4b4bb26288 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -90,7 +90,7 @@ internal static bool ContainsMetadataExpressionOutsideTransform(string expressio
 
             GetReferencedItemNamesAndMetadata(expression, 0, expression.Length, ref pair, ShredderOptions.MetadataOutsideTransforms);
 
-            bool result = (pair.Metadata != null && pair.Metadata.Count > 0);
+            bool result = (pair.Metadata?.Count > 0);
 
             return result;
         }
@@ -386,7 +386,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
                     // well formed, so make sure the name's in the table
                     if ((whatToShredFor & ShredderOptions.ItemTypes) != 0)
                     {
-                        pair.Items = pair.Items ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                        pair.Items ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                         pair.Items.Add(name);
                     }
 
@@ -455,7 +455,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
 
                     if ((whatToShredFor & ShredderOptions.MetadataOutsideTransforms) != 0)
                     {
-                        pair.Metadata = pair.Metadata ?? new Dictionary<string, MetadataReference>(MSBuildNameIgnoreCaseComparer.Default);
+                        pair.Metadata ??= new Dictionary<string, MetadataReference>(MSBuildNameIgnoreCaseComparer.Default);
                         pair.Metadata[qualifiedMetadataName] = new MetadataReference(itemName, metadataName);
                     }
 
@@ -667,7 +667,7 @@ private static bool Sink(string expression, ref int i, int end, char c1, char c2
         {
             if (i < end - 1 && expression[i] == c1 && expression[i + 1] == c2)
             {
-                i = i + 2;
+                i += 2;
                 return true;
             }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index b91daae440a..e64817750e8 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -27,7 +27,6 @@ internal interface IEvaluatorData<P, I, M, D> : IPropertyProvider<P>, IItemProvi
         where M : class, IMetadatum
         where D : class, IItemDefinition<M>
     {
-
         /// <summary>
         /// The ID of this evaluation
         /// </summary>
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 48965e7852d..d0143d1560d 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -187,7 +187,6 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             return GetRegistryValueFromView(keyName, valueName, defaultValue, new ArraySegment<object>(views));
         }
 
-
         /// <summary>
         /// Get the value of the registry key from one of the RegistryView's specified
         /// </summary>
@@ -224,7 +223,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
 
                         // See if this asks for a specific SDK
                         var m = RegistrySdkRegex.Value.Match(keyName);
-                        
+
                         if (m.Success && m.Groups.Count >= 1 && valueName.Equals("InstallRoot", StringComparison.OrdinalIgnoreCase))
                         {
                             return Path.Combine(NativeMethodsShared.FrameworkBasePath, m.Groups[0].Value) + Path.DirectorySeparatorChar;
@@ -312,6 +311,7 @@ internal static string MakeRelative(string basePath, string path)
         /// </summary>
         /// <param name="startingDirectory">The directory to start the search in.</param>
         /// <param name="fileName">The name of the file to search for.</param>
+        /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns>The full path of the directory containing the file if it is found, otherwise an empty string. </returns>
         internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem)
         {
@@ -323,6 +323,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
         /// </summary>
         /// <param name="file">The name of the file to search for.</param>
         /// <param name="startingDirectory">An optional directory to start the search in.  The default location is the directory
+        /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// of the file containing the property function.</param>
         /// <returns>The full path of the file if it is found, otherwise an empty string.</returns>
         internal static string GetPathOfFileAbove(string file, string startingDirectory, IFileSystem fileSystem)
@@ -569,7 +570,7 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
         {
             if (keyName == null)
             {
-                throw new ArgumentNullException("keyName");
+                throw new ArgumentNullException(nameof(keyName));
             }
 
             string basekeyName;
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 1027af72a64..165407a7f02 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -317,6 +317,7 @@ public bool MatchesItem(I item)
         /// </summary>
         /// <param name="item">The item to attempt to find a match for based on matching metadata</param>
         /// <param name="metadata">Names of metadata to look for matches for</param>
+        /// <param name="options">metadata option matching</param>
         /// <returns></returns>
         public bool MatchesItemOnMetadata(IItem item, IEnumerable<string> metadata, MatchOnMetadataOptions options)
         {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 550b876c290..4c88a6d976f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -311,6 +311,5 @@ public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalPro
             }
         }
     }
-
     
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 89f99c08aee..528b2d85cbd 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -81,8 +81,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     {
                         string value = valueFragment.TextFragment;
 
-                        if (excludeTester == null ||
-                            !excludeTester.Value(EscapingUtilities.UnescapeAll(value)))
+                        if (excludeTester?.Value(EscapingUtilities.UnescapeAll(value)) != true)
                         {
                             var item = _itemFactory.CreateItem(value, value, _itemElement.ContainingProject.FullPath);
                             itemsToAdd.Add(item);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 03d07264cf2..146e15c4df2 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -157,7 +157,7 @@ public string GetEscapedValueIfPresent(string itemType, string name)
 
                 private string RouteCall(string itemType, string name, Func<IMetadataTable, string, string, string> getEscapedValueFunc)
                 {
-                    if (itemType == null || itemType.Equals(_operationItem.Key, StringComparison.OrdinalIgnoreCase))
+                    if (itemType?.Equals(_operationItem.Key, StringComparison.OrdinalIgnoreCase) != false)
                     {
                         return getEscapedValueFunc(_operationItem, itemType, name);
                     }
@@ -298,7 +298,7 @@ protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElem
 
                 bool needToExpandMetadataForEachItem = false;
 
-                if (itemsAndMetadataFound.Metadata != null && itemsAndMetadataFound.Metadata.Values.Count > 0)
+                if (itemsAndMetadataFound.Metadata?.Values.Count > 0)
                 {
                     // If there is bare metadata of any kind, and the Include involved an item list, we should
                     // run items individually, as even non-built-in metadata might differ between items
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index ce9f84cd29d..58b2d1d661f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -304,7 +304,6 @@ public ImmutableList<ItemData>.Builder GetItemData(ImmutableHashSet<string> glob
 
                     return ComputeItems(this, globsToIgnore);
                 }
-
             }
 
             private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyItemList, ImmutableHashSet<string> globsToIgnore)
diff --git a/src/Build/Evaluation/Preprocessor.cs b/src/Build/Evaluation/Preprocessor.cs
index dedb60450d1..794e709cefb 100644
--- a/src/Build/Evaluation/Preprocessor.cs
+++ b/src/Build/Evaluation/Preprocessor.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Creates a view of an evaluated project's XML as if it had all been loaded from 
+    /// Creates a view of an evaluated project's XML as if it had all been loaded from
     /// a single file, instead of being assembled by pulling in imported files as it actually was.
     /// </summary>
     /// <remarks>
@@ -73,7 +73,7 @@ private Preprocessor(Project project)
         }
 
         /// <summary>
-        /// Returns an XmlDocument representing the evaluated project's XML as if it all had 
+        /// Returns an XmlDocument representing the evaluated project's XML as if it all had
         /// been loaded from a single file, instead of being assembled by pulling in imported files.
         /// </summary>
         internal static XmlDocument GetPreprocessedDocument(Project project)
@@ -193,7 +193,7 @@ private void AddImplicitImportNodes(XmlElement documentElement)
                     {
                         documentElement.InsertBefore(xmlElement, documentElement.FirstChild);
                     }
-                    
+
                     lastImplicitImportAdded = xmlElement;
                 }
                 else
diff --git a/src/Build/Evaluation/ProjectChangedEventArgs.cs b/src/Build/Evaluation/ProjectChangedEventArgs.cs
index f70ec35ac11..3504098b754 100644
--- a/src/Build/Evaluation/ProjectChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectChangedEventArgs.cs
@@ -20,7 +20,7 @@ public class ProjectChangedEventArgs : EventArgs
         /// <param name="project">The changed project.</param>
         internal ProjectChangedEventArgs(Project project)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(project, "project");
+            ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
 
             Project = project;
         }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index cbdb79a738e..1b1e64980a5 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -54,7 +54,7 @@ internal class ProjectParser
         private static readonly HashSet<string> ValidAttributesOnTarget = new HashSet<string> { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.name, XMakeAttributes.inputs, XMakeAttributes.outputs, XMakeAttributes.keepDuplicateOutputs, XMakeAttributes.dependsOnTargets, XMakeAttributes.beforeTargets, XMakeAttributes.afterTargets, XMakeAttributes.returns };
 
         /// <summary>
-        /// Valid attributes on on error element
+        /// Valid attributes on error element
         /// </summary>
         private static readonly HashSet<string> ValidAttributesOnOnError = new HashSet<string> { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.executeTargets };
 
@@ -94,8 +94,8 @@ internal class ProjectParser
         /// </summary>
         private ProjectParser(XmlDocumentWithLocation document, ProjectRootElement project)
         {
-            ErrorUtilities.VerifyThrowInternalNull(project, "project");
-            ErrorUtilities.VerifyThrowInternalNull(document, "document");
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+            ErrorUtilities.VerifyThrowInternalNull(document, nameof(document));
 
             _document = document;
             _project = project;
@@ -229,7 +229,6 @@ private ProjectPropertyGroupElement ParseProjectPropertyGroupElement(XmlElementW
             return propertyGroup;
         }
 
-
         /// <summary>
         /// Parse a ProjectItemGroupElement
         /// </summary>
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 1cba0713bb1..b75de665c00 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -131,8 +131,6 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
             LoadProjectsReadOnly = loadProjectsReadOnly;
         }
 
-
-
         /// <summary>
         /// Returns an existing ProjectRootElement for the specified file path, if any.
         /// If none exists, calls the provided delegate to load one, and adds that to the cache.
@@ -268,7 +266,7 @@ internal override void RenameEntry(string oldFullPath, ProjectRootElement projec
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(oldFullPath, "oldFullPath");
+                ErrorUtilities.VerifyThrowArgumentLength(oldFullPath, nameof(oldFullPath));
                 RenameEntryInternal(oldFullPath, projectRootElement);
             }
         }
@@ -396,7 +394,7 @@ internal override void DiscardImplicitReferences()
         /// </remarks>
         internal override void DiscardAnyWeakReference(ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
 
             // A PRE may be unnamed if it was only used in memory.
             if (projectRootElement.FullPath != null)
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index 08a80cf42ea..3413404d5aa 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -128,7 +128,7 @@ public string Get(string key)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(key, "key");
+                ErrorUtilities.VerifyThrowArgumentNull(key, nameof(key));
 
                 if (key.Length == 0)
                 {
@@ -155,7 +155,7 @@ public void Clear(XmlDocument document)
         {
             lock (_locker)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(document, "document");
+                ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
 
                 VerifyState();
 
@@ -215,7 +215,7 @@ private void VerifyState()
         /// </remarks>
         private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
             Clear(projectRootElement.XmlDocument);
         }
 
diff --git a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
index e16bb5fd0fc..529c07069be 100644
--- a/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectXmlChangedEventArgs.cs
@@ -32,7 +32,7 @@ public class ProjectXmlChangedEventArgs : EventArgs
         /// <param name="formattingParameter">The formatting parameter to use with <paramref name="unformattedReason"/>.</param>
         internal ProjectXmlChangedEventArgs(ProjectRootElement projectXml, string unformattedReason, string formattingParameter)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectXml, "projectXml");
+            ErrorUtilities.VerifyThrowArgumentNull(projectXml, nameof(projectXml));
 
             this.ProjectXml = projectXml;
             _unformattedReason = unformattedReason;
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 5d9b15567be..0630cd6407b 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -38,6 +38,7 @@ internal class PropertyTrackingEvaluatorDataWrapper<P, I, M, D> : IEvaluatorData
         /// </summary>
         /// <param name="dataToWrap">The underlying <see cref="IEvaluatorData{P,I,M,D}"/> to wrap for property tracking.</param>
         /// <param name="evaluationLoggingContext">The <see cref="EvaluationLoggingContext"/> used to log relevant events.</param>
+        /// <param name="settingValue">Property tracking setting value</param>
         public PropertyTrackingEvaluatorDataWrapper(IEvaluatorData<P, I, M, D> dataToWrap, EvaluationLoggingContext evaluationLoggingContext, int settingValue)
         {
             ErrorUtilities.VerifyThrowInternalNull(dataToWrap, nameof(dataToWrap));
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index 979f7e5de03..6890d8bd75b 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -113,7 +113,7 @@ internal override void DiscardImplicitReferences()
 
         internal override void DiscardAnyWeakReference(ProjectRootElement projectRootElement)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
 
             // A PRE may be unnamed if it was only used in memory.
             if (projectRootElement.FullPath != null)
diff --git a/src/Build/Evaluation/ToolsetProvider.cs b/src/Build/Evaluation/ToolsetProvider.cs
index af6143d9bff..c45a4d25034 100644
--- a/src/Build/Evaluation/ToolsetProvider.cs
+++ b/src/Build/Evaluation/ToolsetProvider.cs
@@ -64,7 +64,7 @@ private ToolsetProvider(ITranslator translator)
         /// </summary>
         public Toolset GetToolset(string toolsVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
             _toolsets.TryGetValue(toolsVersion, out var toolset);
 
             return toolset;
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 1f07b22d429..b411f73aed9 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -146,7 +146,7 @@ private string NormalizeMatchInput(string stringToMatch)
             // Ensure trailing slash because the fixed directory part has a trailing slash.
             if (stringToMatch == string.Empty)
             {
-                normalizedInput = normalizedInput + Path.DirectorySeparatorChar;
+                normalizedInput += Path.DirectorySeparatorChar;
             }
 
             return normalizedInput;
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 546fcc45a68..92d4aa212c9 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -347,7 +347,6 @@ IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies
                     solutionDependencies[FileUtilities.NormalizePath(projectWithDependencies.AbsolutePath)] = projectWithDependencies.Dependencies.Select(
                         dependencyGuid =>
                         {
-
                             // code snippet cloned from SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration
 
                             if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyGuid, out var dependencyProject))
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index f304a90ad46..a7f9ce4b7ae 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -177,7 +177,6 @@ public ProjectGraph(IEnumerable<string> entryProjectFiles, ProjectCollection pro
         ///     If a null reference is returned from <paramref name="projectInstanceFactory" />, the InnerException contains
         ///     <see cref="InvalidOperationException" />
         /// </exception>
-        /// </exception>
         public ProjectGraph(string entryProjectFile, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory)
             : this(new ProjectGraphEntryPoint(entryProjectFile).AsEnumerable(), projectCollection, projectInstanceFactory)
         {
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index cd9b85686e5..ae88e1064b0 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -423,17 +423,13 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
 
             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)
             {
-                switch (GetProjectType(reference))
+                return (GetProjectType(reference)) switch
                 {
-                    case ProjectType.InnerBuild:
-                        return _allTargets;
-                    case ProjectType.OuterBuild:
-                        return _outerBuildTargets;
-                    case ProjectType.NonMultitargeting:
-                        return _allTargets;
-                    default:
-                        throw new ArgumentOutOfRangeException();
-                }
+                    ProjectType.InnerBuild => _allTargets,
+                    ProjectType.OuterBuild => _outerBuildTargets,
+                    ProjectType.NonMultitargeting => _allTargets,
+                    _ => throw new ArgumentOutOfRangeException(),
+                };
             }
         }
 
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 8c820643d32..93707fb4f57 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -67,9 +67,9 @@ public class HostServices : ITranslatable
         /// </summary>
         public ITaskHost GetHostObject(string projectFile, string targetName, string taskName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
 
             HostObjects hostObjects;
             if (_hostObjectMap == null || !_hostObjectMap.TryGetValue(projectFile, out hostObjects))
@@ -121,16 +121,25 @@ public ITaskHost GetHostObject(string projectFile, string targetName, string tas
         /// </summary>
         public void RegisterHostObject(string projectFile, string targetName, string taskName, ITaskHost hostObject)
         {
+
+/* Unmerged change from project 'Microsoft.Build (netcoreapp2.1)'
+Before:
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
             ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
+After:
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName));
+*/
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
 
             // We can only set the host object to a non-null value if the affinity for the project is not out of proc, or if it is, it is only implicitly
             // out of proc, in which case it will become in-proc after this call completes.  See GetNodeAffinity.
             bool isExplicit;
-            bool hasExplicitOutOfProcAffinity = (GetNodeAffinity(projectFile, out isExplicit) == NodeAffinity.OutOfProc) && (isExplicit == true);
+            bool hasExplicitOutOfProcAffinity = (GetNodeAffinity(projectFile, out isExplicit) == NodeAffinity.OutOfProc) && (isExplicit);
             ErrorUtilities.VerifyThrowInvalidOperation(!hasExplicitOutOfProcAffinity || hostObject == null, "InvalidHostObjectOnOutOfProcProject");
-            _hostObjectMap = _hostObjectMap ?? new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
+            _hostObjectMap ??= new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
 
             HostObjects hostObjects = GetHostObjectsFromMapByKeyOrCreateNew(projectFile);
 
@@ -148,15 +157,18 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
         /// Register and unregister from ROT.
         /// Ensure the host object has appropriate COM interface that can be used in task.
         /// </summary>
+        /// <param name="projectFile">project file name</param>
+        /// <param name="targetName">target name</param>
+        /// <param name="taskName">task name</param>
         /// <param name="monikerName">the Moniker used to register host object in ROT</param>
         public void RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(targetName, "targetName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
-            ErrorUtilities.VerifyThrowArgumentNull(monikerName, "monikerName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(targetName, nameof(targetName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowArgumentNull(monikerName, nameof(monikerName));
 
-            _hostObjectMap = _hostObjectMap ?? new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
+            _hostObjectMap ??= new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
 
             HostObjects hostObjects = GetHostObjectsFromMapByKeyOrCreateNew(projectFile);
 
@@ -171,12 +183,12 @@ public void UnregisterProject(string projectFullPath)
         {
             if (projectFullPath != null)
             {
-                if (_hostObjectMap != null && _hostObjectMap.ContainsKey(projectFullPath))
+                if (_hostObjectMap?.ContainsKey(projectFullPath) == true)
                 {
                     _hostObjectMap.Remove(projectFullPath);
                 }
 
-                if (_projectAffinities != null && _projectAffinities.ContainsKey(projectFullPath))
+                if (_projectAffinities?.ContainsKey(projectFullPath) == true)
                 {
                     _projectAffinities.Remove(projectFullPath);
                 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index cff4feb6b66..343a1c4988d 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -62,7 +62,7 @@ public enum ProjectInstanceSettings
     /// and call it several times to build it.
     /// </summary>
     /// <comments>
-    /// Neither this class nor none of its constituents are allowed to have 
+    /// Neither this class nor none of its constituents are allowed to have
     /// references to any of the Construction or Evaluation objects.
     /// This class is immutable except for adding instance items and setting instance properties.
     /// It only exposes items and properties: targets, host services, and the task registry are not exposed as they are only the concern of build.
@@ -100,7 +100,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -134,7 +134,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// The project's root directory, for evaluation of relative paths and
         /// setting the current directory during build.
         /// Is never null.
-        /// If the project has not been loaded from disk and has not been given a path, returns the current directory from 
+        /// If the project has not been loaded from disk and has not been given a path, returns the current directory from
         /// the time the project was loaded - this is the same behavior as Whidbey/Orcas.
         /// If the project has not been loaded from disk but has been given a path, this path may not exist.
         /// </summary>
@@ -158,7 +158,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private HostServices _hostServices;
 
         /// <summary>
-        /// Whether when we read a ToolsVersion that is not equivalent to the current one on the Project tag, we 
+        /// Whether when we read a ToolsVersion that is not equivalent to the current one on the Project tag, we
         /// treat it as the current one.
         /// </summary>
         private bool _usingDifferentToolsVersionFromProjectFile;
@@ -182,7 +182,6 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private bool _translateEntireState;
         private int _evaluationId = BuildEventContext.InvalidEvaluationId;
 
-
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -259,12 +258,13 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
         /// <param name="projectCollection">Project collection</param>
+        /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
         /// <returns>A new project instance</returns>
         private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
 
             // We do not control the current directory at this point, but assume that if we were
             // passed a relative path, the caller assumes we will prepend the current directory.
@@ -340,6 +340,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
         /// <param name="projectCollection">Project collection</param>
+        /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
         /// <returns>A new project instance</returns>
         private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
@@ -398,8 +399,8 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
         /// This is ideal if the project is simply going to be built, and not displayed or edited.
         /// Global properties may be null.
         /// Tools version may be null.
-        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in 
-        /// determining the sub-toolset version. 
+        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in
+        /// determining the sub-toolset version.
         /// </summary>
         /// <param name="xml">The project root element</param>
         /// <param name="globalProperties">The global properties to use.</param>
@@ -422,9 +423,9 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, ProjectLoadSettings? projectLoadSettings)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
 
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, false /*Not explicitly loaded*/);
 
@@ -438,9 +439,9 @@ internal ProjectInstance(string projectFile, IDictionary<string, string> globalP
         /// </summary>
         internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
             Initialize(xml, globalProperties, toolsVersion, null, 0 /* no solution version specified */, buildParameters, loggingService, buildEventContext, sdkResolverService, submissionId);
         }
 
@@ -450,14 +451,14 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(Evaluation.Project.Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings)
         {
-            ErrorUtilities.VerifyThrowInternalNull(data, "data");
-            ErrorUtilities.VerifyThrowInternalLength(directory, "directory");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(fullPath, "fullPath");
+            ErrorUtilities.VerifyThrowInternalNull(data, nameof(data));
+            ErrorUtilities.VerifyThrowInternalLength(directory, nameof(directory));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(fullPath, nameof(fullPath));
 
             _directory = directory;
             _projectFileLocation = ElementLocation.Create(fullPath);
             _hostServices = hostServices;
-            
+
             EvaluationId = data.EvaluationId;
 
             var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
@@ -789,7 +790,7 @@ public List<ProjectItemElement> EvaluatedItemElements
 
         /// <summary>
         /// Serialize the entire project instance state.
-        /// 
+        ///
         /// When false, only a part of the project instance state is serialized (properties and items).
         /// In this case out of proc nodes re-evaluate the project instance from disk to obtain the un-serialized state.
         /// This partial state recombination may lead to build issues when the project instance state differs from what is on disk.
@@ -798,12 +799,12 @@ public bool TranslateEntireState
         {
             get
             {
-                switch (Traits.Instance.EscapeHatches.ProjectInstanceTranslation)
+                return Traits.Instance.EscapeHatches.ProjectInstanceTranslation switch
                 {
-                    case EscapeHatches.ProjectInstanceTranslationMode.Full: return true;
-                    case EscapeHatches.ProjectInstanceTranslationMode.Partial: return false;
-                    default: return _translateEntireState;
-                }
+                    EscapeHatches.ProjectInstanceTranslationMode.Full => true,
+                    EscapeHatches.ProjectInstanceTranslationMode.Partial => false,
+                    _ => _translateEntireState,
+                };
             }
 
             set
@@ -817,7 +818,7 @@ public bool TranslateEntireState
 
         /// <summary>
         /// The ID of the evaluation that produced this ProjectInstance.
-        /// 
+        ///
         /// See <see cref="Project.LastEvaluationId"/>.
         /// </summary>
         public int EvaluationId
@@ -919,7 +920,7 @@ public bool IsImmutable
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// Only set during evaluation, so does not check for immutability.
@@ -944,7 +945,7 @@ Toolset IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMeta
 
         /// <summary>
         /// The sub-toolset version we should use during the build, used to determine which set of sub-toolset
-        /// properties we should merge into this toolset. 
+        /// properties we should merge into this toolset.
         /// </summary>
         string IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SubToolsetVersion
         {
@@ -983,7 +984,7 @@ PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstan
         }
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         ISet<string> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.GlobalPropertiesToTreatAsLocal
         {
@@ -1166,7 +1167,7 @@ internal bool ExplicitToolsVersionSpecified
 
         /// <summary>
         /// The sub-toolset version we should use during the build, used to determine which set of sub-toolset
-        /// properties we should merge into this toolset. 
+        /// properties we should merge into this toolset.
         /// </summary>
         internal string SubToolsetVersion
         {
@@ -1199,7 +1200,7 @@ internal ItemDictionary<ProjectItemInstance> ItemsToBuildWith
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// </summary>
@@ -1213,7 +1214,7 @@ internal TaskRegistry TaskRegistry
         }
 
         /// <summary>
-        /// Number of targets in the project. 
+        /// Number of targets in the project.
         /// </summary>
         internal int TargetsCount
         {
@@ -1237,7 +1238,7 @@ internal ProjectRootElementCacheBase ProjectRootElementCache
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).EvaluatedIncludeEscaped;
         }
@@ -1247,38 +1248,38 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item)
         /// </summary>
         public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstance item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).EvaluatedIncludeEscaped;
         }
 
         /// <summary>
-        /// Gets the escaped value of the provided metadatum. 
+        /// Gets the escaped value of the provided metadatum.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(metadatum, "metadatum");
+            ErrorUtilities.VerifyThrowArgumentNull(metadatum, nameof(metadatum));
 
             return metadatum.EvaluatedValueEscaped;
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetMetadataValueEscaped(ProjectItemInstance item, string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).GetMetadataValueEscaped(name);
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item definition. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item definition.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item, string name)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             return ((IItem)item).GetMetadataValueEscaped(name);
         }
@@ -1289,7 +1290,7 @@ public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item,
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IProperty is an internal interface; this is less confusing to outside customers. ")]
         public static string GetPropertyValueEscaped(ProjectPropertyInstance property)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             return ((IProperty)property).EvaluatedValueEscaped;
         }
@@ -1362,7 +1363,7 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and include any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// </summary>
         /// <remarks>
@@ -1376,7 +1377,7 @@ void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadat
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// </summary>
         /// <remarks>
@@ -1504,7 +1505,7 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         }
 
         /// <summary>
-        /// Get the value of a property in this project, or 
+        /// Get the value of a property in this project, or
         /// an empty string if it does not exist.
         /// </summary>
         /// <remarks>
@@ -1512,7 +1513,7 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         /// at all are not distinguished between by this method.
         /// This is because the build does not distinguish between the two.
         /// The reason this method exists when users can simply do GetProperty(..).EvaluatedValue,
-        /// is that the caller would have to check for null every time. For properties, empty and undefined are 
+        /// is that the caller would have to check for null every time. For properties, empty and undefined are
         /// not distinguished, so it much more useful to also have a method that returns empty string in
         /// either case.
         /// This function returns the unescaped value.
@@ -1551,9 +1552,9 @@ public ProjectPropertyInstance SetProperty(string name, string evaluatedValue)
         /// in use by another ProjectInstance.
         /// </remarks>
         /// <comments>
-        /// For purposes of declaring the project that defined this item (for use with e.g. the 
-        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items 
-        /// like those added by this API. 
+        /// For purposes of declaring the project that defined this item (for use with e.g. the
+        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items
+        /// like those added by this API.
         /// </comments>
         public ProjectItemInstance AddItem(string itemType, string evaluatedInclude)
         {
@@ -1574,9 +1575,9 @@ public ProjectItemInstance AddItem(string itemType, string evaluatedInclude)
         /// in use by another ProjectInstance.
         /// </remarks>
         /// <comments>
-        /// For purposes of declaring the project that defined this item (for use with e.g. the 
-        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items 
-        /// like those added by this API. 
+        /// For purposes of declaring the project that defined this item (for use with e.g. the
+        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items
+        /// like those added by this API.
         /// </comments>
         public ProjectItemInstance AddItem(string itemType, string evaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata)
         {
@@ -2105,10 +2106,10 @@ private void TranslateItems(ITranslator translator)
         /// </summary>
         internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, IReadOnlyCollection<string> targetNames, ISdkResolverService sdkResolverService, int submissionId)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, "globalPropertiesInstances");
-            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, nameof(globalPropertiesInstances));
+            ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
             ErrorUtilities.VerifyThrow(FileUtilities.IsSolutionFilename(projectFile), "Project file {0} is not a solution.", projectFile);
 
             ProjectInstance[] projectInstances = null;
@@ -2340,7 +2341,7 @@ internal ProjectTargetInstance AddTarget(
         {
             VerifyThrowNotImmutable();
 
-            ErrorUtilities.VerifyThrowInternalLength(targetName, "targetName");
+            ErrorUtilities.VerifyThrowInternalLength(targetName, nameof(targetName));
             ErrorUtilities.VerifyThrow(!_actualTargets.ContainsKey(targetName), "Target {0} already exists.", targetName);
 
             ProjectTargetInstance target = new ProjectTargetInstance
@@ -2437,8 +2438,8 @@ int submissionId
         }
 
         /// <summary>
-        /// Spawn the old engine to generate a solution wrapper project, so that our build ordering is somewhat more correct 
-        /// when solutions with toolsVersions &lt; 4.0 are passed to us. 
+        /// Spawn the old engine to generate a solution wrapper project, so that our build ordering is somewhat more correct
+        /// when solutions with toolsVersions &lt; 4.0 are passed to us.
         /// </summary>
         /// <comment>
         /// #############################################################################################
@@ -2597,9 +2598,9 @@ private void Initialize(
             ProjectLoadSettings? projectLoadSettings = null,
             EvaluationContext evaluationContext = null)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
+            ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(explicitToolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, "buildParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
 
             _directory = xml.DirectoryPath;
             _projectFileLocation = (xml.ProjectFileLocation != null) ? xml.ProjectFileLocation : ElementLocation.EmptyLocation;
@@ -2846,10 +2847,7 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluat
 
                 _items.Add(instance);
 
-                if (projectItemToInstanceMap != null)
-                {
-                    projectItemToInstanceMap.Add(item, instance);
-                }
+                projectItemToInstanceMap?.Add(item, instance);
             }
 
             return projectItemToInstanceMap;
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 3d502f86f0e..5b9476f71ed 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -35,11 +35,10 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <summary>
         /// Constructs an empty project item definition instance.
         /// </summary>
-        /// <param name="projectInstance">The project instance to which this item definition belongs.</param>
         /// <param name="itemType">The type of item this definition object represents.</param>
         internal ProjectItemDefinitionInstance(string itemType)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(itemType, "itemType");
+            ErrorUtilities.VerifyThrowArgumentNull(itemType, nameof(itemType));
 
             _itemType = itemType;
         }
@@ -127,7 +126,7 @@ public IEnumerable<string> MetadataNames
         }
 
         /// <summary>
-        /// Implementation of IKeyed exposing the item type, so these 
+        /// Implementation of IKeyed exposing the item type, so these
         /// can be put in a dictionary conveniently.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -198,7 +197,7 @@ string IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string
         ProjectMetadataInstance IItemDefinition<ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement xml, string evaluatedValue, ProjectMetadataInstance predecessor)
         {
             // No mutability check as this is used during creation (evaluation)
-            _metadata = _metadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+            _metadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
 
             ProjectMetadataInstance metadatum = new ProjectMetadataInstance(xml.Name, evaluatedValue);
             _metadata[xml.Name] = metadatum;
diff --git a/src/Build/Instance/ProjectItemGroupTaskInstance.cs b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
index 839d7398ff8..a814b2c41c4 100644
--- a/src/Build/Instance/ProjectItemGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
@@ -53,9 +53,9 @@ internal ProjectItemGroupTaskInstance
             List<ProjectItemGroupTaskItemInstance> items
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(items, "items");
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(items, nameof(items));
 
             _condition = condition;
             _location = location;
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index f33856ecb9e..dc80b36a405 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -50,6 +50,7 @@ public class ProjectItemGroupTaskItemInstance: ITranslatable
         /// </summary>
         private string _matchOnMetadataOptions;
 
+        /// <summary>
         /// The list of metadata to keep.
         /// </summary>
         private string _keepMetadata;
@@ -161,15 +162,15 @@ internal ProjectItemGroupTaskItemInstance
             List<ProjectItemGroupTaskMetadataInstance> metadata
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(itemType, "itemType");
-            ErrorUtilities.VerifyThrowInternalNull(include, "include");
-            ErrorUtilities.VerifyThrowInternalNull(exclude, "exclude");
-            ErrorUtilities.VerifyThrowInternalNull(remove, "remove");
-            ErrorUtilities.VerifyThrowInternalNull(keepMetadata, "keepMetadata");
-            ErrorUtilities.VerifyThrowInternalNull(removeMetadata, "removeMetadata");
-            ErrorUtilities.VerifyThrowInternalNull(keepDuplicates, "keepDuplicates");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowInternalNull(include, nameof(include));
+            ErrorUtilities.VerifyThrowInternalNull(exclude, nameof(exclude));
+            ErrorUtilities.VerifyThrowInternalNull(remove, nameof(remove));
+            ErrorUtilities.VerifyThrowInternalNull(keepMetadata, nameof(keepMetadata));
+            ErrorUtilities.VerifyThrowInternalNull(removeMetadata, nameof(removeMetadata));
+            ErrorUtilities.VerifyThrowInternalNull(keepDuplicates, nameof(keepDuplicates));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _itemType = itemType;
             _include = include;
@@ -196,7 +197,7 @@ List<ProjectItemGroupTaskMetadataInstance> metadata
 
         private ProjectItemGroupTaskItemInstance()
         {
-            
+
         }
 
         /// <summary>
diff --git a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
index 969940ed267..d8b5f0de745 100644
--- a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
@@ -50,10 +50,10 @@ public class ProjectItemGroupTaskMetadataInstance : ITranslatable
         /// </summary>
         internal ProjectItemGroupTaskMetadataInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalNull(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(value, "value");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(value, nameof(value));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 972ba876609..5b660346849 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -52,7 +52,7 @@ public class ProjectItemInstance : IKeyed, IItem<ProjectMetadataInstance>, ITask
         /// <summary>
         /// Constructor for items with no metadata.
         /// Include may be empty.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Mutability follows the project.
         /// </summary>
@@ -64,7 +64,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// <summary>
         /// Constructor for items with no metadata.
         /// Include may be empty.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Mutability follows the project.
         /// </summary>
@@ -75,7 +75,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
 
         /// <summary>
         /// Constructor for items with metadata.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Include may be empty.
         /// Direct metadata may be null, indicating no metadata. It will be cloned.
@@ -106,7 +106,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         {
             CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = null;
 
-            if (directMetadata != null && directMetadata.GetEnumerator().MoveNext())
+            if (directMetadata?.GetEnumerator().MoveNext() == true)
             {
                 metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>(directMetadata.FastCountOrZero());
                 foreach (KeyValuePair<string, string> metadatum in directMetadata)
@@ -159,7 +159,7 @@ public ProjectInstance Project
         /// Item type, for example "Compile"
         /// </summary>
         /// <remarks>
-        /// This cannot be set, as it is used as the key into 
+        /// This cannot be set, as it is used as the key into
         /// the project's items table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -339,7 +339,7 @@ internal string ProjectFullPath
 
         /// <summary>
         /// Get any metadata in the item that has the specified name,
-        /// otherwise returns null. 
+        /// otherwise returns null.
         /// Includes any metadata inherited from item definitions.
         /// Includes any built-in metadata.
         /// </summary>
@@ -349,7 +349,7 @@ public ProjectMetadataInstance GetMetadata(string name)
         }
 
         /// <summary>
-        /// Get the value of a metadata on this item, or 
+        /// Get the value of a metadata on this item, or
         /// String.Empty if it does not exist or has no value.
         /// Includes any metadata inherited from item definitions and any built-in metadata.
         /// To determine whether a piece of metadata is actually present
@@ -416,7 +416,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// Get the value of a metadata on this item, or 
+        /// Get the value of a metadata on this item, or
         /// String.Empty if it does not exist or has no value.
         /// Includes any metadata inherited from item definitions and any built-in metadata.
         /// To determine whether a piece of metadata is actually present
@@ -466,7 +466,7 @@ string ITaskItem2.GetMetadataValueEscaped(string name)
         /// ITaskItem implementation
         /// </summary>
         /// <comments>
-        /// MetadataValue is assumed to be in its escaped form. 
+        /// MetadataValue is assumed to be in its escaped form.
         /// </comments>
         void ITaskItem.SetMetadata(string metadataName, string metadataValue)
         {
@@ -477,7 +477,7 @@ void ITaskItem.SetMetadata(string metadataName, string metadataValue)
         /// ITaskItem2 implementation
         /// </summary>
         /// <comments>
-        /// Assumes metadataValue is unescaped. 
+        /// Assumes metadataValue is unescaped.
         /// </comments>
         void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
         {
@@ -627,7 +627,7 @@ internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance>
         }
 
         /// <summary>
-        /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
+        /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir.
         /// This is not normally legal to set outside of evaluation. However, the CreateItem
         /// needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
         /// tasks to set this particular metadata as a task output.
@@ -699,7 +699,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
             ProjectItemDefinitionInstance itemDefinition;
             if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
             {
-                inheritedItemDefinitions = inheritedItemDefinitions ?? new List<ProjectItemDefinitionInstance>();
+                inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
                 inheritedItemDefinitions.Add(itemDefinition);
             }
 
@@ -717,7 +717,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
         }
 
         /// <summary>
-        /// An item without an item type. Cast to an ITaskItem, this is 
+        /// An item without an item type. Cast to an ITaskItem, this is
         /// what is given to tasks. It is also used for target outputs.
         /// </summary>
         internal sealed class TaskItem :
@@ -802,8 +802,8 @@ internal TaskItem(
                               string definingFileEscaped // the actual project file (or import) that defines this item.
                               )
             {
-                ErrorUtilities.VerifyThrowArgumentLength(includeEscaped, "includeEscaped");
-                ErrorUtilities.VerifyThrowArgumentLength(includeBeforeWildcardExpansionEscaped, "includeBeforeWildcardExpansionEscaped");
+                ErrorUtilities.VerifyThrowArgumentLength(includeEscaped, nameof(includeEscaped));
+                ErrorUtilities.VerifyThrowArgumentLength(includeBeforeWildcardExpansionEscaped, nameof(includeBeforeWildcardExpansionEscaped));
 
                 _includeEscaped = FileUtilities.FixFilePath(includeEscaped);
                 _includeBeforeWildcardExpansionEscaped = FileUtilities.FixFilePath(includeBeforeWildcardExpansionEscaped);
@@ -863,9 +863,9 @@ private TaskItem(ITranslator translator, LookasideStringInterner interner)
             /// Gets or sets the unescaped include, or "name", for the item.
             /// </summary>
             /// <comments>
-            /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but 
+            /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but
             /// that the value being returned was unescaped.  Maintain that behaviour here.  To get
-            /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped. 
+            /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped.
             /// </comments>
             public string ItemSpec
             {
@@ -1236,9 +1236,9 @@ public string GetMetadata(string metadataName)
             /// </summary>
             public string GetMetadataEscaped(string metadataName)
             {
-                if (metadataName == null || metadataName.Length == 0)
+                if (string.IsNullOrEmpty(metadataName))
                 {
-                    ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+                    ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
                 string value = null;
@@ -1278,7 +1278,7 @@ public string GetMetadataEscaped(string metadataName)
             /// ITaskItem implementation which sets metadata.
             /// </summary>
             /// <comments>
-            /// The value is assumed to be escaped. 
+            /// The value is assumed to be escaped.
             /// </comments>
             public void SetMetadata(string metadataName, string metadataValueEscaped)
             {
@@ -1288,7 +1288,7 @@ public void SetMetadata(string metadataName, string metadataValueEscaped)
             }
 
             /// <summary>
-            /// ITaskItem2 implementation which sets the literal value of metadata -- it is escaped 
+            /// ITaskItem2 implementation which sets the literal value of metadata -- it is escaped
             /// internally as necessary.
             /// </summary>
             void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
@@ -1325,19 +1325,19 @@ public void CopyMetadataTo(ITaskItem destinationItem)
             /// Copies direct and item definition metadata.
             /// Does not copy built-in metadata, and will not overwrite existing, non-empty metadata.
             /// If the destination implements ITaskItem2, this avoids losing the escaped nature of values.
-            /// 
+            ///
             /// When copying metadata to a task item which can be accessed from a task (Utilities task item)
             /// this method will merge and expand any metadata originating with item definitions.
             /// </summary>
             /// <param name="destinationItem">destination item to copy the metadata from this to</param>
-            /// <param name="addOriginalItemSpec">Whether the OriginalItemSpec should be added as a piece 
-            /// of magic metadata. For copying of items this is useful but for cloning of items this adds 
-            /// additional metadata which is not useful because the OriginalItemSpec will always be identical 
+            /// <param name="addOriginalItemSpec">Whether the OriginalItemSpec should be added as a piece
+            /// of magic metadata. For copying of items this is useful but for cloning of items this adds
+            /// additional metadata which is not useful because the OriginalItemSpec will always be identical
             /// to the ItemSpec, and the addition will and will cause copy-on-write to trigger.
             /// </param>
             public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
                 string originalItemSpec = null;
                 if (addOriginalItemSpec)
@@ -1413,7 +1413,7 @@ public IDictionary CloneCustomMetadata()
 
             /// <summary>
             /// ITaskItem2 implementation which returns a clone of the metadata on this object.
-            /// Values returned are in their original escaped form. 
+            /// Values returned are in their original escaped form.
             /// </summary>
             /// <returns>The cloned metadata.</returns>
             IDictionary ITaskItem2.CloneCustomMetadataEscaped()
@@ -1553,7 +1553,7 @@ public bool Equals(TaskItem other)
             /// </remarks>
             public bool HasMetadata(string name)
             {
-                if ((_directMetadata != null && _directMetadata.Contains(name)) ||
+                if ((_directMetadata?.Contains(name) == true) ||
                      FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name) ||
                     GetItemDefinitionMetadata(name) != null)
                 {
@@ -1691,7 +1691,7 @@ internal ProjectMetadataInstance SetMetadataObject(string name, string metadataV
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
-                _directMetadata = _directMetadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                 ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, metadataValueEscaped, allowItemSpecModifiers /* may not be built-in metadata name */);
                 _directMetadata.Set(metadatum);
 
@@ -1699,7 +1699,7 @@ internal ProjectMetadataInstance SetMetadataObject(string name, string metadataV
             }
 
             /// <summary>
-            /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
+            /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir.
             /// This is not normally legal to set outside of evaluation. However, the CreateItem
             /// needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
             /// tasks to set this particular metadata as a task output.
@@ -1713,7 +1713,7 @@ internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
 
                 if (!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(name))
                 {
-                    _directMetadata = _directMetadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                    _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                     ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, evaluatedValueEscaped, true /* may be built-in metadata name */);
                     _directMetadata.Set(metadatum);
                 }
@@ -1809,7 +1809,7 @@ internal ProjectItemInstanceFactory(ProjectInstance project)
                 internal ProjectItemInstanceFactory(ProjectInstance project, string itemType)
                     : this(project)
                 {
-                    ErrorUtilities.VerifyThrowInternalLength(itemType, "itemType");
+                    ErrorUtilities.VerifyThrowInternalLength(itemType, nameof(itemType));
                     this.ItemType = itemType;
                 }
 
@@ -1901,7 +1901,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
                 private ProjectItemInstance CreateItem(string includeEscaped, string includeBeforeWildcardExpansionEscaped, ProjectItemInstance source, string definingProject)
                 {
                     ErrorUtilities.VerifyThrowInternalLength(ItemType, "ItemType");
-                    ErrorUtilities.VerifyThrowInternalNull(source, "source");
+                    ErrorUtilities.VerifyThrowInternalNull(source, nameof(source));
 
                     // The new item inherits any metadata originating in item definitions, which
                     // takes precedence over its own item definition metadata.
@@ -1915,14 +1915,14 @@ private ProjectItemInstance CreateItem(string includeEscaped, string includeBefo
                     List<ProjectItemDefinitionInstance> itemDefinitionsClone = null;
                     if (source._taskItem._itemDefinitions != null)
                     {
-                        itemDefinitionsClone = itemDefinitionsClone ?? new List<ProjectItemDefinitionInstance>(source._taskItem._itemDefinitions.Count + 1);
+                        itemDefinitionsClone ??= new List<ProjectItemDefinitionInstance>(source._taskItem._itemDefinitions.Count + 1);
                         itemDefinitionsClone.AddRange(source._taskItem._itemDefinitions);
                     }
 
                     ProjectItemDefinitionInstance sourceItemDefinition;
                     if (_project.ItemDefinitions.TryGetValue(source.ItemType, out sourceItemDefinition))
                     {
-                        itemDefinitionsClone = itemDefinitionsClone ?? new List<ProjectItemDefinitionInstance>();
+                        itemDefinitionsClone ??= new List<ProjectItemDefinitionInstance>();
                         itemDefinitionsClone.Add(sourceItemDefinition);
                     }
 
@@ -2026,7 +2026,7 @@ public TaskItem CreateItem(string includeEscaped, ProjectItemInstance baseItem,
                 {
                     TaskItem item = new TaskItem(baseItem);
 
-                    if (Path.DirectorySeparatorChar != '\\' && includeEscaped != null && includeEscaped.IndexOf('\\') > -1)
+                    if (Path.DirectorySeparatorChar != '\\' && includeEscaped?.IndexOf('\\') > -1)
                     {
                         includeEscaped = includeEscaped.Replace('\\', '/');
                     }
@@ -2057,7 +2057,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
             /// <summary>
             /// Implementation of IMetadataTable that can be passed to expander to expose only built-in metadata on this item.
             /// Built-in metadata is stored in a separate table so it can be cleared out when the item is renamed, as this invalidates the values.
-            /// Also, more importantly, because typically the same regular metadata values can be shared by many items, 
+            /// Also, more importantly, because typically the same regular metadata values can be shared by many items,
             /// and keeping item-specific metadata out of it could allow it to be implemented as a copy-on-write table.
             /// </summary>
             private class BuiltInMetadataTable : IMetadataTable
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index 6be365a0822..73f4653da92 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -61,7 +61,7 @@ internal ProjectMetadataInstance(string name, string escapedValue)
         /// </remarks>
         internal ProjectMetadataInstance(string name, string escapedValue, bool allowItemSpecModifiers)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             if (allowItemSpecModifiers)
             {
diff --git a/src/Build/Instance/ProjectOnErrorInstance.cs b/src/Build/Instance/ProjectOnErrorInstance.cs
index a7a50671284..778da933f1f 100644
--- a/src/Build/Instance/ProjectOnErrorInstance.cs
+++ b/src/Build/Instance/ProjectOnErrorInstance.cs
@@ -56,9 +56,9 @@ internal ProjectOnErrorInstance
             ElementLocation conditionLocation
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(executeTargets, "executeTargets");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalLength(executeTargets, nameof(executeTargets));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _executeTargets = executeTargets;
             _condition = condition;
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
index 90c7e0a39bf..63aff591bec 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
@@ -53,9 +53,9 @@ internal ProjectPropertyGroupTaskInstance
             List<ProjectPropertyGroupTaskPropertyInstance> properties
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(properties, "properties");
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
 
             _condition = condition;
             _location = location;
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index 7f3ebd43cf8..1a7e37876dd 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -50,10 +50,10 @@ public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable
         /// </summary>
         internal ProjectPropertyGroupTaskPropertyInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalNull(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(value, "value");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
+            ErrorUtilities.VerifyThrowInternalNull(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(value, nameof(value));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
 
             _name = name;
             _value = value;
diff --git a/src/Build/Instance/ProjectTargetInstance.cs b/src/Build/Instance/ProjectTargetInstance.cs
index 74b7b03ef1c..dd3dffc3cc5 100644
--- a/src/Build/Instance/ProjectTargetInstance.cs
+++ b/src/Build/Instance/ProjectTargetInstance.cs
@@ -28,7 +28,7 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         private string _name;
 
         /// <summary>
-        /// Condition on the target. 
+        /// Condition on the target.
         /// Evaluated during the build.
         /// </summary>
         private string _condition;
@@ -44,7 +44,7 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         private string _outputs;
 
         /// <summary>
-        /// Return values on the target. 
+        /// Return values on the target.
         /// </summary>
         private string _returns;
 
@@ -76,8 +76,8 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         /// <summary>
         /// Whether the project file that this target lives in has at least one target
         /// with a Returns attribute on it.  If so, the default behaviour for all targets
-        /// in the file without Returns attributes changes from returning the Outputs, to 
-        /// returning nothing. 
+        /// in the file without Returns attributes changes from returning the Outputs, to
+        /// returning nothing.
         /// </summary>
         private bool _parentProjectSupportsReturnsAttribute;
 
@@ -162,17 +162,17 @@ internal ProjectTargetInstance
             bool parentProjectSupportsReturnsAttribute
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(name, "name");
-            ErrorUtilities.VerifyThrowInternalNull(condition, "condition");
-            ErrorUtilities.VerifyThrowInternalNull(inputs, "inputs");
-            ErrorUtilities.VerifyThrowInternalNull(outputs, "outputs");
-            ErrorUtilities.VerifyThrowInternalNull(keepDuplicateOutputs, "keepDuplicateOutputs");
-            ErrorUtilities.VerifyThrowInternalNull(dependsOnTargets, "dependsOnTargets");
-            ErrorUtilities.VerifyThrowInternalNull(beforeTargets, "beforeTargets");
-            ErrorUtilities.VerifyThrowInternalNull(afterTargets, "afterTargets");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(children, "children");
-            ErrorUtilities.VerifyThrowInternalNull(onErrorChildren, "onErrorChildren");
+            ErrorUtilities.VerifyThrowInternalLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowInternalNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowInternalNull(inputs, nameof(inputs));
+            ErrorUtilities.VerifyThrowInternalNull(outputs, nameof(outputs));
+            ErrorUtilities.VerifyThrowInternalNull(keepDuplicateOutputs, nameof(keepDuplicateOutputs));
+            ErrorUtilities.VerifyThrowInternalNull(dependsOnTargets, nameof(dependsOnTargets));
+            ErrorUtilities.VerifyThrowInternalNull(beforeTargets, nameof(beforeTargets));
+            ErrorUtilities.VerifyThrowInternalNull(afterTargets, nameof(afterTargets));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(children, nameof(children));
+            ErrorUtilities.VerifyThrowInternalNull(onErrorChildren, nameof(onErrorChildren));
 
             _name = name;
             _condition = condition;
@@ -338,7 +338,7 @@ public ICollection<ProjectTaskInstance> Tasks
 
         /// <summary>
         /// Full path to the file from which this target originated.
-        /// If it originated in a project that was not loaded and has never been 
+        /// If it originated in a project that was not loaded and has never been
         /// given a path, returns an empty string.
         /// </summary>
         public string FullPath
@@ -450,8 +450,8 @@ string IKeyed.Key
         /// <summary>
         /// Whether the project file that this target lives in has at least one target
         /// with a Returns attribute on it.  If so, the default behaviour for all targets
-        /// in the file without Returns attributes changes from returning the Outputs, to 
-        /// returning nothing. 
+        /// in the file without Returns attributes changes from returning the Outputs, to
+        /// returning nothing.
         /// </summary>
         internal bool ParentProjectSupportsReturnsAttribute
         {
@@ -543,7 +543,7 @@ internal ProjectTaskInstance AddTask(string taskName, string condition, string c
         /// <returns>The new task instance.</returns>
         internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture)
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
             ProjectTaskInstance task = new ProjectTaskInstance(taskName, _location, condition ?? String.Empty, continueOnError ?? String.Empty, msbuildRuntime ?? String.Empty, msbuildArchitecture ?? String.Empty);
             this.AddProjectTargetInstanceChild(task);
             return task;
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index 98b42dc76ce..963f55f9601 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -98,8 +98,8 @@ internal ProjectTaskInstance
             IList<ProjectTaskInstanceChild> outputs
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(element, "element");
-            ErrorUtilities.VerifyThrowInternalNull(outputs, "outputs");
+            ErrorUtilities.VerifyThrowInternalNull(element, nameof(element));
+            ErrorUtilities.VerifyThrowInternalNull(outputs, nameof(outputs));
 
             // These are all immutable
             _name = element.Name;
@@ -163,9 +163,9 @@ internal ProjectTaskInstance
             ElementLocation msbuildRuntimeLocation,
             ElementLocation msbuildArchitectureLocation)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
-            ErrorUtilities.VerifyThrowArgumentNull(condition, "condition");
-            ErrorUtilities.VerifyThrowArgumentNull(continueOnError, "continueOnError");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
+            ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
+            ErrorUtilities.VerifyThrowArgumentNull(continueOnError, nameof(continueOnError));
 
             _name = name;
             _condition = condition;
@@ -339,8 +339,8 @@ internal void SetParameter(string parameterName, string unevaluatedValue)
         /// <param name="condition">The condition.</param>
         internal void AddOutputItem(string taskOutputParameterName, string itemName, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, "taskOutputParameterName");
-            ErrorUtilities.VerifyThrowArgumentLength(itemName, "itemName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, nameof(taskOutputParameterName));
+            ErrorUtilities.VerifyThrowArgumentLength(itemName, nameof(itemName));
             _outputs.Add(new ProjectTaskOutputItemInstance(itemName, taskOutputParameterName, condition ?? String.Empty, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, condition == null ? null : ElementLocation.EmptyLocation));
         }
 
@@ -352,8 +352,8 @@ internal void AddOutputItem(string taskOutputParameterName, string itemName, str
         /// <param name="condition">The condition.</param>
         internal void AddOutputProperty(string taskOutputParameterName, string propertyName, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, "taskOutputParameterName");
-            ErrorUtilities.VerifyThrowArgumentLength(propertyName, "propertyName");
+            ErrorUtilities.VerifyThrowArgumentLength(taskOutputParameterName, nameof(taskOutputParameterName));
+            ErrorUtilities.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
             _outputs.Add(new ProjectTaskOutputPropertyInstance(propertyName, taskOutputParameterName, condition ?? String.Empty, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, ElementLocation.EmptyLocation, condition == null ? null : ElementLocation.EmptyLocation));
         }
 
diff --git a/src/Build/Instance/ProjectTaskOutputItemInstance.cs b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
index ee8f7df8ac6..7bbaa1fee33 100644
--- a/src/Build/Instance/ProjectTaskOutputItemInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
@@ -58,11 +58,11 @@ public sealed class ProjectTaskOutputItemInstance : ProjectTaskInstanceChild, IT
         /// </summary>
         internal ProjectTaskOutputItemInstance(string itemType, string taskParameter, string condition, ElementLocation location, ElementLocation itemTypeLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalLength(itemType, "itemType");
-            ErrorUtilities.VerifyThrowInternalLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(itemTypeLocation, "itemTypeLocation");
-            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, "taskParameterLocation");
+            ErrorUtilities.VerifyThrowInternalLength(itemType, nameof(itemType));
+            ErrorUtilities.VerifyThrowInternalLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(itemTypeLocation, nameof(itemTypeLocation));
+            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, nameof(taskParameterLocation));
 
             _itemType = itemType;
             _taskParameter = taskParameter;
diff --git a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
index fd65a4ceca7..2017af40368 100644
--- a/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputPropertyInstance.cs
@@ -55,11 +55,11 @@ public sealed class ProjectTaskOutputPropertyInstance : ProjectTaskInstanceChild
         /// </summary>
         internal ProjectTaskOutputPropertyInstance(string propertyName, string taskParameter, string condition, ElementLocation location, ElementLocation propertyNameLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation)
         {
-            ErrorUtilities.VerifyThrowInternalLength(propertyName, "propertyName");
-            ErrorUtilities.VerifyThrowInternalLength(taskParameter, "taskParameter");
-            ErrorUtilities.VerifyThrowInternalNull(location, "location");
-            ErrorUtilities.VerifyThrowInternalNull(propertyNameLocation, "propertyNameLocation");
-            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, "taskParameterLocation");
+            ErrorUtilities.VerifyThrowInternalLength(propertyName, nameof(propertyName));
+            ErrorUtilities.VerifyThrowInternalLength(taskParameter, nameof(taskParameter));
+            ErrorUtilities.VerifyThrowInternalNull(location, nameof(location));
+            ErrorUtilities.VerifyThrowInternalNull(propertyNameLocation, nameof(propertyNameLocation));
+            ErrorUtilities.VerifyThrowInternalNull(taskParameterLocation, nameof(taskParameterLocation));
 
             _propertyName = propertyName;
             _taskParameter = taskParameter;
diff --git a/src/Build/Instance/ReflectableTaskPropertyInfo.cs b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
index 81c601c1fd5..4ffcff5b0ac 100644
--- a/src/Build/Instance/ReflectableTaskPropertyInfo.cs
+++ b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
@@ -34,7 +34,7 @@ internal class ReflectableTaskPropertyInfo : TaskPropertyInfo
         internal ReflectableTaskPropertyInfo(TaskPropertyInfo taskPropertyInfo, Type taskType)
             : base(taskPropertyInfo.Name, taskPropertyInfo.PropertyType, taskPropertyInfo.Output, taskPropertyInfo.Required)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskType, "taskType");
+            ErrorUtilities.VerifyThrowArgumentNull(taskType, nameof(taskType));
             _taskType = taskType;
         }
 
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index e9960ce22a2..14ecd85edfa 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -205,7 +205,7 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary<string,
         /// </remarks>
         public void CleanupTask(ITask task)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
 #if FEATURE_APPDOMAIN
             AppDomain appDomain;
             if (_tasksAndAppDomains.TryGetValue(task, out appDomain))
@@ -261,7 +261,7 @@ internal LoadedType InitializeFactory
                 string taskProjectFile
             )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+            ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
             VerifyThrowIdentityParametersValid(taskFactoryIdentityParameters, elementLocation, taskName, "Runtime", "Architecture");
 
             if (taskFactoryIdentityParameters != null)
@@ -273,7 +273,7 @@ string taskProjectFile
 
             try
             {
-                ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
+                ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 _taskName = taskName;
                 _loadedType = _typeLoader.Load(taskName, loadInfo);
                 ProjectErrorUtilities.VerifyThrowInvalidProject(_loadedType != null, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, String.Empty);
@@ -332,7 +332,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             // the task factory parameters if we have any to calculate; otherwise even if we 
             // still launch the task factory, it will be with parameters corresponding to the 
             // current process. 
-            if ((_factoryIdentityParameters != null && _factoryIdentityParameters.Count > 0) || (taskIdentityParameters != null && taskIdentityParameters.Count > 0))
+            if ((_factoryIdentityParameters?.Count > 0) || (taskIdentityParameters?.Count > 0))
             {
                 VerifyThrowIdentityParametersValid(taskIdentityParameters, taskLocation, _taskName, "MSBuildRuntime", "MSBuildArchitecture");
 
@@ -351,9 +351,9 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 
             if (useTaskFactory)
             {
-                ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, "buildComponentHost");
+                ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, nameof(buildComponentHost));
 
-                mergedParameters = mergedParameters ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 string runtime = null;
                 string architecture = null;
@@ -475,7 +475,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
         private static void VerifyThrowIdentityParametersValid(IDictionary<string, string> identityParameters, IElementLocation errorLocation, string taskName, string runtimeName, string architectureName)
         {
             // validate the task factory parameters
-            if (identityParameters != null && identityParameters.Count > 0)
+            if (identityParameters?.Count > 0)
             {
                 string runtime = null;
                 if (identityParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 072b94052e9..68410eb19ac 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -131,7 +131,7 @@ public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggin
 #endif
             )
         {
-            ErrorUtilities.VerifyThrowInternalNull(taskType, "taskType");
+            ErrorUtilities.VerifyThrowInternalNull(taskType, nameof(taskType));
 
             _taskLocation = taskLocation;
             _taskLoggingContext = taskLoggingContext;
@@ -206,7 +206,7 @@ public object GetPropertyValue(TaskPropertyInfo property)
 
                 // If we returned an exception, then we want to throw it when we 
                 // do the get.  
-                if (value != null && (value as Exception) != null)
+                if (value is Exception)
                 {
                     throw (Exception)value;
                 }
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 62d541b85d1..945fe1a875f 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -58,8 +58,8 @@ internal class TaskFactoryLoggingHost :
         /// </summary>
         public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation elementLocation, BuildLoggingContext loggingContext)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "loggingContext");
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             _activeProxy = true;
             _isRunningWithMultipleNodes = isRunningWithMultipleNodes;
@@ -69,11 +69,11 @@ public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation e
 
         /// <summary>
         /// Returns true in the multiproc case
-        /// REVIEW: Should this mean the same thing in the distributed build case?  If we have 
+        /// REVIEW: Should this mean the same thing in the distributed build case?  If we have
         /// a build which happens to be on a distributed cluster, but the build manager has only
         /// alotted a single machine to this build, is this true?  Because the build manager
         /// could later decide to add more nodes to this build.
-        /// UNDONE: This means we are building with multiple processes. If we are building on 
+        /// UNDONE: This means we are building with multiple processes. If we are building on
         /// one machine then I think the maxcpu-count is still 1. In my mind this means multiple nodes either distributed or on the same machine.
         /// </summary>
         public bool IsRunningMultipleNodes
@@ -152,7 +152,7 @@ internal BuildLoggingContext LoggingContext
         /// <param name="e">The event args</param>
         public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -173,7 +173,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
         /// <param name="e">The event args</param>
         public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -194,7 +194,7 @@ public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
         /// <param name="e">The event args</param>
         public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -215,7 +215,7 @@ public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
         /// <param name="e">The event args</param>
         public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             VerifyActiveProxy();
 
             // If we are in building across process we need the events to be serializable. This method will 
@@ -247,7 +247,7 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, Syste
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
@@ -321,10 +321,7 @@ internal void MarkAsInactive()
             {
                 ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
 
-                if (lease != null)
-                {
-                    lease.Unregister(_sponsor);
-                }
+                lease?.Unregister(_sponsor);
 
                 _sponsor.Close();
                 _sponsor = null;
@@ -352,7 +349,7 @@ internal bool IsEventSerializable(BuildEventArgs e)
         /// </summary>
         private void VerifyActiveProxy()
         {
-            ErrorUtilities.VerifyThrow(_activeProxy == true, "Attempted to use an inactive task factory logging host.");
+            ErrorUtilities.VerifyThrow(_activeProxy, "Attempted to use an inactive task factory logging host.");
         }
     }
 }
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index b58f1a138cb..f097932a8e6 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -62,8 +62,8 @@ internal sealed class TaskFactoryWrapper
         /// </summary>
         internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary<string, string> factoryIdentityParameters)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskFactory, "taskFactory");
-            ErrorUtilities.VerifyThrowArgumentLength(taskName, "taskName");
+            ErrorUtilities.VerifyThrowArgumentNull(taskFactory, nameof(taskFactory));
+            ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
             _taskFactory = taskFactory;
             _taskName = taskName;
             TaskFactoryLoadedType = taskFactoryLoadInfo;
@@ -182,8 +182,8 @@ public TaskPropertyInfo GetProperty(string propertyName)
         /// </summary>
         internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object value)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             IGeneratedTask generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
@@ -202,8 +202,8 @@ internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object val
         /// </summary>
         internal object GetPropertyValue(ITask task, TaskPropertyInfo property)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
-            ErrorUtilities.VerifyThrowArgumentNull(property, "property");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
+            ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
             IGeneratedTask generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
@@ -305,11 +305,11 @@ private void PopulatePropertyInfoCacheIfNecessary()
                     }
                 }
 
-                _propertyInfoCache = _propertyInfoCache ?? ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
+                _propertyInfoCache ??= ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
 
-                _namesOfPropertiesWithRequiredAttribute = _namesOfPropertiesWithRequiredAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithOutputAttribute = _namesOfPropertiesWithOutputAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithAmbiguousMatches = _namesOfPropertiesWithAmbiguousMatches ?? ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithRequiredAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithOutputAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithAmbiguousMatches ??= ReadOnlyEmptyDictionary<string, string>.Instance;
             }
         }
         #endregion
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 3d261b4cf46..66e0aa13a51 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -37,7 +37,7 @@ namespace Microsoft.Build.Execution
     /// <example>
     /// &lt;UsingTask TaskName="Microsoft.Build.Tasks.Csc"                     ==> look for the "Csc" task in the
     ///            AssemblyName="Microsoft.Build.Tasks"/&gt;                       weakly-named "Microsoft.Build.Tasks" assembly
-    /// 
+    ///
     /// &lt;UsingTask TaskName="t1"                                            ==> look for the "t1" task in the
     ///            AssemblyName="mytasks, Culture=en, Version=1.0.0.0"/&gt;        strongly-named "mytasks" assembly
     ///
@@ -58,64 +58,64 @@ internal sealed class TaskRegistry : ITranslatable
         /// <summary>
         /// If true, we will force all tasks to run in the MSBuild task host EXCEPT
         /// a small well-known set of tasks that are known to depend on IBuildEngine
-        /// callbacks; as forcing those out of proc would be just setting them up for 
-        /// known failure.  
+        /// callbacks; as forcing those out of proc would be just setting them up for
+        /// known failure.
         /// </summary>
         private static bool s_forceTaskHostLaunch = (Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC") == "1");
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v4), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV4SimpleName = "Microsoft.Build.Tasks.v4.0";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v4), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV4Filename = s_tasksV4SimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v4) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v4) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksV4Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV4Filename);
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v12), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV12SimpleName = "Microsoft.Build.Tasks.v12.0";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v12), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV12Filename = s_tasksV12SimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v12) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v12) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksV12Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV12Filename);
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v14+), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksCoreSimpleName = "Microsoft.Build.Tasks.Core";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v14+), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksCoreFilename = s_tasksCoreSimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v14+) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v14+) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
@@ -129,7 +129,7 @@ internal sealed class TaskRegistry : ITranslatable
         /// <summary>
         /// Cache of tasks already found using fuzzy matching,
         /// keyed by the task name requested.
-        /// Value is a dictionary of all possible matches for that 
+        /// Value is a dictionary of all possible matches for that
         /// task name, by unique identity.
         /// </summary>
         private Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch;
@@ -153,7 +153,7 @@ internal sealed class TaskRegistry : ITranslatable
         /// </summary>
         internal TaskRegistry(ProjectRootElementCacheBase projectRootElementCache)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, "projectRootElementCache");
+            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
 
             RootElementCache = projectRootElementCache;
         }
@@ -163,7 +163,7 @@ private TaskRegistry()
         }
 
         /// <summary>
-        /// Creates a task registry that defers to the specified toolset's registry for those tasks it cannot resolve.        
+        /// Creates a task registry that defers to the specified toolset's registry for those tasks it cannot resolve.
         /// UNDONE: (Logging.) We can't pass the base task registry from the Toolset because we can't call GetTaskRegistry
         /// without logging context information.  When the Project load code is altered to contain logging service
         /// references, we can load the toolset task registry at the time this registry is created and pass it to
@@ -173,8 +173,8 @@ private TaskRegistry()
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         internal TaskRegistry(Toolset toolset, ProjectRootElementCacheBase projectRootElementCache)
         {
-            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, "projectRootElementCache");
-            ErrorUtilities.VerifyThrowInternalNull(toolset, "toolset");
+            ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
+            ErrorUtilities.VerifyThrowInternalNull(toolset, nameof(toolset));
 
             RootElementCache = projectRootElementCache;
             _toolset = toolset;
@@ -228,7 +228,7 @@ IFileSystem fileSystem
             where P : class, IProperty
             where I : class, IItem
         {
-            ErrorUtilities.VerifyThrowInternalNull(directoryOfImportingFile, "directoryOfImportingFile");
+            ErrorUtilities.VerifyThrowInternalNull(directoryOfImportingFile, nameof(directoryOfImportingFile));
 
             if (!ConditionEvaluator.EvaluateCondition
                 (
@@ -447,7 +447,7 @@ ElementLocation elementLocation
         /// </summary>
         /// <param name="taskName">The name of the task to retrieve.</param>
         /// <param name="taskProjectFile">The task's project file.</param>
-        /// <param name="taskIdentityParameters">The set of task identity parameters to be used to identify the 
+        /// <param name="taskIdentityParameters">The set of task identity parameters to be used to identify the
         /// correct task record match.</param>
         /// <param name="exactMatchRequired">True if an exact name match is required.</param>
         /// <param name="targetLoggingContext">The logging context.</param>
@@ -477,7 +477,7 @@ out bool retrievedFromCache
             }
 
             // Try the current task registry
-            if (taskRecord == null && _taskRegistrations != null && _taskRegistrations.Count > 0)
+            if (taskRecord == null && _taskRegistrations?.Count > 0)
             {
                 if (exactMatchRequired)
                 {
@@ -552,12 +552,12 @@ out bool retrievedFromCache
             // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
             if (exactMatchRequired)
             {
-                _cachedTaskRecordsWithExactMatch = _cachedTaskRecordsWithExactMatch ?? new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
+                _cachedTaskRecordsWithExactMatch ??= new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
                 _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
             }
             else
             {
-                _cachedTaskRecordsWithFuzzyMatch = _cachedTaskRecordsWithFuzzyMatch ?? new Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>(StringComparer.OrdinalIgnoreCase);
+                _cachedTaskRecordsWithFuzzyMatch ??= new Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>(StringComparer.OrdinalIgnoreCase);
 
                 // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
                 // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.  
@@ -634,13 +634,13 @@ private Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> GetReleva
         }
 
         /// <summary>
-        /// Registers an evaluated using task tag for future 
+        /// Registers an evaluated using task tag for future
         /// consultation
         /// </summary>
         private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord)
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
-            ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo, "assemblyLoadInfo");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo, nameof(assemblyLoadInfo));
 
             // Lazily allocate the hashtable
             if (_taskRegistrations == null)
@@ -663,14 +663,13 @@ private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, st
 
         private static Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)
         {
-
             return capacity != null
                 ? new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)
                 : new Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
         }
 
         /// <summary>
-        /// Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name 
+        /// Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name
         /// can be created by the factories which are wrapped by the records. (this is done by instantiating the task factory and asking it).
         /// </summary>
         private RegisteredTaskRecord GetMatchingRegistration
@@ -696,7 +695,7 @@ ElementLocation elementLocation
         }
 
         /// <summary>
-        /// An object representing the identity of a task -- not just task name, but also 
+        /// An object representing the identity of a task -- not just task name, but also
         /// the set of identity parameters
         /// </summary>
         [DebuggerDisplay("{Name} ParameterCount = {TaskIdentityParameters.Count}")]
@@ -754,7 +753,7 @@ public IDictionary<string, string> TaskIdentityParameters
             }
 
             /// <summary>
-            /// Comparer used to figure out whether two RegisteredTaskIdentities are equal or not. 
+            /// Comparer used to figure out whether two RegisteredTaskIdentities are equal or not.
             /// </summary>
             internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTaskIdentity>
             {
@@ -764,8 +763,8 @@ internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTask
                 private static RegisteredTaskIdentityComparer s_exact = new RegisteredTaskIdentityComparer(true /* exact match */);
 
                 /// <summary>
-                /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the 
-                /// name, but does a fuzzy match on the task identity parameters. 
+                /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the
+                /// name, but does a fuzzy match on the task identity parameters.
                 /// </summary>
                 private static RegisteredTaskIdentityComparer s_fuzzy = new RegisteredTaskIdentityComparer(false /* fuzzy match */);
 
@@ -783,7 +782,7 @@ private RegisteredTaskIdentityComparer(bool exactMatchRequired)
                 }
 
                 /// <summary>
-                /// The singleton comparer to use for when an exact match is desired 
+                /// The singleton comparer to use for when an exact match is desired
                 /// </summary>
                 public static RegisteredTaskIdentityComparer Exact
                 {
@@ -791,7 +790,7 @@ public static RegisteredTaskIdentityComparer Exact
                 }
 
                 /// <summary>
-                /// The singleton comparer to use for when a fuzzy match is desired 
+                /// The singleton comparer to use for when a fuzzy match is desired
                 /// </summary>
                 public static RegisteredTaskIdentityComparer Fuzzy
                 {
@@ -799,9 +798,9 @@ public static RegisteredTaskIdentityComparer Fuzzy
                 }
 
                 /// <summary>
-                /// Returns true if these two identities match "fuzzily" -- if the names pass a partial type name 
-                /// match and the task identity parameters would constitute a valid merge (e.g. "don't care" and 
-                /// something explicit).  Otherwise returns false. 
+                /// Returns true if these two identities match "fuzzily" -- if the names pass a partial type name
+                /// match and the task identity parameters would constitute a valid merge (e.g. "don't care" and
+                /// something explicit).  Otherwise returns false.
                 /// </summary>
                 public static bool IsPartialMatch(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                 {
@@ -816,7 +815,7 @@ public static bool IsPartialMatch(RegisteredTaskIdentity x, RegisteredTaskIdenti
                 }
 
                 /// <summary>
-                /// Returns true if the two task identities are equal; false otherwise. 
+                /// Returns true if the two task identities are equal; false otherwise.
                 /// </summary>
                 public bool Equals(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                 {
@@ -889,8 +888,8 @@ public int GetHashCode(RegisteredTaskIdentity obj)
 
                 /// <summary>
                 /// Returns true if the two dictionaries representing sets of task identity parameters match; false otherwise.
-                /// Internal so that RegisteredTaskRecord can use this function in its determination of whether the task factory 
-                /// supports a certain task identity.  
+                /// Internal so that RegisteredTaskRecord can use this function in its determination of whether the task factory
+                /// supports a certain task identity.
                 /// </summary>
                 private static bool IdentityParametersMatch(IDictionary<string, string> x, IDictionary<string, string> y, bool exactMatchRequired)
                 {
@@ -997,17 +996,16 @@ internal class RegisteredTaskRecord : ITranslatable
 
             /// <summary>
             /// Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
-            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
+            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue.
             /// </summary>
             internal const string CodeTaskFactory = "CodeTaskFactory";
 
             /// <summary>
             /// Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
-            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
+            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue.
             /// </summary>
             internal const string XamlTaskFactory = "XamlTaskFactory";
 
-
             /// <summary>
             /// Lock for the taskFactoryTypeLoader
             /// </summary>
@@ -1057,14 +1055,14 @@ internal class RegisteredTaskRecord : ITranslatable
             private TaskFactoryWrapper _taskFactoryWrapperInstance;
 
             /// <summary>
-            /// Cache of task names which can be created by the factory. 
-            /// When ever a taskName is checked against the factory we cache the result so we do not have to 
+            /// Cache of task names which can be created by the factory.
+            /// When ever a taskName is checked against the factory we cache the result so we do not have to
             /// make possibly expensive calls over and over again.
             /// </summary>
             private Dictionary<RegisteredTaskIdentity, object> _taskNamesCreatableByFactory;
 
             /// <summary>
-            /// Set of parameters that can be used by the task factory specifically.  
+            /// Set of parameters that can be used by the task factory specifically.
             /// </summary>
             private Dictionary<string, string> _taskFactoryParameters;
 
@@ -1160,14 +1158,14 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody
             }
 
             /// <summary>
-            /// Identity of this task. 
+            /// Identity of this task.
             /// </summary>
             internal RegisteredTaskIdentity TaskIdentity => _taskIdentity;
 
             /// <summary>
-            /// Ask the question, whether or not the task name can be created by the task factory. 
-            /// To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name. 
-            /// This question is useful for assembly tasks where the task may or may not be in an assembly, this can also be useful if the task factory 
+            /// Ask the question, whether or not the task name can be created by the task factory.
+            /// To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name.
+            /// This question is useful for assembly tasks where the task may or may not be in an assembly, this can also be useful if the task factory
             /// loads an external file and uses that to generate the tasks.
             /// </summary>
             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>
@@ -1263,7 +1261,7 @@ internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile,
             }
 
             /// <summary>
-            /// Given a Registered task record and a task name. Check create an instance of the task factory using the record. 
+            /// Given a Registered task record and a task name. Check create an instance of the task factory using the record.
             /// If the factory is a assembly task factory see if the assemblyFile has the correct task inside of it.
             /// </summary>
             internal TaskFactoryWrapper GetTaskFactoryFromRegistrationRecord(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)
@@ -1290,7 +1288,6 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                     ITaskFactory factory = null;
                     LoadedType loadedType = null;
 
-
                     bool isAssemblyTaskFactory = String.Equals(TaskFactoryAttributeName, AssemblyTaskFactory, StringComparison.OrdinalIgnoreCase);
                     bool isTaskHostFactory = String.Equals(TaskFactoryAttributeName, TaskHostFactory, StringComparison.OrdinalIgnoreCase);
 
@@ -1475,7 +1472,6 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                         }
                     }
 
-
                     _taskFactoryWrapperInstance = new TaskFactoryWrapper(factory, loadedType, RegisteredName, TaskFactoryParameters);
                 }
 
@@ -1543,8 +1539,8 @@ internal void ExpandUsingTask<P, I>(ProjectUsingTaskElement projectUsingTaskXml,
                     where P : class, IProperty
                     where I : class, IItem
                 {
-                    ErrorUtilities.VerifyThrowArgumentNull(projectUsingTaskXml, "projectUsingTaskXml");
-                    ErrorUtilities.VerifyThrowArgumentNull(expander, "expander");
+                    ErrorUtilities.VerifyThrowArgumentNull(projectUsingTaskXml, nameof(projectUsingTaskXml));
+                    ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
 
                     ProjectUsingTaskBodyElement taskElement = projectUsingTaskXml.TaskBody;
                     if (taskElement != null)
@@ -1607,7 +1603,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                     where P : class, IProperty
                     where I : class, IItem
                 {
-                    _usingTaskParameters = _usingTaskParameters ?? new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
+                    _usingTaskParameters ??= new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
 
                     // Go through each of the parameters and create new ParameterInfo objects from them
                     foreach (ProjectUsingTaskParameterElement parameter in usingTaskParameterGroup.Parameters)
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 1b265e7fb62..010dec7f5f3 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -64,7 +64,7 @@ internal static ConsoleColor BackgroundColor
 
         /// <summary>
         /// Gets or sets the number of MSBuild processes participating in the build. If greater than 1,
-        /// include the node ID 
+        /// include the node ID
         /// </summary>
         public int NumberOfProcessors { get; set; } = 1;
 
@@ -113,7 +113,7 @@ public void ParseParameters()
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the keys 
+        /// An implementation of IComparer useful for comparing the keys
         /// on DictionaryEntry's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -126,7 +126,7 @@ public int Compare(DictionaryEntry a, DictionaryEntry b)
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the ItemSpecs 
+        /// An implementation of IComparer useful for comparing the ItemSpecs
         /// on ITaskItem's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -208,7 +208,7 @@ internal void WriteLinePrettyFromResource(int indentLevel, string resourceString
         }
 
         /// <summary>
-        /// Writes to the log, using the default indentation. Does not 
+        /// Writes to the log, using the default indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(string formattedString)
@@ -271,7 +271,7 @@ internal void ShowPerfSummary()
         }
 
         /// <summary>
-        /// Writes to the log, using the specified indentation. Does not 
+        /// Writes to the log, using the specified indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(int indentLevel, string formattedString)
@@ -481,7 +481,7 @@ internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandle
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="properties">List of properties</param>
@@ -520,7 +520,7 @@ internal void WriteEnvironment(IDictionary<string, string> environment)
         }
 
         /// <summary>
-        /// Generate a list which contains the properties referenced by the properties 
+        /// Generate a list which contains the properties referenced by the properties
         /// enumerable object
         /// </summary>
         internal List<DictionaryEntry> ExtractPropertyList(IEnumerable properties)
@@ -578,7 +578,7 @@ internal virtual void OutputProperties(List<DictionaryEntry> list)
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         internal void WriteItems(SortedList itemTypes)
@@ -678,7 +678,6 @@ internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
             resetColor();
         }
 
-
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
@@ -837,13 +836,13 @@ internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate wr
             }
 
             /// <summary>
-            /// Returns an IComparer that will put performance counters 
+            /// Returns an IComparer that will put performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal static IComparer DescendingByElapsedTimeComparer => new DescendingByElapsedTime();
 
             /// <summary>
-            /// Private IComparer class for sorting performance counters 
+            /// Private IComparer class for sorting performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal class DescendingByElapsedTime : IComparer
@@ -969,7 +968,7 @@ public virtual void Initialize(IEventSource eventSource)
         /// </summary>
         internal virtual bool ApplyParameter(string parameterName, string parameterValue)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             switch (parameterName.ToUpperInvariant())
             {
@@ -1007,16 +1006,11 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue
                         }
                         else
                         {
-                            switch (parameterValue.ToUpperInvariant())
+                            showProjectFile = (parameterValue.ToUpperInvariant()) switch
                             {
-                                case "TRUE":
-                                    showProjectFile = true;
-                                    break;
-
-                                default:
-                                    showProjectFile = false;
-                                    break;
-                            }
+                                "TRUE" => true,
+                                _ => false,
+                            };
                         }
                     }
 
@@ -1180,7 +1174,6 @@ private bool ApplyVerbosityParameter(string parameterValue)
 
         internal bool runningWithCharacterFileType = false;
 
-
         #region Per-build Members
 
         /// <summary>
@@ -1219,7 +1212,7 @@ private bool ApplyVerbosityParameter(string parameterValue)
         internal Dictionary<string, PerformanceCounter> taskPerformanceCounters;
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         internal Dictionary<string, PerformanceCounter> projectEvaluationPerformanceCounters;
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index e67c64310af..5ee2af9780c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -971,7 +971,6 @@ private EvaluationLocation ReadEvaluationLocation()
                 if (hasParent)
                 {
                     parentId = ReadInt64();
-
                 }
                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);
             }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 8a46cb45cac..bc8f203903e 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -670,7 +670,7 @@ private void Write(BuildEventContext buildEventContext)
 
         private void Write<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> keyValuePairs)
         {
-            if (keyValuePairs != null && keyValuePairs.Any())
+            if (keyValuePairs?.Any() == true)
             {
                 Write(keyValuePairs.Count());
                 foreach (var kvp in keyValuePairs)
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 78b067f88df..b865a4764b0 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -58,7 +58,6 @@ public class ConsoleLogger : INodeLogger
         private bool _skipProjectStartedText = false;
         private bool? _showSummary;
 
-
         #region Constructors
 
         /// <summary>
@@ -120,19 +119,19 @@ private void InitializeBaseConsoleLogger()
                 {
                     if (param.Length <= 0) continue;
 
-                    if (0 == string.Compare(param, "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                     {
                         useMPLogger = true;
                     }
-                    if (0 == string.Compare(param, "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                     {
                         useMPLogger = false;
                     }
-                    if (0 == string.Compare(param, "DISABLECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "DISABLECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
                     {
                         disableConsoleColor = true;
                     }
-                    if (0 == string.Compare(param, "FORCECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "FORCECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
                     {
                         forceConsoleColor = true;
                     }
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 56973a62818..f91527f7fdf 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -131,7 +131,7 @@ private void ParseParameters()
         /// </summary>
         private void ApplyParameter(string parameterName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             if (_forwardingTable.ContainsKey(parameterName))
             {
@@ -141,15 +141,15 @@ private void ApplyParameter(string parameterName)
 
             // If any of the following parameters are set, we will make sure we forward the events
             // necessary for the central logger to emit the requested information
-            if (0 == String.Compare(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showPerfSummary = true;
             }
-            else if (0 == String.Compare(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showSummary = false;
             }
-            else if (0 == String.Compare(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showCommandLine = true;
             }
@@ -160,7 +160,7 @@ private void ApplyParameter(string parameterName)
         /// </summary>
         public virtual void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
 
             ParseParameters();
 
@@ -262,7 +262,6 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
-
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index f488f9eee31..9fcbb94836e 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -70,7 +70,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Compare("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if (string.IsNullOrEmpty(parameterValue))
                 {
@@ -96,7 +96,7 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
         /// </summary>
         public void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             ParseFileLoggerParameters();
             string fileName = _logFile;
             try
@@ -118,10 +118,7 @@ public void Initialize(IEventSource eventSource)
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
-                if (_nodeFileLogger != null)
-                {
-                    _nodeFileLogger.Shutdown();
-                }
+                _nodeFileLogger?.Shutdown();
 
                 string errorCode;
                 string helpKeyword;
@@ -138,10 +135,7 @@ public void Initialize(IEventSource eventSource)
         /// </summary>
         public void Shutdown()
         {
-            if (_nodeFileLogger != null)
-            {
-                _nodeFileLogger.Shutdown();
-            }
+            _nodeFileLogger?.Shutdown();
         }
         #endregion
 
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 704ae2fb3fe..7394b006c0f 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -48,7 +48,7 @@ public FileLogger()
         /// <param name="eventSource">Available events.</param>
         public override void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             eventSource.BuildFinished += FileLoggerBuildFinished;
             InitializeFileLogger(eventSource, 1);
         }
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index eb876400d4e..1bff6ba9ef7 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -123,7 +123,7 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
                 return true;
             }
 
-            if (0 == String.Compare(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
             {
                 if (String.IsNullOrEmpty(parameterValue))
                 {
@@ -144,17 +144,17 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
 
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
             {
                 _showTimeStamp = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
             {
                 _showEventId = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
             {
                 _forceNoAlign = true;
                 _alignMessages = false;
@@ -461,7 +461,7 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
 
                 // If the target where the error occurred is the same as the previous message do not print the location
                 // where the error occurred again
-                if (String.Compare(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!String.Equals(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase))
                 {
                     // If no targetName was specified then do not show the target where the error occurred
                     if (!string.IsNullOrEmpty(valuePair.Key.TargetName))
@@ -576,7 +576,6 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
         {
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
 
-
             // Get the project started event so we can use its information to properly display a project finished event
             ProjectStartedEventMinimumFields startedEvent = _buildEventManager.GetProjectStartedEvent(e.BuildEventContext);
             ErrorUtilities.VerifyThrow(startedEvent != null, "Project finished event for {0} received without matching start event", e.ProjectFile);
@@ -786,7 +785,6 @@ public override void TargetStartedHandler(object sender, TargetStartedEventArgs
             // later in the build
             _buildEventManager.AddTargetStartedEvent(e, _showTimeStamp || IsVerbosityAtLeast(LoggerVerbosity.Detailed));
 
-
             if (this.showPerfSummary)
             {
                 // Create a new performance counter for this target
@@ -1350,7 +1348,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                             // Calculate how many chars will fit on the console buffer
                             int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
                             WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), (prefixAlreadyWritten && index == 0 && i == 0), adjustedPrefixWidth);
-                            index = index + amountToCopy;
+                            index += amountToCopy;
                         }
                     }
                     else
@@ -1389,7 +1387,7 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
             TargetStartedEventMinimumFields targetStartedEvent = _buildEventManager.GetTargetStartedEvent(e);
 
             // Make sure we have not shown the event before
-            if (targetStartedEvent != null && !targetStartedEvent.ShowTargetFinishedEvent)
+            if (targetStartedEvent?.ShowTargetFinishedEvent == false)
             {
                 // Since the target started event has been shows, the target finished event should also be shown
                 targetStartedEvent.ShowTargetFinishedEvent = true;
@@ -1463,7 +1461,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                 ProjectStartedEventMinimumFields projectStartedEvent = _buildEventManager.GetProjectStartedEvent(e);
 
                 // Make sure the project started event has not been show yet
-                if (projectStartedEvent != null && !projectStartedEvent.ShowProjectFinishedEvent)
+                if (projectStartedEvent?.ShowProjectFinishedEvent == false)
                 {
                     projectStartedEvent.ShowProjectFinishedEvent = true;
 
@@ -1486,7 +1484,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         WriteLinePrefix(projectStartedEvent.FullProjectKey, projectStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
                         string message;
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedTopLevelProjectWithDefaultTargets", current, currentProjectNodeId);
                         }
@@ -1502,7 +1500,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(parentStartedEvent.FullProjectKey, parentStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             WriteMessageAligned(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedWithDefaultTargetsMultiProc", previous, parentStartedEvent.FullProjectKey, current, projectStartedEvent.FullProjectKey, currentProjectNodeId), true);
                         }
@@ -1721,7 +1719,7 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                     String.Format(CultureInfo.CurrentCulture, "{0,-40}" /* pad to 40 align left */, scopeName),
                     String.Format(CultureInfo.CurrentCulture, "{0,3}", calls));
 
-                if (_internalPerformanceCounters != null && _internalPerformanceCounters.Count > 0)
+                if (_internalPerformanceCounters?.Count > 0)
                 {
                     // For each of the entry points in the project print out the performance numbers for them
                     foreach (var counter in _internalPerformanceCounters.Values)
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index af005dfbe68..0d8e9fa54aa 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -214,7 +214,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInProject)
+            if (startedEvent?.ErrorInProject == false)
             {
                 _projectStartedEvents.Remove(e);
             }
@@ -227,7 +227,7 @@ internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInTarget)
+            if (startedEvent?.ErrorInTarget == false)
             {
                 _targetStartedEvents.Remove(e);
             }
@@ -601,7 +601,7 @@ public override bool Equals(object obj)
             {
                 return false;
             }
-            return s_eventComparer.Equals(_entryPointContext, key.EntryPointContext) && (String.Compare(_targetName, key.TargetName, StringComparison.OrdinalIgnoreCase) == 0);
+            return s_eventComparer.Equals(_entryPointContext, key.EntryPointContext) && (String.Equals(_targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
         }
 
         public override int GetHashCode()
@@ -648,7 +648,6 @@ internal ProjectFullKey(int projectKey, int entryPointKey)
         /// <summary>
         /// Output the projectKey or the projectKey and the entrypointKey depending on the verbosity level of the logger
         /// </summary>
-
         public string ToString(LoggerVerbosity verbosity)
         {
             string fullProjectKey;
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index db37ae85bf1..5d0ed444b07 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -143,7 +143,6 @@ internal ProfilerResult GetAggregatedResult(bool pruneSmallItems = true)
                 foreach (var pair in profiledResult.ProfiledLocations.OrderBy(p => p.Key.Id))
                 {
                     MergeItem(originalLocations, mergeMap, _aggregatedLocations, pair);
-
                 }
             }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 833fc16645c..5137ecc444a 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -636,7 +636,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
 
                 if (previous == null)
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", current);
                     }
@@ -647,7 +647,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
                 }
                 else
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForNestedProjectWithDefaultTargets", previous, current);
                     }
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
index f5aca34ec3b..0de0274f582 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
@@ -6,7 +6,6 @@
 
 namespace Microsoft.Build.ObjectModelRemoting
 {
-
     /// <summary>
     /// External projects support.
     /// Allow for creating a local representation to external object of type <see cref="ProjectMetadata"/>
@@ -46,6 +45,7 @@ public static object GetParent(ProjectMetadata metadata)
 
         /// <summary>
         /// Helper utility for External projects provider implementation to get access of the EvaluatedValueEscaped
+        /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectMetadata metadata)
         {
             return metadata.EvaluatedValueEscaped;
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
index 377daf47856..ee5c1263f3a 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
@@ -65,10 +65,10 @@ public abstract class ProjectPropertyLink
 
         /// <summary>
         /// Helper utility for External projects provider implementation to get access of the EvaluatedValueEscaped
+        /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectProperty property)
         {
             return property.EvaluatedValueEscapedIntenral;
         }
     }
-
 }
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index d639aa819cd..98ce259b750 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -8,7 +8,6 @@
 
 namespace Microsoft.Build.ObjectModelRemoting
 {
-
     /// <summary>
     /// implemented by MSBuild objects that support remote linking;
     /// </summary>
@@ -76,15 +75,15 @@ public static IReadOnlyCollection<Project> GetLocalProjects(ProjectCollection co
 
         public ProjectItem Create(ProjectItemLink link, Project project = null, ProjectItemElement xml = null)
         {
-            project = project ?? link.Project;
-            xml = xml ?? link.Xml;
+            project ??= link.Project;
+            xml ??= link.Xml;
 
             return new LinkedProjectItem(xml, project, link);
         }
 
         public ProjectItemDefinition Create(ProjectItemDefinitionLink link, Project project = null)
         {
-            project = project ?? link.Project;
+            project ??= link.Project;
 
             return new LinkedProjectItemDefinition(link, project, link.ItemType);
         }
@@ -101,14 +100,14 @@ public Project Create(ProjectLink link)
 
         public ProjectMetadata Create(ProjectMetadataLink link, object parent = null)
         {
-            parent = parent ?? link.Parent;
+            parent ??= link.Parent;
 
             return new LinkedProjectMetadata(parent, link);
         }
 
         public ProjectProperty Create(ProjectPropertyLink link, Project project = null )
         {
-            project = project ?? link.Project;
+            project ??= link.Project;
 
             return new LinkedProjectProperty(project, link);
         }
@@ -270,7 +269,6 @@ internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
 
             internal override ProjectMetadataLink Link { get; }
             object ILinkableObject.Link => Link;
-
         }
 
         private class LinkedProjectProperty : ProjectProperty, ILinkableObject
@@ -315,5 +313,4 @@ public override string UnevaluatedValue
         #endregion
     }
 
-
 }
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 35030eefbac..b3c15748810 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -42,7 +42,6 @@ public EngineFileUtilities(FileMatcher fileMatcher)
             _fileMatcher = fileMatcher;
         }
 
-
         /// <summary>
         /// Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
         /// ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
@@ -143,7 +142,7 @@ private string[] GetFileList
             IEnumerable<string> excludeSpecsEscaped = null
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, "filespecEscaped");
+            ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
             if (excludeSpecsEscaped == null)
             {
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 106a9360ec7..3bb52fd3d73 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -26,7 +26,7 @@ internal class NuGetFrameworkWrapper
 
         public NuGetFrameworkWrapper()
         {
-            /// Resolve the location of the NuGet.Frameworks assembly
+            // Resolve the location of the NuGet.Frameworks assembly
             var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
                 Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index a410a39471f..adf171e6307 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -67,8 +67,8 @@ internal RegistryKeyWrapper(string registryKeyPath, RegistryHive registryHive, R
         /// </summary>
         internal RegistryKeyWrapper(string registryKeyPath, RegistryKey registryHive)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, "registryKeyPath");
-            ErrorUtilities.VerifyThrowArgumentNull(registryHive, "registryHive");
+            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, nameof(registryKeyPath));
+            ErrorUtilities.VerifyThrowArgumentNull(registryHive, nameof(registryHive));
 
             _registryKeyPath = registryKeyPath;
             _registryHive = registryHive;
@@ -173,7 +173,7 @@ public virtual string[] GetSubKeyNames()
         /// <returns></returns>
         public virtual RegistryKeyWrapper OpenSubKey(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             RegistryKeyWrapper wrapper = this;
             string[] keyNames = name.Split(MSBuildConstants.BackslashChar, StringSplitOptions.RemoveEmptyEntries);
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index c0534a9a64b..e277165f314 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Utilities
     /// Unlike System.Version, does not tolerate whitespace, and '+' is ignored as
     /// semver metadata as described above, not tolerated as positive sign of integer
     /// component.
-    /// <summary>
+    /// </summary>
     /// <remarks>
     /// Tolerating leading 'v' allows using $(TargetFrameworkVersion) directly.
     ///
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index a0681677b05..6c1657d1e9d 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -254,7 +254,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the start of a comment
                         insideComment = true;
-                        i = i + 3;
+                        i += 3;
                         continue;
                     }
                 }
@@ -278,7 +278,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the end of a comment
                         insideComment = false;
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index 8a54c20ef6a..3c1528a3064 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -163,7 +163,7 @@ internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLoca
         }
 
         /// <summary>
-        /// Sets the value of an attribute, removing the attribute if the value is null, but still setting it 
+        /// Sets the value of an attribute, removing the attribute if the value is null, but still setting it
         /// if the value is the empty string. Returns the attribute, or null if it was removed.
         /// UNDONE: Make this return a bool if the attribute did not change, so we can avoid dirtying.
         /// </summary>
@@ -185,7 +185,7 @@ internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLoca
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is null, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlAttributeWithLocation attribute, bool returnNullForNonexistentAttributes)
@@ -201,7 +201,7 @@ internal static string GetAttributeValue(XmlAttributeWithLocation attribute, boo
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is not present, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName)
@@ -210,8 +210,8 @@ internal static string GetAttributeValue(XmlElementWithLocation element, string
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
-        /// If the attribute is not present, returns either null or an empty string, depending on the value 
+        /// Returns the value of the attribute.
+        /// If the attribute is not present, returns either null or an empty string, depending on the value
         /// of nullIfNotExists.
         /// </summary>
         internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName, bool nullIfNotExists)
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 77ec4045b3c..9a6b8a3898a 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -19,6 +19,7 @@ internal class XmlReaderExtension : IDisposable
         ///     Creates an XmlReaderExtension with handle to an XmlReader.
         /// </summary>
         /// <param name="filePath">Path to the file on disk.</param>
+        /// <param name="loadAsReadOnly">Whther to load the file in real only mode.</param>
         /// <returns>Disposable XmlReaderExtension object.</returns>
         internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly)
         {
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index b99929a450e..3bcc7bd9bf8 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -31,7 +31,7 @@ internal enum SwitchesToMigrate
     internal enum SwitchValueType
     {
         /// <summary>
-        /// Boolean value 
+        /// Boolean value
         /// </summary>
         SVT_Boolean,
 
@@ -41,7 +41,7 @@ internal enum SwitchValueType
         SVT_String,
 
         /// <summary>
-        /// This switch can occur multiple times and the 
+        /// This switch can occur multiple times and the
         /// final value is the ';' delimeted concat of all the
         /// individual occurrences
         /// </summary>
@@ -50,7 +50,7 @@ internal enum SwitchValueType
 
     /// <summary>
     /// This class contains the migration info for a switch
-    /// that we want to migrate 
+    /// that we want to migrate
     /// </summary>
     internal sealed class CompSwitchInfo
     {
@@ -85,7 +85,7 @@ internal sealed class CompSwitchInfo
         internal object SwitchValue;
 
         /// <summary>
-        /// This is the the name of property in the project file in which the
+        /// This is the name of property in the project file in which the
         /// value of this switch is stored
         /// </summary>
         internal string SwitchProjectPropertyName;
@@ -110,32 +110,32 @@ string switchProjectPropertyName
     }
 
     /// <summary>
-    /// 
+    ///
     /// Class:       AdditionalOptionsParser
     /// Owner:       ParthaD
-    /// 
-    /// This class contains the logic to parse the AdditionalOptions project 
+    ///
+    /// This class contains the logic to parse the AdditionalOptions project
     /// property of v7.x J# projects and add the individual options as project
     /// properties of the upgraded projects.
-    /// 
+    ///
     /// AdditionalOptions project property in v7.x was basically a string that
     /// was passed ditto to the compiler.
     /// It was used to hold J# compiler options that didnt have an 1-1 equivalent
     /// project property.
     /// For v8.0 and beyond, each J# compiler option has a corresponding project
     /// property.
-    /// 
+    ///
     /// AdditionalOptions property string is broken down into list of options.
     /// White space (only ' ' and '\t') are considered as delimiters if not wrapped
-    /// inside double quotes ("). 
+    /// inside double quotes (").
     /// NOTE:
     ///  1. Other unicode spaces or double quotes sequences not considered
-    ///  2. Backslash (\) not considered as possible escape char for ". 
-    /// 
+    ///  2. Backslash (\) not considered as possible escape char for ".
+    ///
     /// Once broken down into individual options, only a few compiler options are
     /// seached for (viz. the options for which v8.0 has new project properties)
     /// Everything else is ignored.
-    /// 
+    ///
     /// Refer to SwitchesToMigrade enum for the switches that are migrated.
     /// </summary>
     internal sealed class AdditionalOptionsParser
@@ -151,7 +151,7 @@ internal sealed class AdditionalOptionsParser
                 null,
                 "CodePage"
             ),
-            
+
             // /x:[all | net]
             new CompSwitchInfo(
                 SwitchesToMigrate.STM_DisableLangExtensions,
@@ -187,7 +187,7 @@ internal sealed class AdditionalOptionsParser
                 null,
                 "SecureScoping"
             ),
-            
+
             // /win32res:<file>
             new CompSwitchInfo(
                 SwitchesToMigrate.STM_Win32Resource,
@@ -216,7 +216,7 @@ ProjectPropertyGroupElement configPropertyGroup
             // Tokenize the additional options first
             string[] compSwitchList;
             compSwitchList = TokenizeAdditionalOptionsValue(additionalOptionsValue);
-            
+
             // Extract the switch arguments
             foreach (string compSwitch in compSwitchList)
             {
@@ -228,11 +228,11 @@ ProjectPropertyGroupElement configPropertyGroup
                     }
                 }
             }
-            
+
             // Finally populate the project file and we'r done!
             PopulatePropertyGroup(configPropertyGroup);
         }
-        
+
         /// <summary>
         /// This will tokenize the given string using ' ' and '\t' as delimiters
         /// The delimiters are escaped inside a pair of quotes
@@ -241,7 +241,7 @@ ProjectPropertyGroupElement configPropertyGroup
         private string[] TokenizeAdditionalOptionsValue(string additionalOptionsValue)
         {
             ArrayList tokens = new ArrayList();
-            
+
             bool inQuotes = false;
             StringBuilder option = new StringBuilder();
             foreach (char c in additionalOptionsValue)
@@ -353,7 +353,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
 
                 case SwitchValueType.SVT_MultiString:
                     Debug.Assert(
-                        null != compSwitchInfo.SwitchValue, 
+                        null != compSwitchInfo.SwitchValue,
                         "Non null switch value expected for a multistring switch: " + matchedID
                     );
 
@@ -402,7 +402,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                         if (null != compSwitchInfo.SwitchValue)
                         {
                             configPropertyGroup.AddProperty(
-                                propertyName, 
+                                propertyName,
                                 compSwitchInfo.SwitchValue.ToString().ToLower(CultureInfo.InvariantCulture)
                             );
                         }
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index 83265f55cdd..af98c8f06b8 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -7,6 +7,7 @@
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains logic for converting projects.  NOTE: This assembly is deprecated.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
+    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
   </PropertyGroup>
   <ItemGroup>
     <!-- Source Files -->
diff --git a/src/Deprecated/Conversion/OldVSProjectFileReader.cs b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
index b720fe5e527..7ca6b1169e9 100644
--- a/src/Deprecated/Conversion/OldVSProjectFileReader.cs
+++ b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
@@ -143,7 +143,7 @@ int     charactersToRead        // The number of characters to read.
             if ((startIndexIntoBuffer + charactersToRead) > bufferToReadInto.Length)
             {
                 // End-user should never see this message, so it doesn't need to be localized.
-                throw new ArgumentException("Cannot write past end of user's buffer.", "charactersToRead");
+                throw new ArgumentException("Cannot write past end of user's buffer.", nameof(charactersToRead));
             }
 
             int charactersCopied = 0;
@@ -463,7 +463,7 @@ string xmlAttributeText
                         // Case-sensitive comparison to see if the entity name matches any of
                         // the well-known ones that were emitted by the XML writer in the VS.NET
                         // 2002/2003 project system.
-                        if (0 == String.Compare(entityName, entities[i], StringComparison.Ordinal))
+                        if (String.Equals(entityName, entities[i], StringComparison.Ordinal))
                         {
                             foundEntity = true;
                             break;
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index baf3db16561..e6dec668ba2 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -372,9 +372,9 @@ private void DoConvert()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile != null) && (this.oldProjectFile.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.oldProjectFile),
                 "MissingOldProjectFile");
-            error.VerifyThrowArgument((this.newProjectFile != null) && (this.newProjectFile.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.newProjectFile),
                 "MissingNewProjectFile");
 
             ConvertInMemoryToMSBuildProject();
@@ -425,7 +425,7 @@ private void ConvertInMemoryToMSBuildProject()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile != null) && (this.oldProjectFile.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.oldProjectFile),
                 "MissingOldProjectFile");
 
             // Make sure the source project file exists.
@@ -516,7 +516,7 @@ private void ConvertInMemoryToMSBuildProject()
                 // Find matching imports but don't delete whilst enumerating else it will throw an error
                 foreach (ProjectImportElement nextImport in xmakeProject.Imports)
                 {
-                    if (String.Compare(nextImport.Project, @"$(MSBuildBinPath)\Microsoft.WinFX.targets", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(nextImport.Project, @"$(MSBuildBinPath)\Microsoft.WinFX.targets", StringComparison.OrdinalIgnoreCase))
                     {
                         listOfImportsToBeDeleted.Add(nextImport);
                     }
@@ -532,7 +532,6 @@ private void ConvertInMemoryToMSBuildProject()
                         listOfWFImportsToBeDeleted.Add(nextImport);
                         workflowImportsToAdd.Add(nextImport.Project.Replace(workflowOldOrcasTargetsPath, workflowNewTargetsPath));
                     }
-
                 }
 
                 // Now delete any matching imports
@@ -564,7 +563,6 @@ private void ConvertInMemoryToMSBuildProject()
                     changedProject = true;
                 }
 
-
                 // Re-add the workflow imports with the v4.0 targets.
                 foreach (string workflowImportToAdd in workflowImportsToAdd)
                 {
@@ -585,7 +583,7 @@ private void ConvertInMemoryToMSBuildProject()
                 {
                     if ((!nextItem.ItemType.Equals("Reference", StringComparison.OrdinalIgnoreCase)) &&
                         (nextItem.Include.Trim().EndsWith(".xaml", StringComparison.OrdinalIgnoreCase)))
-                        
+
                     {
                         if (!nextItem.Metadata.Any(m => String.Equals(m.Name, "Generator", StringComparison.OrdinalIgnoreCase)))
                         {
@@ -634,15 +632,15 @@ private void ConvertInMemoryToMSBuildProject()
 
                 // Fix up TargetFrameworkSubset
                 changedProject = FixTargetFrameworkSubset() || changedProject;
-                
+
                 var hasFSharpSpecificConversions = FSharpSpecificConversions(true);
-                
+
                 changedProject = hasFSharpSpecificConversions || changedProject;
                 changedProject = VBSpecificConversions() || changedProject;
 
                 // Do asset compat repair for any project that was previously a TV < 12.0
                 if (
-                        String.IsNullOrEmpty(oldToolsVersion) || 
+                        String.IsNullOrEmpty(oldToolsVersion) ||
                         String.Equals(oldToolsVersion, "3.5", StringComparison.OrdinalIgnoreCase) ||
                         String.Equals(oldToolsVersion, "4.0", StringComparison.OrdinalIgnoreCase)
                     )
@@ -710,7 +708,7 @@ private bool DoRepairForAssetCompat()
             var toRepairImports = RequiresRepairForAssetCompat();
 
             if (toRepairImports == null || toRepairImports.Count() == 0)
-            { 
+            {
                 // no need to repair
                 return false;
             }
@@ -719,7 +717,7 @@ private bool DoRepairForAssetCompat()
             {
                 RepairImportForAssetCompat(toRepairImport);
             }
-            
+
             //
             // Add PropertyGroup with Conditions right before where the Imports occur
             //   <PropertyGroup>
@@ -754,7 +752,7 @@ private bool DoRepairForAssetCompat()
 
         /// <summary>
         /// Repairs the given import element
-        /// Change Import to use $(VSToolsPath), with Condition using $(VSToolsPath) 
+        /// Change Import to use $(VSToolsPath), with Condition using $(VSToolsPath)
         /// e.g. From: Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets"
         ///        To: Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets" Condition="false"
         ///            Import Project="$(VSToolsPath)\WebApplications\Microsoft.WebApplication.targets"
@@ -764,7 +762,7 @@ private bool DoRepairForAssetCompat()
         private void RepairImportForAssetCompat(ProjectImportElement toRepairImport)
         {
             // We shouldn't have this happen but check anyway:
-            ErrorUtilities.VerifyThrowInternalNull(toRepairImport, "toRepairImport");
+            ErrorUtilities.VerifyThrowInternalNull(toRepairImport, nameof(toRepairImport));
             ErrorUtilities.VerifyThrow(!toRepairImport.Condition.Equals("false", StringComparison.OrdinalIgnoreCase), "RepairImportForAssetCompat should not receive imports with condition=false already");
 
             var newImportElement = this.xmakeProject.CreateImportElement(toRepairImport.Project);
@@ -816,14 +814,13 @@ private string ExtractImportTargetsString(string importProjectValue)
         /// </summary>
         /// <returns>bool</returns>
         private IEnumerable<ProjectImportElement> RequiresRepairForAssetCompat()
-        { 
+        {
             // check if the project has the to-repair pattern in the Imports
             // pattern: $(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\
             var toRepairImports =  from import in xmakeProject.Imports
                                    where HasRepairPattern(import)
                                    select import;
 
-            
             return toRepairImports;
         }
 
@@ -896,7 +893,7 @@ private bool FixTargetFrameworkSubset()
                         parentGroup.SetProperty(XMakeProjectStrings.TargetFrameworkProfile, XMakeProjectStrings.ClientProfile);
                         changedProject = true;
                     }
-            
+
                     // In all cases, <TargetFrameworkSubset/> is no longer supported.  If it comes from the project
                     // that we're converting, then we forcibly remove it.  If it comes from some import... the user is
                     // on their own.  
@@ -915,13 +912,13 @@ private bool FixTargetFrameworkSubset()
 
         /// <summary>
         /// Performs conversions specific to F# projects (VS2008 CTP -> VS2012) and (VS2010 -> VS2012).
-        /// This involves: changing the location of FSharp targets, 
+        /// This involves: changing the location of FSharp targets,
         /// and for 2008CTP, adding explicit mscorlib and FSharp.Core references.
         /// </summary>
         /// <param name="actuallyMakeChanges">if true, make the changes, otherwise, don't actually make any changes, but do report the return boolean as to whether you would make changes</param>
         /// <returns>true if anything was (would be) changed, false otherwise</returns>
         public bool FSharpSpecificConversions(bool actuallyMakeChanges)
-        {           
+        {
             // For FSharp projects, should import different location of FSharp targets
             const string fsharpFS10TargetsPath = @"$(MSBuildExtensionsPath)\FSharp\1.0\Microsoft.FSharp.Targets";
             const string fsharpFS10TargetsPath32 = @"$(MSBuildExtensionsPath32)\FSharp\1.0\Microsoft.FSharp.Targets";
@@ -945,7 +942,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             ProjectImportElement fsharpTargetsDev12PlusImport = null;
             ProjectImportElement fsharpTargetsDev11PortableImport = null;
 
-            if (actuallyMakeChanges == false && this.xmakeProject == null)
+            if (!actuallyMakeChanges && this.xmakeProject == null)
             {
                 // when coming down the actuallyMakeChanges==false code path (from the F# project system's UpgradeProject_CheckOnly method), we may not have loaded the Xml yet, so do that now
                 this.xmakeProject = ProjectRootElement.Open(oldProjectFile);
@@ -953,10 +950,10 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
 
             // local function: string equality check using OrdinalIgnoreCase comparison
             Func<string, string, bool> equals = (s1, s2) => String.Equals(s1, s2, StringComparison.OrdinalIgnoreCase);
-            
+
             // local function: wraps specified string value into Exists('value')
             Func<string, string> exists = s => string.Format(CultureInfo.InvariantCulture, "Exists('{0}')", s);
-            
+
             // local function: 
             // Creates property group element containing one property fsharpDev12PlusProperty with value 'path'. 
             // If addCondition is true, property group will have Exists(path) condition
@@ -967,7 +964,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                     parent.AppendChild(propGroup);
                     var prop = xmakeProject.CreatePropertyElement(fsharpDev12PlusProperty);
                     prop.Value = path;
-                    propGroup.AppendChild(prop);                    
+                    propGroup.AppendChild(prop);
                 };
 
             foreach (ProjectImportElement importElement in xmakeProject.Imports)
@@ -1014,11 +1011,11 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 return false;
 
             if (!actuallyMakeChanges)
-                return true;            
+                return true;
 
             // both branches adds this elements to the project
             var chooseElement = xmakeProject.CreateChooseElement(); // (1)
-            
+
             if (fsharpTargetsDev11PortableImport != null)
             {
                 // Dev11 portable library
@@ -1041,7 +1038,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 // portable libraries are supported since Dev11
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'"); // (2)
                 chooseElement.AppendChild(whenVsVersionIsDev11);
-                
+
                 appendPropertyGroupForDev12PlusTargetsPath(fsharpPortableDev11TargetsPath, whenVsVersionIsDev11);
 
                 var otherwiseIfVsVersionIsDev12Plus = xmakeProject.CreateOtherwiseElement(); // (3)
@@ -1072,7 +1069,6 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 //</Choose>
                 //<Import Project="$(FSharpTargetsPath)" Condition="Exists('$(FSharpTargetsPath)')" />           
 
-
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'");
                 chooseElement.AppendChild(whenVsVersionIsDev11);
                 {
@@ -1132,7 +1128,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 {
                     referencesItemGroup.AddItem(ReferenceItemType, "mscorlib");
                 }
-            }            
+            }
 
             // try to find reference to FSharp.Core 
             ProjectItemElement fsharpCoreItem = null;
@@ -1190,15 +1186,11 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 }
             }
 
-            if (newFSharpCoreItem != null)
-            {
-                newFSharpCoreItem.AddMetadata("Private", "True");
-            }
+            newFSharpCoreItem?.AddMetadata("Private", "True");
 
-            
             const string MinimumVisualStudioVersionProperty = "MinimumVisualStudioVersion";
             var hasMinimumVSVersion = xmakeProject.Properties.Any(prop => prop.Name == MinimumVisualStudioVersionProperty);
-            
+
             foreach(var group in xmakeProject.PropertyGroups)
             {
                 // find first non-conditional property group to add TargetFSharpCoreVersion property
@@ -1225,7 +1217,6 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 fsharpCoreItem.Parent.RemoveChild(fsharpCoreItem);
             }
 
-
             return true;
         }
 
@@ -1433,8 +1424,7 @@ XmlElementWithLocation      visualStudioProjectElement
             )
         {
             // Make sure this is the <VisualStudioProject> element.
-            error.VerifyThrow((visualStudioProjectElement != null) &&
-                (visualStudioProjectElement.Name == VSProjectElements.visualStudioProject),
+            error.VerifyThrow((visualStudioProjectElement?.Name == VSProjectElements.visualStudioProject),
                 "Expected <VisualStudioProject> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -1444,7 +1434,7 @@ XmlElementWithLocation      visualStudioProjectElement
             // to convert a VC++ or some other type of project, and give a more friendly
             // error message.
             string projectType = visualStudioProjectElement.GetAttribute(VSProjectAttributes.projectType);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((projectType == null) || (projectType.Length == 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(string.IsNullOrEmpty(projectType),
                 visualStudioProjectElement.Location, "ProjectTypeCannotBeConverted", projectType);
 
             // Make sure the <VisualStudioProject> tag doesn't have any attributes.
@@ -1518,13 +1508,13 @@ XmlElementWithLocation      languageElement
             // Get the project instance GUID for this project file.  It is required for
             // the main project file, but not for the .USER file.
             this.projectGuid = languageElement.GetAttribute(VSProjectAttributes.projectGuid);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((this.projectGuid != null) || (this.isUserFile == true),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((this.projectGuid != null) || (this.isUserFile),
                 languageElement.Location, "MissingAttribute", languageElement.Name, VSProjectAttributes.projectGuid);
 
             // Get the project type for this project file.  We only support "Local".  We do not
             // convert web projects -- that's Venus's job.
             string projectType = languageElement.GetAttribute(VSProjectAttributes.projectType);
-            ProjectErrorUtilities.VerifyThrowInvalidProject(projectType == null || projectType.Length == 0 ||
+            ProjectErrorUtilities.VerifyThrowInvalidProject(string.IsNullOrEmpty(projectType) ||
                 (String.Compare(projectType, VSProjectAttributes.local, StringComparison.OrdinalIgnoreCase) == 0),
                 languageElement.Location, "ProjectTypeCannotBeConverted", projectType);
 
@@ -1563,7 +1553,7 @@ XmlElementWithLocation      languageElement
             // -----------------------------------------------------------------------
 
             string originalMyType = languageElement.GetAttribute(XMakeProjectStrings.myType);
-            if ((originalMyType != null) && (originalMyType.Length != 0))
+            if (!string.IsNullOrEmpty(originalMyType))
             {
                 // Flag the fact that the Everett project already had a MyType property in there,
                 // so we don't try to override it later.
@@ -1630,7 +1620,6 @@ XmlElementWithLocation      languageElement
                 }
             }
 
-
             // Loop through all the direct child elements of the language element.
             foreach(XmlNode languageChildNode in languageElement)
             {
@@ -1717,9 +1706,9 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                     !isTriumphProject        // Doesn't apply to Triumph->Trinity conversions.
                 )
                 {
-                    if (this.outputType != null && this.outputType.Length > 0)
+                    if (!string.IsNullOrEmpty(this.outputType))
                     {
-                        if (String.Compare(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase))
                         {
                             if (this.hasWindowsFormsReference)
                             {
@@ -1731,11 +1720,11 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                                 this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.console);
                             }
                         }
-                        else if (String.Compare(this.outputType, XMakeProjectStrings.exe, StringComparison.OrdinalIgnoreCase) == 0)
+                        else if (String.Equals(this.outputType, XMakeProjectStrings.exe, StringComparison.OrdinalIgnoreCase))
                         {
                             this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.console);
                         }
-                        else if (String.Compare(this.outputType, XMakeProjectStrings.library, StringComparison.OrdinalIgnoreCase) == 0)
+                        else if (String.Equals(this.outputType, XMakeProjectStrings.library, StringComparison.OrdinalIgnoreCase))
                         {
                             this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.windows);
                         }
@@ -1825,8 +1814,7 @@ XmlElementWithLocation      buildElement
             )
         {
             // Make sure this is the <Build> element.
-            error.VerifyThrow((buildElement != null) &&
-                (buildElement.Name == VSProjectElements.build), "Expected <Build> element.");
+            error.VerifyThrow((buildElement?.Name == VSProjectElements.build), "Expected <Build> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
             error.VerifyThrow(xmakeProject != null, "Expected valid XMake project object.");
@@ -1893,8 +1881,7 @@ XmlElementWithLocation      settingsElement
             )
         {
             // Make sure this is the <Settings> element.
-            error.VerifyThrow((settingsElement != null) &&
-                (settingsElement.Name == VSProjectElements.settings),
+            error.VerifyThrow((settingsElement?.Name == VSProjectElements.settings),
                 "Expected <Settings> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2019,8 +2006,7 @@ XmlElementWithLocation      configElement
             )
         {
             // Make sure this is the <Config> element.
-            error.VerifyThrow((configElement != null) &&
-                (configElement.Name == VSProjectElements.config),
+            error.VerifyThrow((configElement?.Name == VSProjectElements.config),
                 "Expected <Config> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2077,7 +2063,7 @@ XmlElementWithLocation      configElement
 
             // Get the "Name" attribute of the <Config> element.
             string configName = configElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((configName != null) && (configName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(configName),
                 configElement.Location, "MissingAttribute", VSProjectElements.config, VSProjectAttributes.name);
 
             // In the case of VSD projects, the "Name" attribute will have a pipe in it,
@@ -2115,7 +2101,7 @@ XmlElementWithLocation      configElement
 
             // Process OutputPath attribute separately to ensure it contains trailing backslash
             string outputPath = configElement.GetAttribute(VSProjectAttributes.outputPath);
-            if (outputPath != null && outputPath.Length > 0)
+            if (!string.IsNullOrEmpty(outputPath))
             {
                 if (outputPath[outputPath.Length-1] != Path.DirectorySeparatorChar)
                     outputPath += Path.DirectorySeparatorChar;
@@ -2127,20 +2113,20 @@ XmlElementWithLocation      configElement
             // If the "SelectedDevice" or "DeploymentPlatform" attributes exist in the per-user
             //   project file, we should get rid of them.
             string selectedDevice = configElement.GetAttribute ( VSProjectAttributes.selectedDevice );
-            if ( isUserFile && ( selectedDevice != null ) && ( selectedDevice.Length > 0 ) )
+            if (isUserFile && (selectedDevice?.Length > 0))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.selectedDevice );
             }
 
             string deploymentPlatform = configElement.GetAttribute ( VSProjectAttributes.deploymentPlatform );
-            if ( isUserFile && ( deploymentPlatform != null ) && ( deploymentPlatform.Length > 0 ) )
+            if (isUserFile && (deploymentPlatform?.Length > 0))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.deploymentPlatform );
             }
 
             // Get rid of the "IncrementalBuild" attribute
             string incrementalBuild = configElement.GetAttribute ( VSProjectAttributes.incrementalBuild );
-            if (incrementalBuild != null && incrementalBuild.Length > 0)
+            if (!string.IsNullOrEmpty(incrementalBuild))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.incrementalBuild );
             }
@@ -2185,11 +2171,11 @@ XmlElementWithLocation      configElement
                 if (String.IsNullOrEmpty(debugType))
                 {
                     string debugSymbols = configElement.GetAttribute(XMakeProjectStrings.debugSymbols);
-                    if (  0 == String.Compare ( debugSymbols, "true", StringComparison.OrdinalIgnoreCase ) )
+                    if (  String.Equals ( debugSymbols, "true", StringComparison.OrdinalIgnoreCase ) )
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeFull);
                     }
-                    else if ( 0 == String.Compare(debugSymbols, "false", StringComparison.OrdinalIgnoreCase) )
+                    else if ( String.Equals(debugSymbols, "false", StringComparison.OrdinalIgnoreCase) )
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeNone);
                     }
@@ -2261,8 +2247,7 @@ XmlElementWithLocation      platformElement
             if ( !IsUserFile )
             {
                 // Make sure this is the <Platform> element.
-                error.VerifyThrow((platformElement != null) &&
-                    (platformElement.Name == VSProjectElements.platform),
+                error.VerifyThrow((platformElement?.Name == VSProjectElements.platform),
                     "Expected <Platform> element.");
 
                 // Make sure the caller has given us a valid xmakeProject object.
@@ -2285,7 +2270,7 @@ XmlElementWithLocation      platformElement
 
                 // Get the "Name" attribute of the <Platform> element.
                 platformForVSD = platformElement.GetAttribute(VSProjectAttributes.name);
-                ProjectErrorUtilities.VerifyThrowInvalidProject((platformForVSD != null) && (platformForVSD.Length > 0),
+                ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(platformForVSD),
                     platformElement.Location, "MissingAttribute", VSProjectElements.platform, VSProjectAttributes.name);
 
                 // Create a new property group, and add all of the XML attributes as XMake
@@ -2354,8 +2339,7 @@ ProjectPropertyGroupElement configPropertyGroup
             )
         {
             // Make sure this is the <InteropRegistration> element.
-            error.VerifyThrow((interopRegistrationElement != null) &&
-                (interopRegistrationElement.Name == VSProjectElements.interopRegistration),
+            error.VerifyThrow((interopRegistrationElement?.Name == VSProjectElements.interopRegistration),
                 "Expected <InteropRegistration> element.");
 
             // Make sure we've been given a valid configuration property group.
@@ -2411,8 +2395,7 @@ XmlElementWithLocation      referencesElement
             )
         {
             // Make sure this is the <References> element.
-            error.VerifyThrow((referencesElement != null) &&
-                (referencesElement.Name == VSProjectElements.references),
+            error.VerifyThrow((referencesElement?.Name == VSProjectElements.references),
                 "Expected <References> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2496,8 +2479,7 @@ ProjectItemGroupElement referencesItemGroup
             )
         {
             // Make sure this is the <Reference> element.
-            error.VerifyThrow((referenceElement != null) &&
-                (referenceElement.Name == VSProjectElements.reference),
+            error.VerifyThrow((referenceElement?.Name == VSProjectElements.reference),
                 "Expected <Reference> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -2509,7 +2491,7 @@ ProjectItemGroupElement referencesItemGroup
             //   "-Designer", we need to disregard this reference entirely.
 
             string platform = referenceElement.GetAttribute(VSProjectAttributes.platform);
-            if ((platform != null) && (platform.Length > 0))
+            if (!string.IsNullOrEmpty(platform))
             {
                 if (platform.IndexOf("-Designer", 0, platform.Length, StringComparison.Ordinal) != -1)
                 {
@@ -2524,7 +2506,7 @@ ProjectItemGroupElement referencesItemGroup
             // Get the "Name" attribute.  This is a required attribute in the VS7/
             // Everett format.
             string referenceName = referenceElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((referenceName != null) && (referenceName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(referenceName),
                 referenceElement.Location, "MissingAttribute", VSProjectAttributes.name, VSProjectElements.reference);
 
             // Before we go any further, we must special-case some assemblies for VSD projects.
@@ -2533,14 +2515,14 @@ ProjectItemGroupElement referencesItemGroup
                    ( this.language == VSProjectElements.EVisualBasic ) ) )
             {
                 if ( ( this.frameworkVersionForVSD == XMakeProjectStrings.vTwo ) &&
-                     ( 0 == String.Compare ( referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase ) ) )
+                     ( String.Equals ( referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase ) ) )
                 {
                     // We need to remove all references to "System.Data.Common" for VSD projects only.
                     //   Note : We only want to do this for projects that will be updated to v2.0
                     //          System.Data.Common is still valid for v1.0 upgraded projects.
                     return;
                 }
-                else if ( 0 == String.Compare ( referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase ) )
+                else if ( String.Equals ( referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase ) )
                 {
                     // We always want to remove all references to "System.SR"
                     return;
@@ -2548,7 +2530,7 @@ ProjectItemGroupElement referencesItemGroup
             }
 
             if ( ( this.language == VSProjectElements.EVisualBasic ) &&
-                 ( 0 == String.Compare ( referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase ) ) )
+                 ( String.Equals ( referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase ) ) )
             {
                 // We also want to get rid of all 'mscorlib' references for VB projects only.
                 return;
@@ -2566,12 +2548,12 @@ ProjectItemGroupElement referencesItemGroup
             // reference.
             string referencedProjectGuid = referenceElement.GetAttribute(VSProjectAttributes.project);
 
-            if ((comReferenceGuid != null) && (comReferenceGuid.Length > 0) &&
+            if (!string.IsNullOrEmpty(comReferenceGuid) &&
                 (comReferenceGuid != "{00000000-0000-0000-0000-000000000000}"))
             {
                 newReferenceItem = ConvertClassicComReference(referenceElement, referencesItemGroup, referenceName);
             }
-            else if ((referencedProjectGuid != null) && (referencedProjectGuid.Length > 0))
+            else if (!string.IsNullOrEmpty(referencedProjectGuid))
             {
                 newReferenceItem = ConvertProjectToProjectReference(referenceElement, referencesItemGroup, referenceName, ref referencedProjectGuid);
             }
@@ -2688,13 +2670,13 @@ private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocati
             {
                 // For VSD Projects, we want to transform all Everett ( .csdproj & .vbdproj ) project 2 project references into
                 // Whidbey ( .csproj & .vbproj ) references.
-                if (0 == String.Compare(Path.GetExtension(pathToReferencedProject),
+                if (String.Equals(Path.GetExtension(pathToReferencedProject),
                                         XMakeProjectStrings.csdprojFileExtension,
                                         StringComparison.OrdinalIgnoreCase))
                 {
                     pathToReferencedProject = Path.ChangeExtension(pathToReferencedProject, XMakeProjectStrings.csprojFileExtension);
                 }
-                else if (0 == String.Compare(Path.GetExtension(pathToReferencedProject),
+                else if (String.Equals(Path.GetExtension(pathToReferencedProject),
                                              XMakeProjectStrings.vbdprojFileExtension,
                                              StringComparison.OrdinalIgnoreCase))
                 {
@@ -2745,7 +2727,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
             // Get the "AssemblyName" attribute.  If not found, just use the value from the
             // "Name" attribute.  This is what the project loading code does in VS.
             string assemblyName = referenceElement.GetAttribute(VSProjectAttributes.assemblyName);
-            if ((assemblyName == null) || (assemblyName.Length == 0))
+            if (string.IsNullOrEmpty(assemblyName))
             {
                 assemblyName = referenceName;
             }
@@ -2758,7 +2740,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
 
             // MyType should only be added when System.Windows.Forms is present. If this
             // reference is seen, then set a flag so we can later add MyType.
-            if (0 == String.Compare("System.Windows.Forms", assemblyName, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals("System.Windows.Forms", assemblyName, StringComparison.OrdinalIgnoreCase))
             {
                 hasWindowsFormsReference = true;
             }
@@ -2808,7 +2790,7 @@ private void SearchForSolutionFile
                 {
                     // Check that the extension really is ".SLN", because the above call to
                     // GetFiles will also return files such as blah.SLN1 and bloo.SLN2.
-                    if (0 == String.Compare(".sln", slnFile.Extension, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(".sln", slnFile.Extension, StringComparison.OrdinalIgnoreCase))
                     {
                         // Parse the .SLN file.
                         SolutionFile solutionParser = new SolutionFile();
@@ -2954,8 +2936,7 @@ XmlElementWithLocation      importsElement
             )
         {
             // Make sure this is the <Imports> element.
-            error.VerifyThrow((importsElement != null) &&
-                (importsElement.Name == VSProjectElements.imports),
+            error.VerifyThrow((importsElement?.Name == VSProjectElements.imports),
                 "Expected <Imports> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3004,7 +2985,6 @@ XmlElementWithLocation      importsElement
                 {
                     ProjectXmlUtilities.ThrowProjectInvalidChildElement(importsChildNode.Name, importsElement.Name, importsElement.Location);
                 }
-
             }
         }
 
@@ -3020,8 +3000,7 @@ ProjectItemGroupElement importsItemGroup
             )
         {
             // Make sure this is the <Import> element.
-            error.VerifyThrow((importElement != null) &&
-                (importElement.Name == VSProjectElements.import),
+            error.VerifyThrow((importElement?.Name == VSProjectElements.import),
                 "Expected <Import> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3030,7 +3009,7 @@ ProjectItemGroupElement importsItemGroup
 
             // Get the required "Namespace" attribute.
             string importNamespace = importElement.GetAttribute(VSProjectAttributes.importNamespace);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((importNamespace != null) && (importNamespace.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(importNamespace),
                 importElement.Location, "MissingAttribute", VSProjectAttributes.importNamespace, VSProjectElements.import);
             // Remove the "Namespace" attribute, so it doesn't show up in our loop later.
             importElement.RemoveAttribute(VSProjectAttributes.importNamespace);
@@ -3073,8 +3052,7 @@ XmlElementWithLocation      filesElement
             )
         {
             // Make sure this is the <Files> element.
-            error.VerifyThrow((filesElement != null) &&
-                (filesElement.Name == VSProjectElements.files),
+            error.VerifyThrow((filesElement?.Name == VSProjectElements.files),
                 "Expected <Files> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3140,8 +3118,7 @@ XmlElementWithLocation      includeElement
             )
         {
             // Make sure this is the <Include> element.
-            error.VerifyThrow((includeElement != null) &&
-                (includeElement.Name == VSProjectElements.include),
+            error.VerifyThrow((includeElement?.Name == VSProjectElements.include),
                 "Expected <Include> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3210,8 +3187,7 @@ ProjectItemGroupElement filesItemGroup
             )
         {
             // Make sure this is the <File> element.
-            error.VerifyThrow((fileElement != null) &&
-                (fileElement.Name == VSProjectElements.file),
+            error.VerifyThrow((fileElement?.Name == VSProjectElements.file),
                 "Expected <File> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3220,7 +3196,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = fileElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath != null) && (relPath.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(relPath),
                 fileElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.file);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             fileElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3234,7 +3210,7 @@ ProjectItemGroupElement filesItemGroup
             // what the build action is based on the file extension.  This is
             // what the project loading code does in VS.
             string buildAction = fileElement.GetAttribute(VSProjectAttributes.buildAction);
-            if ((buildAction == null) || (buildAction.Length == 0))
+            if (string.IsNullOrEmpty(buildAction))
             {
                 buildAction = VSProjectAttributes.buildActionNone;
             }
@@ -3246,13 +3222,12 @@ ProjectItemGroupElement filesItemGroup
             // Bug Whidbey #248965. If a .resx file is completely empty, do not include a reference
             // to it in the upgraded project file.
             if (!
-                (0 == String.Compare(Path.GetExtension(relPath), ".resx", StringComparison.OrdinalIgnoreCase)
+                (String.Equals(Path.GetExtension(relPath), ".resx", StringComparison.OrdinalIgnoreCase)
                  && IsFilePresentButEmpty(relPath, linkPath))
                )
             {
-
                 // Add the new item to XMake.
-                if ((linkPath == null) || (linkPath.Length == 0))
+                if (string.IsNullOrEmpty(linkPath))
                 {
                     // Normal item.
 
@@ -3318,7 +3293,7 @@ ProjectItemGroupElement filesItemGroup
                 // mark it to copy if newer.
                 if ( ( ( ( this.language == VSProjectElements.ECSharp ) ||
                          ( this.language == VSProjectElements.EVisualBasic ) ) ) &&
-                     ( 0 == String.Compare ( buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase ) ) )
+                     ( String.Equals ( buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase ) ) )
                 {
                     newFileItem.AddMetadata ( XMakeProjectStrings.copytooutput,
                                               XMakeProjectStrings.preservenewest );
@@ -3347,7 +3322,7 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
             // relpath is the filename
             // linkPath, if it exists, is the relative path from the project, or the absolute full path
             string path;
-            if (linkPath == null || linkPath.Length == 0)
+            if (string.IsNullOrEmpty(linkPath))
             {
                 path = Path.Combine(Path.GetDirectoryName(oldProjectFile), relPath);
             }
@@ -3400,8 +3375,7 @@ ProjectItemGroupElement filesItemGroup
             )
         {
             // Make sure this is the <Folder> element.
-            error.VerifyThrow((folderElement != null) &&
-                (folderElement.Name == VSProjectElements.folder),
+            error.VerifyThrow((folderElement?.Name == VSProjectElements.folder),
                 "Expected <Folder> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3410,7 +3384,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = folderElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath != null) && (relPath.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(relPath),
                 folderElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.folder);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             folderElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3432,7 +3406,7 @@ ProjectItemGroupElement filesItemGroup
 
             ProjectItemElement newFolderItem;
 
-            if ((webReferences != null) && (0 == String.Compare(webReferences, "true", StringComparison.OrdinalIgnoreCase)))
+            if ((webReferences != null) && (String.Equals(webReferences, "true", StringComparison.OrdinalIgnoreCase)))
             {
                 // This is a web reference folder.
 
@@ -3454,7 +3428,7 @@ ProjectItemGroupElement filesItemGroup
                 newFolderItem = filesItemGroup.AddItem(XMakeProjectStrings.webReferences,
                     ProjectCollection.Escape(relPath));
             }
-            else if ((webReferenceUrl != null) && (webReferenceUrl.Length > 0))
+            else if (!string.IsNullOrEmpty(webReferenceUrl))
             {
                 // This is an actual web reference URL.
 
@@ -3549,8 +3523,7 @@ XmlElementWithLocation      startupServicesElement
             )
         {
             // Make sure this is the <StartupServices> element.
-            error.VerifyThrow((startupServicesElement != null) &&
-                (startupServicesElement.Name == VSProjectElements.startupServices),
+            error.VerifyThrow((startupServicesElement?.Name == VSProjectElements.startupServices),
                 "Expected <StartupServices> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3614,8 +3587,7 @@ ProjectItemGroupElement startupServicesItemGroup
             )
         {
             // Make sure this is the <Service> element.
-            error.VerifyThrow((serviceElement != null) &&
-                (serviceElement.Name == VSProjectElements.service),
+            error.VerifyThrow((serviceElement?.Name == VSProjectElements.service),
                 "Expected <Service> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3624,7 +3596,7 @@ ProjectItemGroupElement startupServicesItemGroup
 
             // Get the required "ID" attribute.
             string id = serviceElement.GetAttribute(VSProjectAttributes.id);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((id != null) && (id.Length > 0), serviceElement.Location,
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(id), serviceElement.Location,
                 "MissingAttribute", VSProjectAttributes.id, VSProjectElements.service);
             // Remove the "ID" attribute, so it doesn't show up in our loop later.
             serviceElement.RemoveAttribute(VSProjectAttributes.id);
@@ -3667,8 +3639,7 @@ XmlElementWithLocation      otherProjectSettingsElement
             )
         {
             // Make sure this is the <OtherProjectSettings> element.
-            error.VerifyThrow((otherProjectSettingsElement != null) &&
-                (otherProjectSettingsElement.Name == VSProjectElements.otherProjectSettings),
+            error.VerifyThrow((otherProjectSettingsElement?.Name == VSProjectElements.otherProjectSettings),
                 "Expected <Settings> element.");
 
             // Make sure the caller gave us a valid globalPropertyGroup to stuff
@@ -3724,8 +3695,7 @@ out bool                    isTriumphProject
             )
         {
             // Make sure this is the <UserProperties> element.
-            error.VerifyThrow((userPropertiesElement != null) &&
-                (userPropertiesElement.Name == VSProjectElements.userProperties),
+            error.VerifyThrow((userPropertiesElement?.Name == VSProjectElements.userProperties),
                 "Expected <UserProperties> element.");
 
             isTriumphProject = false;
@@ -3823,13 +3793,13 @@ out bool                    isTriumphProject
                 if (officeDocumentPathAttribute != null)
                 {
                     string officeDocumentPath = officeDocumentPathAttribute.Value;
-                    if ((officeDocumentPath != null) && (officeDocumentPath.Length > 0))
+                    if (!string.IsNullOrEmpty(officeDocumentPath))
                     {
                         string projectFileDirectory = Path.GetDirectoryName(Path.GetFullPath(this.oldProjectFile));
                         string officeDocumentFullPath = Path.GetFullPath(Path.Combine(projectFileDirectory, officeDocumentPath));
 
                         // If the office document is in the project directory ...
-                        if (0 == String.Compare(projectFileDirectory, Path.GetDirectoryName(officeDocumentFullPath), StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(projectFileDirectory, Path.GetDirectoryName(officeDocumentFullPath), StringComparison.OrdinalIgnoreCase))
                         {
                             // If the office document actually exists on disk ...
                             if (File.Exists(officeDocumentFullPath))
diff --git a/src/Deprecated/Engine/Choose/Choose.cs b/src/Deprecated/Engine/Choose/Choose.cs
index 7293f8b23cd..b26f269b905 100644
--- a/src/Deprecated/Engine/Choose/Choose.cs
+++ b/src/Deprecated/Engine/Choose/Choose.cs
@@ -237,10 +237,7 @@ ProcessingPass pass
             else
             {
                 ErrorUtilities.VerifyThrow(pass == ProcessingPass.Pass2, "ProcessingPass must be Pass1 or Pass2.");
-                if (whenLastTaken != null)
-                {
-                    whenLastTaken.Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
-                }
+                whenLastTaken?.Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
             }
         }
 
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 16d130649e0..5624527929b 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -9,7 +9,6 @@
 
 using Microsoft.Build.BuildEngine.Shared;
 
-
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.BuildEngine
@@ -65,10 +64,7 @@ internal void ChangePropertyGroupCount(int delta)
             this.propertyGroupCount += delta;
             ErrorUtilities.VerifyThrow(this.propertyGroupCount >= 0, "The property group count should never be negative");
 
-            if (parentGroupingCollection != null)
-            {
-                parentGroupingCollection.ChangePropertyGroupCount(delta);
-            }
+            parentGroupingCollection?.ChangePropertyGroupCount(delta);
         }
 
         /// <summary>
@@ -156,10 +152,7 @@ internal void ChangeItemGroupCount(int delta)
             this.itemGroupCount += delta;
             ErrorUtilities.VerifyThrow(this.itemGroupCount >= 0, "The item group count should never be negative");
 
-            if (parentGroupingCollection != null)
-            {
-                parentGroupingCollection.ChangeItemGroupCount(delta);
-            }
+            parentGroupingCollection?.ChangeItemGroupCount(delta);
         }
 
         /// <summary>
@@ -426,7 +419,6 @@ BuildItemGroup itemGroupToRemove
 
             ChangeItemGroupCount(-1);
             error.VerifyThrow(this.itemGroupCount >= 0, "Too many calls to RemoveItemGroup().");
-
         }
 
         /// <summary>
@@ -570,7 +562,7 @@ internal void RemoveAllPropertyGroupsByCondition(string condition, bool includeI
             ArrayList propertiesToRemove = new ArrayList();
             foreach (BuildPropertyGroup propertyGroup in this.PropertyGroupsAll)
             {
-                if (0 == String.Compare(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
                     && (!propertyGroup.IsImported || includeImportedPropertyGroups))
                 {
                     propertiesToRemove.Add(propertyGroup);
@@ -630,7 +622,7 @@ internal void RemoveAllItemGroupsByCondition(string condition)
 
             foreach (BuildItemGroup itemGroup in this.ItemGroupsAll)
             {
-                if (0 == String.Compare(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
                     && !itemGroup.IsImported)
                 {
                     itemsToRemove.Add(itemGroup);
@@ -660,7 +652,7 @@ internal void RemoveItemsByName(string itemName)
                 // ones that are of the requested item type.
                 foreach (BuildItem item in itemGroup)
                 {
-                    if ((0 == String.Compare(item.Name, itemName, StringComparison.OrdinalIgnoreCase)) &&
+                    if ((String.Equals(item.Name, itemName, StringComparison.OrdinalIgnoreCase)) &&
                             !item.IsImported
                         )
                     {
diff --git a/src/Deprecated/Engine/Choose/When.cs b/src/Deprecated/Engine/Choose/When.cs
index 9f1c919092e..de9263754cc 100644
--- a/src/Deprecated/Engine/Choose/When.cs
+++ b/src/Deprecated/Engine/Choose/When.cs
@@ -83,7 +83,6 @@ int nestingDepth
             }
 
             ProcessWhenChildren(whenElement, parentProject, importedFromAnotherProject, nestingDepth);
-
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
index 7e09548b102..19e9699cb73 100644
--- a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
+++ b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
@@ -11,7 +11,6 @@
 
 namespace Microsoft.Build.BuildEngine
 {
-
     /// <summary>
     /// A hashtable wrapper that defers copying until the data is written.
     /// </summary>
@@ -46,7 +45,7 @@ internal CopyOnWriteHashtable(StringComparer stringComparer)
         /// </summary>
         internal CopyOnWriteHashtable(int capacity, StringComparer stringComparer)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, "stringComparer");
+            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, nameof(stringComparer));
             this.sharedLock = new object();
 
             if (capacity == 0)
@@ -69,8 +68,8 @@ internal CopyOnWriteHashtable(int capacity, StringComparer stringComparer)
         /// <param name="stringComparer">The string comparer to use.</param>
         internal CopyOnWriteHashtable(IDictionary dictionary, StringComparer stringComparer)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(dictionary, "dictionary");
-            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, "stringComparer");
+            ErrorUtilities.VerifyThrowArgumentNull(dictionary, nameof(dictionary));
+            ErrorUtilities.VerifyThrowArgumentNull(stringComparer, nameof(stringComparer));
 
             this.sharedLock = new object();
             CopyOnWriteHashtable source = dictionary as CopyOnWriteHashtable;
@@ -89,7 +88,6 @@ internal CopyOnWriteHashtable(IDictionary dictionary, StringComparer stringCompa
                     // this means a bug in the engine code somewhere.
                     throw new InternalErrorException("Bug: Changing the case-sensitiveness of a copied hash-table.");
                 }
-
             }
 
             // Can't defer this because we don't control what gets written to the dictionary exogenously.
@@ -193,7 +191,6 @@ public Object this[Object key]
                         }
                     }
                 }
-
             }
         }
 #endregion
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 13afc4e393f..4b2922481f4 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -79,7 +79,6 @@ internal WaitHandle QueueEmptyEvent
         /// <returns></returns>
         internal int Count
         {
-
             get
             {
                 // Sum both as the number of items is the sum of items in both queues
@@ -131,10 +130,7 @@ internal void Enqueue(T item)
                     queueReadyEvent.Set();
 
                     // reset queue empty
-                    if (queueEmptyEvent != null)
-                    {
-                        queueEmptyEvent.Reset();
-                    }
+                    queueEmptyEvent?.Reset();
                 }
             }
         }
@@ -162,10 +158,7 @@ internal void EnqueueArray(T[] items)
                     queueReadyEvent.Set();
 
                     // reset queue empty
-                    if (queueEmptyEvent != null)
-                    {
-                        queueEmptyEvent.Reset();
-                    }
+                    queueEmptyEvent?.Reset();
                 }
             }
         }
@@ -183,10 +176,7 @@ internal void Clear()
                 // reset queue ready event because the queue is now empty
                 queueReadyEvent.Reset();
                 // raise queue empty event because the queue is now empty
-                if (queueEmptyEvent != null)
-                {
-                    queueEmptyEvent.Set();
-                }
+                queueEmptyEvent?.Set();
             }
         }
 
@@ -235,10 +225,7 @@ private T GetTopItem(bool dequeue)
                         // signal there are no more items to read
                         queueReadyEvent.Reset();
 
-                        if (queueEmptyEvent != null)
-                        {
-                            queueEmptyEvent.Set();
-                        }
+                        queueEmptyEvent?.Set();
                     }
                 }
             }
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index b56ff6595d0..dfa1b8bba90 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -35,7 +35,7 @@ internal FunctionCallExpressionNode(string functionName, ArrayList arguments)
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluationState state)
         {
-            if (String.Compare(functionName, "exists", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -63,13 +63,12 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
 
                         return false;
                     }
-
                 }
 
                 // Both Exists functions return false if the value is null or empty
                 return File.Exists(expandedValue) || Directory.Exists(expandedValue);
             }
-            else if (String.Compare(functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
diff --git a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
index a02b7ba708e..df182d5140b 100644
--- a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
@@ -72,15 +72,9 @@ internal override string GetUnexpandedValue(ConditionEvaluationState state)
         /// </summary>
         internal override void ResetState()
         {
-            if (leftChild != null)
-            {
-                leftChild.ResetState();
-            }
+            leftChild?.ResetState();
 
-            if (rightChild != null)
-            {
-                rightChild.ResetState();
-            }
+            rightChild?.ResetState();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index 9b1dec56f0c..f42eecf7285 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -125,7 +125,6 @@ private GenericExpressionNode Expr(string expression)
                 node = ExprPrime(expression, node);
             }
 
-
             #region REMOVE_COMPAT_WARNING
             // Check for potential change in behavior
             if (LoggingServices != null && !warnedForExpression &&
@@ -239,7 +238,6 @@ private GenericExpressionNode RelationalExpr(string expression)
             }
         }
 
-
         private OperatorExpressionNode RelationalOperation(string expression)
         {
             OperatorExpressionNode node = null;
@@ -398,6 +396,5 @@ private bool Same(string expression, Token.TokenType token)
             else
                 return false;
         }
-
     }
 }
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index 2c40ffac255..83ae741d5ac 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -148,7 +148,7 @@ internal bool Advance()
             if (errorState)
                 return false;
 
-            if (lookahead != null && lookahead.IsToken(Token.TokenType.EndOfInput))
+            if (lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
                 return true;          
 
             SkipWhiteSpace();
@@ -437,7 +437,6 @@ private bool ParseInternalItemList()
             }
             if (parsePoint >= expression.Length)
             {
-                
                 errorPosition = start + 1;
                 if (fInReplacement)
                 {
@@ -554,11 +553,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction( int start )
         {
             SkipSimpleStringChars();
-            if (0 == string.Compare(expression.Substring(start, parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(expression.Substring(start, parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
             {
                 lookahead = new Token(Token.TokenType.And, expression.Substring(start, parsePoint - start));
             }
-            else if (0 == string.Compare(expression.Substring(start, parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(expression.Substring(start, parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
             {
                 lookahead = new Token(Token.TokenType.Or, expression.Substring(start, parsePoint - start));
             }
diff --git a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
index a66656634ac..14542e15990 100644
--- a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
@@ -83,5 +83,4 @@ internal override void ResetState()
             cachedExpandedValue = null;
         }
     }
-
 }
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index 62d82b0be79..f7665e917bc 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -123,7 +123,7 @@ string implicitBatchableItemType
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             ArrayList buckets = null;
-            if (consumedMetadataReferences != null && consumedMetadataReferences.Count > 0)
+            if (consumedMetadataReferences?.Count > 0)
             {
                 // Add any item types that we were explicitly told to assume.
                 if (implicitBatchableItemType != null)
@@ -392,7 +392,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
 
                 if  (
                         (metadataItemName != null) &&
-                        (0 != String.Compare(item.Name, metadataItemName, StringComparison.OrdinalIgnoreCase))
+                        (!String.Equals(item.Name, metadataItemName, StringComparison.OrdinalIgnoreCase))
                     )
                 {
                     itemMetadataValues[metadataQualifiedName] = String.Empty;
@@ -414,7 +414,6 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
             return itemMetadataValues;
         }
 
-
         #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Engine/BuildResult.cs b/src/Deprecated/Engine/Engine/BuildResult.cs
index 8390e845add..f701828bcc9 100644
--- a/src/Deprecated/Engine/Engine/BuildResult.cs
+++ b/src/Deprecated/Engine/Engine/BuildResult.cs
@@ -343,7 +343,6 @@ internal void WriteToStream(BinaryWriter writer)
             #endregion
         }
 
-
         internal static BuildResult CreateFromStream(BinaryReader reader)
         {
             BuildResult buildResult = new BuildResult();
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index d1f7ef13095..b7f2b14a0d4 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -55,7 +55,7 @@ public class BuildTask
         #region Constructors
         /// <summary>
         /// This constructor initializes a persisted task from an existing task
-        /// element which exists either in the main project file or one of the 
+        /// element which exists either in the main project file or one of the
         /// imported files.
         /// </summary>
         /// <param name="taskElement"></param>
@@ -96,7 +96,7 @@ bool            importedFromAnotherProject
 
                     // this only makes sense in the context of the new OM, 
                     // so just ignore it.  
-                    case XMakeAttributes.msbuildRuntime: 
+                    case XMakeAttributes.msbuildRuntime:
                         // do nothing
                         break;
 
@@ -112,8 +112,8 @@ bool            importedFromAnotherProject
         }
 
         /// <summary>
-        /// Default constructor.  This is not allowed, because it leaves the 
-        /// BuildTask in a bad state. But we have to have it, otherwise FXCop 
+        /// Default constructor.  This is not allowed, because it leaves the
+        /// BuildTask in a bad state. But we have to have it, otherwise FXCop
         /// complains.
         /// </summary>
         /// <owner>rgoel</owner>
@@ -142,7 +142,7 @@ internal XmlElement TaskXmlElement
         }
 
         /// <summary>
-        /// Accessor for the task's "name" element.  
+        /// Accessor for the task's "name" element.
         /// </summary>
         /// <owner>RGoel</owner>
         public string Name
@@ -202,7 +202,7 @@ public bool ContinueOnError
                 {
                     return true;
                 }
-                else 
+                else
                 {
                     return false;
                 }
@@ -237,7 +237,7 @@ public bool ContinueOnError
         }
 
         /// <summary>
-        /// System.Type object corresponding to the task class that implements 
+        /// System.Type object corresponding to the task class that implements
         /// the functionality that runs this task object.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -258,7 +258,7 @@ public Type Type
                                                    parentProject.ProjectBuildEventContext.TaskId
                                                );
 
-                int handleId = parentEngine.EngineCallback.CreateTaskContext(parentProject, ParentTarget, null, taskElement, 
+                int handleId = parentEngine.EngineCallback.CreateTaskContext(parentProject, ParentTarget, null, taskElement,
                                                                                 EngineCallback.inProcNode, taskContext);
                 EngineLoggingServices loggingServices = parentEngine.LoggingServices;
                 TaskExecutionModule taskExecutionModule = parentEngine.NodeManager.TaskExecutionModule;
@@ -313,12 +313,12 @@ internal Target ParentTarget
         #region Methods
 
         /// <summary>
-        /// This retrieves the list of all parameter names from the element 
-        /// node of this task. Note that it excludes anything that a specific 
-        /// property is exposed for or that isn't valid here (Name, Condition, 
+        /// This retrieves the list of all parameter names from the element
+        /// node of this task. Note that it excludes anything that a specific
+        /// property is exposed for or that isn't valid here (Name, Condition,
         /// ContinueOnError).
-        /// 
-        /// Note that if there are none, it returns string[0], rather than null, 
+        ///
+        /// Note that if there are none, it returns string[0], rather than null,
         /// as it makes writing foreach statements over the return value so
         /// much simpler.
         /// </summary>
@@ -336,7 +336,7 @@ public string[] GetParameterNames()
             {
                 string attributeValue = attrib.Name;
 
-                if (!XMakeAttributes.IsSpecialTaskAttribute(attributeValue)) 
+                if (!XMakeAttributes.IsSpecialTaskAttribute(attributeValue))
                 {
                     list.Add(attributeValue);
                 }
@@ -349,7 +349,7 @@ public string[] GetParameterNames()
         /// This retrieves an arbitrary attribute from the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that have no meaning to MSBuild other than that they get passed to the
-        /// task itself as arguments.  
+        /// task itself as arguments.
         /// </summary>
         /// <owner>RGoel</owner>
         public string GetParameterValue
@@ -365,7 +365,7 @@ string attributeName
             error.VerifyThrowInvalidOperation(this.taskElement != null,
                 "CannotUseParameters");
 
-            string attributeValue; 
+            string attributeValue;
 
             // If this is a persisted Task, grab the attribute directly from the
             // task element.
@@ -378,7 +378,7 @@ string attributeName
         /// This sets an arbitrary attribute on the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that get passed in to the task.
-        /// 
+        ///
         /// This optionally escapes the parameter value so it will be treated as a literal.
         /// </summary>
         /// <param name="parameterName"></param>
@@ -509,7 +509,7 @@ public bool Execute
 
         /// <summary>
         /// Indicates that something has changed within the task element, so the project
-        /// needs to be saved and re-evaluated at next build.  Send the "dirtiness" 
+        /// needs to be saved and re-evaluated at next build.  Send the "dirtiness"
         /// notification up the chain.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -517,11 +517,11 @@ private void MarkTaskAsDirty
             (
             )
         {
-            if (this.ParentTarget != null)
-            {
+               
+            
                 // This is a change to the contents of the target.
-                this.ParentTarget.MarkTargetAsDirty();
-            }
+                this.ParentTarget?.MarkTargetAsDirty();
+            
         }
 
         #endregion
diff --git a/src/Deprecated/Engine/Engine/CacheManager.cs b/src/Deprecated/Engine/Engine/CacheManager.cs
index 2263370a656..894d4a82ae8 100644
--- a/src/Deprecated/Engine/Engine/CacheManager.cs
+++ b/src/Deprecated/Engine/Engine/CacheManager.cs
@@ -75,7 +75,7 @@ private CacheScope GetCacheScopeIfExists(string scopeName, BuildPropertyGroup sc
                     {
                         for (int i = 0; i < scopesByName.Count; i++)
                         {
-                            if (scopesByName[i].ScopeProperties.IsEquivalent(scopeProperties) && (String.Compare(scopeToolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            if (scopesByName[i].ScopeProperties.IsEquivalent(scopeProperties) && (String.Equals(scopeToolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase)))
                             {
                                 cacheScope = scopesByName[i];
                                 break;
@@ -216,7 +216,7 @@ internal void ClearCacheScope(string projectName, BuildPropertyGroup buildProper
                     {
                         for (int i = 0; i < scopesByName.Count; i++)
                         {
-                            if (scopesByName[i].ScopeProperties.IsEquivalent(buildPropertyGroup) && (String.Compare(toolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            if (scopesByName[i].ScopeProperties.IsEquivalent(buildPropertyGroup) && (String.Equals(toolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase)))
                             {
                                 scopesByName.RemoveAt(i);
                                 break;
diff --git a/src/Deprecated/Engine/Engine/CacheScope.cs b/src/Deprecated/Engine/Engine/CacheScope.cs
index 9946ae323d4..68441ada9e4 100644
--- a/src/Deprecated/Engine/Engine/CacheScope.cs
+++ b/src/Deprecated/Engine/Engine/CacheScope.cs
@@ -246,7 +246,7 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
                     // If the project file is malformed the build may fail without initializing the initialtargets or
                     // the default targests fields. The retrieval code expects non-null values
                     // so it is necessary to replace null with empty string
-                    ErrorUtilities.VerifyThrow(buildResult.EvaluationResult == false || buildResult.InitialTargets != null 
+                    ErrorUtilities.VerifyThrow(!buildResult.EvaluationResult || buildResult.InitialTargets != null 
                                                && buildResult.DefaultTargets != null , 
                                                "Expect initial targets to be non-null for successful builds");
                     string defaultTargets = buildResult.DefaultTargets == null ? String.Empty : buildResult.DefaultTargets;
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index e9b5b85cf45..58256e02e81 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -95,7 +95,6 @@ public enum ToolsetDefinitionLocations
     [Obsolete("This class has been deprecated. Please use Microsoft.Build.Evaluation.ProjectCollection from the Microsoft.Build assembly instead.")]
     public class Engine
     {
-
         #region Member Data
 
         // For those folks who want to share a single Engine object across many projects
@@ -118,7 +117,7 @@ public class Engine
 
         // The name of the current default toolsVersion. Starts with Constants.defaultVersion
         private string defaultToolsVersion;
-        
+
         // The node Id which the engine is running on
         private int nodeId;
 
@@ -168,7 +167,7 @@ public class Engine
         private DualQueue<BuildRequest> buildRequests;
 
         private ManualResetEvent engineAbortEvent = new ManualResetEvent(false);
-        
+
         // a cached version of the engineAbortEvent so we don't have to wait on it to determine the value.
         // If we do have to wait for something to happen we still need the event though.
         private volatile bool engineAbortCachedValue = false;
@@ -203,7 +202,7 @@ public class Engine
 
         // this seed is used to generate unique logger ids for each distributed logger
         private int lastUsedLoggerId;
-        
+
         // this boolean is true if central logging is enabled 
         private bool enabledCentralLogging;
 
@@ -267,7 +266,7 @@ public class Engine
         /// <summary>
         /// Default constructor that reads toolset information from both the registry
         /// and configuration file.
-        /// The need for parameterless constructor is dictated by COM interop. 
+        /// The need for parameterless constructor is dictated by COM interop.
         /// </summary>
         public Engine()
             : this(1 /* cpu */, false /* not child node */, 0 /* default NodeId */, null/*No msbuild.exe path*/, null, ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry)
@@ -298,7 +297,7 @@ public Engine(BuildPropertyGroup globalProperties)
         }
 
         /// <summary>
-        /// Constructor to specify whether toolsets should be initialized from the msbuild configuration file and from the registry 
+        /// Constructor to specify whether toolsets should be initialized from the msbuild configuration file and from the registry
         /// </summary>
         public Engine(ToolsetDefinitionLocations locations)
             : this(null, locations)
@@ -306,7 +305,7 @@ public Engine(ToolsetDefinitionLocations locations)
         }
 
         /// <summary>
-        /// Constructor to specify the global properties the engine should inherit and 
+        /// Constructor to specify the global properties the engine should inherit and
         /// the locations the engine should inspect for toolset definitions.
         /// </summary>
         public Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations locations)
@@ -331,7 +330,7 @@ internal Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations
             // Override the startup directory with the one we were passed
             ErrorUtilities.VerifyThrow(startupDirectory != null, "Need startup directory");
             this.startupDirectory = startupDirectory;
-            
+
             forwardPropertiesFromChild = Environment.GetEnvironmentVariable("MSBuildForwardPropertiesFromChild");
             // Get a list of properties which should be serialized
             if (!String.IsNullOrEmpty(forwardPropertiesFromChild))
@@ -341,16 +340,16 @@ internal Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations
         }
 
         /// <summary>
-        /// Constructor to init all data except for BinPath which is initialized separately because 
+        /// Constructor to init all data except for BinPath which is initialized separately because
         /// a parameterless constructor is needed for COM interop
         /// </summary>
         internal Engine
         (
-            int numberOfCpus, 
-            bool isChildNode, 
-            int parentNodeId, 
+            int numberOfCpus,
+            bool isChildNode,
+            int parentNodeId,
             string localNodeProviderParameters,
-            BuildPropertyGroup globalProperties, 
+            BuildPropertyGroup globalProperties,
             ToolsetDefinitionLocations locations
         )
         {
@@ -453,7 +452,6 @@ private void InitializeLocalNodeProvider(ToolsetDefinitionLocations locations)
             {
                 LocalNodeProvider localNodeProvider = new LocalNodeProvider();
 
-
                 string configuration = string.Empty;
                 if (localNodeProviderParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
                 {
@@ -480,7 +478,7 @@ private void InitializeLocalNodeProvider(ToolsetDefinitionLocations locations)
         /// </summary>
         /// <remarks>
         /// BinPath is an obsolete concept. We retain it for now for all the hosts that use the BinPath
-        /// property, or the Engine(binPath) constructor, but internally it is just the tools path 
+        /// property, or the Engine(binPath) constructor, but internally it is just the tools path
         /// of the default tools version.
         /// </remarks>
         /// <value>The MSBuild path.</value>
@@ -500,7 +498,6 @@ public string BinPath
             }
         }
 
-
         /// <summary>
         /// Is this engine in the process of building?
         /// </summary>
@@ -511,7 +508,7 @@ public bool IsBuilding
                 return numberOfProjectsInProgress > 0;
             }
         }
-        
+
         /// <summary>
         /// The node Id the current engine instance is running on
         /// </summary>
@@ -641,7 +638,7 @@ internal BuildPropertyGroup EnvironmentProperties
                 return this.environmentProperties;
             }
         }
-        
+
         /// <summary>
         ///  Get a new TaskId
         /// (NOT Thread safe)
@@ -721,7 +718,7 @@ internal Hashtable ImportedProjectsCache
         /// Returns the table of projects loaded by the host.
         /// </summary>
         /// <owner>RGoel</owner>
-        /// <remarks>Marked "internal" for unit tests only.  To maintain encapsulation, please try not to 
+        /// <remarks>Marked "internal" for unit tests only.  To maintain encapsulation, please try not to
         /// use this accessor in real msbuild code, except from within this class.</remarks>
         internal Hashtable ProjectsLoadedByHost
         {
@@ -844,7 +841,6 @@ internal EngineCallback EngineCallback
             }
         }
 
-
         internal bool EnabledCentralLogging
         {
             get
@@ -876,7 +872,7 @@ internal ManualResetEvent FlushRequestEvent
         }
 
         /// <summary>
-        /// The current directory at the time the Engine was constructed -- 
+        /// The current directory at the time the Engine was constructed --
         /// if msbuild.exe is hosting, this is the current directory when
         /// msbuild.exe was started
         /// </summary>
@@ -884,7 +880,7 @@ internal string StartupDirectory
         {
             get { return startupDirectory; }
         }
-        
+
         #endregion
 
         #region Methods
@@ -902,7 +898,6 @@ internal ITaskRegistry GetTaskRegistry(BuildEventContext buildEventContext, stri
             return toolsetState.GetTaskRegistry(buildEventContext);
         }
 
-
         /// <summary>
         /// Adds a new toolset to the engine. Any pre-existing toolset with the same
         /// tools version is replaced with the provided toolset.
@@ -910,7 +905,7 @@ internal ITaskRegistry GetTaskRegistry(BuildEventContext buildEventContext, stri
         /// <param name="toolset">the Toolset</param>
         internal void AddToolset(Toolset toolset)
         {
-            error.VerifyThrowArgumentNull(toolset, "toolset");
+            error.VerifyThrowArgumentNull(toolset, nameof(toolset));
 
             if (toolsetStateMap.ContainsKey(toolset.ToolsVersion))
             {
@@ -940,7 +935,7 @@ internal void UpdateToolsPath(string toolsVersion, string toolsPath)
             {
                 buildProperties = toolsetStateMap[toolsVersion].BuildProperties.Clone(true /* deep clone */);
             }
-            
+
             toolsets.Add(new Toolset(toolsVersion, toolsPath, buildProperties));
         }
 
@@ -960,7 +955,7 @@ private void DirtyProjectsUsingToolsVersion(string toolsVersion)
         }
 
         /// <summary>
-        /// Populate ToolsetStateMap with a dictionary of (toolset version, ToolsetState) 
+        /// Populate ToolsetStateMap with a dictionary of (toolset version, ToolsetState)
         /// using information from the registry and config file, if any.
         /// </summary>
         /// <remarks>Internal for unit testing purposes only</remarks>
@@ -1007,13 +1002,12 @@ internal void PopulateToolsetStateMap(ToolsetDefinitionLocations locations)
                 // Now update the default tools version to 2.0
                 DefaultToolsVersion = Constants.defaultToolsVersion;
             }
-
         }
 
         /// <summary>
         /// The default tools version of this Engine. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
-        /// This value is gotten from the .exe.config file, or else in the registry, 
+        /// This value is gotten from the .exe.config file, or else in the registry,
         /// or if neither specify a default tools version then it is hard-coded to the tools version "2.0".
         /// </summary>
         public string DefaultToolsVersion
@@ -1048,7 +1042,7 @@ public string DefaultToolsVersion
         /// <exception cref="InternalLoggerException">Logger threw arbitrary exception</exception>
         public void RegisterLogger(ILogger logger)
         {
-            error.VerifyThrowArgumentNull(logger, "logger");
+            error.VerifyThrowArgumentNull(logger, nameof(logger));
 
             // Since we are registering a central logger - need to make sure central logging is enabled for all nodes
             if (!enabledCentralLogging)
@@ -1109,7 +1103,7 @@ private void RegisterLoggerInternal(ILogger logger, EventSource sourceForLogger,
         }
 
         /// <summary>
-        /// Called to register distributed loggers with the engine. 
+        /// Called to register distributed loggers with the engine.
         /// This method is not thread safe. All loggers should registered prior to
         /// starting the build in order to guarantee uniform behavior
         /// </summary>
@@ -1117,7 +1111,7 @@ private void RegisterLoggerInternal(ILogger logger, EventSource sourceForLogger,
         /// <exception cref="InternalLoggerException">Logger threw arbitrary exception</exception>
         public void RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger)
         {
-            error.VerifyThrowArgumentNull(forwardingLogger, "forwardingLogger");
+            error.VerifyThrowArgumentNull(forwardingLogger, nameof(forwardingLogger));
             if (centralLogger == null)
             {
                 centralLogger = new NullCentralLogger();
@@ -1210,7 +1204,7 @@ internal void EndEatingLoggingEvents()
         /// <exception cref="InternalLoggerException">Logger threw arbitrary exception</exception>
         public void UnregisterAllLoggers()
         {
-            if (forwardingLoggers != null && forwardingLoggers.Count > 0)
+            if (forwardingLoggers?.Count > 0)
             {
                 // Disconnect forwarding loggers from the event source
                 ((EngineLoggingServicesInProc)primaryLoggingServices).UnregisterEventSource
@@ -1257,7 +1251,7 @@ internal void UnregisterLoggersInternal(ArrayList loggersToUnregister)
 
         /// <summary>
         /// Log BuildFinished event (if there is no unhandled exception) and clear
-        /// the projects loaded by host from the 
+        /// the projects loaded by host from the
         /// </summary>
         internal void EndingEngineExecution(bool buildResult, bool exitedDueToError)
         {
@@ -1269,7 +1263,7 @@ internal void EndingEngineExecution(bool buildResult, bool exitedDueToError)
                 // parent node, so post the event directly to the forwarding loggers.
                 if (Router.ChildMode)
                 {
-                    if (loggers != null && loggers.Count > 0)
+                    if (loggers?.Count > 0)
                     {
                         // Flush all the events currently in the queue
                         LoggingServices.ProcessPostedLoggingEvents();
@@ -1332,7 +1326,6 @@ public void Shutdown()
             UnregisterAllLoggers();
         }
 
-
         /// <summary>
         /// Creates a new empty Project object that is associated with this engine. All projects must be associated with an
         /// engine, because they need loggers, global properties, reserved properties, etc.
@@ -1358,7 +1351,7 @@ public Project GetLoadedProject
             string projectFullFileName
             )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFullFileName, "projectFullFileName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFullFileName, nameof(projectFullFileName));
             return (Project)this.projectsLoadedByHost[projectFullFileName];
         }
 
@@ -1379,7 +1372,7 @@ public void UnloadProject
             Project project
             )
         {
-            error.VerifyThrowArgumentNull(project, "project");
+            error.VerifyThrowArgumentNull(project, nameof(project));
 
             ErrorUtilities.VerifyThrow(project.IsLoadedByHost, "How did the caller get a reference to this Project object if it's not marked as loaded?");
             // Make sure this project object is associated with this engine object.
@@ -1558,7 +1551,7 @@ string targetName
         {
             return BuildProject(project, (targetName == null) ? null : new string[] { targetName }, null, BuildSettings.None);
         }
-        
+
         /// <summary>
         /// Builds a list of targets in an already-loaded project.
         /// </summary>
@@ -1637,15 +1630,15 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
             int flushTimeout = EngineLoggingServices.flushTimeoutInMS; // Timeout with which the log is flushed
             bool forceFlush = false;
             while (
-                    continueExecution && 
-                    (terminatingBuildRequest == null || terminatingBuildRequest.BuildCompleted == false)
+                    continueExecution &&
+                    (terminatingBuildRequest == null || !terminatingBuildRequest.BuildCompleted)
                   )
             {
                 int eventType = 0;
 
                 // See if we have anything to do without waiting on the handles which is expensive 
                 // for kernel mode objects.
-                if (this.engineAbortCachedValue == true)
+                if (this.engineAbortCachedValue)
                 {
                     eventType = 0;
                 }
@@ -1676,7 +1669,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                     // Decrement time remaining until deadlock check
                     if (loopTimeoutRemaining != Timeout.Infinite)
                     {
-                        loopTimeoutRemaining = flushTimeout > loopTimeoutRemaining ? 
+                        loopTimeoutRemaining = flushTimeout > loopTimeoutRemaining ?
                                                   0 : loopTimeoutRemaining - flushTimeout;
                     }
                     // Always force a flush on a time
@@ -1821,7 +1814,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                 // TEM will be null if we're shutting down
                 if (NodeManager.TaskExecutionModule != null)
                 {
-                    if (NodeManager.TaskExecutionModule.UseBreadthFirstTraversal == false /* using depth first traversal */ &&
+                    if (!NodeManager.TaskExecutionModule.UseBreadthFirstTraversal /* using depth first traversal */ &&
                         buildRequests.Count == 0 && taskOutputUpdates.Count == 0 &&
                         NodeManager.TaskExecutionModule.IsIdle
                         )
@@ -1859,7 +1852,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
         /// </summary>
         private void BuildProjectInternal
         (
-            BuildRequest buildRequest, 
+            BuildRequest buildRequest,
             ProjectBuildState buildContext,
             TaskExecutionContext taskExecutionContext,
             bool initialCall
@@ -1890,7 +1883,7 @@ bool initialCall
                 }
 
                 try
-                { 
+                {
                     if (initialCall)
                     {
                         BuildProjectInternalInitial(buildRequest, project);
@@ -1950,7 +1943,7 @@ bool initialCall
                 // Flush out all the logging messages, which may have been posted outside target execution
                 primaryLoggingServices.ProcessPostedLoggingEvents();
 
-                if (buildRequest != null && buildRequest.BuildCompleted || exitedDueToError)
+                if (buildRequest?.BuildCompleted == true || exitedDueToError)
                 {
 #if (!STANDALONEBUILD)
                     CodeMarkers.Instance.CodeMarker(CodeMarkerEvent.perfMSBuildEngineBuildProjectEnd);
@@ -1982,12 +1975,12 @@ Decrementing from 0 projects in progress causes an exception.
                 buildRequest.StartTime = DateTime.Now.Ticks;
                 buildRequest.ProcessingStartTime = buildRequest.StartTime;
             }
-            
+
             if (startRootProjectBuild)
             {
                 StartRootProjectBuild(buildRequest, project);
             }
-            
+
             project.BuildInternal(buildRequest);
         }
 
@@ -2025,7 +2018,6 @@ private void BuildProjectInternalContinue(BuildRequest buildRequest, ProjectBuil
             project.ContinueBuild(buildContext, taskExecutionContext);
         }
 
-
         private void IncrementProjectsInProgress()
         {
             Interlocked.Increment(ref this.numberOfProjectsInProgress);
@@ -2038,8 +2030,8 @@ private void FinishBuildProjectInProgress(BuildRequest buildRequest, ProjectBuil
                 buildRequest.ProcessingTotalTime += DateTime.Now.Ticks - buildRequest.ProcessingStartTime;
             }
 
-            if (buildRequest != null && buildRequest.BuildCompleted ||
-                buildContext != null && buildContext.BuildComplete )
+            if (buildRequest?.BuildCompleted == true ||
+                buildContext?.BuildComplete == true)
             {
                 DecrementProjectsInProgress();
             }
@@ -2211,7 +2203,7 @@ IDictionary targetOutputs
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         /// <param name="projectFile"></param>
@@ -2242,7 +2234,7 @@ BuildSettings buildFlags
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         /// <param name="projectFile"></param>
@@ -2270,7 +2262,7 @@ string toolsVersion
 
         /// <summary>
         /// Loads a set of project files from disk, and builds the given list of targets for each one. This overload
-        /// takes a set of global properties for each project to use for the build, returns the target outputs, 
+        /// takes a set of global properties for each project to use for the build, returns the target outputs,
         /// and also allows the caller to specify additional build flags.
         /// </summary>
         /// <param name="projectFiles">Array of project files to build (can't be null)</param>
@@ -2305,7 +2297,7 @@ string [] toolsVersions
             }
 
             return PostProjectEvaluationRequests
-                (null, projectFiles, targetNamesPerProject, globalPropertiesPerProject, targetOutputsPerProject, 
+                (null, projectFiles, targetNamesPerProject, globalPropertiesPerProject, targetOutputsPerProject,
                  buildFlags, toolsVersions);
         }
 
@@ -2325,13 +2317,12 @@ string [] toolVersions
             fatalErrorContext = null;
 
             BuildEventContext buildEventContext;
-               
+
             // Already have an instantiated project in the OM and it has not fired a project started event for itself yet
-            if (project != null && !project.HaveUsedInitialProjectContextId)
+            if (project?.HaveUsedInitialProjectContextId == false)
             {
                 buildEventContext = project.ProjectBuildEventContext;
             }
-
             else // Dont have an already instantiated project, need to make a new context
             {
                 buildEventContext = new BuildEventContext(
@@ -2341,7 +2332,7 @@ string [] toolVersions
                                                 BuildEventContext.InvalidTaskId
                                                 );
             }
-            
+
             // Currently, MSBuild requires that the calling thread be marked "STA" -- single
             // threaded apartment.  This is because today we are calling the tasks' Execute()
             // method on this main thread, and there are tasks out there that create unmarshallable
@@ -2373,7 +2364,7 @@ string [] toolVersions
                     targetOutputsWorkingCopy[i] = new Hashtable(StringComparer.OrdinalIgnoreCase);
                 }
 
-                buildRequests[i] = 
+                buildRequests[i] =
                     CreateLocalBuildRequest(buildEventContext, project, projectFiles[i], targetNames[i],
                                             globalPropertiesPerProject[i], targetOutputsWorkingCopy[i], buildFlags,
                                             toolVersions[i]);
@@ -2446,8 +2437,8 @@ string [] toolVersions
         }
 
         /// <summary>
-        /// Create a build request which will be posted to the local engine queue, having a HandleId of -1 meaning it came from the local 
-        /// engine rather than an engine call back 
+        /// Create a build request which will be posted to the local engine queue, having a HandleId of -1 meaning it came from the local
+        /// engine rather than an engine call back
         /// </summary>
         /// <returns></returns>
         private BuildRequest CreateLocalBuildRequest(BuildEventContext buildEventContext, Project project, string projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs, BuildSettings buildFlags, string toolsVersion)
@@ -2490,7 +2481,7 @@ private BuildRequest CreateLocalBuildRequest(BuildEventContext buildEventContext
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         internal void BuildProjectFileInternal
@@ -2651,7 +2642,7 @@ private void HandleProjectFileInternalException(BuildRequest buildRequest)
         {
             // Flush out all the logging messages, which may have been posted outside target execution
             primaryLoggingServices.ProcessPostedLoggingEvents();
-            
+
             // Mark evaluation as complete
             buildRequest.BuildCompleted = true;
 
@@ -2672,9 +2663,9 @@ private void HandleProjectFileInternalException(BuildRequest buildRequest)
         /// <param name="cachedResult"></param>
         private void ProcessCachedResult
         (
-            BuildRequest buildRequest, 
-            FileInfo projectFileInfo, 
-            ArrayList actuallyBuiltTargets, 
+            BuildRequest buildRequest,
+            FileInfo projectFileInfo,
+            ArrayList actuallyBuiltTargets,
             BuildResult cachedResult
         )
         {
@@ -2803,7 +2794,7 @@ bool toolsVersionPeekedFromProjectFile
                 if (this.cacheOfBuildingProjects.HasProjectBeenLoaded(projectFullPath, globalPropertiesToUse, toolsVersionToUse))
                 {
                     string joinedNames = ResourceUtilities.FormatResourceString("DefaultTargets");
-                    if (targetNames != null && targetNames.Length > 0)
+                    if (targetNames?.Length > 0)
                     {
                         joinedNames = EscapingUtilities.UnescapeAll(String.Join(";", targetNames));
                     }
@@ -2862,24 +2853,24 @@ bool toolsVersionPeekedFromProjectFile
 
             return returnProject;
         }
-        
+
         /// <summary>
-        /// When using the MSBuild task to build a child project, we need to figure out the set of 
+        /// When using the MSBuild task to build a child project, we need to figure out the set of
         /// global properties that the child should be built with.  It is a merge of whatever
         /// properties the parent project was being built with, plus whatever properties were
         /// actually passed into the MSBuild task (in the "Properties" parameter).  However,
-        /// the slightly wrinkle is the child project may have actually been one that is 
+        /// the slightly wrinkle is the child project may have actually been one that is
         /// currently loaded in the IDE, and the IDE controls what Configuration/Platform each
         /// project should be built with, so we have to honor that too.  So, the order in which
         /// we look at global properties are:
-        /// 
+        ///
         ///     1.  Whatever global properties the parent project was building with.  (The parent
         ///         project is the one that called the &lt;MSBuild&lt; task.
-        ///     2.  If the child project was already previously loaded by the host, whatever global 
+        ///     2.  If the child project was already previously loaded by the host, whatever global
         ///         properties were sent into the child project by the host (via Project.GlobalProperties).
         ///     3.  Whatever properties were passed into the "Properties" parameter of the &lt;MSBuild&lt;
         ///         task.
-        /// 
+        ///
         /// </summary>
         /// <param name="parentProjectGlobalProperties"></param>
         /// <param name="childProjectFile"></param>
@@ -2904,11 +2895,11 @@ IDictionary globalPropertiesPassedIntoTask
                 // If the project file doesn't actually exist on disk, it's a failure.
                 ErrorUtilities.VerifyThrowArgument(File.Exists(childProjectFile), "ProjectFileNotFound", childProjectFile);
             }
-            
+
             // Create a new BuildPropertyGroup to represent the final set of global properties that we're going to
             // use for the child project.
             BuildPropertyGroup finalGlobalProperties = new BuildPropertyGroup();
-            
+
             // Start with the global properties from the parent project.
             if (postMergeProperties == null)
             {
@@ -2918,7 +2909,7 @@ IDictionary globalPropertiesPassedIntoTask
             {
                 finalGlobalProperties.ImportProperties(postMergeProperties);
             }
-            
+
             // childProjectFile could be null when no Projects were passed into the MSBuild task, which
             // means parentProject == childProject, which means no need to import the same properties again.
             if (childProjectFile != null)
@@ -2936,13 +2927,13 @@ IDictionary globalPropertiesPassedIntoTask
                     finalGlobalProperties.ImportProperties(loadedProjectWithSameFullPath.GlobalProperties);
                 }
             }
-            
+
             // Finally, whatever global properties were passed into the task ... those are the final winners.
             if (globalPropertiesPassedIntoTask != null)
             {
                 foreach (DictionaryEntry newGlobalProperty in globalPropertiesPassedIntoTask)
                 {
-                    finalGlobalProperties.SetProperty((string) newGlobalProperty.Key, 
+                    finalGlobalProperties.SetProperty((string) newGlobalProperty.Key,
                         (string) newGlobalProperty.Value);
                 }
             }
@@ -2984,7 +2975,7 @@ internal TaskExecutionContext GetTaskOutputUpdates()
         }
 
         /// <summary>
-        /// This function collects status about the inprogress targets and engine operations. 
+        /// This function collects status about the inprogress targets and engine operations.
         /// This function should always run from the engine domain because it touch engine data
         /// structures.
         /// </summary>
@@ -3002,13 +2993,13 @@ internal NodeStatus RequestStatus(int requestId)
             {
                 foreach (Target target in project.Targets)
                 {
-                    if (target.ExecutionState != null && target.ExecutionState.BuildingRequiredTargets)
+                    if (target.ExecutionState?.BuildingRequiredTargets == true)
                     {
                         inProgressTargets.Add(target);
                     }
                 }
             }
-            TargetInProgessState[] stateOfInProgressTargets = 
+            TargetInProgessState[] stateOfInProgressTargets =
                     new TargetInProgessState[waitingTargets.Length + inProgressTargets.Count];
             for (int i = 0; i < waitingTargets.Length; i++)
             {
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index 9e5c03f1702..0afa060bbbd 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -22,7 +21,7 @@ internal class EngineCallback : IEngineCallback
     {
         #region Constructors
         /// <summary>
-        /// Creates a callback class. There should only be one callback per engine under normal 
+        /// Creates a callback class. There should only be one callback per engine under normal
         /// circumstances.
         /// </summary>
         internal EngineCallback(Engine parentEngine)
@@ -87,7 +86,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
             buildRequest.NodeIndex = executionContext.NodeIndex;
 
             ErrorUtilities.VerifyThrow(buildRequest.ParentBuildEventContext != null, "Should not have a null parentBuildEventContext");
-            ErrorUtilities.VerifyThrow(buildRequest.IsGeneratedRequest == true, "Should not be sending a non generated request from the child node to the parent node");
+            ErrorUtilities.VerifyThrow(buildRequest.IsGeneratedRequest, "Should not be sending a non generated request from the child node to the parent node");
 
             // For buildRequests originating from the TEM  - additional initialization is necessary
             TaskExecutionContext taskExecutionContext = executionContext as TaskExecutionContext;
@@ -117,7 +116,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                                                                    buildRequest.ProjectFileName,
                                                                    buildRequest.GlobalPropertiesPassedByTask);
                         }
-                        catch (ArgumentException e) 
+                        catch (ArgumentException e)
                         {
                             ConvertToInvalidProjectException(buildRequest, parentProject, e);
                         }
@@ -136,13 +135,11 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                         // project.  This allows people to avoid passing in the Projects parameter on the MSBuild task.
                         Project projectToBuild = parentProject;
 
-
-
                         // If the parent project (the calling project) already has the same set of global properties
                         // as what is being requested, just re-use it.  Otherwise, we need to instantiate a new
                         // project object that has the same project contents but different global properties.
                         if (!projectToBuild.GlobalProperties.IsEquivalent(buildRequest.GlobalProperties) &&
-                            (String.Compare(parentProject.ToolsVersion, buildRequest.ToolsetVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            (String.Equals(parentProject.ToolsVersion, buildRequest.ToolsetVersion, StringComparison.OrdinalIgnoreCase)))
                         {
                             projectToBuild = parentEngine.GetMatchingProject(parentProject,
                                                  parentProject.FullFileName, buildRequest.GlobalProperties,
@@ -185,8 +182,8 @@ private static void ConvertToInvalidProjectException(BuildRequest buildRequest,
         /// </summary>
         internal void PostTaskOutputs
         (
-            int handleId, 
-            bool taskExecutedSuccessfully, 
+            int handleId,
+            bool taskExecutedSuccessfully,
             Exception thrownException,
             long executionTime
         )
@@ -211,7 +208,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
 
             // Cache the results
             routingContext.CacheScope.AddCacheEntryForBuildResults(buildResult);
-            
+
             if (Engine.debugMode)
             {
                 Console.WriteLine("Received result for HandleId " + buildResult.HandleId + ":" + buildResult.RequestId + " mapped to " + routingContext.ParentHandleId + ":" + routingContext.ParentRequestId);
@@ -219,7 +216,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
 
             // Update the results with the original handle id and request id, so that 
             buildResult.HandleId = routingContext.ParentHandleId;
-       
+
             // If the build result is created from a generated build request a done notice should be posted as other targets could be waiting for this target to finish
             if (buildResult.HandleId != invalidEngineHandle)
             {
@@ -233,7 +230,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
                 routingContext.TriggeringBuildRequest.BuildCompleted = true;
                 parentEngine.PostEngineCommand(new HostBuildRequestCompletionEngineCommand());
             }
-            
+
             // At this point the execution context we created for the execution of this build request can be deleted
             lock (freedContexts)
             {
@@ -246,7 +243,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
         /// </summary>
         public void SetCacheEntries
         (
-            int handleId, CacheEntry[] entries, 
+            int handleId, CacheEntry[] entries,
             string cacheScope, string cacheKey, string cacheVersion,
             CacheContentType cacheContentType, bool localNodeOnly
         )
@@ -293,13 +290,13 @@ public void SetCacheEntries
                 }
             }
         }
-        
+
         /// <summary>
         /// Called either on the main or child node. This is the routing method for getting cache entries.
         /// </summary>
         public CacheEntry[] GetCacheEntries
         (
-            int handleId, string[] names, 
+            int handleId, string[] names,
             string cacheScope, string cacheKey, string cacheVersion,
             CacheContentType cacheContentType, bool localNodeOnly
         )
@@ -359,7 +356,7 @@ public CacheEntry[] GetCacheEntries
         }
 
         /// <summary>
-        /// Submit the logging message to the engine queue. Note that we are currently not utilizing the 
+        /// Submit the logging message to the engine queue. Note that we are currently not utilizing the
         /// handleId, but plan to do so in the future to fill out the data structure passed to the engine
         /// </summary>
         public void PostLoggingMessagesToHost(int nodeId, NodeLoggingEvent[] nodeLoggingEventArray)
@@ -390,7 +387,7 @@ internal void GetLineColumnOfXmlNode(int handleId, out int lineNumber, out int c
         internal ITaskRegistry GetEngineTaskRegistry(int handleId)
         {
             TaskExecutionContext executionContext = GetTaskContextFromHandleId(handleId);
-            return parentEngine.GetTaskRegistry(executionContext.BuildEventContext, 
+            return parentEngine.GetTaskRegistry(executionContext.BuildEventContext,
                                     executionContext.ParentProject.ToolsVersion);
         }
 
@@ -495,16 +492,16 @@ internal RequestRoutingContext GetRoutingContextFromHandleId(int handleId)
         /// </summary>
         internal int CreateTaskContext
         (
-            Project parentProject, 
+            Project parentProject,
             Target  parentTarget,
             ProjectBuildState buildContext,
-            XmlElement taskNode, 
+            XmlElement taskNode,
             int nodeIndex,
             BuildEventContext taskContext
         )
         {
             int handleId = nextContextId;
-            nextContextId = nextContextId + 1;
+            nextContextId += 1;
 
             TaskExecutionContext executionContext =
                 new TaskExecutionContext(parentProject, parentTarget, taskNode, buildContext, handleId, nodeIndex, taskContext);
@@ -530,10 +527,10 @@ BuildEventContext buildEventContext
         )
         {
             int handleId = nextContextId;
-            nextContextId = nextContextId + 1;
+            nextContextId += 1;
 
             RequestRoutingContext executionContext =
-                new RequestRoutingContext(handleId, nodeIndex, parentHandleId, parentNodeIndex, parentRequestId, 
+                new RequestRoutingContext(handleId, nodeIndex, parentHandleId, parentNodeIndex, parentRequestId,
                                           cacheScope, triggeringBuildRequest, buildEventContext);
 
             executionContexts.Add(handleId, executionContext);
@@ -570,7 +567,7 @@ internal void ClearContextState(int handleId)
 
         #region Constants
         /// <summary>
-        /// Number assigned to an invalid engine handle, This handleId is used by Buildrequests 
+        /// Number assigned to an invalid engine handle, This handleId is used by Buildrequests
         /// to show they are a routing context
         /// </summary>
         internal const int invalidEngineHandle = -1;
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index 15ad1514da1..3a5815111af 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -75,7 +75,7 @@ virtual internal void Shutdown()
         /// <param name="e"></param>
         internal void PostLoggingEvent(BuildEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             if (paused)
             {
@@ -106,7 +106,7 @@ internal void PostLoggingEvent(BuildEventArgs e)
         /// <param name="eventArray"></param>
         internal void PostLoggingEvents(BuildEventArgs[] eventArray)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventArray, "eventArray");
+            ErrorUtilities.VerifyThrowArgumentNull(eventArray, nameof(eventArray));
 
             if (paused)
             {
@@ -139,7 +139,7 @@ internal void PostLoggingEvents(BuildEventArgs[] eventArray)
         /// <param name="e"></param>
         internal void PostLoggingEvent(NodeLoggingEvent e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             if (paused)
             {
@@ -163,7 +163,7 @@ internal void PostLoggingEvent(NodeLoggingEvent e)
         /// <param name="eventArray"></param>
         internal void PostLoggingEvents(NodeLoggingEvent[] eventArray)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventArray, "eventArray");
+            ErrorUtilities.VerifyThrowArgumentNull(eventArray, nameof(eventArray));
 
             if (paused)
             {
@@ -240,7 +240,7 @@ internal void LogErrorEvent(BuildErrorEventArgs e)
             // issue, and it apparently will also cause us problems if we adopt the
             // new Longhorn Add-In Programming Model.  
 
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
         }
 
@@ -260,7 +260,7 @@ internal void LogMessageEvent(BuildMessageEventArgs e)
                 // issue, and it apparently will also cause us problems if we adopt the
                 // new Longhorn Add-In Programming Model.
 
-                ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+                ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
                 PostLoggingEvent(e);
             }
         }
@@ -279,7 +279,7 @@ internal void LogWarningEvent(BuildWarningEventArgs e)
             // issue, and it apparently will also cause us problems if we adopt the
             // new Longhorn Add-In Programming Model.
 
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
         }
 
@@ -297,7 +297,7 @@ internal void LogCustomEvent(CustomBuildEventArgs e)
             // issue, and it apparently will also cause us problems if we adopt the
             // new Longhorn Add-In Programming Model.
 
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
             PostLoggingEvent(e);
         }
         #endregion
@@ -616,7 +616,6 @@ virtual internal void LogWarningFromText(BuildEventContext buildEventContext, st
                 subcategory = AssemblyResources.GetString(subcategoryResourceName);
             }
 
-
             BuildWarningEventArgs e = new BuildWarningEventArgs
                 (
                     subcategory,
@@ -742,9 +741,8 @@ virtual internal void LogProjectStarted(int projectId, BuildEventContext parentB
             if (!OnlyLogCriticalEvents)
             {
                 ProjectStartedEventArgs e;
-
-               
-                if (null != targetNames && targetNames.Length > 0)
+              
+                if (!string.IsNullOrEmpty(targetNames))
                 {
                     e = new ProjectStartedEventArgs
                         (
@@ -1013,7 +1011,6 @@ internal bool FlushBuildEventsImmediatly
         /// </summary>
         protected ManualResetEvent flushRequestEvent;
 
-
         internal const int flushTimeoutInMS = 500;          // flush the queue at least every 1/2 second
         internal const int flushTimeoutInTicks = 500*10000; // flush the queue at least every 1/2 second
         internal const int flushQueueSize = 1000;            // flush the queue every time 1000 events accumulate
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
index 2f6bd3a4f9a..fbf4ed120dd 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
@@ -119,10 +119,7 @@ override internal void ProcessBuildEvent(BuildEventArgs buildEventArgs)
             }
 
             // Check if it necessary to forward the event to another logging service
-            if (forwardingService != null)
-            {
-                forwardingService.PostLoggingEvent(buildEventArgs);
-            }
+            forwardingService?.PostLoggingEvent(buildEventArgs);
         }
 
         internal void RegisterEventSource(int loggerId, EventSource eventSource)
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index a1934f5d9b3..d32e8382aeb 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -46,7 +46,7 @@ internal sealed class EngineProxy : MarshalByRefObject, IBuildEngine3
         private string projectFileOfTaskNode;
 
         /// <summary>
-        /// The token identifing the context of this evaluation 
+        /// The token identifing the context of this evaluation
         /// </summary>
         private int handleId;
 
@@ -56,7 +56,7 @@ internal sealed class EngineProxy : MarshalByRefObject, IBuildEngine3
         private bool continueOnError;
 
         /// <summary>
-        /// The module within which this class has been created. Used for all callbacks to 
+        /// The module within which this class has been created. Used for all callbacks to
         /// engine.
         /// </summary>
         private TaskExecutionModule parentModule;
@@ -102,7 +102,7 @@ private EngineProxy()
         {
             // do nothing
         }
-     
+
         /// <summary>
         /// Create an instance of this class to represent the IBuildEngine2 interface to the task
         /// including the event location where the log messages are raised
@@ -115,10 +115,10 @@ private EngineProxy()
         /// <param name="buildEventContext">Event Context where events will be seen to be raised from. Task messages will get this as their event context</param>
         internal EngineProxy
         (
-            TaskExecutionModule parentModule, 
-            int handleId, 
+            TaskExecutionModule parentModule,
+            int handleId,
             string parentProjectFullFileName,
-            string projectFileOfTaskNode, 
+            string projectFileOfTaskNode,
             EngineLoggingServices loggingServices,
             BuildEventContext buildEventContext
         )
@@ -143,8 +143,8 @@ BuildEventContext buildEventContext
         /// </summary>
         public void LogErrorEvent(BuildErrorEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -190,14 +190,14 @@ public void LogErrorEvent(BuildErrorEventArgs e)
                     e = new BuildErrorEventArgs
                         (
                             e.Subcategory,
-                            e.Code, 
-                            e.File, 
-                            e.LineNumber, 
-                            e.ColumnNumber, 
-                            e.EndLineNumber, 
-                            e.EndColumnNumber, 
+                            e.Code,
+                            e.File,
+                            e.LineNumber,
+                            e.ColumnNumber,
+                            e.EndLineNumber,
+                            e.EndColumnNumber,
                             message,  // this is the new message from above
-                            e.HelpKeyword, 
+                            e.HelpKeyword,
                             e.SenderName
                         );
                 }
@@ -212,8 +212,8 @@ public void LogErrorEvent(BuildErrorEventArgs e)
         /// </summary>
         public void LogWarningEvent(BuildWarningEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -250,7 +250,7 @@ public void LogWarningEvent(BuildWarningEventArgs e)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="file">File field from the original BuildEventArgs</param>
         /// <param name="message">Message field from the original BuildEventArgs</param>
@@ -289,8 +289,8 @@ private static string GetUpdatedMessage(string file, string message, string pare
         /// </summary>
         public void LogMessageEvent(BuildMessageEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -306,8 +306,8 @@ public void LogMessageEvent(BuildMessageEventArgs e)
         /// </summary>
         public void LogCustomEvent(CustomBuildEventArgs e)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
-            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
+            ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
             if (parentModule.IsRunningMultipleNodes && !e.GetType().IsSerializable)
             {
@@ -327,7 +327,7 @@ public bool ContinueOnError
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 return this.continueOnError;
             }
@@ -351,7 +351,7 @@ public int LineNumberOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 ComputeProjectFileLocationOfTaskNode();
                 return this.lineNumber;
@@ -367,7 +367,7 @@ public int ColumnNumberOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 ComputeProjectFileLocationOfTaskNode();
                 return this.columnNumber;
@@ -381,7 +381,7 @@ public string ProjectFileOfTaskNode
         {
             get
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 return projectFileOfTaskNode;
             }
@@ -430,16 +430,16 @@ IDictionary targetOutputs
         /// <returns>result of call to engine</returns>
         public bool BuildProjectFile
             (
-            string projectFileName, 
-            string[] targetNames, 
-            IDictionary globalProperties, 
+            string projectFileName,
+            string[] targetNames,
+            IDictionary globalProperties,
             IDictionary targetOutputs,
             string toolsVersion
             )
         {
             lock (callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
                 // Wrap the project name into an array
                 string[] projectFileNames = new string[1];
@@ -485,7 +485,7 @@ bool unloadProjectsOnCompletion
         }
 
         /// <summary>
-        /// Not implemented for the proxy 
+        /// Not implemented for the proxy
         /// </summary>
 	public void Yield()
 	{
@@ -504,12 +504,12 @@ public void Reacquire()
         /// <remarks>
         /// 1) it is acceptable to pass null for both <c>targetNames</c> and <c>targetOutputs</c>
         /// 2) if no targets are specified, the default targets are built
-        /// 
+        ///
         /// </remarks>
         /// <param name="projectFileNames">The project to build.</param>
         /// <param name="targetNames">The targets in the project to build (can be null).</param>
         /// <param name="globalProperties">An array of hashtables of additional global properties to apply
-        ///     to the child project (array entries can be null). 
+        ///     to the child project (array entries can be null).
         ///     The key and value in the hashtable should both be strings.</param>
         /// <param name="removeGlobalProperties">A list of global properties which should be removed.</param>
         /// <param name="toolsVersions">A tools version recognized by the Engine that will be used during this build (can be null).</param>
@@ -527,11 +527,11 @@ bool returnTargetOutputs
         {
             lock (callbackMonitor)
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy == true, "AttemptingToLogFromInactiveTask");
+                ErrorUtilities.VerifyThrowInvalidOperation(activeProxy, "AttemptingToLogFromInactiveTask");
 
-                ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
+                ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, nameof(projectFileNames));
                 ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalPropertiesPerProject");
-                
+
                 Dictionary<string, ITaskItem[]>[] targetOutputsPerProject = null;
 
                 if (returnTargetOutputs)
@@ -552,7 +552,7 @@ bool returnTargetOutputs
         }
 
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         public override object InitializeLifetimeService()
@@ -573,7 +573,7 @@ public override object InitializeLifetimeService()
                 int leaseTimeFromEnvironment;
                 if (int.TryParse(initialLeaseTimeFromEnvironment , out leaseTimeFromEnvironment) && leaseTimeFromEnvironment > 0)
                 {
-                      initialLeaseTime = leaseTimeFromEnvironment;        
+                      initialLeaseTime = leaseTimeFromEnvironment;
                 }
             }
 
@@ -593,7 +593,7 @@ public override object InitializeLifetimeService()
                 int leaseExtensionFromEnvironment;
                 if (int.TryParse(leaseExtensionTimeFromEnvironment , out leaseExtensionFromEnvironment) && leaseExtensionFromEnvironment > 0)
                 {
-                      leaseExtensionTime = leaseExtensionFromEnvironment;        
+                      leaseExtensionTime = leaseExtensionFromEnvironment;
                 }
             }
 
@@ -605,7 +605,6 @@ public override object InitializeLifetimeService()
             return lease;
         }
 
-
         /// <summary>
         /// Indicates to the EngineProxy that it is no longer needed.
         /// Called by TaskEngine when the task using the EngineProxy is done.
@@ -619,23 +618,19 @@ internal void MarkAsInActive()
             loggingServices = null;
             parentModule = null;
             buildEventContext = null;
-            
+
             // Clear out the sponsor (who is responsible for keeping the EngineProxy remoting lease alive until the task is done)
             // this will be null if the engineproxy was never sent accross an appdomain boundry.
             if (sponsor != null)
             {
                 ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
-             
-                if (lease != null)
-                {
-                    lease.Unregister(sponsor);
-                }
-                
+                lease?.Unregister(sponsor);
+
                 sponsor.Close();
                 sponsor = null;
             }
         }
-	
+
         #region Properties
         /// <summary>
         /// Provide a way to change the BuildEventContext of the engine proxy. This is important in batching where each batch will need its own buildEventContext.
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 8b7230ae7ba..73d8fe767d2 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -1460,7 +1460,6 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
                 return null;
             }
 
-
             /// <summary>
             /// Get the specified type from the assembly partial name supplied
             /// </summary>
@@ -1594,7 +1593,7 @@ private static Function ConstructFunction(string expressionFunction, string expr
             private static string[] ExtractFunctionArguments(string expressionFunction, string argumentsContent)
             {
                 List<string> arguments = new List<string>();
-                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length); ;
+                StringBuilder argumentBuilder = new StringBuilder(argumentsContent.Length); 
 
                 // Iterate over the contents of the arguments extracting the
                 // the individual arguments as we go
@@ -1672,12 +1671,12 @@ private static void AddArgument(List<string> arguments, StringBuilder argumentBu
                 // If we don't have something that can be treated as an argument
                 // then we should treat it as a null so that passing nulls
                 // becomes possible through an empty argument between commas.
-                ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, "argumentBuilder");
+                ErrorUtilities.VerifyThrowArgumentNull(argumentBuilder, nameof(argumentBuilder));
                 // we reached the end of an argument, add the builder's final result
                 // to our arguments. 
                 string argValue = argumentBuilder.ToString().Trim();
                 // We support passing of null through the argument constant value null
-                if (String.Compare("null", argValue, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
                 {
                     arguments.Add(null);
                 }
diff --git a/src/Deprecated/Engine/Engine/ImportCollection.cs b/src/Deprecated/Engine/Engine/ImportCollection.cs
index 9c5669e5373..65aca2c1ea2 100644
--- a/src/Deprecated/Engine/Engine/ImportCollection.cs
+++ b/src/Deprecated/Engine/Engine/ImportCollection.cs
@@ -171,7 +171,7 @@ public void CopyTo(Import[] array, int index)
         /// <param name="condition">Condition. If null, no condition is added.</param>
         public void AddNewImport(string projectFile, string condition)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
+            ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
 
             XmlElement projectElement = this.parentProject.ProjectElement;
             XmlElement newImportElement = projectElement.OwnerDocument.CreateElement(XMakeElements.import, XMakeAttributes.defaultXmlNamespace);
@@ -198,7 +198,7 @@ public void RemoveImport
             Import importToRemove
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(importToRemove, "importToRemove");
+            ErrorUtilities.VerifyThrowArgumentNull(importToRemove, nameof(importToRemove));
 
             // Confirm that it's not an imported import.
             ErrorUtilities.VerifyThrowInvalidOperation(!importToRemove.IsImported,
diff --git a/src/Deprecated/Engine/Engine/ImportedProject.cs b/src/Deprecated/Engine/Engine/ImportedProject.cs
index 3d0b9922958..480cdf9b62a 100644
--- a/src/Deprecated/Engine/Engine/ImportedProject.cs
+++ b/src/Deprecated/Engine/Engine/ImportedProject.cs
@@ -15,7 +15,6 @@ namespace Microsoft.Build.BuildEngine
     /// <owner>SumedhK</owner>
     internal sealed class ImportedProject
     {
-
         /// <summary>
         /// Creates an instance of this class for the specified project file.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index eb6a90b2a09..f5bab0f2fa2 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -329,7 +329,7 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
         {
             if (keyName == null)
             {
-                throw new ArgumentNullException("keyName");
+                throw new ArgumentNullException(nameof(keyName));
             }
 
             string basekeyName;
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index a16f21d38e1..5881de4307c 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -29,8 +29,8 @@ internal class Node
         /// </summary>
         internal Node
         (
-            int nodeId, 
-            LoggerDescription[] nodeLoggers, 
+            int nodeId,
+            LoggerDescription[] nodeLoggers,
             IEngineCallback parentCallback,
             BuildPropertyGroup parentGlobalProperties,
             ToolsetDefinitionLocations toolsetSearchLocations,
@@ -127,7 +127,7 @@ internal void PostBuildRequestToHost(BuildRequest currentRequest)
             TaskExecutionContext taskExecutionContext = localEngine.EngineCallback.GetTaskContextFromHandleId(currentRequest.HandleId);
             while (!taskExecutionContext.BuildContext.BuildRequest.IsExternalRequest)
             {
-                ErrorUtilities.VerifyThrow(taskExecutionContext.BuildContext.BuildRequest.IsGeneratedRequest, 
+                ErrorUtilities.VerifyThrow(taskExecutionContext.BuildContext.BuildRequest.IsGeneratedRequest,
                                            "Must be a generated request");
 
                 taskExecutionContext =
@@ -214,7 +214,7 @@ internal void PostStatus(NodeStatus nodeStatus, bool blockUntilSent)
 
         /// <summary>
         /// A variation of PostStatus that throws instead of calling ReportUnhandledError
-        /// if there's a problem. This allows ReportUnhandledError itself to post status 
+        /// if there's a problem. This allows ReportUnhandledError itself to post status
         /// without the possibility of a loop.
         /// </summary>
         internal void PostStatusThrow(NodeStatus nodeStatus, bool blockUntilSent)
@@ -251,7 +251,7 @@ BuildRequest buildRequest
                             launchedEngineLoopThread = true;
                             ThreadStart threadState = new ThreadStart(this.NodeLocalEngineLoop);
                             Thread taskThread = new Thread(threadState);
-                            taskThread.Name = "MSBuild Child Engine";                            
+                            taskThread.Name = "MSBuild Child Engine";
                             taskThread.SetApartmentState(ApartmentState.STA);
                             taskThread.Start();
                         }
@@ -305,7 +305,7 @@ internal void PostBuildResult(BuildResult buildResult)
                 buildResult.HandleId = nodeRequestMapping.HandleId;
                 buildResult.RequestId = nodeRequestMapping.RequestId;
                 nodeRequestMapping.AddResultToCache(buildResult);
-                
+
                 // posts the result to the inproc node
                 localEngine.Router.PostDoneNotice(0, buildResult);
             }
@@ -387,7 +387,6 @@ bool useBreadthFirstTraversal
                 localEngine.LoggingServices.OnlyLogCriticalEvents = this.logOnlyCriticalEvents;
                 localEngine.PostEngineCommand( new ChangeTraversalTypeCommand( useBreadthFirstTraversal, true ));
             }
-
         }
 
         /// <summary>
@@ -436,7 +435,6 @@ internal void ReportUnhandledError(Exception originalException)
             {
                 try
                 {
-
                     PostStatusThrow(nodeStatus, true /* wait for the message to be sent before returning */);
                 }
                 catch (Exception ex)
@@ -457,10 +455,7 @@ internal void ReportUnhandledError(Exception originalException)
                 LocalNode.DumpExceptionToFile(originalException);
             }
 
-            if (localEngine != null)
-            {
-                localEngine.Shutdown();
-            }
+            localEngine?.Shutdown();
         }
 
         /// <summary>
@@ -474,10 +469,7 @@ internal void ReportUnhandledError(Exception originalException)
         /// <exception cref="Exception">Re-throws exception passed in</exception>
         internal void ReportFatalCommunicationError(Exception originalException, TextWriter loggingStream)
         {
-            if (loggingStream != null)
-            {
-                loggingStream.WriteLine(originalException.ToString());
-            }
+            loggingStream?.WriteLine(originalException.ToString());
 
             string message = ResourceUtilities.FormatResourceString("FatalErrorOnChildNode", nodeId, originalException.Message);
 
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index b200bda4f0b..e920e05c323 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -199,7 +199,7 @@ internal virtual void WriteToStream(BinaryWriter writer, Hashtable loggingTypeCa
                 else
                 {
                     // The customer serialization methods are not availiable, default to .net serialization
-                    writer.BaseStream.Position = writer.BaseStream.Position - 1;
+                    writer.BaseStream.Position -= 1;
                     writer.Write((byte)0);
                     binaryFormatter.Serialize(writer.BaseStream, e);
                 }
@@ -269,7 +269,6 @@ internal virtual void CreateFromStream(BinaryReader reader, Hashtable loggingTyp
                             resolver = null;
                         }
                     }
-                
             }
         }
         #endregion
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index 68183335a46..6a3e94d65cb 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -50,7 +50,7 @@ internal NodeManager(int cpuCount, bool childMode, Engine parentEngine)
         /// <returns></returns>
         internal bool RegisterNodeProvider(INodeProvider nodeProviderToRegister)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(nodeProviderToRegister,"nodeProviderToRegister");
+            ErrorUtilities.VerifyThrowArgumentNull(nodeProviderToRegister, nameof(nodeProviderToRegister));
 
             INodeDescription[] nodeDescriptions = nodeProviderToRegister.QueryNodeDescriptions();
 
@@ -135,7 +135,7 @@ internal NodeStatus[] RequestStatusForNodes(int responseTimeout)
                     // Calculate the time remaining and only continue if there is time left
                     TimeSpan timeSpent = new TimeSpan(DateTime.Now.Ticks - startTime);
                     startTime = DateTime.Now.Ticks;
-                    responseTimeout = responseTimeout - (int)timeSpent.TotalMilliseconds;
+                    responseTimeout -= (int)timeSpent.TotalMilliseconds;
                     if (responseTimeout <= 0)
                     {
                         Console.WriteLine("Response time out out exceeded :" + DateTime.Now.Ticks);
@@ -153,7 +153,6 @@ internal NodeStatus[] RequestStatusForNodes(int responseTimeout)
             return statusForNodes;
         }
 
-
         internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
         {
             ErrorUtilities.VerifyThrow( nodeStatus.RequestId != NodeStatus.UnrequestedStatus,
@@ -174,7 +173,6 @@ internal void PostNodeStatus(int nodeId, NodeStatus nodeStatus)
             statusMessageReceived.Set();
         }
 
-
         internal void PostCycleNotification
         (
             int nodeId, 
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 95a20a3e551..3b8b1b81a89 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -49,7 +49,7 @@ public enum PropertyPosition
         /// </summary>
         UseExistingOrCreateAfterLastImport = 1
     };
-    
+
     /// <summary>
     /// Whether we are in the first (properties) pass, or the second (items) pass.
     /// </summary>
@@ -62,7 +62,7 @@ internal enum ProcessingPass
         /// <summary>
         /// Second pass (evaluating items)
         /// </summary>
-        Pass2        
+        Pass2
     };
 
     /// <summary>
@@ -316,7 +316,7 @@ public class Project
 
         /// <summary>
         /// Items need the project directory in order to evaluate their built-in
-        /// metadata (like "%(FullPath)") when their itemspec is relative. We store this 
+        /// metadata (like "%(FullPath)") when their itemspec is relative. We store this
         /// here in thread-local-storage because we cannot modify the public constructors
         /// to require it, and also it can change during the life of a BuildItem
         /// (when the item is passed to another project).
@@ -381,7 +381,6 @@ string toolsVersion
                 this.mainProjectElement = mainProjectEntireContents.CreateElement(XMakeElements.project, XMakeAttributes.defaultXmlNamespace);
                 this.mainProjectEntireContents.AppendChild(mainProjectElement);
 
-
                 // initialize all case-insensitive hash-tables
                 this.conditionedPropertiesTable = new Hashtable(StringComparer.OrdinalIgnoreCase);
                 this.evaluatedItemsByName = new Hashtable(StringComparer.OrdinalIgnoreCase);
@@ -596,7 +595,7 @@ public string DefaultTargets
         }
 
         /// <summary>
-        /// Returns the array of actual target names that will be built by default. First choice is 
+        /// Returns the array of actual target names that will be built by default. First choice is
         /// the defaultTargets attribute on the Project node, if not present we fall back to the first target
         /// in the project file. Return value is null if there are no targets in the project file.
         /// </summary>
@@ -624,7 +623,7 @@ internal string[] DefaultBuildTargets
         /// Read-write accessor for the "InitialTargets" attribute of the
         /// &lt;Project&gt; element.  This is passed in and out as a semicolon-separated
         /// list of target names.  The "get" returns all of the initial targets in both
-        /// the main project and all imported projects (after property expansion).  The 
+        /// the main project and all imported projects (after property expansion).  The
         /// "set" only sets the initial targets for the main project.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -727,7 +726,6 @@ public bool IsValidated
             }
         }
 
-
         /// <summary>
         /// Is this project in the process of building?
         /// </summary>
@@ -794,12 +792,12 @@ public bool BuildEnabled
 
         /// <summary>
         /// When gotten, returns the effective tools version being used by this project.
-        /// If the tools version is being overridden, the overriding value will be the effective tools version. 
-        /// Otherwise, if there is a ToolsVersion attribute on the Project element, that is the effective tools version. 
+        /// If the tools version is being overridden, the overriding value will be the effective tools version.
+        /// Otherwise, if there is a ToolsVersion attribute on the Project element, that is the effective tools version.
         /// Otherwise, the default tools version of the parent engine is the effective tools version.
-        /// 
+        ///
         /// When set, overrides the current tools version of this project with the provided value.
-        /// 
+        ///
         /// NOTE: This is distinct to the ToolsVersion attribute, if any, on the Project element.
         /// To get and set the ToolsVersion attribute on the Project element use the Project.DefaultToolsVersion
         /// property.
@@ -845,14 +843,14 @@ internal bool OverridingToolsVersion
         }
 
         /// <summary>
-        /// Public read-write accessor for the ToolsVersion xml attribute found on the 
+        /// Public read-write accessor for the ToolsVersion xml attribute found on the
         /// &lt;Project /&gt; element.  If this attribute is not present on the &lt;Project/&gt;
         /// element, getting the value will return the default tools version of the parent Engine.
-        /// 
+        ///
         /// NOTE: This value is distinct from the effective tools version used during a build,
         /// as that value may be overridden during construction of the Project instance or
-        /// by setting the Project.ToolsVersion property. Setting this attribute value will not change the 
-        /// effective tools version if it has been overridden. To change the effective tools version, 
+        /// by setting the Project.ToolsVersion property. Setting this attribute value will not change the
+        /// effective tools version if it has been overridden. To change the effective tools version,
         /// set the Project.ToolsVersion property.
         /// </summary>
         public string DefaultToolsVersion
@@ -903,7 +901,7 @@ public string DefaultToolsVersion
                 // version is actually valid
                 ProjectElement.SetAttribute(XMakeAttributes.toolsVersion, value);
 
-                if (overridingToolsVersion == false)
+                if (!overridingToolsVersion)
                 {
                     this.toolsVersion = DefaultToolsVersion;
                 }
@@ -960,7 +958,7 @@ internal ITaskRegistry TaskRegistry
         }
 
         /// <summary>
-        /// The project directory where the project file is in, this can be empty if the project is constructed in memory and does 
+        /// The project directory where the project file is in, this can be empty if the project is constructed in memory and does
         /// not come from a file location
         /// </summary>
         internal string ProjectDirectory
@@ -1018,10 +1016,7 @@ public BuildPropertyGroup GlobalProperties
                 // the XML every time any property value changes.
 
                 // Unhook the old globalProperties from this project.
-                if (globalProperties != null)
-                {
-                    globalProperties.ClearParentProject();
-                }
+                globalProperties?.ClearParentProject();
 
                 globalProperties = value.Clone(true);
 
@@ -1356,7 +1351,7 @@ private XmlDeclaration XmlDeclarationNode
         {
             get
             {
-                if (mainProjectEntireContents != null && mainProjectEntireContents.HasChildNodes)
+                if (mainProjectEntireContents?.HasChildNodes == true)
                 {
                     return mainProjectEntireContents.FirstChild as XmlDeclaration;
                 }
@@ -1450,7 +1445,7 @@ private void SetDefaultTargets(string defaultTargetsList, BuildPropertyGroup pro
 
         /// <summary>
         /// Determines whether a project file can be considered equivalent to this Project, taking into account
-        /// the set of global properties and the tools version (if any) that that project file 
+        /// the set of global properties and the tools version (if any) that that project file
         /// is going to be built with.
         /// </summary>
         /// <param name="projectFullPath"></param>
@@ -1459,7 +1454,7 @@ private void SetDefaultTargets(string defaultTargetsList, BuildPropertyGroup pro
         /// <returns></returns>
         internal bool IsEquivalentToProject(string projectFullPath, BuildPropertyGroup projectGlobalProperties, string projectToolsVersion)
         {
-            if (String.Compare(projectFullPath, this.FullFileName, StringComparison.OrdinalIgnoreCase) != 0)
+            if (!String.Equals(projectFullPath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -1473,7 +1468,7 @@ internal bool IsEquivalentToProject(string projectFullPath, BuildPropertyGroup p
                 projectToolsVersion = this.DefaultToolsVersion;
             }
 
-            return (String.Compare(ToolsVersion, projectToolsVersion, StringComparison.OrdinalIgnoreCase) == 0
+            return (String.Equals(ToolsVersion, projectToolsVersion, StringComparison.OrdinalIgnoreCase)
                 && this.GlobalProperties.IsEquivalent(projectGlobalProperties));
         }
 
@@ -1672,7 +1667,7 @@ private void SetProjectFileReservedProperties
             this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.programFiles32,
                     FrameworkLocationHelper.programFiles32, PropertyType.ReservedProperty));
 
-            this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.assemblyVersion, 
+            this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.assemblyVersion,
                     Constants.AssemblyVersion, PropertyType.ReservedProperty));
 
             if (this.fullFileName.Length == 0)
@@ -1714,7 +1709,6 @@ private void SetProjectFileReservedProperties
 
                 this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.projectDirectoryNoRoot,
                     EscapingUtilities.Escape(projectDirectoryNoRoot), PropertyType.ReservedProperty));
-                
             }
 
             this.projectDirectory = this.ReservedProperties[ReservedPropertyNames.projectDirectory].FinalValue;
@@ -1788,7 +1782,7 @@ internal void Load
             ProjectLoadSettings projectLoadSettings
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFileName, "projectFileName");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFileName, nameof(projectFileName));
             ErrorUtilities.VerifyThrowArgument(projectFileName.Length > 0, "EmptyProjectFileName");
             ErrorUtilities.VerifyThrowArgument(File.Exists(projectFileName), "ProjectFileNotFound", projectFileName);
 
@@ -1827,7 +1821,6 @@ ProjectLoadSettings projectLoadSettings
                         // on <MSBuild> task tags, and what MSBuildToolsPath to use when scanning child projects
                         // for dependency information.
                         SolutionWrapperProject.Generate(sp, this, toolsVersion, buildEventContext);
-
                     }
                     else if (IsVCProjFilename(projectFileName))
                     {
@@ -1852,7 +1845,6 @@ ProjectLoadSettings projectLoadSettings
                         InternalLoadFromXmlDocument(projectDocument, projectLoadSettings);
                     }
 
-
                     // This project just came off the disk, so it is certainly not dirty yet.
                     this.dirtyNeedToSaveProjectFile = false;
                 }
@@ -1936,7 +1928,7 @@ public void Load
             ProjectLoadSettings projectLoadSettings
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(textReader, "textReader");
+            ErrorUtilities.VerifyThrowArgumentNull(textReader, nameof(textReader));
 
             try
             {
@@ -1988,7 +1980,7 @@ public void LoadXml
             ProjectLoadSettings projectLoadSettings
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectXml, "projectXml");
+            ErrorUtilities.VerifyThrowArgumentNull(projectXml, nameof(projectXml));
 
             try
             {
@@ -2019,7 +2011,6 @@ ProjectLoadSettings projectLoadSettings
             }
         }
 
-
         /// <summary>
         /// Reads in the contents of this project from an in-memory XmlDocument handed to us.
         /// </summary>
@@ -2031,7 +2022,7 @@ internal void LoadFromXmlDocument
             ProjectLoadSettings projectLoadSettings
             )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectXml, "projectXml");
+            ErrorUtilities.VerifyThrowArgumentNull(projectXml, nameof(projectXml));
 
             try
             {
@@ -2086,7 +2077,7 @@ private void InternalLoadFromXmlDocument(XmlDocument projectXml, ProjectLoadSett
                 ProjectErrorUtilities.VerifyThrowInvalidProject(this.mainProjectElement.LocalName == XMakeElements.project,
                     this.mainProjectElement, "UnrecognizedElement", this.mainProjectElement.Name);
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject((mainProjectElement.Prefix.Length == 0) && (String.Compare(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                ProjectErrorUtilities.VerifyThrowInvalidProject((mainProjectElement.Prefix.Length == 0) && (String.Equals(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                     mainProjectElement, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
                 MarkProjectAsDirtyForReprocessXml();
@@ -2103,7 +2094,6 @@ private void InternalLoadFromXmlDocument(XmlDocument projectXml, ProjectLoadSett
                 }
                 throw;
             }
-
         }
 
         /// <summary>
@@ -2153,7 +2143,7 @@ Encoding encoding
 
                 // Update the project filename/path if it has changed.
                 string newFullProjectFilePath = Path.GetFullPath(projectFileName);
-                if (0 != String.Compare(newFullProjectFilePath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(newFullProjectFilePath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
                 {
                     this.FullFileName = newFullProjectFilePath;
                 }
@@ -2368,7 +2358,7 @@ PropertyPosition position
         }
 
         /// <summary>
-        /// Sets a property, and optionally escapes it so that it will be treated as a literal 
+        /// Sets a property, and optionally escapes it so that it will be treated as a literal
         /// value despite any special characters that may be in it.
         /// </summary>
         /// <param name="propertyName"></param>
@@ -2386,7 +2376,7 @@ public void SetProperty
             bool treatPropertyValueAsLiteral
             )
         {
-            this.SetProperty(propertyName, 
+            this.SetProperty(propertyName,
                 treatPropertyValueAsLiteral ? EscapingUtilities.Escape(propertyValue) : propertyValue,
                 condition, position);
         }
@@ -2465,7 +2455,7 @@ PropertyPosition position
         )
         {
             // Property name must be non-empty.
-            error.VerifyThrowArgumentLength(propertyName, "propertyName");
+            error.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
 
             // Property value must be non-null.
             error.VerifyThrowArgument(propertyValue != null,
@@ -2513,7 +2503,6 @@ PropertyPosition position
                         matchingPropertyGroup = this.AddNewPropertyGroup(afterImportPosition);
                         matchingPropertyGroup.Condition = condition;
                     }
-
                 }
 
                 if (importedProperty)
@@ -2565,8 +2554,8 @@ ref BuildProperty matchingProperty
                 }
 
                 if (propertyGroup.IsImported == importedPropertyGroup &&
-                    (0 == String.Compare(propertyGroup.Condition.Trim(), condition.Trim(), StringComparison.OrdinalIgnoreCase)) &&
-                    (!importedPropertyGroup || (importedPropertyGroup && (0 == String.Compare(propertyGroup.ImportedFromFilename, importedFilename, StringComparison.OrdinalIgnoreCase)))))
+                    (String.Equals(propertyGroup.Condition.Trim(), condition.Trim(), StringComparison.OrdinalIgnoreCase)) &&
+                    (!importedPropertyGroup || (importedPropertyGroup && (String.Equals(propertyGroup.ImportedFromFilename, importedFilename, StringComparison.OrdinalIgnoreCase)))))
                 {
                     if (matchingPropertyGroup == null)
                     {
@@ -2581,7 +2570,7 @@ ref BuildProperty matchingProperty
                     // property.
                     foreach (BuildProperty property in propertyGroup)
                     {
-                        if (0 == String.Compare(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
                         {
                             matchingProperty = property;
                         }
@@ -2644,7 +2633,7 @@ public void RemovePropertyGroup
             BuildPropertyGroup propertyGroupToRemove
         )
         {
-            error.VerifyThrowArgumentNull(propertyGroupToRemove, "propertyGroupToRemove");
+            error.VerifyThrowArgumentNull(propertyGroupToRemove, nameof(propertyGroupToRemove));
 
             // Confirm that it's not an imported property group.
             error.VerifyThrowInvalidOperation(!propertyGroupToRemove.IsImported,
@@ -2679,7 +2668,7 @@ public void RemoveImportedPropertyGroup
             BuildPropertyGroup propertyGroupToRemove
         )
         {
-            error.VerifyThrowArgumentNull(propertyGroupToRemove, "propertyGroupToRemove");
+            error.VerifyThrowArgumentNull(propertyGroupToRemove, nameof(propertyGroupToRemove));
 
             // Confirm that it's actually a persisted BuildPropertyGroup in the current project.
             error.VerifyThrowInvalidOperation(
@@ -2793,8 +2782,8 @@ public BuildItem AddNewItem
             string itemInclude
             )
         {
-            ErrorUtilities.VerifyThrowArgumentLength(itemName, "itemName");
-            ErrorUtilities.VerifyThrowArgumentLength(itemInclude, "itemInclude");
+            ErrorUtilities.VerifyThrowArgumentLength(itemName, nameof(itemName));
+            ErrorUtilities.VerifyThrowArgumentLength(itemInclude, nameof(itemInclude));
 
             BuildItemGroup matchingItemGroup = null;
 
@@ -2814,7 +2803,7 @@ string itemInclude
                     // the same type as the new item being added.
                     foreach (BuildItem originalItem in itemGroup)
                     {
-                        if ( 0 == String.Compare( originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
+                        if ( String.Equals( originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
                         {
                             // If the new item that the user is trying to add is already covered by 
                             // a wildcard in an existing item of the project, then there's really
@@ -2932,7 +2921,7 @@ public void RemoveItemGroup
             BuildItemGroup itemGroupToRemove
         )
         {
-            error.VerifyThrowArgumentNull(itemGroupToRemove, "itemGroupToRemove");
+            error.VerifyThrowArgumentNull(itemGroupToRemove, nameof(itemGroupToRemove));
 
             // Confirm that it's not an imported item group.
             error.VerifyThrowInvalidOperation(!itemGroupToRemove.IsImported,
@@ -2981,7 +2970,7 @@ public void RemoveItem
             BuildItem itemToRemove
         )
         {
-            error.VerifyThrowArgumentNull(itemToRemove, "itemToRemove");
+            error.VerifyThrowArgumentNull(itemToRemove, nameof(itemToRemove));
 
             // Confirm that it's not an imported item.
             error.VerifyThrowInvalidOperation(!itemToRemove.IsImported, "CannotModifyImportedProjects");
@@ -3176,7 +3165,7 @@ public bool Build
             string targetName
             )
         {
-            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] {targetName}, 
+            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] {targetName},
                 null, BuildSettings.None);
         }
 
@@ -3312,7 +3301,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                 else if (buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.CycleDetected)
                 {
                     ErrorUtilities.VerifyThrow(
-                        taskExecutionContext != null && taskExecutionContext.ParentTarget != null,
+                        taskExecutionContext?.ParentTarget != null,
                         "Unexpected task context. Should not be null");
                     // Check that the target is in progress
                     ErrorUtilities.VerifyThrow(
@@ -3358,8 +3347,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                             while (buildContext.NameOfBlockingTarget != null)
                             {
                                 Target blockingTarget = GetTargetForName(buildContext.NameOfBlockingTarget);
-                                if (blockingTarget.ExecutionState != null &&
-                                    blockingTarget.ExecutionState.BuildingRequiredTargets)
+                                if (blockingTarget.ExecutionState?.BuildingRequiredTargets == true)
                                 {
                                     blockingTarget.ContinueBuild(buildContext, null);
                                 }
@@ -3367,14 +3355,12 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                                 buildContext.RemoveBlockingTarget();
                             }
                             Target inprogressTarget = GetTargetForName(buildContext.NameOfTargetInProgress);
-                            if (inprogressTarget.ExecutionState != null &&
-                                inprogressTarget.ExecutionState.BuildingRequiredTargets)
+                            if (inprogressTarget.ExecutionState?.BuildingRequiredTargets == true)
                             {
                                 inprogressTarget.ContinueBuild(buildContext, null);
                             }
                         }
 
-
                         buildContext.CurrentBuildContextState = ProjectBuildState.BuildContextState.BuildComplete;
                     }
 
@@ -3534,7 +3520,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
             ProjectBuildState buildContext = null;
 
             string[] targetNamesToBuild = buildRequest.TargetNames;
-            
+
             // Initialize to the parent requests project context id
             int projectContextId = buildRequest.ParentBuildEventContext.ProjectContextId;
 
@@ -3579,9 +3565,9 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                 // Only log the project started event after making sure the project is reevaluated if necessary,
                 // otherwise we could log stale item/property information.
                 if (!ParentEngine.LoggingServices.OnlyLogCriticalEvents && buildRequest.FireProjectStartedFinishedEvents)
-                {  
+                {
                     string joinedTargetNamesToBuild = null;
-                    if (targetNamesToBuild != null && targetNamesToBuild.Length > 0)
+                    if (targetNamesToBuild?.Length > 0)
                     {
                         joinedTargetNamesToBuild = EscapingUtilities.UnescapeAll(String.Join(";", targetNamesToBuild));
                     }
@@ -3603,7 +3589,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
 
                         // Get the list of properties to serialize to the parent node
                         string[] propertyListToSerialize = parentEngine.PropertyListToSerialize;
-                        if (propertyListToSerialize != null && propertyListToSerialize.Length > 0)
+                        if (propertyListToSerialize?.Length > 0)
                         {
                             foreach (string propertyToGet in propertyListToSerialize)
                             {
@@ -3622,7 +3608,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                     BuildItemGroupProxy itemsProxy = new BuildItemGroupProxy(this.evaluatedItems);
 
                     ParentEngine.LoggingServices.LogProjectStarted(this.projectId, buildRequest.ParentBuildEventContext, buildEventContext, FullFileName, joinedTargetNamesToBuild, propertiesProxy, itemsProxy);
-                    
+
                     // See comment on DefaultToolsVersion setter.
                     if (treatinghigherToolsVersionsAs40)
                     {
@@ -3744,7 +3730,7 @@ private void ProcessMainProjectElement
             // Technically, this belongs in ProcessProjectAttributes. However, ToolsVersion
             // affects strategic reserved properties, so it's better to process it before anything else happens
             ProcessToolsVersionDependentProperties();
-            
+
             if (IsValidated)
             {
                 // Validate the project schema. If we have a file, then validate that
@@ -3779,12 +3765,12 @@ private void ProcessMainProjectElement
             // variables ... so we need to set these up early.
             this.evaluatedProperties.Clear();
             this.evaluatedProperties.ImportInitialProperties(this.EnvironmentProperties, this.ReservedProperties, this.Toolset.BuildProperties, this.GlobalProperties);
-            
+
             // Process the attributes of the <project> element.
             ProcessProjectAttributes(this.mainProjectElement, false);
 
             // Figure out where the project is located
-            this.projectDirectory = !string.IsNullOrEmpty(this.fullFileName) ? 
+            this.projectDirectory = !string.IsNullOrEmpty(this.fullFileName) ?
                 Path.GetDirectoryName(this.fullFileName) : Directory.GetCurrentDirectory();
 
             // Process the child elements of the <Project> element, instantiating
@@ -4037,7 +4023,6 @@ bool importedProject
             }
         }
 
-
         /// <summary>
         /// Process the &lt;Import&gt; element by loading the child project file, and processing its &lt;Project&gt; element. In a
         /// given main project, the same file cannot be imported twice -- this is to prevent circular imports.
@@ -4060,8 +4045,8 @@ bool        importedProject
                 // Do not expand properties or items before passing in the value of the
                 // condition attribute to EvaluateCondition, otherwise special characters
                 // inside the property values can really confuse the condition parser.
-                if (!Utilities.EvaluateCondition(temp.Condition, temp.ConditionAttribute, 
-                    new Expander(this.evaluatedProperties), this.conditionedPropertiesTable, 
+                if (!Utilities.EvaluateCondition(temp.Condition, temp.ConditionAttribute,
+                    new Expander(this.evaluatedProperties), this.conditionedPropertiesTable,
                     ParserOptions.AllowProperties, ParentEngine.LoggingServices, projectBuildEventContext))
                 {
                     return;
@@ -4073,15 +4058,14 @@ bool        importedProject
 
             // Expand any $(propertyname) references inside the "Project" attribute value.
             string expandedImportedFilename = (new Expander(this.evaluatedProperties)).ExpandAllIntoStringLeaveEscaped(temp.ProjectPath, temp.ProjectPathAttribute);
-            
+
             // Expand any wildcards
             string[] importedFilenames = EngineFileUtilities.GetFileListEscaped(projectDirectoryLocation, expandedImportedFilename);
 
             for (int i = 0; i < importedFilenames.Length; i++)
             {
-                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);
-                         
-                ProjectErrorUtilities.VerifyThrowInvalidProject((importedFilename != null) && (importedFilename.Length != 0),
+                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);     
+                ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(importedFilename),
                     importElement, "MissingRequiredAttribute",
                     XMakeAttributes.project, XMakeElements.import);
 
@@ -4132,10 +4116,9 @@ bool        importedProject
                             ProjectErrorUtilities.VerifyThrowInvalidProject(importedChildNode.LocalName == XMakeElements.project,
                                 importedChildNode, "UnrecognizedElement", importedChildNode.Name);
 
-                            ProjectErrorUtilities.VerifyThrowInvalidProject((importedChildNode.Prefix.Length == 0) && (String.Compare(importedChildNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                            ProjectErrorUtilities.VerifyThrowInvalidProject((importedChildNode.Prefix.Length == 0) && (String.Equals(importedChildNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                                 importedChildNode, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
-
                             // We have the <Project> element, so process it.
                             this.ProcessProjectAttributes((XmlElement)importedChildNode,
                                 /* imported project */ true);
@@ -4175,7 +4158,7 @@ private XmlDocument LoadImportedProject(Import import)
             // also prevents the same file from being imported twice, even it it's not a
             // circular dependency, but that's fine -- no good reason to do that anyway.
             if ((this.imports[import.EvaluatedProjectPath] != null) ||
-                (string.Compare(this.FullFileName, import.EvaluatedProjectPath, StringComparison.OrdinalIgnoreCase) == 0))
+                (string.Equals(this.FullFileName, import.EvaluatedProjectPath, StringComparison.OrdinalIgnoreCase)))
             {
                 ParentEngine.LoggingServices.LogWarning(projectBuildEventContext, Utilities.CreateBuildEventFileInfo(import.ProjectPathAttribute, FullFileName),
                     "DuplicateImport", import.EvaluatedProjectPath);
@@ -4200,9 +4183,9 @@ private XmlDocument LoadImportedProject(Import import)
                         // look up the engine's cache to see if we've already loaded this imported project on behalf of another
                         // top-level project
                         ImportedProject previouslyImportedProject = (ImportedProject)ParentEngine.ImportedProjectsCache[import.EvaluatedProjectPath];
-                        
+
                         // if this project hasn't been imported before, or if it has changed on disk, we need to load it
-                        if ((previouslyImportedProject == null) || previouslyImportedProject.HasChangedOnDisk(import.EvaluatedProjectPath))
+                        if ((previouslyImportedProject?.HasChangedOnDisk(import.EvaluatedProjectPath) != false))
                         {
                             try
                             {
@@ -4267,7 +4250,7 @@ internal void OnRenameOfImportedFile(string oldFileName, string newFileName)
                 {
                     // ... then check the filename of the PropertyGroup to see if it
                     // matches the *old* file name.
-                    if (0 == String.Compare(pg.ImportedFromFilename, oldFileName, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(pg.ImportedFromFilename, oldFileName, StringComparison.OrdinalIgnoreCase))
                     {
                         // Okay, we found a PropertyGroup that appears to have originated from
                         // the imported file that just got renamed.  We should update the PropertyGroup
@@ -4310,7 +4293,6 @@ private void EvaluateProject(bool currentlyLoading)
                     // on conditions to work correctly, and for wildcards to evaluate relative to the project directory.
                     Project.PerThreadProjectDirectory = this.ProjectDirectory;
 
-
                     // In case we've just loaded the project file, we don't want to repeat all
                     // of the work done during ProcessProjectChildren(...) to evaluate the
                     // properties.
@@ -4446,7 +4428,7 @@ private void EvaluateAllUsingTasks()
         }
 
         /// <summary>
-        /// Adds an item to the appropriate project's evaluated items collection.  This method is 
+        /// Adds an item to the appropriate project's evaluated items collection.  This method is
         /// NOT to be used during the build process to add items that are emitted by tasks.
         /// This is only for the purposes of adding statically-declared items in the logical
         /// project file, or items added to the project file by an IDE modifying the project contents.
@@ -4473,7 +4455,7 @@ internal void AddToItemListByNameIgnoringCondition(BuildItem item)
         }
 
         /// <summary>
-        /// Adds an item to the appropriate project's evaluated items collection.  This method is 
+        /// Adds an item to the appropriate project's evaluated items collection.  This method is
         /// NOT to be used during the build process to add items that are emitted by tasks.
         /// This is only for the purposes of adding statically-declared items in the logical
         /// project file, or items added to the project file by an IDE modifying the project contents.
@@ -4508,7 +4490,7 @@ internal void AddToItemListByName(BuildItem item)
         /// <owner>jomof</owner>
         internal static bool IsSolutionFilename(string filename)
         {
-            return (string.Compare(Path.GetExtension(filename), ".sln", StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(Path.GetExtension(filename), ".sln", StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -4517,7 +4499,7 @@ internal static bool IsSolutionFilename(string filename)
         /// <owner>LukaszG</owner>
         internal static bool IsVCProjFilename(string filename)
         {
-            return (string.Compare(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase));
         }
     }
 }
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index f21598c28a5..72de222753b 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -89,7 +89,7 @@ internal string NameOfBlockingTarget
         {
             get
             {
-                return (requiredTargets != null && requiredTargets.Count > 0 ?
+                return (requiredTargets?.Count > 0 ?
                         this.requiredTargets.Peek() : null);
             }
         }
@@ -138,7 +138,7 @@ internal string GetNextTarget()
         {
             if ((indexOfTargetInProgress + 1) < targetNamesToBuild.Count)
             {
-                indexOfTargetInProgress = indexOfTargetInProgress + 1;
+                indexOfTargetInProgress += 1;
                 return (string)targetNamesToBuild[indexOfTargetInProgress];
             }
             else
@@ -199,17 +199,17 @@ internal void RecordBuildException()
         internal bool ContainsCycle(string name)
         {
             bool containsCycle = false;
-            if (requiredTargets != null && requiredTargets.Count > 1)
+            if (requiredTargets?.Count > 1)
             {
                 string topTarget = requiredTargets.Pop();
                 ErrorUtilities.VerifyThrow(topTarget == name, "Requesting target should be on the top of stack");
                 containsCycle = requiredTargets.Contains(name);
                 requiredTargets.Push(topTarget);
             }
-            if (!containsCycle && requiredTargets != null && requiredTargets.Count > 0)
+            if (!containsCycle && requiredTargets?.Count > 0)
             {
                 containsCycle = 
-                    (String.Compare(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase) == 0);
+                    (String.Equals(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase));
             }
             return containsCycle;
         }
@@ -221,7 +221,7 @@ internal bool ContainsCycle(string name)
         internal bool ContainsBlockingTarget(string name)
         {
             bool containsName = false;
-            if (requiredTargets != null && requiredTargets.Count > 0)
+            if (requiredTargets?.Count > 0)
             {
                 containsName = requiredTargets.Contains(name);
             }
@@ -237,7 +237,7 @@ internal bool ContainsBlockingTarget(string name)
         internal string GetParentTarget(string name)
         {
             string parentName = null;
-            if (requiredTargets != null && requiredTargets.Count > 0)
+            if (requiredTargets?.Count > 0)
             {
                 parentName = (string)targetNamesToBuild[indexOfTargetInProgress];
 
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index 234a362b835..ba497699405 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -156,7 +156,7 @@ string projectFileFullPath
             // Get the list of projects that have this full path.
             ArrayList projectsWithThisFullPath = (ArrayList) this.projects[projectFileFullPath];
 
-            if ((projectsWithThisFullPath != null) && (projectsWithThisFullPath.Count > 0))
+            if ((projectsWithThisFullPath?.Count > 0))
             {
                 return (Project) projectsWithThisFullPath[0];
             }
@@ -396,7 +396,7 @@ internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projec
                 // Loop through them and find the one with the matching set of global properties.
                 foreach (ProjectEntry projectEntry in projectsWithFullPath)
                 {
-                    if ((String.Compare(projectEntry.toolsVersion, toolsVersion, StringComparison.OrdinalIgnoreCase) == 0) &&
+                    if ((String.Equals(projectEntry.toolsVersion, toolsVersion, StringComparison.OrdinalIgnoreCase)) &&
                         projectEntry.globalProperties.IsEquivalent(globalProperties))
                     {
                         return projectEntry;
diff --git a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
index 03811168da2..ab4840d7004 100644
--- a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
+++ b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
@@ -115,7 +115,7 @@ string projectFile
             validatorSettings.XmlResolver = null;
             validatorSettings.ValidationEventHandler += this.OnSchemaValidationError;
             
-            if ((schemaFile == null) || (schemaFile.Length == 0))
+            if (string.IsNullOrEmpty(schemaFile))
             {
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index 9d392e957cf..fc0b67b2fb1 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -56,8 +56,8 @@ internal RegistryKeyWrapper(string registryKeyPath)
         /// <param name="registryHive"></param>
         internal RegistryKeyWrapper(string registryKeyPath, RegistryKey registryHive)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, "registryKeyPath");
-            ErrorUtilities.VerifyThrowArgumentNull(registryHive, "registryHive");
+            ErrorUtilities.VerifyThrowArgumentNull(registryKeyPath, nameof(registryKeyPath));
+            ErrorUtilities.VerifyThrowArgumentNull(registryHive, nameof(registryHive));
 
             this.registryKeyPath = registryKeyPath;
             this.registryHive = registryHive;
@@ -150,7 +150,7 @@ public virtual string[] GetSubKeyNames()
         /// <returns></returns>
         public virtual RegistryKeyWrapper OpenSubKey(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             
             RegistryKeyWrapper wrapper = this;
             string[] keyNames = name.Split(new char[] { '\\' }, StringSplitOptions.RemoveEmptyEntries);
diff --git a/src/Deprecated/Engine/Engine/Router.cs b/src/Deprecated/Engine/Engine/Router.cs
index 7e61058766d..999d71d8d1b 100644
--- a/src/Deprecated/Engine/Engine/Router.cs
+++ b/src/Deprecated/Engine/Engine/Router.cs
@@ -131,12 +131,12 @@ internal void PostDoneNotice(BuildRequest buildRequest)
         /// </summary>
         internal void PostDoneNotice(int nodeId, BuildResult buildResult)
         {
-            if (scheduler != null)
-            {
+               
+            
                 // Notify the scheduler that a given node(nodeId) will be getting a buildResult.
                 // This method is a no-op if the router is on a child process
-                scheduler.NotifyOfBuildResult(nodeId, buildResult);
-            }
+                scheduler?.NotifyOfBuildResult(nodeId, buildResult);
+            
 
             if (nodeId == EngineCallback.inProcNode)
             {
@@ -179,12 +179,12 @@ internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
                                     (nodeIndex, currentRequest.HandleId, currentRequest.NodeIndex,
                                      currentRequest.RequestId, cacheScope, currentRequest, null);
 
-                    if (scheduler != null)
-                    {
+                       
+                    
                         // Check to see if we need to change the traversal strategy of the system
                         // parentHandleId and node index are not used in the function so it can be ignored
-                        scheduler.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
-                    }
+                        scheduler?.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
+                    
                     
                     nodeManager.PostBuildRequestToNode(nodeIndex, currentRequest);
                 }
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index f872023873d..d2a36cab2cf 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -100,7 +100,6 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                 // If we have not chosen an node yet, this can happen if the node was loaded previously on a child node
                 if (nodeUsed == EngineCallback.invalidNode)
                 {
-                    
                     if (useLoadBalancing)
                     {
                         #region UseLoadBalancing
@@ -157,11 +156,11 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                         }
                         #endregion
                     }
-                    else 
+                    else
                     {
                         // round robin schedule the build request 
                         nodeUsed = (lastUsedNode % nodes.Length);
-                        
+
                         // Running total of the number of times this round robin scheduler has been called
                         lastUsedNode++;
 
@@ -210,7 +209,7 @@ internal void NotifyOfSchedulingDecision(BuildRequest currentRequest, int nodeUs
             // Update the records
             ScheduleRecordKey recordKey = new ScheduleRecordKey(currentRequest.HandleId, currentRequest.RequestId);
             ScheduleRecordKey parentKey = new ScheduleRecordKey(currentRequest.ParentHandleId, currentRequest.ParentRequestId);
-            ScheduleRecord record = new ScheduleRecord(recordKey, parentKey, nodeUsed, currentRequest.ProjectFileName, 
+            ScheduleRecord record = new ScheduleRecord(recordKey, parentKey, nodeUsed, currentRequest.ProjectFileName,
                                                        currentRequest.ToolsetVersion, currentRequest.TargetNames);
 
             lock (scheduleTableLock)
@@ -266,7 +265,7 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                         ErrorUtilities.VerifyThrow(handleIdToScheduleRecord.ContainsKey(scheduleRecord.ParentKey),
                                                    "Parent schedule record should be in the table");
                         ScheduleRecord parentRecord = handleIdToScheduleRecord[scheduleRecord.ParentKey];
-                        
+
                         // As long as there are child requests under the parent request the parent request is considered blocked
                         // Remove this build request from the list of requests the parent request is waiting on. This may unblock the parent request
                         parentRecord.ReportChildCompleted(recordKey);
@@ -283,16 +282,15 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                 // Dump some interesting information to the console if profile build is turned on by an environment variable
                 if (parentEngine.ProfileBuild && scheduleRecord != null && buildResult.TaskTime != 0 )
                 {
-
                     Console.WriteLine("N " + scheduleRecord.EvaluationNode + " Name " + scheduleRecord.ProjectName + ":" +
-                                      scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId + 
+                                      scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId +
                                       " Total " + buildResult.TotalTime + " Engine " + buildResult.EngineTime + " Task " + buildResult.TaskTime);
                 }
             }
         }
 
         /// <summary>
-        /// Called when the engine is in the process of sending a buildRequest to a child node. The entire purpose of this method 
+        /// Called when the engine is in the process of sending a buildRequest to a child node. The entire purpose of this method
         /// is to switch the traversal strategy of the systems if there are nodes which do not have enough work availiable to them.
         /// </summary>
         internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, int parentHandleId)
@@ -302,7 +300,7 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
             if (totalRequestsPerNode != null)
             {
                 // Check if it makes sense to switch from one traversal strategy to the other
-                if (parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal == true)
+                if (parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal)
                 {
                     // Check if a switch to depth first traversal is in order
                     bool useBreadthFirstTraversal = false;
@@ -317,14 +315,14 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
                         }
                     }
 
-                    if (useBreadthFirstTraversal == false)
+                    if (!useBreadthFirstTraversal)
                     {
                         if (Engine.debugMode)
                         {
                              Console.WriteLine("Switching to depth first traversal because all node have workitems");
                         }
                         parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal = false;
-                        
+
                         // Switch to depth first and change the traversal strategy of the entire system by notifying all child nodes of the change
                         parentEngine.PostEngineCommand(new ChangeTraversalTypeCommand(false, false));
                     }
@@ -412,7 +410,7 @@ internal void DumpState()
         #region Data
 
         /// <summary>
-        /// NodeId of the engine who instantiated the scheduler. This is used to determine if a 
+        /// NodeId of the engine who instantiated the scheduler. This is used to determine if a
         /// BuildRequest should be build locally as the project has already been loaded on this node.
         /// </summary>
         private int localNodeId;
@@ -430,10 +428,10 @@ internal void DumpState()
         private int[] totalRequestsPerNode;
 
         /// <summary>
-        /// The number of BuildRequests blocked waiting for results for each node. 
+        /// The number of BuildRequests blocked waiting for results for each node.
         /// This will be incremented once when a build request is scheduled which was generated as part of a msbuild callback
         /// and once for each call to NotifyOfBlockedRequest.
-        /// 
+        ///
         /// It is decremented for each call to NotifyOfUnblockedRequest and once all of the child requests have been fullfilled.
         /// </summary>
         private int[] blockedRequestsPerNode;
@@ -460,8 +458,8 @@ internal void DumpState()
         private Dictionary<ScheduleRecordKey, ScheduleRecord> handleIdToScheduleRecord;
 
         /// <summary>
-        /// Indicates the scheduler is instantiated on a child node. This is being determined by 
-        /// initializaing the variable to true in the constructor and then setting it to false in the 
+        /// Indicates the scheduler is instantiated on a child node. This is being determined by
+        /// initializaing the variable to true in the constructor and then setting it to false in the
         /// initialize method (the initialize method will only be called on the parent engine)
         /// </summary>
         private bool childMode;
@@ -476,7 +474,6 @@ internal void DumpState()
         /// </summary>
         private const int nodeWorkLoadProjectCount = 4;
 
-        
         /// <summary>
         /// Used to calculate which node a build request should be sent to if the scheduler is operating in a round robin fashion.
         /// Each time a build request is scheduled to a node in CalculateNodeForBuildRequest the lastUsedNode is incremented.
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index fcf77939cb8..3558e20e889 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -226,7 +226,7 @@ bool        importedFromAnotherProject
             }
 
             // It's considered an error if a target does not have a name.
-            ProjectErrorUtilities.VerifyThrowInvalidProject((targetName != null) && (targetName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(targetName),
                 targetElement, "MissingRequiredAttribute", XMakeAttributes.name, XMakeElements.target);
 
             this.taskElementList = new ArrayList();
@@ -492,7 +492,6 @@ internal BuildState TargetBuildState
             }
         }
 
-
         internal TargetExecutionWrapper ExecutionState
         {
             get
@@ -601,7 +600,7 @@ ProjectBuildState buildContext
                          buildContext.NameOfBlockingTarget == null))
                     {
                         error.VerifyThrow(
-                            String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), this.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                            String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), this.Name, StringComparison.OrdinalIgnoreCase),
                             "The name of the target in progress is inconsistent with the target being built");
 
                         error.VerifyThrow(targetOutputItems != null,
@@ -732,11 +731,11 @@ internal void MarkTargetAsDirty
             (
             )
         {
-            if (this.ParentProject != null)
-            {
+               
+            
                 // This is a change to the contents of the project file.
-                this.ParentProject.MarkProjectAsDirty();
-            }
+                this.ParentProject?.MarkProjectAsDirty();
+            
         }
 
         /// <summary>
@@ -779,7 +778,7 @@ string taskName
             )
         {
             error.VerifyThrow(this.taskElementList != null, "Arraylist not initialized!");
-            error.VerifyThrowArgumentLength(taskName, "taskName");
+            error.VerifyThrowArgumentLength(taskName, nameof(taskName));
 
             // Confirm that it's not an imported target.
             error.VerifyThrowInvalidOperation(!this.IsImported, "CannotModifyImportedProjects");
@@ -812,7 +811,7 @@ BuildTask taskElement
             error.VerifyThrowInvalidOperation(!this.IsImported, "CannotModifyImportedProjects");
 
             error.VerifyThrow(this.taskElementList != null, "Arraylist not initialized!");
-            error.VerifyThrowArgumentNull(taskElement, "taskElement");
+            error.VerifyThrowArgumentNull(taskElement, nameof(taskElement));
 
             // Confirm that the BuildTask belongs to this Target.
             error.VerifyThrowInvalidOperation(taskElement.ParentTarget == this,
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index ed38ed7f986..d7aedf2f70d 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -159,7 +159,6 @@ public IEnumerator GetEnumerator
             return this.targetTable.Values.GetEnumerator();
         }
 
-
         /// <summary>
         /// Adds a new Target to our collection.  This method does nothing
         /// to manipulate the project's XML content.
@@ -218,7 +217,7 @@ public void RemoveTarget
             Target targetToRemove
         )
         {
-            error.VerifyThrowArgumentNull(targetToRemove, "targetToRemove");
+            error.VerifyThrowArgumentNull(targetToRemove, nameof(targetToRemove));
 
             // Confirm that it's not an imported target.
             error.VerifyThrowInvalidOperation(!targetToRemove.IsImported,
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 377fe8f63ad..1b8deddab72 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -238,7 +238,7 @@ out Hashtable upToDateTargetInputs
                 // 1) they do not reference any item vector
                 // 2) they reference item vectors that are not referenced by any input item
                 if ((discreteItemsInTargetOutputs.Count > 0) ||
-                    ((itemVectorsReferencedOnlyInTargetOutputs != null) && (itemVectorsReferencedOnlyInTargetOutputs.Count > 0)))
+                    ((itemVectorsReferencedOnlyInTargetOutputs?.Count > 0)))
                 {
                     result = PerformDependencyAnalysisIfDiscreteOutputs(
                                 itemVectorsInTargetInputs, itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs,
@@ -609,7 +609,6 @@ out Hashtable upToDateTargetInputs
 
                             for (int i = 0; i < inputItemsAssumedToBeUpToDate.Length; i++)
                             {
-
                                 // if we haven't already determined that this input item has changed
                                 if (inputItemsAssumedToBeUpToDate[i] != null)
                                 {
@@ -720,7 +719,6 @@ ArrayList targetOutputItemSpecs
                     loggingService.LogComment(buildEventContext, "BuildTargetCompletely", this.targetToAnalyze.Name);
                     loggingService.LogComment(buildEventContext, "BuildTargetCompletelyNoInputsSpecified");
 
-
                     // otherwise, do a full build
                     result = DependencyAnalysisResult.FullBuild;
                 }
@@ -1140,7 +1138,7 @@ private void RecordComparisonResults(string input, string output, string inputIt
         /// </returns>
         private int CompareLastWriteTimes(string path1, string path2, out bool path1DoesNotExist, out bool path2DoesNotExist)
         {
-            ErrorUtilities.VerifyThrow((path1 != null) && (path1.Length > 0) && (path2 != null) && (path2.Length > 0),
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(path1) && !string.IsNullOrEmpty(path2),
                 "Need to specify paths to compare.");
 
             FileInfo path1Info = null;
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index d9456bffd51..2844e472df7 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -576,7 +576,7 @@ private void InitializeForRunningSingleTargetBatch()
                 // if we're doing an incremental build, we need to effectively run the task twice -- once
                 // to infer the outputs for up-to-date input items, and once to actually execute the task;
                 // as a result we need separate sets of item and property collections to track changes
-                if (howToBuild == DependencyAnalysisResult.IncrementalBuild)    
+                if (howToBuild == DependencyAnalysisResult.IncrementalBuild)
                 {
                     // subset the relevant items to those that are up-to-date
                     foreach (DictionaryEntry upToDateTargetInputsEntry in upToDateTargetInputs)
@@ -713,7 +713,7 @@ private TaskExecutionMode DetermineExecutionMode()
             if ((howToBuild == DependencyAnalysisResult.FullBuild) ||
                 (howToBuild == DependencyAnalysisResult.IncrementalBuild))
             {
-                executionMode = executionMode | TaskExecutionMode.ExecuteTaskAndGatherOutputs;
+                executionMode |= TaskExecutionMode.ExecuteTaskAndGatherOutputs;
             }
             return executionMode;
         }
@@ -740,7 +740,7 @@ private void ExecuteIntrinsicTask(XmlElement taskNode)
             BuildEventContext buildEventContext = PrepareBuildEventContext(true);
             TaskExecutionMode executionMode = DetermineExecutionMode();
 
-            IntrinsicTask task = new IntrinsicTask(taskNode, 
+            IntrinsicTask task = new IntrinsicTask(taskNode,
                                                    parentEngine.LoggingServices,
                                                    buildEventContext,
                                                    parentProject.ProjectDirectory,
@@ -826,10 +826,10 @@ private void ProcessTaskOutputs(TaskExecutionContext executionContext)
                             // by bad user input), the build should be terminated. The exception
                             // will be logged as a fatal build error in engine. The exceptions caused
                             // by user code are converted into LogFatalTaskError messages by the TaskEngine
-                            RemoteErrorException.Throw(executionContext.ThrownException, 
-                                                       targetBuildEventContext, 
+                            RemoteErrorException.Throw(executionContext.ThrownException,
+                                                       targetBuildEventContext,
                                                        "RemoteErrorDuringTaskExecution",
-                                                       parentProject.FullFileName, 
+                                                       parentProject.FullFileName,
                                                        targetClass.Name);
                         }
                     }
@@ -889,7 +889,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
             foreach (ItemBucket bucket in buckets)
             {
                 bucket.Lookup.LeaveScope();
-            }         
+            }
 
             // and also leave the extra scope we created with the cloned project items
             projectContent.LeaveScope();
@@ -909,7 +909,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
                     buildContext.NameOfBlockingTarget == null)
                 {
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "The name of the target in progress is inconsistent with the target being built");
 
                     ErrorUtilities.VerifyThrow(targetOutputItems != null,
@@ -979,7 +979,7 @@ internal List<ProjectBuildState> GetWaitingBuildContexts()
         }
 
         /// <summary>
-        /// Iterate over the contexts waiting for the target - triggering updates for each of them since the target 
+        /// Iterate over the contexts waiting for the target - triggering updates for each of them since the target
         /// is complete
         /// </summary>
         internal void NotifyWaitingTargets(ProjectBuildState errorContext)
@@ -1008,7 +1008,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 {
                     continue;
                 }
-                
+
                 parentEngine.Scheduler.NotifyOfUnblockedRequest(buildContext.BuildRequest);
 
                 ErrorUtilities.VerifyThrow(
@@ -1019,7 +1019,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 if (buildContext.NameOfBlockingTarget == null)
                 {
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "The name of the target in progress is inconsistent with the target being built");
 
                     // This target was part of a sequential request so we need to notify the parent project
@@ -1035,7 +1035,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                     // The target on the waiting list must be waiting for this target to complete due to
                     // a dependent or onerror relationship between targets
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(buildContext.NameOfBlockingTarget, targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(buildContext.NameOfBlockingTarget, targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "This target should only be updated once the dependent target is completed");
 
                     if (Engine.debugMode)
@@ -1045,8 +1045,8 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 }
 
                 // Post a dummy context to the queue to cause the target to run in this context
-                TaskExecutionContext taskExecutionContext = 
-                    new TaskExecutionContext(parentProject, null, null, buildContext, 
+                TaskExecutionContext taskExecutionContext =
+                    new TaskExecutionContext(parentProject, null, null, buildContext,
                                              EngineCallback.invalidEngineHandle, EngineCallback.inProcNode, null);
                 parentEngine.PostTaskOutputUpdates(taskExecutionContext);
             }
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 54396fee8ad..6b4cee24ada 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -30,7 +30,7 @@ namespace Microsoft.Build.BuildEngine
     internal enum TaskExecutionMode
     {
         /// <summary>
-        /// This entry is necessary to use the enum with binary math. It is never used outside 
+        /// This entry is necessary to use the enum with binary math. It is never used outside
         /// intermediate calculations.
         /// </summary>
         Invalid = 0,
@@ -159,7 +159,7 @@ private List<string> CreateListOfParameterValues()
         /// 2) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by exact name
         /// 3) checks the tasks declared by the project, searching by fuzzy match (missing namespace, etc.)
         /// 4) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by fuzzy match (missing namespace, etc.)
-        /// 
+        ///
         /// The search ordering is meant to reduce the number of assemblies we scan, because loading assemblies can be expensive.
         /// The tasks and assemblies declared by the project are scanned first, on the assumption that if the project declared
         /// them, they are likely used.
@@ -254,7 +254,7 @@ private AppDomain PrepareAppDomain()
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
         internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
@@ -278,7 +278,7 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
                 {
                     lookupHash = Utilities.CreateTableIfNecessary((Hashtable)null);
                 }
-		
+
 		// Loop through each of the batch buckets and execute them one at a time
                 for (int i=0; i < buckets.Count; i++)
                 {
@@ -293,15 +293,9 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
             finally
             {
                 // Remove the AssemblyResolve handler in the default AppDomain, we are done with the task.
-                if (resolver != null)
-                {
-                    resolver.RemoveHandler();
-                }
+                resolver?.RemoveHandler();
 
-                if (engineProxy != null)
-                {
-                    engineProxy.MarkAsInActive();
-                }
+                engineProxy?.MarkAsInActive();
 
                 // Now all task batches are done, apply all item adds to the outer 
                 // target batch; we do this even if the task wasn't found (in that case,
@@ -665,7 +659,6 @@ private bool InitializeTaskParameters(ITask task, ItemBucket bucket)
             return taskInitialized;
         }
 
-
         /// <summary>
         /// Finds all the task properties that are required.
         /// Returns them as keys in a dictionary.
@@ -985,7 +978,6 @@ internal bool GatherGeneratedTaskOutputs
             return gatheredGeneratedOutputsSuccessfully;
         }
 
-
         private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutputSpecification, string itemName, string propertyName, PropertyInfo parameter, object outputs)
         {
             // if the task has generated outputs (if it didn't, don't do anything)
@@ -997,7 +989,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     // to store the outputs as items, use the string representations of the outputs as item-specs
                     foreach (object output in convertibleOutputs)
@@ -1018,7 +1010,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     // to store an object array in a property, join all the string representations of the objects with
                     // semi-colons to make the property value
@@ -1055,7 +1047,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     foreach (ITaskItem output in taskItemOutputs)
                     {
@@ -1069,7 +1061,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     // to store an ITaskItem array in a property, join all the item-specs with semi-colons to make the
                     // property value, and ignore/discard the attributes on the ITaskItems
@@ -1119,20 +1111,19 @@ ItemBucket bucket
             // DevDiv bugs: 33981
             foreach (XmlAttribute taskNodeAttribute in taskNode.Attributes)
             {
-                if (String.Compare(taskNodeAttribute.Name, taskParameterName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(taskNodeAttribute.Name, taskParameterName, StringComparison.OrdinalIgnoreCase))
                 {
                     taskParameterAttribute = taskNodeAttribute;
                     break;
                 }
             }
- 
+
             if (taskParameterAttribute != null)
             {
                 if (taskOutputSpecification.IsItemVector)
                 {
                     // This is an output item.
-
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     // Expand only with properties first, so that expressions like Include="@(foo)" will transfer the metadata of the "foo" items as well, not just their item specs.
                     Expander propertyAndMetadataExpander = new Expander(bucket.Expander, ExpanderOptions.ExpandPropertiesAndMetadata);
@@ -1165,9 +1156,8 @@ ItemBucket bucket
                 else
                 {
                     // This is an output property.
-
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     string taskParameterValue = bucket.Expander.ExpandAllIntoString(taskParameterAttribute);
 
@@ -1224,7 +1214,6 @@ private List<TaskOutput> GetTaskOutputSpecifications(bool showWarnings)
             return taskOutputSpecifications;
         }
 
-
         /// <summary>
         /// Given an instantiated task, this helper method sets the specified parameter based on its type.
         /// </summary>
@@ -1590,8 +1579,8 @@ object parameterValue
         }
 
         /// <summary>
-        /// This function correctly computes the line/column number of the task node 
-        /// in the project file (or .TARGETS file) that called it. The XmlNode available 
+        /// This function correctly computes the line/column number of the task node
+        /// in the project file (or .TARGETS file) that called it. The XmlNode available
         /// to the task engine lacks this information so we call back into the build engine
         /// to obtain it.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
index 47694f4d3d3..1f014fc5526 100644
--- a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
@@ -38,10 +38,10 @@ internal void Initialize(string taskAssemblyFileToResolve)
         }
 
         /// <summary>
-        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain, 
+        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain,
         /// so it's possible to create an AppDomain, create an instance of this class in it and use this method to install
         /// an event handler in that AppDomain. Since the event handler instance is stored internally, this method
-        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do 
+        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do
         /// anything else).
         /// </summary>
         /// <owner>lukaszg</owner>
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 9c1c984d50c..0f35fb5e17c 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -30,7 +30,7 @@ internal class TaskExecutionModule
         /// </summary>
         internal TaskExecutionModule
         (
-            EngineCallback engineCallback, 
+            EngineCallback engineCallback,
             TaskExecutionModuleMode moduleMode,
             bool profileExecution
         )
@@ -128,7 +128,7 @@ internal bool UseBreadthFirstTraversal
         }
 
         /// <summary>
-        /// Returns true if the TEM doesn't have a thread in user code and there are no pending 
+        /// Returns true if the TEM doesn't have a thread in user code and there are no pending
         /// workitems
         /// </summary>
         internal bool IsIdle
@@ -140,7 +140,7 @@ internal bool IsIdle
         }
 
         /// <summary>
-        /// Return total time spent executing the tasks by this TEM. This value is only valid if the TEM is created with 
+        /// Return total time spent executing the tasks by this TEM. This value is only valid if the TEM is created with
         /// profileExecution set to true, otherwise this value will be 0
         /// </summary>
         internal long TaskExecutionTime
@@ -155,7 +155,7 @@ internal long TaskExecutionTime
         #region Method used internally inside the TEM boundary (i.e. not called from the engine)
 
         /// <summary>
-        /// This method passes the task outputs to the engine, it is virtual for testing purposes to 
+        /// This method passes the task outputs to the engine, it is virtual for testing purposes to
         /// create a mock TEM
         /// </summary>
         virtual internal void PostTaskOutputs
@@ -176,15 +176,15 @@ long executionTime
         /// <returns>result of call to engine</returns>
         virtual internal bool BuildProjectFile
         (
-            int handleId, 
-            string[] projectFileNames, 
-            string[] targetNames, 
+            int handleId,
+            string[] projectFileNames,
+            string[] targetNames,
             IDictionary[] globalPropertiesPerProject,
             IDictionary[] targetOutputsPerProject,
             EngineLoggingServices loggingServices,
             string [] toolsVersions,
             bool useResultsCache,
-            bool unloadProjectsOnCompletion, 
+            bool unloadProjectsOnCompletion,
             BuildEventContext taskContext
         )
         {
@@ -226,7 +226,7 @@ BuildEventContext taskContext
 
                 buildRequests[i] = new BuildRequest(handleId, fullProjectName, targetNames, globalPropertiesPerProject[i],
                                                     toolsVersions[i], i, useResultsCache, unloadProjectsOnCompletion);
-                ErrorUtilities.VerifyThrow(buildRequests[i].IsGeneratedRequest == true, "Should not be sending non generated requests from TEM to engine");
+                ErrorUtilities.VerifyThrow(buildRequests[i].IsGeneratedRequest, "Should not be sending non generated requests from TEM to engine");
                 buildRequests[i].ParentBuildEventContext = taskContext;
             }
 
@@ -290,16 +290,16 @@ BuildEventContext taskContext
 
             return overallResult;
         }
-       
+
        /// <summary>
        /// Once the buildRequests from the EngineCallback have been created they are sent to this method which will
        /// post the build requests to the parent engine and then wait on the results to come back.
        /// This method uses either a breadthFirst or depthFirst traversal strategy when sending buildRequests to the parent engine.
        /// This method will start in breadthFirst traversal. It will continue to use this strategy until one of two events occur:
-       ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal. 
+       ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal.
        ///     2. The number of buildRequests is larger than the batchRequestSize.
        /// In both of these cases the system will go from a breadthFirstTraversal to a depthFirst Traversal. In the second case
-       /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to 
+       /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to
        /// be overloaded with work.
        /// In a depth first strategy the buildRequests will be sent to the parent engine one at a time and waiting for results for
        /// each buildRequest sent. In a breadthFirst traversal strategy some number of the buildrequests will be sent to the parent engine
@@ -310,7 +310,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
         {
             // If the traversal strategy is breadth first and the number of requests is less than the batchRequestSize
             // or if there is only 1 build request then send ALL build requests to the parent engine and wait on the results.
-            if ((breadthFirstTraversal == true && buildRequests.Length < batchRequestSize) || buildRequests.Length == 1)
+            if ((breadthFirstTraversal && buildRequests.Length < batchRequestSize) || buildRequests.Length == 1)
             {
                 engineCallback.PostBuildRequestsToHost(buildRequests);
                 workerThread.WaitForResults(handleId, buildResultsLocal, buildRequests);
@@ -319,7 +319,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
             {
                 int currentRequestIndex = 0; // Which build request is being processed
                 int numberOfRequestsToSend = 0; // How many buildRequests are going to be sent based on the number of buildRequests remaining and the build request batch size.
-                
+
                 // Arrays that will be used to partion the buildRequests array when sending batches of builds requests at a time.
                 BuildRequest[] wrapperArrayBreadthFirst = new BuildRequest[batchRequestSize];
                 BuildResult[] resultsArrayBreadthFirst = new BuildResult[batchRequestSize];
@@ -332,7 +332,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                 while (currentRequestIndex < buildRequests.Length)
                 {
                     // If there is a breadth first traversal and there are more than batchRequestSize build requests, send the first batchRequestSize, then do the rest depth first
-                    if (breadthFirstTraversal == true)
+                    if (breadthFirstTraversal)
                     {
                         // Figure out how many requests to send, either the full batch size or only part of a batch
                         numberOfRequestsToSend = (buildRequests.Length - currentRequestIndex) <batchRequestSize ? (buildRequests.Length - currentRequestIndex) : batchRequestSize;
@@ -343,7 +343,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                             wrapperArrayBreadthFirst = new BuildRequest[numberOfRequestsToSend];
                             resultsArrayBreadthFirst = new BuildResult[numberOfRequestsToSend];
                         }
-                        
+
                         // Fill the wrapper array with one batch of build requests
                         for (int i = 0; i < numberOfRequestsToSend; i++)
                         {
@@ -353,14 +353,14 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                         }
 
                         engineCallback.PostBuildRequestsToHost(wrapperArrayBreadthFirst);
-                        
+
                         // Only switch from breadth to depth if there are more thanbatchRequestSize items
                         if ((buildRequests.Length - currentRequestIndex) > batchRequestSize)
                         {
                             engineCallback.PostStatus(nodeId, new NodeStatus(false /* use depth first traversal*/), false /* don't block waiting on the send */);
                             breadthFirstTraversal = false;
                         }
-                        
+
                         workerThread.WaitForResults(handleId, resultsArrayBreadthFirst, wrapperArrayBreadthFirst);
                         Array.Copy(resultsArrayBreadthFirst, 0, buildResultsLocal, currentRequestIndex, numberOfRequestsToSend);
                         currentRequestIndex += numberOfRequestsToSend;
@@ -434,8 +434,8 @@ internal bool RethrowTaskExceptions()
 
         #region Methods called from the engine
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, 
-        /// and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters,
+        /// and executes it.
         /// </summary>
         /// <param name="taskState"></param>
         public void ExecuteTask(TaskExecutionState taskState)
@@ -648,12 +648,12 @@ internal TaskWorkerThread GetWorkerThread()
 
         /// <summary>
         /// In a multiproc build this is the maximum number of build requests which will be sent at a time to the parent engine
-        /// A default of 10 was an arbitrary number but turned out to be a good balance between being too small 
+        /// A default of 10 was an arbitrary number but turned out to be a good balance between being too small
         /// causing the system to run out of work too quickly and being too big and flooding the system with requests.
         /// </summary>
         private const int defaultBatchRequestSize = 10;
         private int batchRequestSize = defaultBatchRequestSize;
-        
+
         /// <summary>
         /// The nodeId of the node the TaskExecutionModule is running on
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index 69e52ef45ae..588c848c5b0 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -331,7 +331,6 @@ public void RegisterTask(UsingTask usingTask, Expander expander, EngineLoggingSe
                             "InvalidAttributeValueWithException", assemblyFile,
                             XMakeAttributes.assemblyFile, XMakeElements.usingTask, ex.Message);
                     }
-
                 }
 
                 AssemblyLoadInfo taskAssembly = new AssemblyLoadInfo(assemblyName, assemblyFile);
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index 4be9db73912..d49e9d6992c 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -142,7 +142,7 @@ internal int WorkItemCount
 
         /// <summary>
         /// This a base loop of a worker thread. The worker thread is asleep waiting for either an
-        /// event indicating that it should shut down or that it should become active and take 
+        /// event indicating that it should shut down or that it should become active and take
         /// ownership of the work item queue
         /// </summary>
         private void MainThreadLoop()
@@ -308,12 +308,11 @@ private WaitHandle [] GetHandlesArray( NodeLoopExecutionMode executionMode )
         /// </summary>
         private void NodeActionLoop
         (
-            NodeLoopExecutionMode executionMode, 
-            int handleId, 
+            NodeLoopExecutionMode executionMode,
+            int handleId,
             BuildResult [] buildResults
         )
         {
-
             // Create an array of event to the node thread responds
             WaitHandle[] waitHandles = GetHandlesArray(executionMode);
 
@@ -331,7 +330,7 @@ BuildResult [] buildResults
                     entryTime = DateTime.Now.Ticks;
                 }
             }
-            
+
             bool continueExecution = true;
             while (continueExecution)
             {
@@ -431,7 +430,7 @@ BuildResult [] buildResults
                     {
                         LinkedListNode<BuildResult> currentNode = postedBuildResults.First;
                         while (currentNode != null)
-                        {   
+                        {
                             BuildResult buildResult = currentNode.Value;
                             ErrorUtilities.VerifyThrow(
                                             buildResult.RequestId < buildResults.Length,
@@ -455,7 +454,7 @@ BuildResult [] buildResults
                     }
                 }
                 // Check if we need to update the state
-                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive) 
+                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive)
                 {
                     continueExecution = false;
                 }
@@ -501,7 +500,7 @@ internal void ActivateThread()
         /// </summary>
         internal void WaitForResults
         (
-            int handleId, 
+            int handleId,
             BuildResult[] buildResults,
             BuildRequest [] buildRequests
         )
@@ -513,7 +512,7 @@ BuildRequest [] buildRequests
             {
                 waitingTasks.Add(handleId, taskData);
             }
-            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread : 
+            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread :
                                         NodeLoopExecutionMode.WaitingPassiveThread,
                                         handleId, buildResults);
             lock (waitingTasks)
diff --git a/src/Deprecated/Engine/Engine/Toolset.cs b/src/Deprecated/Engine/Engine/Toolset.cs
index 89764055263..6e96c01f231 100644
--- a/src/Deprecated/Engine/Engine/Toolset.cs
+++ b/src/Deprecated/Engine/Engine/Toolset.cs
@@ -40,8 +40,8 @@ public Toolset(string toolsVersion, string toolsPath)
         /// May be null, in which case an empty property group will be used.</param>
         public Toolset(string toolsVersion, string toolsPath, BuildPropertyGroup buildProperties)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
-            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, "toolsPath");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
+            ErrorUtilities.VerifyThrowArgumentLength(toolsPath, nameof(toolsPath));
 
             this.toolsVersion = toolsVersion;
             this.ToolsPath = toolsPath;
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index f7c5e536f51..c9025f7c3f6 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -40,7 +40,7 @@ private ToolsetCollection()
         /// <param name="parentEngine"></param>
         internal ToolsetCollection(Engine parentEngine)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parentEngine, "parentEngine");
+            ErrorUtilities.VerifyThrowArgumentNull(parentEngine, nameof(parentEngine));
 
             this.parentEngine = parentEngine;
             this.toolsetMap = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -66,7 +66,7 @@ public Toolset this[string toolsVersion]
         {
             get
             {
-                ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
+                ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
 
                 if (this.toolsetMap.ContainsKey(toolsVersion))
                 {
@@ -121,7 +121,7 @@ public bool IsReadOnly
         /// <param name="item"></param>
         public void Add(Toolset item)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(item, "item");
+            ErrorUtilities.VerifyThrowArgumentNull(item, nameof(item));
 
             if (toolsetMap.ContainsKey(item.ToolsVersion))
             {
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index ef382bd585a..7dae6d2bb1d 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -33,7 +33,7 @@ internal ToolsetConfigurationReader()
         /// <param name="readApplicationConfiguration"></param>
         internal ToolsetConfigurationReader(ReadApplicationConfiguration readApplicationConfiguration)
         {
-            error.VerifyThrowArgumentNull(readApplicationConfiguration, "readApplicationConfiguration");
+            error.VerifyThrowArgumentNull(readApplicationConfiguration, nameof(readApplicationConfiguration));
             this.readApplicationConfiguration = readApplicationConfiguration;
         }
 
@@ -55,7 +55,7 @@ protected override IEnumerable<PropertyDefinition> ToolsVersions
                                               toolset.ElementInformation.LineNumber
                                           );
 
-                        if (toolset.toolsVersion != null && toolset.toolsVersion.Length == 0)
+                        if (toolset.toolsVersion?.Length == 0)
                         {
                             InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location);
                         }
@@ -104,7 +104,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
                                       propertyElement.ElementInformation.LineNumber
                                   );
 
-                if (propertyElement.Name != null && propertyElement.Name.Length == 0)
+                if (propertyElement.Name?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location);
                 }
@@ -387,7 +387,7 @@ public string toolsVersion
             }
             set
             {
-                base["toolsVersion"] = value;
+                base[nameof(toolsVersion)] = value;
             }
         }
 
diff --git a/src/Deprecated/Engine/Engine/ToolsetReader.cs b/src/Deprecated/Engine/Engine/ToolsetReader.cs
index f573b78cc11..fbeecd62a08 100644
--- a/src/Deprecated/Engine/Engine/ToolsetReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetReader.cs
@@ -19,12 +19,12 @@ internal class PropertyDefinition
 
         public PropertyDefinition(string name, string value, string source)
         {
-            error.VerifyThrowArgumentLength(name, "name");
-            error.VerifyThrowArgumentLength(source, "source");
+            error.VerifyThrowArgumentLength(name, nameof(name));
+            error.VerifyThrowArgumentLength(source, nameof(source));
 
             // value can be the empty string but not null
-            error.VerifyThrowArgumentNull(value, "value");
-            
+            error.VerifyThrowArgumentNull(value, nameof(value));
+
             this.name = name;
             this.value = value;
             this.source = source;
@@ -54,7 +54,7 @@ public string Value
 
         /// <summary>
         /// A description of the location where the property was defined,
-        /// such as a registry key path or a path to a config file and 
+        /// such as a registry key path or a path to a config file and
         /// line number.
         /// </summary>
         public string Source
@@ -65,7 +65,7 @@ public string Source
             }
         }
     }
-    
+
     internal abstract class ToolsetReader
     {
         /// <summary>
@@ -140,12 +140,12 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                 // We do not accumulate properties when reading them from the registry, because the order
                 // in which values are returned to us is essentially random: so we disallow one property
                 // in the registry to refer to another also in the registry
-                defaultToolsVersionFromRegistry = 
+                defaultToolsVersionFromRegistry =
                     registryReaderToUse.ReadToolsets(toolsets, globalProperties, initialProperties, false /* do not accumulate properties */);
             }
 
             string defaultToolsVersionFromConfiguration = null;
-            
+
             ToolsetConfigurationReader configurationReaderToUse = null;
             if ((locations & ToolsetDefinitionLocations.ConfigurationFile) == ToolsetDefinitionLocations.ConfigurationFile)
             {
@@ -165,7 +165,7 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                         configurationReaderToUse.ReadToolsets(toolsets, globalProperties, initialProperties, true /* accumulate properties */);
                 }
             }
-            
+
             // We'll use the default from the configuration file if it was specified, otherwise we'll try
             // the one from the registry.  It's possible (and valid) that neither the configuration file
             // nor the registry specify a default, in which case we'll just return null.
@@ -209,9 +209,9 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
         }
 
         /// <summary>
-        /// Creating a ToolsetConfigurationReader, and also reading toolsets from the 
-        /// configuration file, are a little expensive. To try to avoid this cost if it's 
-        /// not necessary, we'll check if the file exists first. If it exists, we'll scan for 
+        /// Creating a ToolsetConfigurationReader, and also reading toolsets from the
+        /// configuration file, are a little expensive. To try to avoid this cost if it's
+        /// not necessary, we'll check if the file exists first. If it exists, we'll scan for
         /// the string "toolsVersion" to see if it might actually have any tools versions
         /// defined in it.
         /// </summary>
@@ -252,7 +252,7 @@ internal string ReadToolsets(ToolsetCollection toolsets,
                                      BuildPropertyGroup initialProperties,
                                      bool accumulateProperties)
         {
-            error.VerifyThrowArgumentNull(toolsets, "toolsets");
+            error.VerifyThrowArgumentNull(toolsets, nameof(toolsets));
 
             ReadEachToolset(toolsets, globalProperties, initialProperties, accumulateProperties);
 
@@ -265,7 +265,7 @@ internal string ReadToolsets(ToolsetCollection toolsets,
             // they'll get a nice error saying that toolset isn't available and listing those that are.
             return defaultToolsVersion;
         }
-        
+
         /// <summary>
         /// Reads all the toolsets and populates the given ToolsetCollection with them
         /// </summary>
@@ -313,13 +313,13 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
             string toolsPath = null;
             string binPath = null;
             BuildPropertyGroup properties = new BuildPropertyGroup();
-            
+
             IEnumerable<PropertyDefinition> rawProperties = GetPropertyDefinitions(toolsVersion.Name);
             Expander expander = new Expander(initialProperties);
 
             foreach (PropertyDefinition property in rawProperties)
             {
-                if (0 == String.Compare(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
                 {
                     toolsPath = ExpandProperty(property, expander);
                     toolsPath = ExpandRelativePathsRelativeToExeLocation(toolsPath);
@@ -334,7 +334,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                         );
                     }
                 }
-                else if (0 == String.Compare(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
                 {
                     binPath = ExpandProperty(property, expander);
                     binPath = ExpandRelativePathsRelativeToExeLocation(binPath);
@@ -360,7 +360,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                     // It's an arbitrary property
                     string propertyValue = ExpandProperty(property, expander);
                     PropertyDefinition expandedProperty = new PropertyDefinition(property.Name, propertyValue, property.Source);
-                    
+
                     SetProperty(expandedProperty, properties, globalProperties);
 
                     if (accumulateProperties)
@@ -368,7 +368,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                         SetProperty(expandedProperty, initialProperties, globalProperties);
                     }
                 }
-                
+
                 if (accumulateProperties)
                 {
                     expander = new Expander(initialProperties);
@@ -388,7 +388,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
             }
 
             Toolset toolset = null;
-            
+
             try
             {
                 toolset = new Toolset(toolsVersion.Name, toolsPath == null ? binPath : toolsPath, properties);
diff --git a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
index bb45c98d08a..075f4754872 100644
--- a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
@@ -51,7 +51,7 @@ internal ToolsetRegistryReader()
         /// <param name="msbuildRegistryWrapper"></param>
         internal ToolsetRegistryReader(RegistryKeyWrapper msbuildRegistryWrapper)
         {
-            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, "msbuildRegistryWrapper");
+            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
        
             this.msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
@@ -125,7 +125,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
             {
                 string propertyValue = null;
 
-                if (propertyName != null && propertyName.Length == 0)
+                if (propertyName?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("PropertyNameInRegistryHasZeroLength", toolsVersionWrapper.Name);
                 }
diff --git a/src/Deprecated/Engine/Engine/ToolsetState.cs b/src/Deprecated/Engine/Engine/ToolsetState.cs
index 3bfdc74d917..062a0ef03e6 100644
--- a/src/Deprecated/Engine/Engine/ToolsetState.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetState.cs
@@ -55,7 +55,7 @@ LoadXmlFromPath loadXmlFromPath
             this.parentEngine = engine;
             this.loggingServices = engine.LoggingServices;
 
-            ErrorUtilities.VerifyThrowArgumentNull(toolset, "toolset");
+            ErrorUtilities.VerifyThrowArgumentNull(toolset, nameof(toolset));
             this.toolset = toolset;
 
             this.getFiles = getFiles;
@@ -109,7 +109,6 @@ internal BuildPropertyGroup BuildProperties
             }
         }
 
-
         #endregion
 
         #region Methods
@@ -146,7 +145,7 @@ internal ITaskRegistry GetTaskRegistry(BuildEventContext buildEventContext)
         /// <param name="taskRegistry"></param>
         internal void SetTaskRegistry(ITaskRegistry taskRegistry)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskRegistry, "taskRegistry");
+            ErrorUtilities.VerifyThrowArgumentNull(taskRegistry, nameof(taskRegistry));
             defaultTasksRegistrationAttempted = true;
             defaultTaskRegistry = taskRegistry;
         }
@@ -231,7 +230,7 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
                                     ProjectErrorUtilities.VerifyThrowInvalidProject(topLevelNode.LocalName == XMakeElements.project,
                                         topLevelNode, "UnrecognizedElement", topLevelNode.Name);
 
-                                    ProjectErrorUtilities.VerifyThrowInvalidProject((topLevelNode.Prefix.Length == 0) && (String.Compare(topLevelNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                                    ProjectErrorUtilities.VerifyThrowInvalidProject((topLevelNode.Prefix.Length == 0) && (String.Equals(topLevelNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                                         topLevelNode, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
                                     // the <Project> tag can only the XML namespace -- no other attributes
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index eb54fda085a..ce453502b25 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -476,7 +476,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the start of a comment
                         insideComment = true;
-                        i = i + 3;
+                        i += 3;
                         continue;
                     }
                 }
@@ -500,7 +500,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the end of a comment
                         insideComment = false;
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index f6a663a3ebf..2dcc8cebef1 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -239,7 +239,7 @@ out int foundColumnNumber
             )
         {
             ErrorUtilities.VerifyThrow(xmlElementNumberToSearchFor != 0, "No element to search for!");
-            ErrorUtilities.VerifyThrow((projectFile != null) && (projectFile.Length != 0), "No project file!");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(projectFile), "No project file!");
 
             // Initialize output parameters.
             foundLineNumber = 0;
@@ -282,7 +282,7 @@ out int foundColumnNumber
                                         // letter of the tag name, whereas we would prefer to point at the opening
                                         // left-angle-bracket.  (Whitespace between the left-angle-bracket and
                                         // the tag name is not allowed in XML, so this is safe.)
-                                        foundColumnNumber = foundColumnNumber - 1;
+                                        foundColumnNumber -= 1;
                                     }
                                 }
                                 else if (reader.MoveToFirstAttribute()) 
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index 54447515463..22f730e348c 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -84,19 +84,19 @@ public InternalLoggerException(string message, Exception innerException)
         /// <param name="helpKeyword"></param>
         internal InternalLoggerException
         (
-            string message, 
-            Exception innerException, 
-            BuildEventArgs e, 
-            string errorCode, 
-            string helpKeyword, 
+            string message,
+            Exception innerException,
+            BuildEventArgs e,
+            string errorCode,
+            string helpKeyword,
             bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(helpKeyword), "Must specify the help keyword for the IDE.");
 
             this.e = e;
             this.errorCode = errorCode;
@@ -107,7 +107,7 @@ bool initializationException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
@@ -220,11 +220,11 @@ public bool InitializationException
         /// <param name="messageArgs"></param>
         internal static void Throw
         (
-            Exception innerException, 
-            BuildEventArgs e, 
-            string messageResourceName, 
+            Exception innerException,
+            BuildEventArgs e,
+            string messageResourceName,
             bool initializationException,
-            params string[] messageArgs 
+            params string[] messageArgs
         )
         {
             ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index b3946d77c9c..63d3c34a620 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -137,7 +137,7 @@ string helpKeyword
         ) : 
             base(message)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(message, "message");
+            ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
 
             if (xmlNode != null)
             {
@@ -178,8 +178,8 @@ string helpKeyword
         ) : 
             base(message)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentLength(message, "message");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentLength(message, nameof(message));
 
             this.projectFile = projectFile;
             this.lineNumber = lineNumber;
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 2c54e13abf3..7e24aef9654 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -56,7 +56,7 @@ public InvalidToolsetDefinitionException(string message, Exception innerExceptio
         protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             this.errorCode = info.GetString("errorCode");
         }
@@ -93,7 +93,7 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
         override public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             base.GetObjectData(info, context);
 
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index 1e040579d39..00839224075 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -19,7 +19,7 @@ public sealed class RemoteErrorException : Exception
         internal RemoteErrorException(string message, Exception innerException, BuildEventContext buildEventContext)
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
             ErrorUtilities.VerifyThrow(innerException != null, "Need the logger exception.");
 
             this.buildEventContext = buildEventContext;
diff --git a/src/Deprecated/Engine/Introspector/Introspector.cs b/src/Deprecated/Engine/Introspector/Introspector.cs
index a829277fe83..1946f84a967 100644
--- a/src/Deprecated/Engine/Introspector/Introspector.cs
+++ b/src/Deprecated/Engine/Introspector/Introspector.cs
@@ -214,7 +214,6 @@ private void LogOrDumpError(string resourceName, params object[] args)
         /// </summary>
         private void AddTargetStatesToCycleDetector(NodeStatus[] nodeStatus, TargetCycleDetector cycleDetector)
         {
-
             for (int i = 0; i < nodeStatus.Length; i++)
             {
                cycleDetector.AddTargetsToGraph(nodeStatus[i].StateOfInProgressTargets);
@@ -230,7 +229,6 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
         {
             for (int i = 0; i < nodeStatus.Length; i++)
             {
-
                 TimeSpan timeSinceLastNodeTaskActivity = new TimeSpan(nodeStatus[i].TimeSinceLastTaskActivity);
                 TimeSpan timeSinceLastNodeLoopActivity = new TimeSpan(nodeStatus[i].TimeSinceLastLoopActivity);
  
@@ -253,7 +251,6 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
             }
 
             parentEngine.Scheduler.DumpState();
-
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
index 8778f8bcc85..ccf85258677 100644
--- a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
+++ b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
@@ -9,17 +9,16 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class is used to construct and analyze the graph of inprogress targets in order to find
-    /// cycles inside the graph. To find cycles a post order traversal is used to assign a post order 
+    /// cycles inside the graph. To find cycles a post order traversal is used to assign a post order
     /// traversal to each node. Back edges indicate cycles in the graph and they can indentified by
-    /// a link from lower index node to a higher index node. 
-    /// 
+    /// a link from lower index node to a higher index node.
+    ///
     /// The graph arrives in pieces from individual nodes and needs to be stiched together by identifying
-    /// the parent and child for each cross node link. To do that it is necessary to match up parent 
+    /// the parent and child for each cross node link. To do that it is necessary to match up parent
     /// build request for a child with and outstanding request from the parent (see LinkCrossNodeBuildRequests)
     /// </summary>
     internal class TargetCycleDetector
@@ -138,7 +137,7 @@ internal bool FindCycles()
             // First try to perform the traversal from the roots (i.e nodes that are due to host requests)
             foreach (GraphNode node in dependencyGraph.Values)
             {
-                if (node.isRoot == true && node.traversalIndex == GraphNode.InvalidIndex)
+                if (node.isRoot && node.traversalIndex == GraphNode.InvalidIndex)
                 {
                     BreadthFirstTraversal(node);
                 }
@@ -177,7 +176,7 @@ private void LinkCrossNodeBuildRequests()
         {
             foreach (GraphNode node in dependencyGraph.Values)
             {
-                TargetInProgessState.TargetIdWrapper[] parentsForBuildRequests = 
+                TargetInProgessState.TargetIdWrapper[] parentsForBuildRequests =
                     new TargetInProgessState.TargetIdWrapper[node.targetState.ParentBuildRequests.Count];
 
                 for (int j = 0; j < node.targetState.ParentBuildRequests.Count; j++ )
@@ -236,7 +235,7 @@ private void LinkCrossNodeBuildRequests()
                             {
                                 // Verify that the project name is the same
                                 ErrorUtilities.VerifyThrow(
-                                    String.Compare(buildRequest.ProjectFileName, externalRequests[i].ProjectFileName, StringComparison.OrdinalIgnoreCase) == 0,
+                                    String.Equals(buildRequest.ProjectFileName, externalRequests[i].ProjectFileName, StringComparison.OrdinalIgnoreCase),
                                     "The two requests should have the same project name");
 
                                 // Link the two graph nodes together
@@ -317,10 +316,10 @@ private void DumpCycleSequence(GraphNode parent, GraphNode child)
             {
                 node.traversalIndex = GraphNode.InvalidIndex;
             }
-            BuildEventContext buildEventContext = 
+            BuildEventContext buildEventContext =
                 new BuildEventContext(child.targetState.TargetId.nodeId,
-                                 child.targetState.TargetId.id, 
-                                 BuildEventContext.InvalidProjectContextId, 
+                                 child.targetState.TargetId.id,
+                                 BuildEventContext.InvalidProjectContextId,
                                  BuildEventContext.InvalidTaskId
                                 );
             DumpCycleSequenceOutput(parent, child, buildEventContext);
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index 52ff67e5b6d..eb9feec1cf0 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -201,7 +201,7 @@ out BuildRequest parentRequest
             {
                 // The build context must have formed due to IBuildEngine call
                 ErrorUtilities.VerifyThrow(
-                    String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), target.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                    String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), target.Name, StringComparison.OrdinalIgnoreCase),
                     "The target should be the in progress target for the context");
                 // This target is called due to IBuildEngine or host request
                 return FindParentTargetForBuildRequest(engineCallback, buildContext.BuildRequest, out parentRequest);
@@ -254,7 +254,6 @@ out BuildRequest parentTriggeringRequest
             return null;
         }
 
-
         /// <summary>
         /// This function checks if the given ProjectBuildState is caused by a given parent target (via
         /// a dependency, onerror or IBuildEngine relationship)
@@ -271,7 +270,7 @@ ProjectBuildState projectBuildState
             TargetInProgessState.TargetIdWrapper parentName =
                 FindParentTarget(engineCallback, projectBuildState, target, out parentRequest);
 
-            if (parentName != null && parentName.Equals(parentId))
+            if (parentName?.Equals(parentId) == true)
             {
                 return true;
             }
@@ -582,7 +581,7 @@ public override bool Equals(object obj)
                 if (other != null)
                 {
                     if (other.projectId == projectId && other.nodeId == nodeId &&
-                        (String.Compare(other.name, name, StringComparison.OrdinalIgnoreCase) == 0))
+                        (String.Equals(other.name, name, StringComparison.OrdinalIgnoreCase)))
                     {
                         return true;
                     }
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index 8abbf2b1924..deff9dee49e 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -419,7 +419,7 @@ private void BuildItemHelper(XmlDocument ownerDocument, string itemName, string
             // Only check for null. It's legal to make BuildItems with empty
             // item specs -- this is to be consistent with how we shipped TaskItem.
             // See #567058.
-            ErrorUtilities.VerifyThrowArgumentNull(itemInclude, "itemInclude");
+            ErrorUtilities.VerifyThrowArgumentNull(itemInclude, nameof(itemInclude));
 
             // Validate that the item name doesn't contain any illegal characters.
             if (itemName != null)
@@ -505,7 +505,7 @@ internal BuildItem(XmlElement itemElement, bool importedFromAnotherProject, bool
         /// </summary>
         public BuildItem(string itemName, ITaskItem taskItem) 
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskItem, "taskItem");
+            ErrorUtilities.VerifyThrowArgumentNull(taskItem, nameof(taskItem));
 
             string itemInclude = EscapingUtilities.Escape(taskItem.ItemSpec);
 
@@ -647,7 +647,7 @@ public string Include
                 {
                     // If this is an evaluated item that originated from the project file, and the original
                     // item is declared using a wildcard that still matches the new item spec ...
-                    if ((ParentPersistedItem != null) && (ParentPersistedItem.NewItemSpecMatchesExistingWildcard(value)))
+                    if ((ParentPersistedItem?.NewItemSpecMatchesExistingWildcard(value) == true))
                     {
                         // Don't need to touch the project file since the original wildcard still matches
                         // the new item spec.  But it still should be reevaluated the next time around.
@@ -1196,7 +1196,6 @@ BuildEventContext buildEventContext
 
                         // Add this metadata to the running table we're using, so that one piece of metadata can refer to another one above
                         expander.SetMetadataInMetadataTable(name, metadataElement.Name, evaluatedMetadataValue);
-
                     }
                 }
             }
@@ -1208,7 +1207,7 @@ BuildEventContext buildEventContext
         /// <remarks>BuildItem-spec modifiers are treated as metadata.</remarks>
         public bool HasMetadata(string metadataName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+            ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
             ErrorUtilities.VerifyThrow(this.unevaluatedCustomMetadata != null, "Item not initialized properly. unevaluatedCustomAttributes is null.");
 #if DEBUG
             // The hashtable of metadata (this.unevaluatedCustomMetadata) should never contain 
@@ -1381,7 +1380,7 @@ internal int GetCustomMetadataCount()
         /// <param name="destinationItem">BuildItem to copy custom attributes to</param>
         public void CopyCustomMetadataTo(BuildItem destinationItem)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
             if (IsBackedByXml)
             {
@@ -1523,8 +1522,8 @@ private void VerifyForMetadataSet(string metadataName, string metadataValue)
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.IsDerivableItemSpecModifier(metadataName),
                 "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-            ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
-            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, "metadataValue");
+            ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
+            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, nameof(metadataValue));
 
             // Make sure the metadata doesn't use any special characters in the name.
             XmlUtilities.VerifyThrowValidElementName(metadataName);
@@ -1662,7 +1661,7 @@ private string GetItemSpecModifier(string modifier)
 
             if (modifiedItemSpec.Length == 0)
             {
-                if (String.Compare(modifier, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(modifier, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
                 {
                     modifiedItemSpec = ExtractRecursivePortionOfFinalItemSpecDirectory();
 
@@ -1776,10 +1775,7 @@ private Project GetParentProject()
         private void MarkItemAsDirty()
         {
             Project parentProject = GetParentProject();
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirty();
-            }
+            parentProject?.MarkProjectAsDirty();
         }
 
         /// <summary>
@@ -1789,10 +1785,7 @@ private void MarkItemAsDirty()
         private void MarkItemAsDirtyForReevaluation()
         {
             Project parentProject = GetParentProject();
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirtyForReevaluation();
-            }
+            parentProject?.MarkProjectAsDirtyForReevaluation();
         }
 
         /// <summary>
@@ -1877,10 +1870,7 @@ private void SplitItem()
         /// <owner>rgoel</owner>
         internal void SplitChildItemIfNecessary()
         {
-            if (this.ParentPersistedItem != null)
-            {
-                this.ParentPersistedItem.SplitItem();
-            }
+            this.ParentPersistedItem?.SplitItem();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index f80ff6d33d8..86906da9e00 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class represents a collection of items.  It may be represented
-    /// physically by an &lt;ItemGroup&gt; element persisted in the project file, 
+    /// physically by an &lt;ItemGroup&gt; element persisted in the project file,
     /// or it may just be a virtual BuildItemGroup (e.g., the evaluated items).
     /// </summary>
     [DebuggerDisplay("BuildItemGroup (Count = { Count }, Condition = { Condition })")]
@@ -363,7 +363,7 @@ internal void AddExistingItemAt(int index, BuildItem itemToAdd)
         /// <summary>
         /// Adds an BuildItem to this BuildItemGroup.  If this is a persisted BuildItemGroup, then
         /// this method also inserts the BuildItem's XML into the appropriate location
-        /// in the XML document.  For persisted ItemGroups, the behavior is that 
+        /// in the XML document.  For persisted ItemGroups, the behavior is that
         /// it tries to insert the new BuildItem such that it is "near" other items of the
         /// same type.  ("Near" is defined as just after the last existing item
         /// of the same type, or at the end if none is found.)
@@ -392,7 +392,7 @@ internal void AddItem(BuildItem itemToAdd)
                 int insertionIndex = items.Count;
                 for (int i = 0; i < items.Count; i++)
                 {
-                    if ( 0 == String.Compare(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
+                    if ( String.Equals(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
                     {
                         insertionIndex = i + 1;
 
@@ -439,7 +439,7 @@ internal void AddItem(BuildItem itemToAdd)
         }
 
         /// <summary>
-        /// Creates a new BuildItem defined by the given "Type" and "Include", and 
+        /// Creates a new BuildItem defined by the given "Type" and "Include", and
         /// adds it to the end of this BuildItemGroup.
         /// If the group is persisted, the item is persisted; otherwise it is virtual
         /// </summary>
@@ -453,7 +453,7 @@ public BuildItem AddNewItem(string itemName, string itemInclude)
                 newItem = new BuildItem(xml.OwnerDocument, itemName, itemInclude, parentProject.ItemDefinitionLibrary);
             }
             else
-            { 
+            {
                 // Create a new virtual BuildItem.
                 newItem = new BuildItem(itemName, itemInclude);
             }
@@ -539,8 +539,8 @@ private void RemoveItemElement(BuildItem item)
         /// <summary>
         /// Clones the BuildItemGroup.  A shallow clone here is one that references
         /// the same BuildItem objects as the original, whereas a deep clone actually
-        /// clones the BuildItem objects as well.  If this is a persisted BuildItemGroup, 
-        /// only deep clones are allowed, because you can't have the same XML 
+        /// clones the BuildItem objects as well.  If this is a persisted BuildItemGroup,
+        /// only deep clones are allowed, because you can't have the same XML
         /// element belonging to two parents.
         /// </summary>
         public BuildItemGroup Clone(bool deepClone)
@@ -663,10 +663,7 @@ internal void RemoveAllIntermediateItems()
         /// </summary>
         private void MarkItemGroupAsDirty()
         {
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirty();
-            }
+            parentProject?.MarkProjectAsDirty();
         }
 
         /// <summary>
@@ -747,7 +744,7 @@ private void MustBeInitialized()
         /// </summary>
         private void MustHaveThisParentElement(BuildItem item)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(item != null && item.ItemElement != null && item.ItemElement.ParentNode == xml.Element, "ItemDoesNotBelongToItemGroup");
+            ErrorUtilities.VerifyThrowInvalidOperation(item?.ItemElement?.ParentNode == xml.Element, "ItemDoesNotBelongToItemGroup");
         }
 
         /// <summary>
@@ -767,8 +764,8 @@ internal void Evaluate
         (
             BuildPropertyGroup existingProperties,
             Hashtable existingItemsByName,
-            bool collectItemsIgnoringCondition, 
-            bool collectItemsRespectingCondition, 
+            bool collectItemsIgnoringCondition,
+            bool collectItemsRespectingCondition,
             ProcessingPass pass
         )
         {
@@ -897,7 +894,7 @@ bool expandMetadata
                     itemsToInclude.RemoveItem(item);
                 }
             }
-            
+
             return itemsToInclude;
         }
 
diff --git a/src/Deprecated/Engine/Items/ItemExpander.cs b/src/Deprecated/Engine/Items/ItemExpander.cs
index 56f3737c2f7..78999ddbc24 100644
--- a/src/Deprecated/Engine/Items/ItemExpander.cs
+++ b/src/Deprecated/Engine/Items/ItemExpander.cs
@@ -191,7 +191,7 @@ out Match itemVectorMatch
 
             itemVectorMatch = GetItemVectorMatches(itemVectorExpression);
 
-            if (itemVectorMatch != null && itemVectorMatch.Success)
+            if (itemVectorMatch?.Success == true)
             {
                 // The method above reports a match if there are any
                 // valid @(itemlist) references in the given expression.
@@ -236,7 +236,7 @@ internal static bool ExpressionContainsItemVector(string expression)
         {
             Match itemVectorMatch = GetItemVectorMatches(expression);
 
-            if (itemVectorMatch != null && itemVectorMatch.Success)
+            if (itemVectorMatch?.Success == true)
             {
                 return true;
             }
diff --git a/src/Deprecated/Engine/Items/TaskItem.cs b/src/Deprecated/Engine/Items/TaskItem.cs
index afc43738a54..9b2f69fda41 100644
--- a/src/Deprecated/Engine/Items/TaskItem.cs
+++ b/src/Deprecated/Engine/Items/TaskItem.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.BuildEngine
 {
-
     /// <summary>
     /// This class wraps a project item, and provides a "view" on the item's BuildItem class that is suitable to expose to tasks.
     /// </summary>
@@ -98,7 +97,6 @@ public int MetadataCount
             }
         }
 
-
         /// <summary>
         /// Gets the names of custom metadata on the item
         /// </summary>
@@ -132,7 +130,7 @@ public int CustomMetadataCount
         /// <returns>value of metadata</returns>
         public string GetMetadata(string metadataName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+            ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
 
             // Return the unescaped data to the task.
             return item.GetEvaluatedMetadata(metadataName);
@@ -146,8 +144,8 @@ public string GetMetadata(string metadataName)
         /// <param name="metadataValue"></param>
         public void SetMetadata(string metadataName, string metadataValue)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
-            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, "metadataValue");
+            ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
+            ErrorUtilities.VerifyThrowArgumentNull(metadataValue, nameof(metadataValue));
 
             item.SetMetadata(metadataName, EscapingUtilities.Escape(metadataValue));
         }
@@ -159,7 +157,7 @@ public void SetMetadata(string metadataName, string metadataValue)
         /// <param name="metadataName"></param>
         public void RemoveMetadata(string metadataName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+            ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
 
             item.RemoveMetadata(metadataName);
         }
@@ -175,7 +173,7 @@ public void CopyMetadataTo
             ITaskItem destinationItem
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+            ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
             // Intentionally not _computed_ properties. These are slow and don't really
             // apply anyway.
@@ -185,7 +183,7 @@ ITaskItem destinationItem
 
                 string destinationValue = destinationItem.GetMetadata(key);
 
-                if ((destinationValue == null) || (destinationValue.Length == 0))
+                if (string.IsNullOrEmpty(destinationValue))
                 {
                     destinationItem.SetMetadata(key, EscapingUtilities.UnescapeAll((string)entry.Value));
                 }
@@ -195,13 +193,12 @@ ITaskItem destinationItem
             // between items, and need to know the source item where the metadata came from
             string originalItemSpec = destinationItem.GetMetadata("OriginalItemSpec");
 
-            if ((originalItemSpec == null) || (originalItemSpec.Length == 0))
+            if (string.IsNullOrEmpty(originalItemSpec))
             {
                 destinationItem.SetMetadata("OriginalItemSpec", ItemSpec);
             }
         }
 
-
         /// <summary>
         /// Get the collection of metadata. This does not include built-in metadata.
         /// </summary>
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index e41665da673..cc741b9b68b 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -120,7 +120,7 @@ internal static bool ContainsMetadataExpressionOutsideTransform(string expressio
 
             GetReferencedItemNamesAndMetadata(expression, 0, expression.Length, ref pair, ShredderOptions.MetadataOutsideTransforms);
 
-            bool result = (pair.Metadata != null && pair.Metadata.Count > 0);
+            bool result = (pair.Metadata?.Count > 0);
 
             return result;
         }
@@ -372,7 +372,7 @@ private static bool Sink(string expression, ref int i, int end, char c1, char c2
         {
             if (i < end - 1 && expression[i] == c1 && expression[i + 1] == c2)
             {
-                i = i + 2;
+                i += 2;
                 return true;
             }
 
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index 30fb00eb92b..459aedf5f15 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -61,7 +61,6 @@ namespace Microsoft.Build.BuildEngine
     /// </remarks>
     internal class Lookup
     {
-
         #region Fields
 
         /// <summary>
@@ -884,10 +883,7 @@ private void ImportItemsIntoTable(Hashtable table, string name, BuildItemGroup g
         private void RemoveItemsFromTableWithBackup(Hashtable table, string name, BuildItemGroup group)
         {
             BuildItemGroup existing = (BuildItemGroup)table[name];
-            if (existing != null)
-            {
-                existing.RemoveItemsWithBackup(group);
-            }
+            existing?.RemoveItemsWithBackup(group);
         }
 
         /// <summary>
@@ -897,10 +893,7 @@ private void RemoveItemsFromTableWithBackup(Hashtable table, string name, BuildI
         private void ApplyModificationsToTable(Hashtable table, string name, Dictionary<BuildItem, Dictionary<string, string>> modify)
         {
             BuildItemGroup existing = (BuildItemGroup)table[name];
-            if (existing != null)
-            {
-                existing.ModifyItemsUsingVirtualMetadata(modify);
-            }
+            existing?.ModifyItemsUsingVirtualMetadata(modify);
         }
 
         /// <summary>
@@ -1018,7 +1011,7 @@ private void MustNotBeInTable(Hashtable table, BuildItem item)
         /// </summary>
         private void MustNotBeInTable(Dictionary<string, Dictionary<BuildItem, Dictionary<string, string>>> table, BuildItem item)
         {
-            if (table != null && table.ContainsKey(item.Name))
+            if (table?.ContainsKey(item.Name) == true)
             {
                 Dictionary<BuildItem, Dictionary<string, string>> tableOfItemsOfSameType = table[item.Name];
                 if (tableOfItemsOfSameType != null)
@@ -1034,7 +1027,7 @@ private void MustNotBeInTable(Dictionary<string, Dictionary<BuildItem, Dictionar
         /// </summary>
         private void MustNotBeInTable(Hashtable table, string name, BuildItemGroup group)
         {
-            if (table != null && table.ContainsKey(name))
+            if (table?.ContainsKey(name) == true)
             {
                 BuildItemGroup existing = (BuildItemGroup)table[name];
                 if (existing != null)
diff --git a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
index 0a1d5607bcc..689bbaaab8e 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
@@ -954,7 +954,6 @@ internal class LocalCallDescriptorForRequestStatus : LocalCallDescriptor
         #region Constructors
         internal LocalCallDescriptorForRequestStatus()
         {
-
         }
 
         internal LocalCallDescriptorForRequestStatus(int requestId)
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 73fdb915a95..70921a78534 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -131,13 +131,11 @@ void StartCommunicationThreads()
             ErrorUtilities.VerifyThrow(this.sharedMemory.IsUsable,
                 "Failed to create shared memory for local node input.");
 
-
             // Start the thread that will be processing the calls from the parent engine
             ThreadStart threadState = new ThreadStart(this.SharedMemoryReaderThread);
             readerThread = new Thread(threadState);
             readerThread.Name = "MSBuild Child<-Parent Reader";
             readerThread.Start();
-            
         }
 
         /// <summary>
@@ -153,15 +151,9 @@ void StopCommunicationThreads()
             // to start up its communication threads. This can happen if the node is started with /nodemode:x
             // and no parent is running, or if the parent node has spawned a new process and then crashed 
             // before establishing communication with the child node.
-            if(writerThread != null)
-            {
-              writerThread.Join();
-            }
+            writerThread?.Join();
 
-            if (readerThread != null)
-            {
-                readerThread.Join();
-            }
+            readerThread?.Join();
 
             // Make sure the exit event is not set
             communicationThreadExitEvent.Reset();
@@ -209,7 +201,7 @@ private static bool CreateGlobalEvents(int nodeNumber)
 
             // Indicate to the parent process, this node is currently is ready to start to recieve requests
             globalNodeInUse = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInUseEventName(nodeNumber));
-            
+
             // Used by the parent process to inform the child process to shutdown due to the child process
             // not recieving the initialization command.
             globalNodeErrorShutdown = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeErrorShutdownEventName(nodeNumber));
@@ -280,7 +272,7 @@ public static void StartLocalNodeServer(int nodeNumber)
                     waitHandlesActive[2] = notInUseEvent;
 
                     eventType = WaitHandle.WaitTimeout;
-                    while (eventType == WaitHandle.WaitTimeout && continueRunning == true)
+                    while (eventType == WaitHandle.WaitTimeout && continueRunning)
                     {
                         eventType = WaitHandle.WaitAny(waitHandlesActive, parentCheckInterval, false);
 
@@ -338,7 +330,7 @@ public static void StartLocalNodeServer(int nodeNumber)
         #region Methods
 
         /// <summary>
-        /// This method is run in its own thread, it is responsible for reading messages sent from the parent process 
+        /// This method is run in its own thread, it is responsible for reading messages sent from the parent process
         /// through the shared memory region.
         /// </summary>
         private void SharedMemoryReaderThread()
@@ -450,7 +442,7 @@ internal void ShutdownNode(Node.NodeShutdownLevel shutdownLevel, bool exitProces
                 // accomplished by calling this method again with the ErrorShutdown handle
                 if ( shutdownLevel == Node.NodeShutdownLevel.BuildCompleteSuccess || shutdownLevel == Node.NodeShutdownLevel.BuildCompleteFailure )
                 {
-                    ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true); 
+                    ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true);
                 }
                 // Signal all the communication threads to exit
                 shutdownEvent.Set();
@@ -495,7 +487,6 @@ string parentStartupDirectory
             // Host the msbuild engine and system
             node = new Node(nodeId, nodeLoggers, engineCallback, parentGlobalProperties, toolsetSearchLocations, parentStartupDirectory);
 
-
             // Write the initialization complete event out directly
             LocalCallDescriptorForInitializationComplete callDescriptor =
                 new LocalCallDescriptorForInitializationComplete(Process.GetCurrentProcess().Id);
@@ -548,10 +539,7 @@ internal void ReportFatalCommunicationError(Exception originalException)
             }
             finally
             {
-                if (node != null)
-                {
-                    node.ReportFatalCommunicationError(originalException, null);
-                }
+                node?.ReportFatalCommunicationError(originalException, null);
             }
         }
 
@@ -562,7 +550,6 @@ internal void ReportFatalCommunicationError(Exception originalException)
         /// <param name="originalException"></param>
         internal void ReportNonFatalCommunicationError(Exception originalException)
         {
-             
             if (node != null)
             {
                 try
@@ -624,9 +611,9 @@ internal static string DumpFileName
         private static ManualResetEvent communicationThreadExitEvent = new ManualResetEvent(false);
         private static ManualResetEvent shutdownEvent = new ManualResetEvent(false);
         private static ManualResetEvent notInUseEvent = new ManualResetEvent(false);
-        
+
         /// <summary>
-        /// Indicates the node is now in use. This means the node has recieved an activate command with initialization 
+        /// Indicates the node is now in use. This means the node has recieved an activate command with initialization
         /// data from the parent procss
         /// </summary>
         private static ManualResetEvent inUseEvent    = new ManualResetEvent(false);
@@ -640,7 +627,7 @@ internal static string DumpFileName
         // Timeouts && Constants
         private const int inactivityTimeout   = 60 * 1000; // 60 seconds of inactivity to exit
         private const int parentCheckInterval = 5 * 1000; // Check if the parent process is there every 5 seconds
-	
+
         #endregion
 
     }
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
index 2137adc272a..3c0d967fd5d 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
@@ -122,7 +122,7 @@ internal void PostReplyFromParent(LocalReplyCallDescriptor reply)
             lock (repliesFromParent)
             {
                 ReplyData replyData = (ReplyData) repliesFromParent[requestingCallNumber];
-                ErrorUtilities.VerifyThrow(replyData != null && replyData.waitEvent != null, 
+                ErrorUtilities.VerifyThrow(replyData?.waitEvent != null, 
                     "We must have an event for this call at this point");
 
                 replyData.reply = reply;
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
index ba2972020e4..8d634635004 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
@@ -232,7 +232,6 @@ private void ReserveNextAvailableNodeNumber(int currentNodeNumber)
                         nodeReserveHandle = null;
                         currentNodeNumber++;
                     }
-
                 }
             }
         }
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index ef43c638ee9..0ec6a341b2b 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -46,7 +46,6 @@ string startupDirectory
                 // Go through each of the parameter name value pairs and split them appart
                 for (int param = 0; param < parameters.Length; param++)
                 {
-
                     if (parameters[param].Length > 0)
                     {
                         string[] parameterComponents = parameters[param].Split(valueDelimiters);
@@ -57,7 +56,7 @@ string startupDirectory
                         }
                         else // Only the parameter name is known, this could be for a boolean parameter
                         {
-                            ApplyParameter(parameters[param], null); 
+                            ApplyParameter(parameters[param], null);
                         }
                     }
                 }
@@ -123,14 +122,13 @@ string startupDirectory
         /// </summary>
         public void ApplyParameter(string parameterName, string parameterValue)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
-            if (0 == String.Compare(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
             {
                  try
                 {
                     this.cpuCount = Convert.ToInt32(parameterValue, CultureInfo.InvariantCulture);
-
                 }
                 catch (FormatException)
                 {
@@ -141,11 +139,11 @@ public void ApplyParameter(string parameterName, string parameterValue)
                     //
                 }
             }
-            else if (0 == String.Compare(parameterName, "MSBUILDLOCATION", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "MSBUILDLOCATION", StringComparison.OrdinalIgnoreCase))
             {
                 this.locationOfMSBuildExe = parameterValue;
             }
-            else if (0 == String.Compare(parameterName, "NODEREUSE", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "NODEREUSE", StringComparison.OrdinalIgnoreCase))
             {
                 try
                 {
@@ -170,7 +168,6 @@ public void ApplyParameter(string parameterName, string parameterValue)
             }
         }
 
-
         public INodeDescription[] QueryNodeDescriptions()
         {
             return new INodeDescription[cpuCount-1];
@@ -252,7 +249,7 @@ public void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
                             }
                             ThreadStart threadState = new ThreadStart(this.LaunchNodeAndPostBuildRequest);
                             Thread taskThread = new Thread(threadState);
-                            taskThread.Name = "MSBuild Node Launcher";                            
+                            taskThread.Name = "MSBuild Node Launcher";
                             taskThread.Start();
                         }
                         nodeData[nodeIndex].TargetList.AddFirst(new LinkedListNode<BuildRequest>(buildRequest));
@@ -296,10 +293,10 @@ public void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
             SendShutdownRequests(nodeShutdownLevel);
 
             DateTime startTime = DateTime.Now;
-            
+
             // Wait for all nodes to shutdown
             bool timeoutExpired = false;
-            
+
             // Loop until we are ready to shutdown. We are ready to shutdown when
             // all nodes either have sent their shutdown completed response or they are dead.
             // Secondly, we will exit the loop if our shudtownTimeout has expired
@@ -367,7 +364,7 @@ internal bool ReadyToShutdown()
         /// </summary>
         public void UpdateSettings
         (
-            bool enableCentralizedLogging, 
+            bool enableCentralizedLogging,
             bool enableOnlyLogCriticalEvents,
             bool useBreadthFirstTraversalSetting
         )
@@ -383,7 +380,6 @@ bool useBreadthFirstTraversalSetting
                     UpdateSettings(i);
                 }
             }
-
         }
 
         private void UpdateSettings(int nodeIndex)
@@ -394,7 +390,6 @@ private void UpdateSettings(int nodeIndex)
             nodeData[nodeIndex].NodeCommandQueue.Enqueue(callDescriptor);
         }
 
-
         public void PostIntrospectorCommand(int nodeIndex, TargetInProgessState child, TargetInProgessState parent)
         {
             // Send the updated settings once the node has initialized
@@ -457,7 +452,6 @@ private void TerminateChildNode(int processId)
         {
             try
             {
-
                 if (!Process.GetProcessById(processId).HasExited)
                 {
                     Process.GetProcessById(processId).Kill();
@@ -480,15 +474,13 @@ private void TerminateChildNode(int processId)
         private bool IsNodeProcessAliveOrUninitialized(int nodeId)
         {
             // If it's alive but not being communicated with anymore, that counts as not alive
-            if (nodeData[nodeId].CommunicationFailed == true)
+            if (nodeData[nodeId].CommunicationFailed)
             {
                 return false;
             }
-            
+
             try
             {
- 
-
                 bool isUninitialized = nodeData[nodeId].ProcessId == LocalNodeInfo.unInitializedProcessId;
 
                 if (isUninitialized)
@@ -502,7 +494,6 @@ private bool IsNodeProcessAliveOrUninitialized(int nodeId)
                 {
                     return true;
                 }
-
            }
             catch (ArgumentException)
             {
@@ -727,7 +718,7 @@ private void InitializeNode(int nodeIndex)
             finally
             {
                 // Make sure to decrement the active node count if the communication has failed
-                if (nodeConnected != true)
+                if (!nodeConnected)
                 {
                     DecreaseActiveNodeCount(nodeData[nodeIndex].NodeId);
                     nodeData[nodeIndex].CommunicationFailed = true;
@@ -737,7 +728,7 @@ private void InitializeNode(int nodeIndex)
 
         /// <summary>
         /// This function attempts to find out if there is currently a node running
-        /// for a given index. The node is running if the global mutex with a 
+        /// for a given index. The node is running if the global mutex with a
         /// "Node_" + nodeId + "_ActiveReady" as a name was created
         /// </summary>
         private static  bool checkIfNodeActive(int nodeNumber)
@@ -755,10 +746,7 @@ private static  bool checkIfNodeActive(int nodeNumber)
             }
             finally
             {
-                if (nodeActiveHandle != null)
-                {
-                    nodeActiveHandle.Close();
-                }
+                nodeActiveHandle?.Close();
             }
 
             return nodeIsActive;
@@ -786,7 +774,7 @@ private void LaunchNode(int nodeIndex)
                     startInfo.hStdInput = NativeMethods.InvalidHandle;
                     startInfo.hStdOutput = NativeMethods.InvalidHandle;
                     startInfo.dwFlags = NativeMethods.STARTF_USESTDHANDLES;
-                    dwCreationFlags = dwCreationFlags | NativeMethods.CREATE_NO_WINDOW;
+                    dwCreationFlags |= NativeMethods.CREATE_NO_WINDOW;
                 }
 
                 NativeMethods.SECURITY_ATTRIBUTES pSec = new NativeMethods.SECURITY_ATTRIBUTES();
@@ -812,15 +800,11 @@ private void LaunchNode(int nodeIndex)
                 {
                     exitedDueToError = false;
                 }
-
             }
             finally
             {
                 // Dispose before losing scope
-                if (nodeReadyEvent != null)
-                {
-                    nodeReadyEvent.Close();
-                }
+                nodeReadyEvent?.Close();
 
                 if (exitedDueToError)
                 {
@@ -835,7 +819,7 @@ private void LaunchNode(int nodeIndex)
         private void ReportNodeCommunicationFailure
         (
             int nodeIndex,
-            Exception innerException, 
+            Exception innerException,
             bool decreaseActiveNodeCount
         )
         {
@@ -860,7 +844,7 @@ bool decreaseActiveNodeCount
                 // We can't really do anything except re-throw so this problem can be diagnosed.
                 throw wrappedException;
             }
-            
+
             engineCallback.PostStatus(nodeData[nodeIndex].NodeId, nodeStatus, false);
         }
 
@@ -1003,7 +987,6 @@ private void SharedMemoryReaderThread()
         private int activeNodeCount;
         private int responseCount;
 
-
         private int cpuCount;
 
         private object nodeStateLock;
diff --git a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
index 79783bfc6f2..c9a573e2814 100644
--- a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
+++ b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
@@ -92,7 +92,6 @@ internal static bool IsUserAdministrator()
             }
 
             return bRet;
-            
         }
 
         [DllImport("advapi32.dll", SetLastError = true)]
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index a5df97442c7..47f1f7c65af 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -25,7 +25,7 @@ internal enum SharedMemoryType
     }
 
     /// <summary>
-    /// The shared memory is used to transmit serialized LocalCallDescriptors. 
+    /// The shared memory is used to transmit serialized LocalCallDescriptors.
     /// These local call descriptors encapsulate commands and data that needs
     /// to be communicated between the parent and child objects. This enumeration
     /// is used by the shared memory to mark what kind of LocalCallDescriptor
@@ -36,7 +36,7 @@ internal enum SharedMemoryType
     internal enum ObjectType
     {
         // Has the object been serialized using .net serialization (binary formatter)
-        NetSerialization = 1, 
+        NetSerialization = 1,
         // Used to mark that the next int read represents how many bytes are in the
         // large object which is about to be sent      
         FrameMarker = 2,
@@ -61,10 +61,10 @@ internal enum ObjectType
     }
 
     /// <summary>
-    /// This class is responsible for providing a communication channel between 
+    /// This class is responsible for providing a communication channel between
     /// a child process and a parent process. Each process (child or parent) will
     /// have two SharedMemory class instances, one for reading and one for writing.
-    /// For example, a parent will have one shared memory class to "read" data 
+    /// For example, a parent will have one shared memory class to "read" data
     /// sent from the child and one "write" shared The shared memory communicates
     /// through named shared memory regions.
     /// </summary>
@@ -81,7 +81,7 @@ private SharedMemory()
         /// </summary>
         /// <param name="name">
         /// The name the shared memory will be given, this is combination of node,
-        /// username, admin status, and some other ones, 
+        /// username, admin status, and some other ones,
         /// see LocalNodeProviderGlobalNames.NodeInputMemoryName for greater detail.
         /// </param>
         /// <param name="type">
@@ -89,19 +89,19 @@ private SharedMemory()
         ///  within the shared memory class. For example,
         ///  read only means, only create a memory stream,
         ///  a read lock and a backing byte array and a binary reader. A write
-        ///  only type means,  create a memory stream, write lock and a binary writer. 
+        ///  only type means,  create a memory stream, write lock and a binary writer.
         ///  This type however does not set the type of the memory mapped section,
         ///  the memory mapped section itself is created
         ///  with READWRITE access.
         ///</param>
         /// <param name="allowExistingMapping">
-        ///  The shared memory is given a parameter to determine whether or not to 
-        ///  reuse an existing mapped memory secion. When the node is first created 
+        ///  The shared memory is given a parameter to determine whether or not to
+        ///  reuse an existing mapped memory secion. When the node is first created
         ///  this is false, however when the shared memory threads are created this
-        ///  is true. We do this because we create the shared memory when the node 
+        ///  is true. We do this because we create the shared memory when the node
         ///  is created, at this point the there should be no shared memory with the
-        ///  same name. However when we create the reader and writer threads 
-        ///  (which happens on node reuse) we want to reuse the memory. 
+        ///  same name. However when we create the reader and writer threads
+        ///  (which happens on node reuse) we want to reuse the memory.
         ///</param>
         internal SharedMemory(string name, SharedMemoryType type, bool allowExistingMapping)
         {
@@ -224,7 +224,7 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
                         0,  // Start mapped view at low order offset 0
                          // The size of the shared memory plus some extra space for an int
                          // to write the number of bytes written
-                        (IntPtr)(size + 4)  
+                        (IntPtr)(size + 4)
                     );
 
                 // Check to see if the file view has been created on the fileMapping.
@@ -255,7 +255,6 @@ private void InitializeStreams(SharedMemoryType streamType)
                 this.readStream = new MemoryStream(this.readBuffer);
                 this.binaryReader = new BinaryReader(this.readStream);
                 readLock = new object();
-
             }
             else if (streamType == SharedMemoryType.WriteOnly)
             {
@@ -267,7 +266,6 @@ private void InitializeStreams(SharedMemoryType streamType)
             {
                 ErrorUtilities.VerifyThrow(false, "Unknown shared memory type.");
             }
-
         }
 
         /// <summary>
@@ -328,13 +326,11 @@ protected virtual void Dispose(bool disposing)
             }
         }
 
-
         public void Dispose()
         {
             Dispose(true);
         }
 
-
         ~SharedMemory()
         {
             Dispose();
@@ -360,7 +356,7 @@ internal bool IsUsable
         /// Returns the readActionCounter as a WaitHandle. This WaitHandle is used
         /// to notify the SharedMemory reader threads that there is something ready
         /// in the shared memory to be read. The ReadFlag will remain set as long as
-        /// the number of times the shared memory has been read is less than the 
+        /// the number of times the shared memory has been read is less than the
         /// number of times writer thread has written to the shared memory.
         /// </summary>
         internal WaitHandle ReadFlag
@@ -441,7 +437,7 @@ private void IncrementUnreadBatchCounter()
         }
 
         /// <summary>
-        /// A batch has just been read out of shared memory. 
+        /// A batch has just been read out of shared memory.
         /// </summary>
         private void DecrementUnreadBatchCounter()
         {
@@ -450,13 +446,13 @@ private void DecrementUnreadBatchCounter()
         }
 
         /// <summary>
-        /// This function write out a set of objects into the the shared buffer.
+        /// This function write out a set of objects into the shared buffer.
         /// In normal operation all the objects in the queue are serialized into
         /// the buffer followed by an end marker class. If the buffer is not big
-        /// enough to contain a single object the object is broken into into 
+        /// enough to contain a single object the object is broken into
         /// multiple buffers as follows - first a frame marker is sent containing
         /// the size of the serialized object + size of end marker. The reader makes
-        /// sure upon receiving the frame marker that its buffer is large enough 
+        /// sure upon receiving the frame marker that its buffer is large enough
         /// to contain the object about to be sent. After the frame marker the object
         /// is sent as a series of buffers until all of it is written out.
         /// </summary>
@@ -557,7 +553,7 @@ internal void Write(DualQueue<LocalCallDescriptor> objectsToWrite, DualQueue<Loc
                             (int)writeLength // Length of bytes to write
                         );
 
-                        writeBytesRemaining = writeBytesRemaining - writeLength;
+                        writeBytesRemaining -= writeLength;
                         IncrementUnreadBatchCounter();
 
                         // Once the object is fully sent - remove it from the queue
@@ -692,9 +688,9 @@ private void SerializeCallDescriptorToStream(DualQueue<LocalCallDescriptor> obje
         /// <summary>
         /// This function reads data from the shared memory buffer and returns a list
         /// of deserialized LocalCallDescriptors or null. The method will return null
-        /// if the object being sent accross is a multi buffer object. Read needs to 
+        /// if the object being sent accross is a multi buffer object. Read needs to
         /// be called multiple times until the entire large object has been recived.
-        /// Once this has happened the large object is deserialized and returned in 
+        /// Once this has happened the large object is deserialized and returned in
         /// the Ilist. Read is used by the shared memory reader threads in the LocalNode
         /// (child end) and the LocalNodeProvider(ParentEnd) to read LocalCallDescriptors
         /// from the shared memory. Read is called from loops in the SharedMemoryReaderThread
@@ -802,12 +798,12 @@ internal IList Read()
         }
 
         /// <summary>
-        /// This method first reads the objectId as an int from the stream, 
-        /// this int should be found in the "ObjectType" enumeration. This 
-        /// objectId informs the method what kind of object should be 
+        /// This method first reads the objectId as an int from the stream,
+        /// this int should be found in the "ObjectType" enumeration. This
+        /// objectId informs the method what kind of object should be
         /// deserialized and returned from the method. The objectId is an
-        /// output parameter. This parameter is also returned so it can be 
-        /// used in the read and write methods to determine if 
+        /// output parameter. This parameter is also returned so it can be
+        /// used in the read and write methods to determine if
         /// a frame or end marker was found.
         /// </summary>
         private object DeserializeFromStream(out int objectId)
@@ -915,12 +911,12 @@ internal void Reset()
         private IntPtr pageFileView;
 
         private BinaryFormatter binaryFormatter;
-        
+
         // Binary reader and writer used to read and write from the memory streams used to contain the deserialized LocalCallDescriptors before and after they are copied 
         // to and from the shared memory region.
         private BinaryWriter binaryWriter;
         private BinaryReader binaryReader;
-        
+
         /// <summary>
         /// Memory stream to contain the deserialized objects before they are sent accross the shared memory region
         /// </summary>
@@ -929,7 +925,7 @@ internal void Reset()
         // Backing byte array of the readStream
         private byte[] readBuffer;
         private MemoryStream readStream;
-        
+
         // The count on a semaphore is decremented each time a thread enters the semaphore,
         // and incremented when a thread releases the semaphore. 
         // When the count is zero, subsequent requests block until other threads release the semaphore. 
@@ -937,7 +933,7 @@ internal void Reset()
 
         // unreadBatchCounter is used to track how many batches are remaining to be read from shared memory.
         private Semaphore unreadBatchCounter;
- 
+
         //Used to inform the shared memory reader threads the writer thread has written something in shared memory to read.
 	//The semaphore is incremented when the shared memory is full and when there is an unreadBatch availiable to be read or the shared memory is full.
 	//The semaphore is decremented when the shared memory reader thread is about to read from the shared memory.
@@ -946,7 +942,7 @@ internal void Reset()
         // Whether or not the shared memory is full
         private EventWaitHandle fullFlag;
         private EventWaitHandle notFullFlag;
-        
+
         private object writeLock;
         private object readLock;
 
@@ -959,7 +955,7 @@ internal void Reset()
 
         // Have we disposed this object yet;
         private bool disposed;
-        
+
         // Is the memory read only or write only
         private SharedMemoryType type;
 
@@ -967,7 +963,7 @@ internal void Reset()
         // we were spending a lot of time reflecting for these methods. The loggingTypeCache, caches the methodInfo for the classes and then look them
         // up when serializing or deserializing the objects. 
         private Hashtable loggingTypeCache;
-        
+
         // Keep a pointer to the queue which contains the large object which is being deserialized. We do this because we want to make sure 
         // after the object is properly sent we dequeue off the correct queue.
         private DualQueue<LocalCallDescriptor> largeObjectsQueue;
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index ee027863c82..83af0fb5406 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -566,7 +566,6 @@ internal SortedList ExtractItemList(IEnumerable items)
             return itemTypes;
         }
 
-
         internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
         {
             // Write each item, one per line
@@ -590,7 +589,6 @@ internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
             resetColor();
         }
 
-
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
@@ -719,7 +717,6 @@ internal  bool InScope
                             inScope = false;
 
                             elapsedTime += (System.DateTime.Now - scopeStartTime);
-
                         }
                         else if (!InScope && value)
                         {
@@ -902,7 +899,7 @@ public virtual void Initialize(IEventSource eventSource)
         /// </summary>
         internal virtual bool ApplyParameter(string parameterName, string parameterValue)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             switch (parameterName.ToUpperInvariant())
             {
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 0ac8f1ffcf4..28772e3dbd5 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -54,7 +54,6 @@ public class ConsoleLogger : INodeLogger
         private bool skipProjectStartedText = false;
         private bool? showSummary;
 
-
         #region Constructors
 
         /// <summary>
@@ -99,7 +98,7 @@ public ConsoleLogger
             ColorResetter colorReset
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(write, "write");
+            ErrorUtilities.VerifyThrowArgumentNull(write, nameof(write));
             this.verbosity = verbosity;
             this.write = write;
             this.colorSet = colorSet;
@@ -122,11 +121,11 @@ private void InitializeBaseConsoleLogger()
                     {
                         if (parameterComponents[param].Length > 0)
                         {
-                            if (0 == String.Compare(parameterComponents[param], "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                            if (String.Equals(parameterComponents[param], "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                             {
                                 useMPLogger = true;
                             }
-                            if (0 == String.Compare(parameterComponents[param], "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                            if (String.Equals(parameterComponents[param], "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                             {
                                 useMPLogger = false;
                             }
@@ -255,7 +254,6 @@ public bool ShowSummary
                 else
                 {
                     consoleLogger.ShowSummary = value;
-
                 }
             }
         }
@@ -322,10 +320,7 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
         /// </summary>
         public virtual void Shutdown()
         {
-            if (consoleLogger != null)
-            {
-                consoleLogger.Shutdown();
-            }
+            consoleLogger?.Shutdown();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 7ee72a75c8d..c580693d2a0 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -127,7 +126,7 @@ private void ParseParameters()
         /// </summary>
         private void ApplyParameter(string parameterName)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
+            ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
             if (forwardingTable.ContainsKey(parameterName))
             {
@@ -137,15 +136,15 @@ private void ApplyParameter(string parameterName)
 
             // If any of the following parameters are set, we will make sure we forward the events
             // necessary for the central logger to emit the requested information
-            if (0 == String.Compare(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 this.showPerfSummary = true;
             }
-            else if (0 == String.Compare(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 this.showSummary = false;
             }
-            else if (0 == String.Compare(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
             {
                 showCommandLine = true;
             }
@@ -156,7 +155,7 @@ private void ApplyParameter(string parameterName)
         /// </summary>
         public virtual void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
 
             ParseParameters();
 
@@ -191,7 +190,6 @@ public void Initialize(IEventSource eventSource, int nodeCount)
 
         private void SetForwardingBasedOnVerbosity()
         {
-
             forwardingTable[BuildStartedEventDescription] = 0;
             forwardingTable[BuildFinishedEventDescription] = 0;
 
@@ -254,7 +252,6 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
-
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 128db0a76cc..aa20ca20733 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -67,7 +67,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Compare("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if(string.IsNullOrEmpty(parameterValue))
                 {
@@ -90,7 +90,7 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
 
         public void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             ParseFileLoggerParameters();
             string fileName = logFile;
             try
@@ -112,11 +112,7 @@ public void Initialize(IEventSource eventSource)
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
-
-                if(nodeFileLogger != null)
-                {
-                    nodeFileLogger.Shutdown();
-                }
+                nodeFileLogger?.Shutdown();
 
                 string errorCode;
                 string helpKeyword;
@@ -130,10 +126,7 @@ public void Initialize(IEventSource eventSource)
 
         public void Shutdown()
         {
-            if (nodeFileLogger != null)
-            {
-                nodeFileLogger.Shutdown();
-            }
+            nodeFileLogger?.Shutdown();
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index baf2a2a9a89..1b36ffbd976 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -45,17 +45,14 @@ public FileLogger() : base(LoggerVerbosity.Normal)
         /// <param name="eventSource">Available events.</param>
         public override void Initialize(IEventSource eventSource)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(eventSource, "eventSource");
+            ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             eventSource.BuildFinished += FileLoggerBuildFinished;
             InitializeFileLogger(eventSource, 1);
         }
 
         private void FileLoggerBuildFinished(object sender, BuildFinishedEventArgs e)
         {
-            if (fileWriter != null)
-            {
-                fileWriter.Flush();
-            }
+            fileWriter?.Flush();
         }
 
         /// <summary>
@@ -99,10 +96,7 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, e.Message);
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
                 throw new LoggerException(message,e.InnerException,errorCode, helpKeyword);
             }
         }
@@ -133,10 +127,7 @@ private void Write(string text)
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, ex.Message);
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
                 throw new LoggerException(message, ex.InnerException, errorCode, helpKeyword);
             }
         }
@@ -154,10 +145,7 @@ public override void Shutdown()
             finally
             {
                 // Keep FxCop happy by closing in a Finally.
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
             }
         }
 
@@ -263,7 +251,6 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
         /// </summary>
         private static readonly char[] fileLoggerParameterValueSplitCharacter = { '=' };
 
-
         #endregion
     }
 }
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index b505e646692..5ba629eaa17 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -332,7 +332,6 @@ internal void CreateFromStream(BinaryReader reader)
             }
             else
             {
-
                 string assemblyName = null;
                 string assemblyFile = null;
 
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 11a0c9161f2..6ec726754cf 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -102,22 +102,22 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
             {
                 return true;
             }
-            if (0 == String.Compare(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
             {
                 showCommandline = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
             {
                 showTimeStamp = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
             {
                 showEventId = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
             {
                 forceNoAlign = true;
                 alignMessages = false;
@@ -376,7 +376,6 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
             // Loop through each of the warnings and put them into the correct buckets
             for (int listCount = 0; listCount < listToProcess.Count; listCount++)
             {
-
                 T errorWarningEventArgs = (T)listToProcess[listCount];
 
                 // Target event may be null for a couple of reasons:
@@ -431,7 +430,7 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
 
                 //If the target where the error occurred is the same as the previous message do not print the location
                 // where the error occurred again
-                if (String.Compare(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!String.Equals(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase))
                 {
                     //If no targetName was specified then do not show the target where the error occurred
                     if (! string.IsNullOrEmpty(valuePair.Key.TargetName))
@@ -1176,7 +1175,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                             // Calculate how many chars will fit on the console buffer
                             amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
                             WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), (prefixAlreadyWritten && index == 0 && i == 0), adjustedPrefixWidth);
-                            index = index + amountToCopy;
+                            index += amountToCopy;
                         }
                     }
                     else
@@ -1218,7 +1217,7 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
             TargetStartedEventMinimumFields targetStartedEvent = buildEventManager.GetTargetStartedEvent(e);
 
             //Make sure we have not shown the event before
-            if (targetStartedEvent != null && !targetStartedEvent.ShowTargetFinishedEvent)
+            if (targetStartedEvent?.ShowTargetFinishedEvent == false)
             {
                 //Since the target started event has been shows, the target finished event should also be shown
                 targetStartedEvent.ShowTargetFinishedEvent = true;
@@ -1271,7 +1270,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                 ProjectStartedEventMinimumFields projectStartedEvent = buildEventManager.GetProjectStartedEvent(e);
 
                 // Make sure the project started event has not been show yet
-                if (projectStartedEvent != null && !projectStartedEvent.ShowProjectFinishedEvent)
+                if (projectStartedEvent?.ShowProjectFinishedEvent == false)
                 {
                     projectStartedEvent.ShowProjectFinishedEvent = true;
 
@@ -1294,7 +1293,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         WriteLinePrefix(projectStartedEvent.FullProjectKey, projectStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
                         string message = string.Empty;
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             message = ResourceUtilities.FormatResourceString("ProjectStartedTopLevelProjectWithDefaultTargets", current, currentProjectNodeId);
                         }
@@ -1310,7 +1309,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(parentStartedEvent.FullProjectKey, parentStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             WriteMessageAligned(ResourceUtilities.FormatResourceString("ProjectStartedWithDefaultTargetsMultiProc", previous, parentStartedEvent.FullProjectKey, current, projectStartedEvent.FullProjectKey, currentProjectNodeId), true);
                         }
@@ -1509,7 +1508,6 @@ internal void AddEventStarted(string projectTargetNames, BuildEventContext build
             /// </summary>
             internal void AddEventFinished(string projectTargetNames, BuildEventContext buildEventContext, DateTime eventTimeStamp)
             {
-
                 if (!string.IsNullOrEmpty(projectTargetNames))
                 {
                     MPPerformanceCounter entryPoint = GetPerformanceCounter(projectTargetNames, ref internalPerformanceCounters);
@@ -1550,7 +1548,7 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                                "{0,3}", calls)
                    );
 
-                if (internalPerformanceCounters != null && internalPerformanceCounters.Count > 0)
+                if (internalPerformanceCounters?.Count > 0)
                 {
                     // For each of the entry points in the project print out the performance numbers for them
                     foreach (MPPerformanceCounter counter in internalPerformanceCounters.Values)
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index d8fa15e6395..5bd93664b6f 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -214,7 +214,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInProject)
+            if (startedEvent?.ErrorInProject == false)
             {
                 projectStartedEvents.Remove(e);
             }
@@ -227,7 +227,7 @@ internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInTarget)
+            if (startedEvent?.ErrorInTarget == false)
             {
                 targetStartedEvents.Remove(e);
             }
@@ -513,7 +513,6 @@ internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent)
             this.errorInTarget = false;
             this.buildEventContext = startedEvent.BuildEventContext;
             this.timeStamp = startedEvent.Timestamp;
-
         }
         #endregion
     }
@@ -566,7 +565,7 @@ public override bool Equals(object obj)
             {
                 return false;
             }
-           return  eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Compare(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase) == 0);
+           return  eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Equals(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
         }
 
         public override int GetHashCode()
@@ -657,7 +656,6 @@ public override bool Equals(object obj)
             ProjectFullKey compareKey = obj as ProjectFullKey;
             if (compareKey != null)
             {
-                
                 return ((compareKey.projectKey == this.projectKey) && (compareKey.entryPointKey == this.entryPointKey));
             }
             else
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index a3a3193e116..9328e140c4a 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -600,7 +600,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
 
                 if (previous == null)
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", current);
                     }
@@ -611,7 +611,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
                 }
                 else
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForNestedProjectWithDefaultTargets", previous, current);
                     }
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index 5015d92adb4..1626f53236d 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -13,6 +13,7 @@
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains the legacy compatibility shim for the MSBuild engine.  NOTE: This assembly is deprecated.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
+    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
   </PropertyGroup>
   
   <ItemGroup>
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index e168ef4fe4a..82bfd120cc5 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -54,9 +54,9 @@ internal enum PropertyType
     }
 
     /// <summary>
-    /// This class holds an MSBuild property.  This may be a property that is 
+    /// This class holds an MSBuild property.  This may be a property that is
     /// represented in the MSBuild project file by an XML element, or it
-    /// may not be represented in any real XML file (e.g., global properties, 
+    /// may not be represented in any real XML file (e.g., global properties,
     /// environment properties, etc.)
     /// </summary>
     /// <owner>rgoel</owner>
@@ -135,7 +135,7 @@ private static string Intern(string stringToIntern)
                 customInternTable.Add(stringToIntern, stringToIntern);
                 value = stringToIntern;
             }
-            
+
             return value;
         }
 
@@ -186,7 +186,7 @@ internal BuildProperty
             XmlElement      propertyElement,
             PropertyType    propertyType
         ) :
-            this(propertyElement, 
+            this(propertyElement,
                  propertyElement != null ? Utilities.GetXmlNodeInnerContents(propertyElement) : null,
                  propertyType)
         {
@@ -231,7 +231,7 @@ PropertyType propertyType
                         break;
 
                     default:
-                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyAttribute); 
+                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyAttribute);
                         break;
                 }
             }
@@ -239,7 +239,6 @@ PropertyType propertyType
             this.propertyValue = propertyValue;
             this.finalValueEscaped = propertyValue;
             this.type = propertyType;
-
         }
 
         /// <summary>
@@ -257,12 +256,12 @@ internal BuildProperty
         (
             XmlDocument ownerDocument,
             string propertyName,
-            string propertyValue, 
+            string propertyValue,
             PropertyType propertyType
         )
         {
-            ErrorUtilities.VerifyThrowArgumentLength(propertyName, "propertyName");
-            ErrorUtilities.VerifyThrowArgumentNull(propertyValue, "propertyValue");
+            ErrorUtilities.VerifyThrowArgumentLength(propertyName, nameof(propertyName));
+            ErrorUtilities.VerifyThrowArgumentNull(propertyValue, nameof(propertyValue));
 
             // Validate that the property name doesn't contain any illegal characters.
             XmlUtilities.VerifyThrowValidElementName(propertyName);
@@ -306,7 +305,6 @@ PropertyType propertyType
 
             // Assign the property type.
             this.type = propertyType;
-
         }
 
         /// <summary>
@@ -324,7 +322,7 @@ PropertyType propertyType
         internal BuildProperty
         (
             string propertyName,
-            string propertyValue, 
+            string propertyValue,
             PropertyType propertyType
         ) :
             this(null, propertyName, propertyValue, propertyType)
@@ -332,8 +330,8 @@ PropertyType propertyType
         }
 
         /// <summary>
-        /// Constructor, which initializes the property from just the property 
-        /// name and value, creating it as a "normal" property.  This ends up 
+        /// Constructor, which initializes the property from just the property
+        /// name and value, creating it as a "normal" property.  This ends up
         /// creating a new XML element for the property under a dummy XML document.
         /// </summary>
         /// <param name="propertyName"></param>
@@ -349,7 +347,7 @@ string propertyValue
         }
 
         /// <summary>
-        /// Default constructor.  This is not allowed because it leaves the 
+        /// Default constructor.  This is not allowed because it leaves the
         /// property in a bad state -- without a name or value.  But we have to
         /// have it, otherwise FXCop complains.
         /// </summary>
@@ -367,16 +365,16 @@ private BuildProperty
 
         /// <summary>
         /// Accessor for the property name.  This is read-only, so one cannot
-        /// change the property name once it's set ... your only option is 
+        /// change the property name once it's set ... your only option is
         /// to create a new BuildProperty object.  The reason is that BuildProperty objects
-        /// are often stored in hash tables where the hash function is based 
+        /// are often stored in hash tables where the hash function is based
         /// on the property name.  Modifying the property name of an existing
         /// BuildProperty object would make the hash table incorrect.
         /// </summary>
         /// <owner>RGoel</owner>
         public string Name
         {
-            get 
+            get
             {
                 if (propertyElement != null)
                 {
@@ -386,7 +384,7 @@ public string Name
                 else
                 {
                     // If we are not persisted, propertyName and propertyValue must not be null.
-                    ErrorUtilities.VerifyThrow((this.propertyName != null) && (this.propertyName.Length > 0) && (this.propertyValue != null),
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(this.propertyName) && (this.propertyValue != null),
                         "BuildProperty object doesn't have a name/value pair.");
 
                     // Get the property name from the string variable
@@ -405,13 +403,13 @@ public string Value
             get
             {
                 // If we are not persisted, propertyName and propertyValue must not be null.
-                ErrorUtilities.VerifyThrow(this.propertyValue != null, 
+                ErrorUtilities.VerifyThrow(this.propertyValue != null,
                     "BuildProperty object doesn't have a name/value pair.");
 
                 return this.propertyValue;
             }
 
-            set 
+            set
             {
                 ErrorUtilities.VerifyThrowInvalidOperation(this.type != PropertyType.ImportedProperty,
                     "CannotModifyImportedProjects", this.Name);
@@ -493,7 +491,7 @@ public string FinalValue
         }
 
         /// <summary>
-        /// Accessor for the property type.  This is internal, so that nobody 
+        /// Accessor for the property type.  This is internal, so that nobody
         /// calling the OM can modify the type.  We actually need to modify
         /// it in certain cases internally.  C# doesn't allow a different
         /// access mode for the "get" vs. the "set", so we've made them both
@@ -502,12 +500,12 @@ public string FinalValue
         /// <owner>RGoel</owner>
         internal PropertyType Type
         {
-            get 
+            get
             {
                 return this.type;
             }
 
-            set 
+            set
             {
                 this.type = value;
             }
@@ -606,7 +604,7 @@ internal BuildPropertyGroup ParentPersistedPropertyGroup
         #region Methods
 
         /// <summary>
-        /// Given a property bag, this method evaluates the current property, 
+        /// Given a property bag, this method evaluates the current property,
         /// expanding any property references contained within.  It stores this
         /// evaluated value in the "finalValue" member.
         /// </summary>
@@ -633,16 +631,16 @@ private void MarkPropertyAsDirty
             {
                 ErrorUtilities.VerifyThrow(this.ParentPersistedPropertyGroup.ParentProject != null, "Persisted BuildPropertyGroup doesn't have parent project.");
                 this.ParentPersistedPropertyGroup.MarkPropertyGroupAsDirty();
-            };
+            }
         }
 
         /// <summary>
         /// Creates a shallow or deep clone of this BuildProperty object.
-        /// 
-        /// A shallow clone points at the same XML element as the original, so 
-        /// that modifications to the name or value will be reflected in both 
+        ///
+        /// A shallow clone points at the same XML element as the original, so
+        /// that modifications to the name or value will be reflected in both
         /// copies.  However, the two copies could have different a finalValue.
-        /// 
+        ///
         /// A deep clone actually clones the XML element as well, so that the
         /// two copies are completely independent of each other.
         /// </summary>
@@ -711,9 +709,9 @@ BuildProperty compareToProperty
             // just a back-pointer, and doesn't really contribute to the "identity" of
             // the property.
 
-            return 
+            return
                 (compareToProperty != null) &&
-                (0 == String.Compare(compareToProperty.propertyName, this.propertyName, StringComparison.OrdinalIgnoreCase)) &&
+                (String.Equals(compareToProperty.propertyName, this.propertyName, StringComparison.OrdinalIgnoreCase)) &&
                 (compareToProperty.propertyValue                == this.propertyValue) &&
                 (compareToProperty.FinalValue                   == this.FinalValue) &&
                 (compareToProperty.type                         == this.type);
@@ -744,7 +742,7 @@ public override string ToString
         public static explicit operator string
         (
             BuildProperty propertyToCast
-        ) 
+        )
         {
             if (propertyToCast == null)
             {
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index cfc4f221e58..c1211cc633c 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -242,7 +242,7 @@ internal BuildPropertyGroup(Project parentProject, XmlElement propertyGroupEleme
 
                     // Unrecognized attribute.
                     default:
-                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyGroupAttribute); 
+                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyGroupAttribute);
                         break;
                 }
             }
@@ -386,7 +386,7 @@ internal XmlAttribute ConditionAttribute
         }
 
         /// <summary>
-        /// Accessor for the XmlElement representing this property group.  This is 
+        /// Accessor for the XmlElement representing this property group.  This is
         /// internal to MSBuild, and is read-only.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -525,7 +525,7 @@ internal string ImportedFromFilename
         /// <returns>The property with the given name, or null if it does not exist in this group</returns>
         public BuildProperty this[string propertyName]
         {
-            get 
+            get
             {
                 // We don't support this method for PropertyGroups that are persisted.
                 // This is because persisted PropertyGroups can contain multiple 
@@ -545,7 +545,7 @@ public BuildProperty this[string propertyName]
 
                 // Make sure that the property name passed into the indexer matches
                 // the property name on the BuildProperty object.
-                error.VerifyThrowArgument(0 == String.Compare(propertyName, value.Name, StringComparison.OrdinalIgnoreCase),
+                error.VerifyThrowArgument(String.Equals(propertyName, value.Name, StringComparison.OrdinalIgnoreCase),
                     "PropertyNamesDoNotMatch", "BuildProperty");
 
                 this.SetProperty(value);
@@ -627,7 +627,7 @@ bool deepClone
                     // Do not set the ParentProject on the new BuildPropertyGroup, because it isn't really
                     // part of the project
                     clone = new BuildPropertyGroup(null, propertyTableByName.Count);
-                    
+
                     foreach (DictionaryEntry propertyEntry in this.propertyTableByName)
                     {
                         // If the caller requested a deep clone, then deep clone the BuildProperty object,
@@ -707,8 +707,8 @@ part of the project */
         /// <summary>
         /// ImportInitialProperties is used when setting up an evaluated BuildProperty
         /// Group with the initial set of properties from MSBuild reserved properties,
-        /// environment variables, tools version dependent properties, and global 
-        /// properties.  After this virtual BuildPropertyGroup has been populated with 
+        /// environment variables, tools version dependent properties, and global
+        /// properties.  After this virtual BuildPropertyGroup has been populated with
         /// these, we can continue to read in the properties from the project file.
         /// </summary>
         /// <param name="environmentProperties"></param>
@@ -718,9 +718,9 @@ part of the project */
         /// <owner>RGoel</owner>
         internal void ImportInitialProperties
         (
-            BuildPropertyGroup environmentProperties, 
-            BuildPropertyGroup reservedProperties, 
-            BuildPropertyGroup toolsVersionDependentProperties, 
+            BuildPropertyGroup environmentProperties,
+            BuildPropertyGroup reservedProperties,
+            BuildPropertyGroup toolsVersionDependentProperties,
             BuildPropertyGroup globalProperties
         )
         {
@@ -754,7 +754,7 @@ BuildPropertyGroup globalProperties
         }
 
         /// <summary>
-        /// Sets a property. 
+        /// Sets a property.
         ///
         /// Either overrides the value of the property with the given name, or adds it if it
         /// doesn't already exist. Setting to the same value as before does nothing.
@@ -812,7 +812,7 @@ BuildProperty newProperty
                 {
                     // Allow properties to be "set" to the same value during a build. This is because Visual Studio unfortunately does this often,
                     // and it is safe to do this, because we won't actually change any state.
-                    ErrorUtilities.VerifyThrowInvalidOperation(parentProject == null || !parentProject.IsBuilding, "CannotSetPropertyDuringBuild");
+                    ErrorUtilities.VerifyThrowInvalidOperation(parentProject?.IsBuilding != true, "CannotSetPropertyDuringBuild");
                 }
             }
 
@@ -831,7 +831,7 @@ BuildProperty newProperty
                 }
                 else
                 {
-                    error.VerifyThrow((existingProperty == null) || (existingProperty.Type != PropertyType.OutputProperty), 
+                    error.VerifyThrow((existingProperty == null) || (existingProperty.Type != PropertyType.OutputProperty),
                         "If the property already exists in the main property table, it can't already be there as an output property, because then we would have stored an entry in propertiesOverriddenByOutputProperties.");
 
                     // NOTE: Use Hashtable.Add() because each output property should only be added to this
@@ -851,8 +851,8 @@ BuildProperty newProperty
         }
 
         /// <summary>
-        /// Sets a property taking the property name and value as strings directly. 
-        /// 
+        /// Sets a property taking the property name and value as strings directly.
+        ///
         /// Either overrides the value of the property with the given name, or adds it if it
         /// doesn't already exist. Setting to the same value as before does nothing.
         ///
@@ -883,7 +883,7 @@ public void SetProperty
             bool treatPropertyValueAsLiteral
             )
         {
-            this.SetProperty(propertyName, 
+            this.SetProperty(propertyName,
                 treatPropertyValueAsLiteral ? EscapingUtilities.Escape(propertyValue) : propertyValue);
         }
 
@@ -964,12 +964,12 @@ Project importedProject
         }
 
         /// <summary>
-        /// Adds an existing BuildProperty to the list of properties, does not attempt 
+        /// Adds an existing BuildProperty to the list of properties, does not attempt
         /// to add backing Xml for the item.
         /// </summary>
         /// <param name="propertyToAdd"></param>
         /// <owner>JomoF</owner>
-        internal void AddExistingProperty 
+        internal void AddExistingProperty
         (
             BuildProperty propertyToAdd
         )
@@ -1004,7 +1004,7 @@ BuildProperty propertyToAdd
             // Make sure the property to be added has an XML element backing it,
             // and that its XML belongs to the same XML document as our BuildPropertyGroup.
             error.VerifyThrow(propertyToAdd.PropertyElement != null, "BuildProperty does not have an XML element");
-            error.VerifyThrow(propertyToAdd.PropertyElement.OwnerDocument == this.ownerDocument, 
+            error.VerifyThrow(propertyToAdd.PropertyElement.OwnerDocument == this.ownerDocument,
                 "Cannot add an BuildProperty with a different XML owner document.");
 
             // For persisted groups, just append the property at the end of the <BuildPropertyGroup> tag.
@@ -1025,7 +1025,7 @@ public void RemoveProperty
             BuildProperty property
         )
         {
-            error.VerifyThrowArgumentNull(property, "property");
+            error.VerifyThrowArgumentNull(property, nameof(property));
 
             // If this is a persisted <PropertyGroup>, then remove the property element from 
             // the XML and from the array list.
@@ -1087,7 +1087,7 @@ string propertyName
                 // name.
                 foreach (BuildProperty property in this)
                 {
-                    if (0 == String.Compare(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
                     {
                         // Add the property to our list of things to remove.
                         propertiesToRemove.Add(property);
@@ -1109,10 +1109,7 @@ string propertyName
                 this.propertyTableByName.Remove(propertyName);
 
                 // if the property was overridden by an output property, we also want to remove the original
-                if (propertiesOverriddenByOutputProperties != null)
-                {
-                    propertiesOverriddenByOutputProperties.Remove(propertyName);
-                }
+                propertiesOverriddenByOutputProperties?.Remove(propertyName);
             }
 
             this.MarkPropertyGroupAsDirty();
@@ -1128,7 +1125,6 @@ internal void EnsureNoReservedProperties()
                 // Make sure this property doesn't override a reserved property
                 ProjectErrorUtilities.VerifyThrowInvalidProject(this.ParentProject.ReservedProperties[property.Name] == null,
                     property.PropertyElement, "CannotModifyReservedProperty", property.Name);
-
             }
         }
 
@@ -1216,19 +1212,13 @@ internal void ClearHelper(bool clearImportedPropertyGroup)
             this.conditionAttribute = null;
 
             // Clear the contents of the hash table, if one exists.
-            if (this.propertyTableByName != null)
-            {
-                this.propertyTableByName.Clear();
-            }
+            this.propertyTableByName?.Clear();
 
             // clear out saved properties
             propertiesOverriddenByOutputProperties = null;
 
             // Clear the contents of the arraylist, if one exists.
-            if (this.propertyList != null)
-            {
-                this.propertyList.Clear();
-            }
+            this.propertyList?.Clear();
 
             this.MarkPropertyGroupAsDirty();
         }
@@ -1277,7 +1267,7 @@ internal void MarkPropertyGroupAsDirty
                     // example, if a global property changes....
                     this.ParentProject.MarkProjectAsDirtyForReevaluation();
                 }
-            };
+            }
         }
 
         /// <summary>
@@ -1287,7 +1277,7 @@ internal void MarkPropertyGroupAsDirty
         /// the previously gathered variables, and set new ones. This method
         /// will not, however, unset previously set variables.
         /// Requires property group to be virtual.
-        /// 
+        ///
         /// NOTE: this method does not allow environment variables to override
         /// previously set properties of type "GlobalProperty" or "ReservedProperty"
         /// </summary>
@@ -1333,7 +1323,7 @@ private void SetExtensionsPathProperties()
             // "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
             string programFiles = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
-    
+
             // Similarly for "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
             string programFiles32 = Environment.GetEnvironmentVariable(Constants.programFilesx86);
@@ -1352,7 +1342,7 @@ private void SetExtensionsPathProperties()
 
             bool useLegacyMSBuildExtensionsPathBehavior = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH"));
 
-            string extensionsPath; 
+            string extensionsPath;
             if (useLegacyMSBuildExtensionsPathBehavior)
             {
                 extensionsPath = Path.Combine(programFiles, ReservedPropertyNames.extensionsPathSuffix);
@@ -1367,7 +1357,7 @@ private void SetExtensionsPathProperties()
 
         /// <summary>
         /// This method does a comparison of the actual contents of two property bags
-        /// and returns True if they are equal, else False.  Equality means that 
+        /// and returns True if they are equal, else False.  Equality means that
         /// the two collections contain the same set of property names (case insensitive)
         /// with the same values (case sensitive).
         /// Requires property group to be virtual.
@@ -1484,11 +1474,11 @@ string arg
 
             // If this is a persisted element, then we should have an
             // ArrayList of BuildProperty objects, but not a hash table.
-            error.VerifyThrow(this.propertyList != null, 
+            error.VerifyThrow(this.propertyList != null,
                 "ArrayList of BuildProperty objects expected for this BuildPropertyGroup.");
-            error.VerifyThrow(this.propertyTableByName == null, 
+            error.VerifyThrow(this.propertyTableByName == null,
                 "HashTable of BuildProperty objects not expected for this BuildPropertyGroup.");
-            error.VerifyThrow(this.ownerDocument != null, 
+            error.VerifyThrow(this.ownerDocument != null,
                 "There must be an owner document. It should have been set in the constructor.");
         }
 
@@ -1501,7 +1491,7 @@ private void MustBelongToPropertyGroup
             XmlElement propertyElement
         )
         {
-            error.VerifyThrowInvalidOperation(propertyElement != null, 
+            error.VerifyThrowInvalidOperation(propertyElement != null,
                 "PropertyDoesNotBelongToPropertyGroup");
             error.VerifyThrowInvalidOperation(propertyElement.ParentNode == this.propertyGroupElement,
                 "PropertyDoesNotBelongToPropertyGroup");
diff --git a/src/Deprecated/Engine/Resources/Constants.cs b/src/Deprecated/Engine/Resources/Constants.cs
index 23106a2504e..30c3ff7b0e5 100644
--- a/src/Deprecated/Engine/Resources/Constants.cs
+++ b/src/Deprecated/Engine/Resources/Constants.cs
@@ -45,16 +45,16 @@ internal static bool IsReservedProperty(string property)
         {
             return 
                 (
-                    (String.Compare(property, projectDirectory, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectFile, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectExtension, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectFullPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectName, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, binPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, toolsPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectDefaultTargets, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, programFiles32, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, assemblyVersion, StringComparison.OrdinalIgnoreCase) == 0)
+                    (String.Equals(property, projectDirectory, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectFile, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectExtension, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectFullPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectName, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, binPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, toolsPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectDefaultTargets, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, programFiles32, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, assemblyVersion, StringComparison.OrdinalIgnoreCase))
                     // Intentionally do not include MSBuildExtensionsPath or MSBuildExtensionsPath32 in this list.  We need tasks to be able to override those.
                 );
         }
diff --git a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
index f9d16f4a33a..52316d4fe4c 100644
--- a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
@@ -22,7 +22,7 @@ internal sealed class AssemblyLoadInfo
         /// <param name="assemblyFile"></param>
         public AssemblyLoadInfo(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName != null) && (assemblyName.Length > 0)) || ((assemblyFile != null) && (assemblyFile.Length > 0)),
+            ErrorUtilities.VerifyThrow((!string.IsNullOrEmpty(assemblyName)) || (!string.IsNullOrEmpty(assemblyFile)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index 2dbf3da4b36..dd92e681f9b 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -123,7 +123,6 @@ internal string Name
             }
         }
 
-
         /// <summary>
         /// The assembly's version number.
         /// </summary>
@@ -226,7 +225,6 @@ internal static AssemblyNameExtension UnnamedAssembly
         /// <returns></returns>
         internal int CompareTo(AssemblyNameExtension that)
         {
-
             // Are they identical?
             if (this.Equals(that))
             {
@@ -397,7 +395,7 @@ internal bool Equals(AssemblyNameExtension that)
             }
 
             // Do the names match?
-            if (0 != String.Compare(Name, that.Name, StringComparison.OrdinalIgnoreCase))
+            if (!String.Equals(Name, that.Name, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
diff --git a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
index 111786115c7..03d78fe93bd 100644
--- a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
@@ -31,7 +31,7 @@ internal ConfigurationInSolution(string configurationName, string platformName)
             this.platformName = platformName;
 
             // Some configurations don't have the platform part
-            if ((platformName != null) && (platformName.Length > 0))
+            if (!string.IsNullOrEmpty(platformName))
             {
                 this.fullName = string.Format(CultureInfo.InvariantCulture, "{0}{1}{2}", configurationName, configurationPlatformSeparator, platformName);
             }
diff --git a/src/Deprecated/Engine/Shared/ConversionUtilities.cs b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
index 0ea5e8ad182..bd0dcb8683a 100644
--- a/src/Deprecated/Engine/Shared/ConversionUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
@@ -53,12 +53,12 @@ internal static bool CanConvertStringToBool(string parameterValue)
         /// </summary>
         private static bool ValidBooleanTrue(string parameterValue)
         {
-            return ((String.Compare(parameterValue, "true", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "on", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "yes", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!false", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!off", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!no", StringComparison.OrdinalIgnoreCase) == 0));
+            return ((String.Equals(parameterValue, "true", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "on", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "yes", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!false", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!off", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!no", StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
@@ -67,12 +67,12 @@ private static bool ValidBooleanTrue(string parameterValue)
         /// </summary>
         private static bool ValidBooleanFalse(string parameterValue)
         {
-            return ((String.Compare(parameterValue, "false", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "off", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "no", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!true", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!on", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!yes", StringComparison.OrdinalIgnoreCase) == 0));
+            return ((String.Equals(parameterValue, "false", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "off", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "no", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!true", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!on", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!yes", StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/EscapingUtilities.cs b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
index 3baf1c1d815..4edc578dfac 100644
--- a/src/Deprecated/Engine/Shared/EscapingUtilities.cs
+++ b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
@@ -16,7 +16,7 @@ static internal class EscapingUtilities
     {
         /// <summary>
         /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX. 
+        /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString"></param>
         /// <returns>unescaped string</returns>
@@ -31,7 +31,7 @@ string escapedString
 
         /// <summary>
         /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX. 
+        /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString"></param>
         /// <param name="escapingWasNecessary"></param>
@@ -53,7 +53,7 @@ out bool escapingWasNecessary
             {
                 return escapedString;
             }
-            
+
             // This is where we're going to build up the final string to return to the caller.
             StringBuilder unescapedString = new StringBuilder();
 
@@ -76,7 +76,7 @@ out bool escapingWasNecessary
 
                     // Convert the %XX to an actual real character.
                     string hexString = escapedString.Substring(indexOfPercent + 1, 2);
-                    char unescapedCharacter = (char) int.Parse(hexString, System.Globalization.NumberStyles.HexNumber, 
+                    char unescapedCharacter = (char) int.Parse(hexString, System.Globalization.NumberStyles.HexNumber,
                         CultureInfo.InvariantCulture);
 
                     // if the unescaped character is not on the exception list, append it
@@ -101,7 +101,7 @@ out bool escapingWasNecessary
         }
 
         /// <summary>
-        /// Adds instances of %XX in the input string where the char char to be escaped appears
+        /// Adds instances of %XX in the input string where the char to be escaped appears
         /// XX is the hex value of the ASCII code for the char.
         /// </summary>
         /// <param name="unescapedString"></param>
@@ -170,7 +170,7 @@ string escapedString
                     )
                 {
                     // It has either a '%2' or a '%3'.  This is looking very promising.
-                    return 
+                    return
                         (
                             (-1 != escapedString.IndexOf("%2a", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%2A", StringComparison.Ordinal)) ||
@@ -184,9 +184,9 @@ string escapedString
 
         /// <summary>
         /// Special characters that need escaping.
-        /// It's VERY important that the percent character is the FIRST on the list - since it's both a character 
-        /// we escape and use in escape sequences, we can unintentionally escape other escape sequences if we 
-        /// don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits 
+        /// It's VERY important that the percent character is the FIRST on the list - since it's both a character
+        /// we escape and use in escape sequences, we can unintentionally escape other escape sequences if we
+        /// don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits
         /// (that would require rewriting the algorithm) but since it seems unlikely that we ever do, this should
         /// be good enough to avoid complicating the algorithm at this point.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
index 4a86b11903b..0e449a15cc3 100644
--- a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
+++ b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
@@ -51,7 +51,7 @@ internal static string FormatEventMessage(BuildErrorEventArgs e)
         /// <returns>The formatted message string.</returns>
         internal static string FormatEventMessage(BuildErrorEventArgs e, bool removeCarriageReturn)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "error" should not be localized
             return FormatEventMessage("error", e.Subcategory, removeCarriageReturn ? EscapeCarriageReturn(e.Message) : e.Message,
@@ -80,7 +80,7 @@ internal static string FormatEventMessage(BuildWarningEventArgs e)
         /// <returns>The formatted message string.</returns>
         internal static string FormatEventMessage(BuildWarningEventArgs e, bool removeCarriageReturn)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(e, "e");
+            ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "warning" should not be localized
             return FormatEventMessage("warning", e.Subcategory, removeCarriageReturn ? EscapeCarriageReturn(e.Message) : e.Message,
@@ -129,7 +129,7 @@ int threadId
             }
             */
 
-            if ((file == null) || (file.Length == 0))
+            if (string.IsNullOrEmpty(file))
             {
                 format.Append("MSBUILD : ");    // Should not be localized.
             }
@@ -182,7 +182,7 @@ int threadId
                 }
             }
 
-            if ((subcategory != null) && (subcategory.Length != 0))
+            if (!string.IsNullOrEmpty(subcategory))
             {
                 format.Append("{9} ");
             }
@@ -236,7 +236,6 @@ int threadId
             return formattedMessage.ToString();
         }
 
-
         /// <summary>
         /// Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 14872e95a16..e73eb79374c 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -56,7 +56,6 @@ internal enum FileSystemEntity
         /// <returns>True if the directory exists.</returns>
         internal delegate bool DirectoryExists(string path);
 
-
         /// <summary>
         /// Determines whether the given path has any wild card characters.
         /// </summary>
@@ -253,7 +252,6 @@ internal static string GetLongPathName
             GetFileSystemEntries getFileSystemEntries
         )
         {
-
             if (path.IndexOf("~", StringComparison.Ordinal) == -1)
             {
                 // A path with no '~' must not be a short name.
@@ -308,7 +306,6 @@ GetFileSystemEntries getFileSystemEntries
                 }
                 else
                 {
-
                     if (parts[i].IndexOf("~", StringComparison.Ordinal) == -1)
                     {
                         // If there's no ~, don't hit the disk.
@@ -841,7 +838,6 @@ out bool isLegalFileSpec
 
             } while (matchFileExpression.Length < sizeBefore);
 
-
             /*
              * By definition, "**" must appear alone between directory slashes. If there is any remaining "**" then this is not
              * a valid filespec.
@@ -902,8 +898,6 @@ out bool isLegalFileSpec
             return matchFileExpression.ToString();
         }
 
-
-
         /// <summary>
         /// Given a filespec, get the information needed for file matching. 
         /// </summary>
@@ -1249,8 +1243,7 @@ DirectoryExists directoryExists
             // 2) if the extension is three characters, and the filename contains the * wildcard, it matches files with longer
             //    extensions that start with the same three characters e.g. "*.htm" would match both "file.htm" and "file.html"
             bool needToEnforceExtensionLength =
-                    (extensionPart != null) &&
-                    (extensionPart.IndexOf('*') == -1)
+                    (extensionPart?.IndexOf('*') == -1)
                 &&
                     (extensionPart.EndsWith("?", StringComparison.Ordinal)
                 ||
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 82ff1e65b26..dda680e6c79 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -12,7 +12,6 @@
 using System.Threading;
 using System.Runtime.InteropServices;
 
-
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
@@ -97,7 +96,6 @@ internal static bool IsItemSpecModifier(string name)
                 return false;
             }
 
-
             /* 
              * What follows requires some explanation.
              * 
@@ -333,7 +331,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                 try
                 {
-                    if (String.Compare(modifier, ItemSpecModifiers.FullPath, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(modifier, ItemSpecModifiers.FullPath, StringComparison.OrdinalIgnoreCase))
                     {
                         if(currentDirectory == null)
                         {
@@ -342,7 +340,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                         modifiedItemSpec = GetFullPath(itemSpec, currentDirectory);
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RootDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RootDir, StringComparison.OrdinalIgnoreCase))
                     {
                         if (currentDirectory == null)
                         {
@@ -362,7 +360,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec += Path.DirectorySeparatorChar;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Filename, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Filename, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no filename
                         if (Path.GetDirectoryName(itemSpec) == null)
@@ -376,7 +374,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetFileNameWithoutExtension(itemSpec);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Extension, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Extension, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no extension
                         if (Path.GetDirectoryName(itemSpec) == null)
@@ -390,11 +388,11 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetExtension(itemSpec);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RelativeDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RelativeDir, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = GetDirectory(itemSpec);
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Directory, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Directory, StringComparison.OrdinalIgnoreCase))
                     {
                         if (currentDirectory == null)
                         {
@@ -417,16 +415,16 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = modifiedItemSpec.Substring(root.Length + 1);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
                     {
                         // only the BuildItem class can compute this modifier -- so leave empty
                         modifiedItemSpec = String.Empty;
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Identity, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Identity, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = itemSpec;
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.ModifiedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.ModifiedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -446,7 +444,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.CreatedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.CreatedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -464,7 +462,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.AccessedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.AccessedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -795,8 +793,8 @@ internal static bool IsVCProjFilename(string filename)
         /// <returns>relative path (can be the full path)</returns>
         internal static string MakeRelative(string basePath, string path)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(basePath, "basePath");
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
+            ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
             if (basePath.Length == 0)
             {
@@ -828,7 +826,7 @@ internal static string MakeRelative(string basePath, string path)
         /// <returns>uri object</returns>
         private static Uri CreateUriFromPath(string path)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(path, "path");
+            ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
             Uri pathUri = null;
 
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index 44491ff72c4..d5a8422995e 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -64,7 +64,6 @@ internal static class FrameworkLocationHelper
         internal const string fullDotNetFrameworkSdkRegistryKeyV40 = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathV40;
         internal const string dotNetFrameworkSdkInstallKeyValueV40 = "InstallationFolder";
 
-
         private const string dotNetFrameworkAssemblyFoldersRegistryKeyV40 = dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV40;
         private const string secondaryDotNetFrameworkSdkRegistryPathV40 = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows";
         internal const string secondaryDotNetFrameworkSdkInstallKeyValueV40 = "CurrentInstallFolder";
@@ -85,7 +84,6 @@ internal static string PathToDotNetFrameworkV11
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV11 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -113,7 +111,6 @@ internal static string PathToDotNetFrameworkV20
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV20 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -141,7 +138,6 @@ internal static string PathToDotNetFrameworkV30
                     }
                     else
                     {
-
                         FrameworkLocationHelper.pathToDotNetFrameworkV30 =
                             FindDotNetFrameworkPath(
                                 Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName),
@@ -269,7 +265,6 @@ internal static string PathToDotNetFrameworkSdkV35
                             secondaryDotNetFrameworkSdkRegistryPathV35,
                             secondaryDotNetFrameworkSdkInstallKeyValueV35);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkSdkV35;
@@ -302,7 +297,6 @@ internal static string PathToDotNetFrameworkSdkV40
                             secondaryDotNetFrameworkSdkRegistryPathV40,
                             secondaryDotNetFrameworkSdkInstallKeyValueV40);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkSdkV40;
@@ -347,7 +341,6 @@ internal static string PathToDotNetFrameworkReferenceAssembliesV35
                     {
                         FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV35 = GenerateReferenceAssemblyDirectory(dotNetFrameworkVersionFolderPrefixV35);
                     }
-
                 }
 
                 return FrameworkLocationHelper.pathToDotNetFrameworkReferenceAssembliesV35;
@@ -472,7 +465,7 @@ internal static bool CheckForFrameworkInstallation(string registryEntryToCheckIn
             if (String.IsNullOrEmpty(complusInstallRoot) && String.IsNullOrEmpty(complusVersion))
             {
                 // If the registry entry is 1 then the framework is installed. Go ahead and find the directory. If it is not 1 then the framework is not installed, return null.
-                return String.Compare("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase) == 0;
+                return String.Equals("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase);
             }
 
             return true;
@@ -524,7 +517,7 @@ GetDirectories getDirectories
             // This was removed in beta2
             // We should favor \v3.5 over \v3.5.xxxxx
             // versions previous to 2.0 have .xxxx version numbers.  3.0 and 3.5 do not.
-            if (max.EndsWith(prefix, StringComparison.OrdinalIgnoreCase) != true )
+            if (!max.EndsWith(prefix, StringComparison.OrdinalIgnoreCase))
             {
                 for (int i = 1; i < directories.Length; ++i)
                 {
diff --git a/src/Deprecated/Engine/Shared/LoadedType.cs b/src/Deprecated/Engine/Shared/LoadedType.cs
index 47ec35d0174..6cbb2758453 100644
--- a/src/Deprecated/Engine/Shared/LoadedType.cs
+++ b/src/Deprecated/Engine/Shared/LoadedType.cs
@@ -205,6 +205,5 @@ internal AssemblyLoadInfo Assembly
 
         // whether the loadinseparateappdomain attribute is applied to this type
         private bool? hasLoadInSeparateAppDomainAttribute;
-
     }
 }
diff --git a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
index ee6cb1b6727..e443b6f188c 100644
--- a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
@@ -50,7 +50,7 @@ internal bool IncludeInBuild
         /// <owner>LukaszG</owner>
         static private string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
-            if (string.Compare(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
                 return "AnyCPU";
 
             return platformName;
diff --git a/src/Deprecated/Engine/Shared/ProjectInSolution.cs b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
index 0c720f90641..c3cf27ccd70 100644
--- a/src/Deprecated/Engine/Shared/ProjectInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
@@ -249,9 +249,9 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                     }
                 }
 
-                if (mainProjectElement != null && mainProjectElement.LocalName == "Project")
+                if (mainProjectElement?.LocalName == "Project")
                 {
-                    if (String.Compare(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase))
                     {
                         canBeMSBuildProjectFile = true;
                         return canBeMSBuildProjectFile;
@@ -374,7 +374,7 @@ static internal string DisambiguateProjectTargetName(string uniqueProjectName)
             // entry point targets
             foreach (string projectName in projectNamesToDisambiguate)
             {
-                if (String.Compare(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase))
                 {
                     // Prepend "Solution:" so that the collision is resolved, but the
                     // log of the solution project still looks reasonable.
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index 89cb88cf8b2..a0839d3b360 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -121,7 +121,7 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 0bb83616e54..93f6aa0d908 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -312,7 +312,7 @@ private string ReadLine()
         /// <owner>RGoel</owner>
         internal void ParseSolutionFile()
         {
-            error.VerifyThrow((solutionFile != null) && (solutionFile.Length != 0), "ParseSolutionFile() got a null solution file!");
+            error.VerifyThrow(!string.IsNullOrEmpty(solutionFile), "ParseSolutionFile() got a null solution file!");
 
             FileStream fileStream = null;
             reader = null;
@@ -328,15 +328,9 @@ internal void ParseSolutionFile()
             }
             finally
             {
-                if (fileStream != null)
-                {
-                    fileStream.Close();
-                }
+                fileStream?.Close();
 
-                if (reader != null)
-                {
-                    reader.Close();
-                }
+                reader?.Close();
             }
         }
 
@@ -412,7 +406,6 @@ internal void ParseSolution()
                 // Update the hash table with this unique name
                 projectsByUniqueName[uniqueName] = proj;
             }
-
         } // ParseSolutionFile()
 
         /// <summary>
@@ -501,7 +494,6 @@ private void ValidateSolutionFileVersion(string versionString)
                 "SolutionParseVersionMismatchError", 
                 slnFileMinUpgradableVersion, slnFileMaxVersion);
 
-
             // If the solution file version is greater than the maximum one we will create a comment rather than warn
             // as users such as blend opening a dev10 project cannot do anything about it.
             if (this.slnFileActualVersion > slnFileMaxVersion)
@@ -531,7 +523,7 @@ private void ValidateSolutionFileVersion(string versionString)
         /// <owner>RGoel</owner>
         private void ParseProject(string firstLine)
         {
-            error.VerifyThrow((firstLine != null) && (firstLine.Length != 0), "ParseProject() got a null firstLine!");
+            error.VerifyThrow(!string.IsNullOrEmpty(firstLine), "ParseProject() got a null firstLine!");
             error.VerifyThrow(reader != null, "ParseProject() got a null reader!");
 
             ProjectInSolution proj = new ProjectInSolution(this);
@@ -555,7 +547,7 @@ private void ParseProject(string firstLine)
                     // We have a ProjectDependencies section.  Each subsequent line should identify
                     // a dependency.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
@@ -575,7 +567,7 @@ private void ParseProject(string firstLine)
                     // projects, and contains properties that we'll need in order to call the 
                     // AspNetCompiler task.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         Match match = crackPropertyLine.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
@@ -942,7 +934,7 @@ string propertyValue
             else
             {
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
-                if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' });
 
@@ -984,7 +976,7 @@ string property
             )
         {
             // If the incoming string starts and ends with a double-quote, strip the double-quotes.
-            if ((property != null) && (property.Length > 0) && (property[0] == '"') && (property[property.Length - 1] == '"'))
+            if (!string.IsNullOrEmpty(property) && (property[0] == '"') && (property[property.Length - 1] == '"'))
             {
                 return property.Substring(1, property.Length - 2);
             }
@@ -1022,21 +1014,21 @@ ProjectInSolution proj
             ValidateProjectRelativePath(proj);
             
             // Figure out what type of project this is.
-            if ((String.Compare(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase) == 0))
+            if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.ManagedProject;
             }
-            else if (String.Compare(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SolutionFolder;
             }
-            else if (String.Compare(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.VCProject;
             }
-            else if (String.Compare(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebProject;
                 solutionContainsWebProjects = true;
@@ -1116,7 +1108,7 @@ internal void ParseSolutionConfigurations()
                 string fullConfigurationName = configurationNames[0].Trim();
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
-                if (0 == String.Compare(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
                     continue;
 
                 // Both names must be identical
@@ -1258,7 +1250,7 @@ internal string GetDefaultConfigurationName()
             // Pick the Debug configuration as default if present
             foreach (ConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     defaultConfigurationName = solutionConfiguration.ConfigurationName;
                     break;
@@ -1293,7 +1285,7 @@ internal string GetDefaultPlatformName()
             // Pick the Mixed Platforms platform as default if present
             foreach (ConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase))
                 {
                     defaultPlatformName = solutionConfiguration.PlatformName;
                     break;
@@ -1337,5 +1329,4 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
 
         #endregion
     } // class SolutionParser
-
 } // namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Shared/TypeLoader.cs b/src/Deprecated/Engine/Shared/TypeLoader.cs
index 9485f1065c1..b8066557901 100644
--- a/src/Deprecated/Engine/Shared/TypeLoader.cs
+++ b/src/Deprecated/Engine/Shared/TypeLoader.cs
@@ -224,7 +224,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             // check if the type names match exactly
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
diff --git a/src/Deprecated/Engine/Shared/XMakeAttributes.cs b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
index 128ee5b03bb..dd34b370cb4 100644
--- a/src/Deprecated/Engine/Shared/XMakeAttributes.cs
+++ b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
@@ -80,7 +80,6 @@ string attribute
                     (attribute == msbuildRuntime) ||
                     (attribute == msbuildArchitecture) ||
                     (attribute == xmlns));
-
         }
 
         /// <summary>
@@ -92,10 +91,10 @@ string attribute
         internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute)
         {
             return (!IsSpecialTaskAttribute(attribute) &&
-                ((String.Compare(attribute, condition, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(attribute, continueOnError, StringComparison.OrdinalIgnoreCase) == 0) || 
-                (String.Compare(attribute, msbuildRuntime, StringComparison.OrdinalIgnoreCase) == 0) || 
-                (String.Compare(attribute, msbuildArchitecture, StringComparison.OrdinalIgnoreCase) == 0)));
+                ((String.Equals(attribute, condition, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(attribute, continueOnError, StringComparison.OrdinalIgnoreCase)) || 
+                (String.Equals(attribute, msbuildRuntime, StringComparison.OrdinalIgnoreCase)) || 
+                (String.Equals(attribute, msbuildArchitecture, StringComparison.OrdinalIgnoreCase))));
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/XMakeElements.cs b/src/Deprecated/Engine/Shared/XMakeElements.cs
index 23040d39c4e..5c886fe01d3 100644
--- a/src/Deprecated/Engine/Shared/XMakeElements.cs
+++ b/src/Deprecated/Engine/Shared/XMakeElements.cs
@@ -97,5 +97,4 @@ internal static Hashtable IllegalItemPropertyNames
             }
         }
     }
-
 }
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index b9921bfee35..ae28f0b3ff8 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -44,11 +44,11 @@ internal static XmlElement RenameXmlElement(XmlElement oldElement, string newEle
                 newElement.AppendChild(newChildNode);
             }
 
-            if (oldElement.ParentNode != null)
-            {
+               
+            
                 // Add the new element in the same place the old element was.
-                oldElement.ParentNode.ReplaceChild(newElement, oldElement);
-            }
+                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+            
 
             return newElement;
         }
@@ -69,7 +69,7 @@ internal static string GetXmlNodeFile(XmlNode node, string defaultFile)
             string file = defaultFile;
 
             // NOTE: the XML node may not have a filename if it's purely an in-memory node
-            if ((node.OwnerDocument.BaseURI != null) && (node.OwnerDocument.BaseURI.Length > 0))
+            if (!string.IsNullOrEmpty(node.OwnerDocument.BaseURI))
             {
                 file = new Uri(node.OwnerDocument.BaseURI).LocalPath;
             }
@@ -211,14 +211,14 @@ string attributeName
                     {
                         if (xmlReader.NodeType == XmlNodeType.Element)
                         {
-                            if (String.Compare(xmlReader.Name, elementName, StringComparison.OrdinalIgnoreCase) == 0)
+                            if (String.Equals(xmlReader.Name, elementName, StringComparison.OrdinalIgnoreCase))
                             {
                                 if (xmlReader.HasAttributes)
                                 {
                                     for (int i = 0; i < xmlReader.AttributeCount; i++)
                                     {
                                         xmlReader.MoveToAttribute(i);
-                                        if (String.Compare(xmlReader.Name, attributeName, StringComparison.OrdinalIgnoreCase) == 0)
+                                        if (String.Equals(xmlReader.Name, attributeName, StringComparison.OrdinalIgnoreCase))
                                         {
                                             attributeValue = xmlReader.Value;
                                             break;
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index abf63f9efc6..bac1408f63b 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -30,7 +30,7 @@ static public class SolutionWrapperProject
 
         /// <summary>
         /// Given the full path to a solution, returns a string containing the v3.5 MSBuild-format
-        /// wrapper project for that solution.  
+        /// wrapper project for that solution.
         /// </summary>
         /// <param name="solutionPath">Full path to the solution we are wrapping</param>
         /// <param name="toolsVersionOverride">May be null.  If non-null, contains the ToolsVersion passed in on the command line</param>\
@@ -55,7 +55,7 @@ static public string Generate(string solutionPath, string toolsVersionOverride,
         /// </summary>
         /// <param name="solution"></param>
         /// <param name="msbuildProject"></param>
-        /// <param name="toolsVersionOverride">Tools Version override (may be null). 
+        /// <param name="toolsVersionOverride">Tools Version override (may be null).
         /// Any /tv:xxx switch would cause a value here.</param>
         /// <returns></returns>
         /// <owner>RGoel</owner>
@@ -104,7 +104,6 @@ static internal void Generate(SolutionParser solution, Project msbuildProject, s
 
             // Write a new cache file, hopefully we can use it next time
             UpdateCache(parentEngine, msbuildProject, solutionProjectCache, projectBuildEventContext);
-
         }
 
         /// <summary>
@@ -201,7 +200,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  s
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheNotApplicable", "Configuration", cacheSolutionConfigurationName, fullSolutionConfigurationName);
                 return false;
             }
-            
+
             if (!String.Equals(wrapperProjectToolsVersion, cacheToolsVersion, StringComparison.OrdinalIgnoreCase))
             {
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheNotApplicable", "ToolsVersion", cacheToolsVersion, wrapperProjectToolsVersion);
@@ -261,7 +260,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  s
             else
             {
                 return true;
-            }   
+            }
         }
 
         /// <summary>
@@ -446,7 +445,7 @@ private static void AddCacheRelatedProperties(Project msbuildProject, string ful
                 // Only add projects that correspond to actual files on disk. Solution folders and web projects correspond to folders, so we don't care about them.
                 if (project.ProjectType != SolutionProjectType.SolutionFolder && project.ProjectType != SolutionProjectType.WebProject)
                 {
-                    cacheItemGroup.AddNewItem(cacheProjectListName, EscapingUtilities.Escape(project.RelativePath)); 
+                    cacheItemGroup.AddNewItem(cacheProjectListName, EscapingUtilities.Escape(project.RelativePath));
                 }
             }
         }
@@ -504,10 +503,10 @@ private static string DetermineChildProjectToolsVersion(Engine parentEngine, str
         /// <owner>RGoel, LukaszG</owner>
         static private BuildTask AddMSBuildTaskElement
         (
-            Target target, 
+            Target target,
             string projectPath,
-            string msbuildTargetName, 
-            string configurationName, 
+            string msbuildTargetName,
+            string configurationName,
             string platformName,
             bool specifyProjectToolsVersion
         )
@@ -515,7 +514,7 @@ bool specifyProjectToolsVersion
             BuildTask newTask = target.AddNewTask("MSBuild");
             newTask.SetParameterValue("Projects", projectPath, true /* treat as literal */);
 
-            if (msbuildTargetName != null && msbuildTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(msbuildTargetName))
             {
                 newTask.SetParameterValue("Targets", msbuildTargetName);
             }
@@ -544,7 +543,7 @@ bool specifyProjectToolsVersion
         /// <param name="msbuildProject"></param>
         /// <param name="solution"></param>
         /// <param name="proj"></param>
-        /// <param name="targetOutputItemName">The name of the item exposing this target's outputs.  May be null.</param>        
+        /// <param name="targetOutputItemName">The name of the item exposing this target's outputs.  May be null.</param>
         /// <param name="subTargetName"></param>
         /// <owner>RGoel, LukaszG</owner>
         static private void AddTargetForManagedProject
@@ -557,7 +556,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -570,7 +569,7 @@ string subTargetName
             {
                 newTarget.TargetElement.SetAttribute("Outputs", string.Format(CultureInfo.InvariantCulture, "@({0})", targetOutputItemName));
             }
-            
+
             // Only create build items if we're called with the null subtarget. We're getting called
             // a total of four times and only want to create the build items once.
             bool createBuildItems = (subTargetName == null);
@@ -600,7 +599,7 @@ string subTargetName
                         // PERF: We could emit two <MSBuild> tasks, with a condition on them. But this doubles the size of
                         // the solution wrapper project, and the cost is too high. The consequence is that when solution wrapper
                         // projects are emitted to disk (with MSBUILDEMITSOLUION=1) they cannot be reused for tools version v2.0.
-                        bool specifyProjectToolsVersion = 
+                        bool specifyProjectToolsVersion =
                             String.Equals(msbuildProject.ToolsVersion, "2.0", StringComparison.OrdinalIgnoreCase) ? false : true;
 
                         BuildTask msbuildTask = AddMSBuildTaskElement(newTarget, proj.RelativePath, subTargetName,
@@ -719,7 +718,7 @@ out string addedReferenceGuids
                     (referencedProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out referencedProjectConfiguration)) &&
                     (referencedProjectConfiguration != null))
                 {
-                    string outputReferenceItemNameWithSuffix = string.Format(CultureInfo.InvariantCulture, "{0}_{1}", 
+                    string outputReferenceItemNameWithSuffix = string.Format(CultureInfo.InvariantCulture, "{0}_{1}",
                         outputReferenceItemName, outputReferenceItemNameSuffix);
 
                     bool addCreateItem = false;
@@ -734,7 +733,7 @@ out string addedReferenceGuids
                         BuildTask msbuildTask = AddMSBuildTaskElement(target, referencedProject.RelativePath, "GetTargetPath",
                             referencedProjectConfiguration.ConfigurationName, referencedProjectConfiguration.PlatformName, specifyProjectToolsVersion);
                         msbuildTask.Condition = condition;
-                        msbuildTask.AddOutputItem("TargetOutputs", outputReferenceItemNameWithSuffix);                        
+                        msbuildTask.AddOutputItem("TargetOutputs", outputReferenceItemNameWithSuffix);
 
                         if (referenceGuids.Length > 0)
                         {
@@ -743,7 +742,6 @@ out string addedReferenceGuids
 
                         referenceGuids.Append(projectReferenceGuid);
                         addCreateItem = true;
-
                     }
                     else if (referencedProject.ProjectType == SolutionProjectType.VCProject)
                     {
@@ -768,7 +766,7 @@ out string addedReferenceGuids
 
                         vcbuildTask.Condition = GetConditionStringForConfiguration(solutionConfiguration);
                         vcbuildTask.AddOutputItem("ResolvedOutputPaths", outputReferenceItemNameWithSuffix);
-                        
+
                         if (outputImportLibraryItemName != null)
                         {
                             vcbuildTask.AddOutputItem("ResolvedImportLibraryPaths", outputImportLibraryItemName);
@@ -867,7 +865,6 @@ string projectConfigurationName
                     proj.RelativePath, e.Message);
             }
 
-
             // Create the temporary VC project
             BuildTask createVCProjectTask = target.AddNewTask("CreateTemporaryVCProject");
             createVCProjectTask.SetParameterValue("ProjectFile", fullProjectPath, true /* treat as literal */);
@@ -902,7 +899,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -956,15 +953,15 @@ string subTargetName
                         if (proj.ProjectReferences.Count > 0)
                         {
                             projectPath = AddCreateTemporaryVCProjectTasks(solution, msbuildProject, newTarget, proj,
-                                solutionConfiguration, subTargetName, 
+                                solutionConfiguration, subTargetName,
                                 vcProjectConfiguration.FullName);
                         }
 
                         newTask = VCWrapperProject.AddVCBuildTaskElement(
                             msbuildProject,
                             newTarget,
-                            EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile))), 
-                            projectPath, subTargetName, 
+                            EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile))),
+                            projectPath, subTargetName,
                             null, EscapingUtilities.Escape(vcProjectConfiguration.FullName));
 
                         // Delete the temporary VC project
@@ -1035,7 +1032,7 @@ Project msbuildProject
 
             // TFV v3.5 supported by TV 4.0, TV 3.5
             getFrameworkPathTask.AddOutputItem(
-                "FrameworkVersion35Path", 
+                "FrameworkVersion35Path",
                 "_CombinedTargetFrameworkDirectoriesItem",
                 " ('$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v4.0') and '$(MSBuildToolsVersion)' != '2.0'");
 
@@ -1086,9 +1083,9 @@ string conditionDescribingValidConfigurations
 
             newTask.Condition = conditionDescribingValidConfigurations;
         }
-            
+
         /// <summary>
-        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced 
+        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced
         /// assemblies for the complete list of dependencies, PDBs, satellites, etc.  The invoke
         /// the Copy task to copy all these files (or at least the ones that RAR determined should
         /// be copied local) into the web project's bin directory.
@@ -1100,9 +1097,9 @@ string conditionDescribingValidConfigurations
         /// <owner>RGoel</owner>
         static private void AddTasksToCopyAllDependenciesIntoBinDir
             (
-            Target target, 
-            ProjectInSolution proj, 
-            string referenceItemName, 
+            Target target,
+            ProjectInSolution proj,
+            string referenceItemName,
             string conditionDescribingValidConfigurations
             )
         {
@@ -1142,7 +1139,7 @@ string conditionDescribingValidConfigurations
             BuildTask copyTask = target.AddNewTask("Copy");
             copyTask.SetParameterValue("SourceFiles", "@(" + copyLocalFilesItemName + ")", false /* DO NOT treat as literal */);
             copyTask.SetParameterValue("DestinationFiles", String.Format(CultureInfo.InvariantCulture,
-                @"@({0}->'{1}%(DestinationSubDirectory)%(Filename)%(Extension)')", 
+                @"@({0}->'{1}%(DestinationSubDirectory)%(Filename)%(Extension)')",
                 copyLocalFilesItemName, destinationFolder), false /* DO NOT treat as literal */);
             copyTask.Condition = conditionDescribingValidConfigurations;
         }
@@ -1159,16 +1156,16 @@ string conditionDescribingValidConfigurations
         /// <owner>RGoel</owner>
         static private void AddPropertyGroupForAspNetConfiguration
             (
-            Project msbuildProject, 
-            ProjectInSolution proj, 
-            string configurationName, 
+            Project msbuildProject,
+            ProjectInSolution proj,
+            string configurationName,
             AspNetCompilerParameters aspNetCompilerParameters,
             string solutionFile
             )
         {
             // Add a new PropertyGroup that is condition'd on the Configuration.
             BuildPropertyGroup newPropertyGroup = msbuildProject.AddNewPropertyGroup(false /* insertAtEndOfProject = false */);
-            newPropertyGroup.Condition = String.Format(CultureInfo.InvariantCulture, " '$(AspNetConfiguration)' == '{0}' ", 
+            newPropertyGroup.Condition = String.Format(CultureInfo.InvariantCulture, " '$(AspNetConfiguration)' == '{0}' ",
                 EscapingUtilities.Escape(configurationName));
 
             // Add properties into the property group for each of the AspNetCompiler properties.
@@ -1221,8 +1218,8 @@ string solutionFile
                     // override the AspNetTargetPath.  What we want to do in this case is concatenate:
                     //  $(OutDir) + "\_PublishedWebsites" + (the last portion of the folder in the AspNetPhysicalPath).
                     BuildProperty targetPathOverrideProperty = newPropertyGroup.AddNewProperty(GenerateSafePropertyName(proj, "AspNetTargetPath"),
-                        @"$(OutDir)" + 
-                        EscapingUtilities.Escape(webProjectOverrideFolder) + Path.DirectorySeparatorChar + 
+                        @"$(OutDir)" +
+                        EscapingUtilities.Escape(webProjectOverrideFolder) + Path.DirectorySeparatorChar +
                         EscapingUtilities.Escape(lastFolderInPhysicalPath) + Path.DirectorySeparatorChar);
                     targetPathOverrideProperty.Condition = " '$(OutDir)' != '' ";
                 }
@@ -1230,10 +1227,10 @@ string solutionFile
         }
 
         /// <summary>
-        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of 
-        /// a web project.  These .REFRESH files are just text files that contain absolute or 
-        /// relative paths to the referenced assemblies.  The goal of these tasks is to 
-        /// search all *.REFRESH files and extract fully-qualified absolute paths for 
+        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of
+        /// a web project.  These .REFRESH files are just text files that contain absolute or
+        /// relative paths to the referenced assemblies.  The goal of these tasks is to
+        /// search all *.REFRESH files and extract fully-qualified absolute paths for
         /// each of the references.
         /// </summary>
         /// <param name="target"></param>
@@ -1242,8 +1239,8 @@ string solutionFile
         /// <owner>RGoel</owner>
         static private void AddTasksToResolveAutoRefreshFileReferences
             (
-            Target target, 
-            ProjectInSolution proj, 
+            Target target,
+            ProjectInSolution proj,
             string referenceItemName
             )
         {
@@ -1257,7 +1254,7 @@ string referenceItemName
             // Read the lines out of each .REFRESH file; they should be paths to .DLLs.  Put these paths
             // into an item list.
             BuildTask readLinesTask = target.AddNewTask("ReadLinesFromFile");
-            readLinesTask.SetParameterValue("File", 
+            readLinesTask.SetParameterValue("File",
                 String.Format(CultureInfo.InvariantCulture, @"%({0}_RefreshFile.Identity)", referenceItemName));
             readLinesTask.Condition = String.Format(CultureInfo.InvariantCulture, @" '%({0}_RefreshFile.Identity)' != '' ", referenceItemName);
             readLinesTask.AddOutputItem("Lines", referenceItemName + "_ReferenceRelPath");
@@ -1267,14 +1264,14 @@ string referenceItemName
             // directly to RAR later.
             BuildTask combinePathTask = target.AddNewTask("CombinePath");
             combinePathTask.SetParameterValue("BasePath", webRoot);
-            combinePathTask.SetParameterValue("Paths", 
+            combinePathTask.SetParameterValue("Paths",
                 String.Format(CultureInfo.InvariantCulture, @"@({0}_ReferenceRelPath)", referenceItemName));
             combinePathTask.AddOutputItem("CombinedPaths", referenceItemName);
         }
 
         /// <summary>
         /// When adding a target to build a web project, we want to put a Condition on the Target node that
-        /// effectively says "Only build this target if the web project is active (marked for building) in the 
+        /// effectively says "Only build this target if the web project is active (marked for building) in the
         /// current solution configuration.
         /// </summary>
         /// <param name="solution"></param>
@@ -1307,8 +1304,8 @@ ProjectInSolution proj
                         condition.Append(")");
                     }
                 }
-                else if (String.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0 ||
-                         String.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) ||
+                         String.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     // we don't have a project configuration that matches the solution configuration but
                     // the solution configuration is called "Release" or "Debug" which are standard AspNetConfigurations
@@ -1344,7 +1341,7 @@ string subTargetName
             AddTargetForGetFrameworkPathAndRedistList(msbuildProject);
 
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1395,14 +1392,14 @@ string subTargetName
                     // subTargetName=null and once when subTargetName="Rebuild".
                     if (subTargetName == null)
                     {
-                        AddPropertyGroupForAspNetConfiguration(msbuildProject, proj, configurationName, 
+                        AddPropertyGroupForAspNetConfiguration(msbuildProject, proj, configurationName,
                             aspNetCompilerParameters, solution.SolutionFile);
                     }
 
                     // Update our big condition string to include this configuration.
                     conditionDescribingValidConfigurations.Append(" or ");
                     conditionDescribingValidConfigurations.Append(
-                        String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')", 
+                        String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')",
                         EscapingUtilities.Escape(configurationName)));
                 }
 
@@ -1499,7 +1496,7 @@ private static string MakeIntoSafeItemName(string name)
         /// <param name="textResourceName">Resource string name to use in the tag text</param>
         /// <param name="args">Additional parameters to pass to FormatString</param>
         /// <owner>LukaszG</owner>
-        static internal BuildTask AddErrorWarningMessageElement(Target target, string elementType, 
+        static internal BuildTask AddErrorWarningMessageElement(Target target, string elementType,
             bool treatAsLiteral, string textResourceName, params object[] args)
         {
             string code = null;
@@ -1528,7 +1525,7 @@ static internal BuildTask AddErrorWarningMessageElement(Target target, string el
         /// <param name="msbuildProject">The project to add the target to</param>
         /// <param name="proj">The project to add as a target.</param>
         /// <param name="subTargetName">The target to call within the project that's being added.</param>
-        /// <param name="errorMessage">Optional detailed error message to print out in case we already tried accessing the 
+        /// <param name="errorMessage">Optional detailed error message to print out in case we already tried accessing the
         /// project file before and failed.</param>
         /// <owner>RGoel</owner>
         static private void AddTargetForUnknownProjectType
@@ -1541,7 +1538,7 @@ string errorMessage
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1599,8 +1596,8 @@ string errorMessage
         /// <owner>RGoel</owner>
         static private Target AddAllDependencyTarget
         (
-            Project msbuildProject, 
-            string targetName, 
+            Project msbuildProject,
+            string targetName,
             string targetOutputItemName,
             string subTargetName,
             Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
@@ -1608,7 +1605,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
         {
             Target newTarget = msbuildProject.Targets.AddNewTarget(targetName);
             newTarget.Condition = "'$(CurrentSolutionConfigurationContents)' != ''";
-            
+
             if (!String.IsNullOrEmpty(targetOutputItemName))
             {
                 newTarget.TargetElement.SetAttribute("Outputs", string.Format(CultureInfo.InvariantCulture, "@({0})", targetOutputItemName));
@@ -1624,7 +1621,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                 msbuildTask.SetParameterValue("Projects", buildItemReference);
                 msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)");
 
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     msbuildTask.SetParameterValue("Targets", subTargetName);
                 }
@@ -1642,14 +1639,14 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                     msbuildTask.SetParameterValue("UseResultsCache", "$(UseResultsCache)");
                 }
 
-                BuildTask messageTask = AddErrorWarningMessageElement(newTarget, XMakeElements.message, false /* don't treat as literal */, "SolutionProjectSkippedForBuilding", 
+                BuildTask messageTask = AddErrorWarningMessageElement(newTarget, XMakeElements.message, false /* don't treat as literal */, "SolutionProjectSkippedForBuilding",
                     string.Format(CultureInfo.InvariantCulture, "%(SkipLevel{0}.Identity)", dependencyLevel), "$(Configuration)|$(Platform)");
                 messageTask.Condition = string.Format(CultureInfo.InvariantCulture, "@(SkipLevel{0}) != ''", dependencyLevel);
 
                 BuildTask warningTask = AddErrorWarningMessageElement(newTarget, XMakeElements.warning, false /* don't treat as literal */, "SolutionProjectConfigurationMissing",
                     string.Format(CultureInfo.InvariantCulture, "%(MissingConfigLevel{0}.Identity)", dependencyLevel), "$(Configuration)|$(Platform)");
                 warningTask.Condition = string.Format(CultureInfo.InvariantCulture, "@(MissingConfigLevel{0}) != ''", dependencyLevel);
-                
+
                 string allProjects = GetAllNonMSBuildProjectDependencies(projectsByDependencyLevel, dependencyLevel, subTargetName);
                 if (allProjects.Length > 0)
                 {
@@ -1693,7 +1690,7 @@ static private string GetProjectDependencies(SolutionParser solution, ProjectInS
                     "SolutionParseProjectDepNotFoundError", project.ProjectGuid, dependency);
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(projectUniqueName));
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
@@ -1712,8 +1709,8 @@ static private string GetProjectDependencies(SolutionParser solution, ProjectInS
         /// <returns></returns>
         static private string GetAllNonMSBuildProjectDependencies
         (
-            Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel, 
-            int dependencyLevel, 
+            Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel,
+            int dependencyLevel,
             string subTargetName
         )
         {
@@ -1738,7 +1735,7 @@ string subTargetName
                 }
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName()));
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
@@ -1761,7 +1758,7 @@ string subTargetName
         static private string GetConditionStringForConfiguration(ConfigurationInSolution configuration)
         {
             return string.Format(CultureInfo.InvariantCulture, " ('$(Configuration)' == '{0}') and ('$(Platform)' == '{1}') ",
-                EscapingUtilities.Escape(configuration.ConfigurationName), 
+                EscapingUtilities.Escape(configuration.ConfigurationName),
                 EscapingUtilities.Escape(configuration.PlatformName));
         }
 
@@ -1796,7 +1793,7 @@ SolutionParser solution
         /// <owner>LukaszG</owner>
         static internal void AddPropertyGroupForSolutionConfiguration
         (
-            Project msbuildProject, 
+            Project msbuildProject,
             SolutionParser solution,
             ConfigurationInSolution solutionConfiguration
         )
@@ -1830,12 +1827,12 @@ ConfigurationInSolution solutionConfiguration
         /// <summary>
         /// Creates the default Venus configuration property based on the selected solution configuration.
         /// Unfortunately, Venus projects only expose one project configuration in the IDE (Debug) although
-        /// they allow building Debug and Release from command line. This means that if we wanted to use 
+        /// they allow building Debug and Release from command line. This means that if we wanted to use
         /// the project configuration from the active solution configuration for Venus projects, we'd always
         /// end up with Debug and there'd be no way to build the Release configuration. To work around this,
         /// we use a special mechanism for choosing ASP.NET project configuration: we set it to Release if
-        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution 
-        /// configuration. The property is also settable from the command line, in which case it takes 
+        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution
+        /// configuration. The property is also settable from the command line, in which case it takes
         /// precedence over this algorithm.
         /// </summary>
         /// <param name="msbuildProject"></param>
@@ -1891,7 +1888,7 @@ static private void AddGlobalProperties(Project msbuildProject, SolutionParser s
 
         /// <summary>
         /// Special hack for web projects. It can happen that there is no Release configuration for solutions
-        /// containing web projects, yet we still want to be able to build the Release configuration for 
+        /// containing web projects, yet we still want to be able to build the Release configuration for
         /// those projects. Since the ASP.NET project configuration defaults to the solution configuration,
         /// we allow Release even if it doesn't actually exist in the solution.
         /// </summary>
@@ -1904,7 +1901,7 @@ static private void AddFakeReleaseSolutionConfigurationIfNecessary(SolutionParse
                 bool solutionHasReleaseConfiguration = false;
                 foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
                 {
-                    if (string.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase))
                     {
                         solutionHasReleaseConfiguration = true;
                         break;
@@ -1944,13 +1941,13 @@ static private void AddInitialTargets(Project msbuildProject)
                 "SolutionToolsVersionDoesNotSupportProjectToolsVersion", "$(MSBuildToolsVersion)");
             toolsVersionErrorTask.Condition = "'$(MSBuildToolsVersion)' == '2.0' and ('$(ProjectToolsVersion)' != '2.0' and '$(ProjectToolsVersion)' != '')";
 
-            msbuildProject.InitialTargets = initialTarget.Name + ";" + validateToolsVersionsTarget.Name;            
-        }          
+            msbuildProject.InitialTargets = initialTarget.Name + ";" + validateToolsVersionsTarget.Name;
+        }
 
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         /// <returns></returns>
@@ -1982,7 +1979,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
         {
             string activeSolutionConfiguration;
             string activeSolutionPlatform;
-            
+
             BuildProperty configurationProperty = parentEngine.GlobalProperties["Configuration"];
             BuildProperty platformProperty = parentEngine.GlobalProperties["Platform"];
 
@@ -2011,7 +2008,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
 
         /// <summary>
         /// Loads each MSBuild project in this solution and looks for its project-to-project references so that
-        /// we know what build order we should use when building the solution. 
+        /// we know what build order we should use when building the solution.
         /// </summary>
         /// <owner>LukaszG</owner>
         static private void ScanProjectDependencies(SolutionParser solution, Engine parentEngine, string childProjectToolsVersion, string fullSolutionConfigurationName, BuildEventContext projectBuildEventContext)
@@ -2032,7 +2029,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                     continue;
                 }
 
-                if ((project.ProjectType == SolutionProjectType.ManagedProject) || 
+                if ((project.ProjectType == SolutionProjectType.ManagedProject) ||
                     ((project.ProjectType == SolutionProjectType.Unknown) && (project.CanBeMSBuildProjectFile(out message))))
                 {
                     try
@@ -2040,7 +2037,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                         //Will fail to load a throw an error if the tools version is incorrect.
                         Project msbuildProject = new Project(parentEngine, childProjectToolsVersion);
                         msbuildProject.IsLoadedByHost = false;
-                        
+
                         // this is before building the solution wrapper project, so the current directory may be not set to
                         // the one containing the solution file, and we'd get the relative path wrong
                         msbuildProject.Load(project.AbsolutePath);
@@ -2049,11 +2046,11 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                         // so set it before retrieving references.
                         msbuildProject.GlobalProperties.SetProperty("Configuration",
                             project.ProjectConfigurations[fullSolutionConfigurationName].ConfigurationName, true /* treat as literal */);
-                        msbuildProject.GlobalProperties.SetProperty("Platform", 
+                        msbuildProject.GlobalProperties.SetProperty("Platform",
                             project.ProjectConfigurations[fullSolutionConfigurationName].PlatformName, true /* treat as literal */);
-                        
+
                         BuildItemGroup references = msbuildProject.GetEvaluatedItemsByName("ProjectReference");
-                        
+
                         foreach (BuildItem reference in references)
                         {
                             string referencedProjectGuid = reference.GetEvaluatedMetadata("Project");   // Need unescaped data here.
@@ -2091,7 +2088,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                             // Grab the guid with its curly braces...
                             referencedWebProjectGuid = referencedWebProjectGuid.Substring(0, 38);
                             AddDependencyByGuid(solution, project, parentEngine, projectBuildEventContext, referencedWebProjectGuid);
-                        }                                                
+                        }
                     }
                     // We don't want any problems scanning the project file to result in aborting the build.
                     catch (Exception e)
@@ -2175,7 +2172,7 @@ static private void AddDependencyByGuid(SolutionParser solution, ProjectInSoluti
         /// For MSBuild projects, project dependencies you can set in the IDE only represent build order constraints.
         /// If both projects are VC however, the VC project system treats dependencies as regular P2P references.
         /// This behavior is a carry-over from the days of VC5/6, that's how P2P refs were done back then. Tricky.
-        /// To compensate for that, we need to add a P2P reference for every dependency between two VC projects. 
+        /// To compensate for that, we need to add a P2P reference for every dependency between two VC projects.
         /// MSBuild -> VC, VC -> MSBuild dependencies are not affected.
         /// </summary>
         /// <param name="solution"></param>
@@ -2276,11 +2273,11 @@ static private void AssignDependencyLevels(SolutionParser solution, Dictionary<i
         }
 
         /// <summary>
-        /// Add virtual references for reference chains containing VC static library projects. 
-        /// Since static libraries have no link step, any references they have have to be passed
+        /// Add virtual references for reference chains containing VC static library projects.
+        /// Since static libraries have no link step, any references they have to be passed
         /// to their parent project, if any. So for example, in a chain like
         /// native dll -> native static lib1 -> native static lib2
-        /// we need to add a virtual reference between the native dll and the static lib2 
+        /// we need to add a virtual reference between the native dll and the static lib2
         /// to maintain parity with the IDE behavior.
         /// </summary>
         /// <param name="solution"></param>
@@ -2315,7 +2312,7 @@ private static void GatherChildReferencesForStaticLibraries(SolutionParser solut
                     {
                         foreach (string childReferenceGuid in referencedProject.ProjectReferences)
                         {
-                            if (!project.ProjectReferences.Contains(childReferenceGuid) && 
+                            if (!project.ProjectReferences.Contains(childReferenceGuid) &&
                                 !referenceGuidsToAdd.Contains(childReferenceGuid))
                             {
                                 referenceGuidsToAdd.Add(childReferenceGuid);
diff --git a/src/Deprecated/Engine/Solution/VCProjectParser.cs b/src/Deprecated/Engine/Solution/VCProjectParser.cs
index a58f9d2bf4e..0aaaa4658d5 100644
--- a/src/Deprecated/Engine/Solution/VCProjectParser.cs
+++ b/src/Deprecated/Engine/Solution/VCProjectParser.cs
@@ -58,8 +58,8 @@ internal static bool IsStaticLibrary(XmlDocument project, string configurationNa
                         XmlElement element = (XmlElement)configurationNode;
 
                         // Look for configuration that matches our name
-                        if ((string.Compare(element.Name, "Configuration", StringComparison.OrdinalIgnoreCase) == 0) &&
-                            (string.Compare(element.GetAttribute("Name"), configurationName, StringComparison.OrdinalIgnoreCase) == 0))
+                        if ((string.Equals(element.Name, "Configuration", StringComparison.OrdinalIgnoreCase)) &&
+                            (string.Equals(element.GetAttribute("Name"), configurationName, StringComparison.OrdinalIgnoreCase)))
                         {
                             configurationElement = element;
 
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 2bb2aefb038..574ab4561a9 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -99,7 +99,7 @@ string fullConfigurationName
 
             newTask.SetParameterValue("SolutionFile", solutionPath);
 
-            if ((vcbuildTargetName != null) && (vcbuildTargetName.Length > 0))
+            if (!string.IsNullOrEmpty(vcbuildTargetName))
             {
                 newTask.SetParameterValue(vcbuildTargetName, "true");
             }
@@ -228,7 +228,6 @@ static internal string VCBuildLocationHint
         /// <summary>
         /// constants for VS9 Pro and above SKUs
         /// </summary>
-
         // root registry key for VS9
         private const string vs9RegKey = @"SOFTWARE\Microsoft\VisualStudio\9.0";
         // the name of the value containing disk install directory for the IDE components 
@@ -242,7 +241,6 @@ static internal string VCBuildLocationHint
         /// <summary>
         /// constants for the VC9 Express SKU
         /// </summary>
-
         // root registry key for VC9
         private const string vc9RegKey = @"SOFTWARE\Microsoft\VCExpress\9.0";
         // the name of the value containing disk install directory for the IDE components 
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
index e496b4a57f8..f53abbf2461 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
@@ -38,7 +38,6 @@ internal BuildItemGroupChildXml(XmlDocument ownerDocument, string name, string i
         {
             this.element = ownerDocument.CreateElement(name, XMakeAttributes.defaultXmlNamespace);
             this.Include = include;
-
         }
 
         internal BuildItemGroupChildXml(XmlElement element, ChildType childTypeExpected)
@@ -362,5 +361,4 @@ internal enum ChildType
         /// </summary>
         Any = BuildItemAdd | BuildItemRemove | BuildItemModify
     }
-
 }
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
index a9d6773aa49..8eeca1eb9f4 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
@@ -68,7 +68,7 @@ internal XmlElement ParentElement
         {
             get
             {
-                if (element != null && element.ParentNode is XmlElement)
+                if (element?.ParentNode is XmlElement)
                 {
                     return (XmlElement)element.ParentNode;
                 }
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index 1dbbd8dcff8..54b620c6013 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -56,8 +56,6 @@
     <GenerateResourceMSBuildRuntime>CurrentRuntime</GenerateResourceMSBuildRuntime>
 
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
-    <!-- Disable warnings from XML documentation. https://github.com/Microsoft/msbuild/issues/2927 -->
-    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
 
     <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeApiList:&quot;$(RepoRoot)ref\ExcludeAPIList.txt&quot;</GenAPIAdditionalParameters>
     <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeAttributesList:&quot;$(RepoRoot)ref\ExcludeAttributeList.txt&quot;</GenAPIAdditionalParameters>
diff --git a/src/Framework.UnitTests/Attribute_Tests.cs b/src/Framework.UnitTests/Attribute_Tests.cs
index 448d3a9aa3e..e94e9d66173 100644
--- a/src/Framework.UnitTests/Attribute_Tests.cs
+++ b/src/Framework.UnitTests/Attribute_Tests.cs
@@ -18,7 +18,6 @@ public class AttributeTests
         [Fact]
         public void RequiredRuntimeAttribute()
         {
-
             RequiredRuntimeAttribute attribute =
                 typeof(X).GetTypeInfo().GetCustomAttribute<RequiredRuntimeAttribute>();
 
diff --git a/src/Framework/EnvironmentVariableReadEventArgs.cs b/src/Framework/EnvironmentVariableReadEventArgs.cs
index f34cade967b..809a1b097fd 100644
--- a/src/Framework/EnvironmentVariableReadEventArgs.cs
+++ b/src/Framework/EnvironmentVariableReadEventArgs.cs
@@ -22,6 +22,10 @@ public EnvironmentVariableReadEventArgs()
         /// Initializes an instance of the EnvironmentVariableReadEventArgs class.
         /// </summary>
         /// <param name="environmentVariableName">The name of the environment variable that was read.</param>
+        /// <param name="message">The value of the environment variable that was read.</param>
+        /// <param name="helpKeyword">Help keyword.</param>
+        /// <param name="senderName">The name of the sender of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public EnvironmentVariableReadEventArgs(
             string environmentVariableName,
             string message,
diff --git a/src/Framework/IProjectElement.cs b/src/Framework/IProjectElement.cs
index a5eea6df205..9c2dff5336f 100644
--- a/src/Framework/IProjectElement.cs
+++ b/src/Framework/IProjectElement.cs
@@ -8,7 +8,6 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public interface IProjectElement
     {
-
         /// <summary>
         /// Gets the name of the associated element. 
         /// Useful for display in some circumstances.
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 8c38696e5bc..9813392c45f 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -94,7 +94,7 @@ public override string Message
             {
                 lock (locker)
                 {
-                    if (arguments != null && arguments.Length > 0)
+                    if (arguments?.Length > 0)
                     {
                         if (originalCultureInfo == null)
                         {
@@ -196,7 +196,7 @@ private static string FormatString(CultureInfo culture, string unformatted, para
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 0ba3d618b7a..5d73b6aa153 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -1,12 +1,7 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Diagnostics.Tracing;
-using System.Runtime.InteropServices;
-using System.Threading;
+﻿using System.Diagnostics.Tracing;
 
 namespace Microsoft.Build.Eventing
 {
-
     /// <summary>
     /// This captures information of how various key methods of building with MSBuild ran.
     /// </summary>
@@ -281,7 +276,6 @@ public void RarLogResultsStop()
         [Event(33)]
         public void ParseStart(string projectFileName)
         {
-
             WriteEvent(33, projectFileName);
         }
 
@@ -333,7 +327,7 @@ public void SaveStop(string fileLocation)
             WriteEvent(40, fileLocation);
         }
 
-        /// <param name="targetName"/>The name of the target being executed.</param>
+        /// <param name="targetName">The name of the target being executed.</param>
         [Event(43)]
         public void TargetStart(string targetName)
         {
diff --git a/src/Framework/ProjectEvaluationFinishedEventArgs.cs b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
index 7179df89d9a..1d900b49c03 100644
--- a/src/Framework/ProjectEvaluationFinishedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
@@ -17,7 +17,6 @@ public sealed class ProjectEvaluationFinishedEventArgs : BuildStatusEventArgs
         /// </summary>
         public ProjectEvaluationFinishedEventArgs()
         {
-            
         }
 
         /// <summary>
diff --git a/src/Framework/ProjectEvaluationStartedEventArgs.cs b/src/Framework/ProjectEvaluationStartedEventArgs.cs
index f391d8825d6..80332d2c4f4 100644
--- a/src/Framework/ProjectEvaluationStartedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationStartedEventArgs.cs
@@ -16,7 +16,6 @@ public class ProjectEvaluationStartedEventArgs : BuildStatusEventArgs
         /// </summary>
         public ProjectEvaluationStartedEventArgs()
         {
-
         }
 
         /// <summary>
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index 49754632277..d73247be932 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -22,6 +22,10 @@ public PropertyInitialValueSetEventArgs() { }
         /// <param name="propertyName">The name of the property.</param>
         /// <param name="propertyValue">The value of the property.</param>
         /// <param name="propertySource">The source of the property.</param>
+        /// <param name="message">The message of the property.</param>
+        /// <param name="helpKeyword">The help keyword.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public PropertyInitialValueSetEventArgs(
             string propertyName,
             string propertyValue,
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 6de36dab633..7f9ccb491a5 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -25,6 +25,10 @@ public PropertyReassignmentEventArgs()
         /// <param name="previousValue">The previous value of the reassigned property.</param>
         /// <param name="newValue">The new value of the reassigned property.</param>
         /// <param name="location">The location of the reassignment.</param>
+        /// <param name="message">The message of the reassignment event.</param>
+        /// <param name="helpKeyword">The help keyword of the reassignment.</param>
+        /// <param name="senderName">The sender name of the reassignment event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public PropertyReassignmentEventArgs(
             string propertyName,
             string previousValue,
diff --git a/src/Framework/Sdk/SdkResultFactory.cs b/src/Framework/Sdk/SdkResultFactory.cs
index 88f6a008124..70f672cd62e 100644
--- a/src/Framework/Sdk/SdkResultFactory.cs
+++ b/src/Framework/Sdk/SdkResultFactory.cs
@@ -49,6 +49,7 @@ public virtual SdkResult IndicateSuccess(string path,
         /// components to take more appropriate action (for example installing optional workloads or downloading NuGet SDKs).
         /// </remarks>
         /// <param name="paths">SDK paths which should be imported</param>
+        /// <param name="version">SDK version which should be imported</param>
         /// <param name="propertiesToAdd">Properties to set in the evaluation</param>
         /// <param name="itemsToAdd">Items to add to the evaluation</param>
         /// <param name="warnings">Optional warnings to display during resolution.</param>
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index eb5808ef40b..bbda09f9634 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -17,7 +17,7 @@ public class TaskPropertyInfo
         /// </summary>
         /// <param name="name">Name of the parameter</param>
         /// <param name="typeOfParameter">The actual type of the parameter</param>
-        /// <param name="output">True if the parameter is both an output and and input parameter. False if the parameter is only an input parameter</param>
+        /// <param name="output">True if the parameter is both an output and input parameter. False if the parameter is only an input parameter</param>
         /// <param name="required">True if the parameter must be supplied to each invocation of the task.</param>
         public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool required)
         {
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index 62448bdb008..fa11b3c8f89 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -22,6 +22,10 @@ public UninitializedPropertyReadEventArgs()
         /// Creates an instance of the UninitializedPropertyReadEventArgs class
         /// </summary>
         /// <param name="propertyName">The name of the uninitialized property that was read.</param>
+        /// <param name="message">The message of the uninitialized property that was read.</param>
+        /// <param name="helpKeyword">The helpKeyword of the uninitialized property that was read.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The message importance of the event.</param>
         public UninitializedPropertyReadEventArgs(
             string propertyName,
             string message,
diff --git a/src/Framework/XamlTypes/ContentType.cs b/src/Framework/XamlTypes/ContentType.cs
index 5eb55529bba..0fe304b22fc 100644
--- a/src/Framework/XamlTypes/ContentType.cs
+++ b/src/Framework/XamlTypes/ContentType.cs
@@ -96,7 +96,7 @@ public string GetMetadata(string metadataName)
         {
             if (String.IsNullOrEmpty(metadataName))
             {
-                throw new ArgumentNullException("metadataName");
+                throw new ArgumentNullException(nameof(metadataName));
             }
 
             string value;
diff --git a/src/Framework/XamlTypes/DataSource.cs b/src/Framework/XamlTypes/DataSource.cs
index 64c683badc6..515bbaa392c 100644
--- a/src/Framework/XamlTypes/DataSource.cs
+++ b/src/Framework/XamlTypes/DataSource.cs
@@ -27,8 +27,8 @@ public enum DefaultValueSourceLocation
     /// <summary>
     /// Represents the location and grouping for a <see cref="BaseProperty"/>.
     /// </summary>
-    /// <remarks> 
-    /// Those who manually 
+    /// <remarks>
+    /// Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
@@ -52,12 +52,12 @@ public DataSource()
         #region Properties
 
         /// <summary>
-        /// The storage location for this data source. 
+        /// The storage location for this data source.
         /// </summary>
         /// <remarks>
-        /// This field is mandatory unless <see cref="PersistenceStyle"/> is set. In that case, the parent 
-        /// <see cref="DataSource"/> will be used with the specified style. Example values are <c>ProjectFile</c> and 
-        /// <c>UserFile</c>. <c>ProjectFile</c> causes the property value to be written to and read from the project 
+        /// This field is mandatory unless <see cref="PersistenceStyle"/> is set. In that case, the parent
+        /// <see cref="DataSource"/> will be used with the specified style. Example values are <c>ProjectFile</c> and
+        /// <c>UserFile</c>. <c>ProjectFile</c> causes the property value to be written to and read from the project
         /// manifest file or the property sheet (depending on which node in the solution explorer/property manager window
         /// is used to spawn the property pages UI). <c>UserFile</c> causes the property value to be written to and read
         /// from the .user file.
@@ -72,7 +72,7 @@ public string Persistence
         /// The storage style for this data source.
         /// </summary>
         /// <remarks>
-        /// For example, with <see cref="Persistence"/> of <c>ProjectFile</c>, this field can be <c>Element</c> (default) to 
+        /// For example, with <see cref="Persistence"/> of <c>ProjectFile</c>, this field can be <c>Element</c> (default) to
         /// save as a child XML Element, or <c>Attribute</c> to save properties as an XML attribute.
         /// </remarks>
         public string PersistenceStyle
@@ -146,7 +146,7 @@ public bool HasConfigurationCondition
         /// Among other things this governs how the data is treated during build.
         /// </summary>
         /// <example>
-        /// A value of <c>Item</c> for this property indicates that this property is actually 
+        /// A value of <c>Item</c> for this property indicates that this property is actually
         /// an item array - the list of all items with the item type specified by <see cref="ItemType"/>.
         /// </example>
         public string SourceType
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 04697b84240..5fee06a9d1e 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1265,7 +1265,6 @@ public void HelpMessagesAreValid()
                         // Ignore empty lines
                         if (!String.IsNullOrWhiteSpace(helpMessageLines[i]))
                         {
-
                             if (item.Key.Contains("Examples"))
                             {
                                 // Examples require a certain number of leading spaces
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 6c4a2e79218..a2cc9a8d075 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -659,7 +659,6 @@ public void ConfigurationInvalid()
             // if there's not, we will catch when we try to read the toolsets. Either is fine; we just want to not crash.
             (output.Contains("MSB1043") || output.Contains("MSB4136")).ShouldBeTrue("Output should contain 'MSB1043' or 'MSB4136'");
 
-
         }
 #endif
 
@@ -1424,14 +1423,12 @@ public void TestProcessProjectSwitch()
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-
             projects = new string[] { "test.sln~", "test.sln" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
         }
 
-
         /// <summary>
         /// Ignore .sln and .vcproj files to replicate Building_DF_LKG functionality
         /// </summary>
@@ -1444,7 +1441,6 @@ public void TestProcessProjectSwitchReplicateBuildingDFLKG()
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj"); // "Expected test.proj to be only project found"
         }
 
-
         /// <summary>
         /// Test the case where we remove all of the project extensions that exist in the directory
         /// </summary>
@@ -1584,14 +1580,14 @@ internal string[] GetFiles(string path, string searchPattern)
                 List<string> fileNamesToReturn = new List<string>();
                 foreach (string file in _directoryFileNameList)
                 {
-                    if (String.Compare(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
                     {
-                        if (String.Compare(Path.GetExtension(file), ".sln", StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(Path.GetExtension(file), ".sln", StringComparison.OrdinalIgnoreCase))
                         {
                             fileNamesToReturn.Add(file);
                         }
                     }
-                    else if (String.Compare(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase))
                     {
                         if (Path.GetExtension(file).Contains("proj"))
                         {
@@ -1903,7 +1899,7 @@ public void ProcessConsoleLoggerSwitches()
         {
             ArrayList loggers = new ArrayList();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
-            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); ;
+            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); 
             string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
 
             MSBuildApp.ProcessConsoleLoggerSwitch
@@ -2208,7 +2204,6 @@ public void TasksGetAssemblyLoadContexts()
 
 #endif
 
-
         private string CopyMSBuild()
         {
             string dest = null;
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index dd02ff90a83..2563e623a45 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -46,7 +46,6 @@ string commandLineArg
             this.commandLineArg = commandLineArg;
         }
 
-
         /// <summary>
         /// Serialization constructor
         /// </summary>
@@ -58,7 +57,7 @@ StreamingContext context
             base(info, context)
 
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             commandLineArg = info.GetString("commandLineArg");
         }
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 9f2af74b651..a4e3f1f2045 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -197,7 +197,6 @@ bool emptyParametersAllowed
             internal bool emptyParametersAllowed;
         }
 
-
         // map switches that do not take parameters to their identifiers (taken from ParameterlessSwitch enum)
         // WARNING: keep this map in the same order as the ParameterlessSwitch enumeration
         private static readonly ParameterlessSwitchInfo[] s_parameterlessSwitchesMap =
@@ -299,7 +298,7 @@ out string duplicateSwitchErrorMessage
             {
                 foreach (string parameterlessSwitchName in switchInfo.switchNames)
                 {
-                    if (String.Compare(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase))
                     {
                         parameterlessSwitch = switchInfo.parameterlessSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
@@ -498,7 +497,6 @@ bool emptyParametersAllowed
                     // check if they were all stored successfully i.e. they were all non-empty (after removing quoting, if requested)
                     parametersStored = (emptyParameters == 0);
                 }
-
             }
             else
             {
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index c8584f04930..cafd5d28483 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -63,7 +63,7 @@ StreamingContext context
             base(info, context)
 
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             invalidSwitch = info.GetString("invalidSwitch");
         }
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index 6029f16baf0..a03db6f636f 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -27,17 +27,9 @@ internal NodeEndpointOutOfProcTaskHost(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override long GetHostHandshake()
+        protected override Handshake GetHandshake()
         {
-            return CommunicationsUtilities.GetHostHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
-        }
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected override long GetClientHandshake()
-        {
-            return CommunicationsUtilities.GetClientHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
     }
 }
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index b441f5800db..247e3208f41 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -622,7 +622,7 @@ private void HandlePacket(INodePacket packet)
         /// </summary>
         private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfiguration)
         {
-            ErrorUtilities.VerifyThrow(_isTaskExecuting == false, "Why are we getting a TaskHostConfiguration packet while we're still executing a task?");
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "Why are we getting a TaskHostConfiguration packet while we're still executing a task?");
             _currentConfiguration = taskHostConfiguration;
 
             // Kick off the task running thread.
@@ -636,7 +636,7 @@ private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfigura
         /// </summary>
         private void CompleteTask()
         {
-            ErrorUtilities.VerifyThrow(_isTaskExecuting == false, "The task should be done executing before CompleteTask.");
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "The task should be done executing before CompleteTask.");
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
                 TaskHostTaskComplete taskCompletePacketToSend;
@@ -674,7 +674,7 @@ private void CancelTask()
 
             // Store in a local to avoid a race
             var wrapper = _taskWrapper;
-            if (wrapper != null && !wrapper.CancelTask())
+            if (wrapper?.CancelTask() == false)
             {
                 // Create a possibility for the task to be aborted if the user really wants it dropped dead asap
                 if (Environment.GetEnvironmentVariable("MSBUILDTASKHOSTABORTTASKONCANCEL") == "1")
@@ -711,10 +711,7 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
         private NodeEngineShutdownReason HandleShutdown()
         {
             // Wait for the RunTask task runner thread before shutting down so that we can cleanly dispose all WaitHandles.
-            if (_taskRunnerThread != null)
-            {
-                _taskRunnerThread.Join();
-            }
+            _taskRunnerThread?.Join();
 
             if (_debugCommunications)
             {
@@ -1086,7 +1083,7 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
         /// </summary>
         private void SendBuildEvent(BuildEventArgs e)
         {
-            if (_nodeEndpoint != null && _nodeEndpoint.LinkStatus == LinkStatus.Active)
+            if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)
             {
                 if (!e.GetType().GetTypeInfo().IsSerializable)
                 {
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index ab552477e57..8620083844b 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -38,10 +38,10 @@ internal static void VerifyProjectSchema
             string binPath
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
-            ErrorUtilities.VerifyThrowArgumentNull(binPath, "binPath");
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
+            ErrorUtilities.VerifyThrowArgumentNull(binPath, nameof(binPath));
 
-            if ((schemaFile == null) || (schemaFile.Length == 0))
+            if (string.IsNullOrEmpty(schemaFile))
             {
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
@@ -76,8 +76,8 @@ private void VerifyProjectSchema
             string schemaFile
         )
         {
-            ErrorUtilities.VerifyThrowArgumentNull(schemaFile, "schemaFile");
-            ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
+            ErrorUtilities.VerifyThrowArgumentNull(schemaFile, nameof(schemaFile));
+            ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
 
             // Options for XmlReader object can be set only in constructor. After the object is created, they
             // become read-only. Because of that we need to create
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 7b159909a64..e19fdc5b0b4 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -510,7 +510,7 @@ string [] commandLine
             }
 
 #if FEATURE_GET_COMMANDLINE
-            ErrorUtilities.VerifyThrowArgumentLength(commandLine, "commandLine");
+            ErrorUtilities.VerifyThrowArgumentLength(commandLine, nameof(commandLine));
 #endif
 
 #if FEATURE_APPDOMAIN_UNHANDLED_EXCEPTION
@@ -644,7 +644,6 @@ string [] commandLine
                     // leave priority where it was.
                     catch (Win32Exception) { }
 
-
                     DateTime t1 = DateTime.Now;
 
                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers
@@ -1324,10 +1323,7 @@ string outputResultsCache
             finally
             {
                 FileUtilities.ClearCacheDirectory();
-                if (projectCollection != null)
-                {
-                    projectCollection.Dispose();
-                }
+                projectCollection?.Dispose();
 
                 BuildManager.DefaultBuildManager.Dispose();
             }
@@ -1863,7 +1859,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
 
                     foreach (string includedResponseFile in s_includedResponseFiles)
                     {
-                        if (String.Compare(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase))
                         {
                             commandLineSwitches.SetParameterError("RepeatedResponseFileError", unquotedCommandLineArg);
                             isRepeatedResponseFile = true;
@@ -2198,7 +2194,7 @@ bool recursing
                         if (!String.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
                         {
                             // this combines any found, with higher precedence, with the switches from the original auto response file switches
-                            found = found | GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
+                            found |= GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
                         }
 
                         if (found)
@@ -2586,7 +2582,6 @@ internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameter
                     ex.Message);
             }
 
-
             var logger = new ProfilerLogger(profilerFile);
             loggers.Add(logger);
 
@@ -2653,7 +2648,6 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                         CommandLineSwitchException.Throw("InvalidNodeNumberValue", nodeModeNumber.ToString());
                     }
 
-
                     if (shutdownReason == NodeEngineShutdownReason.Error)
                     {
                         Debug.WriteLine("An error has happened, throwing an exception");
@@ -2784,7 +2778,6 @@ DirectoryGetFiles getFiles
                     }
                 }
 
-
                 if (potentialSolutionFiles != null)
                 {
                     foreach (string s in potentialSolutionFiles)
@@ -2803,13 +2796,13 @@ DirectoryGetFiles getFiles
                 if (extensionsToIgnoreDictionary.Count > 0)
                 {
                     // No point removing extensions if we have no project files
-                    if (potentialProjectFiles != null && potentialProjectFiles.Length > 0)
+                    if (potentialProjectFiles?.Length > 0)
                     {
                         potentialProjectFiles = RemoveFilesWithExtensionsToIgnore(potentialProjectFiles, extensionsToIgnoreDictionary);
                     }
 
                     // No point removing extensions if we have no solutions
-                    if (potentialSolutionFiles != null && potentialSolutionFiles.Length > 0)
+                    if (potentialSolutionFiles?.Length > 0)
                     {
                         potentialSolutionFiles = RemoveFilesWithExtensionsToIgnore(potentialSolutionFiles, extensionsToIgnoreDictionary);
                     }
@@ -2821,7 +2814,7 @@ DirectoryGetFiles getFiles
                     string solutionName = Path.GetFileNameWithoutExtension(potentialSolutionFiles[0]);
                     string projectName = Path.GetFileNameWithoutExtension(potentialProjectFiles[0]);
                     // Compare the names and error if they are not identical
-                    InitializationException.VerifyThrow(String.Compare(solutionName, projectName, StringComparison.OrdinalIgnoreCase) == 0, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(String.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
                 }
                 // If there is more than one solution file in the current directory we have no idea which one to use
                 else if (potentialSolutionFiles.Length > 1)
@@ -2841,17 +2834,17 @@ DirectoryGetFiles getFiles
                         string secondPotentialProjectExtension = Path.GetExtension(potentialProjectFiles[1]);
 
                         // If the two projects have the same extension we can't decide which one to pick
-                        if (String.Compare(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase) != 0)
+                        if (!String.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
                         {
                             // Check to see if the first project is the proj, if it is use it
-                            if (String.Compare(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase) == 0)
+                            if (String.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 potentialProjectFiles = new string[] { potentialProjectFiles[0] };
                                 // We have made a decision
                                 isAmbiguousProject = false;
                             }
                             // If the first project is not the proj check to see if the second one is the proj, if so use it
-                            else if (String.Compare(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase) == 0)
+                            else if (String.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 potentialProjectFiles = new string[] { potentialProjectFiles[1] };
                                 // We have made a decision
@@ -2890,7 +2883,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
             Dictionary<string, object> extensionsToIgnoreDictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
 
             // Go through each of the extensions to ignore and add them as a key in the dictionary
-            if (projectsExtensionsToIgnore != null && projectsExtensionsToIgnore.Length > 0)
+            if (projectsExtensionsToIgnore?.Length > 0)
             {
                 string extension = null;
 
@@ -2917,7 +2910,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
 
                     // The parsed extension does not match the passed in extension, this means that there were
                     // some other chars before the last extension
-                    if (string.Compare(extension, extensionToIgnore, StringComparison.OrdinalIgnoreCase) != 0)
+                    if (!string.Equals(extension, extensionToIgnore, StringComparison.OrdinalIgnoreCase))
                     {
                         InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
                     }
@@ -2926,7 +2919,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
                     if (extensionToIgnore.IndexOfAny(s_wildcards) > -1)
                     {
                         InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
-                    };
+                    }
                     if (!extensionsToIgnoreDictionary.ContainsKey(extensionToIgnore))
                     {
                         extensionsToIgnoreDictionary.Add(extensionToIgnore, null);
@@ -2949,8 +2942,8 @@ Dictionary<string, object> extensionsToIgnoreDictionary
                                 )
         {
             // If we got to this method we should have to possible projects or solutions and some extensions to ignore
-            ErrorUtilities.VerifyThrow(((potentialProjectOrSolutionFiles != null) && (potentialProjectOrSolutionFiles.Length > 0)), "There should be some potential project or solution files");
-            ErrorUtilities.VerifyThrow(((extensionsToIgnoreDictionary != null) && (extensionsToIgnoreDictionary.Count > 0)), "There should be some extensions to Ignore");
+            ErrorUtilities.VerifyThrow(((potentialProjectOrSolutionFiles?.Length > 0)), "There should be some potential project or solution files");
+            ErrorUtilities.VerifyThrow(((extensionsToIgnoreDictionary?.Count > 0)), "There should be some extensions to Ignore");
 
             List<string> filesToKeep = new List<string>();
             foreach (string projectOrSolutionFile in potentialProjectOrSolutionFiles)
@@ -3206,7 +3199,7 @@ ArrayList loggers
                 ConsoleLogger logger = new ConsoleLogger(verbosity);
                 string consoleParameters = "SHOWPROJECTFILE=TRUE;";
 
-                if ((consoleLoggerParameters != null) && (consoleLoggerParameters.Length > 0))
+                if ((consoleLoggerParameters?.Length > 0))
                 {
                     consoleParameters = AggregateParameters(consoleParameters, consoleLoggerParameters);
                 }
@@ -3273,7 +3266,7 @@ int cpuCount
             if (distributedFileLogger)
             {
                 string fileParameters = string.Empty;
-                if ((fileLoggerParameters != null) && (fileLoggerParameters.Length > 0))
+                if ((fileLoggerParameters?.Length > 0))
                 {
                     // Join the file logger parameters into one string seperated by semicolons
                     fileParameters = AggregateParameters(null, fileLoggerParameters);
@@ -3547,7 +3540,7 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
             // DDB Bug msbuild.exe -Logger:FileLogger,Microsoft.Build.Engine fails due to moved engine file.
             // Only add strong naming if the assembly is a non-strong named 'Microsoft.Build.Engine' (i.e, no additional characteristics)
             // Concat full Strong Assembly to match v4.0
-            if (String.Compare(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase))
             {
                 loggerAssemblySpec = "Microsoft.Build.Engine,Version=4.0.0.0,Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a";
             }
@@ -3628,7 +3621,6 @@ out ILogger logger
                     logger.Parameters = loggerDescription.LoggerSwitchParameters;
                 }
             }
-
             catch (LoggerException)
             {
                 // Logger failed politely during parameter/verbosity setting
diff --git a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
index e7e6a6221ef..99aadcb9f7e 100644
--- a/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
+++ b/src/MSBuildTaskHost/Concurrent/ConcurrentDictionary.cs
@@ -93,7 +93,6 @@ private static bool IsValueWriteAtomic()
         /// </summary>
         public ConcurrentDictionary(IEqualityComparer<TKey> comparer = null)
         {
-
             int concurrencyLevel = Environment.ProcessorCount;
             int capacity = DefaultCapacity;
 
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 4fcb3ad7d8d..7fa58465d0b 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -24,6 +24,9 @@
     <LargeAddressAware>true</LargeAddressAware>
     <ApplicationIcon>..\MSBuild\MSBuild.ico</ApplicationIcon>
 
+    <!-- workaround for https://github.com/dotnet/msbuild/issues/5620 -->
+    <BypassFrameworkInstallChecks>true</BypassFrameworkInstallChecks>
+
     <DebugType>full</DebugType><!-- Work around arcade stomping on symbols for same-program-different-arches. -->
   </PropertyGroup>
   <ItemGroup>
@@ -213,6 +216,7 @@
     <PackageReference Include="PdbGit" /> -->
     <PackageReference Include="SourceLink.Create.CommandLine" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 666fc50449f..1b8bdd09f92 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -18,7 +18,6 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class TypeLoader
     {
-
         /// <summary>
         /// Cache to keep track of the assemblyLoadInfos based on a given typeFilter.
         /// </summary>
@@ -119,7 +118,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             }
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
@@ -225,7 +224,7 @@ private class AssemblyInfoToLoadedTypes
             internal AssemblyInfoToLoadedTypes(TypeFilter typeFilter, AssemblyLoadInfo loadInfo)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeFilter, "typefilter");
-                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
@@ -238,7 +237,7 @@ internal AssemblyInfoToLoadedTypes(TypeFilter typeFilter, AssemblyLoadInfo loadI
             /// </summary>
             internal LoadedType GetLoadedTypeByTypeName(string typeName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeName, "typeName");
+                ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
                 // Only one thread should be doing operations on this instance of the object at a time.
 
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Build.cs b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
index 2aaba8f0054..6d45a22485e 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Build.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
@@ -182,7 +182,7 @@ public void AddProject(ProjectStartedEventArgs projectStartedEventArgs)
         {
             Project parent = null;
 
-            if (projectStartedEventArgs.ParentProjectBuildEventContext != null && projectStartedEventArgs.ParentProjectBuildEventContext.ProjectContextId >= 0)
+            if (projectStartedEventArgs.ParentProjectBuildEventContext?.ProjectContextId >= 0)
             {
                 parent = GetOrAddProject(projectStartedEventArgs.ParentProjectBuildEventContext.ProjectContextId);
             }
diff --git a/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs b/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs
index 022fc191533..4e28d5136f1 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/TaskParameter.cs
@@ -65,21 +65,15 @@ public void SaveToElement(XElement parentElement)
         /// <returns>Concrete task parameter node.</returns>
         public static TaskParameter Create(string message, string prefix)
         {
-            switch (prefix)
+            return prefix switch
             {
-                case XmlFileLogger.OutputItemsMessagePrefix:
-                    return new OutputItem(message, prefix);
-                case XmlFileLogger.TaskParameterMessagePrefix:
-                    return new InputParameter(message, prefix);
-                case XmlFileLogger.OutputPropertyMessagePrefix:
-                    return new OutputProperty(message, prefix);
-                case XmlFileLogger.ItemGroupIncludeMessagePrefix:
-                    return new ItemGroup(message, prefix, "Include");
-                case XmlFileLogger.ItemGroupRemoveMessagePrefix:
-                    return new ItemGroup(message, prefix, "Remove");
-                default:
-                    throw new UnknownTaskParameterPrefixException(prefix);
-            }
+                XmlFileLogger.OutputItemsMessagePrefix => new OutputItem(message, prefix),
+                XmlFileLogger.TaskParameterMessagePrefix => new InputParameter(message, prefix),
+                XmlFileLogger.OutputPropertyMessagePrefix => new OutputProperty(message, prefix),
+                XmlFileLogger.ItemGroupIncludeMessagePrefix => new ItemGroup(message, prefix, "Include"),
+                XmlFileLogger.ItemGroupRemoveMessagePrefix => new ItemGroup(message, prefix, "Remove"),
+                _ => throw new UnknownTaskParameterPrefixException(prefix),
+            };
         }
     }
 }
diff --git a/src/Samples/XmlFileLogger/PropertyBag.cs b/src/Samples/XmlFileLogger/PropertyBag.cs
index 7b16f65907b..b70c9300fac 100644
--- a/src/Samples/XmlFileLogger/PropertyBag.cs
+++ b/src/Samples/XmlFileLogger/PropertyBag.cs
@@ -60,7 +60,7 @@ public void AddProperties(IEnumerable<KeyValuePair<string, string>> newPropertie
         {
             if (newProperties == null)
             {
-                throw new ArgumentNullException("newProperties");
+                throw new ArgumentNullException(nameof(newProperties));
             }
 
             foreach (var property in newProperties)
@@ -79,7 +79,7 @@ public void AddProperties(IEnumerable<DictionaryEntry> newProperties)
         {
             if (newProperties == null)
             {
-                throw new ArgumentNullException("newProperties");
+                throw new ArgumentNullException(nameof(newProperties));
             }
 
             foreach (var property in newProperties)
@@ -134,7 +134,7 @@ public bool TryGetValue(string key, out string value)
                 return true;
             }
 
-            return _parent != null && _parent.TryGetValue(key, out value);
+            return _parent?.TryGetValue(key, out value) == true;
         }
     }
 }
diff --git a/src/Samples/XmlFileLogger/XmlFileLogger.cs b/src/Samples/XmlFileLogger/XmlFileLogger.cs
index 10772659ed8..5663da5cd74 100644
--- a/src/Samples/XmlFileLogger/XmlFileLogger.cs
+++ b/src/Samples/XmlFileLogger/XmlFileLogger.cs
@@ -62,7 +62,6 @@ public override void Initialize(IEventSource eventSource)
             };
             eventSource.WarningRaised += (o, args) =>
             {
-
                 _warings++;
                 _build.AddMessage(args, string.Format("Warning {0}: {1}", args.Code, args.Message));
             };
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index ed4b8f3098d..e36e10ad324 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -234,9 +234,9 @@ OpenBaseKey openBaseKey
                     {
                         using (RegistryKey keyPlatform = baseKey.OpenSubKey(directoryKey.RegistryKey, false))
                         {
-                            if (keyPlatform != null && keyPlatform.ValueCount > 0)
+                            if (keyPlatform?.ValueCount > 0)
                             {
-                                if (platform != null && platform.Length > 0)
+                                if (!string.IsNullOrEmpty(platform))
                                 {
                                     string platformValue = keyPlatform.GetValue("Platform", null) as string;
 
@@ -246,7 +246,7 @@ OpenBaseKey openBaseKey
                                     }
                                 }
 
-                                if (osVersion != null && osVersion.Length > 0)
+                                if (!string.IsNullOrEmpty(osVersion))
                                 {
                                     Version ver = VersionUtilities.ConvertToVersion(osVersion);
 
@@ -274,12 +274,12 @@ private bool MatchingPlatformExists(string platform, string platformValue)
         {
             bool match = false;
 
-            if (platformValue != null && platformValue.Length > 0)
+            if (!string.IsNullOrEmpty(platformValue))
             {
                 string[] platforms = platformValue.Split(MSBuildConstants.SemicolonChar);
                 foreach (string p in platforms)
                 {
-                    if (String.Compare(p, platform, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(p, platform, StringComparison.OrdinalIgnoreCase))
                     {
                         match = true;
                         break;
@@ -369,7 +369,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
             // Loop over versions from registry.
             foreach (string version in versions)
             {
-                if ((version.Length > 0) && (String.Compare(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase) == 0))
+                if ((version.Length > 0) && (String.Equals(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase)))
                 {
                     Version candidateVersion = VersionUtilities.ConvertToVersion(version);
 
diff --git a/src/Shared/AssemblyLoadInfo.cs b/src/Shared/AssemblyLoadInfo.cs
index 8284c1a1f5e..8a331562a92 100644
--- a/src/Shared/AssemblyLoadInfo.cs
+++ b/src/Shared/AssemblyLoadInfo.cs
@@ -23,7 +23,7 @@ internal abstract class AssemblyLoadInfo : ITranslatable, IEquatable<AssemblyLoa
         /// </summary>
         internal static AssemblyLoadInfo Create(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName != null) && (assemblyName.Length > 0)) || ((assemblyFile != null) && (assemblyFile.Length > 0)),
+            ErrorUtilities.VerifyThrow((!string.IsNullOrEmpty(assemblyName)) || (!string.IsNullOrEmpty(assemblyFile)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 758e90ee4e6..1986216d384 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -99,7 +99,7 @@ internal AssemblyNameExtension(string assemblyName) : this()
 
         /// <summary>
         /// Construct from a string, but immediately construct a real AssemblyName.
-        /// This will cause an exception to be thrown up front if the assembly name 
+        /// This will cause an exception to be thrown up front if the assembly name
         /// isn't well formed.
         /// </summary>
         /// <param name="assemblyName">
@@ -320,7 +320,7 @@ internal Version Version
         }
 
         /// <summary>
-        /// Is the assembly a complex name or a simple name. A simple name is where only the name is set 
+        /// Is the assembly a complex name or a simple name. A simple name is where only the name is set
         /// a complex name is where the version, culture or publickeytoken is also set
         /// </summary>
         internal bool IsSimpleName
@@ -545,7 +545,7 @@ internal int CompareBaseNameTo(AssemblyNameExtension that)
         }
 
         /// <summary>
-        /// An implementation of compare that compares two base 
+        /// An implementation of compare that compares two base
         /// names as quickly as possible.
         /// </summary>
         /// <param name="that"></param>
@@ -847,7 +847,7 @@ private static AssemblyName GetAssemblyNameFromDisplayName(string displayName)
         }
 
         /// <summary>
-        /// Return a string that has AssemblyName special characters escaped. 
+        /// Return a string that has AssemblyName special characters escaped.
         /// Those characters are Equals(=), Comma(,), Quote("), Apostrophe('), Backslash(\).
         /// </summary>
         /// <remarks>
@@ -896,9 +896,9 @@ internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetarg
         /// <summary>
         /// Do a partial comparison between two assembly name extensions.
         /// Compare the fields of A and B on the following conditions:
-        /// 1) A.Field has a non null value 
+        /// 1) A.Field has a non null value
         /// 2) The field has been selected in the comparison flags or the default comparison flags are passed in.
-        /// 
+        ///
         /// If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
         /// </summary>
         internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags)
@@ -909,9 +909,9 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
         /// <summary>
         /// Do a partial comparison between two assembly name extensions.
         /// Compare the fields of A and B on the following conditions:
-        /// 1) A.Field has a non null value 
+        /// 1) A.Field has a non null value
         /// 2) The field has been selected in the comparison flags or the default comparison flags are passed in.
-        /// 
+        ///
         /// If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
         /// </summary>
         internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag)
diff --git a/src/Shared/AssemblyUtilities.cs b/src/Shared/AssemblyUtilities.cs
index f33454caec0..f4194346f88 100644
--- a/src/Shared/AssemblyUtilities.cs
+++ b/src/Shared/AssemblyUtilities.cs
@@ -153,8 +153,7 @@ private static CultureInfo[] GetValidCultures()
         {
             var cultureTypesType = s_cultureInfoGetCultureMethod?.GetParameters().FirstOrDefault()?.ParameterType;
 
-            ErrorUtilities.VerifyThrow(cultureTypesType != null &&
-                                       cultureTypesType.Name == "CultureTypes" &&
+            ErrorUtilities.VerifyThrow(cultureTypesType?.Name == "CultureTypes" &&
                                        Enum.IsDefined(cultureTypesType, "AllCultures"),
                                        "GetCulture is expected to accept CultureTypes.AllCultures");
 
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index 26a26b3988e..7a96844a816 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -54,7 +54,7 @@ internal static TaskScheduler OneSTAThreadPerTaskSchedulerInstance
         /// <returns>The awaiter.</returns>
         internal static TaskAwaiter GetAwaiter(this WaitHandle handle)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(handle, "handle");
+            ErrorUtilities.VerifyThrowArgumentNull(handle, nameof(handle));
             return handle.ToTask().GetAwaiter();
         }
 
diff --git a/src/Shared/BufferedReadStream.cs b/src/Shared/BufferedReadStream.cs
index e907d980e4a..f3f9b6906b3 100644
--- a/src/Shared/BufferedReadStream.cs
+++ b/src/Shared/BufferedReadStream.cs
@@ -144,7 +144,6 @@ protected override void Dispose(bool disposing)
 
             base.Dispose(disposing);
         }
-
         
     }
 }
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 7a69513847b..a5c7fb21cdd 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -23,7 +23,7 @@ internal class BuildEnvironmentHelper
 
         /// <summary>
         /// Name of the Visual Studio (and Blend) process.
-        // VS ASP intellisense server fails without Microsoft.VisualStudio.Web.Host. Remove when issue fixed: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/574986
+        /// VS ASP intellisense server fails without Microsoft.VisualStudio.Web.Host. Remove when issue fixed: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/574986
         /// </summary>
         private static readonly string[] s_visualStudioProcess = {"DEVENV", "BLEND", "Microsoft.VisualStudio.Web.Host"};
 
@@ -207,7 +207,6 @@ private static BuildEnvironment TryFromMSBuildAssembly()
             }
 
             return null;
-
         }
 
         private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string msbuildAssembly, string msbuildExe, bool allowLegacyToolsVersion = false)
@@ -449,7 +448,6 @@ internal static void ResetInstance_ForUnitTestsOnly(Func<string> getProcessFromR
         private static Func<string, string> s_getEnvironmentVariable = GetEnvironmentVariable;
         private static Func<bool> s_runningTests = CheckIfRunningTests;
 
-
         private static class BuildEnvironmentHelperSingleton
         {
             // Explicit static constructor to tell C# compiler
@@ -473,7 +471,7 @@ internal enum BuildEnvironmentMode
         VisualStudio,
 
         /// <summary>
-        /// Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app 
+        /// Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app
         /// running and not dependent on Visual Studio. (e.g. dotnet CLI, open source clone of our repo)
         /// </summary>
         Standalone,
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index b4346085d21..f0c247113f6 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -316,11 +316,11 @@ internal static Parts Parse(string message)
                 }
 
                 category = match.Groups["CATEGORY"].Value.Trim();
-                if (0 == String.Compare(category, "error", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(category, "error", StringComparison.OrdinalIgnoreCase))
                 {
                     parsedMessage.category = Parts.Category.Error;
                 }
-                else if (0 == String.Compare(category, "warning", StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(category, "warning", StringComparison.OrdinalIgnoreCase))
                 {
                     parsedMessage.category = Parts.Category.Warning;
                 }
@@ -354,11 +354,11 @@ internal static Parts Parse(string message)
             parsedMessage.subcategory = match.Groups["SUBCATEGORY"].Value.Trim();
 
             // Next, see if category is something that is recognized.
-            if (0 == String.Compare(category, "error", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(category, "error", StringComparison.OrdinalIgnoreCase))
             {
                 parsedMessage.category = Parts.Category.Error;
             }
-            else if (0 == String.Compare(category, "warning", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(category, "warning", StringComparison.OrdinalIgnoreCase))
             {
                 parsedMessage.category = Parts.Category.Warning;
             }
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 2bb61d35127..cd238bd5540 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -51,7 +51,59 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with BelowNormal priority
         /// </summary>
-        LowPriority = 16
+        LowPriority = 16,
+
+        /// <summary>
+        /// Building with administrator privileges
+        /// </summary>
+        Administrator = 32
+    }
+
+    internal readonly struct Handshake
+    {
+        readonly int options;
+        readonly int salt;
+        readonly int fileVersionMajor;
+        readonly int fileVersionMinor;
+        readonly int fileVersionBuild;
+        readonly int fileVersionPrivate;
+        readonly int sessionId;
+
+        internal Handshake(HandshakeOptions nodeType)
+        {
+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // This indicates in the first byte that we are a modern build.
+            options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
+            string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
+            salt = CommunicationsUtilities.GetHandshakeHashCode(handshakeSalt + toolsDirectory);
+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
+            fileVersionMajor = fileVersion.Major;
+            fileVersionMinor = fileVersion.Minor;
+            fileVersionBuild = fileVersion.Build;
+            fileVersionPrivate = fileVersion.Revision;
+            sessionId = Process.GetCurrentProcess().SessionId;
+        }
+
+        // This is used as a key, so it does not need to be human readable.
+        public override string ToString()
+        {
+            return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
+        }
+
+        internal int[] RetrieveHandshakeComponents()
+        {
+            return new int[]
+            {
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
+            };
+        }
     }
 
     /// <summary>
@@ -60,19 +112,19 @@ internal enum HandshakeOptions
     static internal class CommunicationsUtilities
     {
         /// <summary>
-        /// The timeout to connect to a node.
+        /// Indicates to the NodeEndpoint that all the various parts of the Handshake have been sent.
         /// </summary>
-        private const int DefaultNodeConnectionTimeout = 900 * 1000; // 15 minutes; enough time that a dev will typically do another build in this time
+        private const int EndOfHandshakeSignal = -0x2a2a2a2a;
 
         /// <summary>
-        /// Flag if we have already calculated the FileVersion hashcode
+        /// The version of the handshake. This should be updated each time the handshake structure is altered.
         /// </summary>
-        private static bool s_fileVersionChecked;
+        internal const byte handshakeVersion = 0x01;
 
         /// <summary>
-        /// A hashcode calculated from the fileversion
+        /// The timeout to connect to a node.
         /// </summary>
-        private static int s_fileVersionHash;
+        private const int DefaultNodeConnectionTimeout = 900 * 1000; // 15 minutes; enough time that a dev will typically do another build in this time
 
         /// <summary>
         /// Whether to trace communications
@@ -102,48 +154,6 @@ static internal int NodeConnectionTimeout
             get { return GetIntegerVariableOrDefault("MSBUILDNODECONNECTIONTIMEOUT", DefaultNodeConnectionTimeout); }
         }
 
-        /// <summary>
-        /// Looks up the file version and caches the hashcode
-        /// This file version hashcode is used in calculating the handshake
-        /// </summary>
-        private static int FileVersionHash
-        {
-            get
-            {
-                if (!s_fileVersionChecked)
-                {
-                    // We only hash in any complus_installroot value, not a file version.
-                    // This is because in general msbuildtaskhost.exe does not load any assembly that
-                    // the parent process loads, so they can't compare the version of a particular assembly.
-                    // They can't compare their own versions, because if one of them is serviced, they
-                    // won't match any more. The only known incompatibility is between a razzle and non-razzle
-                    // parent and child. COMPLUS_Version can (and typically will) differ legitimately between
-                    // them, so just check COMPLUS_InstallRoot.
-                    string complusInstallRoot = Environment.GetEnvironmentVariable("COMPLUS_INSTALLROOT");
-
-                    // This is easier in .NET 4+:
-                    //  var fileIdentity = typeof(CommunicationsUtilities).GetTypeInfo().Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion;
-                    // but we need to be 3.5 compatible here to work in MSBuildTaskHost
-                    string fileIdentity = null;
-                    foreach (var attribute in typeof(CommunicationsUtilities).GetTypeInfo().Assembly.GetCustomAttributes(false))
-                    {
-                        if (attribute is AssemblyInformationalVersionAttribute informationalVersionAttribute)
-                        {
-                            fileIdentity = informationalVersionAttribute.InformationalVersion;
-                            break;
-                        }
-                    }
-
-                    ErrorUtilities.VerifyThrow(fileIdentity != null, "Did not successfully retrieve InformationalVersion.");
-
-                    s_fileVersionHash = GetHandshakeHashCode(complusInstallRoot ?? fileIdentity);
-                    s_fileVersionChecked = true;
-                }
-
-                return s_fileVersionHash;
-            }
-        }
-
         /// <summary>
         /// Get environment block
         /// </summary>
@@ -291,70 +301,19 @@ internal static void SetEnvironment(IDictionary<string, string> newEnvironment)
             }
         }
 
+#nullable enable
         /// <summary>
-        /// Given a base handshake, generates the real handshake based on e.g. elevation level.  
+        /// Indicate to the client that all elements of the Handshake have been sent.
         /// </summary>
-        private static long GenerateHostHandshakeFromBase(long baseHandshake)
+        internal static void WriteEndOfHandshakeSignal(this PipeStream stream)
         {
-#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
-            // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
-            WindowsPrincipal principal = new WindowsPrincipal(WindowsIdentity.GetCurrent());
-
-            // Both the client and the host will calculate this separately, and the idea is that if they come out the same
-            // then we can be sufficiently confident that the other side has the same elevation level as us.  This is complementary
-            // to the username check which is also done on connection.
-            if (principal.IsInRole(WindowsBuiltInRole.Administrator))
-            {
-                unchecked
-                {
-                    baseHandshake = baseHandshake ^ 0x5c5c5c5c5c5c5c5c + Process.GetCurrentProcess().SessionId;
-                }
-            }
-#endif
-
-            // Mask out the first byte. Modern builds expect the first byte to be zero to indicate that they are modern
-            // and should be treated as such. Older builds used a non-zero initial byte. See here:
-            // https://github.com/microsoft/msbuild/blob/584ca5f11b28971f5651b4b8de5f173ad1cb2786/src/Shared/NodeEndpointOutOfProcBase.cs#L403.
-            return baseHandshake & 0x00FFFFFFFFFFFFFF;
-        }
-
-        /// <summary>
-        /// Magic number sent by the host to the client during the handshake.
-        /// Derived from the binary timestamp to avoid mixing binary versions.
-        /// </summary>
-        internal static long GetHostHandshake(HandshakeOptions nodeType)
-        {
-            string salt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
-            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            int nodeHandshakeSalt = GetHandshakeHashCode(salt + toolsDirectory);
-
-            Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", nodeType={2}, FileVersionHash={3}", salt, toolsDirectory, nodeType, FileVersionHash);
-
-            // FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
-            // HandshakeOptions (5 bits) is shifted just after the FileVersionHash
-            // remaining bits of nodeHandshakeSalt (32 bits truncated to 11) are shifted next
-            //      nodeHandshakeSalt    | HandshakeOptions |             fileVersionHash           | SessionID
-            //  0000 0000 0000 0000 000        0 0000        0000 0000 0000 0000 0000 0000 0000 0000  0000 0000
-            unchecked
-            {
-                ulong baseHandshake = ((ulong)(uint)nodeHandshakeSalt << 45) | ((ulong)(uint)nodeType << 40) | ((ulong)(uint)FileVersionHash << 8);
-                return GenerateHostHandshakeFromBase((long)baseHandshake);
-            }
-        }
-
-        /// <summary>
-        /// Magic number sent by the client to the host during the handshake.
-        /// Munged version of the host handshake.
-        /// </summary>
-        internal static long GetClientHandshake(HandshakeOptions hostContext)
-        {
-            return ~GetHostHandshake(hostContext);
+            stream.WriteIntForHandshake(EndOfHandshakeSignal);
         }
 
         /// <summary>
         /// Extension method to write a series of bytes to a stream
         /// </summary>
-        internal static void WriteLongForHandshake(this PipeStream stream, long value)
+        internal static void WriteIntForHandshake(this PipeStream stream, int value)
         {
             byte[] bytes = BitConverter.GetBytes(value);
 
@@ -365,39 +324,49 @@ internal static void WriteLongForHandshake(this PipeStream stream, long value)
                 Array.Reverse(bytes);
             }
 
-            ErrorUtilities.VerifyThrow(bytes.Length == 8, "Long should be 8 bytes");
+            ErrorUtilities.VerifyThrow(bytes.Length == 4, "Int should be 4 bytes");
 
             stream.Write(bytes, 0, bytes.Length);
         }
 
-        /// <summary>
-        /// Extension method to read a series of bytes from a stream
-        /// </summary>
-        internal static long ReadLongForHandshake(this PipeStream stream
+        internal static void ReadEndOfHandshakeSignal(this PipeStream stream, bool isProvider
 #if NETCOREAPP2_1 || MONO
-            , int handshakeReadTimeout
+            , int timeout
 #endif
             )
         {
-            return stream.ReadLongForHandshake((byte[])null, 0
+            // Accept only the first byte of the EndOfHandshakeSignal
+            int valueRead = stream.ReadIntForHandshake(null
 #if NETCOREAPP2_1 || MONO
-                , handshakeReadTimeout
+            , timeout
 #endif
                 );
+
+            if (valueRead != EndOfHandshakeSignal)
+            {
+                if (isProvider)
+                {
+                    CommunicationsUtilities.Trace("Handshake failed on part {0}. Probably the client is a different MSBuild build.", valueRead);
+                }
+                else
+                {
+                    CommunicationsUtilities.Trace("Expected end of handshake signal but received {0}. Probably the host is a different MSBuild build.", valueRead);
+                }
+                throw new InvalidOperationException();
+            }
         }
 
         /// <summary>
         /// Extension method to read a series of bytes from a stream.
         /// If specified, leading byte matches one in the supplied array if any, returns rejection byte and throws IOException.
         /// </summary>
-        internal static long ReadLongForHandshake(this PipeStream stream, byte[] leadingBytesToReject,
-            byte rejectionByteToReturn
+        internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAccept
 #if NETCOREAPP2_1 || MONO
             , int timeout
 #endif
             )
         {
-            byte[] bytes = new byte[8];
+            byte[] bytes = new byte[4];
 
 #if NETCOREAPP2_1 || MONO
             if (!NativeMethodsShared.IsWindows)
@@ -437,24 +406,18 @@ byte rejectionByteToReturn
                         throw new IOException(String.Format(CultureInfo.InvariantCulture, "Unexpected end of stream while reading for handshake"));
                     }
 
-                    if (i == 0 && leadingBytesToReject != null)
-                    {
-                        foreach (byte reject in leadingBytesToReject)
-                        {
-                            if (read == reject)
-                            {
-                                stream.WriteByte(rejectionByteToReturn); // disconnect the host
+                    bytes[i] = Convert.ToByte(read);
 
-                                throw new IOException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} but this matched a byte to reject.", bytes[i]));  // disconnect and quit
-                            }
-                        }
+                    if (i == 0 && byteToAccept != null && byteToAccept != bytes[0])
+                    {
+                        stream.WriteIntForHandshake(0x0F0F0F0F);
+                        stream.WriteIntForHandshake(0x0F0F0F0F);
+                        throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} instead of {1}.", bytes[0], byteToAccept));
                     }
-
-                    bytes[i] = Convert.ToByte(read);
                 }
             }
 
-            long result;
+            int result;
 
             try
             {
@@ -465,7 +428,7 @@ byte rejectionByteToReturn
                     Array.Reverse(bytes);
                 }
 
-                result = BitConverter.ToInt64(bytes, 0 /* start index */);
+                result = BitConverter.ToInt32(bytes, 0 /* start index */);
             }
             catch (ArgumentException ex)
             {
@@ -474,6 +437,7 @@ byte rejectionByteToReturn
 
             return result;
         }
+#nullable disable
 
 #if !FEATURE_APM
         internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int bytesToRead)
@@ -495,12 +459,14 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
         /// <summary>
         /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, int clrVersion = 0, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
+        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
         {
             HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
+            int clrVersion = 0;
+
             // We don't know about the TaskHost. Figure it out.
-            if (taskHost && clrVersion == 0)
+            if (taskHost)
             {
                 // Take the current TaskHost context
                 if (taskHostParameters == null)
@@ -517,6 +483,7 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     is64Bit = taskHostParameters[XMakeAttributes.architecture].Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
+
             if (is64Bit)
             {
                 context |= HandshakeOptions.X64;
@@ -533,6 +500,16 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
             {
                 context |= HandshakeOptions.LowPriority;
             }
+#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
+            // If we are running in elevated privs, we will only accept a handshake from an elevated process as well.
+            // Both the client and the host will calculate this separately, and the idea is that if they come out the same
+            // then we can be sufficiently confident that the other side has the same elevation level as us.  This is complementary
+            // to the username check which is also done on connection.
+            if (new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator))
+            {
+                context |= HandshakeOptions.Administrator;
+            }
+#endif
             return context;
         }
 
@@ -646,5 +623,10 @@ internal static int GetHandshakeHashCode(string fileVersion)
                 }
             }
         }
+
+        internal static int AvoidEndOfHandshakeSignal(int x)
+        {
+            return x == EndOfHandshakeSignal ? ~x : x;
+        }
     }
 }
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index b6f1bf71261..fc5b610c0fe 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -63,15 +63,12 @@ NodeMode ScanNodeMode(string input)
 
                     Trace.Assert(!string.IsNullOrEmpty(nodeMode));
 
-                    switch (nodeMode)
+                    return nodeMode switch
                     {
-                        case "1":
-                            return NodeMode.OutOfProcNode;
-                        case "2":
-                            return NodeMode.OutOfProcTaskHostNode;
-                        default:
-                            throw new NotImplementedException();
-                    }
+                        "1" => NodeMode.OutOfProcNode,
+                        "2" => NodeMode.OutOfProcTaskHostNode,
+                        _ => throw new NotImplementedException(),
+                    };
                 }
             });
 
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 641980fc490..439a8491f96 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -767,7 +767,7 @@ internal static void VerifyThrowArgumentInvalidPath(string parameter, string par
         /// </summary>
         internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)
         {
-            if (parameter != null && parameter.Length == 0 && s_throwExceptions)
+            if (parameter?.Length == 0 && s_throwExceptions)
             {
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
             }
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 03db70e079d..34871308e62 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -200,6 +200,7 @@ int threadId
         /// <param name="columnNumber">column number (0 if n/a)</param>
         /// <param name="endColumnNumber">end column number (0 if n/a)</param>
         /// <param name="threadId">thread id</param>
+        /// <param name="logOutputProperties">log output properties</param>
         /// <returns>The formatted message string.</returns>
         internal static string FormatEventMessage
         (
@@ -227,7 +228,7 @@ string logOutputProperties
             }
             */
 
-            if ((file == null) || (file.Length == 0))
+            if (string.IsNullOrEmpty(file))
             {
                 format.Append("MSBUILD : ");    // Should not be localized.
             }
@@ -280,7 +281,7 @@ string logOutputProperties
                 }
             }
 
-            if ((subcategory != null) && (subcategory.Length != 0))
+            if (!string.IsNullOrEmpty(subcategory))
             {
                 format.Append("{9} ");
             }
@@ -348,7 +349,6 @@ string logOutputProperties
             return formattedMessage.ToString();
         }
 
-
         /// <summary>
         /// Splits strings on 'newLines' with tolerance for Everett and Dogfood builds.
         /// </summary>
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 967e012016b..f3fb4d1462a 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -685,7 +685,6 @@ IEnumerable<string> paths
             }
         }
 
-
         /// <summary>
         /// Checks if the char is a DirectorySeparatorChar or a AltDirectorySeparatorChar
         /// </summary>
@@ -867,7 +866,7 @@ private void GetFilesRecursive(
                         continue;
                     }
                 }
-                files = files ?? new List<string>();
+                files ??= new List<string>();
                 files.Add(file);
             }
             // Add all matched files at once to reduce thread contention
@@ -1144,7 +1143,6 @@ out bool isLegalFileSpec
             }
         }
 
-
         /// <summary>
         /// Determine if the filespec is legal according to the following conditions:
         /// 
@@ -1189,7 +1187,6 @@ private static bool HasMisplacedRecursiveOperator(string str)
             return false;
         }
 
-
         /// <summary>
         /// Append the regex equivalents for character sequences in the fixed directory part of a filespec:
         ///
@@ -1867,7 +1864,6 @@ internal string[] GetFiles
             List<string> excludeSpecsUnescaped = null
             )
         {
-
             // For performance. Short-circuit iff there is no wildcard.
             if (!HasWildcards(filespecUnescaped))
             {
@@ -2189,7 +2185,6 @@ static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped,
             {
                 foreach (string excludeSpec in excludeSpecsUnescaped)
                 {
-
                     // Try a path equality check first to:
                     // - avoid the expensive regex
                     // - maintain legacy behaviour where an illegal filespec is treated as a normal string
@@ -2289,7 +2284,7 @@ private string[] GetFilesImplementation(
                     var excludeBaseDirectory = excludeState.BaseDirectory;
                     var includeBaseDirectory = state.BaseDirectory;
 
-                    if (string.Compare(excludeBaseDirectory, includeBaseDirectory, StringComparison.OrdinalIgnoreCase) != 0)
+                    if (!string.Equals(excludeBaseDirectory, includeBaseDirectory, StringComparison.OrdinalIgnoreCase))
                     {
                         //  What to do if the BaseDirectory for the exclude search doesn't match the one for inclusion?
                         //  - If paths don't match (one isn't a prefix of the other), then ignore the exclude search.  Examples:
@@ -2376,7 +2371,7 @@ private string[] GetFilesImplementation(
                 }
             }
 
-            if (searchesToExclude != null && searchesToExclude.Count == 0)
+            if (searchesToExclude?.Count == 0)
             {
                 searchesToExclude = null;
             }
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 2b66c993281..71431d00924 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -113,27 +113,14 @@ private static WindowsNative.EnumerateDirectoryResult CustomEnumerateDirectoryEn
                 {
                     int hr = Marshal.GetLastWin32Error();
                     Debug.Assert(hr != WindowsNative.ErrorFileNotFound);
-
-                    WindowsNative.EnumerateDirectoryStatus findHandleOpenStatus;
-                    switch (hr)
+                    WindowsNative.EnumerateDirectoryStatus findHandleOpenStatus = hr switch
                     {
-                        case WindowsNative.ErrorFileNotFound:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound;
-                            break;
-                        case WindowsNative.ErrorPathNotFound:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound;
-                            break;
-                        case WindowsNative.ErrorDirectory:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.CannotEnumerateFile;
-                            break;
-                        case WindowsNative.ErrorAccessDenied:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.AccessDenied;
-                            break;
-                        default:
-                            findHandleOpenStatus = WindowsNative.EnumerateDirectoryStatus.UnknownError;
-                            break;
-                    }
-
+                        WindowsNative.ErrorFileNotFound => WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound,
+                        WindowsNative.ErrorPathNotFound => WindowsNative.EnumerateDirectoryStatus.SearchDirectoryNotFound,
+                        WindowsNative.ErrorDirectory => WindowsNative.EnumerateDirectoryStatus.CannotEnumerateFile,
+                        WindowsNative.ErrorAccessDenied => WindowsNative.EnumerateDirectoryStatus.AccessDenied,
+                        _ => WindowsNative.EnumerateDirectoryStatus.UnknownError,
+                    };
                     return new WindowsNative.EnumerateDirectoryResult(directoryPath, findHandleOpenStatus, hr);
                 }
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index a02cf5c4582..8dea0fdaadd 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -31,7 +31,6 @@ internal static partial class FileUtilities
         // A list of possible test runners. If the program running has one of these substrings in the name, we assume
         // this is a test harness.
 
-
         // This flag, when set, indicates that we are running tests. Initially assume it's true. It also implies that
         // the currentExecutableOverride is set to a path (that is non-null). Assume this is not initialized when we
         // have the impossible combination of runningTests = false and currentExecutableOverride = null.
@@ -83,7 +82,6 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/Microsoft/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-
         internal static readonly char[] InvalidPathChars = new char[]
         {
             '|', '\0',
@@ -303,7 +301,7 @@ internal static bool ContainsRelativePathSegments(string path)
                     }
                     else
                     {
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
@@ -350,7 +348,6 @@ private static bool IsValidRelativePathBound(char? c)
         /// </summary>
         internal static string NormalizePath(string path)
         {
-
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
             string fullPath = GetFullPath(path);
             return FixFilePath(fullPath);
@@ -637,7 +634,7 @@ internal static string GetDirectory(string fileSpec)
         /// <returns></returns>
         internal static bool HasExtension(string fileName, string[] allowedExtensions)
         {
-            Debug.Assert(allowedExtensions != null && allowedExtensions.Length > 0);
+            Debug.Assert(allowedExtensions?.Length > 0);
 
             // Easiest way to invoke invalid path chars
             // check, which callers are relying on.
@@ -665,7 +662,6 @@ internal static bool HasExtension(string fileName, string[] allowedExtensions)
         /// </summary>
         internal static string ExecutingAssemblyPath => Path.GetFullPath(AssemblyUtilities.GetAssemblyLocation(typeof(FileUtilities).GetTypeInfo().Assembly));
 
-
         /// <summary>
         /// Determines the full path for the given file-spec.
         /// ASSUMES INPUT IS STILL ESCAPED
@@ -769,7 +765,6 @@ internal static bool PathIsInvalid(string path)
             return path.IndexOfAny(InvalidFileNameChars, lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0) >= 0;
         }
 
-
         /// <summary>
         /// A variation on File.Delete that will throw ExceptionHandling.NotExpectedException exceptions
         /// </summary>
@@ -914,12 +909,11 @@ internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSys
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryExists)
                     : fileSystem.DirectoryExists(fullPath);
-
             }
             catch
             {
@@ -939,12 +933,11 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileExists)
                     : fileSystem.FileExists(fullPath);
-
             }
             catch
             {
@@ -964,7 +957,7 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryEntryExists)
@@ -1328,7 +1321,7 @@ internal static StreamReader OpenRead(string path, Encoding encoding = null, boo
         /// </summary>
         internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem = null)
         {
-            fileSystem = fileSystem ?? DefaultFileSystem;
+            fileSystem ??= DefaultFileSystem;
 
             // Canonicalize our starting location
             string lookInDirectory = GetFullPath(startingDirectory);
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index c8be4058ee7..9ab2e9faf9e 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -20,10 +20,10 @@ internal static class FileUtilitiesRegex
         private static readonly char _forwardSlash = '/';
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern: "<drive letter>:"
+        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:", "D:")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if follows the drive pattern, false otherwise</returns>
         internal static bool IsDrivePattern(string pattern)
         {
             // Format must be two characters long: "<drive letter>:"
@@ -32,10 +32,10 @@ internal static bool IsDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern: "<drive letter>:/" or "<drive letter>:\"
+        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:/" or "C:\")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern with slash</param>
+        /// <returns>true if follows the drive pattern with slash, false otherwise</returns>
         internal static bool IsDrivePatternWithSlash(string pattern)
         {
             return pattern.Length == 3 &&
@@ -43,10 +43,10 @@ internal static bool IsDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern: "<drive letter>:".
+        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if starts with drive pattern, false otherwise</returns>
         internal static bool StartsWithDrivePattern(string pattern)
         {
             // Format dictates a length of at least 2,
@@ -58,10 +58,10 @@ internal static bool StartsWithDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern: "<drive letter>:/" or "<drive letter>:\".
+        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:/" or "C:\")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if starts with drive pattern with slash, false otherwise</returns>
         internal static bool StartsWithDrivePatternWithSlash(string pattern)
         {
             // Format dictates a length of at least 3,
@@ -74,10 +74,10 @@ internal static bool StartsWithDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified file-spec comprises exactly "\\<server>\<share>" (with no trailing characters).
+        /// Indicates whether the specified file-spec comprises exactly "\\server\share" (with no trailing characters).
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>true if comprises Unc pattern</returns>
         internal static bool IsUncPattern(string pattern)
         {
             //Return value == pattern.length means:
@@ -88,10 +88,10 @@ internal static bool IsUncPattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified file-spec begins with "\\<server>\<share>".
+        /// Indicates whether the specified file-spec begins with "\\server\share".
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>true if starts with Unc pattern</returns>
         internal static bool StartsWithUncPattern(string pattern)
         {
             //Any non -1 value returned means there was a match, therefore is begins with the pattern.
@@ -99,10 +99,10 @@ internal static bool StartsWithUncPattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the file-spec begins with a UNC pattern and how long the match is. -1 indicates no match.
+        /// Indicates whether the file-spec begins with a UNC pattern and how long the match is.
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>length of the match, -1 if no match</returns>
         internal static int StartsWithUncPatternMatchLength(string pattern)
         {
             if (!MeetsUncPatternMinimumRequirements(pattern))
@@ -150,10 +150,9 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
 
         /// <summary>
         /// Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
-        /// UNC pattern requires a minimum length of 5 and first two characters must be a slash.
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern minimum requirements</param>
+        /// <returns>true if the UNC pattern is a minimum length of 5 and the first two characters are be a slash, false otherwise.</returns>
 #if !NET35
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
 #endif
@@ -165,6 +164,5 @@ internal static bool MeetsUncPatternMinimumRequirements(string pattern)
                 (pattern[1] == _backSlash ||
                 pattern[1] == _forwardSlash);
        }
-
     }
 }
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 7b86e274cdf..fdde34fa4bd 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Shared
     internal enum DotNetFrameworkArchitecture
     {
         /// <summary>
-        /// Indicates the .NET Framework that is currently being run under.  
+        /// Indicates the .NET Framework that is currently being run under.
         /// </summary>
         Current = 0,
 
@@ -217,7 +217,7 @@ internal static class FrameworkLocationHelper
 
             // v4.7.1
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion471, visualStudioVersion150),
-            
+
             // v4.7.2
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion472, visualStudioVersion150),
 
@@ -428,13 +428,13 @@ internal static string PathToDotNetFrameworkSdkV20
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
+        ///
         /// NOTE:  This returns the path to the root of the fallback SDK
         /// </summary>
         private static string FallbackDotNetFrameworkSdkInstallPath
@@ -476,15 +476,15 @@ private static string FallbackDotNetFrameworkSdkInstallPath
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
+        ///
         /// NOTE:  This explicitly returns the path to the 3.5 tools (bin) under the fallback
-        /// SDK, to match the data we're pulling from the registry now.  
+        /// SDK, to match the data we're pulling from the registry now.
         /// </summary>
         private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
         {
@@ -507,8 +507,7 @@ private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
                             // Path.Combine leaves no trailing slash, so if we had one before, be sure to add it back in
                             if (endsWithASlash)
                             {
-                                s_pathToV35ToolsInFallbackDotNetFrameworkSdk = s_pathToV35ToolsInFallbackDotNetFrameworkSdk
-                                                                             + Path.DirectorySeparatorChar;
+                                s_pathToV35ToolsInFallbackDotNetFrameworkSdk += Path.DirectorySeparatorChar;
                             }
                         }
                         else
@@ -524,15 +523,15 @@ private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
-        /// NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools) 
-        /// under the fallback SDK, to match the data we're pulling from the registry now.  
+        ///
+        /// NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools)
+        /// under the fallback SDK, to match the data we're pulling from the registry now.
         /// </summary>
         private static string PathToV4ToolsInFallbackDotNetFrameworkSdk
         {
@@ -553,7 +552,7 @@ private static string PathToV4ToolsInFallbackDotNetFrameworkSdk
                             // Path.Combine leaves no trailing slash, so if we had one before, be sure to add it back in
                             if (endsWithASlash)
                             {
-                                s_pathToV4ToolsInFallbackDotNetFrameworkSdk = s_pathToV4ToolsInFallbackDotNetFrameworkSdk + "\\";
+                                s_pathToV4ToolsInFallbackDotNetFrameworkSdk += "\\";
                             }
                         }
                         else
@@ -686,7 +685,7 @@ private static bool CheckForFrameworkInstallation(string registryEntryToCheckIns
                 if (NativeMethodsShared.IsWindows)
                 {
                     // If the registry entry is 1 then the framework is installed. Go ahead and find the directory. If it is not 1 then the framework is not installed, return null.
-                    return String.Compare("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase) == 0;
+                    return String.Equals("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase);
                 }
                 // False for non-windows since there is nothing in the registry
                 else
@@ -766,7 +765,7 @@ DotNetFrameworkArchitecture architecture
             else if (indexOfFramework64 == -1 && architecture == DotNetFrameworkArchitecture.Bitness64)
             {
                 // need to add 64 -- since this is a heuristic, we assume that we just need to append.  
-                baseLocation = baseLocation + "64";
+                baseLocation += "64";
             }
             // we don't need to do anything if it's DotNetFrameworkArchitecture.Current.  
 
@@ -869,7 +868,7 @@ internal static string GenerateProgramFiles64()
         }
 
         /// <summary>
-        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then 
+        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then
         /// using that path to generate the path to the reference assemblies location.
         /// </summary>
         internal static string GenerateProgramFilesReferenceAssemblyRoot()
@@ -892,15 +891,15 @@ internal static string GenerateProgramFilesReferenceAssemblyRoot()
         }
 
         /// <summary>
-        /// Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion. 
+        /// Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion.
         /// </summary>
         /// <param name="toolsVersion">The ToolsVersion to look up</param>
         /// <param name="architecture">Target build tools architecture.</param>
-        /// <returns>The path to the build tools folder for that ToolsVersion, if it exists, or 
+        /// <returns>The path to the build tools folder for that ToolsVersion, if it exists, or
         /// null otherwise</returns>
         internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersion, DotNetFrameworkArchitecture architecture)
         {
-            if (string.Compare(toolsVersion, MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal) == 0)
+            if (string.Equals(toolsVersion, MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
             {
                 return GetPathToBuildToolsFromEnvironment(architecture);
             }
@@ -916,7 +915,7 @@ internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersi
         }
 
         /// <summary>
-        /// Take the parts of the Target framework moniker and formulate the reference assembly path based on the the following pattern:
+        /// Take the parts of the Target framework moniker and formulate the reference assembly path based on the following pattern:
         /// For a framework and version:
         ///     $(TargetFrameworkRootPath)\$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)
         /// For a subtype:
@@ -978,7 +977,7 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
                 DirectoryInfo fixedPathInfo = new DirectoryInfo(path);
                 for (int i = 0; i < numberOfLevelsToRemove; i++)
                 {
-                    if (fixedPathInfo != null && fixedPathInfo.Parent != null)
+                    if (fixedPathInfo?.Parent != null)
                     {
                         fixedPathInfo = fixedPathInfo.Parent;
                     }
@@ -991,7 +990,7 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
 
                 if (fixedPath != null && endedWithASlash)
                 {
-                    fixedPath = fixedPath + Path.DirectorySeparatorChar;
+                    fixedPath += Path.DirectorySeparatorChar;
                 }
             }
 
@@ -999,24 +998,21 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
         }
 
         /// <summary>
-        /// Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable 
+        /// Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable
         /// </summary>
         private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitecture architecture)
         {
-            switch (architecture)
+            return architecture switch
             {
-                case DotNetFrameworkArchitecture.Bitness64:
-                    return BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64;
-                case DotNetFrameworkArchitecture.Bitness32:
-                    return BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-                default:
-                    return BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
-            }
+                DotNetFrameworkArchitecture.Bitness64 => BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64,
+                DotNetFrameworkArchitecture.Bitness32 => BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32,
+                _ => BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
+            };
         }
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
-        /// Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture  
+        /// Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture
         /// </summary>
         private static string GetPathToBuildToolsFromRegistry(string toolsVersion, DotNetFrameworkArchitecture architecture)
         {
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 9a04c4f7ea1..128cdec4826 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -128,10 +128,7 @@ override public String ReadString()
 
                     charsRead = _decoder.GetChars(rawBuffer, rawPosition, n, charBuffer, 0);
 
-                    if (memoryStream != null)
-                    {
-                        memoryStream.Seek(readLength, SeekOrigin.Current);
-                    }
+                    memoryStream?.Seek(readLength, SeekOrigin.Current);
 
                     if (currPos == 0 && n == stringLength)
                     {
diff --git a/src/Shared/LanguageParser/StreamMappedString.cs b/src/Shared/LanguageParser/StreamMappedString.cs
index 71876fbd0ed..5967e0b4212 100644
--- a/src/Shared/LanguageParser/StreamMappedString.cs
+++ b/src/Shared/LanguageParser/StreamMappedString.cs
@@ -71,7 +71,8 @@ sealed internal class StreamMappedString
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="binaryStream"></param>
+        /// <param name="binaryStream">The raw binary stream that's being read.</param>
+        /// <param name="forceANSI">When false, try to guess the encoding of binaryStream. When true, force the encoding to ANSI.</param>
         public StreamMappedString(Stream binaryStream, bool forceANSI)
             : this(binaryStream, forceANSI, /* pageSize */ DefaultPageSize)
         {
@@ -80,7 +81,9 @@ public StreamMappedString(Stream binaryStream, bool forceANSI)
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="binaryStream"></param>
+        /// <param name="binaryStream">The raw binary stream that's being read.</param>
+        /// <param name="forceANSI">When false, try to guess the encoding of binaryStream. When true, force the encoding to ANSI.</param>
+        /// <param name="pageSize">Size of pages to use for reading from source file.</param>
         internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize)
         {
             _binaryStream = binaryStream;
@@ -92,7 +95,6 @@ internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize)
         /// <summary>
         /// Restart the stream reader at the beginning.
         /// </summary>
-        /// <param name="binaryStream"></param>
         private void RestartReader()
         {
             _currentPageNumber = -1;
@@ -161,7 +163,7 @@ public char GetAt(int offset)
             // If null now, then the requested character is out of range.
             if (page == null)
             {
-                throw new ArgumentOutOfRangeException("offset");
+                throw new ArgumentOutOfRangeException(nameof(offset));
             }
 
             // Get the relative offset within the buffer.
@@ -340,7 +342,6 @@ private bool IsZeroLengthStream()
         /// COnvert from absolute offset to relative offset within a particular page.
         /// </summary>
         /// <param name="offset"></param>
-        /// <param name="pageNumber"></param>
         /// <returns></returns>
         private int AbsoluteOffsetToPageOffset(int offset)
         {
@@ -360,7 +361,7 @@ private int PageFromAbsoluteOffset(int offset)
         /// <summary>
         /// Returns true of the given position is passed the end of the file.
         /// </summary>
-        /// <param name="position"></param>
+        /// <param name="offset"></param>
         /// <returns></returns>
         public bool IsPastEnd(int offset)
         {
@@ -385,7 +386,7 @@ public string Substring(int startPosition, int length)
                 // If we weren't able to read enough characters then throw an exception.
                 if (page == null)
                 {
-                    throw new ArgumentOutOfRangeException("length");
+                    throw new ArgumentOutOfRangeException(nameof(length));
                 }
 
                 int relativeStartPosition = AbsoluteOffsetToPageOffset(startPosition + i);
diff --git a/src/Shared/LanguageParser/token.cs b/src/Shared/LanguageParser/token.cs
index 5deedb0a4a6..50156ea1906 100644
--- a/src/Shared/LanguageParser/token.cs
+++ b/src/Shared/LanguageParser/token.cs
@@ -59,7 +59,7 @@ internal int Line
          */
         internal bool EqualsIgnoreCase(string compareTo)
         {
-            return (String.Compare(_innerText, compareTo, StringComparison.OrdinalIgnoreCase) == 0);
+            return (String.Equals(_innerText, compareTo, StringComparison.OrdinalIgnoreCase));
         }
     }
 
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index 6e9e3d0f884..aa8aa07d3d4 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -122,7 +122,6 @@ internal bool EndOfLines
             get { return _sources.IsPastEnd(_position); }
         }
 
-
         /*
          * Method:  GetCurrentMatchedString
          * 
@@ -158,17 +157,16 @@ private bool Sink(string match, bool ignoreCase)
                 return false;
             }
 
-
             string compare = _sources.Substring(_position, match.Length);
 
             if
             (
-                String.Compare
+                String.Equals
                 (
                     match,
                     compare,
                     (ignoreCase /* ignore case */) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal
-                ) == 0
+                )
             )
             {
                 Skip(match.Length);
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
index 2ec0b14c481..e5f0f0ad199 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
@@ -93,8 +93,8 @@ public bool Equals(string compareToString, string constrainedString, int start,
                             {
                                 int chx = px[i];
                                 int chy = py[i + start];
-                                chx = chx & 0x00DF; // Extract the uppercase character
-                                chy = chy & 0x00DF; // Extract the uppercase character
+                                chx &= 0x00DF; // Extract the uppercase character
+                                chy &= 0x00DF; // Extract the uppercase character
 
                                 if (chx != chy)
                                 {
@@ -149,7 +149,7 @@ public int GetHashCode(string obj, int start, int length)
                             // the string, and not the null terminator etc.
                             if (length == 1)
                             {
-                                val = val & 0xFFFF;
+                                val &= 0xFFFF;
                             }
 
                             hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ val;
@@ -162,7 +162,7 @@ public int GetHashCode(string obj, int start, int length)
                             val = pint[1] & 0x00DF00DF;
                             if (length == 3)
                             {
-                                val = val & 0xFFFF;
+                                val &= 0xFFFF;
                             }
 
                             hash2 = ((hash2 << 5) + hash2 + (hash2 >> 27)) ^ val;
diff --git a/src/Shared/MetadataConversionUtilities.cs b/src/Shared/MetadataConversionUtilities.cs
index bab097bf90c..39a454c6266 100644
--- a/src/Shared/MetadataConversionUtilities.cs
+++ b/src/Shared/MetadataConversionUtilities.cs
@@ -31,7 +31,7 @@ out bool metadataFound
             )
         {
             string metadataValue = item.GetMetadata(itemMetadataName);
-            if (metadataValue == null || metadataValue.Length == 0)
+            if (string.IsNullOrEmpty(metadataValue))
             {
                 metadataFound = false;
                 return false;
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 49385b177ad..0f239b6d2cc 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -19,7 +19,6 @@
 using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 using Microsoft.Build.Utilities;
 
-
 namespace Microsoft.Build.Shared
 {
     /// <summary>
@@ -379,21 +378,15 @@ private class SystemInformationData
             /// <returns></returns>
             private static ProcessorArchitectures ConvertSystemArchitecture(ushort arch)
             {
-                switch (arch)
+                return arch switch
                 {
-                    case PROCESSOR_ARCHITECTURE_INTEL:
-                        return ProcessorArchitectures.X86;
-                    case PROCESSOR_ARCHITECTURE_AMD64:
-                        return ProcessorArchitectures.X64;
-                    case PROCESSOR_ARCHITECTURE_ARM:
-                        return ProcessorArchitectures.ARM;
-                    case PROCESSOR_ARCHITECTURE_IA64:
-                        return ProcessorArchitectures.IA64;
-                    case PROCESSOR_ARCHITECTURE_ARM64:
-                        return ProcessorArchitectures.ARM64;
-                    default:
-                        return ProcessorArchitectures.Unknown;
-                }
+                    PROCESSOR_ARCHITECTURE_INTEL => ProcessorArchitectures.X86,
+                    PROCESSOR_ARCHITECTURE_AMD64 => ProcessorArchitectures.X64,
+                    PROCESSOR_ARCHITECTURE_ARM => ProcessorArchitectures.ARM,
+                    PROCESSOR_ARCHITECTURE_IA64 => ProcessorArchitectures.IA64,
+                    PROCESSOR_ARCHITECTURE_ARM64 => ProcessorArchitectures.ARM64,
+                    _ => ProcessorArchitectures.Unknown,
+                };
             }
 
             /// <summary>
@@ -1028,7 +1021,7 @@ private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
                 if (!handle.IsInvalid)
                 {
                     FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;
-                    if (!GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime) != true)
+                    if (GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime))
                     {
                         long fileTime = ((long)(uint)ftLastWriteTime.dwHighDateTime) << 32 |
                                         (long)(uint)ftLastWriteTime.dwLowDateTime;
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 05b8ae7a4a5..88b6cb2966b 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -68,7 +68,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
 
         /// <summary>
         /// Set when a packet is available in the packet queue
-        /// </summary>      
+        /// </summary>
         private AutoResetEvent _packetAvailable;
 
         /// <summary>
@@ -87,7 +87,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         private INodePacketFactory _packetFactory;
 
         /// <summary>
-        /// The asynchronous packet queue.  
+        /// The asynchronous packet queue.
         /// </summary>
         /// <remarks>
         /// Operations on this queue must be synchronized since it is accessible by multiple threads.
@@ -136,14 +136,14 @@ public LinkStatus LinkStatus
         public void Listen(INodePacketFactory factory)
         {
             ErrorUtilities.VerifyThrow(_status == LinkStatus.Inactive, "Link not inactive.  Status is {0}", _status);
-            ErrorUtilities.VerifyThrowArgumentNull(factory, "factory");
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             _packetFactory = factory;
 
             InitializeAsyncPacketThread();
         }
 
         /// <summary>
-        /// Causes this node to connect to the matched endpoint.  
+        /// Causes this node to connect to the matched endpoint.
         /// </summary>
         /// <param name="factory">The factory used to create packets.</param>
         public void Connect(INodePacketFactory factory)
@@ -182,7 +182,7 @@ public void SendData(INodePacket packet)
         /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         internal void InternalConstruct(string pipeName)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(pipeName, "pipeName");
+            ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
 
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
@@ -239,12 +239,7 @@ internal void InternalConstruct(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected abstract long GetHostHandshake();
-
-        /// <summary>
-        /// Returns the client handshake for this node endpoint
-        /// </summary>
-        protected abstract long GetClientHandshake();
+        protected abstract Handshake GetHandshake();
 
         /// <summary>
         /// Updates the current link status if it has changed and notifies any registered delegates.
@@ -296,7 +291,7 @@ private void InternalDisconnect()
         /// <param name="packet">The packet to be transmitted.</param>
         private void EnqueuePacket(INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet, "packet");
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
             ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
 
@@ -329,8 +324,6 @@ private void InitializeAsyncPacketThread()
         private void PacketPumpProc()
         {
             NamedPipeServerStream localPipeServer = _pipeServer;
-            PipeStream localWritePipe = _pipeServer;
-            PipeStream localReadPipe = _pipeServer;
 
             AutoResetEvent localPacketAvailable = _packetAvailable;
             AutoResetEvent localTerminatePacketPump = _terminatePacketPump;
@@ -340,6 +333,7 @@ private void PacketPumpProc()
             bool gotValidConnection = false;
             while (!gotValidConnection)
             {
+                gotValidConnection = true;
                 DateTime restartWaitTime = DateTime.UtcNow;
 
                 // We only wait to wait the difference between now and the last original start time, in case we have multiple hosts attempting
@@ -352,14 +346,11 @@ private void PacketPumpProc()
                     // Wait for a connection
 #if FEATURE_APM
                     IAsyncResult resultForConnection = localPipeServer.BeginWaitForConnection(null, null);
-#else
-                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
-#endif
                     CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
-
-#if FEATURE_APM
                     bool connected = resultForConnection.AsyncWaitHandle.WaitOne(waitTimeRemaining, false);
 #else
+                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
+                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
                     bool connected = connectionTask.Wait(waitTimeRemaining);
 #endif
                     if (!connected)
@@ -374,57 +365,57 @@ private void PacketPumpProc()
                     localPipeServer.EndWaitForConnection(resultForConnection);
 #endif
 
-                    // The handshake protocol is a simple long exchange.  The host sends us a long, and we
-                    // respond with another long.  Once the handshake is complete, both sides can be assured the
-                    // other is ready to accept data.
-                    // To avoid mixing client and server builds, the long is the MSBuild binary timestamp.
-
-                    // Compatibility issue here.
-                    // Previous builds of MSBuild 4.0 would exchange just a byte.
-                    // Host would send either 0x5F or 0x60 depending on whether it was the toolset or not respectively.
-                    // Client would return either 0xF5 or 0x06 respectively.
-                    // Therefore an old host on a machine with new clients running will hang, 
-                    // sending a byte and waiting for a byte until it eventually times out;
-                    // because the new client will want 7 more bytes before it returns anything.
-                    // The other way around is not a problem, because the old client would immediately return the (wrong)
-                    // byte on receiving the first byte of the long sent by the new host, and the new host would disconnect.
-                    // To avoid the hang, special case here:
-                    // Make sure our handshakes always start with 00.
-                    // If we received ONLY one byte AND it's 0x5F or 0x60, return 0xFF (it doesn't matter what as long as
-                    // it will cause the host to reject us; new hosts expect 00 and old hosts expect F5 or 06).
+                    // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
+                    // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
+                    // Once the handshake is complete, both sides can be assured the other is ready to accept data.
+                    Handshake handshake = GetHandshake();
                     try
                     {
-                        long handshake = localReadPipe.ReadLongForHandshake(/* reject these leads */ new byte[] { 0x5F, 0x60 }, 0xFF /* this will disconnect the host; it expects leading 00 or F5 or 06 */
+                        int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+                        for (int i = 0; i < handshakeComponents.Length; i++)
+                        {
+                            int handshakePart = _pipeServer.ReadIntForHandshake(i == 0 ? (byte?)CommunicationsUtilities.handshakeVersion : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
 #if NETCOREAPP2_1 || MONO
                             , ClientConnectTimeout /* wait a long time for the handshake from this side */
 #endif
                             );
 
-#if FEATURE_SECURITY_PERMISSIONS
-                        WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
-#endif
+                            if (handshakePart != handshakeComponents[i])
+                            {
+                                CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, handshakeComponents[i]);
+                                _pipeServer.WriteIntForHandshake(i + 1);
+                                gotValidConnection = false;
+                                break;
+                            }
+                        }
 
-                        if (handshake != GetHostHandshake())
+                        if (gotValidConnection)
                         {
-                            CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshake, GetHostHandshake());
-                            localPipeServer.Disconnect();
-                            continue;
-                        }
+                            // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
+#if NETCOREAPP2_1 || MONO
+                            _pipeServer.ReadEndOfHandshakeSignal(false, ClientConnectTimeout); /* wait a long time for the handshake from this side */
+#else
+                            _pipeServer.ReadEndOfHandshakeSignal(false);
+#endif
+                            CommunicationsUtilities.Trace("Successfully connected to parent.");
+                            _pipeServer.WriteEndOfHandshakeSignal();
 
 #if FEATURE_SECURITY_PERMISSIONS
-                        // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
-                        // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
-                        // user we were started by.
-                        WindowsIdentity clientIdentity = null;
-                        localPipeServer.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
-
-                        if (clientIdentity == null || !String.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
-                        {
-                            CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
-                            localPipeServer.Disconnect();
-                            continue;
-                        }
+                            // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
+                            // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
+                            // user we were started by.
+                            WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
+                            WindowsIdentity clientIdentity = null;
+                            localPipeServer.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
+
+                            if (clientIdentity == null || !String.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
+                            {
+                                CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
+                                gotValidConnection = false;
+                                continue;
+                            }
 #endif
+                        }
                     }
                     catch (IOException e)
                     {
@@ -432,19 +423,25 @@ private void PacketPumpProc()
                         // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
                         //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
                         // 2. The host is too old sending us bits we automatically reject in the handshake
+                        // 3. We expected to read the EndOfHandshake signal, but we received something else
                         CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
+                        
+                        gotValidConnection = false;
+                    }
+                    catch (InvalidOperationException)
+                    {
+                        gotValidConnection = false;
+                    }
+
+                    if (!gotValidConnection)
+                    {
                         if (localPipeServer.IsConnected)
                         {
                             localPipeServer.Disconnect();
                         }
-
                         continue;
                     }
 
-                    gotValidConnection = true;
-
-                    CommunicationsUtilities.Trace("Writing handshake to parent");
-                    localWritePipe.WriteLongForHandshake(GetClientHandshake());
                     ChangeLinkStatus(LinkStatus.Active);
                 }
                 catch (Exception e)
@@ -467,8 +464,8 @@ private void PacketPumpProc()
             }
 
             RunReadLoop(
-                new BufferedReadStream(localReadPipe),
-                localWritePipe,
+                new BufferedReadStream(_pipeServer),
+                _pipeServer,
                 localPacketQueue, localPacketAvailable, localTerminatePacketPump);
 
             CommunicationsUtilities.Trace("Ending read loop");
diff --git a/src/Shared/OutOfProcTaskHostTaskResult.cs b/src/Shared/OutOfProcTaskHostTaskResult.cs
index 03fcc964d2c..5bba48c8960 100644
--- a/src/Shared/OutOfProcTaskHostTaskResult.cs
+++ b/src/Shared/OutOfProcTaskHostTaskResult.cs
@@ -61,7 +61,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
                 result == TaskCompleteType.CrashedDuringExecution ||
                 result == TaskCompleteType.CrashedAfterExecution)
             {
-                ErrorUtilities.VerifyThrowInternalNull(taskException, "taskException");
+                ErrorUtilities.VerifyThrowInternalNull(taskException, nameof(taskException));
             }
 
             if (exceptionMessage != null)
@@ -75,7 +75,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
                     );
             }
 
-            if (exceptionMessageArgs != null && exceptionMessageArgs.Length > 0)
+            if (exceptionMessageArgs?.Length > 0)
             {
                 ErrorUtilities.VerifyThrow(exceptionMessage != null, "If we have message args, we need a message.");
             }
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index a819f326029..303749fc6fd 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -389,7 +389,7 @@ private static void ThrowInvalidProject
             params object[] args
         )
         {
-            ErrorUtilities.VerifyThrowInternalNull(elementLocation, "elementLocation");
+            ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 #if DEBUG
             if (errorSubCategoryResourceName != null)
             {
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index 9c6f2361554..c311159d878 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -84,7 +84,6 @@ params object[] args
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
-        /// <param name="condition">The condition to check.</param>
         /// <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
         /// <param name="projectFile">The invalid project file.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
diff --git a/src/Shared/ProjectWriter.cs b/src/Shared/ProjectWriter.cs
index 9a467ad193b..d925f19dea0 100644
--- a/src/Shared/ProjectWriter.cs
+++ b/src/Shared/ProjectWriter.cs
@@ -119,7 +119,7 @@ internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementD
 
             // don't write an XML declaration unless the project already has one or has non-default encoding
             _writeXmlDeclaration = projectRootElementDeclaration != null ||
-                                   _documentEncoding != null && !_documentEncoding.IsUtf8Encoding();
+                                   _documentEncoding?.IsUtf8Encoding() == false;
         }
 
         /// <summary>
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index c0a712ab818..bb362f26f24 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -128,7 +128,7 @@ public bool Contains(T item)
         /// </summary>
         public void CopyTo(T[] array, int arrayIndex)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(array, "array");
+            ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
 
             ICollection<T> backingCollection = _backing as ICollection<T>;
             if (backingCollection != null)
@@ -184,7 +184,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// </summary>
         void ICollection.CopyTo(Array array, int index)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(array, "array");
+            ErrorUtilities.VerifyThrowArgumentNull(array, nameof(array));
 
             int i = index;
             foreach (T entry in _backing)
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index 1d8350fd73d..17444232eba 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -60,10 +60,7 @@ public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifet
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: false);
 
-            if (dict != null)
-            {
-                dict.TryAdd(key, obj);
-            }
+            dict?.TryAdd(key, obj);
         }
 
         /// <summary>
@@ -73,10 +70,7 @@ public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime l
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: true);
             object obj = null;
-            if (dict != null)
-            {
-                dict.TryGetValue(key, out obj);
-            }
+            dict?.TryGetValue(key, out obj);
 
             return obj;
         }
@@ -88,10 +82,7 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: true);
             object obj = null;
-            if (dict != null)
-            {
-                dict.TryRemove(key, out obj);
-            }
+            dict?.TryRemove(key, out obj);
 
             return obj;
         }
@@ -155,10 +146,7 @@ private static void DisposeObjects(Lazy<ConcurrentDictionary<object, object>> li
                     try
                     {
                         IDisposable disposable = obj as IDisposable;
-                        if (disposable != null)
-                        {
-                            disposable.Dispose();
-                        }
+                        disposable?.Dispose();
                     }
                     catch (Exception ex)
                     {
diff --git a/src/Shared/RegistryHelper.cs b/src/Shared/RegistryHelper.cs
index 49f6e4076dc..53085889348 100644
--- a/src/Shared/RegistryHelper.cs
+++ b/src/Shared/RegistryHelper.cs
@@ -48,7 +48,7 @@ internal static string GetDefaultValue(RegistryKey baseKey, string subkey)
 
             using (RegistryKey key = baseKey.OpenSubKey(subkey))
             {
-                if (key != null && key.ValueCount > 0)
+                if (key?.ValueCount > 0)
                 {
                     value = (string)key.GetValue("");
                 }
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index b380e8f2054..ad9884e695f 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -38,7 +38,7 @@ internal static class ResourceUtilities
         internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, out string code)
         {
 #if !BUILDINGAPPXTASKS
-            ErrorUtilities.VerifyThrowInternalNull(message, "message");
+            ErrorUtilities.VerifyThrowInternalNull(message, nameof(message));
 #endif
 
             code = null;
@@ -69,7 +69,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
 
                 code = message.Substring(i, 7);
 
-                i = i + 8;
+                i += 8;
             }
             else
 #endif
@@ -227,7 +227,7 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Shared/ReuseableStringBuilder.cs b/src/Shared/ReuseableStringBuilder.cs
index 8f295e0b263..bcd727bc402 100644
--- a/src/Shared/ReuseableStringBuilder.cs
+++ b/src/Shared/ReuseableStringBuilder.cs
@@ -80,7 +80,6 @@ string IInternable.ExpensiveConvertToString()
                 _cachedString = ((ReuseableStringBuilder)this).ToString();
             }
             return _cachedString;
-
         }
 
         /// <summary>
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 9f031270a1f..141528ecc11 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -86,6 +86,7 @@ internal class TaskHostConfiguration : INodePacket
 
         private Dictionary<string, string> _globalParameters;
 
+#if FEATURE_APPDOMAIN
         /// <summary>
         /// Constructor
         /// </summary>
@@ -102,6 +103,25 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="taskName">Name of the task.</param>
         /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
         /// <param name="taskParameters">Parameters to apply to the task.</param>
+        /// <param name="globalParameters">global properties for the current project.</param>
+#else
+        /// <summary>
+        /// Constructor
+        /// </summary>
+        /// <param name="nodeId">The ID of the node being configured.</param>
+        /// <param name="startupDirectory">The startup directory for the task being executed.</param>
+        /// <param name="buildProcessEnvironment">The set of environment variables to apply to the task execution process.</param>
+        /// <param name="culture">The culture of the thread that will execute the task.</param>
+        /// <param name="uiCulture">The UI culture of the thread that will execute the task.</param>
+        /// <param name="lineNumberOfTask">The line number of the location from which this task was invoked.</param>
+        /// <param name="columnNumberOfTask">The column number of the location from which this task was invoked.</param>
+        /// <param name="projectFileOfTask">The project file from which this task was invoked.</param>
+        /// <param name="continueOnError">Flag to continue with the build after a the task failed</param>
+        /// <param name="taskName">Name of the task.</param>
+        /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
+        /// <param name="taskParameters">Parameters to apply to the task.</param>
+        /// <param name="globalParameters">global properties for the current project.</param>
+#endif
         public TaskHostConfiguration
             (
                 int nodeId,
@@ -122,8 +142,8 @@ public TaskHostConfiguration
                 Dictionary<string, string> globalParameters
             )
         {
-            ErrorUtilities.VerifyThrowInternalLength(taskName, "taskName");
-            ErrorUtilities.VerifyThrowInternalLength(taskLocation, "taskLocation");
+            ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowInternalLength(taskLocation, nameof(taskLocation));
 
             _nodeId = nodeId;
             _startupDirectory = startupDirectory;
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index 4a190e217fa..9699bbab4f3 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -91,7 +91,7 @@ internal class TaskHostTaskComplete : INodePacket
         /// <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
         public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<string, string> buildProcessEnvironment)
         {
-            ErrorUtilities.VerifyThrowInternalNull(result, "result");
+            ErrorUtilities.VerifyThrowInternalNull(result, nameof(result));
 
             _taskResult = result.Result;
             _taskException = result.TaskException;
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index 3e85e65d579..5be8cbaaf55 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -181,7 +181,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
         /// </summary>
         internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if ((s_resolverLoadedType != null) && (s_resolverLoadedType.LoadedAssembly != null))
+            if ((s_resolverLoadedType?.LoadedAssembly != null))
             {
                 // Match the name being requested by the resolver with the FullName of the assembly we have loaded
                 if (args.Name.Equals(s_resolverLoadedType.LoadedAssembly.FullName, StringComparison.Ordinal))
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 95b5e812934..fe6d67f1c8c 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -555,7 +555,6 @@ public void LogCommandLine(MessageImportance importance, string commandLine)
                 ErrorUtilities.ThrowInvalidOperation("LoggingBeforeTaskInitialization", e.Message);
             }
 
-
             BuildEngine.LogMessageEvent(e);
         }
 
@@ -737,7 +736,7 @@ params object[] messageArgs
             string messageCode;
             string throwAwayMessageBody = ResourceUtilities.ExtractMessageCode(true /* only msbuild codes */, FormatResourceString(messageResourceName, messageArgs), out messageCode);
 
-            ErrorUtilities.VerifyThrow(messageCode == null || messageCode.Length == 0, "Called LogErrorFromResources instead of LogErrorWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
+            ErrorUtilities.VerifyThrow(string.IsNullOrEmpty(messageCode), "Called LogErrorFromResources instead of LogErrorWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
 #endif
 
             LogError
@@ -1325,7 +1324,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
                 //  Log it as a warning or error.
                 string origin = messageParts.origin;
 
-                if ((origin == null) || (origin.Length == 0))
+                if (string.IsNullOrEmpty(origin))
                 {
                     // Use the task class name as the origin, if none specified.
                     origin = TaskNameUpperCase;
diff --git a/src/Shared/TaskLoggingHelperExtension.cs b/src/Shared/TaskLoggingHelperExtension.cs
index 3f1c1528468..fbfe95f875c 100644
--- a/src/Shared/TaskLoggingHelperExtension.cs
+++ b/src/Shared/TaskLoggingHelperExtension.cs
@@ -88,7 +88,7 @@ public ResourceManager TaskSharedResources
         /// <exception cref="InvalidOperationException">Thrown when the <c>TaskResources</c> property of the owner task is not set.</exception>
         override public string FormatResourceString(string resourceName, params object[] args)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(resourceName, "resourceName");
+            ErrorUtilities.VerifyThrowArgumentNull(resourceName, nameof(resourceName));
             ErrorUtilities.VerifyThrowInvalidOperation(TaskResources != null, "Shared.TaskResourcesNotRegistered", TaskName);
             ErrorUtilities.VerifyThrowInvalidOperation(TaskSharedResources != null, "Shared.TaskResourcesNotRegistered", TaskName);
 
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 31d299b2737..cccb5b6fd43 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -95,7 +95,7 @@ public TaskParameter(object wrappedParameter)
 
             Type wrappedParameterType = wrappedParameter.GetType();
 
-            if ((wrappedParameter as Exception) != null)
+            if (wrappedParameter is Exception)
             {
                 _parameterType = TaskParameterType.Invalid;
                 _wrappedParameter = wrappedParameter;
@@ -311,7 +311,7 @@ private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
                 IDictionary customMetadata = copyFrom.CloneCustomMetadata();
                 escapedMetadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                if (customMetadata != null && customMetadata.Count > 0)
+                if (customMetadata?.Count > 0)
                 {
                     foreach (string key in customMetadata.Keys)
                     {
@@ -523,7 +523,7 @@ private class TaskParameterTaskItem :
             /// </summary>
             public TaskParameterTaskItem(string escapedItemSpec, string escapedDefiningProject, Dictionary<string, string> escapedMetadata)
             {
-                ErrorUtilities.VerifyThrowInternalNull(escapedItemSpec, "escapedItemSpec");
+                ErrorUtilities.VerifyThrowInternalNull(escapedItemSpec, nameof(escapedItemSpec));
 
                 _escapedItemSpec = escapedItemSpec;
                 _escapedDefiningProject = escapedDefiningProject;
@@ -614,13 +614,13 @@ public string GetMetadata(string metadataName)
             /// <param name="metadataValue">The metadata value.</param>
             public void SetMetadata(string metadataName, string metadataValue)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
 
                 // Non-derivable metadata can only be set at construction time.
                 // That's why this is IsItemSpecModifier and not IsDerivableItemSpecModifier.
                 ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(metadataName), "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-                _customEscapedMetadata = _customEscapedMetadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                _customEscapedMetadata ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 _customEscapedMetadata[metadataName] = metadataValue ?? String.Empty;
             }
@@ -631,7 +631,7 @@ public void SetMetadata(string metadataName, string metadataValue)
             /// <param name="metadataName">The name of the metadata to remove.</param>
             public void RemoveMetadata(string metadataName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
                 ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(metadataName), "Shared.CannotChangeItemSpecModifiers", metadataName);
 
                 if (_customEscapedMetadata == null)
@@ -654,7 +654,7 @@ public void RemoveMetadata(string metadataName)
             /// <param name="destinationItem">The item to copy metadata to.</param>
             public void CopyMetadataTo(ITaskItem destinationItem)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, "destinationItem");
+                ErrorUtilities.VerifyThrowArgumentNull(destinationItem, nameof(destinationItem));
 
                 // also copy the original item-spec under a "magic" metadata -- this is useful for tasks that forward metadata
                 // between items, and need to know the source item where the metadata came from
@@ -721,7 +721,7 @@ public override object InitializeLifetimeService()
             /// </summary>
             string ITaskItem2.GetMetadataValueEscaped(string metadataName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(metadataName, "metadataName");
+                ErrorUtilities.VerifyThrowArgumentNull(metadataName, nameof(metadataName));
 
                 string metadataValue = null;
 
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index 8948d8dde99..ae76d151a37 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -15,8 +15,8 @@ namespace Microsoft.Build.Shared
     internal static partial class FileUtilities
     {
         /// <summary>
-        /// Generates a unique directory name in the temporary folder.  
-        /// Caller must delete when finished. 
+        /// Generates a unique directory name in the temporary folder.
+        /// Caller must delete when finished.
         /// </summary>
         /// <param name="createDirectory"></param>
         internal static string GetTemporaryDirectory(bool createDirectory = true)
@@ -86,7 +86,7 @@ internal static string GetTemporaryFile(string directory, string extension, bool
 
             try
             {
-                directory = directory ?? Path.GetTempPath();
+                directory ??= Path.GetTempPath();
 
                 Directory.CreateDirectory(directory);
 
@@ -147,6 +147,5 @@ public void Dispose()
                 Directory.Delete(Path, true);
             }
         }
-
     }
 }
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 4fb6b9f9f40..2da1f6a18eb 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -100,12 +100,12 @@ public string toolsVersion
 
             set
             {
-                base["toolsVersion"] = value;
+                base[nameof(toolsVersion)] = value;
             }
         }
 
         /// <summary>
-        /// Property element collection 
+        /// Property element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public PropertyElementCollection PropertyElements
@@ -321,7 +321,7 @@ internal sealed class PropertyElementCollection : ConfigurationElementCollection
 
             /// <summary>
             /// Collection type
-            /// This has to be public as cannot change access modifier when overriding  
+            /// This has to be public as cannot change access modifier when overriding
             /// </summary>
             public override ConfigurationElementCollectionType CollectionType
             {
@@ -610,7 +610,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     /// <summary>
     /// This class is used to programmatically read msbuildToolsets section
     /// in from the configuration file.  An example of application config file:
-    /// 
+    ///
     /// &lt;configuration&gt;
     ///     &lt;msbuildToolsets default="2.0"&gt;
     ///         &lt;toolset toolsVersion="2.0"&gt;
@@ -622,7 +622,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     ///         &lt;/toolset&gt;
     ///     &lt;/msbuildToolsets&gt;
     /// &lt;/configuration&gt;
-    /// 
+    ///
     /// </summary>
     /// <remarks>
     /// Internal for unit testing only
@@ -630,7 +630,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     internal sealed class ToolsetConfigurationSection : ConfigurationSection
     {
         /// <summary>
-        /// toolsVersion element collection 
+        /// toolsVersion element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public ToolsetElementCollection Toolsets
@@ -688,7 +688,7 @@ public string MSBuildOverrideTasksPath
         }
 
         /// <summary>
-        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by 
+        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by
         /// default to build projects with this version of MSBuild.
         /// </summary>
         [ConfigurationProperty("DefaultOverrideToolsVersion")]
@@ -707,7 +707,7 @@ public string DefaultOverrideToolsVersion
 
             set
             {
-                base["DefaultOverrideToolsVersion"] = value;
+                base[nameof(DefaultOverrideToolsVersion)] = value;
             }
         }
     }
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index d2b59ce5c80..418a6f1c055 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -201,7 +201,7 @@ public bool LogTaskInputs
         public readonly bool IgnoreEmptyImports = Environment.GetEnvironmentVariable("MSBUILDIGNOREEMPTYIMPORTS") == "1";
 
         /// <summary>
-        /// Whether to to respect the TreatAsLocalProperty parameter on the Project tag. 
+        /// Whether to respect the TreatAsLocalProperty parameter on the Project tag.
         /// </summary>
         public readonly bool IgnoreTreatAsLocalProperty = Environment.GetEnvironmentVariable("MSBUILDIGNORETREATASLOCALPROPERTY") != null;
 
@@ -271,6 +271,29 @@ public bool LogTaskInputs
         /// </remarks>
         public readonly bool UseMinimalResxParsingInCoreScenarios = Environment.GetEnvironmentVariable("MSBUILDUSEMINIMALRESX") == "1";
 
+        private bool _sdkReferencePropertyExpansionInitialized;
+        private SdkReferencePropertyExpansionMode? _sdkReferencePropertyExpansionValue;
+
+        /// <summary>
+        /// Overrides the default behavior of property expansion on evaluation of a <see cref="Framework.SdkReference"/>.
+        /// </summary>
+        /// <remarks>
+        /// Escape hatch for problems arising from https://github.com/dotnet/msbuild/pull/5552.
+        /// </remarks>
+        public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
+        {
+            get
+            {
+                if (!_sdkReferencePropertyExpansionInitialized)
+                {
+                    _sdkReferencePropertyExpansionValue = ComputeSdkReferencePropertyExpansion();
+                    _sdkReferencePropertyExpansionInitialized = true;
+                }
+
+                return _sdkReferencePropertyExpansionValue;
+            }
+        }
+
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
@@ -314,10 +337,58 @@ public bool LogTaskInputs
             return null;
         }
 
+        private static SdkReferencePropertyExpansionMode? ComputeSdkReferencePropertyExpansion()
+        {
+            var mode = Environment.GetEnvironmentVariable("MSBUILD_SDKREFERENCE_PROPERTY_EXPANSION_MODE");
+
+            if (mode == null)
+            {
+                return null;
+            }
+
+            // The following uses StartsWith instead of Equals to enable possible tricks like
+            // the dpiAware "True/PM" trick (see https://devblogs.microsoft.com/oldnewthing/20160617-00/?p=93695)
+            // in the future.
+
+            const StringComparison comparison = StringComparison.OrdinalIgnoreCase;
+
+            if (mode.StartsWith("no", comparison))
+            {
+                return SdkReferencePropertyExpansionMode.NoExpansion;
+            }
+
+            if (mode.StartsWith("default", comparison))
+            {
+                return SdkReferencePropertyExpansionMode.DefaultExpand;
+            }
+
+            if (mode.StartsWith(nameof(SdkReferencePropertyExpansionMode.ExpandUnescape), comparison))
+            {
+                return SdkReferencePropertyExpansionMode.ExpandUnescape;
+            }
+
+            if (mode.StartsWith(nameof(SdkReferencePropertyExpansionMode.ExpandLeaveEscaped), comparison))
+            {
+                return SdkReferencePropertyExpansionMode.ExpandLeaveEscaped;
+            }
+
+            ErrorUtilities.ThrowInternalError($"Invalid escape hatch for SdkReference property expansion: {mode}");
+
+            return null;
+        }
+
         public enum ProjectInstanceTranslationMode
         {
             Full,
             Partial
         }
+
+        public enum SdkReferencePropertyExpansionMode
+        {
+            NoExpansion,
+            DefaultExpand,
+            ExpandUnescape,
+            ExpandLeaveEscaped
+        }
     }
 }
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 20a1a75f2fa..f1cd7166213 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -21,7 +21,7 @@ internal static class TranslatorHelpers
         /// <typeparam name="T">The reference type.</typeparam>
         /// <param name="translator">The translator</param>
         /// <param name="instance">The value to be translated.</param>
-        /// <param name="factory">The factory method used to instantiate values of type T.</param>
+        /// <param name="valueFactory">The factory method used to instantiate values of type T.</param>
         public static void Translate<T>(
             this ITranslator translator,
             ref T instance,
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index b88c90eefdd..7115f9d347f 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
@@ -133,7 +132,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             }
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
@@ -281,7 +280,7 @@ private class AssemblyInfoToLoadedTypes
             internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, AssemblyLoadInfo loadInfo)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeFilter, "typefilter");
-                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, "loadInfo");
+                ErrorUtilities.VerifyThrowArgumentNull(loadInfo, nameof(loadInfo));
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
@@ -294,7 +293,7 @@ internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, Assembly
             /// </summary>
             internal LoadedType GetLoadedTypeByTypeName(string typeName)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(typeName, "typeName");
+                ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
                 // Only one thread should be doing operations on this instance of the object at a time.
 
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index a78ff71ecbd..9680172543b 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -712,7 +712,6 @@ public void VerifyAssemblyNameExSerialization(string assemblyName)
         [Fact]
         public void VerifyAssemblyNameExSerializationWithRemappedFrom()
         {
-            
             AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension assemblyRemappedFrom = new AssemblyNameExtension("System.Xml, Version=9.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             assemblyRemappedFrom.MarkImmutable();
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index db6f2277c5e..293b4dbcec3 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -128,7 +128,6 @@ void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false,
             //    of Directory.GetFiles, which is case-sensitive on Unix.
         }
 
-
         /// <summary>
         /// A test data class for providing data to the <see cref="FileMatcherTest.GetFilesComplexGlobbingMatching"/> test.
         /// </summary>
@@ -724,7 +723,6 @@ public void Regress162390()
             );
         }
 
-
         /*
         * Method:  GetLongFileNameForShortLocalPath
         *
@@ -982,7 +980,6 @@ public void ReduceDoubleSlashesBaseline()
             ValidateFileMatch(Path.Combine("**", "*.cs"), "file.cs", true);
         }
 
-
         [Fact]
         public void ReduceDoubleSlashes()
         {
@@ -1091,7 +1088,6 @@ public void Unc()
                 true
                 );
 
-
             ValidateFileMatch
                 (
                 "**",
@@ -1204,7 +1200,6 @@ public void SplitFileSpec()
             ValidateSplitFileSpec("bin\\**\\", "bin\\", "**\\", "");
             ValidateSplitFileSpec("bin\\**\\*", "bin\\", "**\\", "*");
             ValidateSplitFileSpec("**", "", "**\\", "*.*");
-
         }
 
         [Fact]
@@ -1455,7 +1450,6 @@ public void ExcludePatternAndSpecificFiles()
                     @"bin\**",
                     @"Program_old.cs",
                     @"Properties\AssemblyInfo_old.cs"
-
                 },
                 new[]    //  Matching files
                 {
@@ -1857,8 +1851,6 @@ out bool isLegalFileSpec
             isLegalFileSpec.ShouldBe(expectedIsLegalFileSpec);
         }
 
-
-
         #region Support functions.
 
         /// <summary>
@@ -1972,7 +1964,7 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             if
                             (
                                 pattern == null ||
-                                String.Compare(pattern, "*.*", StringComparison.OrdinalIgnoreCase) == 0
+                                String.Equals(pattern, "*.*", StringComparison.OrdinalIgnoreCase)
                             )
                             {
                                 ++hits;
@@ -1982,7 +1974,7 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             {
                                 string tail = pattern.Substring(1);
                                 string candidateTail = candidate.Substring(candidate.Length - tail.Length);
-                                if (String.Compare(tail, candidateTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                if (String.Equals(tail, candidateTail, StringComparison.OrdinalIgnoreCase))
                                 {
                                     ++hits;
                                     files.Add(FileMatcher.Normalize(candidate));
@@ -1992,11 +1984,11 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             {
                                 string leader = pattern.Substring(0, pattern.Length - 4);
                                 string candidateLeader = candidate.Substring(candidate.Length - leader.Length - 4, leader.Length);
-                                if (String.Compare(leader, candidateLeader, StringComparison.OrdinalIgnoreCase) == 0)
+                                if (String.Equals(leader, candidateLeader, StringComparison.OrdinalIgnoreCase))
                                 {
                                     string tail = pattern.Substring(pattern.Length - 2);
                                     string candidateTail = candidate.Substring(candidate.Length - 2);
-                                    if (String.Compare(tail, candidateTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                    if (String.Equals(tail, candidateTail, StringComparison.OrdinalIgnoreCase))
                                     {
                                         ++hits;
                                         files.Add(FileMatcher.Normalize(candidate));
@@ -2053,7 +2045,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
 
                                 if
                                 (
-                                    String.Compare(pattern, "*.*", StringComparison.OrdinalIgnoreCase) == 0
+                                    String.Equals(pattern, "*.*", StringComparison.OrdinalIgnoreCase)
                                     || pattern == null
                                 )
                                 {
@@ -2067,7 +2059,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                                 {
                                     string tail = pattern.Substring(1);
                                     string baseMatchTail = baseMatch.Substring(1);
-                                    if (String.Compare(tail, baseMatchTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                    if (String.Equals(tail, baseMatchTail, StringComparison.OrdinalIgnoreCase))
                                     {
                                         directories.Add(FileMatcher.Normalize(match));
                                     }
@@ -2138,7 +2130,6 @@ internal static string Normalize(string path)
                 // Preserve parent-directory markers.
                 normalized = normalized.Replace(@".." + Path.DirectorySeparatorChar, "<:PARENT:>");
 
-
                 // Just get rid of doubles enough to satisfy our test cases.
                 string doubleSeparator = Path.DirectorySeparatorChar.ToString() + Path.DirectorySeparatorChar.ToString();
                 normalized = normalized.Replace(doubleSeparator, Path.DirectorySeparatorChar.ToString());
@@ -2190,7 +2181,6 @@ private bool IsMatchingDirectory(string path, string candidate)
                 return false;
             }
 
-
             /// <summary>
             /// Searches the candidates array for one that matches path
             /// </summary>
@@ -2326,7 +2316,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                     int timesFound = 0;
                     foreach (string file in normalizedFiles)
                     {
-                        if (String.Compare(file, matchingFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(file, matchingFile, StringComparison.OrdinalIgnoreCase))
                         {
                             ++timesFound;
                         }
@@ -2345,7 +2335,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                     int timesFound = 0;
                     foreach (string file in normalizedFiles)
                     {
-                        if (String.Compare(file, nonmatchingFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(file, nonmatchingFile, StringComparison.OrdinalIgnoreCase))
                         {
                             ++timesFound;
                         }
@@ -2358,8 +2348,6 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
             Assert.Equal(0, mockFileSystem.FileHits3); // "At least one file that was marked untouchable was referenced."
         }
 
-
-
         /// <summary>
         /// Simulate GetFileSystemEntries
         /// </summary>
@@ -2377,7 +2365,6 @@ private static ImmutableArray<string> GetFileSystemEntriesLoopBack(FileMatcher.F
 
         private static FileMatcher loopBackFileMatcher = new FileMatcher(FileSystems.Default, GetFileSystemEntriesLoopBack);
 
-
         private static void ValidateSplitFileSpec
             (
             string filespec,
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index b9b730401aa..43e2aa4c725 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -273,7 +273,6 @@ public void HasExtension_WhenInvalidFileName_ThrowsArgumentException()
             Assert.Throws<ArgumentException>(() =>
             {
                 FileUtilities.HasExtension("|/", new[] { ".exe" });
-
             });
         }
 
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index b7b47a4e20e..6988124e6e4 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -70,7 +70,6 @@ internal static string MSBuildAssemblyVersion
             }
         }
 
-
         /// <summary>
         /// Helper method to tell us whether a particular metadata name is an MSBuild well-known metadata
         /// (e.g., "RelativeDir", "FullPath", etc.)
@@ -431,7 +430,6 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
             foreach (var key in expected.Keys)
             {
                 item.GetMetadataValue(key).ShouldBe(expected[key]);
-
             }
         }
 
@@ -778,7 +776,6 @@ string newExpectedProjectContents
             Assert.Equal(newExpectedProjectContents, newActualProjectContents); // "Project XML does not match expected XML.  See 'Standard Out' tab for details."
         }
 
-
         private static string s_tempProjectDir;
 
         /// <summary>
@@ -1351,7 +1348,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
         {
             using (var buildManager = new BuildManager())
             {
-                parameters = parameters ?? new BuildParameters();
+                parameters ??= new BuildParameters();
 
                 if (logger != null)
                 {
@@ -1607,7 +1604,7 @@ internal static ProjectGraph CreateProjectGraph(
             IEnumerable<int> entryPoints = null,
             ProjectCollection projectCollection = null)
         {
-            createProjectFile = createProjectFile ?? CreateProjectFile;
+            createProjectFile ??= CreateProjectFile;
 
             var nodes = new Dictionary<int, (bool IsRoot, string ProjectPath)>();
 
@@ -1656,7 +1653,7 @@ bool IsRoot(int node)
             {
                 foreach (var nodeDependencies in dependencyEdges)
                 {
-                    if (nodeDependencies.Value != null && nodeDependencies.Value.Contains(node))
+                    if (nodeDependencies.Value?.Contains(node) == true)
                     {
                         return false;
                     }
@@ -1842,8 +1839,6 @@ internal static string GetSleepCommandTemplate()
                     : "sleep {0}";
         }
 
-
-
         /// <summary>
         /// Break the provided string into an array, on newlines
         /// </summary>
@@ -1898,7 +1893,6 @@ internal class BuildManagerSession : IDisposable
 
             public MockLogger Logger { get; set; }
 
-
             public BuildManagerSession(
                 TestEnvironment env,
                 BuildParameters buildParametersPrototype = null,
diff --git a/src/Shared/UnitTests/TestData/GlobbingTestData.cs b/src/Shared/UnitTests/TestData/GlobbingTestData.cs
index 4d7418086c6..a0fe1f04247 100644
--- a/src/Shared/UnitTests/TestData/GlobbingTestData.cs
+++ b/src/Shared/UnitTests/TestData/GlobbingTestData.cs
@@ -5,7 +5,6 @@
 
 namespace Microsoft.Build.Engine.UnitTests.Globbing
 {
-    
     public static class GlobbingTestData
     {
         public static IEnumerable<object[]> IncludesAndExcludesWithWildcardsTestData
diff --git a/src/Shared/VisualStudioLocationHelper.cs b/src/Shared/VisualStudioLocationHelper.cs
index 35792d610fa..b3f5bcb2487 100644
--- a/src/Shared/VisualStudioLocationHelper.cs
+++ b/src/Shared/VisualStudioLocationHelper.cs
@@ -85,7 +85,6 @@ private static ISetupConfiguration GetQuery()
                 // Try to CoCreate the class object.
                 return new SetupConfiguration();
             }
-
             catch (COMException ex) when (ex.ErrorCode == REGDB_E_CLASSNOTREG)
             {
                 // Try to get the class object using app-local call.
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
index bf9c6ed8ca3..bd30282b614 100644
--- a/src/Shared/WeakStringCache.Concurrent.cs
+++ b/src/Shared/WeakStringCache.Concurrent.cs
@@ -26,6 +26,7 @@ public WeakStringCache()
         /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
         /// </summary>
         /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <param name="cacheHit">true if match found in cache, false otherwise.</param>
         /// <returns>A string matching the given internable.</returns>
         /// <remarks>
         /// This method performs two operations on the underlying ConcurrentDictionary on both cache hit and cache miss.
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 103570c4d6e..51017eb2c93 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -49,16 +49,15 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 newElement.AppendChild(oldElement.FirstChild);
             }
 
-            if (oldElement.ParentNode != null)
-            {
+               
+            
                 // Add the new element in the same place the old element was.
-                oldElement.ParentNode.ReplaceChild(newElement, oldElement);
-            }
+                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+            
 
             return newElement;
         }
 
-
         /// <summary>
         /// Verifies that a name is valid for the name of an item, property, or piece of metadata.
         /// If it isn't, throws an ArgumentException indicating the invalid character.
@@ -70,7 +69,7 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
         /// <param name="name">name to validate</param>
         internal static void VerifyThrowArgumentValidElementName(string name)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
 
             int firstInvalidCharLocation = LocateFirstInvalidElementNameCharacter(name);
 
@@ -89,7 +88,7 @@ internal static void VerifyThrowArgumentValidElementName(string name)
         /// </remarks>
         internal static void VerifyThrowProjectValidElementName(string name, IElementLocation location)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(name, "name");
+            ErrorUtilities.VerifyThrowArgumentLength(name, nameof(name));
             int firstInvalidCharLocation = LocateFirstInvalidElementNameCharacter(name);
 
             if (-1 != firstInvalidCharLocation)
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index f5f4477693e..abf1346f0cd 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -92,8 +92,6 @@ public Miscellaneous(ITestOutputHelper output) : base(output)
         {
         }
 
-
-
         /// <summary>
         /// Let us have the following dependency structure
         ///
@@ -142,8 +140,6 @@ public void CopyLocalDependenciesWhenParentReferenceInGacFalseAllParentsInGac()
             t.ResolvedFiles[0].GetMetadata("CopyLocal").ShouldBe("false", StringCompareShould.IgnoreCase);
         }
 
-
-
         [Fact]
         public void ValidateFrameworkNameError()
         {
@@ -445,7 +441,6 @@ public void Basic()
             assemblyNames[0].SetMetadata(ItemMetadataNames.winMDFile, "NOPE");
             assemblyNames[0].SetMetadata(ItemMetadataNames.winmdImplmentationFile, "IMPL");
 
-
             assemblyNames[1].SetMetadata("Private", "true");
             assemblyNames[2].SetMetadata("Private", "false");
             assemblyNames[4].SetMetadata("Private", "false");
@@ -476,7 +471,7 @@ public void Basic()
             // Process the primary items.
             foreach (ITaskItem item in t.ResolvedFiles)
             {
-                if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     systemXmlFound = true;
                     item.GetMetadata("DestinationSubDirectory").ShouldBe("", StringCompareShould.IgnoreCase);
@@ -535,13 +530,13 @@ public void Basic()
                     item.GetMetadata("CopyLocal").ShouldBe("true", StringCompareShould.IgnoreCase);
                     item.GetMetadata("FusionName").ShouldBe("MyMissingAssembly", StringCompareShould.IgnoreCase);
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     // The version of System.Xml.dll in C:\MyProject is an older version.
                     // This version is not a match. When want the current version which should have been in a different directory.
                     Assert.True(false, "Wrong version of System.Xml.dll matched--version was wrong");
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     // The version of System.Data.dll in C:\MyProject has an incorrect PKT
                     // This version is not a match.
@@ -592,14 +587,14 @@ public void Basic()
             // Process the satellites.
             foreach (ITaskItem item in t.SatelliteFiles)
             {
-                if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "en", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "en", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase))
                 {
                     enSatellitePdbFound = true;
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.imageRuntime));
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.winMDFile));
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.winmdImplmentationFile));
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "en-GB", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "en-GB", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase))
                 {
                     engbSatellitePdbFound = true;
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.imageRuntime));
@@ -729,7 +724,6 @@ public void EmbedInteropTypes()
                 { "false", "false", "false", "false" }     // MyDontCopyLocalAssembly
             };
 
-
             int assembliesCount = (int)EmbedInteropTypes_Indices.EndMarker;
 
             // now let's verify our data structures are all set up correctly
@@ -807,7 +801,6 @@ public void NOPForEmptyItemLists()
             Assert.True(succeeded); // "Expected success."
         }
 
-
         /// <summary>
         /// If no related file extensions are input to RAR, .pdb and .xml should be used
         /// by default.
@@ -1021,7 +1014,6 @@ public void SimulateCreateProjectAgainstWhidbeyWithTrailingSlash()
             SimulateCreateProjectAgainstWhidbeyInternal(ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version45) + @"\");
         }
 
-
         /// <summary>
         /// Invalid candidate assembly files should not crash
         /// </summary>
@@ -1168,7 +1160,6 @@ public void NonExistentReference()
             Assert.Equal(0, String.Compare(ToolLocationHelper.GetPathToDotNetFrameworkFile("System.Xml.dll", TargetDotNetFrameworkVersion.Version45), t.ResolvedFiles[0].ItemSpec, StringComparison.OrdinalIgnoreCase));
         }
 
-
         /// <summary>
         /// Consider this situation.
         ///
@@ -2206,7 +2197,6 @@ public void GatherVersions410DotNet()
             Assert.Equal("v00001.0", ((string)returnedVersions[14].RegistryKey));
         }
 
-
         [Fact]
         public void GatherVersions40255DotNet()
         {
@@ -2371,7 +2361,6 @@ private void RemoveAssemblyFoldersExTestConditionRegistryKey()
             }
         }
 
-
         /// <summary>
         /// CandidateAssemblyFiles are extra files passed in through the CandidateAssemblyFiles
         /// that should be considered for matching when search paths contains {CandidateAssemblyFiles}
@@ -2393,7 +2382,6 @@ public void CandidateAssemblyFiles()
             Assert.Equal(Path.Combine(s_myVersion20Path, "System.Xml.dll"), t.ResolvedFiles[0].ItemSpec);
         }
 
-
         /// <summary>
         /// Make sure three part version numbers put on the required target framework do not cause a problem.
         /// </summary>
@@ -2861,7 +2849,6 @@ public void DuplicateEntries()
                 Assert.Empty(errorFileNames); // "Expected no Error file names"
                 Assert.Single(remap);
 
-
                 AssemblyRemapping pair = remap.First<AssemblyRemapping>();
                 Assert.Equal("Remapped", pair.To.Name);
                 Assert.False(pair.To.Retargetable);
@@ -2974,7 +2961,6 @@ public void ToElementButNoFrom()
             }
         }
 
-
         /// <summary>
         /// If a relative file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}
         /// then try to resolve directly to that file name and make it a full path.
@@ -3012,7 +2998,6 @@ public void RawFileNameRelative()
             }
         }
 
-
         /// <summary>
         /// If a relative searchPath is passed in through the search path parameter
         /// then try to resolve the file but make sure it is a full name
@@ -3198,7 +3183,6 @@ public void Regress444793()
             );
         }
 
-
         /// <summary>
         /// If a file name is passed in through the Assemblies parameter and the search paths contains {RawFileName}
         /// then try to resolve directly to that file name.
@@ -3698,7 +3682,6 @@ public void ConflictGeneratesMessageReferencingAssemblyName()
             e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "D");
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -3787,7 +3770,6 @@ public void ConflictWithForeVersionPrimary()
             Assert.True(ContainsItem(t.ResolvedDependencyFiles, s_myLibraries_V2_GDllPath));
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -4002,7 +3984,6 @@ public void SpecificVersionAbsent()
             Assert.Empty(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// Unresolved primary references should result in warnings.
         /// </summary>
@@ -4029,7 +4010,6 @@ public void Regress199998()
             Assert.Equal(1, m.Warnings);
         }
 
-
         /// <summary>
         /// In this case,
         /// - A single primary file reference to simple name "A".
@@ -4267,7 +4247,6 @@ public void SimpleNameWithSpecificVersionFalse()
             Assert.True(ContainsItem(t.ResolvedFiles, @"c:\MyStronglyNamed\A.dll")); // "Expected to find assembly, but didn't."
         }
 
-
         /// <summary>
         /// Consider this situation:
         ///
@@ -4303,7 +4282,6 @@ public void IrrelevantAssemblyNameElement()
             Assert.True(ContainsItem(t.ResolvedFiles, s_myLibraries_V1_DDllPath)); // "Expected to find assembly, but didn't."
         }
 
-
         /// <summary>
         /// Regress EVERETT QFE 626
         /// Consider this dependency chain:
@@ -4359,7 +4337,7 @@ public void RegressQFE626()
 
             foreach (ITaskItem item in t.ResolvedDependencyFiles)
             {
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("false", item.GetMetadata("CopyLocal"));
                 }
@@ -4422,12 +4400,12 @@ public void Regress265054()
 
             foreach (ITaskItem item in t.ResolvedDependencyFiles)
             {
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("false", item.GetMetadata("CopyLocal"));
                 }
 
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("true", item.GetMetadata("CopyLocal"));
                 }
@@ -4520,13 +4498,10 @@ public void Regress275161_ScatterAssemblies()
 
             Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1."
 
-
             Assert.True(ContainsItem(t.ScatterFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2."
 
-
             Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m1.netmodule")); //                 "Expected to find scatter file m1 in CopyLocalFiles."
 
-
             Assert.True(ContainsItem(t.CopyLocalFiles, @"C:\Regress275161\m2.netmodule")); //                 "Expected to find scatter file m2 in CopyLocalFiles."
         }
 
@@ -4669,7 +4644,6 @@ public void Regress313086_Part2_MscorlibAsRawFilename()
             Assert.Single(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// If a directory path is passed into AssemblyFiles, then we should warn and continue on.
         /// </summary>
@@ -4748,7 +4722,6 @@ public void RelativeAssemblyFiles()
             }
         }
 
-
         /// <summary>
         /// Behave gracefully if a referenced assembly is inaccessible to the user.
         /// </summary>
@@ -4803,7 +4776,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryFileIsInaccessible(
             Assert.Single(t.ResolvedFiles);
         }
 
-
         /// <summary>
         /// Behave gracefully if a referenced assembly is inaccessible to the user.
         /// </summary>
@@ -4821,7 +4793,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryAsRawFileIsInaccess
             };
             t.SearchPaths = new string[] { "{RawFileName}" };
 
-
             Execute(t);
 
             Assert.Equal(1, e.Warnings); // "One warning expected in this scenario."
@@ -4829,8 +4800,6 @@ public void Regress316906_UnauthorizedAccessViolation_PrimaryAsRawFileIsInaccess
             Assert.Empty(t.ResolvedFiles);
         }
 
-
-
         /// <summary>
         /// If there's a SearhPath like {Registry:,,} then still behave nicely.
         /// </summary>
@@ -4903,7 +4872,6 @@ public void Regress276548_AssemblyNameDifferentThanFusionName()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "One warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Single(t.ResolvedFiles);
@@ -4945,13 +4913,11 @@ public void Regress314573_VeryLongPaths()
 
             Execute(t);
 
-
             Assert.Equal(1, e.Warnings); // "One warning expected in this scenario." // Couldn't find dependencies for {HintPathFromItem}-resolved item.
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Empty(t.ResolvedFiles);  // This test used to have 1 here. But that was because the mock GetAssemblyName was not accurately throwing an exception for non-existent files.
         }
 
-
         /// <summary>
         /// Need to be robust in the face of assembly names with special characters.
         /// </summary>
@@ -4974,7 +4940,6 @@ public void Regress265003_EscapedCharactersInFusionName()
             t.Assemblies[1].SetMetadata("HintPath", @"c:\MyEscapedName\__'ASP'dw0024ry.dll");
             t.TargetFrameworkDirectories = new string[] { Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName) };
 
-
             t.SearchPaths = new string[]
             {
                 @"{TargetFrameworkDirectory}",
@@ -4984,7 +4949,6 @@ public void Regress265003_EscapedCharactersInFusionName()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "One warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Equal(2, t.ResolvedFiles.Length);
@@ -5023,7 +4987,6 @@ public void Regress284081_UnescapedCharactersInFusionNameWithHintPath()
 
             Execute(t);
 
-
             Assert.Equal(0, e.Warnings); // "No warning expected in this scenario."
             Assert.Equal(0, e.Errors); // "No errors expected in this scenario."
             Assert.Single(t.ResolvedFiles);
@@ -5147,7 +5110,6 @@ public void Regress354669_HintPathWithTrailingSlash()
 
             t.Assemblies[0].SetMetadata("HintPath", @"C:\Regress354669\");
 
-
             t.SearchPaths = new string[]
             {
                 "{RawFileName}",
@@ -5240,7 +5202,6 @@ public void Regress_DogfoodCLRThrowsFileLoadException()
             Execute(t);
         }
 
-
         /// <summary>
         /// There was a bug in which any file mentioned in the InstalledAssemblyTables was automatically
         /// considered to be a file present in the framework directory. This assumption was originally true,
@@ -5312,7 +5273,6 @@ public void InvalidCharsInInstalledAssemblyTable()
                 new TaskItem("SomeAssembly")
             };
 
-
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
             t.InstalledAssemblyTables = new TaskItem[] { new TaskItem("asdfasdfasjr390rjfiogatg~~!@@##$%$%%^&**()") };
 
@@ -5349,7 +5309,6 @@ public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
 
             t.Assemblies[0].SetMetadata("HintPath", @"C:\Regress435487\microsoft.build.engine.dll");
 
-
             t.SearchPaths = new string[]
             {
                 @"{HintPathFromItem}",
@@ -5415,7 +5374,6 @@ public void PartialNameMatchingFromRedist()
                 AssemblyNameExtension Av2 = new AssemblyNameExtension(v2);
                 AssemblyNameExtension Av3 = new AssemblyNameExtension(v3);
 
-
                 AssemblyTableInfo assemblyTableInfo = new AssemblyTableInfo(redistFile, "MyFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { assemblyTableInfo });
                 InstalledAssemblies installedAssemblies = new InstalledAssemblies(redistList);
@@ -5611,7 +5569,6 @@ private static string CreateGenericRedistList()
             return tempFile;
         }
 
-
         [Fact]
         public void GetRedistListPathsFromDisk_ThrowsArgumentNullException()
         {
@@ -5661,7 +5618,6 @@ public void RedistListGenerateBlackListEmptyAssemblyInfoWithRedistAssemblies()
                 List<string> whiteListErrorFileNames = new List<string>();
                 Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[0], whiteListErrors, whiteListErrorFileNames);
 
-
                 // Since there were no white list expect the black list to return null
                 Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
             }
@@ -5768,8 +5724,6 @@ public void RedistListNoSubsetListName()
                    "</FileList >";
                 File.WriteAllText(subsetFile, subsetListContents);
 
-
-
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
@@ -5868,8 +5822,6 @@ public void RedistListDifferentNameToSubSet()
                    "</FileList >";
                 File.WriteAllText(subsetFile, subsetListContents);
 
-
-
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
@@ -5987,7 +5939,7 @@ public void RedistListNoAssembliesinRedistList()
         [Fact]
         public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         {
-            string redistFile = CreateGenericRedistList(); ;
+            string redistFile = CreateGenericRedistList(); 
             string goodSubsetFile = FileUtilities.GetTemporaryFile();
             try
             {
@@ -6240,7 +6192,6 @@ public void SubsetListFinderEmptySubsetToSearchFor()
             Assert.Empty(returnArray); // "Expected the array returned to be 0 length"
         }
 
-
         /// <summary>
         /// Verify that the method will not crash if there are empty string array elements
         /// </summary>
@@ -6554,7 +6505,6 @@ public void TestGenerateFrameworkName()
             installedSubSetTable = null;
             Assert.True(String.IsNullOrEmpty(ResolveAssemblyReference.GenerateSubSetName(null, installedSubSetTable)));
 
-
             targetFrameworks = new string[] { "Client", "Framework" };
             installedSubSetTable = new ITaskItem[] { new TaskItem("c:\\foo\\Mouse.xml"), new TaskItem("D:\\foo\\bar\\Man.xml") };
             Assert.Equal("Client, Framework, Mouse, Man", ResolveAssemblyReference.GenerateSubSetName(targetFrameworks, installedSubSetTable));
@@ -6638,7 +6588,6 @@ public void ReferenceTableDependentItemsInBlackList()
             VerifyReferenceTable(referenceTable, mockEngine, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, new string[] { warningMessage });
         }
 
-
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// and enginePrimary->sqlDependencyReference: sqlDependencyReference is in black list
@@ -6709,7 +6658,6 @@ public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
             xmlPrimaryReference.AddSourceItems(enginePrimaryReference.GetSourceItems());
             xmlPrimaryReference.AddDependee(enginePrimaryReference);
 
-
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, null, null, xmlAssemblyName, enginePrimaryReference, null, null, xmlPrimaryReference);
 
@@ -6753,7 +6701,6 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
             xmlPrimaryReference.AddSourceItems(enginePrimaryReference.GetSourceItems());
             xmlPrimaryReference.AddDependee(enginePrimaryReference);
 
-
             dataDependencyReference.FullPath = "FullPath";
             dataDependencyReference.MakeDependentAssemblyReference(xmlPrimaryReference);
 
@@ -6762,7 +6709,6 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
 
             InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { dataAssemblyName }, out blackList);
 
-
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem2.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6821,7 +6767,6 @@ public void ReferenceTableDependentItemsInBlackList3()
             VerifyReferenceTable(referenceTable, mockEngine, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, new string[] { warningMessage, warningMessage2 });
         }
 
-
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// and xmlPrimary->dataDependencyReference: sqlDependencyReference is in black list
@@ -6914,7 +6859,6 @@ public void ReferenceTableDependentItemsInBlackList5()
 
             InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out blackList);
 
-
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6936,7 +6880,6 @@ public void ReferenceTableDependentItemsInBlackList5()
             table.Clear();
         }
 
-
         /// <summary>
         /// Testing case
         /// enginePrimary -> dataDependencyReference   also enginePrimary->sqlDependencyReference   specific version = true on the primary
@@ -7191,7 +7134,6 @@ private void InitializeMockEngine(out ReferenceTable referenceTable, out MockEng
             referenceTable = MakeEmptyReferenceTable(rar.Log);
         }
 
-
         /// <summary>
         ///Initialize the black list and use it to remove references from the reference table
         /// </summary>
@@ -7477,7 +7419,6 @@ public void ResolveAssemblyReferenceVerifyFullClientName()
             }
         }
 
-
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
         /// black list is not used.
@@ -7513,7 +7454,6 @@ public void ResolveAssemblyReferenceVerifyFullClientNameWithSubsetTables()
             }
         }
 
-
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
         /// black list is not used.
@@ -7753,7 +7693,6 @@ public void Regress397129_HandleInvalidDirectoriesAndFiles_Case2()
 
             t.Assemblies[0].SetMetadata("HintPath", @"||invalidpath||");
 
-
             t.SearchPaths = new string[]
             {
                 @"{HintPathFromItem}"
@@ -7815,7 +7754,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions_Case1()
                 new TaskItem("A")
             };
 
-
             t.SearchPaths = new string[]
             {
                 @"C:\Regress393931"
@@ -7848,7 +7786,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions()
                 new TaskItem("A")
             };
 
-
             t.SearchPaths = new string[]
             {
                 @"C:\Regress393931"
@@ -7899,7 +7836,6 @@ public void SGenDependeicies()
             Assert.True(ContainsItem(t.SerializationAssemblyFiles, @"c:\SGenDependeicies\mycomponent2.XmlSerializers.dll")); // "Expected to find serialization assembly, but didn't."
         }
 
-
         /// <summary>
         /// Consider this dependency chain:
         ///
@@ -8049,7 +7985,7 @@ private int RunTargetFrameworkFilteringTest(string projectTargetFramework)
                 }
                 Assert.NotEqual(0, mask); // "Unexpected assembly in resolved list."
                 Assert.Equal(0, (mask & set)); // "Assembly found twice in resolved list."
-                set = set | mask;
+                set |= mask;
             }
             return set;
         }
@@ -8283,7 +8219,6 @@ public void VerifyAssemblyInRedistListDiffVersion()
             }
         }
 
-
         /// <summary>
         /// Verify when we ask if an assembly is in the redist list we get the right answer.
         /// The public key is significant and should make the match not work
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index 91fec5aa1a1..1f35cf0117a 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -76,7 +76,7 @@ public void DependeeDirectoryIsProbedForDependency()
                 bool succeeded = Execute(t);
 
                 Assert.True(succeeded);
-                ;
+                
                 uniqueFileExists[s_dependsOnNuGet_NWinMdPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NDllPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NExePath].ShouldBe(1);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 0ec77ad4895..5b2c9c4de6b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -322,7 +322,6 @@ internal void StopIOMonitoringAndAssert_Minimal_IOUse(int ioThreshold = 1)
                 }
             }
 
-
             uniqueFileExists = null;
             uniqueGetAssemblyName = null;
         }
@@ -344,7 +343,6 @@ internal void StopIOMonitoringAndAssert_Zero_IOUse()
                 }
             }
 
-
             // Check for zero IO in GetAssemblyName.
             foreach (var entry in uniqueGetAssemblyName)
             {
@@ -644,11 +642,11 @@ internal static string[] GetFiles(string path, string pattern)
             {
                 string baseDir = Path.GetDirectoryName(file);
 
-                if (0 == String.Compare(baseDir, path, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(baseDir, path, StringComparison.OrdinalIgnoreCase))
                 {
                     string fileExtension = Path.GetExtension(file);
 
-                    if (0 == String.Compare(fileExtension, extension, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(fileExtension, extension, StringComparison.OrdinalIgnoreCase))
                     {
                         matches.Add(file);
                     }
@@ -711,36 +709,36 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             imageRuntimeVersion = getAssemblyRuntimeVersion(fullPath);
             isManagedWinMD = false;
 
-            if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 isManagedWinMD = true;
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -748,7 +746,7 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -760,11 +758,11 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMDLib\LibWithWinmdAndNoDll.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMDLib\LibWithWinmdAndNoDll.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -838,10 +836,9 @@ internal static bool FileExists(string path)
                 {
                     uniqueFileExists[lowerPath] = 0;
                 }
-                
-                uniqueFileExists[lowerPath] = uniqueFileExists[lowerPath] + 1;
-            }
 
+                uniqueFileExists[lowerPath] += 1;
+            }
 
             // First, MyMissingAssembly doesn't exist anywhere.
             if (path.IndexOf("MyMissingAssembly") != -1)
@@ -854,16 +851,14 @@ internal static bool FileExists(string path)
                 path = Path.GetFullPath(path);
             }
 
-
             foreach (string file in s_existentFiles)
             {
-                if (0 == String.Compare(path, file, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(path, file, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
             }
 
-
             // Everything else doesn't exist.
             return false;
         }
@@ -885,7 +880,7 @@ internal static bool DirectoryExists(string path)
 
             foreach (string dir in existentDirs)
             {
-                if (0 == String.Compare(path, dir, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(path, dir, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
@@ -911,7 +906,7 @@ internal static string[] GetDirectories(string path, string pattern)
 
                 return paths;
             }
-            else if (String.Compare(path, @".", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @".", StringComparison.OrdinalIgnoreCase))
             {
                 // Pretend the current directory has a few subfolders.
                 return new string[] {
@@ -929,75 +924,74 @@ internal static string[] GetDirectories(string path, string pattern)
         /// <returns>Image runtime version</returns>
         internal static string GetRuntimeVersion(string path)
         {
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0, CLR V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleClrOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleClrOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "CLR V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleBadWindowsRuntime.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleBadWindowsRuntime.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "Windows Runtime";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndOther.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndOther.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0, Other V2.0.50727";
             }
-
-            else if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return "V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return "V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
@@ -1053,7 +1047,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, @"c:\OldClrBug\MyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, @"c:\OldClrBug\MyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase)
             )
             {
                 // An older LKG of the CLR could throw a FileLoadException if it doesn't recognize
@@ -1063,7 +1057,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib that returns null for its assembly name.
@@ -1072,7 +1066,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "BadImage.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "BadImage.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 throw new System.BadImageFormatException(@"The format of the file '" + Path.Combine(s_myVersion20Path, "BadImage.dll") + "' is invalid");
@@ -1080,9 +1074,9 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myProjectPath, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myProjectPath, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib.dll with no metadata.
@@ -1091,8 +1085,8 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib.dll with no metadata.
@@ -1104,129 +1098,129 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 throw new FileNotFoundException(path);
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo45Framework, Version=4.5.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo4Framework, Version=4.0.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo35Framework, Version=3.5.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, @"c:\Regress315619\A\MyAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress315619\A\MyAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyAssembly, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"c:\Regress315619\B\MyAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress315619\B\MyAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyAssembly, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress442570_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
-            if (String.Compare(path, @"c:\Regress387218\v1\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\v1\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\Regress387218\v2\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\v2\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"c:\Regress390219\v1\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\v1\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=fr, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\Regress390219\v2\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\v2\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=2.0.0.0, Culture=en, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyStronglyNamed\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyStronglyNamed\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyNameMismatch\Foo.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyNameMismatch\Foo.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyEscapedName\=A=.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyEscapedName\=A=.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("\\=A\\=, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089", true);
             }
 
-            if (String.Compare(path, @"c:\MyEscapedName\__'ASP'dw0024ry.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyEscapedName\__'ASP'dw0024ry.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("__\\'ASP\\'dw0024ry", true);
             }
 
-            if (String.Compare(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate an assembly that throws an UnauthorizedAccessException upon access.
                 throw new UnauthorizedAccessException();
             }
 
-            if (String.Compare(path, Path.Combine(Path.GetTempPath(), @"RawFileNameRelative\System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(Path.GetTempPath(), @"RawFileNameRelative\System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
-            if (String.Compare(path, Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles\System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles\System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
             // This is an assembly with an earlier version.
-            if (String.Compare(path, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
             // This is an assembly with an incorrect PKT.
-            if (String.Compare(path, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=A77a5c561934e089");
@@ -1238,19 +1232,19 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("MyGacAssembly, Version=9.2.3401.1, Culture=neutral, PublicKeyToken=a6694b450823df78");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=2.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=4.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=9.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
@@ -1258,7 +1252,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "System.Data.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // Simulate a strongly named assembly.
@@ -1281,70 +1275,66 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             {
                 return new AssemblyNameExtension("E, Version=0.0.0.0, Culture=neutral, PUBlicKeyToken=null");
             }
-
-
-            if (String.Compare(path, s_unifyMeDll_V05Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V05Path, StringComparison.OrdinalIgnoreCase))
             {
                 throw new FileNotFoundException();
             }
 
-            if (String.Compare(path, s_unifyMeDll_V10Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V10Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=1.0.0.0, Culture=nEUtral, PublicKeyToken=b77a5c561934e089, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Framework\Everett\System.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Framework\Everett\System.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("System, Version=1.0.5000.0, Culture=neutral, PublICKeyToken=" + AssemblyRef.EcmaPublicKey);
             }
 
-            if (String.Compare(path, @"C:\Framework\Whidbey\System.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Framework\Whidbey\System.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=" + AssemblyRef.EcmaPublicKey);
             }
-
-
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnEverettSystem, VersION=1.0.5000.0, Culture=neutral, PublicKeyToken=feedbeadbadcadbe");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, Version=0.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderA\C.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderA\C.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("C, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderB\C.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderB\C.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, VERSion=1.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, VeRSIon=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, Version=3.0.0.0, Culture=neutral, PublicKEYToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_unifyMeDll_V20Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V20Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=2.0.0.0, Culture=neutral, PublicKeyTOKEn=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_unifyMeDll_V30Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V30Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=3.0.0.0, Culture=neutral, PublICkeyToken=b77a5c561934e089");
             }
@@ -1364,417 +1354,417 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("G, Version=2.0.0.0, Culture=neutral, PublicKEyToken=aaaaaaaaaaaaaaaa");
             }
 
-            if (String.Compare(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress317975\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress317975\v2\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\v2\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
             // Set up assembly names for testing target framework version checks
             // Is version 4 and will only depends on 4.0 assemblies
-            if (String.Compare(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnOnlyv4Assemblies, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             // Is version 9 and will not have any dependencies, will be in the redist list
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("ReferenceVersion9, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             // Is a third party assembly which depends on a version 9 assembly
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             //A second assembly which depends on version 9 framework assemblies.
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9Also, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, s_regress444809_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_V2_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_V2_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\MSIL\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\MSIL\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress714052\X86\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\X86\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\b.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\b.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
-            if (String.Compare(path, @"C:\Regress714052\MSIL\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\MSIL\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
-            if (String.Compare(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("V, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("W, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("X, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Z, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Y, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Microsoft.Build, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnMSBuild12, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\v4\MsCorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\v4\MsCorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("mscorlib, Version=4.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\WinMD\v255\MsCorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\v255\MsCorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("mscorlib, Version=255.255.255.255, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DotNetAssemblyDependsOnWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DotNetAssemblyDependsOn255WinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnInvalidPeHeader.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnInvalidPeHeader.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnInvalidPeHeader, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnAmd64.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnAmd64.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnAmd64, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnArm.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnArm.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnArm, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnIA64.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnIA64.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnIA64, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnArmv7.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnArmv7.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnArmv7, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnX86.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnX86.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnX86, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnUnknown.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnUnknown.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnUnknown, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnAnyCPUUnknown.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnAnyCPUUnknown.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnAnyCPUUnknown, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("WinMDWithVersion255, Version=255.255.255.255");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly2, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly3, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly4, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeReferencingSystem, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeReferencingSystemDNE, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeAndCLR, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents2\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents2\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=2.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponent7s\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponent7s\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents9\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents9\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponentsVv1\MyGridWinMD2.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponentsVv1\MyGridWinMD2.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD2, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponentsV1\MyGridWinMD3.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponentsV1\MyGridWinMD3.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD3, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugX86SDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugNeutralSDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("X86SDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("NeutralSDKWINMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("Debugx86SDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugNeutralSDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("X86SDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("NeutralSDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\SDKReference.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\SDKReference.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SDKReference, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("b, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder_x64\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder_x64\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("assemblyfromconfig_common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=AMD64");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder_x86\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder_x86\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("assemblyfromconfig_common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder5010x64\v5assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder5010x64\v5assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("v5assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=AMD64");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder501000x86\v5assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder501000x86\v5assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("v5assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
 
-            if (string.Compare(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (string.Compare(path, s_nugetCache_N_Lib_NDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, s_nugetCache_N_Lib_NDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("N, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
@@ -1783,7 +1773,6 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             return new AssemblyNameExtension(defaultName);
         }
 
-
         /// <summary>
         /// Cached implementation. Given an assembly name, crack it open and retrieve the list of dependent
         /// assemblies and  the list of scatter files.
@@ -1861,7 +1850,7 @@ string path
         /// <returns>The array of dependent assembly names.</returns>
         internal static AssemblyNameExtension[] GetDependencies(string path)
         {
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1869,7 +1858,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1877,7 +1866,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1885,7 +1874,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress454863_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress454863_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1893,7 +1882,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1901,7 +1890,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1909,7 +1898,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1917,7 +1906,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress387218\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1925,7 +1914,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress387218\B.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\B.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1933,7 +1922,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress390219\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1941,7 +1930,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress390219\B.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\B.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1949,7 +1938,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1957,7 +1946,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1965,7 +1954,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1973,7 +1962,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\OldClrBug\DependsMyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\OldClrBug\DependsMyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1981,7 +1970,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress563286\DependsOnBadImage.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress563286\DependsOnBadImage.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1989,17 +1978,17 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 throw new UnauthorizedAccessException();
             }
 
-            if (String.Compare(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2007,7 +1996,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2015,7 +2004,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2023,7 +2012,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndClr.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndClr.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                  {
@@ -2031,7 +2020,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                  };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                  {
@@ -2039,7 +2028,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                  };
             }
 
-            if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2047,7 +2036,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2055,7 +2044,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2066,7 +2055,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2075,7 +2064,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2084,7 +2073,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2095,8 +2084,8 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 return new AssemblyNameExtension[]
@@ -2104,14 +2093,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"MyRelativeAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"MyRelativeAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myAppRootPath, "DependsOnSimpleA.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myAppRootPath, "DependsOnSimpleA.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2119,7 +2108,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress312873\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress312873\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2127,7 +2116,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderA\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderA\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2135,7 +2124,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderB\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderB\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2143,7 +2132,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2151,7 +2140,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\myassemblies\My.Assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\myassemblies\My.Assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2159,7 +2148,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "MyGrid.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "MyGrid.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2167,16 +2156,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\MyRawDropControls\MyRawDropControl.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyRawDropControls\MyRawDropControl.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                     new AssemblyNameExtension("mscorlib, VeRsIon=2.0.0.0, Culture=neuTRal, PublicKeyToken=b77a5c561934e089")
                 };
             }
-
-
-            if (String.Compare(path, s_myLibraries_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2184,7 +2171,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_TDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_TDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2192,7 +2179,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2201,7 +2188,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2209,7 +2196,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V2_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V2_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2217,14 +2204,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnWeaklyNamedUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnWeaklyNamedUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2232,7 +2219,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2240,7 +2227,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2248,7 +2235,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2256,7 +2243,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2264,7 +2251,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2272,14 +2259,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myMissingAssemblyAbsPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myMissingAssemblyAbsPath, StringComparison.OrdinalIgnoreCase))
             {
                 throw new FileNotFoundException(path);
             }
 
             // Set up assembly names for testing target framework version checks
             // Is version 4 and will only depends on 4.0 assemblies
-            if (String.Compare(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2288,7 +2275,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             // Is version 9 and will not have any dependencies, will be in the redist list
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2298,7 +2285,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             // Is a third party assembly which depends on a version 9 assembly
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2308,7 +2295,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             //A second assembly which depends on version 9 framework assemblies.
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2316,7 +2303,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2324,7 +2311,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2332,7 +2319,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2341,7 +2328,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2349,7 +2336,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2357,7 +2344,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2365,12 +2352,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2378,12 +2365,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2391,12 +2378,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2404,7 +2391,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2413,7 +2400,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2422,7 +2409,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2431,7 +2418,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2440,7 +2427,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2449,13 +2436,13 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[0];
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2464,7 +2451,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[0];
             }
@@ -2474,7 +2461,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 return new AssemblyNameExtension[0];
             }
 
-            if (String.Compare(path, s_portableDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_portableDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a portable assembly with a reference to System.Runtime
                 return new AssemblyNameExtension[]
@@ -2483,7 +2470,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_netstandardLibraryDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_netstandardLibraryDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a .NET Standard assembly
                 return new AssemblyNameExtension[]
@@ -2492,7 +2479,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2536,89 +2523,89 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (String.Compare(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "", "vBogusVersion", "v1.a.2.3", "v1.0", "v3.0", "v2.0.50727", "v2.0.x86chk", "RandomJunk" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "ZControlA", "ZControlB", "Infragistics.GridControl.1.0", "Infragistics.MyHKLMControl.1.0", "Infragistics.MyControlWithFutureTargetNDPVersion.1.0", "Infragistics.MyControlWithPastTargetNDPVersion.1.0", "Infragistics.MyControlWithServicePack.1.0" };
                 }
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "RawDropControls" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.MyControlWithFutureTargetNDPVersion.1.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.MyNDP1Control.1.0", "Infragistics.MyControlWithPastTargetNDPVersion.1.0" };
                 }
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return new string[] { };
@@ -2626,39 +2613,39 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     // This control has a service pack
                     return new string[] { "sp1", "sp2" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.3600" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "PocketPC" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "AFETestDeviceControl" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "1234" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Windows" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "7.0", "8.0", "v8.0", "9.0" };
                 }
@@ -2666,105 +2653,105 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (String.Compare(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "A", "B" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "X86" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "MSIL" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "None" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Mix" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "vBogusVersion", "v2.0.50727" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.FancyControl.1.0", "Infragistics.MyHKLMControl.1.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.3600" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "PocketPC" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "8.0" };
                 }
@@ -2785,41 +2772,41 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponentsA";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponentsB";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyRawDropControls";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKCU Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return s_myComponentsV30Path;
                 }
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return s_myComponentsV20Path;
@@ -2827,7 +2814,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentBase";
@@ -2835,7 +2822,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp1", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp1", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentServicePack1";
@@ -2843,7 +2830,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp2", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp2", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentServicePack2";
@@ -2851,18 +2838,18 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return s_myComponentsV10Path;
                 }
 
-                if (String.Compare(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\V1Control";
                 }
-                if (String.Compare(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl\1234", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl\1234", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\V1ControlSP1";
                 }
@@ -2870,44 +2857,44 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKLM Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKLM Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\X86";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\X86";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\Mix";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\None";
                 }
@@ -2957,7 +2944,7 @@ protected static bool ContainsItem(ITaskItem[] items, string spec)
         {
             foreach (ITaskItem item in items)
             {
-                if (0 == String.Compare(item.ItemSpec, spec, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, spec, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index f21876d03c3..d9daab826d4 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -114,7 +114,7 @@ public void HighVersionDoesntExist()
 
             t.BuildEngine = engine;
             t.Assemblies = assemblyNames;
-                t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" }; ;
+                t.SearchPaths = new string[] { s_myApp_V10Path, @"C:\Framework\Everett" }; 
 
             bool succeeded = Execute(t);
 
diff --git a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
index 349ae0014ca..c1de8787f55 100644
--- a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
+++ b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
@@ -49,7 +49,7 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
                 (resolvedProjectWithConfiguration == null) ? string.Empty : resolvedProjectWithConfiguration.GetMetadata("FullConfiguration"));
 
             Assert.Equal(expectedResult, result);
-            if (result == true)
+            if (result)
             {
                 Assert.Equal(expectedFullConfiguration, resolvedProjectWithConfiguration.GetMetadata("FullConfiguration"));
                 Assert.Equal(expectedConfiguration, resolvedProjectWithConfiguration.GetMetadata("Configuration"));
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 72e60aa3539..8d0a7300c85 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -223,7 +223,6 @@ public void EmptyLanguage()
             mockLogger.AssertLogContains(String.Format(unformattedMessage, "Language"));
         }
 
-
         /// <summary>
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
@@ -509,7 +508,7 @@ public void BuildTaskSimpleCodeFactoryTestExtraUsing()
                     </Project>";
 
             MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
-            string linqString = System.Linq.Expressions.ExpressionType.Add.ToString();
+            string linqString = nameof(System.Linq.Expressions.ExpressionType.Add);
             mockLogger.AssertLogContains(linqString + ":Hello, World!");
         }
 
@@ -539,7 +538,6 @@ public void BuildTaskDateCodeFactory()
                         </Target>
                     </Project>";
 
-
             MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
             mockLogger.AssertLogContains("Current Date and Time:");
             mockLogger.AssertLogDoesntContain("[[]]");
@@ -876,7 +874,6 @@ public bool Execute()
             mockLogger.AssertLogContains(unformattedMessage);
         }
 
-
         /// <summary>
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index bf3e66cb713..c807d9c934c 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -175,10 +175,10 @@ bool useResponseFile
                     // Skip anything shorter than the compare string.
                     continue;
                 }
-                if (String.Compare(s.Substring(0, startsWith.Length), startsWith, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(s.Substring(0, startsWith.Length), startsWith, StringComparison.OrdinalIgnoreCase))
                 {
                     // If this doesn't match the 'except' then this is an error.
-                    if (String.Compare(s, except, StringComparison.Ordinal) != 0)
+                    if (!String.Equals(s, except, StringComparison.Ordinal))
                     {
                         msg += String.Format(" Found something!\r\n");
                         Console.WriteLine(msg);
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 69c943c4551..2114a8f4fac 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -40,16 +40,16 @@ public bool UseSingleThreadedCopy
         private int _parallelismThreadCount = DefaultParallelismThreadCount;
 
         /// <summary>
-        /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run 
+        /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
-        /// once we're done. 
+        /// once we're done.
         /// </summary>
         private readonly string _alwaysOverwriteReadOnlyFiles;
 
         /// <summary>
-        /// Temporarily save off the value of MSBUILDALWAYSRETRY, so that we can run 
+        /// Temporarily save off the value of MSBUILDALWAYSRETRY, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
-        /// once we're done. 
+        /// once we're done.
         /// </summary>
         private readonly string _alwaysRetry;
 
@@ -57,7 +57,7 @@ public bool UseSingleThreadedCopy
 
         /// <summary>
         /// There are a couple of environment variables that can affect the operation of the Copy
-        /// task.  Make sure none of them are set. 
+        /// task.  Make sure none of them are set.
         /// </summary>
         public Copy_Tests(ITestOutputHelper testOutputHelper)
         {
@@ -72,7 +72,7 @@ public Copy_Tests(ITestOutputHelper testOutputHelper)
         }
 
         /// <summary>
-        /// Restore the environment variables we cleared out at the beginning of the test. 
+        /// Restore the environment variables we cleared out at the beginning of the test.
         /// </summary>
         public void Dispose()
         {
@@ -189,7 +189,7 @@ public void DoNotNormallyCopyOverReadOnlyFile()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when 
+        /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when
         /// OverwriteReadOnlyFiles is false
         /// </summary>
         [Fact]
@@ -256,7 +256,7 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSRETRY is set, keep retrying the copy. 
+        /// If MSBUILDALWAYSRETRY is set, keep retrying the copy.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -1011,7 +1011,7 @@ internal class CopyMonitor
         }
 
         /// <summary>
-        /// CopiedFiles should only include files that were successfully copied 
+        /// CopiedFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [Fact]
@@ -1547,7 +1547,7 @@ public void CopyWithDuplicatesUsingFiles()
         }
 
         /// <summary>
-        /// DestinationFiles should only include files that were successfully copied 
+        /// DestinationFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [Fact]
@@ -1604,7 +1604,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
 
         /// <summary>
         /// If the destination path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
@@ -1648,7 +1648,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
 
         /// <summary>
         /// If the source path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
@@ -1769,7 +1769,7 @@ public void FailureWithNoRetries()
                 UseHardlinksIfPossible = UseHardLinks,
                 UseSymboliclinksIfPossible = UseSymbolicLinks,
             };
-            
+
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
             bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
 
@@ -1813,7 +1813,7 @@ public void DefaultNoHardlink()
             {
                 RetryDelayMilliseconds = 1,  // speed up tests!
             };
-            
+
             Assert.False(t.UseHardlinksIfPossible);
         }
 
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 363cc04a965..9a77edb3002 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -16,7 +16,6 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateCSharpManifestResourceName_Tests
     {
-
         private readonly ITestOutputHelper _testOutput;
 
         public CreateCSharpManifestResourceName_Tests(ITestOutputHelper output)
@@ -82,7 +81,6 @@ public void Regress172107()
                     null
                 );
 
-
             MemoryStream m = new MemoryStream();
             m.Write(new byte[] { 0x64, 0xc3, 0x61, 0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73 }, 0, 9); // dÃa.Class in ANSI
             m.Flush();
@@ -97,8 +95,6 @@ public void Regress172107()
             Assert.Equal(className, result);
         }
 
-
-
         /// <summary>
         /// Test for a namespace that has UTF8 characters but there's no BOM at the start.
         ///
@@ -456,7 +452,6 @@ public void DependentUponConvention_DoesNotApplyToNonResx(bool explicitlySpecify
             }
         }
 
-
         /// <summary>
         /// Opt into DependentUpon convention and load the expected file properly when the file is in a subfolder.
         /// </summary>
@@ -796,7 +791,7 @@ class MyForm
         /// <returns>The Stream</returns>
         private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
         {
-            if (String.Compare(path, "SR1.strings", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, "SR1.strings", StringComparison.OrdinalIgnoreCase))
             {
                 return StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }");
             }
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index aac9f57f6c6..ce70c6c1a2f 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -16,7 +16,6 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateVisualBasicManifestResourceName_Tests
     {
-
         private readonly ITestOutputHelper _testOutput;
 
         public CreateVisualBasicManifestResourceName_Tests(ITestOutputHelper output)
@@ -411,7 +410,7 @@ End Class
         /// <returns>The Stream</returns>
         private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
         {
-            if (String.Compare(path, "SR1.strings", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, "SR1.strings", StringComparison.OrdinalIgnoreCase))
             {
                 return StreamHelpers.StringToStream(
 @"
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index f8375e81d89..03a50d12ec5 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -328,7 +328,6 @@ public void TestGeneralFrameworkMonikerGoodWithFrameworkInFallbackPaths()
                 Assert.Equal(".NET Framework 4.1", displayName);
             }
         }
-
     }
 }
 #endif
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 52973541190..05200fcfac9 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -404,7 +404,6 @@ static void Main(string[] args)
                 }
                 ");
 
-
             // -------------------------------------------------------
             // TeamBuild.proj
             // -------------------------------------------------------
@@ -550,7 +549,6 @@ public void DifferentGlobalPropertiesWithoutDefault()
             }
         }
 
-
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
@@ -606,7 +604,6 @@ public void DifferentGlobalPropertiesWithBlanks()
             }
         }
 
-
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
@@ -711,7 +708,6 @@ public void DifferentAdditionalPropertiesWithDefault()
             }
         }
 
-
         /// <summary>
         /// Check if passing additional global properties via metadata works
         /// </summary>
@@ -770,7 +766,6 @@ public void DifferentAdditionalPropertiesWithGlobalProperties()
             }
         }
 
-
         /// <summary>
         /// Check if passing additional global properties via metadata works
         /// </summary>
@@ -1433,7 +1428,7 @@ public void MSBuildTaskPassesTaskIdToSpawnedBuilds()
 
                 var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == "MSBuild").BuildEventContext.TaskId;
                 var actualTaskId = logger.ProjectStartedEvents
-                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .Where(p => p.ParentProjectBuildEventContext?.TaskId > 0)
                     .First()
                     .ParentProjectBuildEventContext.TaskId;
 
@@ -1469,7 +1464,7 @@ public void CustomTaskWithBuildProjectFilePassesTaskId()
 
                 var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == nameof(BuildProjectFileTask)).BuildEventContext.TaskId;
                 var actualTaskId = logger.ProjectStartedEvents
-                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .Where(p => p.ParentProjectBuildEventContext?.TaskId > 0)
                     .First()
                     .ParentProjectBuildEventContext.TaskId;
 
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index c5a56f24f1e..298548b0fbf 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -29,7 +29,7 @@ public void BasicMove()
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
                     sw.Write("This is a source temp file.");
                 FileInfo file = new FileInfo(sourceFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -71,7 +71,7 @@ public void BasicMoveOverwriteReadOnlyFilesTrue()
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
                     sw.Write("This is a source temp file.");
                 FileInfo file = new FileInfo(sourceFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -98,7 +98,7 @@ public void BasicMoveOverwriteReadOnlyFilesTrue()
                 if (File.Exists(sourceFile))
                 {
                     FileInfo file = new FileInfo(sourceFile);
-                    file.Attributes = file.Attributes & ~FileAttributes.ReadOnly; // mark read only
+                    file.Attributes &= ~FileAttributes.ReadOnly; // mark read only
                     File.Delete(sourceFile);
                 }
 
@@ -206,7 +206,7 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark destination read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark destination read only
 
                 Move t = new Move();
                 t.BuildEngine = new MockEngine(true /* log to console */);
@@ -230,7 +230,7 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
                 File.Delete(sourceFile);
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes ^ FileAttributes.ReadOnly; // mark destination writable only
+                file.Attributes ^= FileAttributes.ReadOnly; // mark destination writable only
                 File.Delete(destinationFile);
             }
         }
@@ -301,7 +301,7 @@ public void MoveOverExistingFileOverwriteReadOnly()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes & ~FileAttributes.ReadOnly; // mark not read only
+                file.Attributes &= ~FileAttributes.ReadOnly; // mark not read only
 
                 Move t = new Move();
                 t.OverwriteReadOnlyFiles = true;
@@ -349,7 +349,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 Move t = new Move();
                 t.OverwriteReadOnlyFiles = true;
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 41bedd6cf66..51c2397ccac 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -218,7 +218,7 @@ public void CheckTaskItemToTypeLibAttr()
         }
 
         /// <summary>
-        /// Helper function for creating a ComReferenceInfo object using an existing TaskInfo object and 
+        /// Helper function for creating a ComReferenceInfo object using an existing TaskInfo object and
         /// typelib name/path. The type lib pointer will obviously not be initialized, so this object cannot
         /// be used in any code that uses it.
         /// </summary>
@@ -293,45 +293,45 @@ public void CheckIsExistingProjectReference()
 
             // find the Ax ref, matching with any type of reference - should NOT find it
             bool retValue = rcr.IsExistingProjectReference(axAttr, null, out ComReferenceInfo referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "ActiveX ref should NOT be found for any type of ref"
+            Assert.True(!retValue && referenceInfo == null); // "ActiveX ref should NOT be found for any type of ref"
 
             // find the Ax ref, matching with aximp types - should find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.aximp, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == axRefInfo); // "ActiveX ref should be found for aximp ref types"
+            Assert.True(retValue && referenceInfo == axRefInfo); // "ActiveX ref should be found for aximp ref types"
 
             // find the Ax ref, matching with tlbimp types - should NOT find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.tlbimp, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "ActiveX ref should NOT be found for tlbimp ref types"
+            Assert.True(!retValue && referenceInfo == null); // "ActiveX ref should NOT be found for tlbimp ref types"
 
 
             // find the Tlb ref, matching with any type of reference - should find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, null, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found for any type of ref"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found for any type of ref"
 
             // find the Tlb ref, matching with tlbimp types - should find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, ComReferenceTypes.tlbimp, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found for tlbimp ref types"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found for tlbimp ref types"
 
             // find the Tlb ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, ComReferenceTypes.primary, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "Tlb ref should NOT be found for primary ref types"
+            Assert.True(!retValue && referenceInfo == null); // "Tlb ref should NOT be found for primary ref types"
 
 
             // find the Pia ref, matching with any type of reference - should find it
             retValue = rcr.IsExistingProjectReference(piaAttr, null, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found for any type of ref"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found for any type of ref"
 
             // find the Pia ref, matching with pia types - should find it
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.primary, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found for pia ref types"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found for pia ref types"
 
             // find the Pia ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.aximp, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "Pia ref should NOT be found for aximp ref types"
+            Assert.True(!retValue && referenceInfo == null); // "Pia ref should NOT be found for aximp ref types"
 
             // try to find a non existing reference
             retValue = rcr.IsExistingProjectReference(notInProjectAttr, null, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "not in project ref should not be found"
+            Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
         }
 
         /// <summary>
@@ -356,19 +356,19 @@ public void CheckIsExistingDependencyReference()
 
             // find the Ax ref - should find it
             bool retValue = rcr.IsExistingDependencyReference(axAttr, out ComReferenceInfo referenceInfo);
-            Assert.True(retValue == true && referenceInfo == axRefInfo); // "ActiveX ref should be found"
+            Assert.True(retValue && referenceInfo == axRefInfo); // "ActiveX ref should be found"
 
             // find the Tlb ref - should find it
             retValue = rcr.IsExistingDependencyReference(tlbAttr, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == tlbRefInfo); // "Tlb ref should be found"
+            Assert.True(retValue && referenceInfo == tlbRefInfo); // "Tlb ref should be found"
 
             // find the Pia ref - should find it
             retValue = rcr.IsExistingDependencyReference(piaAttr, out referenceInfo);
-            Assert.True(retValue == true && referenceInfo == piaRefInfo); // "Pia ref should be found"
+            Assert.True(retValue && referenceInfo == piaRefInfo); // "Pia ref should be found"
 
             // try to find a non existing reference - should not find it
             retValue = rcr.IsExistingDependencyReference(notInProjectAttr, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "not in project ref should not be found"
+            Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
 
             // Now, try to resolve a non-existent ComAssemblyReference. 
             string path;
@@ -378,7 +378,7 @@ public void CheckIsExistingDependencyReference()
         }
 
         /// <summary>
-        /// ResolveComReference automatically adds missing tlbimp references for aximp references. 
+        /// ResolveComReference automatically adds missing tlbimp references for aximp references.
         /// This test verifies we actually create the missing references.
         /// </summary>
         [Fact]
@@ -646,10 +646,10 @@ public void TestCheckForConflictingReferences()
 
         /// <summary>
         /// In order to make ResolveComReferences multitargetable, two properties, ExecuteAsTool
-        /// and SdkToolsPath were added.  In order to have correct behavior when using pre-4.0 
+        /// and SdkToolsPath were added.  In order to have correct behavior when using pre-4.0
         /// toolsversions, ExecuteAsTool must default to true, and the paths to the tools will be the
-        /// v3.5 path.  It is difficult to verify the tool paths in a unit test, however, so 
-        /// this was done by ad hoc testing and will be maintained by the dev suites.  
+        /// v3.5 path.  It is difficult to verify the tool paths in a unit test, however, so
+        /// this was done by ad hoc testing and will be maintained by the dev suites.
         /// </summary>
         [Fact]
         public void MultiTargetingDefaultSetCorrectly()
@@ -662,7 +662,7 @@ public void MultiTargetingDefaultSetCorrectly()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWCreateTlb()
@@ -673,7 +673,7 @@ public void AxReferenceKnowsItsRCWCreateTlb()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWCreateTlb_IncludeVersion()
@@ -684,7 +684,7 @@ public void AxReferenceKnowsItsRCWCreateTlb_IncludeVersion()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWTlbExists()
@@ -695,7 +695,7 @@ public void AxReferenceKnowsItsRCWTlbExists()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         ///
         /// Tests that still works when IncludeVersionInInteropName = true
         /// </summary>
@@ -708,7 +708,7 @@ public void AxReferenceKnowsItsRCWTlbExists_IncludeVersion()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWPiaExists()
@@ -719,7 +719,7 @@ public void AxReferenceKnowsItsRCWPiaExists()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         ///
         /// Tests that still works when IncludeVersionInInteropName = true
         /// </summary>
@@ -732,8 +732,8 @@ public void AxReferenceKnowsItsRCWPiaExists_IncludeVersion()
         private enum RcwStyle { GenerateTlb, PreexistingTlb, PreexistingPia };
 
         /// <summary>
-        /// Helper method that will new up an AX and matching TLB reference, and verify that the AX reference 
-        /// sets its RCW appropriately. 
+        /// Helper method that will new up an AX and matching TLB reference, and verify that the AX reference
+        /// sets its RCW appropriately.
         /// </summary>
         private void CheckAxReferenceRCWTlbExists(RcwStyle rcwStyle, bool includeVersionInInteropName)
         {
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index 5e3385a4c34..eaca84dcc98 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -55,7 +55,7 @@ private void TestVerifyReferenceAttributesHelper(string itemSpec, string project
                 expectedMissingAttribute, missingAttr);
 
             Assert.Equal(result, expectedResult);
-            if (result == false)
+            if (!result)
             {
                 Assert.Equal(missingAttr, expectedMissingAttribute);
             }
@@ -107,7 +107,7 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
                 itemSpec, projectGuid, package, name, xmlString, expectedResult, result, expectedPath, resolvedPath);
 
             Assert.Equal(result, expectedResult);
-            if (result == true)
+            if (result)
             {
                 Assert.Equal(resolvedPath.ItemSpec, expectedPath);
             }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 307649ce8b6..6b859de116a 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -626,8 +626,8 @@ public void NothingOutOfDateExceptAdditionalInput()
             {
                 if (resxFile != null) File.Delete(resxFile);
                 if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs != null && additionalInputs[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs != null && additionalInputs[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
             }
         }
 
@@ -1511,7 +1511,7 @@ public void InvalidReference()
                 Assert.False(result);
 
                 // Should have not written any files
-                Assert.True(t.FilesWritten != null && t.FilesWritten.Length == 0);
+                Assert.True(t.FilesWritten?.Length == 0);
                 Assert.False(File.Exists(resourcesFile));
             }
             finally
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index b3c46b3889b..69c6556db0f 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -364,7 +364,6 @@ public void ForceOutOfDateByDeletion()
             Utilities.AssertLogContainsResource(t2, "GenerateResource.ResourceNotFound", t2.Sources[0].ItemSpec);
         }
 
-
         /// <summary>
         ///  Force out-of-date with ShouldRebuildResgenOutputFile on the linked file
         /// </summary>
@@ -803,7 +802,6 @@ public void NothingOutOfDateExceptReference()
 
                 File.GetLastWriteTime(incrementalUpToDate.OutputResources[0].ItemSpec).ShouldBe(firstWriteTime);
 
-
                 _output.WriteLine("** Touch the reference, and repeat, it should now rebuild");
                 DateTime newTime = DateTime.Now + new TimeSpan(0, 1, 0);
                 File.SetLastWriteTime(localSystemDll, newTime);
@@ -890,8 +888,8 @@ public void NothingOutOfDateExceptAdditionalInput()
             {
                 if (resxFile != null) File.Delete(resxFile);
                 if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs != null && additionalInputs[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs != null && additionalInputs[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
             }
         }
 
@@ -1455,7 +1453,6 @@ public void StronglyTypedResourcesEmitTypeIntoClass()
                 generatedSource.ShouldNotContain("object MyString", "Strongly-typed resource accessor is returning type `object` instead of `string`");
                 generatedSource.ShouldContain("static string MyString");
                 generatedSource.ShouldMatch("//.*Looks up a localized string similar to MyValue", "Couldn't find a comment in the usual format for a string resource.");
-
             }
             finally
             {
@@ -1471,7 +1468,6 @@ public void StronglyTypedResourcesEmitTypeIntoClass()
             }
         }
 
-
         /// <summary>
         ///  STR with resource namespace yields proper output, message (CS)
         /// </summary>
@@ -1882,7 +1878,7 @@ public void InvalidReference()
                 Assert.False(result);
 
                 // Should have not written any files
-                Assert.True(t.FilesWritten != null && t.FilesWritten.Length == 0);
+                Assert.True(t.FilesWritten?.Length == 0);
                 Assert.False(File.Exists(resourcesFile));
             }
             finally
@@ -3315,7 +3311,6 @@ public void ResxValueNewlines(string newline)
             }
             finally
             {
-
                 File.Delete(t.Sources[0].ItemSpec);
                 foreach (ITaskItem item in t.FilesWritten)
                 {
@@ -3373,7 +3368,6 @@ GenerateResource ExecuteTask()
                 Utilities.FileUpdated(resourcesFile, initialWriteTime).ShouldBeFalse();
             }
         }
-
     }
 }
 
@@ -3498,7 +3492,7 @@ public static void ExecuteTask(GenerateResource t)
             bool success = t.Execute();
             Assert.True(success);
 
-            if (t.OutputResources != null && t.OutputResources[0] != null && t.Sources[0] != null)
+            if (t.OutputResources?[0] != null && t.Sources[0] != null)
             {
                 File.GetLastWriteTime(t.OutputResources[0].ItemSpec).ShouldBeGreaterThanOrEqualTo(File.GetLastWriteTime(t.Sources[0].ItemSpec), $"we're talking here about {t.OutputResources[0].ItemSpec} and {t.Sources[0].ItemSpec}");
             }
@@ -3890,7 +3884,6 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
                     Assert.Contains("namespace " + classNamespace.ToLower(), Utilities.ReadFileContent(STRFile).ToLower());
                 }
 
-
                 // Verify log is as expected
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ProcessingFile", textFile, resourcesFile);
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ReadResourceMessage", 4, textFile);
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
index 3bf41699346..62414fb64cf 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
@@ -139,6 +139,5 @@ read any of the formats listed below.
 
         private const string FinalBoilerplate = @"</root>
 ";
-
     }
 }
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index d2756b09680..96ccee06a50 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -155,6 +155,5 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
                 base.AddResponseFileCommands(commandLine);
             }
         }
-
     }
 }
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 7e96b14814a..ab6b6c95d2b 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -12,7 +12,6 @@
 
 namespace Microsoft.Build.Tasks.UnitTests
 {
-
     public sealed class WriteLinesToFile_Tests
     {
         private readonly ITestOutputHelper _output;
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 9aaecf85ef9..a4e0fb53426 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -527,7 +527,7 @@ public void CompiledDllWithType()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlContent = _xmlDocument;
-                xslCompiledPath.ItemSpec = xslCompiledPath.ItemSpec + ";xslt";
+                xslCompiledPath.ItemSpec += ";xslt";
                 t.XslCompiledDllPath = xslCompiledPath;
                 Assert.Equal(xslCompiledPath.ItemSpec, t.XslCompiledDllPath.ItemSpec);
                 Assert.True(t.Execute()); // "XsltComiledDll1 execution should've passed"
@@ -648,7 +648,7 @@ public void MissingXmlFile()
                 XslTransformation t = new XslTransformation();
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
-                xmlPaths[0].ItemSpec = xmlPaths[0].ItemSpec + "bad";
+                xmlPaths[0].ItemSpec += "bad";
                 t.XmlInputPaths = xmlPaths;
                 t.XslInputPath = xslPath;
                 Console.WriteLine(engine.Log);
@@ -678,7 +678,7 @@ public void MissingXsltFile()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlInputPaths = xmlPaths;
-                xslPath.ItemSpec = xslPath.ItemSpec + "bad";
+                xslPath.ItemSpec += "bad";
                 t.XslInputPath = xslPath;
                 Assert.False(t.Execute()); // "This test should've failed (bad xslt)."
                 Console.WriteLine(engine.Log);
@@ -707,7 +707,7 @@ public void MissingCompiledDllFile()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlContent = _xmlDocument;
-                xslCompiledPath.ItemSpec = xslCompiledPath.ItemSpec + "bad;xslt";
+                xslCompiledPath.ItemSpec += "bad;xslt";
                 t.XslCompiledDllPath = xslCompiledPath;
                 Assert.False(t.Execute()); // "XsltComiledDllBad execution should've failed"
                 Console.WriteLine(engine.Log);
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index ce4f0954256..88df2dd738b 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -95,7 +95,7 @@ internal void Read(XmlReader reader)
         /// <returns></returns>
         internal static bool StringEquals(string a, string b)
         {
-            return String.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
+            return String.Equals(a, b, StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index f301ab38e41..ab6b685ba91 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -187,6 +187,7 @@ private void LazyInitialize()
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName">The sdkname of the reference.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 992cd1ba6fd..dced5e5453e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -18,6 +18,8 @@ internal class AssemblyFoldersResolver : Resolver
         /// <param name="searchPathElement"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="fileExists"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVesion"></param>
         public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
@@ -27,6 +29,7 @@ public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAsse
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName">The sdk name of the reference.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 5acebabb7eb..b7c394ebe42 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -558,7 +558,7 @@ internal static string GetRuntimeVersion(string path)
                 {
                     runtimeVersion = new StringBuilder(bufferLength);
                     hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);
-                    bufferLength = bufferLength * 2;
+                    bufferLength *= 2;
                 } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);
 
                 if (hresult == NativeMethodsShared.S_OK)
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index e9cc3fafc42..f2fe396824f 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -99,6 +99,7 @@ out userRequestedSpecificFile
             return null;
         }
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Compile search paths into an array of resolvers.
         /// </summary>
@@ -118,6 +119,24 @@ out userRequestedSpecificFile
         /// <param name="getAssemblyPathInGac"></param>
         /// <param name="log"></param>
         /// <returns></returns>
+#else
+        /// <summary>
+        /// Compile search paths into an array of resolvers.
+        /// </summary>
+        /// <param name="buildEngine"></param>
+        /// <param name="searchPaths"></param>
+        /// <param name="candidateAssemblyFiles">Paths to assembly files mentioned in the project.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="frameworkPaths">Paths to FX folders.</param>
+        /// <param name="fileExists"></param>
+        /// <param name="getAssemblyName"></param>
+        /// <param name="installedAssemblies"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="log"></param>
+        /// <returns></returns>
+#endif
         public static Resolver[] CompileSearchPaths
         (
             IBuildEngine buildEngine,
@@ -147,29 +166,29 @@ TaskLoggingHelper log
 
                 // Was {HintPathFromItem} specified? If so, take the Item's
                 // HintPath property.
-                if (0 == String.Compare(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
 #if FEATURE_GAC
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
                 }
 #endif
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 066901110f3..eb126f0656a 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -26,6 +26,8 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// <param name="searchPathElement"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="fileExists"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVesion"></param>
         public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index ffc77ba7845..5f0cdbf64e0 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -36,7 +36,7 @@ internal enum CopyLocalState
         NoBecausePrerequisite,
 
         /// <summary>
-        /// The Reference should be CopyLocal='false' because the the Private attribute is set to 'false' in the project. 
+        /// The Reference should be CopyLocal='false' because the Private attribute is set to 'false' in the project.
         /// </summary>
         NoBecauseReferenceItemHadMetadata,
 
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index e361f78e0ed..098d1a23603 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -97,7 +97,7 @@ internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssembl
                     var current = new AssemblyNameExtension(a.FullName);
 
                     // If the current version is higher than the previously looked at.
-                    if (current.Version != null && current.Version.CompareTo(assemblyNameToUse.Version) > 0)
+                    if (current.Version?.CompareTo(assemblyNameToUse.Version) > 0)
                     {
                         // Only compare the Culture and the public key token, the simple names will ALWAYS be the same and the version we do not care about.
                         if (assemblyName.PartialNameCompare(current, PartialComparisonFlags.Culture | PartialComparisonFlags.PublicKeyToken))
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index a8b77e6a55a..16342d58a31 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -43,7 +43,7 @@ public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchit
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">Allowed executable extensions.</param>
         /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the <AssemblyFolderKey> on the reference in the project.</param>
+        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
         /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
         /// <param name="foundPath">The path where the file was found.</param>
         /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 567e98ca889..96b53b98a28 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -113,7 +113,6 @@ public override bool Execute()
                     {
                         writeOutput = false;
                     }
-
                 }
                 catch(System.Xml.XmlException)
                 {
@@ -121,7 +120,6 @@ public override bool Execute()
                 }
             }
 
-
             if (AppConfigFile != null)
             {
                 AppConfigFile.CopyMetadataTo(OutputAppConfigFile);
@@ -148,7 +146,7 @@ public override bool Execute()
         /// </summary>
         private static bool IsMatch(AssemblyName suggestedRedirect, string name, string culture, string publicKeyToken)
         {
-            if (String.Compare(suggestedRedirect.Name, name, StringComparison.OrdinalIgnoreCase) != 0)
+            if (!String.Equals(suggestedRedirect.Name, name, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -168,7 +166,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
             }
 
             if (!String.IsNullOrEmpty(culture) &&
-                String.Compare(cultureString, culture, StringComparison.OrdinalIgnoreCase) != 0)
+                !String.Equals(cultureString, culture, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -181,7 +179,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
         /// </summary>
         private static bool ByteArrayMatchesString(Byte[] a, string s)
         {
-            return String.Compare(ResolveAssemblyReference.ByteArrayToString(a), s, StringComparison.OrdinalIgnoreCase) != 0;
+            return !String.Equals(ResolveAssemblyReference.ByteArrayToString(a), s, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -351,7 +349,7 @@ private XDocument LoadAppConfig(ITaskItem appConfigItem)
         /// </summary>
         private IDictionary<AssemblyName, string> ParseSuggestedRedirects()
         {
-            ErrorUtilities.VerifyThrow(SuggestedRedirects != null && SuggestedRedirects.Length > 0, "This should not be called if there is no suggested redirect.");
+            ErrorUtilities.VerifyThrow(SuggestedRedirects?.Length > 0, "This should not be called if there is no suggested redirect.");
 
             var map = new Dictionary<AssemblyName, string>();
             foreach (var redirect in SuggestedRedirects)
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index bd27d48ab41..24e3b06dade 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -34,6 +34,12 @@ internal static class GlobalAssemblyCache
         /// </summary>
         /// <param name="assemblyName">The assembly name.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
+        /// <param name="getRuntimeVersion">Delegate to get the clr version of the file.</param>
+        /// <param name="targetedRuntime">Version of the targetted runtime.</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         private static string GetLocationImpl(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntime, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion)
         {
@@ -211,7 +217,11 @@ private static string CheckForFullFusionNameInGac(AssemblyNameExtension assembly
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
         /// <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
-        /// <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fullFusionName">Are we guaranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         internal static string GetLocation
         (
@@ -232,11 +242,16 @@ bool specificVersion
         /// <summary>
         /// Given a strong name, find its path in the GAC.
         /// </summary>
+        /// <param name="buildEngine">The build engine</param>
         /// <param name="strongName">The strong name.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
         /// <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
         /// <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         internal static string GetLocation
         (
@@ -284,10 +299,10 @@ bool specificVersion
             }
 
             // A delegate was not passed in to use the default one
-            getPathFromFusionName = getPathFromFusionName ?? pathFromFusionName;
+            getPathFromFusionName ??= pathFromFusionName;
 
             // A delegate was not passed in to use the default one
-            getGacEnumerator = getGacEnumerator ?? gacEnumerator;
+            getGacEnumerator ??= gacEnumerator;
 
             // If we have no processor architecture set then we can tryout a number of processor architectures.
             string location;
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 69e0aeeea4f..c5c67e630e5 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -240,7 +240,6 @@ internal void RemoveDependency(Reference dependencyToRemove)
             _dependencies.Remove(dependencyToRemove);
         }
 
-
         /// <summary>
         /// Get the dependee references for this reference.
         ///  This is collection of References.
@@ -494,7 +493,7 @@ internal string FullPath
                     _fileNameWithoutExtension = null;
                     _directoryName = null;
 
-                    if (_fullPath == null || _fullPath.Length == 0)
+                    if (string.IsNullOrEmpty(_fullPath))
                     {
                         _scatterFiles = Array.Empty<string>();
                         _satelliteFiles = new List<string>();
@@ -522,7 +521,7 @@ internal string DirectoryName
         {
             get
             {
-                if ((_directoryName == null || _directoryName.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_directoryName)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _directoryName = Path.GetDirectoryName(_fullPath);
                     if (_directoryName.Length == 0)
@@ -542,7 +541,7 @@ internal string FileNameWithoutExtension
         {
             get
             {
-                if ((_fileNameWithoutExtension == null || _fileNameWithoutExtension.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_fileNameWithoutExtension)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _fileNameWithoutExtension = Path.GetFileNameWithoutExtension(_fullPath);
                 }
@@ -557,7 +556,7 @@ internal string FullPathWithoutExtension
         {
             get
             {
-                if ((_fullPathWithoutExtension == null || _fullPathWithoutExtension.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_fullPathWithoutExtension)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _fullPathWithoutExtension = Path.Combine(DirectoryName, FileNameWithoutExtension);
                 }
@@ -565,7 +564,6 @@ internal string FullPathWithoutExtension
             }
         }
 
-
         /// <summary>
         /// This is the HintPath from the source item. This is used to resolve the assembly.
         /// </summary>
@@ -884,7 +882,7 @@ string executableExtension
             _primarySourceItem = sourceItem;
             SDKName = sourceItem.GetMetadata("SDKName");
 
-            if (executableExtension != null && executableExtension.Length > 0)
+            if (!string.IsNullOrEmpty(executableExtension))
             {
                 // Set the expected extension.
                 SetExecutableExtension(executableExtension);
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 344c40c092d..1561d3eee24 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -145,9 +145,9 @@ internal sealed class ReferenceTable
         private readonly ConcurrentDictionary<string, AssemblyMetadata> _assemblyMetadataCache;
 
         /// <summary>
-        /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is. 
-        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message 
-        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we 
+        /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is.
+        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message
+        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we
         /// discover an assembly in the black list we can log the correct message.
         /// </summary>
         internal delegate void LogExclusionReason(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
@@ -158,6 +158,7 @@ internal sealed class ReferenceTable
         // PEHeader
         private const int PEHEADER = 0x00004550;
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Construct.
         /// </summary>
@@ -180,10 +181,48 @@ internal sealed class ReferenceTable
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
         /// <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
+        /// <param name="openBaseKey"></param>
+        /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
+        /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
+        /// <param name="allowedAssemblyExtensions"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="projectTargetFramework"></param>
+        /// <param name="targetFrameworkMoniker"></param>
+        /// <param name="log"></param>
+        /// <param name="latestTargetFrameworkDirectories"></param>
+        /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
+        /// <param name="doNotCopyLocalIfInGac"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="isWinMDFile"></param>
+        /// <param name="ignoreVersionForFrameworkReferences"></param>
+        /// <param name="readMachineTypeFromPEHeader"></param>
+        /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
+        /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+#else
+        /// <summary>
+        /// Construct.
+        /// </summary>
+        /// <param name="buildEngine"></param>
+        /// <param name="findDependencies">If true, then search for dependencies.</param>
+        /// <param name="findSatellites">If true, then search for satellite files.</param>
+        /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
+        /// <param name="findRelatedFiles">If true, then search for related files.</param>
+        /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
+        /// <param name="relatedFileExtensions"></param>
+        /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
+        /// <param name="resolvedSDKItems">Resolved sdk items</param>
+        /// <param name="frameworkPaths">Path to the FX.</param>
+        /// <param name="installedAssemblies">Installed assembly XML tables.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="directoryExists">Delegate used for files.</param>
+        /// <param name="getDirectories">Delegate used for getting directories.</param>
+        /// <param name="getAssemblyName">Delegate used for getting assembly names.</param>
+        /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
-        /// <param name="openBaseKey"></param>
         /// <param name="getRuntimeVersion"></param>
         /// <param name="targetedRuntimeVersion"></param>
         /// <param name="projectTargetFramework"></param>
@@ -198,6 +237,7 @@ internal sealed class ReferenceTable
         /// <param name="readMachineTypeFromPEHeader"></param>
         /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
         /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+#endif
         internal ReferenceTable
         (
             IBuildEngine buildEngine,
@@ -378,7 +418,6 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
             References[assemblyName] = reference;
         }
 
-
         /// <summary>
         /// Find the reference that corresponds to the given path.
         /// </summary>
@@ -542,7 +581,7 @@ ITaskItem referenceAssemblyName
             // Figure out the specific version value.
             bool wantSpecificVersion = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.specificVersion, out bool foundSpecificVersionMetadata);
 
-            bool isSimpleName = (assemblyName != null && assemblyName.IsSimpleName);
+            bool isSimpleName = (assemblyName?.IsSimpleName == true);
 
             // Create the reference.
             var reference = new Reference(_isWinMDFile, _fileExists, _getRuntimeVersion);
@@ -588,7 +627,6 @@ ITaskItem referenceAssemblyName
                 }
             }
 
-
             // Embed Interop Types aka "NOPIAs" support is not available for Fx < 4.0
             // So, we just ignore this setting on down-level platforms
             if (_projectTargetFramework != null && _projectTargetFramework >= s_targetFrameworkVersion_40)
@@ -1008,7 +1046,7 @@ out FrameworkName frameworkName
 
             var dependencies = new List<AssemblyNameExtension>(dependentAssemblies?.Length ?? 0);
 
-            if (dependentAssemblies != null && dependentAssemblies.Length > 0)
+            if (dependentAssemblies?.Length > 0)
             {
                 // Re-map immediately so that to the sytem we actually got the remapped version when reading the manifest.
                 for (int i = 0; i < dependentAssemblies.Length; i++)
@@ -1048,7 +1086,7 @@ out FrameworkName frameworkName
         }
 
         /// <summary>
-        /// Given an enumerator of pre-unified assembly names, return an enumerator of unified 
+        /// Given an enumerator of pre-unified assembly names, return an enumerator of unified
         /// assembly names.
         /// </summary>
         private IEnumerable<UnifiedAssemblyName> GetUnifiedAssemblyNames
@@ -1195,10 +1233,10 @@ private static bool IsPseudoAssembly(string name)
         }
 
         /// <summary>
-        /// Based on the set of parent assemblies we want to add their directories to the list of resolvers so that 
+        /// Based on the set of parent assemblies we want to add their directories to the list of resolvers so that
         /// if the dependency is sitting beside the assembly which requires it then we will resolve the assembly from that location first.
-        /// 
-        /// The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly 
+        ///
+        /// The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly
         /// to be found using those resolvers so that our GAC and AssemblyFolders checks later on will work on those assemblies.
         /// </summary>
         internal static void CalculateParentAssemblyDirectories(List<string> parentReferenceFolders, Reference parentReference)
@@ -1226,7 +1264,7 @@ internal static void CalculateParentAssemblyDirectories(List<string> parentRefer
         }
 
         /// <summary>
-        /// Given an unresolved reference (one that we don't know the full name for yet), figure out the 
+        /// Given an unresolved reference (one that we don't know the full name for yet), figure out the
         /// full name. Should only be called on references that haven't been resolved yet--otherwise, its
         /// a perf problem.
         /// </summary>
@@ -1390,7 +1428,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
 
                     // Need to deal with dependencies, this can also include primary references who are dependencies themselves and are in the black list
-                    if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees != null && dependees.Count > 1)))
+                    if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees?.Count > 1)))
                     {
                         // Does the assembly have specific version true, or does any of its primary parent references have specific version true.
                         // This is checked because, if an assembly is in the black list, the only way it can possibly be allowed is if
@@ -1433,7 +1471,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
 
         /// <summary>
         /// References usually only contains who they depend on, they do not know who depends on them. Given a reference
-        /// A we cannot inspect A to find out that B,C,D depend on it. This method will traverse the references and build up this other direction of the graph, 
+        /// A we cannot inspect A to find out that B,C,D depend on it. This method will traverse the references and build up this other direction of the graph,
         /// therefore we will be able to know given reference A, that B,C,D depend on it.
         /// </summary>
         private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyGraph, AssemblyNameExtension assemblyName, Reference assemblyReference)
@@ -1534,7 +1572,7 @@ internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         }
 
         /// <summary>
-        /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other 
+        /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other
         /// assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the black list.
         /// </summary>
         /// <param name="removedReference">Reference to remove dependencies for</param>
@@ -1579,7 +1617,7 @@ private static void RemoveDependencies(Reference removedReference, Dictionary<As
         /// Searches the table for references that haven't been resolved to their full file names and
         /// for dependencies that haven't yet been found.
         ///
-        /// If any are found, they're resolved and then dependencies are found. Then the process is repeated 
+        /// If any are found, they're resolved and then dependencies are found. Then the process is repeated
         /// until nothing is left unresolved.
         /// </summary>
         /// <param name="remappedAssembliesValue">The table of remapped assemblies.</param>
@@ -1634,7 +1672,6 @@ private void ComputeClosure()
                     ErrorUtilities.VerifyThrow(dependencyIterations < maxIterations, "Maximum iterations exceeded while looking for dependencies.");
                 } while (moreDependencies);
 
-
                 // If everything is either resolved or unresolvable, then we can quit.
                 // Otherwise, loop again.
                 moreResolvable = false;
@@ -1773,7 +1810,7 @@ private void ResolveAssemblyFilenames()
         }
 
         /// <summary>
-        /// This methods looks for conflicts between assemblies and attempts to 
+        /// This methods looks for conflicts between assemblies and attempts to
         /// resolve them.
         /// </summary>
         private void ResolveConflictsBetweenReferences(Dictionary<string, List<AssemblyNameReference>> baseNameToReferences)
@@ -1812,7 +1849,7 @@ private void ResolveConflictsBetweenReferences(List<AssemblyNameReference> assem
         }
 
         /// <summary>
-        /// Based on the closure, get a table of ideal remappings needed to 
+        /// Based on the closure, get a table of ideal remappings needed to
         /// produce zero conflicts.
         /// </summary>
         internal void ResolveConflicts
@@ -1865,7 +1902,7 @@ out List<AssemblyNameReference> conflictingReferences
                     }
 
                     byte[] pkt = assemblyName.GetPublicKeyToken();
-                    if (pkt != null && pkt.Length > 0)
+                    if (pkt?.Length > 0)
                     {
                         AssemblyName baseKey = assemblyName.AssemblyName.CloneIfPossible();
                         Version version = baseKey.Version;
@@ -1923,8 +1960,8 @@ out List<AssemblyNameReference> conflictingReferences
         }
 
         /// <summary>
-        /// If a reference is a higher version than what exists in the redist list of the target framework then 
-        /// this reference needs to be marked as excluded so that it is not not allowed to be referenced. 
+        /// If a reference is a higher version than what exists in the redist list of the target framework then
+        /// this reference needs to be marked as excluded so that it is not allowed to be referenced.
         /// 
         /// If the user needs this reference then they need to set specific version to true.
         /// </summary>
@@ -1981,12 +2018,12 @@ private bool InLatestRedistList(AssemblyNameExtension assemblyName)
 
         /// <summary>
         /// Get the redist list which corresponds to the highest target framework for a given target framework moniker.
-        /// 
+        ///
         /// This is done in two ways:
         ///  First, if the latestTargetFrameworkDirectories parameter is passed into RAR those directories will be used to get the redist list
-        ///  regardless of the target framework moniker. 
-        ///  
-        /// Second, if latest Target Framework Directories is not passed in then we ask the ToollocationHelper for the highest target framework which has 
+        ///  regardless of the target framework moniker.
+        ///
+        /// Second, if latest Target Framework Directories is not passed in then we ask the ToollocationHelper for the highest target framework which has
         /// a TargetFrameworkIdentifier which matches the passed in TargetFrameworkMoniker.
         /// </summary>
         private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(FrameworkNameVersioning targetFrameworkMoniker)
@@ -2005,7 +2042,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
 
                         // The latestTargetFrameworkDirectories can be passed into RAR, if they are then use those directories rather than 
                         // getting a list by looking at the file system.
-                        if (_latestTargetFrameworkDirectories != null && _latestTargetFrameworkDirectories.Length > 0)
+                        if (_latestTargetFrameworkDirectories?.Length > 0)
                         {
                             referenceAssemblyDirectories = new List<string>(_latestTargetFrameworkDirectories);
                             otherFrameworkName = String.Join(";", _latestTargetFrameworkDirectories);
@@ -2019,7 +2056,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
                             }
                         }
 
-                        if (referenceAssemblyDirectories != null && referenceAssemblyDirectories.Count > 0)
+                        if (referenceAssemblyDirectories?.Count > 0)
                         {
                             var seenFrameworkDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                             var assemblyTableInfos = new List<AssemblyTableInfo>();
@@ -2050,7 +2087,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
         }
 
         /// <summary>
-        /// Based on a target framework moniker, get the set of reference assembly directories which 
+        /// Based on a target framework moniker, get the set of reference assembly directories which
         /// correspond to the highest version of the target framework identifier property on the target framework moniker.
         /// </summary>
         private static IList<string> GetHighestVersionReferenceAssemblyDirectories(FrameworkNameVersioning targetFrameworkMoniker, out FrameworkNameVersioning highestVersionMoniker)
@@ -2069,7 +2106,7 @@ private static IList<string> GetHighestVersionReferenceAssemblyDirectories(Frame
             }
             return referenceAssemblyDirectories;
         }
-        
+
         /// <summary>
         /// Is the assemblyName in the current redist list and does it have a version number which is higher than what is in the current redist list.
         /// This may happen if someone passes in a p2p reference whcih is a framework assembly which is a higher version than what is in the redist list.
@@ -2150,7 +2187,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(
 
             return haveMarkedReference;
         }
-        
+
         /// <summary>
         /// Build a table of simple names mapped to assemblyname+reference.
         /// </summary>
@@ -2196,7 +2233,6 @@ Dictionary<string, List<AssemblyNameReference>> baseNameToReferences
                 if (baseNameToReferences[baseName].Count == 1)
                 {
                     baseNameToReferences.Remove(baseName);
-
                 }
             }
         }
@@ -2298,7 +2334,7 @@ out _
                     }
                 }
             }
-            
+
             // Remove the one chosen.
             int victor = 1 - victim;
 
@@ -2339,12 +2375,14 @@ private static bool IsAssemblyRemovedFromDotNetFramework(AssemblyNameExtension a
         }
 
         /// <summary>
-        /// Get unification information for the given assembly name. 
+        /// Get unification information for the given assembly name.
         /// </summary>
         /// <param name="assemblyName">The assembly name.</param>
         /// <param name="unifiedVersion">The new version of the assembly to use.</param>
         /// <param name="unificationReason">The reason this reference was unified.</param>
         /// <param name="isPrerequisite">True if this is a prereq assembly.</param>
+        /// <param name="isRedistRoot">May be true, false or null. Null means there was no IsRedistRoot in the redist list.</param>
+        /// <param name="redistName">Name of the corresponding Resist specified in the redist list.</param>
         /// <returns>True if there was a unification.</returns>
         private bool UnifyAssemblyNameVersions
         (
@@ -2414,7 +2452,6 @@ out redistName
                 }
             }
 
-
             return false;
         }
 
@@ -2456,6 +2493,8 @@ private bool CompareAssembliesIgnoringVersion(AssemblyName a, AssemblyName b)
         /// <param name="dependencyFiles">Dependent references fully resolved.</param>
         /// <param name="relatedFiles">Related files like .xmls and .pdbs.</param>
         /// <param name="satelliteFiles">Satellite files.</param>
+        /// <param name="serializationAssemblyFiles">Serialization assembly files.</param>
+        /// <param name="scatterFiles">Receives the list of associated scatter files.</param>
         /// <param name="copyLocalFiles">All copy-local files out of primaryFiles+dependencyFiles+relatedFiles+satelliteFiles.</param>
         internal void GetReferenceItems
         (
@@ -2586,7 +2625,7 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 referenceItem.SetMetadata(ItemMetadataNames.redist, reference.RedistName);
             }
 
-            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies != null && _installedAssemblies.FrameworkAssemblyEntryInRedist(assemblyName)))
+            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies?.FrameworkAssemblyEntryInRedist(assemblyName) == true))
             {
                 if (!IsAssemblyRemovedFromDotNetFramework(assemblyName, reference.FullPath, _frameworkPaths, _installedAssemblies))
                 {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 61e2a6a93e5..c88ed99568e 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -29,12 +29,12 @@ namespace Microsoft.Build.Tasks
     public class ResolveAssemblyReference : TaskExtension
     {
         /// <summary>
-        /// key assembly used to trigger inclusion of facade references. 
+        /// key assembly used to trigger inclusion of facade references.
         /// </summary>
         private const string SystemRuntimeAssemblyName = "System.Runtime";
 
         /// <summary>
-        /// additional key assembly used to trigger inclusion of facade references. 
+        /// additional key assembly used to trigger inclusion of facade references.
         /// </summary>
         private const string NETStandardAssemblyName = "netstandard";
 
@@ -127,11 +127,11 @@ public bool UnresolveFrameworkAssembliesFromHigherFrameworks
 
         /// <summary>
         /// If there is a mismatch between the targetprocessor architecture and the architecture of a primary reference.
-        /// 
-        /// When this is error,  an error will be logged. 
-        /// 
+        ///
+        /// When this is error,  an error will be logged.
+        ///
         /// When this is warn, if there is a mismatch between the targetprocessor architecture and the architecture of a primary reference a warning will be logged.
-        /// 
+        ///
         /// When this is none, no error or warning will be logged.
         /// </summary>
         public string WarnOrErrorOnTargetArchitectureMismatch
@@ -154,12 +154,12 @@ public string WarnOrErrorOnTargetArchitectureMismatch
         ///
         /// Optional attributes are:
         ///     bool Private [default=true] -- means 'CopyLocal'
-        ///     string FusionName -- the simple or strong fusion name for this item. If this 
+        ///     string FusionName -- the simple or strong fusion name for this item. If this
         ///         attribute is present it can save time since the assembly file won't need
         ///         to be opened to get the fusion name.
         ///     bool ExternallyResolved [default=false] -- indicates that the reference and its
         ///        dependencies are resolved by an external system (commonly from nuget assets) and
-        ///        so several steps can be skipped as an optimization: finding dependencies, 
+        ///        so several steps can be skipped as an optimization: finding dependencies,
         ///        satellite assemblies, etc.
         /// </summary>
         public ITaskItem[] AssemblyFiles
@@ -169,9 +169,9 @@ public ITaskItem[] AssemblyFiles
         }
 
         /// <summary>
-        /// The list of directories which contain the redist lists for the most current 
+        /// The list of directories which contain the redist lists for the most current
         /// framework which can be targeted on the machine. If this is not set
-        /// Then we will looks for the highest framework installed on the machine 
+        /// Then we will looks for the highest framework installed on the machine
         /// for a given target framework identifier and use that.
         /// </summary>
         public string[] LatestTargetFrameworkDirectories
@@ -239,26 +239,26 @@ public string[] TargetFrameworkSubsets
         ///
         /// Optional attributes are:
         ///     bool Private [default=true] -- means 'CopyLocal'
-        ///     string HintPath [default=''] -- location of file name to consider as a reference, 
+        ///     string HintPath [default=''] -- location of file name to consider as a reference,
         ///         used when {HintPathFromItem} is one of the paths in SearchPaths.
-        ///     bool SpecificVersion [default=absent] -- 
-        ///         when true, the exact fusionname in the Include must be matched. 
+        ///     bool SpecificVersion [default=absent] --
+        ///         when true, the exact fusionname in the Include must be matched.
         ///         when false, any assembly with the same simple name will be a match.
-        ///         when absent, then look at the value in Include. 
+        ///         when absent, then look at the value in Include.
         ///           If its a simple name then behave as if specific version=false.
-        ///           If its a strong name name then behave as if specific version=true.
-        ///     string ExecutableExtension [default=absent] -- 
+        ///           If its a strong name then behave as if specific version=true.
+        ///     string ExecutableExtension [default=absent] --
         ///         when present, the resolved assembly must have this extension.
         ///         when absent, .dll is considered and then .exe for each directory looked at.
-        ///     string SubType -- only items with empty SubTypes will be considered. Items 
+        ///     string SubType -- only items with empty SubTypes will be considered. Items
         ///         with non-empty subtypes will be ignored.
-        ///     string AssemblyFolderKey [default=absent] -- supported for legacy AssemblyFolder 
+        ///     string AssemblyFolderKey [default=absent] -- supported for legacy AssemblyFolder
         ///         resolution. This key can have a value like 'hklm\vendor folder'. When set, only
         ///         this particular assembly folder key will be used.
         ///            This is to support the scenario in VSWhidey#357946 in which there are multiple
         ///            side-by-side libraries installed and the user wants to pick an exact version.
-        ///     bool EmbedInteropTyeps [default=absent] -- 
-        ///         when true, we should treat this assembly as if it has no dependencies and should 
+        ///     bool EmbedInteropTyeps [default=absent] --
+        ///         when true, we should treat this assembly as if it has no dependencies and should
         ///         be completely embedded into the target assembly.
         /// </summary>
         public ITaskItem[] Assemblies
@@ -291,9 +291,9 @@ public ITaskItem[] ResolvedSDKReferences
         }
 
         /// <summary>
-        /// Path to the target frameworks directory. Required to figure out CopyLocal status 
+        /// Path to the target frameworks directory. Required to figure out CopyLocal status
         /// for resulting items.
-        /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity 
+        /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity
         /// have a Private='true' attribute on their source item.
         /// </summary>
         public string[] TargetFrameworkDirectories
@@ -304,14 +304,14 @@ public string[] TargetFrameworkDirectories
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be installed on the target machine.
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="Microsoft-Windows-CLRCoreComp" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// When present, assemblies from this list will be candidates to automatically "unify" from prior versions up to
         /// the version listed in the XML. Also, assemblies with InGAC='true' will be considered prerequisites and will be CopyLocal='false'
         /// unless explicitly overridden.
@@ -330,16 +330,16 @@ public ITaskItem[] InstalledAssemblyTables
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be in the target subset
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="ClientSubset" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// Items in this list may optionally specify the "FrameworkDirectory" metadata to associate an InstalledAssemblySubsetTable
-        /// with a particular framework directory. 
+        /// with a particular framework directory.
         /// If there is only a single TargetFrameworkDirectories element, then any items in this list missing the
         /// "FrameworkDirectory" metadata will be treated as though this metadata is set to the lone (unique) value passed
         /// to TargetFrameworkDirectories.
@@ -356,19 +356,19 @@ public ITaskItem[] InstalledAssemblySubsetTables
 
         /// <summary>
         /// A list of XML files that contain the full framework for the profile.
-        /// 
-        /// Normally nothing is passed in here, this is for the cases where the location of the xml file for the full framework 
+        ///
+        /// Normally nothing is passed in here, this is for the cases where the location of the xml file for the full framework
         /// is not under a RedistList folder.
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="MatchingRedistListName" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// Items in this list must specify the "FrameworkDirectory" metadata to associate an redist list
-        /// with a particular framework directory. If the association is not made an error will be logged. The reason is, 
+        /// with a particular framework directory. If the association is not made an error will be logged. The reason is,
         /// The logic in rar assumes if a FrameworkDirectory is not set it will use the target framework directory.
         /// </summary>
         public ITaskItem[] FullFrameworkAssemblyTables
@@ -383,7 +383,7 @@ public ITaskItem[] FullFrameworkAssemblyTables
 
         /// <summary>
         /// [default=false]
-        /// Boolean property to control whether or not the task should look for and use additional installed 
+        /// Boolean property to control whether or not the task should look for and use additional installed
         /// assembly tables (a.k.a Redist Lists) found in the RedistList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
@@ -395,7 +395,7 @@ public bool IgnoreDefaultInstalledAssemblyTables
 
         /// <summary>
         /// [default=false]
-        /// Boolean property to control whether or not the task should look for and use additional installed 
+        /// Boolean property to control whether or not the task should look for and use additional installed
         /// assembly subset tables (a.k.a Subset Lists) found in the SubsetList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
@@ -415,14 +415,14 @@ public bool IgnoreVersionForFrameworkReferences
         }
 
         /// <summary>
-        /// The preferred target processor architecture. Used for resolving {GAC} references. 
+        /// The preferred target processor architecture. Used for resolving {GAC} references.
         /// Should be like x86, IA64 or AMD64.
-        /// 
+        ///
         /// This is the order of preference:
         /// (1) Assemblies in the GAC that match the supplied ProcessorArchitecture.
         /// (2) Assemblies in the GAC that have ProcessorArchitecture=MSIL
         /// (3) Assemblies in the GAC that have no ProcessorArchitecture.
-        /// 
+        ///
         /// If absent, then only consider assemblies in the GAC that have ProcessorArchitecture==MSIL or
         /// no ProcessorArchitecture (these are pre-Whidbey assemblies).
         /// </summary>
@@ -496,7 +496,6 @@ public string[] AllowedAssemblyExtensions
             set { _allowedAssemblyExtensions = value; }
         }
 
-
         /// <summary>
         /// [default=.pdb;.xml]
         /// These are the extensions that will be considered when looking for related files.
@@ -507,7 +506,6 @@ public string[] AllowedRelatedFileExtensions
             set { _relatedFileExtensions = value; }
         }
 
-
         /// <summary>
         /// If this file name is passed in, then we parse it as an app.config file and extract bindingRedirect mappings. These mappings are used in the dependency
         /// calculation process to remap versions of assemblies.
@@ -563,23 +561,22 @@ public bool AutoUnify
             set { _autoUnify = value; }
         }
 
-
         /// <summary>
-        ///  When determining if a dependency should be copied locally one of the checks done is to see if the 
-        ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then 
-        ///  We will use that for the dependency as well. 
-        ///  
-        /// However, if the metadata is not set then the dependency will go through the same checks as the parent reference. 
+        ///  When determining if a dependency should be copied locally one of the checks done is to see if the
+        ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then
+        ///  We will use that for the dependency as well.
+        ///
+        /// However, if the metadata is not set then the dependency will go through the same checks as the parent reference.
         /// One of these checks is to see if the reference is in the GAC. If a reference is in the GAC then we will not copy it locally
         /// as it is assumed it will be in the gac on the target machine as well. However this only applies to that specific reference and not its dependencies.
-        /// 
+        ///
         /// This means a reference in the project file may be copy local false due to it being in the GAC but the dependencies may still be copied locally because they are not in the GAC.
         /// This is the default behavior for RAR and causes the default value for this property to be true.
-        /// 
-        /// When this property is false we will still check project file references to see if they are in the GAC and set their copy local state as appropriate. 
-        /// However for dependencies we will not only check to see if they are in the GAC but we will also check to see if the parent reference from the project file is in the GAC. 
+        ///
+        /// When this property is false we will still check project file references to see if they are in the GAC and set their copy local state as appropriate.
+        /// However for dependencies we will not only check to see if they are in the GAC but we will also check to see if the parent reference from the project file is in the GAC.
         /// If the parent reference from the project file is in the GAC then we will not copy the dependency locally.
-        /// 
+        ///
         /// NOTE: If there are multiple parent reference and ANY of them does not come from the GAC then we will set copy local to true.
         /// </summary>
         public bool CopyLocalDependenciesWhenParentReferenceInGac
@@ -705,9 +702,9 @@ public string TargetFrameworkMonikerDisplayName
         }
 
         /// <summary>
-        /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring 
+        /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring
         /// of TargetFrameworkSubsets.
-        /// 
+        ///
         /// Full, Complete
         /// </summary>
         public string[] FullTargetFrameworkSubsetNames
@@ -744,7 +741,7 @@ public string ProfileName
 
         /// <summary>
         /// Set of folders which containd a RedistList directory which represent the full framework for a given client profile.
-        /// An example would be 
+        /// An example would be
         /// %programfiles%\reference assemblies\microsoft\framework\v4.0
         /// </summary>
         public string[] FullFrameworkFolders
@@ -785,9 +782,9 @@ public ITaskItem[] ResolvedFiles
         ///     string FusionName - the fusion name for this dependency.
         ///     string ResolvedFrom - the literal search path that this file was resolved from.
         ///     bool IsRedistRoot - Whether or not this assembly is the representative for an entire redist.
-        ///         'true' means the assembly is representative of an entire redist and should be indicated as 
+        ///         'true' means the assembly is representative of an entire redist and should be indicated as
         ///         an application dependency in an application manifest.
-        ///         'false' means the assembly is internal to a redist and should not be part of the 
+        ///         'false' means the assembly is internal to a redist and should not be part of the
         ///         application manifest.
         ///     string Redist - The name (if any) of the redist that contains this assembly.
         /// Does not include first order primary references--this list is in ResolvedFiles.
@@ -811,10 +808,10 @@ public ITaskItem[] RelatedFiles
         }
 
         /// <summary>
-        /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency 
+        /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency
         /// that caused this item to exist is CopyLocal=true.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
-        ///     string DestinationSubDirectory - the relative destination directory that this file 
+        ///     string DestinationSubDirectory - the relative destination directory that this file
         ///       should be copied to. This is mainly for satellites.
         /// </summary>
         [Output]
@@ -824,7 +821,7 @@ public ITaskItem[] SatelliteFiles
         }
 
         /// <summary>
-        /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency 
+        /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency
         /// that caused this item to exist is CopyLocal=true.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
@@ -856,9 +853,9 @@ public ITaskItem[] CopyLocalFiles
         }
 
         /// <summary>
-        /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly 
-        /// identity--including culture and PKT--that was found that did not have a suitable bindingRedirect 
-        /// entry in the ApplicationConfigurationFile. 
+        /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly
+        /// identity--including culture and PKT--that was found that did not have a suitable bindingRedirect
+        /// entry in the ApplicationConfigurationFile.
         ///
         /// Each returned ITaskItem will have the following values:
         ///  ItemSpec - the full fusion name of the assembly family with empty version=0.0.0.0
@@ -905,7 +902,6 @@ public String DependsOnNETStandard
             private set;
         }
 
-
         #endregion
         #region Logging
 
@@ -1408,7 +1404,6 @@ private void LogInputs()
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", latestFolder);
                 }
 
-
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "ProfileTablesLocation");
                 foreach (ITaskItem profileTable in FullFrameworkAssemblyTables)
                 {
@@ -1422,11 +1417,11 @@ private void LogInputs()
         /// Log a specific item metadata.
         /// </summary>
         /// <param name="item"></param>
-        /// <param name="attribute"></param>
+        /// <param name="metadataName"></param>
         private void LogAttribute(ITaskItem item, string metadataName)
         {
             string metadataValue = item.GetMetadata(metadataName);
-            if (metadataValue != null && metadataValue.Length > 0)
+            if (!string.IsNullOrEmpty(metadataValue))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.LogAttributeFormat", metadataName, metadataValue));
             }
@@ -1558,7 +1553,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
         /// <param name="importance">The importance of the message.</param>
         private void LogFullName(Reference reference, MessageImportance importance)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(reference, "reference");
+            ErrorUtilities.VerifyThrowArgumentNull(reference, nameof(reference));
 
             if (reference.IsResolved)
             {
@@ -1572,6 +1567,7 @@ private void LogFullName(Reference reference, MessageImportance importance)
         /// show information about them.
         /// </summary>
         /// <param name="reference">The reference.</param>
+        /// <param name="fusionName">The fusion name.</param>
         /// <param name="importance">The importance of the message.</param>
         private void LogAssembliesConsideredAndRejected(Reference reference, string fusionName, MessageImportance importance)
         {
@@ -1602,7 +1598,6 @@ private void LogAssembliesConsideredAndRejected(Reference reference, string fusi
                         }
                     }
 
-
                     // If this is a new search location, then show the message.
                     if (lastSearchPath != location.SearchPath)
                     {
@@ -1770,7 +1765,6 @@ private void LogCopyLocalState(Reference reference, MessageImportance importance
             }
         }
 
-
         /// <summary>
         /// Log a message about the imageruntime information.
         /// </summary>
@@ -1888,6 +1882,7 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         #endregion
         #region ITask Members
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Execute the task.
         /// </summary>
@@ -1899,7 +1894,28 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
         /// <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
         /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
+        /// <param name="getRuntimeVersion">Delegate used to get the runtime version.</param>
+        /// <param name="openBaseKey">Key object to open.</param>
+        /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
+        /// <param name="isWinMDFile">Delegate used for checking whether it is a WinMD file.</param>
+        /// <param name="readMachineTypeFromPEHeader">Delegate use to read machine type from PE Header</param>
+        /// <returns>True if there was success.</returns>
+#else
+        /// <summary>
+        /// Execute the task.
+        /// </summary>
+        /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
+        /// <param name="getDirectories">Delegate used for finding directories.</param>
+        /// <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
+        /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
+        /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
+        /// <param name="getRuntimeVersion">Delegate used to get the runtime version.</param>
+        /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
+        /// <param name="isWinMDFile">Delegate used for checking whether it is a WinMD file.</param>
+        /// <param name="readMachineTypeFromPEHeader">Delegate use to read machine type from PE Header</param>
         /// <returns>True if there was success.</returns>
+#endif
         internal bool Execute
         (
             FileExists fileExists,
@@ -1964,7 +1980,6 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         }
                     }
 
-
                     // Validate the contents of the InstalledAssemblyTables parameter.
                     AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(_ignoreDefaultInstalledAssemblyTables, _installedAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
                     AssemblyTableInfo[] whiteListSubsetTableInfo = null;
@@ -1972,7 +1987,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     InstalledAssemblies installedAssemblies = null;
                     RedistList redistList = null;
 
-                    if (installedAssemblyTableInfo != null && installedAssemblyTableInfo.Length > 0)
+                    if (installedAssemblyTableInfo?.Length > 0)
                     {
                         redistList = RedistList.GetRedistList(installedAssemblyTableInfo);
                     }
@@ -1989,7 +2004,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     List<string> whiteListErrorFilesNames = new List<string>();
 
                     // Check for partial success in GetRedistList and log any tolerated exceptions.
-                    if (redistList != null && redistList.Count > 0 || targetingProfile || ShouldUseSubsetBlackList())
+                    if (redistList?.Count > 0 || targetingProfile || ShouldUseSubsetBlackList())
                     {
                         // If we are not targeting a dev 10 profile and we have the required components to generate a orcas style subset, do so
                         if (!targetingProfile && ShouldUseSubsetBlackList())
@@ -1997,7 +2012,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             // Based in the target framework subset names find the paths to the files
                             SubsetListFinder whiteList = new SubsetListFinder(_targetFrameworkSubsets);
                             whiteListSubsetTableInfo = GetInstalledAssemblyTableInfo(IgnoreDefaultInstalledAssemblySubsetTables, InstalledAssemblySubsetTables, new GetListPath(whiteList.GetSubsetListPathsFromDisk), TargetFrameworkDirectories);
-                            if (whiteListSubsetTableInfo.Length > 0 && (redistList != null && redistList.Count > 0))
+                            if (whiteListSubsetTableInfo.Length > 0 && (redistList?.Count > 0))
                             {
                                 blackList = redistList.GenerateBlackList(whiteListSubsetTableInfo, whiteListErrors, whiteListErrorFilesNames);
                             }
@@ -2041,7 +2056,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             }
                         }
 
-                        if (redistList != null && redistList.Count > 0)
+                        if (redistList?.Count > 0)
                         {
                             installedAssemblies = new InstalledAssemblies(redistList);
                         }
@@ -2181,7 +2196,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         try
                         {
                             excludedReferencesExist = false;
-                            if (redistList != null && redistList.Count > 0)
+                            if (redistList?.Count > 0)
                             {
                                 excludedReferencesExist = dependencyTable.MarkReferencesForExclusion(blackList);
                             }
@@ -2197,7 +2212,6 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             dependencyTable.RemoveReferencesMarkedForExclusion(true /* Remove the reference and do not warn*/, subsetOrProfileName);
                         }
 
-
                         // Based on the closure, get a table of ideal remappings needed to 
                         // produce zero conflicts.
                         dependencyTable.ResolveConflicts
@@ -2220,7 +2234,7 @@ out autoUnifiedRemappedAssemblyReferences
                         try
                         {
                             excludedReferencesExist = false;
-                            if (redistList != null && redistList.Count > 0)
+                            if (redistList?.Count > 0)
                             {
                                 excludedReferencesExist = dependencyTable.MarkReferencesForExclusion(blackList);
                             }
@@ -2294,7 +2308,7 @@ out _copyLocalFiles
                             {
                                 // if we're finding dependencies and a given reference was not marked as ExternallyResolved
                                 // then its use of System.Runtime/.netstandard would already have been identified above.
-                                continue; 
+                                continue;
                             }
 
                             var rawDependencies = GetDependencies(resolvedReference, fileExists, getAssemblyMetadata, assemblyMetadataCache);
@@ -2427,7 +2441,7 @@ out _copyLocalFiles
         private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, FileExists fileExists, GetAssemblyMetadata getAssemblyMetadata, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
         {
             AssemblyNameExtension[] result = null;
-            if (resolvedReference != null && resolvedReference.IsPrimary && !resolvedReference.IsBadImage)
+            if (resolvedReference?.IsPrimary == true && !resolvedReference.IsBadImage)
             {
                 System.Runtime.Versioning.FrameworkName frameworkName = null;
                 string[] scatterFiles = null;
@@ -2469,7 +2483,6 @@ private static IReadOnlyCollection<DependentAssembly> CombineRemappedAssemblies(
             return combined;
         }
 
-
         /// <summary>
         /// If a targeted runtime is passed in use that, if none is passed in then we need to use v2.0.50727
         /// since the common way this would be empty is if we were using RAR as an override task.
@@ -2498,6 +2511,7 @@ internal static Version SetTargetedRuntimeVersion(string targetedRuntimeVersionR
         /// <param name="installedAssemblyTableInfo">Installed assembly info of the profile redist lists</param>
         /// <param name="fullRedistAssemblyTableInfo">Installed assemblyInfo for the full framework redist lists</param>
         /// <param name="blackList">Generated exclusion list</param>
+        /// <param name="fullFrameworkRedistList">Redist list which will contain the full framework redist list.</param>
         private void HandleProfile(AssemblyTableInfo[] installedAssemblyTableInfo, out AssemblyTableInfo[] fullRedistAssemblyTableInfo, out Dictionary<string, string> blackList, out RedistList fullFrameworkRedistList)
         {
             // Redist list which will contain the full framework redist list.
@@ -2672,12 +2686,11 @@ private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableIn
             }
         }
 
-
         /// <summary>
         /// Determine if a black list should be used or not
-        /// 
+        ///
         /// The black list should only be used if there are TargetFrameworkSubsets to use or TargetFrameworkProfiles.
-        /// 
+        ///
         /// 1) If we find a Full or equivalent marker in the list of subsets passed in we do not want to generate a black list even if installedAssemblySubsets are passed in
         /// 2) If we are ignoring the default installed subset tables and we have not passed in any additional subset tables, we do not want to generate a black list
         /// 3) If no targetframework subsets were passed in and no additional subset tables were passed in, we do not want to generate a blacklist
@@ -2725,7 +2738,7 @@ private bool ShouldUseSubsetBlackList()
         /// Populates the suggested redirects output parameter.
         /// </summary>
         /// <param name="idealAssemblyRemappings">The list of ideal remappings.</param>
-        /// <param name="idealAssemblyRemappedReferences">The list of of references to ideal assembly remappings.</param>
+        /// <param name="idealAssemblyRemappedReferences">The list of references to ideal assembly remappings.</param>
         private void PopulateSuggestedRedirects(List<DependentAssembly> idealAssemblyRemappings, List<AssemblyNameReference> idealAssemblyRemappedReferences)
         {
             var holdSuggestedRedirects = new List<ITaskItem>();
@@ -2793,7 +2806,7 @@ private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAs
 
                 if (String.IsNullOrEmpty(frameworkDirectory))
                 {
-                    if (TargetFrameworkDirectories != null && TargetFrameworkDirectories.Length == 1)
+                    if (TargetFrameworkDirectories?.Length == 1)
                     {
                         // Exactly one TargetFrameworkDirectory, so assume it's related to this
                         // InstalledAssemblyTable.
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 7cbbcefaa82..be72b128729 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -139,6 +139,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
         /// <param name="assemblyName">The assembly name to look up.</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
         /// <param name="wantSpecificVersion">Whether the version needs to match exactly or loosely.</param>
+        /// <param name="allowMismatchBetweenFusionNameAndFileName">Whether to allow naming mismatch.</param>
         /// <param name="pathToCandidateAssembly">Path to a possible file.</param>
         /// <param name="searchLocation">Information about why the candidate file didn't match</param>
         protected bool FileMatchesAssemblyName
@@ -160,7 +161,7 @@ ResolutionSearchLocation searchLocation
             if (!allowMismatchBetweenFusionNameAndFileName)
             {
                 string candidateBaseName = Path.GetFileNameWithoutExtension(pathToCandidateAssembly);
-                if (String.Compare(assemblyName?.Name, candidateBaseName, StringComparison.CurrentCultureIgnoreCase) != 0)
+                if (!String.Equals(assemblyName?.Name, candidateBaseName, StringComparison.CurrentCultureIgnoreCase))
                 {
                     if (searchLocation != null)
                     {
@@ -178,7 +179,7 @@ ResolutionSearchLocation searchLocation
                 }
             }
 
-            bool isSimpleAssemblyName = assemblyName != null && assemblyName.IsSimpleName;
+            bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;
 
             if (fileExists(pathToCandidateAssembly))
             {
@@ -241,8 +242,8 @@ ResolutionSearchLocation searchLocation
                         }
                     }
 
-                    bool matchedSpecificVersion = (wantSpecificVersion && assemblyName != null && assemblyName.Equals(targetAssemblyName));
-                    bool matchPartialName = !wantSpecificVersion && assemblyName != null && assemblyName.PartialNameCompare(targetAssemblyName);
+                    bool matchedSpecificVersion = (wantSpecificVersion && assemblyName?.Equals(targetAssemblyName) == true);
+                    bool matchPartialName = !wantSpecificVersion && assemblyName?.PartialNameCompare(targetAssemblyName) == true;
 
                     if (matchedSpecificVersion || matchPartialName)
                     {
@@ -284,6 +285,7 @@ ResolutionSearchLocation searchLocation
         /// </summary>
         /// <param name="assemblyName">The assembly name to look up.</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
+        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">The possible filename extensions of the assembly. Must be one of these or its no match.</param>
         /// <param name="directory">the directory to look in</param>
         /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
@@ -348,7 +350,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                             AssemblyNameExtension foundAssembly = getAssemblyName(fullPath);
 
                             // If the processor architecture does not match the we should continue to see if there is a better match.
-                            if (foundAssembly != null && foundAssembly.AssemblyName.ProcessorArchitecture == ProcessorArchitecture.MSIL)
+                            if (foundAssembly?.AssemblyName.ProcessorArchitecture == ProcessorArchitecture.MSIL)
                             {
                                 return fullPath;
                             }
@@ -371,7 +373,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                     {
                         foreach (string executableExtension in executableExtensions)
                         {
-                            if (String.Compare(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase) == 0)
+                            if (String.Equals(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase))
                             {
                                 string fullPath = Path.Combine(directory, weakNameBase);
                                 var extensionlessAssemblyName = new AssemblyNameExtension(weakNameBaseFileName);
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 7c4f8841a24..d69c23af424 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -43,7 +43,7 @@ public string DefaultToVcxPlatformMapping
             set
             {
                 _defaultToVcxPlatformMapping = value;
-                if (_defaultToVcxPlatformMapping != null && _defaultToVcxPlatformMapping.Length == 0)
+                if (_defaultToVcxPlatformMapping?.Length == 0)
                 {
                     _defaultToVcxPlatformMapping = null;
                 }
@@ -83,7 +83,7 @@ public string VcxToDefaultPlatformMapping
             {
                 _vcxToDefaultPlatformMapping = value;
 
-                if (_vcxToDefaultPlatformMapping != null && _vcxToDefaultPlatformMapping.Length == 0)
+                if (_vcxToDefaultPlatformMapping?.Length == 0)
                 {
                     _vcxToDefaultPlatformMapping = null;
                 }
diff --git a/src/Tasks/AxReference.cs b/src/Tasks/AxReference.cs
index 95136153fbc..5cb6271b1fc 100644
--- a/src/Tasks/AxReference.cs
+++ b/src/Tasks/AxReference.cs
@@ -22,6 +22,7 @@ internal class AxReference : AxTlbBaseReference
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
@@ -29,9 +30,10 @@ internal class AxReference : AxTlbBaseReference
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
-        /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="sdkToolsPath">Path to the SDK tools directory where aximp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal AxReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory,
             bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, string sdkToolsPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, resolverCallback, referenceInfo, itemName, outputDirectory, delaySign, keyFile, keyContainer, includeTypeLibVersionInName, true /* always execute as tool */, sdkToolsPath, buildEngine, environmentVariables)
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index 39f3871bcf1..f9072bc3401 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -24,6 +24,7 @@ internal abstract class AxTlbBaseReference : ComReference
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
@@ -31,9 +32,11 @@ internal abstract class AxTlbBaseReference : ComReference
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe or tlbimp.exe</param>
         /// <param name="toolPath">Path to the SDK tools directory where aximp.exe or tlbimp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, bool executeAsTool, string toolPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, referenceInfo, itemName)
         {
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 036f9aee7d7..97990245c1c 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -95,7 +95,7 @@ public string Path
             get => _path;
             set
             {
-                if (!_fInitialized || string.Compare(_path, value, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!_fInitialized || !string.Equals(_path, value, StringComparison.OrdinalIgnoreCase))
                 {
                     _path = value;
                     Refresh();
@@ -597,7 +597,7 @@ private void RefreshProducts()
                         int nStartIndex = packagePath.Length;
                         if ((strSubDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
                         {
-                            nStartIndex = nStartIndex + 1;
+                            nStartIndex += 1;
                         }
 
                         ExploreDirectory(strSubDirectory.Substring(nStartIndex), rootElement, packagePath);
@@ -1460,7 +1460,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                     }
 
                     if ((packageFileSource != null) && (packageFileDestination != null) &&
-                        ((packageFileCopy == null) || (String.Compare(packageFileCopy.Value, "False", StringComparison.InvariantCulture) != 0)))
+                        ((packageFileCopy == null) || (!String.Equals(packageFileCopy.Value, "False", StringComparison.InvariantCulture))))
                     {
                         // if this is the key for an external check, we will add it to the Resource Updater instead of copying the file
                         XmlNode subNode = null;
@@ -1612,7 +1612,7 @@ private static void ClearReadOnlyAttribute(string strFileName)
             FileAttributes attribs = File.GetAttributes(strFileName);
             if ((attribs & FileAttributes.ReadOnly) != 0)
             {
-                attribs = attribs & (~FileAttributes.ReadOnly);
+                attribs &= (~FileAttributes.ReadOnly);
                 File.SetAttributes(strFileName, attribs);
             }
         }
@@ -2092,7 +2092,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (publicKey == null || !publicKey.ToLowerInvariant().Equals(publicKeyAttribute.Value.ToLowerInvariant()))
+                    if (publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
@@ -2105,7 +2105,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     ReplaceAttribute(packageFileNode, HASH_ATTRIBUTE, fileHash);
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (!fileHash.ToLowerInvariant().Equals(hashAttribute.Value.ToLowerInvariant()))
+                    if (!fileHash.Equals(hashAttribute.Value, StringComparison.OrdinalIgnoreCase))
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", "Hash", builder.Name, fileSource));
                     }
diff --git a/src/Tasks/BootstrapperUtil/Product.cs b/src/Tasks/BootstrapperUtil/Product.cs
index 93fd74ef4ae..542b9749106 100644
--- a/src/Tasks/BootstrapperUtil/Product.cs
+++ b/src/Tasks/BootstrapperUtil/Product.cs
@@ -213,7 +213,7 @@ internal XmlValidationResults GetPackageValidationResults(string culture)
             return ValidationResults?.PackageResults(culture);
         }
 
-        internal bool ValidationPassed => ValidationResults == null || ValidationResults.ValidationPassed;
+        internal bool ValidationPassed => ValidationResults?.ValidationPassed != false;
 
         internal ProductValidationResults ValidationResults { get; }
     }
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 322979edfbb..990ee217fee 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -31,7 +31,7 @@ public class CodeTaskFactory : ITaskFactory
         /// This dictionary keeps track of custom references to compiled assemblies.  The in-memory assembly is loaded from a byte
         /// stream and as such its dependencies cannot be found unless they are in the MSBuild.exe directory or the GAC.  They
         /// cannot be found even if they are already loaded in the AppDomain.  This dictionary knows the FullName of the assembly
-        /// and a reference to the assembly itself.  In the <see cref="CurrentDomainOnAssemblyResolve"/> handler, the dictionary 
+        /// and a reference to the assembly itself.  In the <see cref="CurrentDomainOnAssemblyResolve"/> handler, the dictionary
         /// is used to return the loaded assemblies as a way to allow custom references that are not in the normal assembly Load
         /// context.
         /// </summary>
@@ -71,7 +71,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         private static readonly ConcurrentDictionary<FullTaskSpecification, Assembly> s_compiledTaskCache = new ConcurrentDictionary<FullTaskSpecification, Assembly>();
 
         /// <summary>
-        /// The default assemblies to reference when compiling inline code. 
+        /// The default assemblies to reference when compiling inline code.
         /// </summary>
         private static List<string> s_defaultReferencedAssemblies;
 
@@ -81,7 +81,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         private List<string> _referencedAssemblies;
 
         /// <summary>
-        /// Merged set of namespaces (default + specified) 
+        /// Merged set of namespaces (default + specified)
         /// </summary>
         private List<string> _usingNamespaces;
 
@@ -151,7 +151,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         public Type TaskType { get; private set; }
 
         /// <summary>
-        /// The assemblies that the codetaskfactory should reference by default. 
+        /// The assemblies that the codetaskfactory should reference by default.
         /// </summary>
         private static List<string> DefaultReferencedAssemblies
         {
@@ -624,7 +624,7 @@ private bool HasInvalidChildNodes(XmlNode parentNode, XmlNodeType[] allowedNodeT
         }
 
         /// <summary>
-        /// Add a reference assembly to the list of references passed to the compiler. We will try and load the assembly to make sure it is found 
+        /// Add a reference assembly to the list of references passed to the compiler. We will try and load the assembly to make sure it is found
         /// before sending it to the compiler. The reason we load here is that we will be using it in this appdomin anyways as soon as we are going to compile, which should be right away.
         /// </summary>
         [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadWithPartialName", Justification = "Necessary since we don't have the full assembly name. ")]
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 8c9c1718c32..c886278ade5 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -254,7 +254,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 // if returned namespace is null or its type is not System.String, fall back to the default 
                 // way of getting the type lib name (just to be safe)
-                if (data == null || string.Compare(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase) != 0)
+                if (data == null || !string.Equals(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase))
                 {
                     typeLibName = Marshal.GetTypeLibName(typeLib);
                     return true;
@@ -265,7 +265,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 if (typeLibName.Length >= 4)
                 {
-                    if (string.Compare(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase))
                     {
                         typeLibName = typeLibName.Substring(0, typeLibName.Length - 4);
                     }
@@ -328,6 +328,7 @@ internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool s
         /// Strips type library number from a type library path (for example, "ref.dll\2" becomes "ref.dll")
         /// </summary>
         /// <param name="typeLibPath">type library path with possible typelib number appended to it</param>
+        /// <param name="fileExists">Delegate to check whether the file exists</param>
         /// <returns>proper file path to the type library</returns>
         internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists fileExists)
         {
@@ -452,7 +453,7 @@ internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TY
                 return false;
             }
 
-            if (typeLibPath != null && typeLibPath.Length > 0)
+            if (!string.IsNullOrEmpty(typeLibPath))
             {
                 // We have to check for NULL here because QueryPathOfRegTypeLib() returns
                 // a BSTR with a NULL character appended to it.
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index 85e8cc3e3e2..9e433200cdd 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -134,7 +134,7 @@ internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYP
         /// </summary>
         internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(path, "path");
+            ErrorUtilities.VerifyThrowArgumentNull(path, nameof(path));
 
             this.taskItem = originalTaskItem;
 
diff --git a/src/Tasks/ComReferenceTypes.cs b/src/Tasks/ComReferenceTypes.cs
index c6b553c19ee..764d4baeded 100644
--- a/src/Tasks/ComReferenceTypes.cs
+++ b/src/Tasks/ComReferenceTypes.cs
@@ -20,7 +20,7 @@ internal static class ComReferenceTypes
         /// </summary>
         internal static bool IsTlbImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.tlbimp, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.tlbimp, StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -28,7 +28,7 @@ internal static bool IsTlbImp(string refType)
         /// </summary>
         internal static bool IsAxImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.aximp, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.aximp, StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -36,7 +36,7 @@ internal static bool IsAxImp(string refType)
         /// </summary>
         internal static bool IsPia(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.primary, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.primary, StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -44,7 +44,7 @@ internal static bool IsPia(string refType)
         /// </summary>
         internal static bool IsPiaOrTlbImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase));
         }
     }
 }
diff --git a/src/Tasks/CommandLineBuilderExtension.cs b/src/Tasks/CommandLineBuilderExtension.cs
index d2b8ba10fc7..6550ca7a004 100644
--- a/src/Tasks/CommandLineBuilderExtension.cs
+++ b/src/Tasks/CommandLineBuilderExtension.cs
@@ -267,7 +267,7 @@ internal void AppendSwitchIfNotNull
                             if (!string.IsNullOrEmpty(metadataValue))
                             {
                                 // Treat attribute as a boolean flag?
-                                if (treatAsFlags == null || treatAsFlags[i] == false)
+                                if (treatAsFlags == null || !treatAsFlags[i])
                                 {
                                     // Not a boolean flag.
                                     CommandLine.Append(',');
@@ -286,7 +286,7 @@ internal void AppendSwitchIfNotNull
                             }
                             else
                             {
-                                if (treatAsFlags == null || treatAsFlags[i] == false)
+                                if (treatAsFlags == null || !treatAsFlags[i])
                                 {
                                     // If the caller of this method asked us to add metadata
                                     // A, B, and C, and metadata A doesn't exist on the item,
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index dd7906d532b..4a8d4297fc1 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -695,7 +695,7 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                 // We only do the cheap check for identicalness here, we try the more expensive check
                 // of comparing the fullpaths of source and destination to see if they are identical,
                 // in the exception handler lower down.
-                else if (0 != String.Compare(
+                else if (!String.Equals(
                              sourceFileState.Name,
                              destinationFileState.Name,
                              StringComparison.OrdinalIgnoreCase))
@@ -892,7 +892,7 @@ private static bool PathsAreIdentical(string source, string destination)
             string fullSourcePath = Path.GetFullPath(source);
             string fullDestinationPath = Path.GetFullPath(destination);
             StringComparison filenameComparison = NativeMethodsShared.IsWindows ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
-            return (0 == String.Compare(fullSourcePath, fullDestinationPath, filenameComparison));
+            return (String.Equals(fullSourcePath, fullDestinationPath, filenameComparison));
         }
 
     	private static int GetParallelismFromEnvironment()
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index f4858c53010..af7321ea80e 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public class CreateCSharpManifestResourceName : CreateManifestResourceName
@@ -20,8 +20,8 @@ public class CreateCSharpManifestResourceName : CreateManifestResourceName
         protected override string SourceFileExtension => ".cs";
 
         /// <summary>
-        /// Utility function for creating a C#-style manifest name from 
-        /// a resource name. 
+        /// Utility function for creating a C#-style manifest name from
+        /// a resource name.
         /// </summary>
         /// <param name="fileName">The file name of the dependent (usually a .resx)</param>
         /// <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
@@ -64,7 +64,7 @@ The reason is that CreateManifestName can't be static because it is an
         }
 
         /// <summary>
-        /// Utility function for creating a C#-style manifest name from 
+        /// Utility function for creating a C#-style manifest name from
         /// a resource name. Note that this function attempts to emulate the
         /// Everret implementation of this code which can be found by searching for
         /// ComputeNonWFCResourceName() or ComputeWFCResourceName() in
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index 89f9d51c851..f53eee09666 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -64,7 +64,6 @@ public ITaskItem[] ResourceFiles
         /// The resulting manifest names.
         /// </summary>
         /// <value></value>
-
         [Output]
         public ITaskItem[] ManifestResourceNames { get; private set; }
 
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 568d4204343..4d656ba43ee 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public class CreateVisualBasicManifestResourceName : CreateManifestResourceName
@@ -18,8 +18,8 @@ public class CreateVisualBasicManifestResourceName : CreateManifestResourceName
         protected override string SourceFileExtension => ".vb";
 
         /// <summary>
-        /// Utility function for creating a VB-style manifest name from 
-        /// a resource name. 
+        /// Utility function for creating a VB-style manifest name from
+        /// a resource name.
         /// </summary>
         /// <param name="fileName">The file name of the dependent (usually a .resx)</param>
         /// <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
@@ -62,7 +62,7 @@ The reason is that CreateManifestName can't be static because it is an
         }
 
         /// <summary>
-        /// Utility function for creating a VB-style manifest name from 
+        /// Utility function for creating a VB-style manifest name from
         /// a resource name. Note that this function attempts to emulate the
         /// Everret implementation of this code which can be found by searching for
         /// ComputeNonWFCResourceName() or ComputeWFCResourceName() in
diff --git a/src/Tasks/Culture.cs b/src/Tasks/Culture.cs
index 30b61bd2c5b..6dc32800ee3 100644
--- a/src/Tasks/Culture.cs
+++ b/src/Tasks/Culture.cs
@@ -36,7 +36,7 @@ string dependentUponFilename
             info.culture = null;
             string parentName = dependentUponFilename ?? String.Empty;
 
-            if (0 == String.Compare(Path.GetFileNameWithoutExtension(parentName),
+            if (String.Equals(Path.GetFileNameWithoutExtension(parentName),
                                    Path.GetFileNameWithoutExtension(name),
                                    StringComparison.OrdinalIgnoreCase))
             {
@@ -57,7 +57,7 @@ string dependentUponFilename
 
                 // See if this is a valid culture name.
                 bool validCulture = false;
-                if ((cultureName != null) && (cultureName.Length > 1))
+                if ((cultureName?.Length > 1))
                 {
                     // ... strip the "." to make "en-US"
                     cultureName = cultureName.Substring(1);
diff --git a/src/Tasks/Delegate.cs b/src/Tasks/Delegate.cs
index f9363684e4b..563f6c39e0e 100644
--- a/src/Tasks/Delegate.cs
+++ b/src/Tasks/Delegate.cs
@@ -22,6 +22,7 @@ namespace Microsoft.Build.Tasks
     /// File SetAttributes delegate
     /// </summary>
     /// <param name="path">The path to set attributes for.</param>
+    /// <param name="attributes">The actual file attributes.</param>
     internal delegate void SetAttributes(string path, FileAttributes attributes);
 
     /// <summary>
@@ -82,8 +83,10 @@ namespace Microsoft.Build.Tasks
     /// assemblies and  the list of scatter files.
     /// </summary>
     /// <param name="path">Path to the assembly.</param>
+    /// <param name="assemblyMetadataCache">Assembly metadata cache.</param>
     /// <param name="dependencies">Receives the list of dependencies.</param>
     /// <param name="scatterFiles">Receives the list of associated scatter files.</param>
+    /// <param name="frameworkNameAttribute">The framework name</param>
     internal delegate void GetAssemblyMetadata
     (
         string path,
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 67b4b936a7c..f8306894c3b 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -79,7 +79,7 @@ internal bool HasFileChanged()
             FileInfo info = FileUtilities.GetFileInfoNoThrow(filename);
 
             // Obviously if the file no longer exists then we are not up to date.
-            if (info == null || !info.Exists)
+            if (info?.Exists != true)
             {
                 return true;
             }
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index f3cbccfde1d..1f9181ec72e 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -131,6 +131,7 @@ private async Task<bool> ExecuteAsync()
         /// Attempts to download the file.
         /// </summary>
         /// <param name="uri">The parsed <see cref="Uri"/> of the request.</param>
+        /// <param name="cancellationToken">The cancellation token for the task.</param>
         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
diff --git a/src/Tasks/ErrorFromResources.cs b/src/Tasks/ErrorFromResources.cs
index 596fc974f4c..83c5f106d6a 100644
--- a/src/Tasks/ErrorFromResources.cs
+++ b/src/Tasks/ErrorFromResources.cs
@@ -51,7 +51,7 @@ public override bool Execute()
                 string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, Log.FormatResourceString(Resource, Arguments), out string errorCode);
 
                 // If the user specifies a code, that should override. 
-                Code = Code ?? errorCode;
+                Code ??= errorCode;
 
                 Log.LogError(null, Code, HelpKeyword, File, 0, 0, 0, 0, message);
             }
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 35db2490c74..df817422bfd 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -617,7 +617,6 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
 
                 commandLine.AppendFileNameIfNotNull(batchFileForCommandLine);
             }
-            
         }
 
         #endregion
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index 39ad392e8f8..0a6095e5d58 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -115,15 +115,12 @@ public override bool Execute()
 
         internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         {
-            switch (encoding)
+            return encoding switch
             {
-                case Tasks.HashEncoding.Hex:
-                    return ConversionUtilities.ConvertByteArrayToHex(hash);
-                case Tasks.HashEncoding.Base64:
-                    return Convert.ToBase64String(hash);
-                default:
-                    throw new NotImplementedException();
-            }
+                Tasks.HashEncoding.Hex => ConversionUtilities.ConvertByteArrayToHex(hash),
+                Tasks.HashEncoding.Base64 => Convert.ToBase64String(hash),
+                _ => throw new NotImplementedException(),
+            };
         }
 
         internal static bool TryParseHashEncoding(string value, out HashEncoding encoding)
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index f6e8010e4e9..c979b21be5b 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -148,7 +148,6 @@ public FileDirInfo(string filename)
                             IsReadOnly = fileInfo.IsReadOnly;
                             LastWriteTimeUtc = fileInfo.LastWriteTimeUtc;
                             Length = fileInfo.Length;
-
                         }
                         else
                         {
@@ -162,7 +161,6 @@ public FileDirInfo(string filename)
                                 IsReadOnly = false;
                                 LastWriteTimeUtc = directoryInfo.LastWriteTimeUtc;
                             }
-
                         }
                     }
                 }
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index 1e78ee56ee2..7aa4cfd5f95 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -28,7 +28,6 @@ private enum DependencyType { Install, Prerequisite };
         protected abstract bool OnManifestResolved(Manifest manifest);
         protected abstract Type GetObjectType();
 
-
         protected GenerateManifestBase() : base(AssemblyResources.PrimaryResources, "MSBuild.")
         {
         }
@@ -92,24 +91,14 @@ protected internal AssemblyReference AddAssemblyFromItem(ITaskItem item)
                 return null;
             }
 
-            AssemblyReferenceType referenceType;
             AssemblyType assemblyType = GetItemAssemblyType(item);
-            switch (assemblyType)
+            AssemblyReferenceType referenceType = assemblyType switch
             {
-                case AssemblyType.Managed:
-                    referenceType = AssemblyReferenceType.ManagedAssembly;
-                    break;
-                case AssemblyType.Native:
-                    referenceType = AssemblyReferenceType.NativeAssembly;
-                    break;
-                case AssemblyType.Satellite:
-                    referenceType = AssemblyReferenceType.ManagedAssembly;
-                    break;
-                default:
-                    referenceType = AssemblyReferenceType.Unspecified;
-                    break;
-            }
-
+                AssemblyType.Managed => AssemblyReferenceType.ManagedAssembly,
+                AssemblyType.Native => AssemblyReferenceType.NativeAssembly,
+                AssemblyType.Satellite => AssemblyReferenceType.ManagedAssembly,
+                _ => AssemblyReferenceType.Unspecified,
+            };
             DependencyType dependencyType = GetItemDependencyType(item);
             AssemblyReference assembly;
             if (dependencyType == DependencyType.Install)
@@ -252,12 +241,12 @@ private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, A
                     // Don't need publicKeyToken attribute for non-ClickOnce case
                     publicKeyToken = null;
                     // Language attribute should be omitted if neutral
-                    if (String.Compare(culture, "neutral", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(culture, "neutral", StringComparison.OrdinalIgnoreCase))
                     {
                         culture = null;
                     }
                     // WinXP loader doesn't understand "msil"
-                    if (String.Compare(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase))
                     {
                         _processorArchitecture = null;
                     }
@@ -330,7 +319,7 @@ protected internal FileReference FindFileFromItem(ITaskItem item)
             }
             foreach (FileReference file in _manifest.FileReferences)
             {
-                if (String.Compare(targetPath, file.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, file.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return file;
                 }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index cb87f14e533..8551c4b2824 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -50,7 +50,6 @@ namespace Microsoft.Build.Tasks
     public sealed partial class GenerateResource : TaskExtension
     {
 
-
 #region Fields
 
         // This cache helps us track the linked resource files listed inside of a resx resource file
@@ -627,7 +626,7 @@ private void GenerateResGenCommandLineWithoutResources(CommandLineBuilderExtensi
         {
             // Throw an internal error, since this method should only ever get called by other aspects of this task, not
             // anything that the user touches.
-            ErrorUtilities.VerifyThrowInternalNull(resGenCommand, "resGenCommand");
+            ErrorUtilities.VerifyThrowInternalNull(resGenCommand, nameof(resGenCommand));
 
             // append the /useSourcePath flag if requested.
             if (UseSourcePath)
@@ -692,7 +691,6 @@ public override bool Execute()
                     Sources = newSources.ToArray();
                 }
 
-
                 // If there are no sources to process, just return (with success) and report the condition.
                 if ((Sources == null) || (Sources.Length == 0))
                 {
@@ -1136,13 +1134,13 @@ private bool GenerateResourcesUsingResGen(List<ITaskItem> inputsToProcess, List<
 #endif
         }
 
-
 #if FEATURE_RESGEN
         /// <summary>
         /// Given an instance of the ResGen task with everything but the strongly typed
         /// resource-related parameters filled out, execute the task and return the result
         /// </summary>
-        /// <param name="resGen">The task to execute.</param>
+        /// <param name="inputsToProcess">Input files to give to resgen.exe.</param>
+        /// <param name="outputsToProcess">Output files to give to resgen.exe.</param>
         private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess, List<ITaskItem> outputsToProcess)
         {
             ErrorUtilities.VerifyThrow(inputsToProcess.Count != 0, "There should be resource files to process");
@@ -1265,7 +1263,8 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
         /// Given an instance of the ResGen task with everything but the strongly typed
         /// resource-related parameters filled out, execute the task and return the result
         /// </summary>
-        /// <param name="resGen">The task to execute.</param>
+        /// <param name="inputsToProcess">Input files to give to resgen.exe.</param>
+        /// <param name="outputsToProcess">Output files to give to resgen.exe.</param>
         private bool GenerateStronglyTypedResourceUsingResGen(List<ITaskItem> inputsToProcess, List<ITaskItem> outputsToProcess)
         {
             ErrorUtilities.VerifyThrow(inputsToProcess.Count == 1 && outputsToProcess.Count == 1, "For STR, there should only be one input and one output.");
@@ -1302,7 +1301,6 @@ private bool GenerateStronglyTypedResourceUsingResGen(List<ITaskItem> inputsToPr
         /// Factoring out the setting of the default parameters to the
         /// ResGen task.
         /// </summary>
-        /// <param name="resGen"></param>
         private ResGen CreateResGenTaskWithDefaultParameters()
         {
             ResGen resGen = new ResGen();
@@ -1391,7 +1389,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
                     // However, our cache will sometimes record all the info we need (for incremental builds).
                     string sourceFileName = Sources[i].ItemSpec;
                     ResGenDependencies.PortableLibraryFile library = _cache.TryGetPortableLibraryInfo(sourceFileName);
-                    if (library != null && library.AllOutputFilesAreUpToDate())
+                    if (library?.AllOutputFilesAreUpToDate() == true)
                     {
                         AppendCachedOutputTaskItems(library, cachedOutputFiles);
                     }
@@ -1442,7 +1440,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
         /// <summary>
         /// Given a cached portable library that is up to date, create ITaskItems to represent the output of the task, as if we did real work.
         /// </summary>
-        /// <param name="library">The portable library cache entry to extract output files & metadata from.</param>
+        /// <param name="library">The portable library cache entry to extract output files and metadata from.</param>
         /// <param name="cachedOutputFiles">List of output files produced from the cache.</param>
         private void AppendCachedOutputTaskItems(ResGenDependencies.PortableLibraryFile library, List<ITaskItem> cachedOutputFiles)
         {
@@ -1741,7 +1739,6 @@ private void UpdateNewestUncorrelatedInputWriteTime()
         /// needed, it should always err on the side of returning 'true'. This
         /// is because a separate AppDomain, while slow to create, is always safe.
         /// </summary>
-        /// <param name="sources">The list of .resx files.</param>
         /// <returns></returns>
         private bool NeedSeparateAppDomain()
         {
@@ -1755,15 +1752,15 @@ private bool NeedSeparateAppDomain()
             {
                 string extension = Path.GetExtension(source.ItemSpec);
 
-                if (String.Compare(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".exe", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".exe", StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
 
-                if (String.Compare(extension, ".resx", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".resw", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(extension, ".resx", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".resw", StringComparison.OrdinalIgnoreCase))
                 {
                     XmlReader reader = null;
                     string name = null;
@@ -2160,7 +2157,7 @@ private void RecordFilesWritten()
             }
 
             // Add any state file
-            if (StateFile != null && StateFile.ItemSpec.Length > 0)
+            if (StateFile?.ItemSpec.Length > 0)
             {
                 // It's possible the file wasn't actually written (eg the path was invalid)
                 // We can't easily tell whether that happened here, and I think it's fine to add it anyway.
@@ -2431,7 +2428,7 @@ internal void Run(
 #if !FEATURE_ASSEMBLYLOADCONTEXT
             // If references were passed in, we will have to give the ResxResourceReader an object
             // by which it can resolve types that are referenced from within the .RESX.
-            if ((_assemblyFiles != null) && (_assemblyFiles.Length > 0))
+            if ((_assemblyFiles?.Length > 0))
             {
                 _typeResolver = new AssemblyNamesTypeResolutionService(_assemblyFiles);
             }
@@ -2509,7 +2506,7 @@ internal Assembly ResolveAssembly(object sender, ResolveEventArgs args)
 
                     if (candidateAssemblyName != null)
                     {
-                        if (String.Compare(requestedAssemblyName.Name, candidateAssemblyName.Name, StringComparison.CurrentCultureIgnoreCase) == 0)
+                        if (String.Equals(requestedAssemblyName.Name, candidateAssemblyName.Name, StringComparison.CurrentCultureIgnoreCase))
                         {
                             return Assembly.UnsafeLoadFrom(_assemblyFiles[i].ItemSpec);
                         }
@@ -2563,7 +2560,7 @@ private void PopulateAssemblyNames()
         /// </summary>
         /// <remarks>Uses the input and output file extensions to determine their format</remarks>
         /// <param name="inFile">Input resources file</param>
-        /// <param name="outFile">Output resources file</param>
+        /// <param name="outFileOrDir">Output resources file or directory</param>
         /// <returns>True if conversion was successful, otherwise false</returns>
         private bool ProcessFile(string inFile, string outFileOrDir)
         {
@@ -2782,7 +2779,7 @@ e is SerializationException ||
                 }
 
                 if (currentOutputDirectory != null &&
-                    currentOutputDirectoryAlreadyExisted == false)
+                    !currentOutputDirectoryAlreadyExisted)
                 {
                     // Do not annoy the user by removing an empty directory we did not create.
                     try
@@ -2932,23 +2929,23 @@ private Format GetFormat(string filename)
                 return Format.Error;
             }
 
-            if (String.Compare(extension, ".txt", StringComparison.OrdinalIgnoreCase) == 0 ||
-                String.Compare(extension, ".restext", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(extension, ".txt", StringComparison.OrdinalIgnoreCase) ||
+                String.Equals(extension, ".restext", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Text;
             }
-            else if (String.Compare(extension, ".resx", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".resw", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resx", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".resw", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.XML;
             }
-            else if (String.Compare(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".exe", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".exe", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Assembly;
             }
-            else if (String.Compare(extension, ".resources", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resources", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Binary;
             }
@@ -3255,6 +3252,8 @@ internal void ReadAssemblyResources(String name, String outFileOrDir)
         /// <param name="name">Assembly's file name</param>
         /// <param name="assemblyName">AssemblyName of this assembly</param>
         /// <param name="culture">Assembly's CultureInfo</param>
+        /// <param name="a">The actual Assembly</param>
+        /// <param name="mainAssembly">Whether this is the main assembly</param>
         private NeutralResourcesLanguageAttribute CheckAssemblyCultureInfo(String name, AssemblyName assemblyName, CultureInfo culture, Assembly a, bool mainAssembly)
         {
             NeutralResourcesLanguageAttribute neutralResourcesLanguageAttribute = null;
@@ -3303,6 +3302,7 @@ private static bool ContainsProperlyNamedResourcesFiles(Assembly a, bool mainAss
         /// <summary>
         /// Write resources from the resources ArrayList to the specified output file
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="filename">Output resources file</param>
         private void WriteResources(ReaderInfo reader, String filename)
         {
@@ -3321,7 +3321,6 @@ private void WriteResources(ReaderInfo reader, String filename)
 #endif
                     break;
 
-
                 case Format.Assembly:
                     _logger.LogErrorFromResources("GenerateResource.CannotWriteAssembly", filename);
                     break;
@@ -3411,8 +3410,10 @@ private bool HaveSystemResourcesExtensionsReference
         /// <summary>
         /// Create a strongly typed resource class
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="outFile">Output resource filename, for defaulting the class filename</param>
         /// <param name="inputFileName">Input resource filename, for error messages</param>
+        /// <param name="sourceFile">The generated strongly typed filename</param>
         private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, String inputFileName, out String sourceFile)
         {
             CodeDomProvider provider = null;
@@ -3498,6 +3499,7 @@ public static string GenerateDefaultStronglyTypedFilename(CodeDomProvider provid
         /// Broken out here so it can be called from GenerateResource class.
         /// Not a true "TryXXX" method, as it still throws if it encounters an exception it doesn't expect.
         /// </comments>
+        /// <param name="logger">Logger helper.</param>
         /// <param name="stronglyTypedLanguage">The language to create a provider for.</param>
         /// <param name="provider">The provider in question, if one is successfully created.</param>
         /// <returns>True if the provider was successfully created, false otherwise.</returns>
@@ -3527,6 +3529,7 @@ public static bool TryCreateCodeDomProvider(TaskLoggingHelper logger, string str
         /// <summary>
         /// Read resources from an XML or binary format file
         /// </summary>
+        /// <param name="readerInfo">Reader info</param>
         /// <param name="reader">Appropriate IResourceReader</param>
         /// <param name="fileName">Filename, for error messages</param>
         private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String fileName)
@@ -3547,6 +3550,7 @@ private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String
         /// <summary>
         /// Read resources from a text format file
         /// </summary>
+        /// <param name="reader">Reader info</param>
         /// <param name="fileName">Input resources filename</param>
         private void ReadTextResources(ReaderInfo reader, String fileName)
         {
@@ -3612,7 +3616,7 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                     // sign.  Deal with it.
                     if (name[name.Length - 1] == ' ')
                     {
-                        name.Length = name.Length - 1;
+                        name.Length -= 1;
                     }
                     ch = sr.Read(); // move past =
                     // If it exists, move past the first space after the equals sign.
@@ -3718,11 +3722,11 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
             }
         }
 
-
         /// <summary>
         /// Write resources to an XML or binary format resources file.
         /// </summary>
         /// <remarks>Closes writer automatically</remarks>
+        /// <param name="reader">Reader information</param>
         /// <param name="writer">Appropriate IResourceWriter</param>
         private void WriteResources(ReaderInfo reader,
             IResourceWriter writer)
@@ -3763,6 +3767,7 @@ private void WriteResources(ReaderInfo reader,
         /// <summary>
         /// Write resources to a text format resources file
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="fileName">Output resources file</param>
         private void WriteTextResources(ReaderInfo reader, String fileName)
         {
@@ -3796,6 +3801,7 @@ private void WriteTextResources(ReaderInfo reader, String fileName)
         /// <summary>
         /// Add a resource from a text file to the internal data structures
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="name">Resource name</param>
         /// <param name="value">Resource value</param>
         /// <param name="inputFileName">Input file for messages</param>
@@ -3820,10 +3826,10 @@ private void AddResource(ReaderInfo reader, IResource entry, String inputFileNam
             reader.resourcesHashTable.Add(entry.Name, entry);
         }
 
-
         /// <summary>
         /// Add a resource from an XML or binary format file to the internal data structures
         /// </summary>
+        /// <param name="reader">Reader info</param>
         /// <param name="name">Resource name</param>
         /// <param name="value">Resource value</param>
         /// <param name="inputFileName">Input file for messages</param>
@@ -3934,7 +3940,7 @@ internal int LinePosition
         }
 
         /// <summary>
-        /// For flow of control & passing sufficient error context back
+        /// For flow of control and passing sufficient error context back
         /// from ReadTextResources
         /// </summary>
         [Serializable]
@@ -4014,6 +4020,7 @@ public Assembly GetAssembly(AssemblyName name)
         /// Not implemented.  Not called by the ResxResourceReader.
         /// </summary>
         /// <param name="name"></param>
+        /// <param name="throwOnError"></param>
         /// <returns></returns>
         public Assembly GetAssembly(AssemblyName name, bool throwOnError)
         {
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index a8e07666114..7a922908366 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -65,7 +65,7 @@ public override bool Execute()
             {
                 // If it's a known zone and the user add additional permission to it.
                 if (!String.IsNullOrEmpty(TargetZone)
-                    && trustInfo.PermissionSet != null && trustInfo.PermissionSet.Count > 0
+                    && trustInfo.PermissionSet?.Count > 0
                     && !String.Equals(TargetZone, Custom, StringComparison.OrdinalIgnoreCase))
                 {
                     Log.LogErrorFromResources("GenerateManifest.KnownTargetZoneCannotHaveAdditionalPermissionType");
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index 880a2f62f0b..e5e8195e1f8 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -149,7 +149,7 @@ public override bool Execute()
 
             var outputItems = new List<ITaskItem>();
 
-            if (installedSDKs != null && installedSDKs.Count > 0)
+            if (installedSDKs?.Count > 0)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "GetInstalledSDKs.FoundSDKs", installedSDKs.Count);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetInstalledSDKs.ListInstalledSDKs");
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index e5201d9b62b..408bf6f3435 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -192,7 +192,7 @@ public override bool Execute()
             {
                 _tfmPaths = GetPaths(RootPath, TargetFrameworkFallbackSearchPaths, moniker);
 
-                if (_tfmPaths != null && _tfmPaths.Count > 0)
+                if (_tfmPaths?.Count > 0)
                 {
                     TargetFrameworkMonikerDisplayName = ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(_tfmPaths[0], moniker);
                 }
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 4393c520267..4e7bffa6f13 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -110,7 +110,7 @@ public ITaskItem[] ResolvedSDKReferences
         }
 
         /// <summary>
-        /// Extensions which should be considered reference files, we will look for 
+        /// Extensions which should be considered reference files, we will look for
         /// the files in the order they are specified in the array.
         /// </summary>
         public string[] ReferenceExtensions
@@ -367,7 +367,7 @@ private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity,
                 // If the SDK is manifest driven we want to grab them from the ApiContracts in the manifest if possible- will only happen if TargetSdk is identified
                 string[] manifestReferencePaths = GetReferencePathsFromManifest(resolvedSDKReference);
 
-                if (manifestReferencePaths != null && manifestReferencePaths.Length > 0)
+                if (manifestReferencePaths?.Length > 0)
                 {
                     // Found ApiContract references, use those
                     foreach (string manifestReferencePath in manifestReferencePaths)
@@ -481,7 +481,7 @@ private void GenerateOutputItems()
                             outputItem.SetMetadata(ItemMetadataNames.imageRuntime, referenceInfo.ImageRuntime);
                         }
 
-                        if (referenceInfo != null && referenceInfo.IsWinMD)
+                        if (referenceInfo?.IsWinMD == true)
                         {
                             outputItem.SetMetadata(ItemMetadataNames.winMDFile, "true");
 
@@ -606,7 +606,7 @@ private void GatherReferenceAssemblies(HashSet<ResolvedReferenceAssembly> resolv
         }
 
         /// <summary>
-        /// Gather the redist files from from the redist directory.
+        /// Gather the redist files from the redist directory.
         /// </summary>
         private void GatherRedistFiles(HashSet<ResolvedRedistFile> resolvedRedistFiles, ITaskItem sdkReference, string redistFilePath, SDKInfo info)
         {
@@ -1011,7 +1011,7 @@ internal SDKInfo GetCacheFileInfoFromSDK(string sdkRootDirectory, string[] sdkMa
                 directoriesToHash.AddRange(referenceDirectories);
                 directoriesToHash.AddRange(redistDirectories);
 
-                if (sdkManifestReferences != null && sdkManifestReferences.Length > 0)
+                if (sdkManifestReferences?.Length > 0)
                 {
                     // Manifest driven- get the info from the known list
                     PopulateReferencesDictionaryFromManifestPaths(directoryToFileList, references, sdkManifestReferences);
@@ -1078,7 +1078,7 @@ private static void PopulateRedistDictionaryFromPaths(ConcurrentDictionary<strin
             }
 
             /// <summary>
-            /// Is the assembly list cache file up to date. 
+            /// Is the assembly list cache file up to date.
             /// This is done by comparing the last write time of the cache file to the last write time of the code.
             /// If our code is newer than the last write time of the cache file then there may be some different serialization used so we should say it is out of date and just regenerate it.
             /// </summary>
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index 241235d223b..c822fa90f90 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -42,7 +42,7 @@ public class Hash : TaskExtension
         /// </summary>
         public override bool Execute()
         {
-            if (ItemsToHash != null && ItemsToHash.Length > 0)
+            if (ItemsToHash?.Length > 0)
             {
                 using (var sha1 = SHA1.Create())
                 {
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index 9b343227cef..6624a318f53 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -284,43 +284,21 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
 
         private static Exception GetException(int res, string apiName, string message)
         {
-            string reason;
-            switch (res)
+            string reason = res switch
             {
-                case ERROR_ACCESS_DENIED:
-                    reason = "Access is denied.";
-                    break;
-                case ERROR_SEM_TIMEOUT:
-                    reason = "A Restart Manager function could not obtain a Registry write mutex in the allotted time. " +
-                             "A system restart is recommended because further use of the Restart Manager is likely to fail.";
-                    break;
-                case ERROR_BAD_ARGUMENTS:
-                    reason = "One or more arguments are not correct. This error value is returned by the Restart Manager " +
-                             "function if a NULL pointer or 0 is passed in a parameter that requires a non-null and non-zero value.";
-                    break;
-                case ERROR_MAX_SESSIONS_REACHED:
-                    reason = "The maximum number of sessions has been reached.";
-                    break;
-                case ERROR_WRITE_FAULT:
-                    reason = "An operation was unable to read or write to the registry.";
-                    break;
-                case ERROR_OUTOFMEMORY:
-                    reason = "A Restart Manager operation could not complete because not enough memory was available.";
-                    break;
-                case ERROR_CANCELLED:
-                    reason = "The current operation is canceled by user.";
-                    break;
-                case ERROR_MORE_DATA:
-                    reason = "More data is available.";
-                    break;
-                case ERROR_INVALID_HANDLE:
-                    reason = "No Restart Manager session exists for the handle supplied.";
-                    break;
-                default:
-                    reason = $"0x{res:x8}";
-                    break;
-            }
-
+                ERROR_ACCESS_DENIED => "Access is denied.",
+                ERROR_SEM_TIMEOUT => "A Restart Manager function could not obtain a Registry write mutex in the allotted time. " +
+   "A system restart is recommended because further use of the Restart Manager is likely to fail.",
+                ERROR_BAD_ARGUMENTS => "One or more arguments are not correct. This error value is returned by the Restart Manager " +
+"function if a NULL pointer or 0 is passed in a parameter that requires a non-null and non-zero value.",
+                ERROR_MAX_SESSIONS_REACHED => "The maximum number of sessions has been reached.",
+                ERROR_WRITE_FAULT => "An operation was unable to read or write to the registry.",
+                ERROR_OUTOFMEMORY => "A Restart Manager operation could not complete because not enough memory was available.",
+                ERROR_CANCELLED => "The current operation is canceled by user.",
+                ERROR_MORE_DATA => "More data is available.",
+                ERROR_INVALID_HANDLE => "No Restart Manager session exists for the handle supplied.",
+                _ => $"0x{res:x8}",
+            };
             throw new Win32Exception(res, $"{message} ({apiName}() error {res}: {reason})");
         }
     }
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 88abe02d007..de2da27930b 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -199,7 +199,7 @@ public override bool Execute()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators?.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 655ac5b8e9b..1f0e1cc3d6a 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -194,7 +194,6 @@ public bool IsClickOnceManifest
             set => _isClickOnceManifest = value;
         }
 
-
         /// <summary>
         /// Specifies the maximum allowable length of a file path in a ClickOnce application deployment.
         /// If this value is specified, then the length of each file path in the application is checked against this limit.
@@ -414,7 +413,7 @@ private void ValidateCom()
             {
                 if (assembly.ReferenceType == AssemblyReferenceType.NativeAssembly && !assembly.IsPrerequisite && !String.IsNullOrEmpty(assembly.ResolvedPath))
                 {
-                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath); ;
+                    ComInfo[] comInfoArray = ManifestReader.GetComInfo(assembly.ResolvedPath); 
                     if (comInfoArray != null)
                     {
                         foreach (ComInfo comInfo in comInfoArray)
@@ -632,7 +631,7 @@ private void ValidateReferencesForClickOnceApplication()
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (targetPathList[key] == false)
+                    else if (!targetPathList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", assembly.ToString());
                         targetPathList[key] = true; // only warn once per path
@@ -675,7 +674,7 @@ private void ValidateReferencesForClickOnceApplication()
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (targetPathList[key] == false)
+                    else if (!targetPathList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", file.TargetPath);
                         targetPathList[key] = true; // only warn once per path
@@ -705,7 +704,7 @@ private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustI
             }
             else
             {
-                if (assembly.AssemblyIdentity != null && assembly.AssemblyIdentity.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion))
+                if (assembly.AssemblyIdentity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
                 {
                     // if the binary is targeting v4.0 and it has the transparent attribute then we may allow partially trusted callers.
                     if (assembly.IsPrimary
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 0c09b3e58d9..8f50a5387fd 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -404,7 +404,7 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
             string fullName = GetFullName(FullNameFlags.Default);
             foreach (RedistList list in redistDictionary.Values)
             {
-                if (list != null && list.IsFrameworkAssembly(fullName))
+                if (list?.IsFrameworkAssembly(fullName) == true)
                 {
                     return true;
                 }
diff --git a/src/Tasks/ManifestUtil/AssemblyReference.cs b/src/Tasks/ManifestUtil/AssemblyReference.cs
index bebb3b3b03f..81c741db55d 100644
--- a/src/Tasks/ManifestUtil/AssemblyReference.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReference.cs
@@ -85,7 +85,7 @@ internal bool IsVirtual
             {
                 if (AssemblyIdentity == null)
                     return false;
-                if (String.Compare(AssemblyIdentity.Name, Constants.CLRPlatformAssemblyName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(AssemblyIdentity.Name, Constants.CLRPlatformAssemblyName, StringComparison.OrdinalIgnoreCase))
                     return true;
                 else
                     return false;
@@ -102,7 +102,6 @@ public AssemblyReferenceType ReferenceType
             set { _referenceType = value; }
         }
 
-
         /// <summary>
         /// True if the reference is specified in the project file, false if it is added to the manifest as a result
         /// of computing the closure of all project references.
diff --git a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
index e09397b053a..2b81f70979d 100644
--- a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
@@ -79,10 +79,10 @@ public AssemblyReference Find(string name)
             }
             foreach (AssemblyReference a in _list)
             {
-                if (a.AssemblyIdentity != null && String.Compare(
+                if (a.AssemblyIdentity != null && String.Equals(
                         name,
                         a.AssemblyIdentity.Name,
-                        StringComparison.OrdinalIgnoreCase) == 0)
+                        StringComparison.OrdinalIgnoreCase))
                 {
                     return a;
                 }
@@ -156,7 +156,7 @@ public AssemblyReference FindTargetPath(string targetPath)
             }
             foreach (AssemblyReference a in _list)
             {
-                if (String.Compare(targetPath, a.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, a.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return a;
                 }
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 1f4766a09dc..107adb290e2 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -7,6 +7,9 @@
 using System.Globalization;
 using System.Resources;
 using System.Runtime.InteropServices;
+#if RUNTIME_TYPE_NETCORE
+using System.Runtime.InteropServices.ComTypes;
+#endif
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -46,7 +49,11 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
             catch (COMException) { }
 
 #pragma warning disable 618
+#if RUNTIME_TYPE_NETCORE
+            ITypeLib tlib = (ITypeLib)obj;
+#else
             UCOMITypeLib tlib = (UCOMITypeLib)obj;
+#endif
             if (tlib != null)
             {
                 IntPtr typeLibAttrPtr = IntPtr.Zero;
@@ -67,7 +74,11 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
                     tlib.GetTypeInfoType(i, out TYPEKIND tkind);
                     if (tkind == TYPEKIND.TKIND_COCLASS)
                     {
+#if RUNTIME_TYPE_NETCORE
+                        tlib.GetTypeInfo(i, out ITypeInfo tinfo);
+#else
                         tlib.GetTypeInfo(i, out UCOMITypeInfo tinfo);
+#endif
 
                         IntPtr tinfoAttrPtr = IntPtr.Zero;
                         tinfo.GetTypeAttr(out tinfoAttrPtr);
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index da358580c54..687ea0d65a6 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -137,7 +137,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
 
             IList<string> referenceAssemblyPaths = GetPathToReferenceAssemblies(frameworkName);
 
-            if (referenceAssemblyPaths != null && referenceAssemblyPaths.Count > 0)
+            if (referenceAssemblyPaths?.Count > 0)
             {
                 // the first one in the list is the reference assembly path for the requested TFM
                 string referenceAssemblyPath = referenceAssemblyPaths[0];
@@ -232,7 +232,6 @@ private static string GetInstallableFramework(string redistListFilePath)
             return installableFramework;
         }
 
-
         private static CompatibleFramework GetSubsetCompatFramework(FrameworkNameVersioning frameworkName)
         {
             CompatibleFramework compat = GetFullCompatFramework(frameworkName);
@@ -411,7 +410,7 @@ public string MinimumRequiredVersion
         internal override void OnAfterLoad()
         {
             base.OnAfterLoad();
-            if (_entryPoint == null && AssemblyReferences != null && AssemblyReferences.Count > 0)
+            if (_entryPoint == null && AssemblyReferences?.Count > 0)
             {
                 _entryPoint = AssemblyReferences[0];
                 _entryPoint.ReferenceType = AssemblyReferenceType.ClickOnceManifest;
@@ -594,8 +593,7 @@ private void ValidateEntryPoint()
                         }
                         else
                         {
-                            if (entryPointManifest.FileAssociations != null &&
-                                entryPointManifest.FileAssociations.Count > 0)
+                            if (entryPointManifest.FileAssociations?.Count > 0)
                             {
                                 OutputMessages.AddErrorMessage("GenerateManifest.FileAssociationsNotInstalled");
                             }
diff --git a/src/Tasks/ManifestUtil/FileReference.cs b/src/Tasks/ManifestUtil/FileReference.cs
index 1b46df71c7b..69c418bb40a 100644
--- a/src/Tasks/ManifestUtil/FileReference.cs
+++ b/src/Tasks/ManifestUtil/FileReference.cs
@@ -83,7 +83,7 @@ internal bool ImportComComponent(string path, OutputMessageCollection outputMess
         [XmlIgnore]
         public bool IsDataFile
         {
-            get => String.Compare(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase) == 0;
+            get => String.Equals(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase);
             set => _writeableType = value ? "applicationData" : null;
         }
 
@@ -365,12 +365,12 @@ public bool Versioned
         {
             get
             {
-                if (String.Compare(_versioned, "yes", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(_versioned, "yes", StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
 
-                if (String.Compare(_versioned, "no", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(_versioned, "no", StringComparison.OrdinalIgnoreCase))
                 {
                     return false;
                 }
diff --git a/src/Tasks/ManifestUtil/FileReferenceCollection.cs b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
index d044fba2cbc..25be81c3805 100644
--- a/src/Tasks/ManifestUtil/FileReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
@@ -79,7 +79,7 @@ public FileReference FindTargetPath(string targetPath)
             }
             foreach (FileReference f in _list)
             {
-                if (String.Compare(targetPath, f.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, f.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return f;
                 }
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index d6c882667d7..13a69ff34fc 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -424,21 +424,13 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
 
             if (a.AssemblyIdentity == null)
             {
-                switch (a.ReferenceType)
+                a.AssemblyIdentity = a.ReferenceType switch
                 {
-                    case AssemblyReferenceType.ClickOnceManifest:
-                        a.AssemblyIdentity = AssemblyIdentity.FromManifest(a.ResolvedPath);
-                        break;
-                    case AssemblyReferenceType.ManagedAssembly:
-                        a.AssemblyIdentity = AssemblyIdentity.FromManagedAssembly(a.ResolvedPath);
-                        break;
-                    case AssemblyReferenceType.NativeAssembly:
-                        a.AssemblyIdentity = AssemblyIdentity.FromNativeAssembly(a.ResolvedPath);
-                        break;
-                    default:
-                        a.AssemblyIdentity = AssemblyIdentity.FromFile(a.ResolvedPath);
-                        break;
-                }
+                    AssemblyReferenceType.ClickOnceManifest => AssemblyIdentity.FromManifest(a.ResolvedPath),
+                    AssemblyReferenceType.ManagedAssembly => AssemblyIdentity.FromManagedAssembly(a.ResolvedPath),
+                    AssemblyReferenceType.NativeAssembly => AssemblyIdentity.FromNativeAssembly(a.ResolvedPath),
+                    _ => AssemblyIdentity.FromFile(a.ResolvedPath),
+                };
             }
 
             if (!a.IsPrerequisite)
@@ -597,7 +589,7 @@ private void ValidateReferences()
                     {
                         identityList.Add(key, false);
                     }
-                    else if (identityList[key] == false)
+                    else if (!identityList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateAssemblyIdentity", identity);
                         identityList[key] = true; // only warn once per identity
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index be17ffc5e97..c338c4d8ded 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -5,9 +5,256 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Runtime.InteropServices;
 using System.Collections.Specialized;
+#if RUNTIME_TYPE_NETCORE
+using System.Collections.Generic;
+using System.IO;
+using System.Reflection;
+using System.Reflection.Metadata;
+using System.Reflection.PortableExecutable;
+#endif
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
+#if RUNTIME_TYPE_NETCORE
+    internal class MetadataReader : IDisposable
+    {
+        private StringDictionary _attributes;
+        private List<string> _customAttributes;
+
+        private FileStream _assemblyStream;
+        private PEReader _peReader;
+        private System.Reflection.Metadata.MetadataReader _reader;
+
+        private MetadataReader(string path)
+        {
+            try
+            {
+                _assemblyStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Delete | FileShare.Read);
+                if (_assemblyStream != null)
+                {
+                    _peReader = new PEReader(_assemblyStream, PEStreamOptions.LeaveOpen);
+                    if (_peReader != null)
+                    {
+                        if (_peReader.HasMetadata)
+                        {
+                            _reader = _peReader.GetMetadataReader();
+                        }
+                    }
+                }
+            }
+            catch(Exception)
+            {
+                Close();
+            }
+        }
+
+        public static MetadataReader Create(string path)
+        {
+            var r = new MetadataReader(path);
+            return r._reader != null ? r : null;
+        }
+
+        public bool HasAssemblyAttribute(string name)
+        {
+            if (_customAttributes == null)
+            {
+                lock (this)
+                {
+                    if (_customAttributes == null)
+                    {
+                        ImportCustomAttributesNames();
+                    }
+                }
+            }
+
+            return _customAttributes.Contains(name);
+        }
+
+        public string Name => Attributes[nameof(Name)];
+        public string Version => Attributes[nameof(Version)];
+        public string PublicKeyToken => Attributes[nameof(PublicKeyToken)];
+        public string Culture => Attributes[nameof(Culture)];
+        public string ProcessorArchitecture => Attributes[nameof(ProcessorArchitecture)];
+
+        private void ImportCustomAttributesNames()
+        {
+            _customAttributes = new List<string>();
+
+            AssemblyDefinition def = _reader.GetAssemblyDefinition();
+
+            CustomAttributeHandleCollection col = def.GetCustomAttributes();
+            foreach (CustomAttributeHandle handle in col)
+            {
+                EntityHandle ctorHandle = _reader.GetCustomAttribute(handle).Constructor;
+                if (ctorHandle.Kind != HandleKind.MemberReference)
+                    continue;
+
+                EntityHandle mHandle = _reader.GetMemberReference((MemberReferenceHandle)ctorHandle).Parent;
+                if (mHandle.Kind != HandleKind.TypeReference)
+                    continue;
+
+                string type = GetTypeName((TypeReferenceHandle)mHandle);
+
+                _customAttributes.Add(type);
+            }
+        }
+
+        private StringDictionary Attributes
+        {
+            get
+            {
+                if (_attributes == null)
+                {
+                    lock (this)
+                    {
+                        if (_attributes == null)
+                        {
+                            ImportAttributes();
+                        }
+                    }
+                }
+
+                return _attributes;
+            }
+        }
+
+        private string GetTypeName(TypeReferenceHandle handle)
+        {
+            TypeReference reference = _reader.GetTypeReference(handle);
+
+            // We don't need the type reference scope.
+
+            return reference.Namespace.IsNil
+                ? _reader.GetString(reference.Name)
+                : _reader.GetString(reference.Namespace) + "." + _reader.GetString(reference.Name);
+        }
+
+        private void ImportAttributes()
+        {
+            AssemblyDefinition ad = _reader.GetAssemblyDefinition();
+
+            string name = _reader.GetString(ad.Name);
+            string version = ad.Version.ToString();
+            string publicKeyToken = GetPublicKeyToken();
+            string culture = _reader.GetString(ad.Culture);
+            if (String.IsNullOrEmpty(culture))
+            {
+                culture = "neutral";
+            }
+            string processorArchitecture = GetProcessorArchitecture();
+
+            _attributes = new StringDictionary
+            {
+                { "Name", name },
+                { "Version", version },
+                { "PublicKeyToken", publicKeyToken },
+                { "Culture", culture },
+                { "ProcessorArchitecture", processorArchitecture }
+            };
+        }
+
+        private string GetPublicKeyToken()
+        {
+            string publicKeyToken = null;
+
+            AssemblyDefinition ad = _reader.GetAssemblyDefinition();
+            BlobReader br = _reader.GetBlobReader(ad.PublicKey);
+            byte[] pk = br.ReadBytes(br.Length);
+            if (pk.Length != 0)
+            {
+                AssemblyName an = new AssemblyName();
+                an.SetPublicKey(pk);
+                byte[] pkt = an.GetPublicKeyToken();
+
+                publicKeyToken = BitConverter.ToString(pkt).Replace("-","");
+            }
+
+            if (!String.IsNullOrEmpty(publicKeyToken))
+                publicKeyToken = publicKeyToken.ToUpperInvariant();
+
+            return publicKeyToken;
+        }
+
+        private string GetProcessorArchitecture()
+        {
+            string processorArchitecture = "unknown";
+
+            if (_peReader.PEHeaders == null ||
+                _peReader.PEHeaders.CoffHeader == null)
+            {
+                return processorArchitecture;
+            }
+
+            Machine machine = _peReader.PEHeaders.CoffHeader.Machine;
+            CorHeader corHeader = _peReader.PEHeaders.CorHeader;
+            if (corHeader != null)
+            {
+                CorFlags corFlags = corHeader.Flags;
+                if ((corFlags & CorFlags.ILLibrary) != 0)
+                {
+                    processorArchitecture = "msil";
+                }
+                else
+                {
+                    switch (machine)
+                    {
+                        case Machine.I386:
+                            // "x86" only if corflags "requires" but not "prefers" x86
+                            if ((corFlags & CorFlags.Requires32Bit) != 0 &&
+                                (corFlags & CorFlags.Prefers32Bit) == 0)
+                            {
+                                processorArchitecture = "x86";
+                            }
+                            else
+                            {
+                                processorArchitecture = "msil";
+                            }
+                            break;
+                        case Machine.IA64:
+                            processorArchitecture = "ia64";
+                            break;
+                        case Machine.Amd64:
+                            processorArchitecture = "amd64";
+                            break;
+                        case Machine.Arm:
+                            processorArchitecture = "arm";
+                            break;
+                        case Machine.Arm64:
+                            processorArchitecture = "arm64";
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+
+            return processorArchitecture;
+        }
+
+        public void Close()
+        {
+            if (_peReader != null)
+            {
+                _peReader.Dispose();
+            }
+
+            if (_assemblyStream != null)
+            {
+                _assemblyStream.Close();
+            }
+
+            _attributes = null;
+            _reader = null;
+            _peReader = null;
+            _assemblyStream = null;
+        }
+
+        void IDisposable.Dispose()
+        {
+            Close();
+        }
+    }
+#else
     internal class MetadataReader : IDisposable
     {
         private readonly string _path;
@@ -151,4 +398,5 @@ private interface IMetaDataDispenser
             int OpenScopeOnMemory();
         }
     }
+#endif
 }
diff --git a/src/Tasks/ManifestUtil/NativeMethods.cs b/src/Tasks/ManifestUtil/NativeMethods.cs
index 7b9131a90e7..e18eef1ebeb 100644
--- a/src/Tasks/ManifestUtil/NativeMethods.cs
+++ b/src/Tasks/ManifestUtil/NativeMethods.cs
@@ -12,6 +12,8 @@ internal static class NativeMethods
         public static readonly IntPtr RT_MANIFEST = new IntPtr(24);
         [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
         public static extern IntPtr LoadLibraryExW(string strFileName, IntPtr hFile, UInt32 ulFlags);
+        [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+        public static extern int SetDllDirectoryW(string strPathName);
         [DllImport("Kernel32.dll", SetLastError = true)]
         public static extern bool FreeLibrary(IntPtr hModule);
         [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
diff --git a/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs b/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
index 011248735db..6fde99029e6 100644
--- a/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
+++ b/src/Tasks/ManifestUtil/RSAPKCS1SHA256SignatureDescription.cs
@@ -13,7 +13,11 @@ public sealed class RSAPKCS1SHA256SignatureDescription : SignatureDescription
         public RSAPKCS1SHA256SignatureDescription()
         {
             KeyAlgorithm = typeof(RSACryptoServiceProvider).FullName;
+#if RUNTIME_TYPE_NETCORE
+            DigestAlgorithm = typeof(SHA256).FullName;
+#else
             DigestAlgorithm = typeof(SHA256Cng).FullName;
+#endif
             FormatterAlgorithm = typeof(RSAPKCS1SignatureFormatter).FullName;
             DeformatterAlgorithm = typeof(RSAPKCS1SignatureDeformatter).FullName;
         }
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 2a08073279d..fbfcbef3594 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -32,16 +32,23 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public static class SecurityUtilities
     {
+#if RUNTIME_TYPE_NETCORE
+        // Partial trust and permission sets are not supported by .NET Core.
+#else
         private const string PermissionSetsFolder = "PermissionSets";
         private const string LocalIntranet = "LocalIntranet";
         private const string Internet = "Internet";
         private const string Custom = "Custom";
+#endif
         private const string ToolName = "signtool.exe";
+#if !RUNTIME_TYPE_NETCORE
         private const int Fx2MajorVersion = 2;
         private const int Fx3MajorVersion = 3;
+#endif
         private static readonly Version s_dotNet40Version = new Version("4.0");
         private static readonly Version s_dotNet45Version = new Version("4.5");
 
+#if !RUNTIME_TYPE_NETCORE
         private const string InternetPermissionSetXml = "<PermissionSet class=\"System.Security.PermissionSet\" version=\"1\" ID=\"Custom\" SameSite=\"site\">\n" +
                                                           "<IPermission class=\"System.Security.Permissions.FileDialogPermission, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" version=\"1\" Access=\"Open\" />\n" +
                                                           "<IPermission class=\"System.Security.Permissions.IsolatedStorageFilePermission, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" version=\"1\" Allowed=\"ApplicationIsolationByUser\" UserQuota=\"512000\" />\n" +
@@ -112,15 +119,12 @@ internal static PermissionSet ComputeZonePermissionSetHelper(string targetZone,
 
         private static PermissionSet GetNamedPermissionSetFromZone(string targetZone, string targetFrameworkMoniker)
         {
-            switch (targetZone)
+            return targetZone switch
             {
-                case LocalIntranet:
-                    return GetNamedPermissionSet(LocalIntranet, targetFrameworkMoniker);
-                case Internet:
-                    return GetNamedPermissionSet(Internet, targetFrameworkMoniker);
-                default:
-                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
-            }
+                LocalIntranet => GetNamedPermissionSet(LocalIntranet, targetFrameworkMoniker),
+                Internet => GetNamedPermissionSet(Internet, targetFrameworkMoniker),
+                _ => throw new ArgumentException(String.Empty /* no message */, nameof(targetZone)),
+            };
         }
 
         private static PermissionSet GetNamedPermissionSet(string targetZone, string targetFrameworkMoniker)
@@ -235,19 +239,12 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioni
         [SuppressMessage("Microsoft.Security.Xml", "CA3057: DoNotUseLoadXml.")]
         private static XmlElement GetCurrentCLRPermissions(string targetZone)
         {
-            SecurityZone zone;
-            switch (targetZone)
+            var zone = targetZone switch
             {
-                case LocalIntranet:
-                    zone = SecurityZone.Intranet;
-                    break;
-                case Internet:
-                    zone = SecurityZone.Internet;
-                    break;
-                default:
-                    throw new ArgumentException(String.Empty /* no message */, nameof(targetZone));
-            }
-
+                LocalIntranet => SecurityZone.Intranet,
+                Internet => SecurityZone.Internet,
+                _ => throw new ArgumentException(String.Empty /* no message */, nameof(targetZone)),
+            };
             var evidence = new Evidence(new EvidenceBase[] { new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity("")) }, null);
 
             PermissionSet sandbox = SecurityManager.GetStandardSandbox(evidence);
@@ -267,20 +264,12 @@ private static XmlElement GetCurrentCLRPermissions(string targetZone)
 
         private static XmlElement GetXmlElement(string targetZone, int majorVersion)
         {
-            XmlDocument doc;
-
-            switch (majorVersion)
+            XmlDocument doc = majorVersion switch
             {
-                case Fx2MajorVersion:
-                    doc = CreateXmlDocV2(targetZone);
-                    break;
-                case Fx3MajorVersion:
-                    doc = CreateXmlDocV3(targetZone);
-                    break;
-                default:
-                    throw new ArgumentException(String.Empty /* no message */, nameof(majorVersion));
-            }
-
+                Fx2MajorVersion => CreateXmlDocV2(targetZone),
+                Fx3MajorVersion => CreateXmlDocV3(targetZone),
+                _ => throw new ArgumentException(String.Empty /* no message */, nameof(majorVersion)),
+            };
             XmlElement rootElement = doc.DocumentElement;
 
             return rootElement;
@@ -481,6 +470,7 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
             }
             return ps;
         }
+#endif
 
         /// <summary>
         /// Signs a ClickOnce manifest or PE file.
@@ -561,7 +551,7 @@ private static bool UseSha256Algorithm(X509Certificate2 cert)
         /// <param name="cert">The certificate to be used to sign the file.</param>
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
-        /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the 
+        /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the
         /// current user's personal certificate store.</remarks>
         public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path)
         {
@@ -598,8 +588,14 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
             }
             else
             {
-                using(RSA rsa = CngLightup.GetRSAPrivateKey(cert))
-                {                    
+#if RUNTIME_TYPE_NETCORE
+                IntPtr hModule = IntPtr.Zero;
+
+                using (RSA rsa = cert.GetRSAPrivateKey())
+#else
+                using (RSA rsa = CngLightup.GetRSAPrivateKey(cert))
+#endif
+                {
                     if (rsa == null)
                         throw new ApplicationException(resources.GetString("SecurityUtil.OnlyRSACertsAreAllowed"));
                     try
@@ -622,6 +618,20 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
                             signer = new CmiManifestSigner2(rsa, cert, useSha256);
                         }
 
+#if RUNTIME_TYPE_NETCORE
+                        // Manifest signing uses .NET FX APIs, implemented in clr.dll.
+                        // Load the library explicitly.
+
+                        string clrDllDir = Path.Combine(
+                                Environment.GetFolderPath(Environment.SpecialFolder.Windows),
+                                "Microsoft.NET",
+                                Environment.Is64BitProcess ? "Framework64" : "Framework",
+                                "v4.0.30319");
+
+                        NativeMethods.SetDllDirectoryW(clrDllDir);
+                        hModule = NativeMethods.LoadLibraryExW(Path.Combine(clrDllDir, "clr.dll"), IntPtr.Zero, NativeMethods.LOAD_LIBRARY_AS_DATAFILE);
+                        // No need to check hModule - Sign() method will quickly fail if we did not load clr.dll
+#endif
                         if (timestampUrl == null)
                             manifest.Sign(signer);
                         else
@@ -637,6 +647,17 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
                         }
                         throw new ApplicationException(ex.Message, ex);
                     }
+#if RUNTIME_TYPE_NETCORE
+                    finally
+                    {
+                        if (hModule != IntPtr.Zero)
+                        {
+                            NativeMethods.FreeLibrary(hModule);
+                        }
+
+                        NativeMethods.SetDllDirectoryW(null);
+                    }
+#endif
                 }
             }
         }
@@ -659,8 +680,8 @@ private static void SignPEFile(X509Certificate2 cert, Uri timestampUrl, string p
             }
         }
 
-        private static void SignPEFileInternal(X509Certificate2 cert, Uri timestampUrl, 
-                                               string path, System.Resources.ResourceManager resources, 
+        private static void SignPEFileInternal(X509Certificate2 cert, Uri timestampUrl,
+                                               string path, System.Resources.ResourceManager resources,
                                                bool useSha256, bool useRFC3161Timestamp)
         {
             var startInfo = new ProcessStartInfo(
@@ -721,9 +742,9 @@ internal static string GetCommandLineParameters(string certThumbprint, Uri times
 
             if (timestampUrl != null)
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture, 
-                                                "{0} {1} ", 
-                                                useRFC3161Timestamp ? "/tr" : "/t", 
+                commandLine.Append(String.Format(CultureInfo.InvariantCulture,
+                                                "{0} {1} ",
+                                                useRFC3161Timestamp ? "/tr" : "/t",
                                                 timestampUrl.ToString()));
             }
             commandLine.Append(string.Format(CultureInfo.InvariantCulture, "\"{0}\"", path));
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index e5a0d7aa194..72d619f4b6b 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -21,12 +21,16 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     [ComVisible(false)]
     public sealed class TrustInfo
     {
+#if !RUNTIME_TYPE_NETCORE
+        // Partial trust and permission sets are not supported by .NET Core.
+        // SameSite evaluation is conditioned on .NET FX but always done in .NET Core code.
         private PermissionSet _inputPermissionSet;
+        private PermissionSet _outputPermissionSet;
+        private bool _sameSiteChanged;
+#endif
         private XmlDocument _inputTrustInfoDocument;
         private bool _isFullTrust = true;
-        private PermissionSet _outputPermissionSet;
         private string _sameSiteSetting = "site";
-        private bool _sameSiteChanged;
 
         private void AddSameSiteAttribute(XmlElement permissionSetElement)
         {
@@ -45,10 +49,12 @@ private void AddSameSiteAttribute(XmlElement permissionSetElement)
         /// </summary>
         public void Clear()
         {
+#if !RUNTIME_TYPE_NETCORE
             _inputPermissionSet = null;
+            _outputPermissionSet = null;
+#endif
             _inputTrustInfoDocument = null;
             _isFullTrust = true;
-            _outputPermissionSet = null;
         }
 
         private void FixupPermissionSetElement(XmlElement permissionSetElement)
@@ -129,12 +135,13 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
                 defaultAssemblyRequestElement.Attributes.Append(idrefAttribute);
             }
 
-            if (String.Compare(idAttribute.Value, idrefAttribute.Value, StringComparison.Ordinal) != 0)
+            if (!String.Equals(idAttribute.Value, idrefAttribute.Value, StringComparison.Ordinal))
             {
                 idrefAttribute.Value = idAttribute.Value;
             }
         }
 
+#if !RUNTIME_TYPE_NETCORE
         private PermissionSet GetInputPermissionSet()
         {
             if (_inputPermissionSet == null)
@@ -161,6 +168,7 @@ private PermissionSet GetInputPermissionSet()
             }
             return _inputPermissionSet;
         }
+#endif
 
         private XmlElement GetInputPermissionSetElement()
         {
@@ -200,7 +208,6 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
             //      <requestedExecutionLevel level="asInvoker" />
             //  </requestedPrivileges>
 
-
             // we always create a requestedPrivilege node to put into the generated TrustInfo document
             //
             XmlElement requestedPrivilegeElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.requestedPrivilegeElement), XmlNamespaces.asmv3);
@@ -232,7 +239,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
                 //  here so we can allow the passed-in node to override it if there is a comment present
                 //
                 System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
-                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment"); ;
+                commentString = resources.GetString("TrustInfo.RequestedExecutionLevelComment"); 
             }
             else
             {
@@ -252,7 +259,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
                     //  keep the default null value which means we will not create one in the
                     //  output document)
                     //
-                    if (previousNode != null && previousNode.NodeType == XmlNodeType.Comment)
+                    if (previousNode?.NodeType == XmlNodeType.Comment)
                     {
                         commentString = ((XmlComment)previousNode).Data;
                     }
@@ -329,6 +336,7 @@ private XmlElement GetPermissionSetElement(XmlDocument document)
             return permissionSetElement;
         }
 
+#if !RUNTIME_TYPE_NETCORE
         private PermissionSet GetOutputPermissionSet()
         {
             if (_outputPermissionSet == null)
@@ -351,6 +359,7 @@ private XmlDocument GetOutputPermissionSetDocument()
 
             return outputDocument;
         }
+#endif
 
         /// <summary>
         /// Determines whether the application has permission to call unmanaged code.
@@ -359,6 +368,10 @@ public bool HasUnmanagedCodePermission
         {
             get
             {
+#if RUNTIME_TYPE_NETCORE
+                // Always use full-trust on .NET Core.
+                return true;
+#else
                 PermissionSet ps = GetOutputPermissionSet();
                 if (ps == null)
                 {
@@ -367,6 +380,7 @@ public bool HasUnmanagedCodePermission
                 var ups = new PermissionSet(PermissionState.None);
                 ups.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode));
                 return ps.Intersect(ups) != null;
+#endif
             }
         }
 
@@ -377,12 +391,20 @@ public bool IsFullTrust
         {
             get
             {
+#if RUNTIME_TYPE_NETCORE
+                // Always use full-trust on .NET Core.
+               return true;
+#else
                 GetInputPermissionSet();
                 return _isFullTrust;
+#endif
             }
+#if !RUNTIME_TYPE_NETCORE
             set => _isFullTrust = value;
+#endif
         }
 
+#if !RUNTIME_TYPE_NETCORE
         /// <summary>
         /// Gets or sets the permission set object for the application trust.
         /// </summary>
@@ -391,6 +413,7 @@ public PermissionSet PermissionSet
             get => GetOutputPermissionSet();
             set => _outputPermissionSet = value ?? throw new ArgumentNullException("PermissionSet cannot be set to null.");
         }
+#endif
 
         /// <summary>
         /// Determines whether to preserve partial trust permission when the full trust flag is set.
@@ -467,7 +490,17 @@ private void ReadTrustInfo(string xml)
             _inputTrustInfoDocument.LoadXml(xml);
             XmlElement psElement = GetInputPermissionSetElement();
             XmlAttribute unrestrictedAttribute = (XmlAttribute)psElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute));
+#if RUNTIME_TYPE_NETCORE
+            // Partial trust is not supported on .NET Core.
+            // Fail if loaded manifest does not specify full-trust.
+            // It can happen if manifest is manually modifed.
+            if (unrestrictedAttribute == null || (false == Boolean.Parse(unrestrictedAttribute.Value)))
+            {
+                throw new ArgumentException("Partial trust is not supported.");
+            }
+#else
             _isFullTrust = unrestrictedAttribute != null && Boolean.Parse(unrestrictedAttribute.Value);
+#endif
             XmlAttribute sameSiteAttribute = (XmlAttribute)psElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.sameSiteAttribute));
             if (sameSiteAttribute != null)
                 _sameSiteSetting = sameSiteAttribute.Value;
@@ -482,7 +515,9 @@ public string SameSiteAccess
             set
             {
                 _sameSiteSetting = value;
+#if !RUNTIME_TYPE_NETCORE
                 _sameSiteChanged = true;
+#endif
             }
         }
 
@@ -544,6 +579,14 @@ public void Write(Stream output)
 
                 // If permission set was not altered, just write out what was read in...
                 MemoryStream m = new MemoryStream();
+#if RUNTIME_TYPE_NETCORE
+                // Simpler code on .NET Core - due to no support for custom permission sets.
+                XmlElement permissionSetElement = outputDocument.DocumentElement;
+                FixupPermissionSetElement(permissionSetElement);
+
+                outputDocument.Save(m);
+                m.Position = 0;
+#else
                 if (_outputPermissionSet == null && !_sameSiteChanged)
                 {
                     XmlElement permissionSetElement = outputDocument.DocumentElement;
@@ -573,6 +616,7 @@ public void Write(Stream output)
                         m.Position = 0;
                     }
                 }
+#endif
 
                 // Wrap <PermissionSet> in a <TrustInfo> section
                 Stream s = tempPrivilegeDocument != null ? XmlUtil.XslTransform(trustInfoResource2, m, new DictionaryEntry("defaultRequestedPrivileges", tempPrivilegeDocument)) : XmlUtil.XslTransform(trustInfoResource2, m);
@@ -668,6 +712,32 @@ public void WriteManifest(Stream input, Stream output)
                 assemblyElement.AppendChild(trustInfoElement);
             }
 
+#if RUNTIME_TYPE_NETCORE
+            // Partial trust and permission sets are not supported on .NET Core.
+            // Consequently we do not support updating permissionSet element.
+            XmlElement securityElement = (XmlElement)trustInfoElement.SelectSingleNode(XPaths.securityElement, nsmgr);
+            if (securityElement == null)
+            {
+                securityElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.securityElement), XmlNamespaces.asmv2);
+                trustInfoElement.AppendChild(securityElement);
+            }
+            XmlElement applicationRequestMinimumElement = (XmlElement)securityElement.SelectSingleNode(XPaths.applicationRequestMinimumElement, nsmgr);
+            if (applicationRequestMinimumElement == null)
+            {
+                applicationRequestMinimumElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.applicationRequestMinimumElement), XmlNamespaces.asmv2);
+                securityElement.AppendChild(applicationRequestMinimumElement);
+            }
+
+            XmlNodeList permissionSetNodes = applicationRequestMinimumElement.SelectNodes(XPaths.permissionSetElement, nsmgr);
+            foreach (XmlNode permissionSetNode in permissionSetNodes)
+                applicationRequestMinimumElement.RemoveChild(permissionSetNode);
+
+            XmlElement fullTrustPermissionSetElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.permissionSetElement), XmlNamespaces.asmv2);
+            XmlAttribute unrestrictedAttribute = document.CreateAttribute(XmlUtil.TrimPrefix(XPaths.unrestrictedAttribute), XmlNamespaces.asmv2);
+            unrestrictedAttribute.Value = "true";
+            applicationRequestMinimumElement.AppendChild(fullTrustPermissionSetElement);
+            FixupPermissionSetElement(fullTrustPermissionSetElement);
+#else
             // If we have an input trustinfo document and no output specified then just copy the input to the output
             if (_inputTrustInfoDocument != null && _outputPermissionSet == null && !_sameSiteChanged)
             {
@@ -700,6 +770,7 @@ public void WriteManifest(Stream input, Stream output)
                 applicationRequestMinimumElement.AppendChild(permissionSetElement);
                 FixupPermissionSetElement(permissionSetElement);
             }
+#endif
 
             // Truncate any contents that may be in the file
             if (output.Length > 0)
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index d0f293057ea..ad3315a7604 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -29,6 +29,10 @@ internal static class Util
         private static StreamWriter s_logFileWriter;
         // Major, Minor, Build and Revision of CLR v2.0
         private static readonly int[] s_clrVersion2 = { 2, 0, 50727, 0 };
+#if RUNTIME_TYPE_NETCORE
+        // Major, Minor, Build and Revision of CLR v4.0
+        private static readonly int[] s_clrVersion4 = { 4, 0, 30319, 0 };
+#endif
 
         #region " Platform <-> ProcessorArchitecture mapping "
         // Note: These two arrays are parallel and must correspond to one another.
@@ -110,7 +114,13 @@ public static string GetAssemblyPath()
         public static string GetClrVersion()
         {
             Version v = Environment.Version;
+#if RUNTIME_TYPE_NETCORE
+            // This is a version of ClickOnce .NET FX target runtime, which cannot be obtained in .NET (Core) process.
+            // Set to .NET FX v4 runtime as the ony one supported for manifest generation in .NET (Core) process.
+            v = new Version(s_clrVersion4[0], s_clrVersion4[1], s_clrVersion4[2], s_clrVersion4[3]);
+#else
             v = new Version(v.Major, v.Minor, v.Build, 0);
+#endif
             return v.ToString();
         }
 
@@ -125,7 +135,13 @@ public static string GetClrVersion(string targetFrameworkVersion)
                 return GetClrVersion();
 
             Version clrVersion;
+#if RUNTIME_TYPE_NETCORE
+            // This is a version of ClickOnce .NET FX target runtime, which cannot be obtained in .NET (Core) process.
+            // Set to .NET FX v4 runtime as the ony one supported for manifest generation in .NET (Core) process.
+            Version currentVersion = new Version(s_clrVersion4[0], s_clrVersion4[1], s_clrVersion4[2], s_clrVersion4[3]);
+#else
             Version currentVersion = Environment.Version;
+#endif
             Version frameworkVersion = GetTargetFrameworkVersion(targetFrameworkVersion);
 
             // for FX 4.0 or above use the current version.
@@ -135,7 +151,12 @@ public static string GetClrVersion(string targetFrameworkVersion)
             }
             else
             {
+#if RUNTIME_TYPE_NETCORE
+                // Set to .NET FX v4 runtime as the ony one supported for manifest generation in .NET (Core) process.
+                clrVersion = new Version(s_clrVersion4[0], s_clrVersion4[1], s_clrVersion4[2], s_clrVersion4[3]);
+#else
                 clrVersion = new Version(s_clrVersion2[0], s_clrVersion2[1], s_clrVersion2[2], s_clrVersion2[3]);
+#endif
             }
             return clrVersion.ToString();
         }
@@ -314,7 +335,7 @@ internal static bool IsValidFrameworkVersion(string value)
         public static string PlatformToProcessorArchitecture(string platform)
         {
             for (int i = 0; i < s_platforms.Length; ++i)
-                if (String.Compare(platform, s_platforms[i], StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(platform, s_platforms[i], StringComparison.OrdinalIgnoreCase))
                     return s_processorArchitectures[i];
             return null;
         }
@@ -510,7 +531,6 @@ int IComparer.Compare(object obj1, object obj2)
         }
         #endregion
 
-
         public static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d7a6ae38e71..eedc9f79b71 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -66,7 +66,6 @@ internal static class Win32
         internal const int TRUST_E_EXPLICIT_DISTRUST = unchecked((int)0x800B0111);
         internal const int CERT_E_CHAINING = unchecked((int)0x800B010A);
 
-
         // Values for dwFlags of CertVerifyAuthenticodeLicense.
         internal const int AXL_REVOCATION_NO_CHECK = unchecked((int)0x00000001);
         internal const int AXL_REVOCATION_CHECK_END_CERT_ONLY = unchecked((int)0x00000002);
@@ -275,8 +274,13 @@ private void init()
             CryptoConfig.AddAlgorithm(typeof(RSAPKCS1SHA256SignatureDescription),
                                Sha256SignatureMethodUri);
 
+#if RUNTIME_TYPE_NETCORE
+            CryptoConfig.AddAlgorithm(typeof(SHA256Managed),
+                               Sha256DigestMethod);
+#else
             CryptoConfig.AddAlgorithm(typeof(System.Security.Cryptography.SHA256Cng),
                                Sha256DigestMethod);
+#endif
         }
 
         private static XmlElement FindIdElement(XmlElement context, string idValue)
@@ -326,7 +330,7 @@ private SignedCmiManifest2() { }
         internal SignedCmiManifest2(XmlDocument manifestDom, bool useSha256)
         {
             if (manifestDom == null)
-                throw new ArgumentNullException("manifestDom");
+                throw new ArgumentNullException(nameof(manifestDom));
             _manifestDom = manifestDom;
             _useSha256 = useSha256;
         }
@@ -345,7 +349,7 @@ internal void Sign(CmiManifestSigner2 signer, string timeStampUrl)
             // Signer cannot be null.
             if (signer == null || signer.StrongNameKey == null)
             {
-                throw new ArgumentNullException("signer");
+                throw new ArgumentNullException(nameof(signer));
             }
 
             // Remove existing SN signature.
@@ -465,6 +469,7 @@ private static void RemoveExistingSignature(XmlDocument manifestDom)
         /// As for official guidance – I’m not sure of any.    For workarounds though, if you’re using the Microsoft software CSPs, they share the underlying key store.  You can get the key container name from your RSA object, then open up a new RSA object with the same key container name but with PROV_RSA_AES.   At that point, you should be able to use SHA-2 algorithms.
         /// </summary>
         /// <param name="oldCsp"></param>
+        /// <param name="useSha256">Whether to use sha256</param>
         /// <returns></returns>
         [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Cryptographic.Standard", "CA5358:RSAProviderNeeds2048bitKey", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
         internal static RSACryptoServiceProvider GetFixedRSACryptoServiceProvider(RSACryptoServiceProvider oldCsp, bool useSha256)
@@ -514,7 +519,7 @@ private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlg
             byte[] cspPublicKeyBlob;
 
             if(snKey is RSACryptoServiceProvider){
-                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider((RSACryptoServiceProvider)snKey, useSha256)).ExportCspBlob(false);            
+                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider((RSACryptoServiceProvider)snKey, useSha256)).ExportCspBlob(false);
                 if (cspPublicKeyBlob == null || cspPublicKeyBlob.Length == 0)
                 {
                     throw new CryptographicException(Win32.NTE_BAD_KEY);
@@ -694,7 +699,11 @@ private static XmlDocument CreateLicenseDom(CmiManifestSigner2 signer, XmlElemen
         private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManifestSigner2 signer, string timeStampUrl, bool useSha256)
         {
             // Make sure it is RSA, as this is the only one Fusion will support.
+#if RUNTIME_TYPE_NETCORE
+            RSA rsaPrivateKey = signer.Certificate.GetRSAPrivateKey();
+#else
             RSA rsaPrivateKey = CngLightup.GetRSAPrivateKey(signer.Certificate);
+#endif
             if (rsaPrivateKey == null)
             {
                 throw new NotSupportedException();
@@ -756,7 +765,7 @@ private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManife
             issuerNode.AppendChild(licenseDom.ImportNode(xmlDigitalSignature, true));
 
             // Time stamp it if requested.
-            if (timeStampUrl != null && timeStampUrl.Length != 0)
+            if (!string.IsNullOrEmpty(timeStampUrl))
             {
                 TimestampSignedLicenseDom(licenseDom, timeStampUrl, useSha256);
             }
@@ -1049,12 +1058,12 @@ internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey) :
         internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256)
         {
             if (strongNameKey == null)
-                throw new ArgumentNullException("strongNameKey");
+                throw new ArgumentNullException(nameof(strongNameKey));
 
 #if (true) // BUGBUG: Fusion only supports RSA. Do we throw if not RSA???
             RSA rsa = strongNameKey as RSA;
             if (rsa == null)
-                throw new ArgumentNullException("strongNameKey");
+                throw new ArgumentNullException(nameof(strongNameKey));
 #endif
             _strongNameKey = strongNameKey;
             _certificate = certificate;
diff --git a/src/Tasks/Message.cs b/src/Tasks/Message.cs
index 0d6fc93f403..88b6dca9f84 100644
--- a/src/Tasks/Message.cs
+++ b/src/Tasks/Message.cs
@@ -47,7 +47,7 @@ public override bool Execute()
         {
             MessageImportance messageImportance;
 
-            if ((Importance == null) || (Importance.Length == 0))
+            if (string.IsNullOrEmpty(Importance))
             {
                 messageImportance = MessageImportance.Normal;
             }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 6275d3bcd30..b194c847366 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -329,6 +329,9 @@
     <Compile Include="AssignTargetPath.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="BootstrapperUtil\*.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="CallTarget.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -407,6 +410,15 @@
     <Compile Include="FxCopExclusions\Microsoft.Build.Tasks.Suppressions.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="GenerateResource.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -459,6 +471,9 @@
     <Compile Include="MakeDir.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="ManifestUtil\*.cs" Exclude="ManifestUtil\CngLightup.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="Message.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -483,6 +498,9 @@
     <Compile Include="ResolveKeySource.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="ResolveNonMSBuildProjectOutput.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -557,9 +575,6 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="AxTlbBaseTask.cs" />
-    <Compile Include="BootstrapperUtil\*.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="ComDependencyWalker.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -585,18 +600,9 @@
     <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="GenerateBootstrapper.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -611,11 +617,11 @@
     <Compile Include="Interop.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="RCWForCurrentContext.cs" />
-    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
+    <Compile Include="ManifestUtil\CngLightup.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="ManifestUtil\*.cs" Condition="'$(MonoBuild)' != 'true'">
+    <Compile Include="RCWForCurrentContext.cs" />
+    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="PiaReference.cs">
@@ -628,9 +634,6 @@
     <Compile Include="ResolveComReferenceCache.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -998,6 +1001,9 @@
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Reflection.TypeExtensions" />
+    <PackageReference Include="System.Runtime.InteropServices" />
+    <PackageReference Include="System.Security.Cryptography.Pkcs" />
+    <PackageReference Include="System.Security.Cryptography.Xml" />
     <PackageReference Include="System.Security.Permissions" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index b6afab6807b..b5d20aaf8eb 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -96,7 +96,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <TargetPlatformWinMDLocation Condition="'$(TargetPlatformWinMDLocation)' == '' and Exists('$(TargetPlatformSdkMetadataLocation)')">$(TargetPlatformSdkMetadataLocation)</TargetPlatformWinMDLocation>
     <UseOSWinMdReferences Condition="'$(UseOSWinMdReferences)' == '' and ('$(TargetPlatformWinMDLocation)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &gt; '7.0')">true</UseOSWinMdReferences>
     <TargetPlatformWinMDLocation Condition="'$(UseOsWinMdReferences)' == 'true'">$(WinDir)\System32\WinMetadata</TargetPlatformWinMDLocation>
-    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
+    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == '' and '$(TargetPlatformIdentifier)' != '' and '$(TargetPlatformVersion)' != ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
     <TargetPlatformDisplayName Condition="'$(TargetPlatformDisplayName)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
   </PropertyGroup>
 
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index a9136d0a089..8e64b2f7038 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -180,7 +180,7 @@ private static void MakeWriteableIfReadOnly(string file)
             var info = new FileInfo(file);
             if ((info.Attributes & FileAttributes.ReadOnly) != 0)
             {
-                info.Attributes = info.Attributes & ~FileAttributes.ReadOnly;
+                info.Attributes &= ~FileAttributes.ReadOnly;
             }
         }
 
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 71d2fd91fa4..76065042e2a 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1324,10 +1324,10 @@ internal enum AssemblyComparisonResult
         #region Methods
 #if FEATURE_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONS
         /// <summary>
-        /// Given a pointer to a metadata blob, read the string parameter from it.  Returns true if 
-        /// a valid string was constructed and false otherwise.  
-        /// 
-        /// Adapted from bizapps\server\designers\models\packagemodel\nativemethods.cs (TryReadStringArgument) and 
+        /// Given a pointer to a metadata blob, read the string parameter from it.  Returns true if
+        /// a valid string was constructed and false otherwise.
+        ///
+        /// Adapted from bizapps\server\designers\models\packagemodel\nativemethods.cs (TryReadStringArgument) and
         /// the original ARD implementation in vsproject\compsvcspkg\enumcomplus.cpp (GetStringCustomAttribute)
         /// This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
         /// </summary>
@@ -1402,10 +1402,10 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
         }
 #endif
         /// <summary>
-        /// Returns the number of bytes that compressed data -- the length of the uncompressed 
-        /// data -- takes up, and has an out value of the length of the string.  
-        /// 
-        /// Decompression algorithm stolen from ndp\clr\src\toolbox\mdbg\corapi\metadata\cormetadata.cs, which 
+        /// Returns the number of bytes that compressed data -- the length of the uncompressed
+        /// data -- takes up, and has an out value of the length of the string.
+        ///
+        /// Decompression algorithm stolen from ndp\clr\src\toolbox\mdbg\corapi\metadata\cormetadata.cs, which
         /// was translated from the base implementation in ndp\clr\src\inc\cor.h
         /// This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
         /// </summary>
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index 601bc5336f7..c8944fa05b1 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -74,7 +74,6 @@ public RCWForCurrentContext(T rcw)
         /// Call this helper if your managed object is really an RCW to a COM object
         /// and that COM object was created in a different apartment from where it is being accessed
         /// </summary>
-        /// <param name="rcw">An RCW object created in the original apartment context.</param>
         /// <returns>A new RCW created in the current apartment context</returns>
         public T RCW
         {
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 9bc15d0aed2..9da5c32a396 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Tasks
     /// Framework version dependencies to the current Framework version.
     /// This list is also used by the deployment system to exclude Framework
     /// dependencies from customer deployment packages.
-    /// </summary>    
+    /// </summary>
     internal sealed class RedistList
     {
         // List of cached RedistList objects, the key is a semi-colon delimited list of data file paths
@@ -66,7 +66,7 @@ internal sealed class RedistList
 
         // List of cached BlackList RedistList objects, the key is a semi-colon delimited list of data file paths
         private readonly ConcurrentDictionary<string, Dictionary<string, string>> _cachedBlackList = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
-        
+
         /***************Fields which are only set in the constructor and should not be modified by the class. **********************/
         // Array of errors encountered while reading files.
         private readonly ReadOnlyCollection<Exception> _errors;
@@ -165,12 +165,12 @@ public bool IsFrameworkAssembly(string assemblyName)
         public bool IsPrerequisiteAssembly(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            return entry != null && entry.InGAC;
+            return entry?.InGAC == true;
         }
 
         /// <summary>
-        /// If there was a remapping entry in the redist list list then remap the passed in assemblynameextension 
-        /// if not just return the original one. 
+        /// If there was a remapping entry in the redist list then remap the passed in assemblynameextension
+        /// if not just return the original one.
         /// </summary>
         public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap)
         {
@@ -482,24 +482,26 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         }
 
         /// <summary>
-        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the 
-        /// assemblies listed in the WhiteList from the RedistList. 
-        /// 
+        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the
+        /// assemblies listed in the WhiteList from the RedistList.
+        ///
         /// 1) If there are assemblies in the redist list and one or more client subset files are read in with matching names then
         ///    the subtraction will take place. If there were no matching redist lists read in the black list will be empty.
-        ///    
+        ///
         /// 2) If the subset has a matching name but there are no files inside of it then the black list will contain ALL files in the redist list.
-        /// 
+        ///
         /// 3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for black list generation.
         ///
         /// When generating the blacklist, we will first see if the black list is in the appdomain wide cache
         /// so that we do not regenerate one for multiple calls using the same whiteListAssemblyTableInfo.
-        /// 
+        ///
         /// </summary>
         /// <param name="whiteListAssemblyTableInfo">List of paths to white list xml files</param>
-        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value. 
+        /// <param name="whiteListErrors">List of white listed errors</param>
+        /// <param name="whiteListErrorFileNames">List of white listed error file names</param>
+        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value.
         ///          If there is no assemblies in the redist list null is returned.
-        /// </returns> 
+        /// </returns>
         internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableInfo, List<Exception> whiteListErrors, List<string> whiteListErrorFileNames)
         {
             // Return null if there are no assemblies in the redist list.
@@ -621,6 +623,10 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
         /// XML formatting issues will recorded in the 'errors' collection.
         /// </summary>
         /// <param name="assemblyTableInfo">Information about the redistlist file.</param>
+        /// <param name="assembliesList">List of assembly from installed assembly table.</param>
+        /// <param name="errorsList">Error list.</param>
+        /// <param name="errorFilenamesList">Error filename list.</param>
+        /// <param name="remapEntries">Assembly remaping.</param>
         /// <returns>Redist name of the redist list just read in</returns>
         internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List<AssemblyEntry> assembliesList, List<Exception> errorsList, List<string> errorFilenamesList, List<AssemblyRemapping> remapEntries)
         {
@@ -833,7 +839,7 @@ private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableIn
             }
 
             bool isValidEntry = !string.IsNullOrEmpty(name) && (!fullFusionNameRequired || (fullFusionNameRequired && !string.IsNullOrEmpty(version) && !string.IsNullOrEmpty(publicKeyToken) && !string.IsNullOrEmpty(culture)));
-            Debug.Assert(isValidEntry, string.Format(CultureInfo.InvariantCulture, "Missing attribute in redist file: {0}, line #{1}", path, 
+            Debug.Assert(isValidEntry, string.Format(CultureInfo.InvariantCulture, "Missing attribute in redist file: {0}, line #{1}", path,
                 reader is IXmlLineInfo ? ((IXmlLineInfo)reader).LineNumber : 0));
             AssemblyEntry newEntry = null;
             if (isValidEntry)
@@ -928,7 +934,7 @@ public int CompareTo(object obj)
     }
 
     /// <summary>
-    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders 
+    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders
     /// for a list of provided subset list names.
     /// </summary>
     internal class SubsetListFinder
@@ -958,8 +964,8 @@ internal class SubsetListFinder
         /// This class takes in a list of subset names to look for and provides a method to search the target framework directories to see if those
         /// files exist.
         /// </summary>
-        /// <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be 
-        /// found in the target framework directories. This can happen if the the subsets are instead passed in as InstalledDefaultSubsetTables</param>
+        /// <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be
+        /// found in the target framework directories. This can happen if the subsets are instead passed in as InstalledDefaultSubsetTables</param>
         internal SubsetListFinder(string[] subsetToSearchFor)
         {
             ErrorUtilities.VerifyThrowArgumentNull(subsetToSearchFor, nameof(subsetToSearchFor));
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index ecd34871a69..3fdf14ffd43 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -72,7 +72,7 @@ public override bool Execute()
 
             AssemblyRegistrationCache cacheFile = null;
 
-            if ((AssemblyListFile != null) && (AssemblyListFile.ItemSpec.Length > 0))
+            if ((AssemblyListFile?.ItemSpec.Length > 0))
             {
                 cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
                             new AssemblyRegistrationCache();
@@ -89,7 +89,7 @@ public override bool Execute()
                         string tlbPath;
 
                         // if the type lib path is not supplied, generate default one
-                        if ((TypeLibFiles[i] != null) && (TypeLibFiles[i].ItemSpec.Length > 0))
+                        if ((TypeLibFiles[i]?.ItemSpec.Length > 0))
                         {
                             tlbPath = TypeLibFiles[i].ItemSpec;
                         }
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 08df15001b4..5794aac4d9c 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -538,7 +538,7 @@ private string GenerateResGenFullPath()
             /// </summary>
             private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments, bool useForResponseFile)
             {
-                resGenArguments = resGenArguments ?? new CommandLineBuilderExtension();
+                resGenArguments ??= new CommandLineBuilderExtension();
 
                 if (IsNullOrEmpty(OutputFiles))
                 {
@@ -577,7 +577,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                     resGenArguments.AppendSwitch("/compile" + (useForResponseFile ? "\n" : String.Empty));
 
                     // append the resources to compile
-                    if (InputFiles != null && InputFiles.Length > 0)
+                    if (InputFiles?.Length > 0)
                     {
                         ITaskItem[] inputFiles = InputFiles;
                         ITaskItem[] outputFiles = OutputFiles;
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index e174d3e8f0d..236d8102924 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -61,7 +61,7 @@ internal string BaseLinkedFileDirectory
                 }
                 if ((value == null && baseLinkedFileDirectory != null) ||
                      (value != null && baseLinkedFileDirectory == null) ||
-                     (String.Compare(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase) != 0))
+                     (!String.Equals(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase)))
                 {
                     // Ok, this is slightly complicated.  Changing the base directory in any manner may
                     // result in changes to how we find .resx files.  Therefore, we must clear our out
@@ -132,7 +132,7 @@ internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
             // this entry from the cache and rebuild all the state at a later point.
-            if (retVal != null && retVal.HasFileChanged())
+            if (retVal?.HasFileChanged() == true)
             {
                 portableLibraries.RemoveDependencyFile(libraryPath);
                 _isDirty = true;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 63fef7d822d..89ed55d4c40 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -327,7 +327,7 @@ public override bool Execute()
 
             _timestampCache = (ResolveComReferenceCache)StateFileBase.DeserializeCache(StateFile, Log, typeof(ResolveComReferenceCache));
 
-            if (_timestampCache == null || (_timestampCache != null && !_timestampCache.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath)))
+            if (_timestampCache?.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath) != true)
             {
                 if (!Silent)
                 {
@@ -442,7 +442,7 @@ public override bool Execute()
             }
             finally
             {
-                if ((_timestampCache != null) && _timestampCache.Dirty)
+                if ((_timestampCache?.Dirty == true))
                 {
                     _timestampCache.SerializeCache(StateFile, Log);
                 }
@@ -1165,7 +1165,7 @@ bool IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, out
 
             for (int i = 0; i < ResolvedAssemblyReferences.GetLength(0); i++)
             {
-                if (String.Compare(Path.GetFileName(ResolvedAssemblyReferences[i].ItemSpec), assemblyName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(Path.GetFileName(ResolvedAssemblyReferences[i].ItemSpec), assemblyName, StringComparison.OrdinalIgnoreCase))
                 {
                     assemblyPath = ResolvedAssemblyReferences[i].ItemSpec;
                     return true;
@@ -1308,6 +1308,7 @@ internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
         /// <param name="outputDirectory">Directory the interop DLL should be written to</param>
         /// <param name="refName">Name of reference</param>
         /// <param name="topLevelRef">True if this is a top-level reference</param>
+        /// <param name="dependencyPaths">List of dependency paths for that reference</param>
         /// <param name="wrapperInfo">Information about wrapper locations</param>
         /// <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
         internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outputDirectory, string refName, bool topLevelRef, List<string> dependencyPaths, out ComReferenceWrapperInfo wrapperInfo)
@@ -1333,7 +1334,7 @@ internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outp
                     {
                         // conflicting typelib names for different typelibs? generate a temporary wrapper
                         if (!ComReference.AreTypeLibAttrEqual(referenceInfo.attr, projectRefInfo.attr) &&
-                            String.Compare(referenceInfo.typeLibName, projectRefInfo.typeLibName, StringComparison.OrdinalIgnoreCase) == 0)
+                            String.Equals(referenceInfo.typeLibName, projectRefInfo.typeLibName, StringComparison.OrdinalIgnoreCase))
                         {
                             isTemporary = true;
                         }
@@ -1619,7 +1620,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
                 if (_projectTargetFramework != null && (_projectTargetFramework >= s_targetFrameworkVersion_40))
                 {
                     if ((embedInteropTypesMetadata != null) &&
-                        (String.Compare(embedInteropTypesMetadata, "true", StringComparison.OrdinalIgnoreCase) == 0))
+                        (String.Equals(embedInteropTypesMetadata, "true", StringComparison.OrdinalIgnoreCase)))
                     {
                         // Embed Interop Types forces CopyLocal to false
                         taskItem.SetMetadata(ItemMetadataNames.copyLocal, "false");
@@ -1631,7 +1632,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
 
                 // if Private is not set on the original item, we set CopyLocal to false for GAC items 
                 // and true for non-GAC items
-                if ((privateMetadata == null) || (privateMetadata.Length == 0))
+                if (string.IsNullOrEmpty(privateMetadata))
                 {
                     if (String.Compare(taskItem.ItemSpec, 0, gacPath, 0, gacPath.Length, StringComparison.OrdinalIgnoreCase) == 0)
                     {
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index bc9b0393007..f6741aa36d2 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -84,7 +84,6 @@ private static UInt64 HashFromBlob(byte[] data)
             return result;
         }
 
-
         private bool ResolveAssemblyKey()
         {
             bool pfxSuccess = true;
@@ -102,7 +101,7 @@ private bool ResolveAssemblyKey()
                 }
                 if (pfxSuccess)
                 {
-                    if (0 != String.Compare(keyFileExtension, pfxFileExtension, StringComparison.OrdinalIgnoreCase))
+                    if (!String.Equals(keyFileExtension, pfxFileExtension, StringComparison.OrdinalIgnoreCase))
                     {
                         ResolvedKeyFile = KeyFile;
                     }
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 3b10b04bd42..ab41808f881 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// This task resolves items in the build process (built, dependencies, satellites,
     /// content, debug symbols, documentation, etc.) to files for manifest generation.
-    /// </Summary>
+    /// </summary>
     /// <comment>
     /// This task executes following steps:
     ///   (1) Filter out Framework assemblies
@@ -630,7 +630,7 @@ private bool IsFiltered(ITaskItem item)
                 return true;
             }
 
-            if (identity != null && identity.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion))
+            if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
             {
                 return true;
             }
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 0170382a0a6..ade412a266b 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -144,7 +144,7 @@ public override bool Execute()
                     }
                     catch (Exception)
                     {
-                        Debug.Assert(false, "Unexpected exception in ResolveNativeReference.Execute. " + 
+                        Debug.Assert(false, "Unexpected exception in ResolveNativeReference.Execute. " +
                             "Please log a MSBuild bug specifying the steps to reproduce the problem.");
                         throw;
                     }
diff --git a/src/Tasks/ResolveNonMSBuildProjectOutput.cs b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
index 9c527a294b2..790fe7fab92 100644
--- a/src/Tasks/ResolveNonMSBuildProjectOutput.cs
+++ b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
@@ -11,14 +11,14 @@
 namespace Microsoft.Build.Tasks
 {
     /// <remarks>
-    /// This task determines the output files for non-MSBuild project references. We look inside 
+    /// This task determines the output files for non-MSBuild project references. We look inside
     /// a special property set by the VS IDE for the list of project guids and their associated outputs.
     /// While there's nothing that would prevent resolution of MSBuild projects in this task, the IDE
     /// only pre-resolves non-MSBuild projects so that we can separate MSBuild project references from
     /// non-MSBuild ones and return the list of MSBuild projects as UnresolvedProjectReferences.
-    /// Then we can use more powerful MSBuild mechanisms to manipulate just the MSBuild project 
-    /// references (i.e. calling into specific targets of references to get the manifest file name) 
-    /// which would not be possible with a mixed list of MSBuild & non-MSBuild references.
+    /// Then we can use more powerful MSBuild mechanisms to manipulate just the MSBuild project
+    /// references (i.e. calling into specific targets of references to get the manifest file name)
+    /// which would not be possible with a mixed list of MSBuild and non-MSBuild references.
     /// </remarks>
     public class ResolveNonMSBuildProjectOutput : ResolveProjectBase
     {
@@ -155,9 +155,10 @@ public override bool Execute()
         #region Methods
 
         /// <summary>
-        /// Given a project reference task item and an XML document containing pre-resolved output paths, 
+        /// Given a project reference task item and an XML document containing pre-resolved output paths,
         /// find the output path for that task item.
         /// </summary>
+        /// <param name="projectRef">project reference to resolve</param>
         /// <param name="resolvedPath">resulting ITaskItem containing the resolved path</param>
         /// <returns>true if resolved successfully</returns>
         internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedPath)
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 85618b0140b..51ddc6acde9 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -140,7 +140,7 @@ public string TargetPlatformIdentifier
         {
             get
             {
-                _targetPlatformIdentifier = _targetPlatformIdentifier ?? String.Empty;
+                _targetPlatformIdentifier ??= String.Empty;
                 return _targetPlatformIdentifier;
             }
 
@@ -155,7 +155,7 @@ public string ProjectName
         {
             get
             {
-                _projectName = _projectName ?? String.Empty;
+                _projectName ??= String.Empty;
                 return _projectName;
             }
 
@@ -241,7 +241,7 @@ private Version TargetPlatformAsVersion
         {
             get
             {
-                _targetPlatformVersion = _targetPlatformVersion ?? s_defaultTargetPlatformVersion;
+                _targetPlatformVersion ??= s_defaultTargetPlatformVersion;
                 return _targetPlatformVersion;
             }
 
@@ -1381,7 +1381,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                                 // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it. 
                                 // Also, replace the entry if we have already added an entry for a non configuration specific entry and we now have a configuration specific entry that matches what we are targeting.
-                                if ((configurationComponent == null && !containsKey) || (configurationComponent != null && configurationComponent.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase)))
+                                if ((configurationComponent == null && !containsKey) || (configurationComponent?.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase) == true))
                                 {
                                     AddStatusMessage("ResolveSDKReference.FoundAppxLocation", appxLocation.Key + "=" + appxLocation.Value);
 
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index d2d62c26564..06437e4493b 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -264,7 +264,7 @@ private static void AddLinkedResource(string resxFilename, bool pathsRelativeToB
         /// </summary>
         /// <remarks>
         /// We can't hard-code byte[] type name due to version number
-        /// updates & potential whitespace issues with ResX files.
+        /// updates and potential whitespace issues with ResX files.
         ///
         /// Comment and logic from https://github.com/dotnet/winforms/blob/16b192389b377c647ab3d280130781ab1a9d3385/src/System.Windows.Forms/src/System/Resources/ResXDataNode.cs#L411-L416
         /// </remarks>
@@ -347,6 +347,5 @@ internal static string[] ParseResxFileRefString(string stringValue)
             }
             return result;
         }
-
     }
 }
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index cf37031dcda..bac55b5daee 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -10,8 +10,8 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// This class will provide the ability for classes given an SdkToolsPath and their tool name to find that tool. 
-    /// The tool will be looked for either under the SDKToolPath passed into the task or as fallback to look for the toolname using the toolslocation helper. 
+    /// This class will provide the ability for classes given an SdkToolsPath and their tool name to find that tool.
+    /// The tool will be looked for either under the SDKToolPath passed into the task or as fallback to look for the toolname using the toolslocation helper.
     /// </summary>
     internal static class SdkToolsPathUtility
     {
@@ -38,10 +38,10 @@ internal static FileExists FileInfoExists
 
         /// <summary>
         /// This method will take a sdkToolsPath and a toolName and return the path to the tool if it is found and exists.
-        /// 
+        ///
         /// First the method will try and find the tool under the sdkToolsPath taking into account the current processor architecture
         /// If the tool could not be found the method will try and find the tool under the sdkToolsPath (which should point to the x86 sdk directory).
-        /// 
+        ///
         /// Finally if the method has not found the tool yet it will fallback and use the toolslocation helper method to try and find the tool.
         /// </summary>
         /// <returns>Path including the toolName of the tool if found, null if it is not found</returns>
@@ -54,25 +54,15 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
                 string processorSpecificToolDirectory;
                 try
                 {
-                    switch (currentArchitecture)
+                    processorSpecificToolDirectory = currentArchitecture switch
                     {
                         // There may not be an arm directory so we will fall back to the x86 tool location
                         // but if there is then we should try and use it.
-                        case ProcessorArchitecture.ARM:
-                            processorSpecificToolDirectory = Path.Combine(sdkToolsPath, "arm");
-                            break;
-                        case ProcessorArchitecture.AMD64:
-                            processorSpecificToolDirectory = Path.Combine(sdkToolsPath, "x64");
-                            break;
-                        case ProcessorArchitecture.IA64:
-                            processorSpecificToolDirectory = Path.Combine(sdkToolsPath, "ia64");
-                            break;
-                        case ProcessorArchitecture.X86:
-                        default:
-                            processorSpecificToolDirectory = sdkToolsPath;
-                            break;
-                    }
-
+                        ProcessorArchitecture.ARM => Path.Combine(sdkToolsPath, "arm"),
+                        ProcessorArchitecture.AMD64 => Path.Combine(sdkToolsPath, "x64"),
+                        ProcessorArchitecture.IA64 => Path.Combine(sdkToolsPath, "ia64"),
+                        _ => sdkToolsPath,
+                    };
                     pathToTool = Path.Combine(processorSpecificToolDirectory, toolName);
 
                     if (!fileExists(pathToTool))
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index ff9adc9c4b8..8ff555870e0 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -9,7 +9,6 @@
 using System.Threading;
 using System.Security.Permissions;
 
-
 using System.ComponentModel;
 
 namespace Microsoft.Build.Tasks
@@ -62,13 +61,11 @@ protected override string GetLocalizedString(string value)
         }
     }
 
-
     /// <summary>
     ///    AutoGenerated resource class. Usage:
     ///
     ///        string s = SR.GetString(SR.MyIdenfitier);
     /// </summary>
-
     internal sealed class SR
     {
         internal const string ClassDocComment = "ClassDocComment";
@@ -135,12 +132,12 @@ public static string GetString(string name, params object[] args)
                 return null;
             string res = sys._resources.GetString(name, SR.Culture);
 
-            if (args != null && args.Length > 0)
+            if (args?.Length > 0)
             {
                 for (int i = 0; i < args.Length; i++)
                 {
                     String value = args[i] as String;
-                    if (value != null && value.Length > 1024)
+                    if (value?.Length > 1024)
                     {
                         args[i] = value.Substring(0, 1024 - 3) + "...";
                     }
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 10fe9859407..ea9cf1c27e4 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -33,7 +33,6 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private Hashtable instanceLocalFileStateCache = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
-
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
         /// cache this for long periods of time since there's no way (without actually 
@@ -48,7 +47,6 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private Dictionary<string, bool> instanceLocalDirectoryExists = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
 
-
         /// <summary>
         /// GetDirectories information is also purely instance-local. This information
         /// is only considered good for the lifetime of the task (or whatever) that owns 
@@ -155,7 +153,7 @@ internal FileState(DateTime lastModified)
             /// </summary>
             internal FileState(SerializationInfo info, StreamingContext context)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
                 lastModified = new DateTime(info.GetInt64("mod"), (DateTimeKind)info.GetInt32("modk"));
                 assemblyName = (AssemblyNameExtension)info.GetValue("an", typeof(AssemblyNameExtension));
@@ -177,7 +175,7 @@ internal FileState(SerializationInfo info, StreamingContext context)
             [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
             public void GetObjectData(SerializationInfo info, StreamingContext context)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
                 info.AddValue("mod", lastModified.Ticks);
                 info.AddValue("modk", (int)lastModified.Kind);
@@ -246,7 +244,7 @@ internal SystemState()
         /// </summary>
         internal SystemState(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             instanceLocalFileStateCache = (Hashtable)info.GetValue("fileState", typeof(Hashtable));
             isDirty = false;
@@ -257,8 +255,7 @@ internal SystemState(SerializationInfo info, StreamingContext context)
         /// This is used to optimize IO in the case of files requested from one 
         /// of the FX folders.
         /// </summary>
-        /// <param name="providedFrameworkPaths"></param>
-        /// <param name="installedAssemblyTables"></param>
+        /// <param name="installedAssemblyTableInfos"></param>
         internal void SetInstalledAssemblyInformation
         (
             AssemblyTableInfo[] installedAssemblyTableInfos
@@ -273,7 +270,7 @@ AssemblyTableInfo[] installedAssemblyTableInfos
         [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
         public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, "info");
+            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
 
             info.AddValue("fileState", instanceLocalFileStateCache);
         }
@@ -371,7 +368,6 @@ private FileState GetFileState(string path)
             upToDateLocalFileStateCache.TryGetValue(path, out FileState state);
             if (state == null)
             {   // We haven't seen this file this ResolveAssemblyReference session
-
                 state = ComputeFileStateFromCachesAndDisk(path);
                 upToDateLocalFileStateCache[path] = state;
             }
diff --git a/src/Tasks/TlbImp.cs b/src/Tasks/TlbImp.cs
index dbcd83aae6f..c54749f2baa 100644
--- a/src/Tasks/TlbImp.cs
+++ b/src/Tasks/TlbImp.cs
@@ -12,7 +12,7 @@ public sealed partial class ResolveComReference
     {
         /// <summary>
         /// Passed to the "Transform" property on the TlbImp task to indicate
-        /// what transforms, if any, to apply to the type library during 
+        /// what transforms, if any, to apply to the type library during
         /// assembly generation
         /// </summary>
         internal enum TlbImpTransformFlags
@@ -35,7 +35,7 @@ internal enum TlbImpTransformFlags
         }
 
         /// <summary>
-        /// Defines the "TlbImp" MSBuild task, which enables using TlbImp.exe 
+        /// Defines the "TlbImp" MSBuild task, which enables using TlbImp.exe
         /// to generate assemblies from type libraries.
         /// </summary>
         internal class TlbImp : AxTlbBaseTask
@@ -296,46 +296,38 @@ private TlbImpTransformFlags GetTlbImpTransformFlagsParameterWithDefault(string
             }
 
             /// <summary>
-            /// Verifies that an allowed combination of TlbImpTransformFlags has been 
+            /// Verifies that an allowed combination of TlbImpTransformFlags has been
             /// passed to the Transform property.
             /// </summary>
             /// <returns>True if Transform is valid and false otherwise</returns>
             private bool ValidateTransformFlags()
             {
                 // Any flag on its own is fine ...
-                switch (Transform)
+                return Transform switch
                 {
-                    case TlbImpTransformFlags.None:
-                        return true;
-                    case TlbImpTransformFlags.SerializableValueClasses:
-                        return true;
-                    case TlbImpTransformFlags.TransformDispRetVals:
-                        return true;
-                }
-
-                // ... But any and all other combinations of flags are disallowed.
-                return false;
+                    TlbImpTransformFlags.None => true,
+                    TlbImpTransformFlags.SerializableValueClasses => true,
+                    TlbImpTransformFlags.TransformDispRetVals => true,
+                    // ... But any and all other combinations of flags are disallowed.
+                    _ => false,
+                };
             }
 
             /// <summary>
-            /// Converts a given flag to the equivalent parameter passed to the /transform: 
+            /// Converts a given flag to the equivalent parameter passed to the /transform:
             /// option of tlbimp.exe
             /// </summary>
             /// <param name="flags">The TlbImpTransformFlags being converted</param>
             /// <returns>A string that can be passed to /transform: on the command line</returns>
             private static string ConvertTransformFlagsToCommandLineCommand(TlbImpTransformFlags flags)
             {
-                switch (flags)
+                return flags switch
                 {
-                    case TlbImpTransformFlags.None:
-                        return null;
-                    case TlbImpTransformFlags.SerializableValueClasses:
-                        return "SerializableValueClasses";
-                    case TlbImpTransformFlags.TransformDispRetVals:
-                        return "DispRet";
-                }
-
-                return null;
+                    TlbImpTransformFlags.None => null,
+                    TlbImpTransformFlags.SerializableValueClasses => "SerializableValueClasses",
+                    TlbImpTransformFlags.TransformDispRetVals => "DispRet",
+                    _ => null,
+                };
             }
 
             #endregion // ToolTask Members
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 5cf76a06636..c6cc0e606b9 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -34,16 +34,23 @@ internal class TlbReference : AxTlbBaseReference, ITypeLibImporterNotifySink
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
+        /// <param name="referenceFiles">List of referenc files</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
         /// <param name="outputDirectory">directory we should write the wrapper to</param>
+        /// <param name="hasTemporaryWrapper">Whether it has a temporary wrapper</param>
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
+        /// <param name="noClassMembers">Whether it has no class members</param>
+        /// <param name="targetProcessorArchitecture">Architecture to seek.</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using tlbimp.exe</param>
         /// <param name="sdkToolsPath">Path to the SDK tools directory where tlbimp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, IEnumerable<string> referenceFiles, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool hasTemporaryWrapper,
             bool delaySign, string keyFile, string keyContainer, bool noClassMembers, string targetProcessorArchitecture, bool includeTypeLibVersionInName, bool executeAsTool, string sdkToolsPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, resolverCallback, referenceInfo, itemName, outputDirectory, delaySign, keyFile, keyContainer, includeTypeLibVersionInName, executeAsTool, sdkToolsPath, buildEngine, environmentVariables)
@@ -171,7 +178,7 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
                     // that the set of references will also contain the file that is meant to be written here (when reference resolution
                     // found the file in the output folder). We need to filter out this case.
                     var fullPathToOutput = Path.GetFullPath(wrapperPath); // Current directory is the directory of the project file.
-                    tlbImp.ReferenceFiles = _referenceFiles.Where(rf => String.Compare(fullPathToOutput, rf, StringComparison.OrdinalIgnoreCase) != 0).ToArray();
+                    tlbImp.ReferenceFiles = _referenceFiles.Where(rf => !String.Equals(fullPathToOutput, rf, StringComparison.OrdinalIgnoreCase)).ToArray();
                 }
 
                 switch (_targetProcessorArchitecture)
diff --git a/src/Tasks/ToolTaskExtension.cs b/src/Tasks/ToolTaskExtension.cs
index d9c1238bb32..b421c0253a8 100644
--- a/src/Tasks/ToolTaskExtension.cs
+++ b/src/Tasks/ToolTaskExtension.cs
@@ -91,7 +91,6 @@ protected internal int GetIntParameterWithDefault(string parameterName, int defa
         /// Will only be called if the task returned a non empty string from GetResponseFileCommands
         /// Called after ValidateParameters, SkipTaskExecution and GetResponseFileCommands
         /// </summary>
-        /// <param name="responseFilePath">full path to the temporarily created response file</param>
         /// <returns></returns>
         protected override string GenerateResponseFileCommands()
         {
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 928fb7aecce..cbcde5d8ef8 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -78,7 +78,7 @@ public override bool Execute()
                 for (int i = 0; i < Assemblies.Length; i++)
                 {
                     // if the type lib path is not supplied, generate default one
-                    if (TypeLibFiles != null && TypeLibFiles[i] != null && TypeLibFiles[i].ItemSpec.Length > 0)
+                    if (TypeLibFiles?[i]?.ItemSpec.Length > 0)
                     {
                         cacheFile.AddEntry(Assemblies[i].ItemSpec, TypeLibFiles[i].ItemSpec);
                     }
@@ -142,7 +142,7 @@ public override bool Execute()
         /// </summary>
         private bool Unregister(string assemblyPath, string typeLibPath)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, "typeLibPath");
+            ErrorUtilities.VerifyThrowArgumentNull(typeLibPath, nameof(typeLibPath));
 
             Log.LogMessageFromResources(MessageImportance.Low, "UnregisterAssembly.UnregisteringAssembly", assemblyPath);
 
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index acaa9cb6dd3..71be097965b 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -102,7 +102,7 @@ public override bool Execute()
                     OutputFile = new TaskItem(Path.Combine(OutputDirectory.ItemSpec, OutputFile.ItemSpec));
                 }
 
-                OutputFile = OutputFile ?? new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, extension));
+                OutputFile ??= new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, extension));
 
                 File.WriteAllText(OutputFile.ItemSpec, code); // Overwrites file if it already exists (and can be overwritten)
             }
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 2ca1d976b8d..41d74bb1934 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -327,8 +327,8 @@ internal bool HasSwitch(string propertyName)
         }
 
         /// <summary>
-        /// Returns true if the property exists (regardless of whether it is 
-        /// set or not) and false otherwise. 
+        /// Returns true if the property exists (regardless of whether it is
+        /// set or not) and false otherwise.
         /// </summary>
         internal bool PropertyExists(string propertyName)
         {
@@ -526,10 +526,10 @@ private string GatherArguments(string parentSwitch, ICollection<Tuple<string, bo
                     {
                         if (!String.IsNullOrEmpty(retVal))
                         {
-                            retVal = retVal + separator;
+                            retVal += separator;
                         }
 
-                        retVal = retVal + argSwitch.Value;
+                        retVal += argSwitch.Value;
                     }
                     else
                     {
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 50f1c3872cd..1f7722260d3 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -109,7 +109,7 @@ internal class RelationsParser
         private const string switchAttribute = "SWITCH";
 
         #endregion
-        
+
         #region Properties
 
         /// <summary>
@@ -474,7 +474,6 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
                             }
                         }
                     }
-
                     else if (String.Equals(child.Name, includedPlatformType, StringComparison.OrdinalIgnoreCase))
                     {
                         foreach (XmlAttribute attrib in child.Attributes)
@@ -530,7 +529,7 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
         }
 
         /// <summary>
-        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
+        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for
         /// this parameter group
         /// </summary>
         private static SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations switchGroup)
@@ -573,7 +572,7 @@ private void LogError(string messageResourceName, params object[] messageArgs)
         }
 
         /// <summary>
-        /// An XML document can have many root nodes, but usually we want the single root 
+        /// An XML document can have many root nodes, but usually we want the single root
         /// element. Callers can test each root node in turn with this method, until it returns
         /// true.
         /// </summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index ad88b5c4039..b0aeb1c7198 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -420,7 +420,7 @@ internal CodeCompileUnit GenerateCode()
         }
 
         /// <summary>
-        /// Generates a method called "AddDefaultsToActiveSwitchList" that takes all of the properties that have 
+        /// Generates a method called "AddDefaultsToActiveSwitchList" that takes all of the properties that have
         /// default values and adds them to the active switch list
         /// </summary>
         private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass)
@@ -469,7 +469,7 @@ private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass)
         }
 
         /// <summary>
-        /// Generates a method called "AddFallbacksToActiveSwitchList" that takes all of the properties that 
+        /// Generates a method called "AddFallbacksToActiveSwitchList" that takes all of the properties that
         /// are not set but have fallbacks and adds the fallbacks to the active list if they are set.
         /// </summary>
         private void GenerateFallbacks(CodeTypeDeclaration taskClass)
@@ -992,7 +992,7 @@ private bool ContainsCurrentPlatform(string SwitchValue)
         }
 
         /// <summary>
-        /// This method generates overrides array 
+        /// This method generates overrides array
         /// </summary>
         private void GenerateOverrides(Property property, CodeMemberProperty propertyName)
         {
@@ -1171,7 +1171,7 @@ private void GenerateRelations(CodeTypeDeclaration taskClass)
                     if (switchRelations.Value.Requires.Count > 0)
                     {
                         var checkRequired = new CodeConditionStatement { Condition = null };
-                        
+
                         foreach (string required in switchRelations.Value.Requires)
                         {
                             if (checkRequired.Condition != null)
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index e99eb57997d..3e1f9e5d32f 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -387,7 +387,7 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
                 propertyToAdd.Arguments.Add(arg);
             }
 
-            if (argumentDependencyLookup != null && !argumentDependencyLookup.ContainsKey(propertyToAdd.Name))
+            if (argumentDependencyLookup?.ContainsKey(propertyToAdd.Name) == false)
             {
                 argumentDependencyLookup.Add(propertyToAdd.Name, propertyToAdd);
             }
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index bbd77b0b8a2..a6483ae584e 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -234,7 +234,7 @@ internal void ValidateOverrides()
             {
                 foreach (KeyValuePair<string, string> overridePair in overriddenSwitch.Value.Overrides)
                 {
-                    if (String.Equals(overridePair.Key, (overriddenSwitch.Value.Type == CommandLineToolSwitchType.Boolean && overriddenSwitch.Value.BooleanValue == false) ? overriddenSwitch.Value.ReverseSwitchValue.TrimStart('/') : overriddenSwitch.Value.SwitchValue.TrimStart('/'), StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(overridePair.Key, (overriddenSwitch.Value.Type == CommandLineToolSwitchType.Boolean && !overriddenSwitch.Value.BooleanValue) ? overriddenSwitch.Value.ReverseSwitchValue.TrimStart('/') : overriddenSwitch.Value.SwitchValue.TrimStart('/'), StringComparison.OrdinalIgnoreCase))
                     {
                         foreach (KeyValuePair<string, CommandLineToolSwitch> overrideTarget in ActiveToolSwitches)
                         {
@@ -245,7 +245,7 @@ internal void ValidateOverrides()
                                     overriddenSwitches.Add(overrideTarget.Key);
                                     break;
                                 }
-                                else if ((overrideTarget.Value.Type == CommandLineToolSwitchType.Boolean) && (overrideTarget.Value.BooleanValue == false) && String.Equals(overrideTarget.Value.ReverseSwitchValue.TrimStart('/'), overridePair.Value, StringComparison.OrdinalIgnoreCase))
+                                else if ((overrideTarget.Value.Type == CommandLineToolSwitchType.Boolean) && (!overrideTarget.Value.BooleanValue) && String.Equals(overrideTarget.Value.ReverseSwitchValue.TrimStart('/'), overridePair.Value, StringComparison.OrdinalIgnoreCase))
                                 {
                                     overriddenSwitches.Add(overrideTarget.Key);
                                     break;
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 7466911e233..5a722627479 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -83,8 +83,8 @@ public Type TaskType
         /// </summary>
         public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
-            ErrorUtilities.VerifyThrowArgumentNull(taskParameters, "taskParameters");
+            ErrorUtilities.VerifyThrowArgumentNull(taskName, nameof(taskName));
+            ErrorUtilities.VerifyThrowArgumentNull(taskParameters, nameof(taskParameters));
 
             var log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName)
             {
@@ -211,7 +211,7 @@ public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
         /// </remarks>
         public void CleanupTask(ITask task)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(task, "task");
+            ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index 80543f08545..562468ff8ec 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -467,7 +467,6 @@ public void TestVerifyThrowElse()
             }
            );
         }
-
         
     }
 
diff --git a/src/Utilities.UnitTests/MuxLogger_Tests.cs b/src/Utilities.UnitTests/MuxLogger_Tests.cs
index f4bdda15924..21fcfb9f78c 100644
--- a/src/Utilities.UnitTests/MuxLogger_Tests.cs
+++ b/src/Utilities.UnitTests/MuxLogger_Tests.cs
@@ -313,14 +313,12 @@ public void RegisteringLoggerDuringBuildThrowsException()
 
                     // This call should throw an InvalidOperationException
                     muxLogger.RegisterLogger(submission.SubmissionId, mockLogger);
-
                 }
                 finally
                 {
                     buildManager.EndBuild();
                 }
             });
-
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/PlatformManifest_Tests.cs b/src/Utilities.UnitTests/PlatformManifest_Tests.cs
index 8e0e38be62d..79522881a6c 100644
--- a/src/Utilities.UnitTests/PlatformManifest_Tests.cs
+++ b/src/Utilities.UnitTests/PlatformManifest_Tests.cs
@@ -54,7 +54,7 @@ public void EmptyManifestLocation()
         }
 
         /// <summary>
-        /// Should get a read error when the manifest location is valid but doesn't have a 
+        /// Should get a read error when the manifest location is valid but doesn't have a
         /// file named Platform.xml
         /// </summary>
         [Fact]
@@ -80,7 +80,7 @@ public void ManifestLocationHasNoPlatformXml()
         }
 
         /// <summary>
-        /// Should get a read error when trying to read an invalid manifest file. 
+        /// Should get a read error when trying to read an invalid manifest file.
         /// </summary>
         [Fact]
         public void InvalidManifest()
@@ -94,7 +94,7 @@ public void InvalidManifest()
         }
 
         /// <summary>
-        /// Verify that a simple PlatformManifest can be successfully constructed. 
+        /// Verify that a simple PlatformManifest can be successfully constructed.
         /// </summary>
         [Fact]
         public void SimpleValidManifest()
@@ -114,8 +114,8 @@ public void SimpleValidManifest()
         }
 
         /// <summary>
-        /// Verify that a simple PlatformManifest can be successfully constructed, even if it's missing 
-        /// some fields. 
+        /// Verify that a simple PlatformManifest can be successfully constructed, even if it's missing
+        /// some fields.
         /// </summary>
         [Fact]
         public void SimpleValidManifestWithMissingFriendlyName()
@@ -135,8 +135,8 @@ public void SimpleValidManifestWithMissingFriendlyName()
         }
 
         /// <summary>
-        /// Platform manifest with a dependent platform missing some information. 
-        /// NOTE: probably ought to be an error. 
+        /// Platform manifest with a dependent platform missing some information.
+        /// NOTE: probably ought to be an error.
         /// </summary>
         [Fact]
         public void DependentPlatformMissingName()
@@ -188,8 +188,8 @@ public void MultipleDependentPlatforms()
         }
 
         /// <summary>
-        /// Platform manifest with a contract missing some information. 
-        /// NOTE: technically probably ought to be an error. 
+        /// Platform manifest with a contract missing some information.
+        /// NOTE: technically probably ought to be an error.
         /// </summary>
         [Fact]
         public void ContractMissingVersion()
@@ -218,7 +218,7 @@ public void ContractMissingVersion()
         }
 
         /// <summary>
-        /// Verify a platform manifest with API contracts. 
+        /// Verify a platform manifest with API contracts.
         /// </summary>
         [Fact]
         public void MultipleContracts()
@@ -301,8 +301,8 @@ public void VersionedContentTrueFlagReturnsTrue()
         }
 
         /// <summary>
-        /// Wrapper around PlatformManifest that creates one with the specified content in 
-        /// the temporary directory and deletes it on disposal. 
+        /// Wrapper around PlatformManifest that creates one with the specified content in
+        /// the temporary directory and deletes it on disposal.
         /// </summary>
         private sealed class TemporaryPlatformManifest : IDisposable
         {
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index 77964a82a4e..990979c8840 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -14,24 +14,15 @@ public class ProcessorArchitectureTests
     {
         internal static string ProcessorArchitectureIntToString()
         {
-            switch (NativeMethodsShared.ProcessorArchitecture)
+            return NativeMethodsShared.ProcessorArchitecture switch
             {
-                case NativeMethodsShared.ProcessorArchitectures.X86:
-                    return ProcessorArchitecture.X86;
-
-                case NativeMethodsShared.ProcessorArchitectures.X64:
-                    return ProcessorArchitecture.AMD64;
-
-                case NativeMethodsShared.ProcessorArchitectures.IA64:
-                    return ProcessorArchitecture.IA64;
-
-                case NativeMethodsShared.ProcessorArchitectures.ARM:
-                    return ProcessorArchitecture.ARM;
-
+                NativeMethodsShared.ProcessorArchitectures.X86 => ProcessorArchitecture.X86,
+                NativeMethodsShared.ProcessorArchitectures.X64 => ProcessorArchitecture.AMD64,
+                NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
+                NativeMethodsShared.ProcessorArchitectures.ARM => ProcessorArchitecture.ARM,
                 // unknown architecture? return null
-                default:
-                    return null;
-            }
+                _ => null,
+            };
         }
 
         [Fact]
@@ -73,7 +64,7 @@ public void ValidateConvertDotNetFrameworkArchitectureToProcessorArchitecture()
                     procArchitecture = ToolLocationHelper.ConvertDotNetFrameworkArchitectureToProcessorArchitecture(Utilities.DotNetFrameworkArchitecture.Bitness64);
 
                     //We should also allow NULL if the machine is true x86 only.
-                    bool isValidResult = procArchitecture == null || procArchitecture.Equals(ProcessorArchitecture.AMD64) || procArchitecture.Equals(ProcessorArchitecture.IA64);
+                    bool isValidResult = procArchitecture?.Equals(ProcessorArchitecture.AMD64) != false || procArchitecture.Equals(ProcessorArchitecture.IA64);
 
                     isValidResult.ShouldBeTrue();
                     break;
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 124ef58cb6b..49c97bdefbc 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -180,7 +180,6 @@ public void CheckMetadataCount()
             t.MetadataCount.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length + 1);
         }
 
-
         [Fact]
         public void NonexistentRequestFullPath()
         {
@@ -420,7 +419,7 @@ public ITaskItem[] CreatedTaskItems
             /// </summary>
             public void Run(string[] includes, IDictionary<string, string> metadataToAdd)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(includes, "includes");
+                ErrorUtilities.VerifyThrowArgumentNull(includes, nameof(includes));
 
                 CreatedTaskItems = new TaskItem[includes.Length];
 
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 45f8705a621..d94dc519c00 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -18,8 +18,6 @@
 using Microsoft.Win32;
 #endif
 
-
-
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using UtilitiesDotNetFrameworkArchitecture = Microsoft.Build.Utilities.DotNetFrameworkArchitecture;
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
@@ -717,17 +715,11 @@ public void TestGetPathToBuildToolsFile()
         {
             string net20Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version20);
 
-            if (net20Path != null)
-            {
-                net20Path.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "2.0"));
-            }
+            net20Path?.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "2.0"));
 
             string net35Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version35);
 
-            if (net35Path != null)
-            {
-                net35Path.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "3.5"));
-            }
+            net35Path?.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "3.5"));
 
             ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version40).ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "4.0"));
 
@@ -754,7 +746,6 @@ public void TestGetPathToBuildToolsFile_32Bit()
             ToolLocationHelper.GetPathToDotNetFrameworkFile("msbuild.exe", TargetDotNetFrameworkVersion.Version40, UtilitiesDotNetFrameworkArchitecture.Bitness32).ShouldBe(
                     ToolLocationHelper.GetPathToBuildToolsFile("msbuild.exe", "4.0", UtilitiesDotNetFrameworkArchitecture.Bitness32));
 
-
             var toolsPath32 = ProjectCollection.GlobalProjectCollection.GetToolset(ObjectModelHelpers.MSBuildDefaultToolsVersion).Properties["MSBuildToolsPath32"];
             string tv12path = Path.Combine(Path.GetFullPath(toolsPath32.EvaluatedValue), "msbuild.exe");
 
@@ -834,7 +825,6 @@ public void TestGetDotNetFrameworkSdkRootRegistryKey()
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version46, VisualStudioVersion.Version120) );
             ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version46, VisualStudioVersion.Version140).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK46);
 
-
             // v4.6.1
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version461, VisualStudioVersion.Version100) );
             Should.Throw<ArgumentException>( () => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version461, VisualStudioVersion.Version110) );
@@ -1728,7 +1718,6 @@ public void GetPathToReferenceAssembliesWithRootGoodWithChain()
             string framework39redistDirectory = Path.Combine(framework39Directory, "RedistList");
             string framework39RedistList = Path.Combine(framework39redistDirectory, "FrameworkList.xml");
 
-
             try
             {
                 Directory.CreateDirectory(framework41redistDirectory);
@@ -1739,7 +1728,6 @@ public void GetPathToReferenceAssembliesWithRootGoodWithChain()
                 File.WriteAllText(framework40RedistList, redistString40);
                 File.WriteAllText(framework41RedistList, redistString41);
 
-
                 FrameworkNameVersioning frameworkName = new FrameworkNameVersioning("MyFramework", new Version("4.1"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(tempDirectory, frameworkName);
 
@@ -1823,7 +1811,6 @@ public void DisplayNameGeneration()
             }
         }
 
-
         /// <summary>
         /// Make sure we do not crash if there is a circular reference in the redist lists, we should only have a path in our reference assembly list once.
         ///
@@ -1859,7 +1846,6 @@ public void GetPathToReferenceAssembliesWithRootCircularReference()
                 File.WriteAllText(framework40RedistList, redistString40);
                 File.WriteAllText(framework41RedistList, redistString41);
 
-
                 FrameworkNameVersioning frameworkName = new FrameworkNameVersioning("MyFramework", new Version("4.1"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(tempDirectory, frameworkName);
 
@@ -2132,7 +2118,6 @@ public void LegacyFramework30WithNo20Installed()
             list[1].ShouldBe(LegacyFrameworkTestHelper.DotNet30FrameworkPath, StringCompareShould.IgnoreCase);
         }
 
-
         /// <summary>
         /// Verify when 35 is simulated to be installed that the method returns the 3.5 directory
         /// </summary>
@@ -2170,7 +2155,6 @@ public void LegacyFramework35NotInstalled()
             list.Count.ShouldBe(0);
         }
 
-
         /// <summary>
         /// Verify when 35 reference assembly are simulated to not be installed that the method returns an empty list
         /// </summary>
@@ -3382,7 +3366,6 @@ public void VerifySDKManifest()
 
                 string manifestFile = Path.Combine(manifestPath, "SDKManifest.xml");
 
-
                 string manifestPlatformSDK = @"
                 <FileList
                     DisplayName = ""Windows""
@@ -3450,7 +3433,6 @@ public void VerifySDKManifest()
                     </File>
                 </FileList>";
 
-
                 File.WriteAllText(manifestFile, manifestExtensionSDK);
                 sdkManifest = new SDKManifest(manifestPath);
 
@@ -3830,7 +3812,6 @@ public void VerifyGetInstalledSDKLocations3()
                     folderKey.SetValue("", Path.Combine(testDirectoryRoot, platformDirectory));
                 }
 
-
                 if (Directory.Exists(testDirectoryRoot))
                 {
                     FileUtilities.DeleteDirectoryNoThrow(testDirectoryRoot, true);
@@ -4237,7 +4218,6 @@ public void VerifyFindRootFolderWhereAllFilesExist()
             ToolLocationHelper.FindRootFolderWhereAllFilesExist(@"c:<>;" + roots, "file1.txt").ShouldBe(rootDirectories[0]); // should ignore invalid dir
         }
 
-
 #if FEATURE_REGISTRY_SDKS
         /// <summary>
         /// Verify that the GetPlatformSDKPropsFileLocation method can be correctly called for pre-OneCore SDKs during evaluation time as a msbuild function.
@@ -4697,52 +4677,52 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "Windows", "MyPlatform" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v1.0", "1.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v1.1", "1.0", "2.0", "3.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "2.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "4.0", "5.0", "6.0", "9.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { string.Empty };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "1.0" };
                 }
@@ -4750,22 +4730,22 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "Windows" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v2.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "3.0" };
                 }
@@ -4785,54 +4765,54 @@ private string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey)
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\v1.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
                 // This has a v in the sdk version and should not be found but we need a real path in case it is so it will show up in the returned list and fail the test.
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\v1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\v1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\v1.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly\2.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly\2.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\1.0\\ExtensionSDKs\\MyAssembly\\2.0");
                 }
 
                 // This has a set of bad char in the returned directory so it should not be allowed.
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return _fakeStructureRoot + @"\Windows\1.0\ExtensionSDKs\MyAssembly\<>?/";
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "MyPlatform\\5.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "SomeOtherPlace\\MyPlatformOtherLocation\\4.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\6.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\6.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows Kits\\6.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\9.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\9.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "MyPlatform\\9.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "SomeOtherPlace\\MyPlatformOtherLocation\\4.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\1.0");
                 }
@@ -4840,12 +4820,12 @@ private string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey)
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\2.0\\ExtensionSDKs\\MyAssembly\\3.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\2.0");
                 }
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 78c523c03ed..d8c69b18f9e 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -856,6 +856,5 @@ protected override string GenerateCommandLineCommands()
                 return $"echo łoł > {OutputPath}";
             }
         }
-
     }
 }
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index a1654a3ea8e..c71b51aaed0 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -1408,7 +1408,7 @@ public void InProcTrackingStartProcessFindStrNullCommandLine()
                 startInfo.hStdInput = BackEndNativeMethods.InvalidHandle;
                 startInfo.hStdOutput = BackEndNativeMethods.InvalidHandle;
                 startInfo.dwFlags = BackEndNativeMethods.STARTFUSESTDHANDLES;
-                dwCreationFlags = dwCreationFlags | BackEndNativeMethods.CREATENOWINDOW;
+                dwCreationFlags |= BackEndNativeMethods.CREATENOWINDOW;
 
                 BackEndNativeMethods.SECURITY_ATTRIBUTES pSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
                 BackEndNativeMethods.SECURITY_ATTRIBUTES tSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
@@ -2226,7 +2226,6 @@ public void LaunchMultipleOfSameTool_DifferentContexts()
             {
                 FileUtilities.DeleteDirectoryNoThrow(testDir, true);
             }
-
         }
 
         [Fact(Skip = "Needs investigation")]
@@ -2393,7 +2392,7 @@ private static void LaunchDuplicateToolsAndVerifyTlogExistsForEach(string tlogPa
                 startInfo.hStdInput = BackEndNativeMethods.InvalidHandle;
                 startInfo.hStdOutput = BackEndNativeMethods.InvalidHandle;
                 startInfo.dwFlags = BackEndNativeMethods.STARTFUSESTDHANDLES;
-                dwCreationFlags = dwCreationFlags | BackEndNativeMethods.CREATENOWINDOW;
+                dwCreationFlags |= BackEndNativeMethods.CREATENOWINDOW;
 
                 BackEndNativeMethods.SECURITY_ATTRIBUTES pSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
                 BackEndNativeMethods.SECURITY_ATTRIBUTES tSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 6dceadcfa27..cb671c25576 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -12,8 +12,6 @@
 using Microsoft.Build.Utilities;
 using Xunit;
 
-
-
 #pragma warning disable 0219
 
 #if FEATURE_FILE_TRACKER
@@ -1212,7 +1210,7 @@ public void MultipleCanonicalCLMissingOutputDependencyRemoved()
             compactOutputs.SaveTlog(delegate (string fullTrackedPath)
             {
                 // We need to answer the question "should fullTrackedPath be included in the TLog?"
-                return (string.Compare(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase) != 0);
+                return (!string.Equals(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase));
             });
 
             // Read the Tlogs back in..
@@ -1235,7 +1233,6 @@ public void MultipleCanonicalCLMissingOutputDependencyRemoved()
             Assert.Empty(outofDate);
         }
 
-
         [Fact]
         public void MultipleCanonicalCLMissingInputDependencyRemoved()
         {
@@ -1282,7 +1279,7 @@ public void MultipleCanonicalCLMissingInputDependencyRemoved()
             d.SaveTlog(delegate (string fullTrackedPath)
             {
                 // We need to answer the question "should fullTrackedPath be included in the TLog?"
-                return (string.Compare(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase) != 0);
+                return (!string.Equals(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase));
             });
 
             // read the tlog back in again
@@ -1302,7 +1299,6 @@ public void MultipleCanonicalCLMissingInputDependencyRemoved()
             Assert.Empty(outofdate);
         }
 
-
         [Fact]
         public void MultiplePrimaryCanonicalCL()
         {
@@ -1959,7 +1955,6 @@ public void MultipleRootedCLAcrossTlogs2()
             Assert.True(outofdate[0].ItemSpec == Path.Combine("TestFiles", "one.cpp"));
         }
 
-
         [Fact]
         public void OutputSingleCanonicalCL()
         {
@@ -2412,7 +2407,6 @@ public void OutputCLMinimalRebuildOptimization()
                 Path.GetFullPath(Path.Combine("TestFiles", "three.obj")),
             });
 
-
             // Represent our tracked and computed outputs
             CanonicalTrackedOutputFiles outputs = new CanonicalTrackedOutputFiles(DependencyTestHelper.MockTask, DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog"))));
 
@@ -2507,7 +2501,6 @@ public void OutputCLMinimalRebuildOptimizationComputed()
                 Path.GetFullPath(Path.Combine("TestFiles", "three.obj")),
             });
 
-
             // Represent our tracked and computed outputs
             CanonicalTrackedOutputFiles outputs = new CanonicalTrackedOutputFiles(DependencyTestHelper.MockTask, DependencyTestHelper.ItemArray(new TaskItem(Path.Combine("TestFiles", "one.write.tlog"))));
 
@@ -3529,7 +3522,6 @@ public void FlatTrackingDataInputOrOutputNewerThanTracking()
             // We should be out of date inputs & outputs vs tracking (since we wrote the files after the tracking logs)
             Assert.False(FlatTrackingData.IsUpToDate(DependencyTestHelper.MockTask.Log, UpToDateCheckType.InputOrOutputNewerThanTracking, inputs, outputs));
 
-
             // Touch the tracking logs so that are more recent that any of the inputs
             Thread.Sleep(_sleepTimeMilliseconds);
             File.SetLastWriteTime(Path.Combine("TestFiles", "one.read.tlog"), DateTime.Now);
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index 64c4bf0430a..8e7953b699f 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -109,7 +109,6 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         /// <returns></returns>
         public override string ToString() => CommandLine.ToString();
 
-
         // Use if escaping of hyphens is supposed to take place
         private static readonly string s_allowedUnquotedRegexNoHyphen =
                          "^"                             // Beginning of line
@@ -401,7 +400,7 @@ public void AppendFileNamesIfNotNull(string[] fileNames, string delimiter)
         {
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (fileNames != null && fileNames.Length > 0)
+            if (fileNames?.Length > 0)
             {
                 // Don't let injection attackers escape from our quotes by sticking in
                 // their own quotes. Quotes are illegal.
@@ -436,7 +435,7 @@ public void AppendFileNamesIfNotNull(ITaskItem[] fileItems, string delimiter)
         {
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (fileItems != null && fileItems.Length > 0)
+            if (fileItems?.Length > 0)
             {
                 // Don't let injection attackers escape from our quotes by sticking in
                 // their own quotes. Quotes are illegal.
@@ -572,7 +571,7 @@ public void AppendSwitchIfNotNull(string switchName, string[] parameters, string
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -604,7 +603,7 @@ public void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, str
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -683,7 +682,7 @@ public void AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -714,7 +713,7 @@ public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem[] paramet
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 145aee2eb51..b6abb5f011d 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -1230,7 +1230,7 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // logger is registered without a ProjectFinished handler, but does have an Any handler (as the mock logger does) then we would end up
                     // sending the BuildFinished event before the ProjectFinished event got processed in the Any handler.
                     ProjectFinishedEventArgs projectFinishedEvent = buildEvent as ProjectFinishedEventArgs;
-                    if (projectFinishedEvent != null && buildEvent.BuildEventContext != null && buildEvent.BuildEventContext.Equals(_firstProjectStartedEventContext))
+                    if (projectFinishedEvent != null && buildEvent.BuildEventContext?.Equals(_firstProjectStartedEventContext) == true)
                     {
                         string message = projectFinishedEvent.Succeeded ? ResourceUtilities.GetResourceString("MuxLogger_BuildFinishedSuccess") : ResourceUtilities.GetResourceString("MuxLogger_BuildFinishedFailure");
                         RaiseBuildFinishedEvent(sender, new BuildFinishedEventArgs(message, null, projectFinishedEvent.Succeeded));
diff --git a/src/Utilities/ProcessorArchitecture.cs b/src/Utilities/ProcessorArchitecture.cs
index abdced9c21f..0b12a2ceb81 100644
--- a/src/Utilities/ProcessorArchitecture.cs
+++ b/src/Utilities/ProcessorArchitecture.cs
@@ -55,36 +55,16 @@ public static class ProcessorArchitecture
         /// <returns>null if unknown architecture or error, one of the known architectures otherwise</returns>
         private static string GetCurrentProcessArchitecture()
         {
-            string architecture;
-
-            switch (NativeMethodsShared.ProcessorArchitecture)
+            string architecture = NativeMethodsShared.ProcessorArchitecture switch
             {
-                case NativeMethodsShared.ProcessorArchitectures.X86:
-                    architecture = X86;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.X64:
-                    architecture = AMD64;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.IA64:
-                    architecture = IA64;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.ARM:
-                    architecture = ARM;
-                    break;
-
-                case NativeMethodsShared.ProcessorArchitectures.ARM64:
-                    architecture = ARM64;
-                    break;
-
+                NativeMethodsShared.ProcessorArchitectures.X86 => X86,
+                NativeMethodsShared.ProcessorArchitectures.X64 => AMD64,
+                NativeMethodsShared.ProcessorArchitectures.IA64 => IA64,
+                NativeMethodsShared.ProcessorArchitectures.ARM => ARM,
+                NativeMethodsShared.ProcessorArchitectures.ARM64 => ARM64,
                 // unknown architecture? return null
-                default:
-                    architecture = null;
-                    break;
-            }
-
+                _ => null,
+            };
             return architecture;
         }
     }
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index a7c19160911..429a215a58a 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -264,7 +264,7 @@ string metadataValue
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(metadataName),
                 "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-            _metadata = _metadata ?? new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+            _metadata ??= new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
             _metadata[metadataName] = metadataValue ?? string.Empty;
         }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 82cd4cc9d4a..e05d4970bbf 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -125,7 +125,7 @@ public enum TargetDotNetFrameworkVersion
     }
 
     /// <summary>
-    /// Used to specify the version of Visual Studio from which to select associated 
+    /// Used to specify the version of Visual Studio from which to select associated
     /// tools for some methods of ToolLocationHelper
     /// </summary>
     public enum VisualStudioVersion
@@ -168,7 +168,7 @@ public enum VisualStudioVersion
     public enum DotNetFrameworkArchitecture
     {
         /// <summary>
-        /// Indicates the .NET Framework that is currently being run under.  
+        /// Indicates the .NET Framework that is currently being run under.
         /// </summary>
         Current = 0,
 
@@ -208,7 +208,7 @@ public static class ToolLocationHelper
         private static Dictionary<string, IList<string>> s_cachedReferenceAssemblyPaths;
 
         /// <summary>
-        /// Cache the frameworkName of the highest version of a framework given its root path and identifier. 
+        /// Cache the frameworkName of the highest version of a framework given its root path and identifier.
         /// This is to optimize calls to GetHighestVersionOfTargetFramework
         /// </summary>
         private static Dictionary<string, FrameworkNameVersioning> s_cachedHighestFrameworkNameForTargetFrameworkIdentifier;
@@ -231,7 +231,7 @@ public static class ToolLocationHelper
         private static Dictionary<string, string> s_cachedTargetFrameworkDisplayNames;
 
         /// <summary>
-        /// Cache the set of target platform references for a particular combination of inputs.  For legacy 
+        /// Cache the set of target platform references for a particular combination of inputs.  For legacy
         /// target platforms, this is just grabbing all winmds from the References\CommonConfiguration\Neutral
         /// folder; for OneCore-based platforms, this involves reading the list from Platform.xml and synthesizing
         /// the locations.
@@ -279,14 +279,14 @@ public static class ToolLocationHelper
         #region Public methods
 
         /// <summary>
-        /// The current ToolsVersion. 
+        /// The current ToolsVersion.
         /// </summary>
         public static string CurrentToolsVersion => MSBuildConstants.CurrentToolsVersion;
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Get a sorted list of AssemblyFoldersExInfo which contain information about what directories the 3rd party assemblies are registered under for use during build and design time.
-        /// 
+        ///
         /// This method will enumerate the AssemblyFoldersEx registry location and return a list of AssemblyFoldersExInfo in the same order in which
         /// they will be searched during both design and build time for reference assemblies.
         /// </summary>
@@ -314,7 +314,6 @@ public static IList<AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string regis
 
             AssemblyFoldersEx assemblyFoldersEx = new AssemblyFoldersEx(registryRoot, targetFrameworkVersion, registryKeySuffix, osVersion, platform, new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames), new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue), targetProcessorArchitecture, new OpenBaseKey(RegistryHelper.OpenBaseKey));
 
-
             var assemblyFolders = new List<AssemblyFoldersExInfo>();
             assemblyFolders.AddRange(assemblyFoldersEx);
             return assemblyFolders;
@@ -808,7 +807,7 @@ public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, strin
         /// <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
         /// <param name="targetPlatformVersion">The version of the targeted platform</param>
         /// <param name="diskRoots">List of disk roots to search for sdks within</param>
-        /// <param name="registryRoot">Registry root to look for sdks within</param> 
+        /// <param name="registryRoot">Registry root to look for sdks within</param>
         /// <returns>Location of the target platform SDK props file without .props filename</returns>
         public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot)
         {
@@ -939,7 +938,6 @@ public static string[] GetPlatformOrFrameworkExtensionSdkReferences
                 string targetPlatformVersion
             )
         {
-
             lock (s_locker)
             {
                 if (s_cachedExtensionSdkReferences == null)
@@ -998,7 +996,7 @@ string targetPlatformVersion
         private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string targetPlatformIdentifier, string targetPlatformVersion)
         {
             string platformKey = TargetPlatformSDK.GetSdkKey(targetPlatformIdentifier, targetPlatformVersion);
-            if (TryGetPlatformManifest(targetSdk, platformKey, out var manifest) && manifest != null && manifest.VersionedContent)
+            if (TryGetPlatformManifest(targetSdk, platformKey, out var manifest) && manifest?.VersionedContent == true)
             {
                 return manifest.PlatformVersion;
             }
@@ -1009,7 +1007,7 @@ private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string tar
         }
 
         /// <summary>
-        /// Gathers the set of platform winmds based on the assumption that they come from 
+        /// Gathers the set of platform winmds based on the assumption that they come from
         /// an SDK that is specified solely by TPI / TPV.
         /// </summary>
         private static string[] GetLegacyTargetPlatformReferences(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot)
@@ -1058,7 +1056,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
         }
 
         /// <summary>
-        /// Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination, 
+        /// Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination,
         /// based on the assumption that it is an SDK that has both {SDKI, SDKV} and TP* specifiers.
         /// </summary>
         private static string[] GetTargetPlatformReferencesFromManifest
@@ -1186,7 +1184,7 @@ private static bool TryGetPlatformManifest(TargetPlatformSDK matchingSdk, string
         /// <param name="sdkVersion">The verision of the SDK</param>
         /// <param name="targetPlatformIdentifier">The identifier of the targeted platform</param>
         /// <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
-        /// <param name="targetPlatformVersion">The version of the targeted platform</param> 
+        /// <param name="targetPlatformVersion">The version of the targeted platform</param>
         /// <param name="folderName">The content folder name under SDK path</param>
         /// <param name="diskRoot">An optional disk root to search.  A value should only be passed from a unit test.</param>
         /// <returns>The SDK content folder path</returns>
@@ -1296,12 +1294,12 @@ public static string GetPlatformSDKLocation(string targetPlatformIdentifier, str
         }
 
         /// <summary>
-        /// Given a target platform identifier and version, get the display name for that platform SDK. 
+        /// Given a target platform identifier and version, get the display name for that platform SDK.
         /// </summary>
         public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) => GetPlatformSDKDisplayName(targetPlatformIdentifier, targetPlatformVersion, null, null);
 
         /// <summary>
-        /// Given a target platform identifier and version, get the display name for that platform SDK. 
+        /// Given a target platform identifier and version, get the display name for that platform SDK.
         /// </summary>
         public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot)
         {
@@ -1381,7 +1379,7 @@ public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, str
                 }
             }
 
-            if (availablePlatformVersions != null && availablePlatformVersions.Count > 0)
+            if (availablePlatformVersions?.Count > 0)
             {
                 return availablePlatformVersions.OrderByDescending(x => x).FirstOrDefault().ToString();
             }
@@ -1517,9 +1515,9 @@ public static string FindRootFolderWhereAllFilesExist(string possibleRoots, stri
 
             return string.Empty;
         }
-        
+
         /// <summary>
-        /// Tries to parse the "version" out of a platformMoniker. 
+        /// Tries to parse the "version" out of a platformMoniker.
         /// </summary>
         /// <param name="platformMoniker">PlatformMoniker, in the form "PlatformName, Version=version"</param>
         /// <param name="platformVersion">The version of the platform, if the parse was successful - Else set to null</param>
@@ -1549,8 +1547,8 @@ private static bool TryParsePlatformVersion(string platformMoniker, out Version
         }
 
         /// <summary>
-        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
-        /// object that matches.  
+        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK
+        /// object that matches.
         /// </summary>
         private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string multiPlatformDiskRoots, string registryRoot)
         {
@@ -1577,7 +1575,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
         }
 
         /// <summary>
-        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
+        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK
         /// object that matches.
         /// </summary>
         private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot)
@@ -1604,7 +1602,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
         }
 
         /// <summary>
-        /// Given a target platform identifier and version, generate a reasonable default display name. 
+        /// Given a target platform identifier and version, generate a reasonable default display name.
         /// </summary>
         /// <param name="targetPlatformIdentifier"></param>
         /// <param name="targetPlatformVersion"></param>
@@ -1638,9 +1636,9 @@ public static string PathToSystem
 
         /// <summary>
         /// Returns the full name of the .NET Framework SDK root registry key.  When targeting .NET 3.5 or
-        /// above, looks in the locations associated with Visual Studio 2010.  If you wish to target the 
-        /// .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// above, looks in the locations associated with Visual Studio 2010.  If you wish to target the
+        /// .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version) => GetDotNetFrameworkSdkRootRegistryKey(version, VisualStudioVersion.VersionLatest);
@@ -1658,10 +1656,10 @@ public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkV
         }
 
         /// <summary>
-        /// Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path. When 
-        /// targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish 
-        /// to target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path. When
+        /// targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish
+        /// to target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version) => GetDotNetFrameworkSdkInstallKeyValue(version, VisualStudioVersion.VersionLatest);
@@ -1686,7 +1684,7 @@ public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkV
         public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version) => GetPathToDotNetFramework(version, UtilitiesDotNetFrameworkArchitecture.Current);
 
         /// <summary>
-        /// Get a fully qualified path to the framework's root directory. 
+        /// Get a fully qualified path to the framework's root directory.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <param name="architecture">Desired architecture, or DotNetFrameworkArchitecture.Current for the architecture this process is currently running under.</param>
@@ -1699,19 +1697,19 @@ public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion versi
         }
 
         /// <summary>
-        /// Returns the path to the "bin" directory of the latest .NET Framework SDK. When targeting .NET 3.5 
-        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
-        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Returns the path to the "bin" directory of the latest .NET Framework SDK. When targeting .NET 3.5
+        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target
+        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <returns>Path string.</returns>
         public static string GetPathToDotNetFrameworkSdk() => GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion.Latest);
 
         /// <summary>
-        /// Returns the path to the "bin" directory of the .NET Framework SDK. When targeting .NET 3.5 
-        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
-        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Returns the path to the "bin" directory of the .NET Framework SDK. When targeting .NET 3.5
+        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target
+        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <returns>Path string.</returns>
@@ -1803,7 +1801,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
         /// <param name="targetFrameworkProfile">Profile being targeted</param>
         /// <param name="platformTarget">What is the targeted platform, this is used to determine where we should look for the standard libraries. Note, this parameter is only used for .net frameworks less than 4.0</param>
         /// <param name="targetFrameworkRootPath">Root directory where the target framework will be looked for. Uses default path if this is null</param>
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// <exception cref="ArgumentNullException">When the frameworkName is null</exception>
         /// <returns>Collection of reference assembly locations.</returns>
         public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths)
@@ -1903,7 +1901,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkI
         /// <param name="targetFrameworkVersion">Version being targeted</param>
         /// <param name="targetFrameworkProfile">Profile being targeted</param>
         /// <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
         /// Uses the default path if this is null.
         /// </param>
@@ -1921,7 +1919,6 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkI
             return GetPathToReferenceAssemblies(targetFrameworkRootPath, targetFrameworkFallbackSearchPaths, targetFrameworkName);
         }
 
-
         /// <summary>
         /// Returns the paths to the reference assemblies location for the given target framework.
         /// This method will assume the requested ReferenceAssemblyRoot path will be the ProgramFiles directory specified by Environment.SpecialFolder.ProgramFiles
@@ -2164,7 +2161,6 @@ private static IList<string> HandleLegacy20(VersionToPath PathToDotNetFramework)
             return referencePaths;
         }
 
-
         /// <summary>
         /// Returns the paths to the reference assemblies location for the given framework version relative to a given targetFrameworkRoot.
         /// The method will not check to see if the path exists or not.
@@ -2172,7 +2168,7 @@ private static IList<string> HandleLegacy20(VersionToPath PathToDotNetFramework)
         /// <param name="targetFrameworkRootPath">Root directory which will be used to calculate the reference assembly path. The references assemblies will be
         /// generated in the following way TargetFrameworkRootPath\TargetFrameworkIdentifier\TargetFrameworkVersion\SubType\TargetFrameworkSubType.
         /// </param>
-        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the the framework cannot be found in @targetFrameworkRootPath</param>
+        /// <param name="targetFrameworkFallbackSearchPaths">';' separated list of paths that are looked up if the framework cannot be found in @targetFrameworkRootPath</param>
         /// <param name="frameworkName">A frameworkName class which represents a TargetFrameworkMoniker. This cannot be null.</param>
         /// <returns>Collection of reference assembly locations.</returns>
         public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, FrameworkNameVersioning frameworkName)
@@ -2267,7 +2263,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
         }
 
         /// <summary>
-        /// Figures out a display name given the target framework details. 
+        /// Figures out a display name given the target framework details.
         /// This is the equivalent of the target framework moniker, but for display.
         /// If one cannot be found from the redist list file, a synthesized one is returned, so there is always a display name.
         /// </summary>
@@ -2945,7 +2941,7 @@ private static void ExtractSdkDiskRootsFromEnvironment(List<string> diskRoots, s
         }
 
         /// <summary>
-        /// Get the disk roots to search for both platform and extension sdks in. The environment variable can 
+        /// Get the disk roots to search for both platform and extension sdks in. The environment variable can
         /// override the defaults.
         /// </summary>
         /// <returns></returns>
@@ -2956,7 +2952,7 @@ private static List<string> GetTargetPlatformMonikerDiskRoots(string[] diskRoots
             ExtractSdkDiskRootsFromEnvironment(sdkDiskRoots, sdkDirectoryRootsFromEnvironment);
             if (sdkDiskRoots.Count == 0)
             {
-                if (diskRoots != null && diskRoots.Length > 0)
+                if (diskRoots?.Length > 0)
                 {
                     ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerDiskRoots", "Passed in DiskRoots '{0}'", string.Join(";", diskRoots));
                     sdkDiskRoots.AddRange(diskRoots);
@@ -2973,7 +2969,7 @@ private static List<string> GetTargetPlatformMonikerDiskRoots(string[] diskRoots
         }
 
         /// <summary>
-        /// Get the disk roots to search for multi platform extension sdks in. The environment variable can 
+        /// Get the disk roots to search for multi platform extension sdks in. The environment variable can
         /// override the defaults.
         /// </summary>
         private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
@@ -2981,7 +2977,7 @@ private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
             var sdkDiskRoots = new List<string>();
             string sdkDirectoryRootsFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDMULTIPLATFORMSDKREFERENCEDIRECTORY");
             ExtractSdkDiskRootsFromEnvironment(sdkDiskRoots, sdkDirectoryRootsFromEnvironment);
-            if (sdkDiskRoots.Count == 0 && diskRoots != null && diskRoots.Length > 0)
+            if (sdkDiskRoots.Count == 0 && diskRoots?.Length > 0)
             {
                 ErrorUtilities.DebugTraceMessage("GetMultiPlatformSdkDiskRoots", "Passed in DiskRoots '{0}'", string.Join(";", diskRoots));
                 sdkDiskRoots.AddRange(diskRoots);
@@ -3020,12 +3016,11 @@ private static string GetTargetPlatformMonikerRegistryRoots(string registryRootL
                 ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerRegistryRoots", "MSBUILDDISABLEREGISTRYFORSDKLOOKUP is set registry sdk lookup is disabled");
             }
 
-
             return registryRoot;
         }
 
         /// <summary>
-        /// Given a platform SDK object, populate its supported platforms. 
+        /// Given a platform SDK object, populate its supported platforms.
         /// </summary>
         private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
         {
@@ -3091,7 +3086,7 @@ private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
         }
 
         /// <summary>
-        /// Take the path to a reference assembly directory which contains a RedistList folder which then contains a FrameworkList.xml file. 
+        /// Take the path to a reference assembly directory which contains a RedistList folder which then contains a FrameworkList.xml file.
         /// We will read in the xml file and determine if it has an IncludedFramework element in the redist list. If it does it will calculate
         /// the path where the next link in the chain should be and return that path.
         /// Also, when reading the redist list, if any display name is found it will be cached, keyed off the path passed in.
@@ -3104,8 +3099,8 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
             lock (s_locker)
             {
                 // Cache the results of the chain search so that we do not have to do an expensive read more than once per process per redist list.
-                s_chainedReferenceAssemblyPath = s_chainedReferenceAssemblyPath ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                s_cachedTargetFrameworkDisplayNames = s_cachedTargetFrameworkDisplayNames ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                s_chainedReferenceAssemblyPath ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                s_cachedTargetFrameworkDisplayNames ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 if (s_chainedReferenceAssemblyPath.TryGetValue(path, out string cachedPath))
                 {
@@ -3250,9 +3245,9 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
 
         /// <summary>
         /// Get a fully qualified path to a file in the latest .NET Framework SDK. Error if the .NET Framework SDK can't be found.
-        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
-        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to
+        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <returns>Path string.</returns>
@@ -3260,9 +3255,9 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
 
         /// <summary>
         /// Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
-        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
-        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to
+        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <param name="version">Version of the targeted .NET Framework</param>
@@ -3318,8 +3313,8 @@ public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotN
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <param name="visualStudioVersion">Version of Visual Studio</param>
         /// <param name="architecture">The required architecture of the requested file.</param>
-        /// <param name="canFallBackIfNecessary">If true, will follow the fallback pattern -- from requested architecture, to 
-        /// current architecture, to x86.  Otherwise, if the requested architecture path doesn't exist, that's it -- no path 
+        /// <param name="canFallBackIfNecessary">If true, will follow the fallback pattern -- from requested architecture, to
+        /// current architecture, to x86.  Otherwise, if the requested architecture path doesn't exist, that's it -- no path
         /// will be returned.</param>
         /// <returns></returns>
         private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, UtilitiesDotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary)
@@ -3354,7 +3349,7 @@ private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDot
         }
 
         /// <summary>
-        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
+        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path.
         /// If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
         /// </summary>
         internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string pathToSdk, string processorArchitecture)
@@ -3409,22 +3404,17 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
                     return ProcessorArchitecture.X86;
                 case DotNetFrameworkArchitecture.Bitness64:
                     // We need to know which 64-bit architecture we're on.
-                    switch (NativeMethodsShared.ProcessorArchitectureNative)
+                    return NativeMethodsShared.ProcessorArchitectureNative switch
                     {
-                        case NativeMethodsShared.ProcessorArchitectures.X64:
-                            return ProcessorArchitecture.AMD64;
-                        case NativeMethodsShared.ProcessorArchitectures.IA64:
-                            return ProcessorArchitecture.IA64;
+                        NativeMethodsShared.ProcessorArchitectures.X64 => ProcessorArchitecture.AMD64,
+                        NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
                         // Error, OK, we're trying to get the 64-bit path on a 32-bit machine.
                         // That ... doesn't make sense. 
-                        case NativeMethodsShared.ProcessorArchitectures.X86:
-                            return null;
-                        case NativeMethodsShared.ProcessorArchitectures.ARM:
-                            return null;
+                        NativeMethodsShared.ProcessorArchitectures.X86 => null,
+                        NativeMethodsShared.ProcessorArchitectures.ARM => null,
                         // unknown architecture? return null
-                        default:
-                            return null;
-                    }
+                        _ => null,
+                    };
                 case DotNetFrameworkArchitecture.Current:
                     return ProcessorArchitecture.CurrentProcessArchitecture;
             }
@@ -3434,8 +3424,8 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
         }
 
         /// <summary>
-        /// Returns the path to the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
-        /// this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that
+        /// this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="version">Target .NET Framework version</param>
         /// <param name="visualStudioVersion">Version of Visual Studio associated with the SDK.</param>
@@ -3445,8 +3435,8 @@ public static string GetPathToWindowsSdk(TargetDotNetFrameworkVersion version, V
             => FrameworkLocationHelper.GetPathToWindowsSdk(TargetDotNetFrameworkVersionToSystemVersion(version));
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
-        /// this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that
+        /// this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3463,8 +3453,8 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
             );
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
-        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired
+        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3482,8 +3472,8 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
             );
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
-        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired
+        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3526,7 +3516,7 @@ private static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrame
         }
 
         /// <summary>
-        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
+        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path.
         /// If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
         /// </summary>
         [Obsolete("Consider using GetPlatformSDKLocationFile instead")]
@@ -3579,38 +3569,34 @@ private static string GetPathToWindowsSdkFile(string fileName, string pathToSdk,
         /// <returns>The tools path folder of the appropriate ToolsVersion if it exists, otherwise null.</returns>
         public static string GetPathToBuildTools(string toolsVersion, UtilitiesDotNetFrameworkArchitecture architecture)
         {
-            switch (toolsVersion)
+            return toolsVersion switch
             {
-                case "2.0":
-                    return GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20, architecture);
-                case "3.5":
-                    return GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35, architecture);
-                case "4.0":
-                    return GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version40, architecture);
-            }
-
-            // Doesn't map to an existing .NET Framework, so let's grab it out of the toolset.
-            return FrameworkLocationHelper.GeneratePathToBuildToolsForToolsVersion(toolsVersion, ConvertToSharedDotNetFrameworkArchitecture(architecture));
+                "2.0" => GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20, architecture),
+                "3.5" => GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35, architecture),
+                "4.0" => GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version40, architecture),
+                // Doesn't map to an existing .NET Framework, so let's grab it out of the toolset.
+                _ => FrameworkLocationHelper.GeneratePathToBuildToolsForToolsVersion(toolsVersion, ConvertToSharedDotNetFrameworkArchitecture(architecture)),
+            };
         }
 
         /// <summary>
-        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
+        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild
         /// tools path for that ToolsVersion
         /// </summary>
         /// <param name="fileName">The file to find the path to</param>
         /// <param name="toolsVersion">The ToolsVersion in which to find the file</param>
-        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
+        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it
         /// exists, otherwise null.</returns>
         public static string GetPathToBuildToolsFile(string fileName, string toolsVersion) => GetPathToBuildToolsFile(fileName, toolsVersion, UtilitiesDotNetFrameworkArchitecture.Current);
 
         /// <summary>
-        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
+        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild
         /// tools path for that ToolsVersion
         /// </summary>
         /// <param name="fileName">The file to find the path to</param>
         /// <param name="toolsVersion">The ToolsVersion in which to find the file</param>
         /// <param name="architecture">The architecture of the build tools file to get</param>
-        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
+        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it
         /// exists, otherwise null.</returns>
         public static string GetPathToBuildToolsFile(string fileName, string toolsVersion, UtilitiesDotNetFrameworkArchitecture architecture)
         {
@@ -3690,9 +3676,8 @@ public static IList<string> GetSupportedTargetFrameworks()
             return s_targetFrameworkMonikers;
         }
 
-
         /// <summary>
-        /// This method will return the highest version of a target framework moniker based on the identifier. This method will only 
+        /// This method will return the highest version of a target framework moniker based on the identifier. This method will only
         /// find full frameworks, this means no profiles will be returned.
         /// </summary>
         public static FrameworkNameVersioning HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier)
@@ -3742,8 +3727,8 @@ public static FrameworkNameVersioning HighestVersionOfTargetFrameworkIdentifier(
         #region private methods
 
         /// <summary>
-        /// Converts a member of the Microsoft.Build.Utilities.DotNetFrameworkArchitecture enum to the equivalent member of the 
-        /// Microsoft.Build.Shared.DotNetFrameworkArchitecture enum. 
+        /// Converts a member of the Microsoft.Build.Utilities.DotNetFrameworkArchitecture enum to the equivalent member of the
+        /// Microsoft.Build.Shared.DotNetFrameworkArchitecture enum.
         /// </summary>
         private static SharedDotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkArchitecture(UtilitiesDotNetFrameworkArchitecture architecture)
         {
@@ -3812,8 +3797,8 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 {
                     if (programFilesReferenceAssemblyLocationFound &&
                         (
-                            string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30, StringComparison.OrdinalIgnoreCase) == 0
-                            || string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35, StringComparison.OrdinalIgnoreCase) == 0
+                            string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30, StringComparison.OrdinalIgnoreCase)
+                            || string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35, StringComparison.OrdinalIgnoreCase)
                         )
                        )
                     {
@@ -3821,7 +3806,7 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                         continue;
                     }
 
-                    if (string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase))
                     {
                         bFoundDotNetFrameworkIdentifier = true;
                     }
@@ -3830,10 +3815,9 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 }
             }
 
-
-            if (programFilesReferenceAssemblyLocationFound && bFoundDotNetFrameworkIdentifier == false)
+            if (programFilesReferenceAssemblyLocationFound && !bFoundDotNetFrameworkIdentifier)
             {
-                if (bAddDotNetFrameworkIdentifier == false)
+                if (!bAddDotNetFrameworkIdentifier)
                 {
                     // special case for .NETFramework v2.0 - check also in the framework path because v20 does not have reference
                     // assembly folders
@@ -3853,11 +3837,9 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 }
             }
 
-
             return frameworkIdentifiers;
         }
 
-
         /// <summary>
         /// Gets the installed versions for a given framework
         /// </summary>
@@ -3878,7 +3860,7 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
             //backward compatibility with orcas
             //In case of orcas .NETFramework v3.0, v3.5 - the version folders are directly under the frameworkReferenceRoot
             //first check here
-            if (string.Compare(frameworkIdentifier, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(frameworkIdentifier, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase))
             {
                 IList<string> versions = GetFx35AndEarlierVersions(frameworkReferenceRoot);
                 if (versions.Count > 0)
@@ -3955,7 +3937,7 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
                     Version ver = VersionUtilities.ConvertToVersion(frameworkVersion);
                     // check if profile is installed correctly
                     IList<string> refAssemblyPaths = GetPathToReferenceAssemblies(new FrameworkNameVersioning(frameworkIdentifier, ver, subType.Name));
-                    if (refAssemblyPaths != null && refAssemblyPaths.Count > 0)
+                    if (refAssemblyPaths?.Count > 0)
                     {
                         frameworkProfiles.Add(subType.Name);
                     }
@@ -3965,7 +3947,6 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
             return frameworkProfiles;
         }
 
-
         /// <summary>
         /// returns the .NETFramework versions lessthanOrEqualTo 3.5 installed in the machine
         /// Only returns Fx versions lessthanOrEqualTo 3.5 if DNFx3.5 is installed
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 365066c0e9d..12e5e1d8e77 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1367,7 +1367,6 @@ public override bool Execute()
                     }
                     else
                     {
-
                         Encoding encoding;
 
                         if (Traits.Instance.EscapeHatches.AvoidUnicodeWhenWritingToolTaskBatch)
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index 5351c673e7c..a52909af113 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -23,7 +23,7 @@ internal static class CanonicalTrackedFilesHelper
         internal static bool RootContainsAllSubRootComponents(string compositeRoot, string compositeSubRoot)
         {
             // If the two are identical, then clearly all keys are present
-            if (string.Compare(compositeRoot, compositeSubRoot, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(compositeRoot, compositeSubRoot, StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index be7d6f571f5..d16a1ca76ee 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -424,7 +424,7 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
         /// </summary>
         private void SourceDependenciesForOutputRoot(Dictionary<string, ITaskItem> sourceDependencies, string sourceKey, ITaskItem[] filesToIgnore)
         {
-            bool thereAreFilesToIgnore = filesToIgnore != null && filesToIgnore.Length > 0;
+            bool thereAreFilesToIgnore = filesToIgnore?.Length > 0;
 
             if (DependencyTable.TryGetValue(sourceKey, out Dictionary<string, string> dependencies))
             {
@@ -797,7 +797,6 @@ private void ConstructDependencyTable()
                                                 break;
                                             }
 
-
                                             tlogEntry = tlog.ReadLine();
                                         }
                                     }
@@ -867,7 +866,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         {
             // If there are no tlog files, then this will be a clean build
             // so there is no need to write a new tlog
-            if (_tlogFiles != null && _tlogFiles.Length > 0)
+            if (_tlogFiles?.Length > 0)
             {
                 string tLogRootingMarker = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);
 
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 6d20cad9feb..15d8417f515 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -289,10 +289,10 @@ public static bool FileIsUnderPath(string fileName, string path)
         /// <param name="outputs">ITaskItem array of outputs.</param>
         public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] outputs)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(sources, "sources");
+            ErrorUtilities.VerifyThrowArgumentNull(sources, nameof(sources));
 
             // So we don't have to deal with null checks.
-            outputs = outputs ?? Array.Empty<ITaskItem>();
+            outputs ??= Array.Empty<ITaskItem>();
 
             var rootSources = new List<string>(sources.Length + outputs.Length);
 
@@ -641,7 +641,7 @@ public static string TrackerArguments(string command, string arguments, string d
         /// <returns>Process instance</returns>
         public static Process StartProcess(string command, string arguments, ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName)
         {
-            dllName = dllName ?? GetFileTrackerPath(toolType);
+            dllName ??= GetFileTrackerPath(toolType);
 
             string fullArguments = TrackerArguments(command, arguments, dllName, intermediateDirectory, rootFiles, cancelEventName);
             return Process.Start(GetTrackerPath(toolType), fullArguments);
@@ -727,10 +727,7 @@ internal static void LogMessageFromResources(TaskLoggingHelper Log, MessageImpor
         internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importance, string message, params object[] messageArgs)
         {
             // Only log when we have been passed a TaskLoggingHelper
-            if (Log != null)
-            {
-                Log.LogMessage(importance, message, messageArgs);
-            }
+            Log?.LogMessage(importance, message, messageArgs);
         }
 
         /// <summary>
@@ -743,10 +740,7 @@ internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importa
         internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, string messageResourceName, params object[] messageArgs)
         {
             // Only log when we have been passed a TaskLoggingHelper
-            if (Log != null)
-            {
-                Log.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
-            }
+            Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
         }
 
         #endregion
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 88b60b0dfc8..f69c68b7a08 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -223,8 +223,6 @@ public FlatTrackingData(ITaskItem[] tlogFiles, ITaskItem[] tlogFilesToIgnore, Da
             InternalConstruct(null, tlogFiles, tlogFilesToIgnore, false, missingFileTimeUtc, excludedInputPaths);
         }
 
-
-
         /// <summary>
         /// Constructor
         /// </summary>
@@ -613,7 +611,7 @@ private void RecordEntryDetails(string tlogEntry, bool populateTable)
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLog", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public void SaveTlog(DependencyFilter includeInTLog)
         {
-            if (TlogFiles != null && TlogFiles.Length > 0)
+            if (TlogFiles?.Length > 0)
             {
                 string tLogRootingMarker = DependencyTableCache.FormatNormalizedTlogRootingMarker(TlogFiles);
 
@@ -678,7 +676,6 @@ public DateTime GetLastWriteTimeUtc(string file)
             return fileModifiedTimeUtc;
         }
 
-
         #endregion
 
         #region Static Methods
@@ -848,7 +845,6 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
             // Read the output table, skipping missing files
             FlatTrackingData outputs = new FlatTrackingData(writeTLogNames, true);
 
-
             // If we failed we need to clean the Tlogs
             if (!trackedOperationsSucceeded)
             {
@@ -872,7 +868,7 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
 
                 // In addition to temporary file removal, an optional set of files to remove may be been supplied
 
-                if (trackedFilesToRemoveFromTLogs != null && trackedFilesToRemoveFromTLogs.Length > 0)
+                if (trackedFilesToRemoveFromTLogs?.Length > 0)
                 {
                     IDictionary<string, ITaskItem> trackedFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
 
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index 802f2164d3a..414a572d4d5 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -71,7 +71,7 @@ internal static bool ItemsExist(ITaskItem[] files)
         {
             bool allExist = true;
 
-            if (files != null && files.Length > 0)
+            if (files?.Length > 0)
             {
                 foreach (ITaskItem item in files)
                 {
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
index 30635a19eaa..a8b28069581 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/AssemblyFixtureAttribute.cs
@@ -21,5 +21,4 @@ public enum Scope
             Method
         }
     }
-
 }
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
index 711e2f6aa3a..1fc7269cd91 100644
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
+++ b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
@@ -152,11 +152,11 @@ internal static MethodInfo LookupConditionalMethod(Type t, string name)
             TypeInfo ti = t.GetTypeInfo();
 
             MethodInfo mi = ti.GetDeclaredMethod(name);
-            if (mi != null && mi.IsStatic && mi.GetParameters().Length == 0 && mi.ReturnType == typeof(bool))
+            if (mi?.IsStatic == true && mi.GetParameters().Length == 0 && mi.ReturnType == typeof(bool))
                 return mi;
 
             PropertyInfo pi = ti.GetDeclaredProperty(name);
-            if (pi != null && pi.PropertyType == typeof(bool) && pi.GetMethod != null && pi.GetMethod.IsStatic && pi.GetMethod.GetParameters().Length == 0)
+            if (pi?.PropertyType == typeof(bool) && pi.GetMethod?.IsStatic == true && pi.GetMethod.GetParameters().Length == 0)
                 return pi.GetMethod;
 
             return LookupConditionalMethod(ti.BaseType, name);
