diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index b7744d6ed4f..878d5c58c6e 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -11,9 +11,12 @@
 using System.Text;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -22,7 +25,6 @@
 using Microsoft.Win32;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ProjectHelpers = Microsoft.Build.UnitTests.BackEnd.ProjectHelpers;
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
@@ -4893,5 +4895,27 @@ public void ExpandItemVectorFunctions_Exists_Directories()
                 squiggleItems.Select(i => i.EvaluatedInclude).ShouldBe(new[] { alphaBetaPath, alphaDeltaPath }, Case.Insensitive);
             }
         }
+
+        [Fact]
+        public void PropertyFunctionRegisterAnalyzer()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var logger = new MockLogger();
+                ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+                loggingService.RegisterLogger(logger);
+                var loggingContext = new MockLoggingContext(
+                    loggingService,
+                    new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
+                var dummyAssemblyFile = env.CreateFile(env.CreateFolder(), "test.dll");
+
+                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default)
+                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterAnalyzer({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance, loggingContext);
+
+                result.ShouldBe(Boolean.TrueString);
+                _ = logger.AllBuildEvents.Select(be => be.ShouldBeOfType<BuildCheckAcquisitionEventArgs>());
+                logger.AllBuildEvents.Count.ShouldBe(1);
+            }
+        }
     }
 }
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 6e57337863d..7e0091c5d47 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -23,6 +23,7 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Cop, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 // DO NOT expose Internals to "Microsoft.Build.UnitTests.OM.OrcasCompatibility" as this assembly is supposed to only see public interface
 
 // This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index 606759a34e2..b7f79c796ac 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -10,7 +10,7 @@
 
 namespace Microsoft.Build.BuildCheck.Acquisition
 {
-    internal class BuildCheckAcquisitionModule
+    internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
     {
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
@@ -18,6 +18,7 @@ internal class BuildCheckAcquisitionModule
         /// </summary>
         private static readonly CoreClrAssemblyLoader s_coreClrAssemblyLoader = new();
 #endif
+
         public BuildAnalyzerFactory? CreateBuildAnalyzerFactory(AnalyzerAcquisitionData analyzerAcquisitionData)
         {
             try
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
new file mode 100644
index 00000000000..98df459aed5
--- /dev/null
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -0,0 +1,12 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.Acquisition
+{
+    internal interface IBuildCheckAcquisitionModule
+    {
+        BuildAnalyzerFactory? CreateBuildAnalyzerFactory(AnalyzerAcquisitionData analyzerAcquisitionData);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index a5860c27bb4..6789ae47bd4 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -103,7 +103,7 @@ private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
             { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
             { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
             { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => _stats.Merge(((BuildCheckTracingEventArgs)e).TracingData, (span1, span2) => span1 + span2) },
-            { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData()) },
+            { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), e.BuildEventContext!) },
         };
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index c8c03f4e6fe..5bfe3f92490 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -25,7 +25,7 @@ namespace Microsoft.Build.BuildCheck.Infrastructure;
 internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
 {
     private static IBuildCheckManager? s_globalInstance;
-  
+
     internal static IBuildCheckManager GlobalInstance => s_globalInstance ?? throw new InvalidOperationException("BuildCheckManagerProvider not initialized");
 
     public IBuildCheckManager Instance => GlobalInstance;
@@ -60,7 +60,7 @@ public void InitializeComponent(IBuildComponentHost host)
 
     public void ShutdownComponent() => GlobalInstance.Shutdown();
 
-    private sealed class BuildCheckManager : IBuildCheckManager
+    internal sealed class BuildCheckManager : IBuildCheckManager
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
         private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
@@ -68,11 +68,12 @@ private sealed class BuildCheckManager : IBuildCheckManager
         private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
-        private readonly BuildCheckAcquisitionModule _acquisitionModule = new();
+        private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
         internal BuildCheckManager(ILoggingService loggingService)
         {
             _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
+            _acquisitionModule = new BuildCheckAcquisitionModule();
             _loggingService = loggingService;
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
@@ -94,14 +95,18 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
             }
         }
 
-        public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData)
+        public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext)
         {
             if (IsInProcNode)
             {
                 BuildAnalyzerFactory? factory = _acquisitionModule.CreateBuildAnalyzerFactory(acquisitionData);
                 if (factory != null)
                 {
-                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, factory);
+                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, factory, buildEventContext);
+                }
+                else
+                {
+                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
                 }
             }
             else
@@ -161,7 +166,8 @@ internal void RegisterCustomAnalyzer(
         /// </summary>
         internal void RegisterCustomAnalyzer(
             BuildCheckDataSource buildCheckDataSource,
-            BuildAnalyzerFactory factory)
+            BuildAnalyzerFactory factory,
+            BuildEventContext buildEventContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
@@ -170,6 +176,7 @@ internal void RegisterCustomAnalyzer(
                     factory,
                     instance.SupportedRules.Select(r => r.Id).ToArray(),
                     instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
+                _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.GetType().Name);
             }
         }
 
@@ -279,7 +286,6 @@ private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventConte
             }
         }
 
-
         public void ProcessEvaluationFinishedEventArgs(
             AnalyzerLoggingContext buildAnalysisContext,
             ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
@@ -362,9 +368,13 @@ private class BuildAnalyzerFactoryContext(
                 ba.Initialize(configContext);
                 return new BuildAnalyzerWrapper(ba);
             };
+
             public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+
             public string[] RuleIds { get; init; } = ruleIds;
+
             public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
+
             public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
         }
     }
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index ca91897ad44..8e82c543c32 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics.Tracing;
 using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
@@ -19,8 +20,7 @@ internal enum BuildCheckDataSource
 {
     EventArgs,
     BuildExecution,
-
-    ValuesCount = BuildExecution + 1
+    ValuesCount = BuildExecution + 1,
 }
 
 /// <summary>
@@ -34,7 +34,7 @@ void ProcessEvaluationFinishedEventArgs(
 
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
-    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData);
+    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext);
 
     Dictionary<string, TimeSpan> CreateTracingStats();
 
@@ -44,10 +44,12 @@ void ProcessEvaluationFinishedEventArgs(
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
     //  to manager about what analyzers need to be materialized and configuration fetched.
     // No unloading of analyzers is yet considered - once loaded it stays for whole build.
-
     void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string fullPath);
+
     void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+
     void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+
     void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
 
     void Shutdown();
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 00516fb758b..45ed260d425 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -27,7 +27,9 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     {
     }
 
-    public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData) { }
+    public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext) 
+    {
+    }
 
     public Dictionary<string, TimeSpan> CreateTracingStats() => throw new NotImplementedException();
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index dc2d2ed13ca..354571bb26b 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -158,6 +158,7 @@
     <Compile Include="FileSystem\*.cs" />
     <Compile Include="BuildCheck\Acquisition\AnalyzerAcquisitionData.cs" />
     <Compile Include="BuildCheck\Acquisition\BuildCheckAcquisitionModule.cs" />
+    <Compile Include="BuildCheck\Acquisition\IBuildCheckAcquisitionModule.cs" />
     <Compile Include="BuildCheck\Analyzers\SharedOutputPathAnalyzer.cs" />
     <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationException.cs" />
     <Compile Include="BuildCheck\Infrastructure\BuildEventsProcessor.cs" />
@@ -696,6 +697,7 @@
       <Link>SharedUtilities\XmlUtilities.cs</Link>
     </Compile>
     <Compile Include="Evaluation\LazyItemEvaluator.EvaluatorData.cs" />
+    <Content Include="stylecop.json" />
 
     <!-- Win32 RC Files -->
     <RCResourceFile Include="native.rc" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index a037905be7e..8822c0212fe 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1,17 +1,17 @@
 ï»¿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!--
-    Microsoft ResX Schema
-
+  <!-- 
+    Microsoft ResX Schema 
+    
     Version 2.0
-
-    The primary goals of this format is to allow a simple XML format
-    that is mostly human readable. The generation and parsing of the
-    various data types are done through the TypeConverter classes
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
     associated with the data types.
-
+    
     Example:
-
+    
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-
-    There are any number of "resheader" rows that contain simple
+                
+    There are any number of "resheader" rows that contain simple 
     name/value pairs.
-
-    Each data row contains a name, and value. The row also contains a
-    type or mimetype. Type corresponds to a .NET class that support
-    text/value conversion through the TypeConverter architecture.
-    Classes that don't support this are serialized and stored with the
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
     mimetype set.
-
-    The mimetype is used for serialized objects, and tells the
-    ResXResourceReader how to depersist the object. This is currently not
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
     extensible. For a given mimetype the value must be set accordingly:
-
-    Note - application/x-microsoft.net.object.binary.base64 is the format
-    that the ResXResourceWriter will generate, however the reader can
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
     read any of the formats listed below.
-
+    
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-
+    
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array
+    value   : The object must be serialized into a byte array 
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -142,7 +142,7 @@
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
-  <data name="EnvironmentDerivedPropertyRead">
+  <data name="EnvironmentDerivedPropertyRead" xml:space="preserve">
     <value>Property '{0}' with value '{1}' expanded from the environment.</value>
   </data>
   <data name="SubmissionAlreadyComplete" xml:space="preserve">
@@ -476,7 +476,7 @@
     likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
     special exception to abort the build.</comment>
   </data>
-  <data name="General.TwoVectorsMustHaveSameLength">
+  <data name="General.TwoVectorsMustHaveSameLength" xml:space="preserve">
     <value>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</value>
     <comment>{StrBegin="MSB3094: "}</comment>
   </data>
@@ -1162,7 +1162,7 @@
       LOCALIZATION: "{2}" is a localized message from a CLR/FX exception. Also, Microsoft.Build.Framework should not be localized
     </comment>
   </data>
-  <data name="TaskReturnedFalseButDidNotLogError">
+  <data name="TaskReturnedFalseButDidNotLogError" xml:space="preserve">
     <value>MSB4181: The "{0}" task returned false but did not log an error.</value>
     <comment>{StrBegin="MSB4181: "}</comment>
   </data>
@@ -1292,7 +1292,7 @@
     <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</value>
     <comment>{StrBegin="MSB4067: "}</comment>
   </data>
-  <data name="PropertyOutsidePropertyGroupInTarget" xml:space="preserve" Condition="$([MSBuild]::AreFeaturesEnabled('17.6'))">
+  <data name="PropertyOutsidePropertyGroupInTarget" xml:space="preserve">
     <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</value>
     <comment>{StrBegin="MSB4067: "}</comment>
   </data>
@@ -1743,7 +1743,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>MSB4231: ProjectRootElement can't reload if it contains unsaved changes.</value>
     <comment>{StrBegin="MSB4231: "}</comment>
   </data>
-  <data name="LogTaskInputs.Truncated">
+  <data name="LogTaskInputs.Truncated" xml:space="preserve">
     <value>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</value>
   </data>
   <data name="MetaprojectGenerated" xml:space="preserve">
@@ -1971,9 +1971,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     </comment>
   </data>
   <data name="ProjectCacheHitWithOutputs" xml:space="preserve">
-    <value>{0} -> Cache Hit</value>
+    <value>{0} -&gt; Cache Hit</value>
     <comment>
-      {StrBegin="{0} -> "}LOCALIZATION: This string is used to indicate progress and matches the format for a log message from Microsoft.Common.CurrentVersion.targets. {0} is a project name.
+      {StrBegin="{0} -&gt; "}LOCALIZATION: This string is used to indicate progress and matches the format for a log message from Microsoft.Common.CurrentVersion.targets. {0} is a project name.
     </comment>
   </data>
   <data name="ProjectCacheMissWithDefaultTargets" xml:space="preserve">
@@ -2000,7 +2000,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file path. {1} is a comma-separated list of target names
     </comment>
   </data>
-   <data name="DefaultSDKResolverError" xml:space="preserve">
+  <data name="DefaultSDKResolverError" xml:space="preserve">
     <value>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</value>
   </data>
   <data name="SDKResolverReturnedNull" xml:space="preserve">
@@ -2042,7 +2042,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Imported files archive exceeded 2GB limit and it's not embedded.</value>
   </data>
   <data name="Binlog_FwdCompatUnsupported" xml:space="preserve">
-    <value>Forward compatible reading is not supported for file format version {0} (needs >= 18).</value>
+    <value>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</value>
     <comment>
       LOCALIZATION: {0} is an integer number denoting version.
     </comment>
@@ -2095,11 +2095,12 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </comment>
   </data>
-  <!--
-        The Build message bucket is: MSB4000 - MSB4999
-
-        Next message code should be MSB4279
-
-        Don't forget to update this comment after using a new code.
-  -->
+  <data name="CustomAnalyzerSuccessfulAcquisition" xml:space="preserve">
+    <value>Custom analyzer {0} has been registered successfully.</value>
+    <comment>The message is emmited on successful loading of the custom analyzer in app domain.</comment>
+  </data>
+  <data name="CustomAnalyzerFailedAcquisition" xml:space="preserve">
+    <value>Failed to ragister the custom analyzer: {0}.</value>
+    <comment>The message is emmited on failed loading of the custom analyzer in app domain.</comment>
+  </data>
 </root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 83d03235b23..563cdcc63c2 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: VÃ½chozÃ­ pÅekladaÄ sady SDK nedokÃ¡zal pÅeloÅ¾it sadu SDK â{0}â, protoÅ¾e adresÃ¡Å â{1}â neexistoval.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 3001fd096d9..668a612bf7a 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: Der SDK-Standardresolver konnte SDK "{0}" nicht auflÃ¶sen, da das Verzeichnis "{1}" nicht vorhanden war.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index f5f6b78041f..1673d5e2a5a 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: La resoluciÃ³n predeterminada del SDK no pudo resolver el SDK "{0}" porque el directorio "{1}" no existÃ­a.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 28c5c4c14b9..125669fa641 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: Le programme de rÃ©solution du SDK par dÃ©faut nâa pas pu rÃ©soudre le SDK Â«{0}Â», car le rÃ©pertoire Â«{1}Â» nâexistait pas.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index db3bb216291..cb083681300 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: il resolver SDK predefinito non Ã¨ riuscito a risolvere l'SDK "{0}" perchÃ© la directory "{1}" non esiste.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 82ddae9c55f..3fd9a12302e 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: ãã£ã¬ã¯ããª "{0}" ãå­å¨ããªãã£ããããæ¢å®ã® SDK ãªã¾ã«ãã¼ã¯ SDK "{1}" ãè§£æ±ºã§ãã¾ããã§ããã</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 4b5c0ff47ac..e6e302839ce 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: ëë í°ë¦¬ "{0}"ì´(ê°) ìì¼ë¯ë¡ ê¸°ë³¸ SDK íì¸ìê° SDK "{1}"ì(ë¥¼) íì¸íì§ ëª»íìµëë¤.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b253894f759..2c0fd575dce 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: DomyÅlne narzÄdzie Resolver zestawu SDK nie moÅ¼e rozpoznaÄ zestawu SDK â{0}â, poniewaÅ¼ katalog â{1}â nie istnieje.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 7e767a652cb..aeaa1eba431 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: O resolvedor SDK padrÃ£o falhou ao resolver SDK "{0}" porque o diretÃ³rio "{1}" nÃ£o existia.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index bf90a1bb435..195a24979af 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¾Ð¼Ñ ÑÐ¾Ð¿Ð¾ÑÑÐ°Ð²Ð¸ÑÐµÐ»Ñ Ð¿Ð°ÐºÐµÑÐ¾Ð² SDK Ð½Ðµ ÑÐ´Ð°Ð»Ð¾ÑÑ ÑÐ°Ð·ÑÐµÑÐ¸ÑÑ Ð¿Ð°ÐºÐµÑ SDK "{0}", ÑÐ°Ðº ÐºÐ°Ðº ÐºÐ°ÑÐ°Ð»Ð¾Ð³ "{1}" Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index ec82a4c4384..0c4e6ecc1e0 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: "{1}" dizini olmadÄ±ÄÄ±ndan, varsayÄ±lan SDK Ã§Ã¶zÃ¼mleyicisi "{0}" SDKâsÄ±nÄ± Ã§Ã¶zÃ¼mleyemedi.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index d148cff64c7..b1fb3c6921d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: é»è®¤ SDK è§£æç¨åºè§£æ SDKâ{0}âå¤±è´¥ï¼å ä¸ºç®å½â{1}âä¸å­å¨ã</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index ef485bd062f..63ac69da9b3 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -207,6 +207,16 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to ragister the custom analyzer: {0}.</source>
+        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer {0} has been registered successfully.</target>
+        <note>The message is emmited on successful loading of the custom analyzer in app domain.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: é è¨­ç SDK è§£æç¨å¼ç¡æ³è§£æ SDK "{0}"ï¼å çºç®é "{1}" ä¸å­å¨ã</target>
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
new file mode 100644
index 00000000000..a23089290be
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -0,0 +1,113 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public class BuildCheckManagerTests : IDisposable
+    {
+        private readonly TestEnvironment _env;
+
+        private readonly IBuildCheckManager _testedInstance;
+        private readonly ILoggingService _loggingService;
+        private readonly MockLogger _logger;
+
+        public BuildCheckManagerTests(ITestOutputHelper output)
+        {
+            _env = TestEnvironment.Create(output);
+
+            // this is needed to ensure the binary logger does not pollute the environment
+            _env.WithEnvironmentInvariant();
+
+            _loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            _logger = new MockLogger();
+            _loggingService.RegisterLogger(_logger);
+            _testedInstance = new BuildCheckManager(_loggingService);
+        }
+
+        [Theory]
+        [InlineData(true, "Custom analyzer BuildAnalyzerRuleMock has been registered successfully.")]
+        [InlineData(false, "Failed to ragister the custom analyzer: DummyPath.")]
+        public void ProcessAnalyzerAcquisitionTest(bool isAnalyzerRuleExist, string expectedMessage)
+        {
+            MockBuildCheckAcquisition(isAnalyzerRuleExist);
+            MockEnabledDataSourcesDefinition();
+
+            _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath"), new BuildEventContext(1, 2, 3, 4, 5, 6, 7));
+
+            _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs))
+                .ShouldContain(be => be.Message == expectedMessage);
+        }
+
+        public void Dispose() => _env.Dispose();
+
+        private void MockBuildCheckAcquisition(bool isAnalyzerRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isAnalyzerRuleExist));
+
+        private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
+
+        private void MockField(string fieldName, object mockedValue)
+        {
+            var mockedField = _testedInstance.GetType().GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance);
+            mockedField.SetValue(_testedInstance, mockedValue);
+        }
+    }
+
+    internal class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
+    {
+        private readonly bool _isAnalyzerRuleExistForTest = true;
+
+        internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
+
+        public BuildAnalyzerFactory? CreateBuildAnalyzerFactory(AnalyzerAcquisitionData analyzerAcquisitionData) =>
+            _isAnalyzerRuleExistForTest
+            ? () => new BuildAnalyzerRuleMock()
+            : null;
+    }
+
+    internal class BuildAnalyzerRuleMock : BuildAnalyzer
+    {
+        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+            "X01234",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new BuildAnalyzerConfiguration());
+
+        public override string FriendlyName => "BuildAnalyzerRuleMock";
+
+        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if analyzer needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "Argument for the message format"));
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index f0fda0d4b29..c523f879b8e 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,12 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
@@ -19,6 +14,7 @@ namespace Microsoft.Build.BuildCheck.UnitTests
     public class EndToEndTests : IDisposable
     {
         private readonly TestEnvironment _env;
+
         public EndToEndTests(ITestOutputHelper output)
         {
             _env = TestEnvironment.Create(output);
@@ -91,7 +87,6 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
             // var cache = new SimpleProjectRootElementCache();
             // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
 
-
             TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
                 /*lang=json,strict*/
                 """
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 1768410a565..566b6eff6d4 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -30,12 +30,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\FileUtilities.cs">
-      <Link>Shared\FileUtilities.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\TempFileUtilities.cs">
-      <Link>Shared\TempFileUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>Shared\ErrorUtilities.cs</Link>
     </Compile>
