diff --git a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
index ff94b3f759e..f9de1bc6144 100644
--- a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
@@ -15,7 +15,7 @@ public sealed class UsedUninitializedProperties_Tests
     [Fact]
     public void Basics()
     {
-        PropertiesUsageTracker props = new(TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, 3, 4)));
+        PropertiesUseTracker props = new(TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, 3, 4)));
 
         Assert.False(props.TryGetPropertyElementLocation("Hello", out IElementLocation? elementLocation));
         Assert.Null(elementLocation);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index de806a2727c..18d85f2323c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -77,12 +77,12 @@ internal override void ExecuteTask(Lookup lookup)
                                 "CannotModifyReservedProperty",
                                 property.Name);
 
-                            bucket.Expander.PropertiesUsageTracker.CurrentlyEvaluatingPropertyElementName = property.Name;
-                            bucket.Expander.PropertiesUsageTracker.PropertyReadContext =
+                            bucket.Expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = property.Name;
+                            bucket.Expander.PropertiesUseTracker.PropertyReadContext =
                                 PropertyReadContext.PropertyEvaluation;
 
                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);
-                            bucket.Expander.PropertiesUsageTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);
+                            bucket.Expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);
 
                             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents)
                             {
@@ -101,7 +101,8 @@ internal override void ExecuteTask(Lookup lookup)
                         foreach (ItemBucket bucket in buckets)
                         {
                             bucket.LeaveScope();
-                            bucket.Expander.PropertiesUsageTracker.ResetPropertyReadContext(false);
+                            // We are now done processing this property - so no need to pop its previous context.
+                            bucket.Expander.PropertiesUseTracker.ResetPropertyReadContext(pop: false);
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 49920cb248a..950b2848a68 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
+using System.Diagnostics;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
@@ -58,7 +59,7 @@ internal sealed class ItemBucket : IComparable
         #region Constructors
 
         /// <summary>
-        /// Private default constructor disallows parameterless instantiation.
+        /// Private constructor for creating comparison bucket.
         /// </summary>
         private ItemBucket(Dictionary<string, string> metadata)
         {
@@ -157,6 +158,7 @@ internal Expander<ProjectPropertyInstance, ProjectItemInstance> Expander
         {
             get
             {
+                Debug.Assert(_expander != null, "ItemBucket.Initialize was not properly called");
                 return _expander;
             }
         }
diff --git a/src/Build/Construction/ProjectPropertyElement.cs b/src/Build/Construction/ProjectPropertyElement.cs
index 0c5ce4493b6..8929dea6406 100644
--- a/src/Build/Construction/ProjectPropertyElement.cs
+++ b/src/Build/Construction/ProjectPropertyElement.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.Construction
     /// So the CM only represents Normal properties.
     /// </remarks>
     [DebuggerDisplay("{Name} Value={Value} Condition={Condition}")]
-    public class ProjectPropertyElement : ProjectElement, IElementWithLocation
+    public class ProjectPropertyElement : ProjectElement, IPropertyElementWithLocation
     {
         internal ProjectPropertyElementLink PropertyLink => (ProjectPropertyElementLink)Link;
 
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index bafb66a97f0..f7918c19052 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -275,7 +275,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 fileSystem,
                 projectRootElementCache);
 
-            expander.PropertiesUsageTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
+            expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
             // We are evaluating this expression now and it can cache some state for the duration,
             // so we don't want multiple threads working on the same expression
             lock (parsedExpression)
@@ -292,7 +292,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                         // Finished using the expression tree. Add it back to the pool so other threads can use it.
                         expressionPool.Push(parsedExpression);
                     }
-                    expander.PropertiesUsageTracker.ResetPropertyReadContext();
+                    expander.PropertiesUseTracker.ResetPropertyReadContext();
                 }
             }
 
@@ -345,7 +345,7 @@ internal interface IConditionEvaluationState
 
             ElementLocation ElementLocation { get; }
 
-            PropertiesUsageTracker PropertiesUsageTracker { get; }
+            PropertiesUseTracker PropertiesUseTracker { get; }
 
             /// <summary>
             ///     Table of conditioned properties and their values.
@@ -400,7 +400,7 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
 
             public ElementLocation ElementLocation { get; }
 
-            public PropertiesUsageTracker PropertiesUsageTracker => _expander.PropertiesUsageTracker;
+            public PropertiesUseTracker PropertiesUseTracker => _expander.PropertiesUseTracker;
 
             public IFileSystem FileSystem { get; }
 
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index d745c2328e2..e8a7858d415 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -46,7 +46,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Checks if value is empty before any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract bool IsUnexpandedValueEmpty();
 
         /// <summary>
         /// If any expression nodes cache any state for the duration of evaluation,
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index eabcdc4e7b7..f398e8d740a 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -52,11 +52,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // That means we don't have to fully expand a condition like " '@(X)' == '' "
             // which is a performance advantage if @(X) is a huge item list.
 
-            // this is the possible case of '$(a)' == ''
-            if (LeftChild.IsUnexpandedValueEmpty(state) ||
-                RightChild.IsUnexpandedValueEmpty(state))
+            // This is the possible case of an expression similar to '$(a)' == '', where a usage of uninitialized
+            //  property is reasonable and should not be flagged by uninitialized reads detection.
+            // So if at least one side is empty, we know to signal to PropertiesUseTracker to not flag in this scope.
+            // The other side might not be property at all - that's fine, as then PropertiesUseTracker won't be even called.
+            if (LeftChild.IsUnexpandedValueEmpty() || RightChild.IsUnexpandedValueEmpty())
             {
-                state.PropertiesUsageTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluationWithOneSideEmpty;
+                state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluationWithOneSideEmpty;
             }
 
             bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
@@ -94,7 +96,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             UpdateConditionedProperties(state);
 
             // reset back the property read context (it's no longer a condition with one side empty)
-            state.PropertiesUsageTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
+            state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
 
             return Compare(leftExpandedValue, rightExpandedValue);
         }
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 994acc957c5..66bfc64c1c2 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -43,7 +43,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         }
 
         /// <inheritdoc cref="GenericExpressionNode"/>
-        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state) => false;
+        internal override bool IsUnexpandedValueEmpty() => false;
 
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index dcafcc12b2e..6089e5dd255 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -16,10 +13,11 @@ namespace Microsoft.Build.Evaluation
     [DebuggerDisplay("{DebuggerDisplay,nq}")]
     internal sealed class NumericExpressionNode : OperandExpressionNode
     {
-        private string _value;
+        private readonly string _value;
 
         internal NumericExpressionNode(string value)
         {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(value), "NumericExpressionNode cannot have empty value");
             _value = value;
         }
 
@@ -34,14 +32,14 @@ internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluatio
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version? result)
         {
             return Version.TryParse(_value, out result);
         }
 
         /// <inheritdoc cref="GenericExpressionNode"/>
-        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state)
-            => string.IsNullOrEmpty(_value);
+        internal override bool IsUnexpandedValueEmpty()
+            => false;
 
         /// <summary>
         /// Get the unexpanded value
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 31295897512..34c7194b7a4 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -44,8 +44,8 @@ internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluatio
         }
 
         /// <inheritdoc cref="GenericExpressionNode"/>
-        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state)
-            => true;
+        internal override bool IsUnexpandedValueEmpty()
+            => LeftChild.IsUnexpandedValueEmpty() && RightChild.IsUnexpandedValueEmpty();
 
         /// <summary>
         /// Value before any item and property expressions are expanded
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index b395b7c0fdd..f66e2d5efee 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -118,7 +118,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
 
 
         /// <inheritdoc cref="GenericExpressionNode"/>
-        internal override bool IsUnexpandedValueEmpty(ConditionEvaluator.IConditionEvaluationState state) 
+        internal override bool IsUnexpandedValueEmpty() 
             => string.IsNullOrEmpty(_value);
 
         /// <summary>
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 51b6d9da9f6..b82733a9d8e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1279,21 +1279,21 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                     return;
                 }
 
-                _expander.PropertiesUsageTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
                 if (!EvaluateConditionCollectingConditionedProperties(propertyElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                 {
                     return;
                 }
 
-                _expander.PropertiesUsageTracker.PropertyReadContext = PropertyReadContext.PropertyEvaluation;
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.PropertyEvaluation;
 
                 // Set the name of the property we are currently evaluating so when we are checking to see if we want to add the property to the list of usedUninitialized properties we can not add the property if
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
-                _expander.PropertiesUsageTracker.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
+                _expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
                 string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
 
-                _expander.PropertiesUsageTracker.CheckPreexistingUndefinedUsage(propertyElement, evaluatedValue, _evaluationLoggingContext);
+                _expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(propertyElement, evaluatedValue, _evaluationLoggingContext);
 
                 _data.SetProperty(propertyElement, evaluatedValue);
             }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 20e0cd7e304..c64d877596a 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -307,7 +307,7 @@ private void FlushFirstValueIfNeeded()
         /// <summary>
         /// Set of properties which are null during expansion.
         /// </summary>
-        private PropertiesUsageTracker _propertiesUsageTracker;
+        private PropertiesUseTracker _propertiesUseTracker;
 
         private readonly IFileSystem _fileSystem;
 
@@ -321,7 +321,7 @@ private void FlushFirstValueIfNeeded()
         private Expander(IPropertyProvider<P> properties, LoggingContext loggingContext)
         {
             _properties = properties;
-            _propertiesUsageTracker = new PropertiesUsageTracker(loggingContext);
+            _propertiesUseTracker = new PropertiesUseTracker(loggingContext);
             _loggingContext = loggingContext;
         }
 
@@ -440,10 +440,10 @@ internal IMetadataTable Metadata
         /// If a property is expanded but evaluates to null then it is considered to be un-initialized.
         /// We want to keep track of these properties so that we can warn if the property gets set later on.
         /// </summary>
-        internal PropertiesUsageTracker PropertiesUsageTracker
+        internal PropertiesUseTracker PropertiesUseTracker
         {
-            get { return _propertiesUsageTracker; }
-            set { _propertiesUsageTracker = value; }
+            get { return _propertiesUseTracker; }
+            set { _propertiesUseTracker = value; }
         }
 
         /// <summary>
@@ -496,7 +496,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, _loggingContext);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _propertiesUsageTracker, _fileSystem);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -517,7 +517,7 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string metaExpanded = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _propertiesUsageTracker, _fileSystem);
+            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
         }
 
         /// <summary>
@@ -565,7 +565,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             expression = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _propertiesUsageTracker, _fileSystem);
+            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             expression = FileUtilities.MaybeAdjustFilePath(expression);
 
             List<T> result = new List<T>();
@@ -1150,7 +1150,7 @@ internal static string ExpandPropertiesLeaveEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                PropertiesUsageTracker propertiesUsageTracker,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem)
             {
                 return
@@ -1160,7 +1160,7 @@ internal static string ExpandPropertiesLeaveEscaped(
                             properties,
                             options,
                             elementLocation,
-                            propertiesUsageTracker,
+                            propertiesUseTracker,
                             fileSystem));
             }
 
@@ -1186,7 +1186,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                PropertiesUsageTracker propertiesUsageTracker,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
@@ -1296,12 +1296,12 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                                 properties,
                                 options,
                                 elementLocation,
-                                propertiesUsageTracker,
+                                propertiesUseTracker,
                                 fileSystem);
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, propertiesUsageTracker);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, propertiesUseTracker);
                         }
 
                         if (propertyValue != null)
@@ -1344,7 +1344,7 @@ internal static object ExpandPropertyBody(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                PropertiesUsageTracker propertiesUsageTracker,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem)
             {
                 Function<T> function = null;
@@ -1375,9 +1375,9 @@ internal static object ExpandPropertyBody(
                             propertyBody,
                             elementLocation,
                             propertyValue,
-                            propertiesUsageTracker,
+                            propertiesUseTracker,
                             fileSystem,
-                            propertiesUsageTracker.LoggingContext);
+                            propertiesUseTracker.LoggingContext);
 
                         // We may not have been able to parse out a function
                         if (function != null)
@@ -1405,7 +1405,7 @@ internal static object ExpandPropertyBody(
                         }
                         else
                         {
-                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, propertiesUsageTracker);
+                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, propertiesUseTracker);
                             propertyBody = propertyBody.Substring(indexerStart);
 
                             // recurse so that the function representing the indexer can be executed on the property value
@@ -1415,7 +1415,7 @@ internal static object ExpandPropertyBody(
                                 properties,
                                 options,
                                 elementLocation,
-                                propertiesUsageTracker,
+                                propertiesUseTracker,
                                 fileSystem);
                         }
                     }
@@ -1433,7 +1433,7 @@ internal static object ExpandPropertyBody(
                 // doesn't exist in the collection, and we're not executing a static function
                 if (!String.IsNullOrEmpty(propertyName))
                 {
-                    propertyValue = LookupProperty(properties, propertyName, elementLocation, propertiesUsageTracker);
+                    propertyValue = LookupProperty(properties, propertyName, elementLocation, propertiesUseTracker);
                 }
 
                 if (function != null)
@@ -1540,15 +1540,15 @@ internal static string ConvertToString(object valueToConvert)
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
-                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUsageTracker);
+                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUseTracker);
             }
 
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUsageTracker propertiesUsageTracker)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
@@ -1557,7 +1557,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&
                                    MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
 
-                propertiesUsageTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
+                propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
                 
                 if (isArtifical)
                 {
@@ -1580,7 +1580,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 {
                     if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
                     {
-                        environmentDerivedProperty.loggingContext = propertiesUsageTracker.LoggingContext;
+                        environmentDerivedProperty.loggingContext = propertiesUseTracker.LoggingContext;
                     }
 
                     propertyValue = property.EvaluatedValueEscaped;
@@ -2765,7 +2765,7 @@ internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                             arguments,
                             BindingFlags.Public | BindingFlags.InvokeMethod,
                             string.Empty,
-                            expander.PropertiesUsageTracker,
+                            expander.PropertiesUseTracker,
                             expander._fileSystem,
                             expander._loggingContext);
 
@@ -3197,7 +3197,7 @@ private struct FunctionBuilder<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            public PropertiesUsageTracker PropertiesUsageTracker { get; set; }
+            public PropertiesUseTracker PropertiesUseTracker { get; set; }
 
             internal readonly Function<T> Build()
             {
@@ -3209,7 +3209,7 @@ internal readonly Function<T> Build()
                     Arguments,
                     BindingFlags,
                     Remainder,
-                    PropertiesUsageTracker,
+                    PropertiesUseTracker,
                     FileSystem,
                     LoggingContext);
             }
@@ -3261,7 +3261,7 @@ internal class Function<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            private PropertiesUsageTracker _propertiesUsageTracker;
+            private PropertiesUseTracker _propertiesUseTracker;
 
             private readonly IFileSystem _fileSystem;
 
@@ -3278,7 +3278,7 @@ internal Function(
                 string[] arguments,
                 BindingFlags bindingFlags,
                 string remainder,
-                PropertiesUsageTracker propertiesUsageTracker,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3297,7 +3297,7 @@ internal Function(
                 _receiverType = receiverType;
                 _bindingFlags = bindingFlags;
                 _remainder = remainder;
-                _propertiesUsageTracker = propertiesUsageTracker;
+                _propertiesUseTracker = propertiesUseTracker;
                 _fileSystem = fileSystem;
                 _loggingContext = loggingContext;
             }
@@ -3321,7 +3321,7 @@ internal static Function<T> ExtractPropertyFunction(
                 string expressionFunction,
                 IElementLocation elementLocation,
                 object propertyValue,
-                PropertiesUsageTracker propertiesUsageTracker,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3345,7 +3345,7 @@ internal static Function<T> ExtractPropertyFunction(
                 ProjectErrorUtilities.VerifyThrowInvalidProject(!expressionRoot.IsEmpty, elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
                 functionBuilder.Expression = expressionFunction;
-                functionBuilder.PropertiesUsageTracker = propertiesUsageTracker;
+                functionBuilder.PropertiesUseTracker = propertiesUseTracker;
 
                 // This is a static method call
                 // A static method is the content that follows the last "::", the rest being the type
@@ -3497,7 +3497,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             properties,
                             options,
                             elementLocation,
-                            _propertiesUsageTracker,
+                            _propertiesUseTracker,
                             _fileSystem);
 
                         if (argument is string argumentValue)
@@ -3631,7 +3631,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         properties,
                         options,
                         elementLocation,
-                        _propertiesUsageTracker,
+                        _propertiesUseTracker,
                         _fileSystem);
                 }
 
@@ -5499,147 +5499,6 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
 #nullable enable
-    /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized.
-    /// </summary>
-    internal sealed class PropertiesUsageTracker
-    {
-        internal LoggingContext LoggingContext { get; init; }
-
-        public PropertiesUsageTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;
-
-        /// <summary>
-        /// Whether to warn when we set a property for the first time, after it was previously used.
-        /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
-        /// </summary>
-        // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
-        private bool _warnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
-
-        /// <summary>
-        /// Lazily allocated collection of properties and the element which used them.
-        /// </summary>
-        private Dictionary<string, IElementLocation>? _properties;
-
-        internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)
-        {
-            if (isArtificial || !isUninitialized)
-            {
-                return;
-            }
-
-            // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
-            //
-            // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
-            // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
-            //
-            // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
-            // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
-
-            // here handle null probably (or otherwise execution)
-            if (_warnForUninitializedProperties && CurrentlyEvaluatingPropertyElementName != null)
-            {
-                // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
-                if (!MSBuildNameIgnoreCaseComparer.Default.Equals(CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
-                {
-                    TryAdd(
-                        propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
-                        elementLocation);
-                }
-            }
-        }
-
-        internal void TryAdd(string propertyName, IElementLocation elementLocation)
-        {
-            if (_properties is null)
-            {
-                _properties = new(StringComparer.OrdinalIgnoreCase);
-            }
-            else if (_properties.ContainsKey(propertyName))
-            {
-                return;
-            }
-
-            _properties.Add(propertyName, elementLocation);
-        }
-
-        internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
-        {
-            if (_properties is null)
-            {
-                elementLocation = null;
-                return false;
-            }
-
-            return _properties.TryGetValue(propertyName, out elementLocation);
-        }
-
-        internal void RemoveProperty(string propertyName)
-        {
-            _properties?.Remove(propertyName);
-        }
-
-        /// <summary>
-        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
-        /// </summary>
-        internal string? CurrentlyEvaluatingPropertyElementName
-        {
-            get;
-            set;
-        }
-
-        internal void CheckPreexistingUndefinedUsage(IElementWithLocation propertyElement, string evaluatedValue, LoggingContext loggingContext)
-        {
-            // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
-            // during evaluation.
-            if (evaluatedValue.Length > 0 && _warnForUninitializedProperties)
-            {
-                // Is the property we are currently setting in the list of properties which have been used but not initialized
-                IElementLocation? elementWhichUsedProperty;
-                bool isPropertyInList = TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
-
-                if (isPropertyInList)
-                {
-                    // Once we are going to warn for a property once, remove it from the list so we do not add it again.
-                    RemoveProperty(propertyElement.Name);
-                    loggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty?.LocationString);
-                }
-            }
-
-            CurrentlyEvaluatingPropertyElementName = null;
-            PropertyReadContext = PropertyReadContext.Other;
-        }
-
-        private PropertyReadContext _propertyReadContext;
-        private PropertyReadContext _previousPropertyReadContext = PropertyReadContext.Other;
-        internal PropertyReadContext PropertyReadContext
-        {
-            private get => _propertyReadContext;
-            set
-            {
-                _previousPropertyReadContext = _propertyReadContext;
-                _propertyReadContext = value;
-            }
-        }
-
-        internal void ResetPropertyReadContext(bool popPrevious = true)
-        {
-            _propertyReadContext = popPrevious ? _previousPropertyReadContext : PropertyReadContext.Other;
-            _previousPropertyReadContext = PropertyReadContext.Other;
-        }
-    }
-
-    /// <summary>
-    /// Type of the context in which a property is read.
-    /// </summary>
-    internal enum PropertyReadContext
-    {
-        // we are not interested in distinguishing the item read etc.
-        Other,
-        ConditionEvaluation,
-        ConditionEvaluationWithOneSideEmpty,
-        PropertyEvaluation,
-        PropertyEvaluationSelf,
-    }
 
     internal static class IntrinsicFunctionOverload
     {
diff --git a/src/Build/Evaluation/PropertiesUseTracker.cs b/src/Build/Evaluation/PropertiesUseTracker.cs
new file mode 100644
index 00000000000..b88423adff1
--- /dev/null
+++ b/src/Build/Evaluation/PropertiesUseTracker.cs
@@ -0,0 +1,158 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+#nullable enable
+
+namespace Microsoft.Build.Evaluation;
+
+/// <summary>
+/// This class tracks reads of properties - so that it can detect uninitialized usages
+///  and so that it can forward the accessing information to further interested consumers (e.g. BuildCheck).
+/// </summary>
+internal sealed class PropertiesUseTracker
+{
+    internal LoggingContext LoggingContext { get; init; }
+
+    public PropertiesUseTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;
+
+    /// <summary>
+    /// Whether to warn when we set a property for the first time, after it was previously used.
+    /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
+    /// </summary>
+    // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
+    private bool _warnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
+
+    /// <summary>
+    /// Lazily allocated collection of properties and the element which used them.
+    /// </summary>
+    private Dictionary<string, IElementLocation>? _properties;
+
+    internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)
+    {
+        if (isArtificial || !isUninitialized)
+        {
+            return;
+        }
+
+        // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
+        //
+        // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
+        // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
+        //
+        // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
+        // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
+
+        // here handle null probably (or otherwise execution)
+        if (_warnForUninitializedProperties && CurrentlyEvaluatingPropertyElementName != null)
+        {
+            // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
+            if (!MSBuildNameIgnoreCaseComparer.Default.Equals(CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
+            {
+                TryAdd(
+                    propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
+                    elementLocation);
+            }
+        }
+    }
+
+    internal void TryAdd(string propertyName, IElementLocation elementLocation)
+    {
+        if (_properties is null)
+        {
+            _properties = new(StringComparer.OrdinalIgnoreCase);
+        }
+        else if (_properties.ContainsKey(propertyName))
+        {
+            return;
+        }
+
+        _properties.Add(propertyName, elementLocation);
+    }
+
+    internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
+    {
+        if (_properties is null)
+        {
+            elementLocation = null;
+            return false;
+        }
+
+        return _properties.TryGetValue(propertyName, out elementLocation);
+    }
+
+    internal void RemoveProperty(string propertyName)
+    {
+        _properties?.Remove(propertyName);
+    }
+
+    /// <summary>
+    ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
+    /// </summary>
+    internal string? CurrentlyEvaluatingPropertyElementName
+    {
+        get;
+        set;
+    }
+
+    internal void CheckPreexistingUndefinedUsage(IPropertyElementWithLocation propertyElement, string evaluatedValue, LoggingContext loggingContext)
+    {
+        // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
+        // during evaluation.
+        if (evaluatedValue.Length > 0 && _warnForUninitializedProperties)
+        {
+            // Is the property we are currently setting in the list of properties which have been used but not initialized
+            IElementLocation? elementWhichUsedProperty;
+            bool isPropertyInList = TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
+
+            if (isPropertyInList)
+            {
+                // Once we are going to warn for a property once, remove it from the list so we do not add it again.
+                RemoveProperty(propertyElement.Name);
+                loggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty?.LocationString);
+            }
+        }
+
+        CurrentlyEvaluatingPropertyElementName = null;
+        PropertyReadContext = PropertyReadContext.Other;
+    }
+
+    private PropertyReadContext _propertyReadContext;
+    private PropertyReadContext _previousPropertyReadContext = PropertyReadContext.Other;
+    internal PropertyReadContext PropertyReadContext
+    {
+        private get => _propertyReadContext;
+        set
+        {
+            _previousPropertyReadContext = _propertyReadContext;
+            _propertyReadContext = value;
+        }
+    }
+
+    internal void ResetPropertyReadContext(bool pop = true)
+    {
+        _propertyReadContext = pop ? _previousPropertyReadContext : PropertyReadContext.Other;
+        _previousPropertyReadContext = PropertyReadContext.Other;
+    }
+}
+
+/// <summary>
+/// Type of the context in which a property is read.
+/// </summary>
+internal enum PropertyReadContext
+{
+    // we are not interested in distinguishing the item read etc.
+    Other,
+    ConditionEvaluation,
+    ConditionEvaluationWithOneSideEmpty,
+    PropertyEvaluation,
+    PropertyEvaluationSelf,
+}
diff --git a/src/Build/Instance/IElementWithLocation.cs b/src/Build/Instance/IElementWithLocation.cs
deleted file mode 100644
index 34a05fe3de4..00000000000
--- a/src/Build/Instance/IElementWithLocation.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Construction;
-
-namespace Microsoft.Build.Execution
-{
-    internal interface IElementWithLocation
-    {
-        string Name { get; }
-        string Value { get; }
-        ElementLocation Location { get; }
-    }
-}
diff --git a/src/Build/Instance/IPropertyElementWithLocation.cs b/src/Build/Instance/IPropertyElementWithLocation.cs
new file mode 100644
index 00000000000..f77282d9590
--- /dev/null
+++ b/src/Build/Instance/IPropertyElementWithLocation.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Represents a xml node in a project file that defines a property.
+    /// </summary>
+    internal interface IPropertyElementWithLocation
+    {
+        /// <summary>
+        /// Name of the property.
+        /// </summary>
+        string Name { get; }
+
+        /// <summary>
+        /// Unevaluated value of the property.
+        /// </summary>
+        string Value { get; }
+
+        /// <summary>
+        /// Location of the property element within build scripts.
+        /// </summary>
+        ElementLocation Location { get; }
+    }
+}
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index f7c5f5654d3..5ce7695e734 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Execution
     /// Immutable.
     /// </summary>
     [DebuggerDisplay("{_name}={Value} Condition={_condition}")]
-    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable, IElementWithLocation
+    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable, IPropertyElementWithLocation
     {
         /// <summary>
         /// Name of the property
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index f439bafbb4e..3e958274425 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -191,6 +191,7 @@
     <Compile Include="BuildCheck\Utilities\Constants.cs" />
     <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="Evaluation\PropertiesUseTracker.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
     <Compile Include="FileAccess\FileAccessData.cs" />
     <Compile Include="FileAccess\FlagsAndAttributes.cs" />
@@ -199,7 +200,7 @@
     <Compile Include="FileAccess\RequestedAccess.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
-    <Compile Include="Instance\IElementWithLocation.cs" />
+    <Compile Include="Instance\IPropertyElementWithLocation.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
