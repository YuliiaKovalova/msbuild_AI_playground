diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 688b0e3f306..5b65829e926 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1500,19 +1500,6 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                                 }
                                 finally
                                 {
-                                    // Embed the source file
-                                    if (factory is IHasSourceFilePath factoryWithSourceFilePath &&
-                                        factoryWithSourceFilePath.SourceFilePath != null)
-                                    {
-                                        taskFactoryLoggingHost.LoggingContext.LogIncludeFile(factoryWithSourceFilePath.SourceFilePath);
-
-                                        if (factoryWithSourceFilePath.IsGeneratedSourceFile &&
-                                            factoryWithSourceFilePath.DeleteGeneratedSourceFile &&
-                                            FileSystems.Default.FileExists(factoryWithSourceFilePath.SourceFilePath))
-                                        {
-                                            File.Delete(factoryWithSourceFilePath.SourceFilePath);
-                                        }
-                                    }
 #if FEATURE_APPDOMAIN
                                     taskFactoryLoggingHost.MarkAsInactive();
 #endif
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index a9e6f75705f..3faaf1bc7a2 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -364,6 +364,10 @@ private void CollectImports(BuildEventArgs e)
             {
                 projectImportsCollector.AddFile(responseFileArgs.ResponseFilePath);
             }
+            else if (e is ResponseGeneratedFileUsedEventArgs responseGeneratedFileArgs)
+            {
+                projectImportsCollector.AddFileFromMemory(responseGeneratedFileArgs.ResponseFilePath, responseGeneratedFileArgs.ResponseFileCode);
+            }
         }
 
         /// <summary>
diff --git a/src/Framework/IHasSourceFilePath.cs b/src/Framework/IHasSourceFilePath.cs
deleted file mode 100644
index 15f0b933e4d..00000000000
--- a/src/Framework/IHasSourceFilePath.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.Build.Framework
-{
-    internal interface IHasSourceFilePath
-    {
-        string? SourceFilePath { get; }
-
-        bool IsGeneratedSourceFile { get; }
-
-        bool DeleteGeneratedSourceFile { get; }
-    }
-}
diff --git a/src/Framework/ResponseFileUsedEventArgs.cs b/src/Framework/ResponseFileUsedEventArgs.cs
index ac7f3950697..7e9f132a262 100644
--- a/src/Framework/ResponseFileUsedEventArgs.cs
+++ b/src/Framework/ResponseFileUsedEventArgs.cs
@@ -14,17 +14,13 @@ public class ResponseFileUsedEventArgs : BuildMessageEventArgs
         public ResponseFileUsedEventArgs()
         {
         }
-
         /// <summary>
-        /// Initializes a new instance of the <see cref="ResponseFileUsedEventArgs"/> class.
         /// Initialize a new instance of the ResponseFileUsedEventArgs class.
         /// </summary>
-        public ResponseFileUsedEventArgs(string? responseFilePath)
-            : base(null, null, null, MessageImportance.Low)
+        public ResponseFileUsedEventArgs(string? responseFilePath) : base()
         {
             ResponseFilePath = responseFilePath;
         }
-
         public string? ResponseFilePath { set; get; }
     }
 }
diff --git a/src/Framework/ResponseGeneratedFileUsedEventArgs.cs b/src/Framework/ResponseGeneratedFileUsedEventArgs.cs
new file mode 100644
index 00000000000..93ba22615bb
--- /dev/null
+++ b/src/Framework/ResponseGeneratedFileUsedEventArgs.cs
@@ -0,0 +1,29 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Arguments for the response file used event
+    /// </summary>
+    [Serializable]
+    public class ResponseGeneratedFileUsedEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ResponseGeneratedFileUsedEventArgs"/> class.
+        /// Initialize a new instance of the ResponseFileUsedEventArgs class.
+        /// </summary>
+        public ResponseGeneratedFileUsedEventArgs(string responseFilePath, string responseFileCode)
+            : base(null, null, null, MessageImportance.Low)
+        {
+            ResponseFilePath = responseFilePath;
+            ResponseFileCode = responseFileCode;
+        }
+
+        public string ResponseFilePath { set; get; }
+
+        public string ResponseFileCode { set; get; }
+    }
+}
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index da848678ded..0ed5acd1127 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -503,6 +503,16 @@ public void LogMessageFromResources(MessageImportance importance, string message
 #endif
         }
 
+        public void LogIncludeGeneratedFile(string filePath, string data)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(filePath, nameof(filePath));
+            ErrorUtilities.VerifyThrowArgumentNull(data, nameof(data));
+
+            var responseGeneratedFileUsedArgs = new ResponseGeneratedFileUsedEventArgs(filePath, data);
+
+            BuildEngine.LogMessageEvent(responseGeneratedFileUsedArgs);
+        }
+
         /// <summary>
         /// Flatten the inner exception message
         /// </summary>
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 58f6799ceab..34b425d47e7 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -13,9 +13,9 @@
 
 namespace Microsoft.Build.UnitTests
 {
-#if FEATURE_CODETASKFACTORY
 
     using System.CodeDom.Compiler;
+    using System.Globalization;
     using System.IO.Compression;
     using Microsoft.Build.Logging;
     using Shouldly;
@@ -1043,8 +1043,89 @@ public override bool Execute()
             }
         }
 
+        /// <summary>
+        /// Code factory test where the TMP directory does not exist.
+        /// See https://github.com/dotnet/msbuild/issues/328 for details.
+        /// </summary>
+        [Fact]
+        public void BuildTaskSimpleCodeFactoryTempDirectoryDoesntExist()
+        {
+            string projectFileContents = @"
+                    <Project ToolsVersion='msbuilddefaulttoolsversion'>
+                        <UsingTask TaskName=`CustomTaskFromCodeFactory_BuildTaskSimpleCodeFactory` TaskFactory=`CodeTaskFactory` AssemblyFile=`$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll` >
+                         <ParameterGroup>
+                             <Text/>
+                          </ParameterGroup>
+                            <Task>
+                                <Code>
+                                     Log.LogMessage(MessageImportance.High, Text);
+                                </Code>
+                            </Task>
+                        </UsingTask>
+                        <Target Name=`Build`>
+                            <CustomTaskFromCodeFactory_BuildTaskSimpleCodeFactory Text=`Hello, World!` />
+                        </Target>
+                    </Project>";
+
+            var oldTempPath = Environment.GetEnvironmentVariable("TMP");
+            var newTempPath = Path.Combine(Path.GetFullPath(oldTempPath), Path.GetRandomFileName());
+
+            try
+            {
+                // Ensure we're getting the right temp path (%TMP% == GetTempPath())
+                Assert.Equal(
+                    FileUtilities.EnsureTrailingSlash(Path.GetTempPath()),
+                    FileUtilities.EnsureTrailingSlash(Path.GetFullPath(oldTempPath)));
+                Assert.False(Directory.Exists(newTempPath));
+
+                Environment.SetEnvironmentVariable("TMP", newTempPath);
+
+                Assert.Equal(
+                    FileUtilities.EnsureTrailingSlash(newTempPath),
+                    FileUtilities.EnsureTrailingSlash(Path.GetTempPath()));
+
+                MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
+                mockLogger.AssertLogContains("Hello, World!");
+            }
+            finally
+            {
+                Environment.SetEnvironmentVariable("TMP", oldTempPath);
+                FileUtilities.DeleteDirectoryNoThrow(newTempPath, true);
+            }
+        }
+
+        /// <summary>
+        /// Test the simple case where we have a string parameter and we want to log that.
+        /// </summary>
+        [Fact]
+        public void RedundantMSBuildReferences()
+        {
+            string projectFileContents = @"
+                    <Project ToolsVersion='msbuilddefaulttoolsversion'>
+                        <UsingTask TaskName=`CustomTaskFromCodeFactory_RedundantMSBuildReferences` TaskFactory=`CodeTaskFactory` AssemblyFile=`$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll` >
+                         <ParameterGroup>
+                             <Text/>
+                          </ParameterGroup>
+                            <Task>
+                              <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.Framework.dll' />
+                              <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.Utilities.Core.dll' />
+
+                                <Code>
+                                     Log.LogMessage(MessageImportance.High, Text);
+                                </Code>
+                            </Task>
+                        </UsingTask>
+                        <Target Name=`Build`>
+                            <CustomTaskFromCodeFactory_RedundantMSBuildReferences Text=`Hello, World!` />
+                        </Target>
+                    </Project>";
+
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
+            mockLogger.AssertLogContains("Hello, World!");
+        }
+
         [Fact]
-        public void EmbedsSourceFileInBinlog()
+        public void EmbedsGeneratedFromSourceFileInBinlog()
         {
             string taskName = "HelloTask";
 
@@ -1094,23 +1175,29 @@ public override bool Execute()
                 CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
             };
 
-            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
 
             result.ShouldBeTrue();
-            File.Exists(taskClass.Path).ShouldBeTrue();
+
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
 
             string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
             using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
             using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
 
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith($"{taskName}.cs"),
-                $"Binlog's embedded files didn't have the expected {taskName}.cs.");
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
         }
 
         [Fact]
-        public void EmbedsSourceFileInBinlogWhenFailsToCompile()
+        public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
         {
             string taskName = "HelloTask";
 
@@ -1153,133 +1240,143 @@ public class {{taskName}} : Task
                 CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
             };
 
-            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
 
             result.ShouldBeFalse();
-            File.Exists(classThatFailsToCompile.Path).ShouldBeTrue();
+
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
 
             string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
             using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
             using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
 
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith($"{taskName}.cs"),
-                $"Binlog's embedded files didn't have the expected {taskName}.cs.");
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
         }
 
-        /// <summary>
-        /// Code factory test where the TMP directory does not exist.
-        /// See https://github.com/dotnet/msbuild/issues/328 for details.
-        /// </summary>
         [Fact]
-        public void BuildTaskSimpleCodeFactoryTempDirectoryDoesntExist()
+        public void EmbedsGeneratedFileInBinlog()
         {
-            string projectFileContents = @"
-                    <Project ToolsVersion='msbuilddefaulttoolsversion'>
-                        <UsingTask TaskName=`CustomTaskFromCodeFactory_BuildTaskSimpleCodeFactory` TaskFactory=`CodeTaskFactory` AssemblyFile=`$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll` >
-                         <ParameterGroup>
-                             <Text/>
-                          </ParameterGroup>
-                            <Task>
-                                <Code>
-                                     Log.LogMessage(MessageImportance.High, Text);
-                                </Code>
-                            </Task>
-                        </UsingTask>
-                        <Target Name=`Build`>
-                            <CustomTaskFromCodeFactory_BuildTaskSimpleCodeFactory Text=`Hello, World!` />
-                        </Target>
-                    </Project>";
+            string taskName = "HelloTask";
 
-            var oldTempPath = Environment.GetEnvironmentVariable("TMP");
-            var newTempPath = Path.Combine(Path.GetFullPath(oldTempPath), Path.GetRandomFileName());
+            using var env = TestEnvironment.Create();
 
-            try
-            {
-                // Ensure we're getting the right temp path (%TMP% == GetTempPath())
-                Assert.Equal(
-                    FileUtilities.EnsureTrailingSlash(Path.GetTempPath()),
-                    FileUtilities.EnsureTrailingSlash(Path.GetFullPath(oldTempPath)));
-                Assert.False(Directory.Exists(newTempPath));
+            string projectFileContents = $"""
+                <Project>
 
-                Environment.SetEnvironmentVariable("TMP", newTempPath);
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="CodeTaskFactory"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    <Task>
+                	    <Code Type="Fragment" Language="cs">
+                		    <![CDATA[
+                		      Log.LogMessage("Hello, World tttttest!");
+                		    ]]>
+                	    </Code>
+                    </Task>
+                  </UsingTask>
 
-                Assert.Equal(
-                    FileUtilities.EnsureTrailingSlash(newTempPath),
-                    FileUtilities.EnsureTrailingSlash(Path.GetTempPath()));
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
 
-                MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
-                mockLogger.AssertLogContains("Hello, World!");
-            }
-            finally
+                </Project>
+                """;
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
             {
-                Environment.SetEnvironmentVariable("TMP", oldTempPath);
-                FileUtilities.DeleteDirectoryNoThrow(newTempPath, true);
-            }
-        }
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
 
-        /// <summary>
-        /// Test the simple case where we have a string parameter and we want to log that.
-        /// </summary>
-        [Fact]
-        public void RedundantMSBuildReferences()
-        {
-            string projectFileContents = @"
-                    <Project ToolsVersion='msbuilddefaulttoolsversion'>
-                        <UsingTask TaskName=`CustomTaskFromCodeFactory_RedundantMSBuildReferences` TaskFactory=`CodeTaskFactory` AssemblyFile=`$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll` >
-                         <ParameterGroup>
-                             <Text/>
-                          </ParameterGroup>
-                            <Task>
-                              <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.Framework.dll' />
-                              <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.Utilities.Core.dll' />
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
 
-                                <Code>
-                                     Log.LogMessage(MessageImportance.High, Text);
-                                </Code>
-                            </Task>
-                        </UsingTask>
-                        <Target Name=`Build`>
-                            <CustomTaskFromCodeFactory_RedundantMSBuildReferences Text=`Hello, World!` />
-                        </Target>
-                    </Project>";
+            result.ShouldBeTrue();
 
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
-            mockLogger.AssertLogContains("Hello, World!");
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
         }
-    }
-#else
-    public sealed class CodeTaskFactoryTests
-    {
+
         [Fact]
-        public void CodeTaskFactoryNotSupported()
+        public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
         {
-            string projectFileContents = @"
-                    <Project ToolsVersion='msbuilddefaulttoolsversion'>
-                        <UsingTask TaskName=`CustomTaskFromCodeFactory_BuildTaskSimpleCodeFactory` TaskFactory=`CodeTaskFactory` AssemblyFile=`$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll` >
-                         <ParameterGroup>
-                             <Text/>
-                          </ParameterGroup>
-                            <Task>
-                                <Code>
-                                     Log.LogMessage(MessageImportance.High, Text);
-                                </Code>
-                            </Task>
-                        </UsingTask>
-                        <Target Name=`Build`>
-                            <CustomTaskFromCodeFactory_BuildTaskSimpleCodeFactory Text=`Hello, World!` />
-                        </Target>
-                    </Project>";
+            string taskName = "HelloTask";
+
+            using var env = TestEnvironment.Create();
+
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="CodeTaskFactory"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    <Task>
+                	    <Code Type="Fragment" Language="cs">
+                		    <![CDATA[
+                		      Log.LogMessage("Hello, World tttttest!
+                		    ]]>
+                	    </Code>
+                    </Task>
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
 
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectFailure(projectFileContents, allowTaskCrash: false);
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
+
+            result.ShouldBeFalse();
 
-            BuildErrorEventArgs error = mockLogger.Errors.FirstOrDefault();
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
 
-            Assert.NotNull(error);
-            Assert.Equal("MSB4801", error.Code);
-            Assert.Contains("CodeTaskFactory", error.Message);
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
         }
     }
-#endif
 }
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 40ee85812ab..79486931fae 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -22,6 +22,8 @@
 using Xunit;
 
 using static VerifyXunit.Verifier;
+using Microsoft.Build.Logging;
+using System.IO.Compression;
 
 #nullable disable
 
@@ -645,15 +647,13 @@ public override bool Execute()
         }
 
         [Fact]
-        public void EmbedsSourceFileInBinlog()
+        public void EmbedsGeneratedFromSourceFileInBinlog()
         {
             string taskName = "HelloTask";
-            string csprojFileName = "EmbedsSourceFileInTheBinlogTest.csproj";
-            string targetName = "SayHello";
 
             using var env = TestEnvironment.Create();
-            TransientTestFolder folder = env.CreateFolder(createFolder: true);
-            TransientTestFile taskClass = env.CreateFile(folder, $"{taskName}.cs", $$"""
+            var folder = env.CreateFolder(createFolder: true);
+            var taskClass = env.CreateFile(folder, $"{taskName}.cs", $$"""
                 namespace InlineTask
                 {
                     using Microsoft.Build.Utilities;
@@ -667,8 +667,9 @@ public override bool Execute()
                         }
                     }
                 }
-                """);         
-            TransientTestFile assemblyProj = env.CreateFile(folder, csprojFileName, $"""
+                """);
+
+            string projectFileContents = $"""
                 <Project>
 
                   <UsingTask
@@ -681,54 +682,59 @@ public override bool Execute()
                     </Task>
                   </UsingTask>
 
-                    <Target Name="{targetName}">
+                    <Target Name="SayHello">
                         <{taskName} />
                     </Target>
 
                 </Project>
-                """);
+                """;
 
-            string binLogFile = Path.Combine(folder.Path, "log.binlog");
-            string output = RunnerUtilities.ExecMSBuild($"{assemblyProj.Path} /t:{targetName} /bl:\"LogFile={binLogFile};ProjectImports=ZipFile\"", out bool success);
+            TransientTestFile binlog = env.ExpectFile(".binlog");
 
-            success.ShouldBeTrue();
-            File.Exists(taskClass.Path).ShouldBeTrue();
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
 
-            string projectImportsZipPath = Path.ChangeExtension(binLogFile, ".ProjectImports.zip");
+            result.ShouldBeTrue();
+
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
             using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
             using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
 
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith($"{taskName}.cs"),
-                $"Binlog's embedded files didn't have the expected {taskName}.cs.");
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
         }
 
         [Fact]
-        public void EmbedsSourceFileInBinlogWhenFailsToCompile()
+        public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
         {
             string taskName = "HelloTask";
-            string csprojFileName = "EmbedsSourceFileInTheBinlogTest.csproj";
-            string targetName = "SayHello";
 
             using var env = TestEnvironment.Create();
-            TransientTestFolder folder = env.CreateFolder(createFolder: true);
-            TransientTestFile classThatFailsToCompile = env.CreateFile(folder, $"{taskName}.cs", $$"""
+            var folder = env.CreateFolder(createFolder: true);
+            var classThatFailsToCompile = env.CreateFile(folder, $"{taskName}.cs", $$"""
                 namespace InlineTask
                 {
-                    using Microsoft.Build.Utilities
+                    using Microsoft.Build.Utilities;
 
                     public class {{taskName}} : Task
                     {
-                        public override bool Execute()
-                        {
-                            Log.LogMessage("Hello, world!")
-                            return !Log.HasLoggedErrors
-                        }
-                    }
-                }
                 """);
-            TransientTestFile assemblyProj = env.CreateFile(folder, csprojFileName, $"""
+
+            string projectFileContents = $"""
                 <Project>
 
                   <UsingTask
@@ -741,27 +747,158 @@ public override bool Execute()
                     </Task>
                   </UsingTask>
 
-                    <Target Name="{targetName}">
+                    <Target Name="SayHello">
                         <{taskName} />
                     </Target>
 
                 </Project>
-                """);
+                """;
 
-            string binLogFile = Path.Combine(folder.Path, "log.binlog");
-            string output = RunnerUtilities.ExecMSBuild($"{assemblyProj.Path} /t:{targetName} /bl:\"LogFile={binLogFile};ProjectImports=ZipFile\"", out bool success);
+            TransientTestFile binlog = env.ExpectFile(".binlog");
 
-            success.ShouldBeFalse();
-            File.Exists(classThatFailsToCompile.Path).ShouldBeTrue();
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
 
-            string projectImportsZipPath = Path.ChangeExtension(binLogFile, ".ProjectImports.zip");
+            result.ShouldBeFalse();
+
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
             using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
             using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
 
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlog()
+        {
+            string taskName = "HelloTask";
+
+            using var env = TestEnvironment.Create();
+
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="RoslynCodeTaskFactory"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    <Task>
+                	    <Code Type="Fragment" Language="cs">
+                		    <![CDATA[
+                		      Log.LogMessage("Hello, World tttttest!");
+                		    ]]>
+                	    </Code>
+                    </Task>
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
+
+            result.ShouldBeTrue();
+
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
+            using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
+        {
+            string taskName = "HelloTask";
+
+            using var env = TestEnvironment.Create();
+
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="RoslynCodeTaskFactory"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    <Task>
+                	    <Code Type="Fragment" Language="cs">
+                		    <![CDATA[
+                		      Log.LogMessage("Hello, World tttttest!
+                		    ]]>
+                	    </Code>
+                    </Task>
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
+
+            result.ShouldBeFalse();
+
+            // Get the file path from the logs
+            // Then check if it is in the binlog
+            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
+            using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            filePath = filePath.Replace(":\\", "\\");
+
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith($"{taskName}.cs"),
-                $"Binlog's embedded files didn't have the expected {taskName}.cs.");
+            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
+                $"Binlog's embedded files didn't have the expected '{filePath}'.");
         }
 
 #if !FEATURE_RUN_EXE_IN_TESTS
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index e048b3ca618..a3fe4ec2e4e 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -11,7 +11,6 @@
 
 namespace Microsoft.Build.Tasks
 {
-#if FEATURE_CODETASKFACTORY
     using System.CodeDom;
     using System.CodeDom.Compiler;
     using System.Collections.Concurrent;
@@ -27,7 +26,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// A task factory which can take code dom supported languages and create a task out of it
     /// </summary>
-    public class CodeTaskFactory : ITaskFactory, IHasSourceFilePath
+    public class CodeTaskFactory : ITaskFactory
     {
         /// <summary>
         /// This dictionary keeps track of custom references to compiled assemblies.  The in-memory assembly is loaded from a byte
@@ -161,12 +160,6 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         /// </summary>
         public Type TaskType { get; private set; }
 
-        public string SourceFilePath { get => _sourcePath; }
-
-        public bool IsGeneratedSourceFile { get; private set; }
-
-        public bool DeleteGeneratedSourceFile { get => true; }
-
         /// <summary>
         /// Get the type information for all task parameters.
         /// </summary>
@@ -236,8 +229,6 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
                 {
                     _type = "Class";
                 }
-
-                IsGeneratedSourceFile = false;
             }
 
             _referencedAssemblies = ExtractReferencedAssemblies();
@@ -799,18 +790,24 @@ private Assembly CompileInMemoryAssembly()
                 // Our code generation is complete, grab the source from the builder ready for compilation
                 string fullCode = codeBuilder.ToString();
 
+                string tempDirectory = FileUtilities.TempFileDirectory;
+                string fileName = Guid.NewGuid().ToString() + ".txt";
+                string outputPath = Path.Combine(tempDirectory, fileName);
+
+                // Embed generated file in the binlog
+                _log.LogIncludeGeneratedFile(outputPath, fullCode);
+
+                // Log the location of the code file in binlog
+                _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileInBinlogAt", outputPath);
+
                 var fullSpec = new FullTaskSpecification(finalReferencedAssemblies, fullCode);
                 if (!s_compiledTaskCache.TryGetValue(fullSpec, out Assembly existingAssembly))
                 {
                     // Invokes compilation.
                     CompilerResults compilerResults = provider.CompileAssemblyFromSource(compilerParameters, fullCode);
 
-                    string outputPath = null;
                     if (compilerResults.Errors.Count > 0 || Environment.GetEnvironmentVariable("MSBUILDLOGCODETASKFACTORYOUTPUT") != null)
-                    {
-                        string tempDirectory = FileUtilities.TempFileDirectory;
-                        string fileName = Guid.NewGuid().ToString() + ".txt";
-                        outputPath = Path.Combine(tempDirectory, fileName);
+                    {                        
                         File.WriteAllText(outputPath, fullCode);
                     }
 
@@ -1019,46 +1016,4 @@ int IComparable<FullTaskSpecification>.CompareTo(FullTaskSpecification other)
             }
         }
     }
-#else
-    /// <summary>
-    /// A task factory which can take code dom supported languages and create a task out of it
-    /// </summary>
-    /// <remarks>CodeDom is not supported for .NET Core so this code task factory simply logs an error that it isn't supported.
-    /// If we don't compile this class, then the user will get an error that the class doesn't exist which is a bad experience.</remarks>
-    [Obsolete("The CodeTaskFactory is not supported on .NET Core.  This class is included so that users receive run-time errors and should not be used for any other purpose.", error: true)]
-    public sealed class CodeTaskFactory : ITaskFactory
-    {
-        public string FactoryName => "Code Task Factory";
-
-        public Type TaskType { get; } = null;
-
-        public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost)
-        {
-            TaskLoggingHelper log = new TaskLoggingHelper(taskFactoryLoggingHost, taskName)
-            {
-                TaskResources = AssemblyResources.PrimaryResources,
-                HelpKeywordPrefix = "MSBuild."
-            };
-
-            log.LogErrorWithCodeFromResources("TaskFactoryNotSupportedFailure", nameof(CodeTaskFactory));
-
-            return false;
-        }
-
-        public TaskPropertyInfo[] GetTaskParameters()
-        {
-            throw new NotSupportedException();
-        }
-
-        public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
-        {
-            throw new NotSupportedException();
-        }
-
-        public void CleanupTask(ITask task)
-        {
-            throw new NotSupportedException();
-        }
-    }
-#endif
 }
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 3e363da30cf..7f89cca13af 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -22,7 +22,7 @@
 
 namespace Microsoft.Build.Tasks
 {
-    public sealed class RoslynCodeTaskFactory : ITaskFactory, IHasSourceFilePath
+    public sealed class RoslynCodeTaskFactory : ITaskFactory
     {
         /// <summary>
         /// A set of default namespaces to add so that user does not have to include them.  Make sure that these are covered
@@ -119,12 +119,6 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory, IHasSourceFilePath
         /// </summary>
         public Type TaskType { get; private set; }
 
-        public string SourceFilePath { get; private set; }
-
-        public bool IsGeneratedSourceFile { get; private set; }
-
-        public bool DeleteGeneratedSourceFile { get; private set; }
-
         /// <inheritdoc cref="ITaskFactory.CleanupTask(ITask)"/>
         public void CleanupTask(ITask task)
         {
@@ -167,9 +161,6 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
                 return false;
             }
 
-            SourceFilePath = taskInfo.Source;
-            IsGeneratedSourceFile = taskInfo.Source != null ? false : true;
-
             // Attempt to compile an assembly (or get one from the cache)
             if (!TryCompileInMemoryAssembly(taskFactoryLoggingHost, taskInfo, out Assembly assembly))
             {
@@ -449,7 +440,6 @@ internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, str
 
                 // Instead of using the inner text of the <Code /> element, read the specified file as source code
                 taskInfo.CodeType = RoslynCodeTaskFactoryCodeType.Class;
-                taskInfo.Source = sourceAttribute.Value;
                 taskInfo.SourceCode = File.ReadAllText(sourceAttribute.Value.Trim());
             }
 
@@ -691,18 +681,19 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
 
             // Delete the code file unless compilation failed or the environment variable MSBUILDLOGCODETASKFACTORYOUTPUT
             // is set (which allows for debugging problems)
-            DeleteGeneratedSourceFile = Environment.GetEnvironmentVariable("MSBUILDLOGCODETASKFACTORYOUTPUT") == null;
+            bool deleteSourceCodeFile = Environment.GetEnvironmentVariable("MSBUILDLOGCODETASKFACTORYOUTPUT") == null;
 
             try
             {
+                // Embed generated file in the binlog
+                _log.LogIncludeGeneratedFile(sourceCodePath, taskInfo.SourceCode);
+
+                // Log the location of the code file in binlog
+                _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileInBinlogAt", sourceCodePath);
+
                 // Create the code
                 File.WriteAllText(sourceCodePath, taskInfo.SourceCode);
 
-                if (IsGeneratedSourceFile)
-                {
-                    SourceFilePath = sourceCodePath;
-                }
-
                 // Execute the compiler.  We re-use the existing build task by hosting it and giving it our IBuildEngine instance for logging
                 RoslynCodeTaskFactoryCompilerBase managedCompiler = null;
 
@@ -756,21 +747,18 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
 
                     if (!managedCompiler.Execute())
                     {
-                        DeleteGeneratedSourceFile = false;
+                        deleteSourceCodeFile = false;
 
                         _log.LogErrorWithCodeFromResources("CodeTaskFactory.FindSourceFileAt", sourceCodePath);
 
                         return false;
                     }
 
-                    if (!DeleteGeneratedSourceFile)
+                    if (!deleteSourceCodeFile)
                     {
                         // Log the location of the code file because MSBUILDLOGCODETASKFACTORYOUTPUT was set.
                         _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileAt", sourceCodePath);
-                    }
-
-                    // Log the location of the code file in binlog
-                    _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileInBinlogAt", sourceCodePath);
+                    }   
                 }
 
                 // Return the assembly which is loaded into memory
@@ -792,6 +780,11 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
                 {
                     File.Delete(assemblyPath);
                 }
+
+                if (deleteSourceCodeFile && FileSystems.Default.FileExists(sourceCodePath))
+                {
+                    File.Delete(sourceCodePath);
+                }
             }
         }
     }
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
index 1473000bfab..72993020895 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
@@ -35,11 +35,6 @@ internal sealed class RoslynCodeTaskFactoryTaskInfo : IEquatable<RoslynCodeTaskF
         /// </summary>
         public ISet<string> References { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
-        /// <summary>
-        /// Gets or sets the source of the assembly.
-        /// </summary>
-        public string Source { get; set; }
-
         /// <summary>
         /// Gets or sets the source code of the assembly.
         /// </summary>
diff --git a/src/UnitTests.Shared/MockLogger.cs b/src/UnitTests.Shared/MockLogger.cs
index dab6b5e32d0..ea638a0bbb2 100644
--- a/src/UnitTests.Shared/MockLogger.cs
+++ b/src/UnitTests.Shared/MockLogger.cs
@@ -504,6 +504,52 @@ public void AssertLogContains(bool isCaseSensitive, params string[] contains)
             }
         }
 
+        /// <summary>
+        /// Asserts that log file contains a message with a single parameter.
+        /// </summary>
+        /// <param name="message">The message that contains '{0}' substring.</param>
+        /// <param name="parameter">The parameter.</param>
+        public void AssertLogContainsMessageWithParameter(string message, out string parameter)
+        {
+            parameter = "";
+            string placeholder = "{0}";
+
+            string regexPattern = "";
+            if (message.Contains(placeholder))
+            {
+                regexPattern = message.Replace(placeholder, "(.*)");
+            }
+            else
+            {
+                Assert.True(
+                        false,
+                        $"'{message}' was expected to contain a substring '{{0}}'.");
+            }
+
+            lock (_lockObj)
+            {
+                var reader = new StringReader(FullLog);
+                string currentLine = reader.ReadLine();
+
+                while (currentLine != null)
+                {
+                    var match = Regex.Match(currentLine, regexPattern);
+
+                    if (match.Success && match.Groups.Count > 1)
+                    {
+                        parameter = match.Groups[1].Value;
+                        return;
+                    }
+
+                    currentLine = reader.ReadLine();
+                }
+
+                Assert.True(
+                        false,
+                        $"Log was expected to contain '{message}', but did not. Full log:\n=======\n{FullLog}\n=======");
+            }
+        }
+
         /// <summary>
         /// Assert that the log file does not contain the given string.
         /// </summary>
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index a7a8078a74d..0643f993db6 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -1359,15 +1359,20 @@ private static void BuildProjectWithNewOM(string content, ref MockLogger logger,
             result = project.Build(loggers);
         }
 
-        public static void BuildProjectWithNewOMAndBinaryLogger(string content, BinaryLogger binaryLogger, out bool result)
+        public static MockLogger BuildProjectWithNewOMAndBinaryLogger(string content, BinaryLogger binaryLogger, out bool result)
         {
             // Replace the nonstandard quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             Project project = new Project(XmlReader.Create(new StringReader(content)), null, toolsVersion: null);
-            List<ILogger> loggers = new List<ILogger>();
-            loggers.Add(binaryLogger);
+
+            var mockLogger = new MockLogger();
+
+            List<ILogger> loggers = new List<ILogger>() { binaryLogger, mockLogger };
+
             result = project.Build(loggers);
+
+            return mockLogger;
         }
 
         public static MockLogger BuildProjectContentUsingBuildManagerExpectResult(string content, BuildResultCode expectedResult)
