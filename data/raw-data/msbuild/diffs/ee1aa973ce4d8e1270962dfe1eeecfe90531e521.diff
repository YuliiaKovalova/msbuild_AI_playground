diff --git a/documentation/specs/BuildCheck/BuildCheck.md b/documentation/specs/BuildCheck/BuildCheck.md
index e1aaba36424..c2f6e0e8864 100644
--- a/documentation/specs/BuildCheck/BuildCheck.md
+++ b/documentation/specs/BuildCheck/BuildCheck.md
@@ -205,19 +205,20 @@ build_check.BC0101.severity=warning
 
 #### Scope of Check
 
-Option `EvaluationCheckScope` with following possible options will be available:
+Option `EvaluationCheckScope` (just `scope` in `.editorconfig`) with following possible options will be available:
 
-| EvaluationCheckScope (Solution Explorer)   | EditorConfig option      |  Behavior  | 
+| EvaluationCheckScope (scope)   | EditorConfig option      |  Behavior  | 
 | ------------- | ------------- |   ------------- |
 | ProjectFileOnly | `project_file` | Only the data from currently checked project will be sent to the check. Imports will be discarded. | 
 | WorkTreeImports | `work_tree_imports` |  Only the data from currently checked project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the check. Other imports will be discarded. |  
 | ProjectWithAllImports | `all` | All data will be sent to the check. | 
 
-All rules of a single check must have the `EvaluationCheckScope` configured to a same value. If any rule from the check have the value configured differently - a warning will be issued during the build and check will be deregistered.
+Same rule can have `EvaluationCheckScope` configured to different values for different projects. If check has multiple rules (this is e.g. case of PropertyUsageCheck rules - [BC0201](Codes.md#bc0201---usage-of-undefined-property), [BC0202](Codes.md#bc0202---property-first-declared-after-it-was-used) and [BC0203](Codes.md#bc0203----property-declared-but-never-used)) - those can have the `EvaluationCheckScope` set to distinct values.
 
-Same rule can have `EvaluationCheckScope` configured to different values for different projects.
+Currently the proper filtering of data is at the discretion of the Check - as the infrastructure might not be able to decide what can be considered in scope (e.g. in case of [BC0203](Codes.md#bc0203----property-declared-but-never-used) - "_Property declared, but never used_" - the property writes (definitions) are scoped, but reads (usages) are not, while [BC0201](Codes.md#bc0201---usage-of-undefined-property) "_Usage of undefined property_" needs to scope reads, but not writes (definitions). Identical input data need to be scoped differently based on the meaning of the Check). 
+
+Some checks might completely ignore the `EvaluationCheckScope` setting - as they can operate on data, that are sourced from build execution (as opposed from build evaluation) and hence the scoping is not possible. This is e.g. case of [BC0102](Codes.md#bc0102---double-writes) "_Double Writes_" check.
 
-BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the check code](#BuildExecutionCheckConfiguration) or from `.editorconfig` file) for an check that has a subscription to unfilterable data - a warning will be issued during the build and check will be deregistered.
 
 #### Configuring evalution scope
 
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index b208653baff..1af3e371ae1 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -4,12 +4,12 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 
 | Diagnostic&nbsp;Code | Default Severity | Reason |
 |:-----|-------|----------|
-| [BC0101](#BC0101) | Warning | Shared output path. |
-| [BC0102](#BC0102) | Warning | Double writes. |
-| [BC0103](#BC0103) | Suggestion | Used environment variable. |
-| [BC0201](#BC0201) | Warning | Usage of undefined property. |
-| [BC0202](#BC0202) | Warning | Property first declared after it was used. |
-| [BC0203](#BC0203) | None | Property declared but never used. |
+| [BC0101](#bc0101---shared-output-path) | Warning | Shared output path. |
+| [BC0102](#bc0102---double-writes) | Warning | Double writes. |
+| [BC0103](#bc0103---used-environment-variable) | Suggestion | Used environment variable. |
+| [BC0201](#bc0201---usage-of-undefined-property) | Warning | Usage of undefined property. |
+| [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Property first declared after it was used. |
+| [BC0203](#bc0203----property-declared-but-never-used) | None | Property declared but never used. |
 
 
 To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview)
@@ -19,7 +19,8 @@ _Cmd:_
 dotnet build -bl -check
 ```
 
-## <a name="BC0101"></a>BC0101 - Shared output path.
+<a name="BC0101"></a>
+## BC0101 - Shared output path.
 
 "Two projects should not share their OutputPath nor IntermediateOutputPath locations"
 
@@ -28,7 +29,8 @@ It is not recommended to share output path nor intermediate output path between
 If you want to produce outputs in a consolidated output folder - consider using the [Artifacts output layout](https://learn.microsoft.com/en-us/dotnet/core/sdk/artifacts-output) and/or [Microsoft.Build.Artifacts SDK](https://github.com/microsoft/MSBuildSdks/tree/main/src/Artifacts).
 
 
-## <a name="BC0102"></a>BC0102 - Double writes.
+<a name="BC0102"></a>
+## BC0102 - Double writes.
 
 "Two tasks should not write the same file"
 
@@ -36,7 +38,8 @@ This is a similar problem as ['BC0101 - Shared output path'](#BC0101) - however
 
 If you want multiple tasks to update file in a one-by-one pipeline fashion, it is recommended to give each intermediate output a distinct name - preventing silent mixups if any of the tasks in the chain are skipped or removed.
 
-## <a name="BC0103"></a>BC0103 - Used environment variable.
+<a name="BC0103"></a>
+## BC0103 - Used environment variable.
 
 "Environment variables should not be used as a value source for the properties"
 
@@ -45,11 +48,12 @@ Relying on environment variables introduces variability and unpredictability, as
 
 This practice can result in inconsistent build outcomes and makes debugging difficult, since environment variables are external to project files and build scripts. To ensure consistent and reproducible builds, avoid using environment variables. Instead, explicitly pass properties using the /p option, which offers better control and traceability.
 
-## <a name="BC0201"></a>BC0201 - Usage of undefined property.
+<a name="BC0201"></a>
+## BC0201 - Usage of undefined property.
 
 "A property that is accessed should be declared first."
 
-This check indicates that a property was acessed without being declared (the declaration might have happen later - see [BC0202](#BC0202) for such checking). Only accessing in the configured scope (by default it's the project file only) are checked.
+This check indicates that a property was accessed without being declared (the declaration might have happen later - see [BC0202](#BC0202) for such checking). Only accessing in the configured scope (by default it's the project file only) are checked.
 
 There are couple cases which are allowed by the check:
 
@@ -59,7 +63,7 @@ There are couple cases which are allowed by the check:
 * Checking the property for emptyness - e.g.:
   `<PropertyGroup Condition="'$(PropertyThatMightNotBeDefined)' == ''">`
 
-* Any usage of property in condition. This can be opted out vie the configuration `AllowUninitializedPropertiesInConditions` - e.g.:
+* Any usage of property in condition. This can be opted out via the configuration `AllowUninitializedPropertiesInConditions` - e.g.:
   ```ini
   [*.csproj]
   build_check.BC0201.severity=error
@@ -69,17 +73,19 @@ There are couple cases which are allowed by the check:
 
   BC0201 and BC0202 must have same value for the optional switch - as both operate on top of same data and same filtering.
 
-## <a name="BC0202"></a>BC0202 - Property first declared after it was used.
+<a name="BC0202"></a>
+## BC0202 - Property first declared after it was used.
 
 "A property should be declared before it is first used."
 
-This check indicates that a property was acessed before it was declared. The default scope of this rule is the project file only. The scope captures the read and write operations as well. So this rule reports:
+This check indicates that a property was accessed before it was declared. The default scope of this rule is the project file only. The scope captures the read and write operations as well. So this rule reports:
  * Uninitialized reads that happened anywhere during the build, while the uninitialized property was later defined within the scope of this check (e.g. project file).
  * Uninitialized reads that happened within the scope of check (e.g. project file), while later defined anywhere in the build
 
 If `BC0202` and [BC0201](#BC0201) are both enabled - then `BC0201` reports only the undefined reads that are not reported by this rule (so those that do not have late definitions).
 
-## <a name="BC0203"></a>BC0203 -  Property declared but never used.
+<a name="BC0203"></a>
+## BC0203 -  Property declared but never used.
 
 "A property that is not used should not be declared."
 
diff --git a/documentation/specs/proposed/Wasm-tasks.md b/documentation/specs/proposed/Wasm-tasks.md
new file mode 100644
index 00000000000..519815bcd66
--- /dev/null
+++ b/documentation/specs/proposed/Wasm-tasks.md
@@ -0,0 +1,354 @@
+# Wasm/WASI tasks in MSBuild
+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.
+
+## Stories 
+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.
+
+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.
+
+## Terminology and context
+-  **WebAssembly (abbreviated Wasm)**
+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)
+
+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.
+    - WASIp1 filesystem, environment variables, stdIO, programs are "Modules"
+    - WASIp2 rich interface data types, networking, programs are "Components"
+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI
+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host
+
+### Diagram of a Wasm execution from a host
+```mermaid 
+flowchart TD
+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]
+
+    A[Engine]  --> E[Linker]
+    
+    E -->|Define host functions & WASI| H[Instance]
+
+    H <---> Mem[Shared Memory]
+    
+    K[Module] -->|Piece of functionality| H
+    
+    L[Store] -->|Config for runtime| H
+    
+    H -->|Invoke module functions| M[Execution]
+
+    subgraph " "
+    A
+    K
+    L
+    end
+
+    subgraph "Single run"
+    H
+    E
+    M
+    Mem
+    end
+
+```
+
+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks
+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.
+
+#### Rust example:
+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)
+3. write your Rust program
+3. `project.csproj`
+```xml
+  <Target Name="CompileAndRun" BeforeTargets="Build">
+    <Exec Command="cargo build --target wasm32-wasi --release --manifest-path='sometask/Cargo.toml'">
+    <Exec Command="wasmtime run path_to_compiled_rust_program.wasm --additional_args_for_wasmtime_enabling_more_than_CPU_and_memory" />
+</Target>
+```
+4. `dotnet build`
+This does not provide an ergonomic way to pass MSBuild parameters to the "task" or get outputs from it.
+
+## Goals for the Wasm tasks feature
+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task
+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task
+3. Demos/examples
+
+### Prototype features
+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)
+- âœ… WasmTask - creating tasks from .wasm files
+    - âœ… Specification for what should this .wasm file export and how it will be ran
+    - âœ… ITaskFactory that let's msbuild use task parameters defined inside the .wasm module
+- âœ… Rust example
+
+#### User Experience
+1. `dotnet new install MSBuildWasm.Templates`
+2. `dotnet new rust.msbuild.task -o new-project-using-rust-task` 
+3. The user Writes a task in Rust based on the template, compiles it to a .wasm module e.g. `cargo b --target wasm32-wasi`
+4. The user adds the task to their .proj file and it runs and logs as if it were a C# task. Template:
+```xml
+<ItemGroup>
+  <PackageReference Include="MSBuildWasm" Version="0.2.0" />
+</ItemGroup>
+
+...
+
+<UsingTask TaskName="FancyWasmTask" 
+           AssemblyFile="$(MSBuildWasmAssembly)" 
+           TaskFactory="WasmTaskFactory" 
+           Condition="$(MSBuildWasmAssembly) != ''">
+  <Task>compiled_task_implementation.wasm</Task>
+</UsingTask>
+
+<Target Name="name">
+  <FancyWasmTask Param="..." Param2="asdf">
+    <Output .../>
+  </FancyWasiTask>
+</Target>
+```
+
+### Advanced features
+- âœ… prototype `MSBuildWasm.Templates` package
+- âŒ ~~.NET example~~ (WASIp1 will not be supported in .NET)
+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust 
+    - [ ] investigate integrating tools compiling languages to Wasm/WASI
+    - On task level
+        - [ ] RustTaskFactory
+        - exploring other languages (Go, C/C++, Zig)
+- investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (ðŸ‘€ Mono runtime)
+    - âŒ Due to the prototype implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2; ecosystem for implementing WasmTasks with WASIp2 is not ready yet
+
+
+## Design
+### diagram
+
+```mermaid
+flowchart TD
+    A[MSBuild] -.->|1. Registering tasks| B[WasmTaskFactory]
+    A -.->|5. Target execution| C[TaskExecutionHost]
+    C -->|6. a. instantiate \n b. set parameters from XML\n c. Execute task| D[WasmTask]
+    H[languages targeting wasi P1] -->|"0. compile using wasi-sdk/cargo"| G
+    D -->|9. properties| C 
+    
+    D -->|7. run module's Execute function| E[wasmtime-dotnet]
+    E -->|8. stdout json \nwith property values| D
+    E <--> F[Wasmtime]
+
+    B -->|4. Create Type for\n the specific WasmTask| D
+    B <-->|3. GetTaskParameters| E
+    G[.wasm module] -->|2. module path via XML| B
+    %%B, C, D%%
+    style A fill:magenta
+    style B fill:#512bd4
+    style C fill:#512bd4
+    style D fill:#512bd4
+```
+MSBuildWasm classes are purple.
+
+
+### Wasm/WASI communication with MSBuild
+Without WASIp2 WIT (which is not yet implemented in wasmtime-dotnet: [issue](https://github.com/bytecodealliance/wasmtime-dotnet/issues/324) ), the only data type that can be a Wasm function parameter and output is a number. MSBuild Tasks have parameters which are of the following types: `string`, `bool`, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.
+
+In the current implementation the .wasm task module has to: 
+-  **import** functions from "module" `msbuild-log`: `LogError(u32 message_ptr, u32 message_len)`, `LogWarning(u32 message_ptr, u32 message_len)`, `LogMessage(u32 MessageImportance, u32 message_ptr, u32 message_len)`. 
+-  **export** functions `GetTaskInfo()`; `Execute() -> u32`, which returns 0 for success and 1 for failure.
+
+### Task parameters 
+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a C# type with corresponding properties.
+Task parameter values are passed into the wasm module as a JSON string in stdin.
+
+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers, the [wit-bindgen](https://github.com/bytecodealliance/wit-bindgen) tool could be used to generate guest language bindings/composite types.
+
+Every resource available to the Wasm/WASI runtime has to be specified explicitly when running the host - Wasmtime is a sandbox by default. WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), 
+The prototype implementation uses the following features:
+It copies items on input to a temporary directory and passes the path to the Wasm module. The module can access these files and write to the directory. Output properties are copied out after the run. StdIn is used for passing parameters and StdOut for getting the output.
+Users can specify in the task usage `Directories="directories on host that can be accessed in addition to the temporary one"`
+- After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.
+WASIp2 defines more host features, but configuring them [is not yet exposed](https://github.com/bytecodealliance/wasmtime/issues/8036#issuecomment-2180272305) in the .NET host API: [WASI docs](https://github.com/WebAssembly/WASI/tree/main/wasip2) e.g. random, networking, clocks.
+
+### Json format for parameter spec
+They mirror MSBuild Task parameters as they need to be reflected to a C# class.
+```jsonc
+{
+    "properties": [
+        {
+            "name": "Param1",
+            "property_type": "String", 
+            "required": true, // Maps to RequiredAttribute in MSBuild
+            "output": false // Maps to OutputAttribute in MSBuild
+        },
+        {
+            "name": "Param2",
+            "property_type": "Bool",
+            "required": false,
+            "output": false
+        },
+        {
+            "name": "Param3",
+            "property_type": "ITaskItem", 
+            "required": false,
+            "output": false
+        },
+        {
+            "name": "Param4",
+            "property_type": "ITaskItemArray",
+            "required": false,
+            "output": true // output means that the parameter is read from the output of the task, but it can be inputted too
+        }
+    ]
+}
+```
+### Json format for parameter values
+```jsonc
+{
+    "Param1": "hello",
+    "Param2": true,
+    "Param3": {
+        "ItemSpec": "C:\\real\\path\\file.txt",
+        "WasmPath": "file.txt", // guest runtime path
+        "More .NET metadata": "..."
+    },
+    "Param4": [
+        {
+            "ItemSpec": "item1",
+            "Metadata1": "value1"
+        },
+        {
+            "ItemSpec": "item2",
+            "Metadata2": "value2"
+        }
+    ]
+}
+```
+
+### Json format for task output
+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.
+```jsonc
+{
+    "Param4": [
+        {
+            "ItemSpec": "also/can/be/dir",
+            "WasmPath": "also/can/be/dir"
+        },
+        {
+            "ItemSpec": "name_in_host.txt",
+            "WasmPath": "item.txt"
+        }
+    ]
+}
+```
+
+
+### Testing
+#### Unit tests
+- [ ] setting parameters in the task
+- [ ] parsing outputs
+- [ ] examples contain expected functions
+
+#### E2E tests
+- Using Wasm/WASI Tasks in a build
+- [ ] Rust tasks
+    - [ ] logging
+    - [x] passing parameters
+    - [x] accessing files
+
+
+## Implementation details
+### wasmtime-dotnet bindings and basic usage
+```csharp
+using var engine = new Engine();
+using var module = Module.FromFile(engine, WasmFilePath);
+using var linker = new Linker(engine);
+linker.DefineWasi(); // linking WASI
+linker.Define("namespace", "function", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm
+using var store = new Store(engine);
+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO 
+store.SetWasiConfiguration(wasiConfigBuilder);
+Instance instance = linker.Instantiate(store, module);
+Action fn = instance.GetAction("Execute");
+fn.Invoke();
+```
+
+
+## Development remarks
+
+### Architectural decision record
+- **Inside MSBuild or as an external package?**
+    - the feature seems largely independent
+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*
+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*
+
+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**
+    - customizableðŸ‘
+    - hard to maintainðŸ‘Ž, wasi is changing
+    - lot of work ðŸ‘Ž
+    - *-> resolved to use wasmtime*
+    - Choosing Wasm/WASI runtime 
+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.
+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.
+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).
+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other .NET projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API
+
+- **bundling wasm runtime with MSBuild?**
+    - compatibilityðŸ‘
+    - ease of use ðŸ‘
+    - sizeðŸ‘Ž
+    - maintenanceðŸ‘Ž
+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*
+
+- **Interacting with the tooling for creating .wasi files from other languages?**
+    - hard, unstable
+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*
+
+- **start with windows or UNIX?**
+    - *-> most different is the investigation about how to bundle tooling for other languages*
+
+- **renaming this feature from WASI-... to Wasm-...**
+    - file extensions are called .wasm ðŸ‘
+    - WASI is a standard building on Wasm ðŸ‘
+    - the compilation target is called wasm-wasi ðŸ‘ðŸ‘Ž
+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*
+
+- **communication between host and a wasm module**
+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO 
+    - eventually with Wasm/WASI component model better data-structures  
+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) 
+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279
+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*
+        - JSON is a suitable format because we pass: lists, dicts strings and bools; and [`serde`](https://serde.rs/) in Rust enables ergonomic serialization to/from data structures
+     
+- **TaskExecutionHost?**
+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, 
+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost
+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet
+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*
+
+### Related projects
+
+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - consortium, where Microsoft is a member 
+
+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#, via the C API, maintained by *Bytecode Alliance*
+
+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a WASI component from a C#.NET project using NativeAOT-LLVM, experimental release June 2024, created by people from Microsoft, the prototype can't use it because components are different from modules and we can't switch because wasmtime-dotnet does not support components.
+
+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) 
+- compile dotnet to Wasm
+- moved to sdk and runtime repos `dotnet workload install wasi-experimental` in .NET 8.0 
+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)
+    - it does not support function exports and imports to the extent needed for prototype implementation
+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2
+
+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)
+
+### Random
+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually [PR](https://github.com/bytecodealliance/wasmtime-dotnet/pull/320)
+
+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports [issue](https://github.com/golang/go/issues/65199). .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks via Mono but in preview 7 it changed to target WASIp2 and it won't come back [PR](https://github.com/dotnet/runtime/pull/104683).
+
+### Conclusion and Future work
+State of the Wasm/WASI ecosystem does not enable implementing a robust useful solution right now (August 2024), in terms of functionality [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) is close to what is ergonomically possible using WASIp1 modules.
+To get the sandboxing benefit of using WASI runtimes, several things need to happen first:
+- wasmtime C API to support WASIp2 components and better granularity for giving access to resources in the guest. 
+- wasmtime-dotnet has to implement bindings to the updated C API 
+- an easy way to convert WIT to C# host bindings (wit-bindgen only handles guest bindings)
+- figure out what MSBuild context do we want to pass (now it's just the logging functions)
+- less experimental Mono WASIp2 support
+- make a component for executing .NET tasks
+
+To get the multilanguage task authoring benefit:
+- Other languages have to implement the component model and an easy workflow to compile library components
\ No newline at end of file
diff --git a/documentation/specs/proposed/wasmtask.wit b/documentation/specs/proposed/wasmtask.wit
new file mode 100644
index 00000000000..97db65fbc14
--- /dev/null
+++ b/documentation/specs/proposed/wasmtask.wit
@@ -0,0 +1,88 @@
+ï»¿package msbuild:wasm-task;
+
+// Callbacks with logs from the task to the MSBuild logging system
+interface host-logger {
+    enum message-importance {
+        high, 
+        normal,
+        low
+    }
+
+    log-message: func(importance: message-importance, message: string);
+    log-warning: func(message: string);
+    log-error: func(message: string);
+}
+
+// Describes the task's interface to MSBuild
+world wasm-task {
+    // wit doesn't have maps/dictionaries
+    record string-kv-pair {
+        key: string,
+        value: string
+    }
+    type string-map = list<string-kv-pair>;
+
+    // Mirroring TaskItem in MSBuild - it's a description of a file or directory
+    record task-item { 
+        // Path inside the sandbox
+        wasm-path: string,
+        metadata: string-map
+    }
+    // Enum for types of properties in tasks
+    enum property-type {
+        bool-type,
+        string-type,
+        task-item-type,
+        bool-array-type,
+        string-array-type,
+        task-item-array-type
+    }
+
+    // Variant contains one of the possible types of properties
+    variant property-value {
+        bool-value(bool),
+        string-value(string),
+        task-item(task-item),
+        bool-array(bool-list),
+        string-array(string-list),
+        task-item-array(task-item-list)
+    }
+
+    type task-item-list = list<task-item>;
+    type bool-list = list<bool>;
+    type string-list = list<string>;
+
+    // Mirrors MSBuild's TaskPropertyInfo
+    record task-property-info {
+        name: string,
+        proptype: property-type,
+        output: bool,
+        required: bool
+    }
+
+    // Information about a task passed from the task to MSBuild
+    record task-info {
+        name: string,
+        parameters: list<task-property-info>,
+        metadata: string-map // E.g., requirements for the host environment
+    }
+
+    // Information about the host environment passed from MSBuild to the task
+    record host-info {
+        preopened-directories: task-item-list
+    }
+
+    // Input to execute 
+    // (In MSBuild, normally the task already magically has set its properties to the values from the project file, but here we need to pass them)
+    record task-input {
+        host-info: host-info,
+        properties: list<property-value>
+    }
+
+    // Host obtains information about the task to know what properties to read from the project file and pass in
+    export get-task-info: func() -> task-info;
+    // Execute is the entry point for the task, returns success
+    export execute: func(input: task-input) -> bool;
+    // Task should call host-logger functions to log messages
+    import host-logger;
+}
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index d9bb101159f..100f45c363a 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -82,6 +82,16 @@ It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` obj
  * https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
  * https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BuildEventArgsReader.cs
 
+## Meaning of various Ids in the BuildEventArgs
+
+The [`BuildEventArgs`](https://github.com/dotnet/msbuild/blob/main/src/Framework/BuildEventArgs.cs) sent to the loggers (and later stored in the binlog) can have [`BuildEventContext`](https://github.com/dotnet/msbuild/blob/main/src/Framework/BuildEventContext.cs) attached. This context contains multiple integer Ids, that can be of interest for the consumer:
+* `ProjectInstanceId` - This indicates unique combination of a project and global properties (basically a project configuration for a build.). The same combination dictates a need for evaluation (or possibility to reuse existing) - so the id correlates with `EvaluationId`. `ProjectInstanceId` is however not present on evaluation events.
+* `EvaluationId` - Indicates unique evaluation run - that needs to happen for each unique combination of project and global properties. `EvaluationId` is present on all evaluation time events and on the `ProjectStartedEventArgs` (this event can be used to correlate the `EvaluationId` with `ProjectInstanceId` - to get all build execution time events that used a specific evaluation).
+* `ProjectContextId` - This indicates unique build request (so request for result from project + target(s) combination). There can be multiple build requests using the same evaluation - so a single `ProjectInstanceId` (and `EvaluationId`) often maps to multiple `ProjectContextId`s
+* `NodeId` - indicates the node where the event was generated ('0' for the SchedulerNode with possible in-proc execution node, positive ids for the out-of-proc execution nodes). The whole evaluation happens on a single node - so all evaluation time events with single `EvaluationId` have same `NodeId`. Execution is attempted to be performed on a node which evaluated ('evaluation affinity') - so usually all events with corresponding `EvaluationId` and `InstanceId` have the same `NodeId`. But evaluation results are transferable between nodes (it's `Translatable`) so evaluation events and build events `NodeId` doesn't have to match. Single build execution happens on the same node - so all events with same `ProjectContextId` have same `NodeId`. Though multiple build executions can be interleaved on a same node (due to 'Yielding' - either voluntarily explicitly called by the Task, or implicitly enforced by `RequestBuilder`).
+
+It's also good to note that those Ids can have negative values - indicating uninitialized value (this can be expected in many cases - e.g. evaluation time events cannot have `ProjectContextId` as they are not tied to single result request; or `ProjectInstanceId` are not ever populated on evaluation time events).
+
 ## Incrementing the file format
 
 Every .binlog file has the first four bytes that indicate the file version. The current file format is indicated in [`BinaryLogger.cs`](/src/Build/Logging/BinaryLogger/BinaryLogger.cs).
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index ef38fa5942e..9d90c75075e 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -28,6 +28,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
 - [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
 - [Add ParameterName and PropertyName to TaskParameterEventArgs](https://github.com/dotnet/msbuild/pull/10130)
+- [Emit eval props if requested by any sink](https://github.com/dotnet/msbuild/pull/10243)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 1d81e8ac1aa..1d65cf6b471 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -82,7 +82,7 @@ public BuildManager_Tests(ITestOutputHelper output)
                 EnableNodeReuse = false
             };
             _buildManager = new BuildManager();
-            _projectCollection = new ProjectCollection();
+            _projectCollection = new ProjectCollection(globalProperties: null, _parameters.Loggers, ToolsetDefinitionLocations.Default);
 
             _env = TestEnvironment.Create(output);
             _inProcEnvCheckTransientEnvironmentVariable = _env.SetEnvironmentVariable("MSBUILDINPROCENVCHECK", "1");
@@ -137,8 +137,8 @@ public void SimpleBuild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -254,8 +254,8 @@ public void SimpleGraphBuild()
             _logger.AssertLogContains("[success]");
             _logger.ProjectStartedEvents.Count.ShouldBe(1);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             properties.TryGetValue("InitialProperty1", out string propertyValue).ShouldBeTrue();
             propertyValue.ShouldBe("InitialProperty1", StringCompareShould.IgnoreCase);
@@ -571,8 +571,8 @@ public void InProcForwardPropertiesFromChild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -611,8 +611,8 @@ public void InProcMsBuildForwardAllPropertiesFromChild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -655,8 +655,8 @@ public void MsBuildForwardAllPropertiesFromChildLaunchChildNode()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -704,7 +704,15 @@ public void OutOfProcNodeForwardCertainproperties()
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, Array.Empty<string>(), null);
 
-            BuildResult result = _buildManager.Build(_parameters, data);
+            // We need to recreate build parameters to ensure proper capturing of newly set environment variables
+            BuildParameters parameters = new BuildParameters
+            {
+                ShutdownInProcNodeOnBuildFinish = true,
+                Loggers = new ILogger[] { _logger },
+                EnableNodeReuse = false
+            };
+
+            BuildResult result = _buildManager.Build(parameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
@@ -760,11 +768,21 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
             _env.SetEnvironmentVariable("MsBuildForwardPropertiesFromChild", "InitialProperty3;IAMNOTREAL");
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
+            _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "0");
+
             var project = CreateProject(contents, null, _projectCollection, false);
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, Array.Empty<string>(), null);
 
-            BuildResult result = _buildManager.Build(_parameters, data);
+            // We need to recreate build parameters to ensure proper capturing of newly set environment variables
+            BuildParameters parameters = new BuildParameters
+            {
+                ShutdownInProcNodeOnBuildFinish = true,
+                Loggers = new ILogger[] { _logger },
+                EnableNodeReuse = false
+            };
+
+            BuildResult result = _buildManager.Build(parameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
             _logger.AssertLogContains("[success]");
             Assert.Equal(3, _logger.ProjectStartedEvents.Count);
@@ -785,7 +803,8 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
             Assert.Equal("InitialProperty3", propertyValue);
 
             projectStartedEvent = _logger.ProjectStartedEvents[2];
-            Assert.Null(projectStartedEvent.Properties);
+            properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            (properties == null || properties.Count == 0).ShouldBeTrue();
         }
 
         /// <summary>
@@ -822,7 +841,7 @@ public void ForwardNoPropertiesLaunchChildNode()
 
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
-            Assert.Null(properties);
+            (properties == null || properties.Count == 0).ShouldBeTrue();
         }
 
         /// <summary>
@@ -919,7 +938,7 @@ public void ForwardNoPropertiesLaunchChildNodeDefault()
 
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
-            Assert.Null(properties);
+            (properties == null || properties.Count == 0).ShouldBeTrue();
         }
 
         /// <summary>
@@ -3475,9 +3494,11 @@ private static string BuildAndCheckCache(BuildManager localBuildManager, IEnumer
         /// </summary>
         private static Dictionary<string, string> ExtractProjectStartedPropertyList(IEnumerable properties)
         {
-            // Gather a sorted list of all the properties.
-            return properties?.Cast<DictionaryEntry>()
-                .ToDictionary(prop => (string)prop.Key, prop => (string)prop.Value, StringComparer.OrdinalIgnoreCase);
+            Dictionary<string, string> propertiesLookup = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            Internal.Utilities.EnumerateProperties(properties, propertiesLookup,
+                static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
+
+            return propertiesLookup;
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index e829d9f4384..e19d7fbec5b 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -222,14 +222,21 @@ public bool IncludeEvaluationProfile
             set { }
         }
 
-        /// <summary>
-        /// Log properties and items on ProjectEvaluationFinishedEventArgs
-        /// instead of ProjectStartedEventArgs.
-        /// </summary>
-        public bool IncludeEvaluationPropertiesAndItems
+        /// <inheritdoc cref="ILoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents"/>
+        public void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent,
+            bool inEvaluationFinishedEvent)
+        { }
+
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
+        {
+            get => false;
+        }
+
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
         {
             get => false;
-            set { }
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 10859bb9ce5..c1fdc67f6a5 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -277,7 +277,7 @@ public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPr
 
             if (includeEvaluationPropertiesAndItems)
             {
-                pc.Collection.LoggingService.IncludeEvaluationPropertiesAndItems = true;
+                pc.Collection.LoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents(inProjectStartedEvent: false, inEvaluationFinishedEvent: true);
             }
 
             var project = env.CreateTestProjectWithFiles(@"
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 52c61ccc9ab..ffd2b33a2ed 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2771,7 +2771,8 @@ private NodeConfiguration GetNodeConfiguration()
                 , new LoggingNodeConfiguration(
                     loggingService.IncludeEvaluationMetaprojects,
                     loggingService.IncludeEvaluationProfile,
-                    loggingService.IncludeEvaluationPropertiesAndItems,
+                    loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent,
+                    loggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent,
                     loggingService.IncludeTaskInputs));
             }
 
@@ -3279,25 +3280,19 @@ public string? Parameters
             /// </summary>
             public void Initialize(IEventSource eventSource)
             {
-                // The concrete type we get should always be our internal
-                // implementation and up-to-date, but we need to meet the
-                // external contract so can't specify that for the
-                // argument.
-
-                IEventSource4 eventSource4 = (IEventSource4)eventSource;
-
                 // Most checks in LoggingService are "does any attached logger
                 // specifically opt into this new behavior?". As such, the
                 // NullLogger shouldn't opt into them explicitly and should
                 // let other loggers opt in.
 
-                // IncludeEvaluationPropertiesAndItems is different though,
-                // because its check is "do ALL attached loggers opt into
-                // the new behavior?", since the new behavior removes
-                // information from old loggers. So the NullLogger must
-                // opt in to ensure it doesn't accidentally veto the new
-                // behavior.
-                eventSource4.IncludeEvaluationPropertiesAndItems();
+                // IncludeEvaluationPropertiesAndItems was different,
+                // because it checked "do ALL attached loggers opt into
+                // the new behavior?".
+                // It was fixed and hence we need to be careful not to opt in
+                // the behavior as it was done before - but let the other loggers choose.
+                //
+                // For this reason NullLogger MUST NOT call
+                // ((IEventSource4)eventSource).IncludeEvaluationPropertiesAndItems();
             }
 
             /// <summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index e96185fc640..1dba5f10f78 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -202,6 +202,16 @@ public override BuildResult Execute()
             return BuildResult!;
         }
 
+        /// <summary>
+        /// Whether the build has started.
+        /// </summary>
+        internal override bool IsStarted
+        {
+            get => BuildRequest != null;
+            // Ignore the set - the submission is started once the BuildRequest is set.
+            set { }
+        }
+
         protected internal override BuildResult CreateFailedResult(Exception exception)
         {
             ErrorUtilities.VerifyThrow(BuildRequest != null,
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
index ba6f45afc09..1cf4819c51d 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
@@ -77,7 +77,7 @@ protected internal BuildSubmissionBase(BuildManager buildManager, int submission
         /// <summary>
         /// Whether the build has started.
         /// </summary>
-        internal bool IsStarted { get; set; }
+        internal abstract bool IsStarted { get; set; }
 
         /// <summary>
         /// Indicates that all logging events for this submission are complete.
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index ecbf7b8026b..104dac56f6f 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -206,12 +206,24 @@ bool IncludeEvaluationProfile
 
         /// <summary>
         /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
-        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// or/and <see cref="ProjectStartedEventArgs"/>?
         /// </summary>
-        bool IncludeEvaluationPropertiesAndItems
+        void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent, bool inEvaluationFinishedEvent);
+
+        /// <summary>
+        /// Indicates whether properties and items should be logged on <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
+        {
+            get;
+        }
+
+        /// <summary>
+        /// Indicates whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>.
+        /// </summary>
+        bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
         {
             get;
-            set;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 9a6df6ce995..df990251a96 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -201,12 +201,6 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// </summary>
         private bool? _includeEvaluationProfile;
 
-        /// <summary>
-        /// Whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
-        /// instead of <see cref="ProjectStartedEventArgs"/>.
-        /// </summary>
-        private bool? _includeEvaluationPropertiesAndItems;
-
         /// <summary>
         /// Whether to include task inputs in task events.
         /// </summary>
@@ -546,33 +540,77 @@ public bool IncludeTaskInputs
             set => _includeTaskInputs = value;
         }
 
-        /// <summary>
-        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
-        /// instead of <see cref="ProjectStartedEventArgs"/>?
-        /// </summary>
-        public bool IncludeEvaluationPropertiesAndItems
+        /// <inheritdoc cref="ILoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents"/>
+        public void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent, bool inEvaluationFinishedEvent)
         {
-            get
+            _evalDataBehaviorSet = true;
+            IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = inEvaluationFinishedEvent;
+            IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = inProjectStartedEvent;
+        }
+
+        private bool _evalDataBehaviorSet;
+        private bool _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+        private bool _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
+        private void InferEvalDataBehavior()
+        {
+            if (_evalDataBehaviorSet)
             {
-                if (_includeEvaluationPropertiesAndItems == null)
+                return;
+            }
+            // Set this right away - to prevent SO exception in case of any future refactoring
+            //  that would refer to the IncludeEvaluation... properties here
+            _evalDataBehaviorSet = true;
+
+            bool? escapeHatch = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation;
+            if (escapeHatch.HasValue)
+            {
+                IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = escapeHatch.Value;
+                IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = !escapeHatch.Value;
+            }
+            else
+            {
+                var sinks = _eventSinkDictionary.Values.OfType<EventSourceSink>().ToList();
+
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
                 {
-                    var escapeHatch = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation;
-                    if (escapeHatch.HasValue)
-                    {
-                        _includeEvaluationPropertiesAndItems = escapeHatch.Value;
-                    }
-                    else
-                    {
-                        var sinks = _eventSinkDictionary.Values.OfType<EventSourceSink>();
-                        // .All() on an empty list defaults to true, we want to default to false
-                        _includeEvaluationPropertiesAndItems = sinks.Any() && sinks.All(sink => sink.IncludeEvaluationPropertiesAndItems);
-                    }
+                    // If any logger requested the data - we need to emit them
+                    IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent =
+                        sinks.Any(sink => sink.IncludeEvaluationPropertiesAndItems);
+                    // If any logger didn't request the data - hence it's likely legacy logger
+                    //  - we need to populate the data in legacy way
+                    IncludeEvaluationPropertiesAndItemsInProjectStartedEvent =
+                        sinks.Any(sink => !sink.IncludeEvaluationPropertiesAndItems);
                 }
+                else
+                {
+                    bool allSinksIncludeEvalData = sinks.Any() && sinks.All(sink => sink.IncludeEvaluationPropertiesAndItems);
 
-                return _includeEvaluationPropertiesAndItems ?? false;
+                    IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = allSinksIncludeEvalData;
+                    IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = !allSinksIncludeEvalData;
+                }
             }
+        }
 
-            set => _includeEvaluationPropertiesAndItems = value;
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
+        {
+            get
+            {
+                InferEvalDataBehavior();
+                return _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+            }
+            private set => _includeEvaluationPropertiesAndItemsInProjectStartedEvent = value;
+        }
+
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
+        {
+            get
+            {
+                InferEvalDataBehavior();
+                return _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
+            }
+            private set => _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = value;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 49a3cd48fb7..06614c42125 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -132,7 +132,7 @@ private static BuildEventContext CreateInitialContext(
 
             // If we are only logging critical events lets not pass back the items or properties
             if (!loggingService.OnlyLogCriticalEvents &&
-                !loggingService.IncludeEvaluationPropertiesAndItems &&
+                loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent &&
                 (!loggingService.RunningOnRemoteNode || loggingService.SerializeAllProperties))
             {
                 if (projectProperties is null)
@@ -152,7 +152,7 @@ private static BuildEventContext CreateInitialContext(
             }
 
             if (projectProperties != null &&
-                !loggingService.IncludeEvaluationPropertiesAndItems &&
+                loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent &&
                 propertiesToSerialize?.Length > 0 &&
                 !loggingService.SerializeAllProperties)
             {
diff --git a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
index 1bae5efa98b..8c6315338da 100644
--- a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
@@ -9,12 +9,14 @@ internal sealed class LoggingNodeConfiguration : ITranslatable
     {
         private bool _includeEvaluationMetaprojects;
         private bool _includeEvaluationProfiles;
-        private bool _includeEvaluationPropertiesAndItems;
+        private bool _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+        private bool _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
         private bool _includeTaskInputs;
 
         public bool IncludeEvaluationMetaprojects => _includeEvaluationMetaprojects;
         public bool IncludeEvaluationProfiles => _includeEvaluationProfiles;
-        public bool IncludeEvaluationPropertiesAndItems => _includeEvaluationPropertiesAndItems;
+        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent => _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent => _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
         public bool IncludeTaskInputs => _includeTaskInputs;
 
         public LoggingNodeConfiguration()
@@ -24,12 +26,14 @@ public LoggingNodeConfiguration()
         public LoggingNodeConfiguration(
             bool includeEvaluationMetaprojects,
             bool includeEvaluationProfiles,
-            bool includeEvaluationPropertiesAndItems,
+            bool includeEvaluationPropertiesAndItemsInProjectStartedEvent,
+            bool includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent,
             bool includeTaskInputs)
         {
             _includeEvaluationMetaprojects = includeEvaluationMetaprojects;
             _includeEvaluationProfiles = includeEvaluationProfiles;
-            _includeEvaluationPropertiesAndItems = includeEvaluationPropertiesAndItems;
+            _includeEvaluationPropertiesAndItemsInProjectStartedEvent = includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+            _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
             _includeTaskInputs = includeTaskInputs;
         }
 
@@ -37,7 +41,8 @@ void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _includeEvaluationMetaprojects);
             translator.Translate(ref _includeEvaluationProfiles);
-            translator.Translate(ref _includeEvaluationPropertiesAndItems);
+            translator.Translate(ref _includeEvaluationPropertiesAndItemsInProjectStartedEvent);
+            translator.Translate(ref _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent);
             translator.Translate(ref _includeTaskInputs);
         }
     }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 14706fc57cd..af13beb079d 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -779,9 +779,12 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
                 _loggingService.IncludeTaskInputs = true;
             }
 
-            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItems)
+            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent)
             {
-                _loggingService.IncludeEvaluationPropertiesAndItems = true;
+                _loggingService.SetIncludeEvaluationPropertiesAndItemsInEvents(
+                    configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent,
+                    configuration.LoggingNodeConfiguration
+                        .IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent);
             }
 
             try
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 7f76541d134..ac8d2f5c00c 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -275,14 +275,6 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
                 // Update the wrapper
                 wrapper.StartNewProject(projectFullPath, configurations);
             }
-
-            if (configurations.GroupBy(c => c.EvaluationCheckScope).Count() > 1)
-            {
-                throw new BuildCheckConfigurationException(
-                    string.Format("All rules for a single check should have the same EvaluationCheckScope for a single project (violating rules: [{0}], project: {1})",
-                        checkFactoryContext.RuleIds.ToCsvString(),
-                        projectFullPath));
-            }
         }
 
         private void SetupChecksForNewProject(string projectFullPath, ICheckContext checkContext)
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 064ea77a49d..7e400d10138 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -343,7 +343,7 @@ internal static void Evaluate(
                 IEnumerable properties = null;
                 IEnumerable items = null;
 
-                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
+                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent)
                 {
                     globalProperties = evaluator._data.GlobalPropertiesDictionary;
                     properties = Traits.LogAllEnvironmentVariables ? evaluator._data.Properties : evaluator.FilterOutEnvironmentDerivedProperties(evaluator._data.Properties);
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index 270134614f5..164cfc8e377 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -71,6 +71,11 @@ protected internal override void CheckResultValidForCompletion(GraphBuildResult
         protected internal override GraphBuildResult CreateFailedResult(Exception exception)
             => new(SubmissionId, exception);
 
+        /// <summary>
+        /// Whether the build has started.
+        /// </summary>
+        internal override bool IsStarted { get; set; }
+
         // WARNING!: Do not remove the below proxy properties.
         //  They are required to make the OM forward compatible
         //  (code built against this OM should run against binaries with previous version of OM).
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 2ccc4a88c32..1237dcf131f 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -38,49 +38,29 @@ public EndToEndTests(ITestOutputHelper output)
 
     public void Dispose() => _env.Dispose();
 
-    [Fact]
-    public void PropertiesUsageAnalyzerTest()
+    [Theory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void PropertiesUsageAnalyzerTest(bool buildInOutOfProcessNode)
     {
-        using TestEnvironment env = TestEnvironment.Create();
-        string contents = """
-                              <Project DefaultTargets="PrintEnvVar">
-
-                              <!-- MyProp4 is not defined - but it's checked against empty - which is allowed -->
-                              <PropertyGroup Condition="'$(MyProp4)' == ''">
-                                <!-- MyProp3 defined here - but not used anywhere -->
-                                <!-- MyProp1 used here - but not defined -->
-                                <MyProp3>$(MyProp1)</MyProp3>
-                              </PropertyGroup>
-
-
-                              <Target Name="PrintEnvVar">
-                                  <!-- MyProp2 used here - but defined later -->
-                                  <Message Text="MyProp2 has value $(MyProp2)" Importance="High" Condition="'$(MyProp2)' == ''" />
-                                  <PropertyGroup>
-                                    <MyProp2>$(MyProp2);xxx</MyProp2>
-                                  </PropertyGroup>
-                              </Target>
-
-                              </Project>
-                              """;
-        TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
-        TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
-
-        string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check /v:detailed", out bool success);
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode,
+            out TransientTestFile projectFile,
+            "PropsCheckTest.csproj");
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check", out bool success);
         _env.Output.WriteLine(output);
         _env.Output.WriteLine("=========================");
         success.ShouldBeTrue(output);
 
-        output.ShouldMatch(@"BC0201: .* Property: \[MyProp1\]");
-        output.ShouldMatch(@"BC0202: .* Property: \[MyProp2\]");
-        // since it's just suggestion, it doesn't have a colon ':'
-        output.ShouldMatch(@"BC0203 .* Property: \[MyProp3\]");
+        output.ShouldMatch(@"BC0201: .* Property: \[MyProp11\]");
+        output.ShouldMatch(@"BC0202: .* Property: \[MyPropT2\]");
+        output.ShouldMatch(@"BC0203: .* Property: \[MyProp13\]");
 
         // each finding should be found just once - but reported twice, due to summary
         Regex.Matches(output, "BC0201: .* Property").Count.ShouldBe(2);
         Regex.Matches(output, "BC0202: .* Property").Count.ShouldBe(2);
-        // since it's not an error - it's not in summary
-        Regex.Matches(output, "BC0203 .* Property").Count.ShouldBe(1);
+        Regex.Matches(output, "BC0203 .* Property").Count.ShouldBe(2);
     }
 
     [Theory]
@@ -420,20 +400,23 @@ private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attribut
     private void PrepareSampleProjectsAndConfig(
         bool buildInOutOfProcessNode,
         out TransientTestFile projectFile,
-        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        string entryProjectAssetName,
+        IEnumerable<string>? supplementalAssetNames = null,
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity = null,
         IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig = null)
     {
         string testAssetsFolderName = "SampleCheckIntegrationTest";
         TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
         TransientTestFile testFile = _env.CreateFile(workFolder, "somefile");
 
-        string contents = ReadAndAdjustProjectContent("Project1");
-        string contents2 = ReadAndAdjustProjectContent("Project2");
-        string contentsImported = ReadAndAdjustProjectContent("ImportedFile1");
+        string contents = ReadAndAdjustProjectContent(entryProjectAssetName);
+        projectFile = _env.CreateFile(workFolder, entryProjectAssetName, contents);
 
-        projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
-        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
-        TransientTestFile importedFile1 = _env.CreateFile(workFolder, "ImportedFile1.props", contentsImported);
+        foreach (string supplementalAssetName in supplementalAssetNames ?? Enumerable.Empty<string>())
+        {
+            string supplementalContent = ReadAndAdjustProjectContent(supplementalAssetName);
+            TransientTestFile supplementalFile = _env.CreateFile(workFolder, supplementalAssetName, supplementalContent);
+        }
 
         _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, ruleToCustomConfig, testAssetsFolderName));
 
@@ -454,6 +437,19 @@ string ReadAndAdjustProjectContent(string fileName) =>
                 .Replace("WorkFolderPath", workFolder.Path);
     }
 
+    private void PrepareSampleProjectsAndConfig(
+        bool buildInOutOfProcessNode,
+        out TransientTestFile projectFile,
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig = null)
+        => PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode,
+            out projectFile,
+            "Project1.csproj",
+            new[] { "Project2.csproj", "ImportedFile1.props" },
+            ruleToSeverity,
+            ruleToCustomConfig);
+
     private string ReadEditorConfig(
         IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
         IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig,
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
index 57d36981808..9b63ef6a700 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
@@ -11,3 +11,7 @@ build_check.BC0103.CustomConfig=dummy
 build_check.COND0543.Severity=Error
 build_check.COND0543.EvaluationCheckScope=CheckedProjectOnly
 build_check.COND0543.CustomSwitch=QWERTY
+
+build_check.BC0201.Severity=warning
+build_check.BC0202.Severity=warning
+build_check.BC0203.Severity=warning
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1.props
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1.props
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
similarity index 92%
rename from src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
index 4412879248c..918173e191c 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
@@ -16,7 +16,7 @@
    <Target Name="Hello">
        <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
        <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
-       <MSBuild Projects=".\FooBar-Copy.csproj" Targets="Hello" />
+       <MSBuild Projects=".\Project2.csproj" Targets="Hello" />
 
        <PropertyGroup>
          <ReadFromEnvVariable>$(TEST)</ReadFromEnvVariable>
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2.csproj
similarity index 91%
rename from src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2.csproj
index 17b8d3da249..b8355528363 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2.csproj
@@ -11,7 +11,7 @@
     </PropertyGroup>
                     
     <ItemGroup>
-        <Reference Include="bin/foo.dll" />
+        <Reference Include="bin/Project1.dll" />
     </ItemGroup>
                     
     <Target Name="Hello">
@@ -19,4 +19,4 @@
         <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
     </Target>
                    
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj
new file mode 100644
index 00000000000..4e5bb2af0e3
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj
@@ -0,0 +1,26 @@
+<Project DefaultTargets="PrintEnvVar">
+    <PropertyGroup>
+        <!--
+        <MyProp1>value-of-prop1</MyProp1>
+        <MyProp2>$(MyProp1)</MyProp2>
+        <MyProp3>blah</MyProp3>
+        -->
+    </PropertyGroup>
+
+    <PropertyGroup Condition="'$(MyProp12)' == ''">
+        <MyProp13>$(MyProp11)</MyProp13>
+    </PropertyGroup>
+
+    <!--
+        <ItemGroup>
+        <a Include="$(nonexistent)" />
+        </ItemGroup>
+    -->
+
+    <Target Name="PrintEnvVar">
+        <Message Text="MyPropT2 has value $(MyPropT2)" Importance="High" Condition="'$(MyPropT2)' == ''" />
+        <PropertyGroup>
+            <MyPropT2>$(MyPropT2);xxx</MyPropT2>
+        </PropertyGroup>
+    </Target>
+</Project>
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 67bacf49a74..7eb7895b2df 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -50,30 +50,6 @@ public void EventArgsCtors()
             projectStartedEvent = new ProjectStartedEventArgs(1, null, null, null, null, null, null, null, DateTime.Now);
         }
 
-        /// <summary>
-        /// Verify different Items and properties are not taken into account in the equals comparison. They should
-        /// not be considered as part of the equals evaluation
-        /// </summary>
-        [Fact]
-        public void ItemsAndPropertiesDifferentEquals()
-        {
-            ArrayList itemsList = new ArrayList();
-            ArrayList propertiesList = new ArrayList();
-            ProjectStartedEventArgs differentItemsAndProperties = new ProjectStartedEventArgs(
-                  s_baseProjectStartedEvent.ProjectId,
-                  s_baseProjectStartedEvent.Message,
-                  s_baseProjectStartedEvent.HelpKeyword,
-                  s_baseProjectStartedEvent.ProjectFile,
-                  s_baseProjectStartedEvent.TargetNames,
-                  propertiesList,
-                  itemsList,
-                  s_baseProjectStartedEvent.ParentProjectBuildEventContext,
-                  s_baseProjectStartedEvent.Timestamp);
-
-            s_baseProjectStartedEvent.Properties.ShouldNotBe(propertiesList);
-            s_baseProjectStartedEvent.Items.ShouldNotBe(itemsList);
-        }
-
         /// <summary>
         /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index cc9d14af45a..4636850306a 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using System.Runtime.Serialization;
@@ -249,7 +250,9 @@ public IDictionary<string, string>? GlobalProperties
         {
             get
             {
-                return globalProperties;
+                return globalProperties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                    ? ImmutableDictionary<string, string>.Empty
+                    : null);
             }
 
             internal set
@@ -298,7 +301,9 @@ public IEnumerable? Properties
                 // up the live list of properties from the loaded project, which is stored in the configuration as well.
                 // By doing this, we no longer need to transmit properties using this message because they've already
                 // been transmitted as part of the BuildRequestConfiguration.
-                return properties;
+                return properties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                    ? Enumerable.Empty<DictionaryEntry>()
+                    : null);
             }
         }
 
@@ -322,7 +327,9 @@ public IEnumerable? Items
                 // case, this access is to the live list.  For the central logger in the multi-proc case, the main node
                 // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
-                return items;
+                return items ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                    ? Enumerable.Empty<DictionaryEntry>()
+                    : null);
             }
         }
 
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index 08353749def..afd777eef97 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -41,6 +41,12 @@ public MSBuildTestAssemblyFixture()
             var runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
             runningTestsField.SetValue(null, true);
 
+            // Set the field in BuildEnvironmentState - as it might have been already preintialized by the data preparation of data driven tests
+            testInfoType = frameworkAssembly.GetType("Microsoft.Build.Framework.BuildEnvironmentState");
+            runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
+            runningTestsField.SetValue(null, true);
+            
+
             // Note: build error files will be initialized in test environments for particular tests, also we don't have output to report error files into anyway...
             _testEnvironment = TestEnvironment.Create(output: null, ignoreBuildErrorFiles: true);
 
diff --git a/src/UnitTests.Shared/MockLogger.cs b/src/UnitTests.Shared/MockLogger.cs
index 782cef74d41..b530cc538f0 100644
--- a/src/UnitTests.Shared/MockLogger.cs
+++ b/src/UnitTests.Shared/MockLogger.cs
@@ -213,6 +213,11 @@ public void Initialize(IEventSource eventSource)
             {
                 _reportTelemetry = true;
             }
+
+            if (eventSource is IEventSource4 eventSource4)
+            {
+                eventSource4.IncludeEvaluationPropertiesAndItems();
+            }
         }
 
         /// <summary>
