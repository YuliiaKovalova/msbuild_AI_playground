diff --git a/MSBuild.sln b/MSBuild.sln
index 5c8326406f6..e441e1779ed 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -80,6 +80,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.VSSetup.Arm64", "sr
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnitTests.Shared", "src\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj", "{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Analyzers", "src\Analyzers\Microsoft.Build.Analyzers.csproj", "{512E01F7-2899-433B-93E2-D63B43AF0420}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -864,6 +866,54 @@ Global
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x64.Build.0 = Release|x64
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.ActiveCfg = Release|Any CPU
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.Build.0 = Release|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|ARM64.ActiveCfg = Release-MONO|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|ARM64.Build.0 = Release-MONO|arm64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{71E59632-D644-491B-AF93-22BC93167C56}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|ARM64.ActiveCfg = Debug|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|ARM64.Build.0 = Debug|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|x64.ActiveCfg = Debug|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|x64.Build.0 = Debug|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug|x86.Build.0 = Debug|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|ARM64.Build.0 = Debug-MONO|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|ARM64.Build.0 = MachineIndependent|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|Any CPU.Build.0 = Release|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|ARM64.ActiveCfg = Release|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|ARM64.Build.0 = Release|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|x64.ActiveCfg = Release|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|x64.Build.0 = Release|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|x86.ActiveCfg = Release|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release|x86.Build.0 = Release|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|ARM64.ActiveCfg = Release-MONO|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|ARM64.Build.0 = Release-MONO|arm64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{512E01F7-2899-433B-93E2-D63B43AF0420}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/src/Analyzers/API/BuildAnalysisContext.cs b/src/Analyzers/API/BuildAnalysisContext.cs
new file mode 100644
index 00000000000..098ae5470f6
--- /dev/null
+++ b/src/Analyzers/API/BuildAnalysisContext.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Analyzers.Infrastructure;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental;
+
+public class BuildAnalysisContext
+{
+    private protected readonly LoggingContext _loggingContext;
+
+    internal BuildAnalysisContext(LoggingContext loggingContext) => _loggingContext = loggingContext;
+
+    public void ReportResult(BuildAnalysisResult result)
+    {
+        BuildEventArgs eventArgs = result.ToEventArgs(ConfigurationProvider.GetMergedConfiguration(result.BuildAnalysisRule).Severity);
+        eventArgs.BuildEventContext = _loggingContext.BuildEventContext;
+        _loggingContext.LogBuildEvent(eventArgs);
+    }
+}
diff --git a/src/Analyzers/API/BuildAnalysisLoggerFactory.cs b/src/Analyzers/API/BuildAnalysisLoggerFactory.cs
new file mode 100644
index 00000000000..4ed8d920770
--- /dev/null
+++ b/src/Analyzers/API/BuildAnalysisLoggerFactory.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Analyzers.Infrastructure;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental;
+
+public class BuildAnalysisLoggerFactory : IBuildAnalysisLoggerFactory
+{
+    public ILogger CreateBuildAnalysisLogger(IBuildAnalysisLoggingContextFactory loggingContextFactory)
+    {
+        return new AnalyzersConnectorLogger(loggingContextFactory, BuildAnalysisManager.Instance);
+    }
+}
diff --git a/src/Analyzers/API/BuildAnalysisResult.cs b/src/Analyzers/API/BuildAnalysisResult.cs
new file mode 100644
index 00000000000..0b5fc893d06
--- /dev/null
+++ b/src/Analyzers/API/BuildAnalysisResult.cs
@@ -0,0 +1,115 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental;
+
+public class BuildAnalysisResult
+{
+    public static BuildAnalysisResult Create(BuildAnalysisRule rule, ElementLocation location, params string[] messageArgs)
+    {
+        return new BuildAnalysisResult(rule, location, messageArgs);
+    }
+
+    public BuildAnalysisResult(BuildAnalysisRule buildAnalysisRule, ElementLocation location, string[] messageArgs)
+    {
+        BuildAnalysisRule = buildAnalysisRule;
+        Location = location;
+        MessageArgs = messageArgs;
+    }
+
+    internal BuildEventArgs ToEventArgs(BuildAnalysisResultSeverity severity)
+        => severity switch
+        {
+            BuildAnalysisResultSeverity.Info => new BuildAnalysisResultMessage(this),
+            BuildAnalysisResultSeverity.Warning => new BuildAnalysisResultWarning(this),
+            BuildAnalysisResultSeverity.Error => new BuildAnalysisResultError(this),
+            _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
+        };
+
+    public BuildAnalysisRule BuildAnalysisRule { get; }
+    public ElementLocation Location { get; }
+    public string[] MessageArgs { get; }
+
+    private string? _message;
+    public string Message => _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}{BuildAnalysisRule.Id}: {string.Format(BuildAnalysisRule.MessageFormat, MessageArgs)}";
+}
+
+public sealed class BuildAnalysisResultWarning : BuildWarningEventArgs
+{
+    public BuildAnalysisResultWarning(BuildAnalysisResult result)
+    {
+        this.Message = result.Message;
+    }
+
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
+
+public sealed class BuildAnalysisResultError : BuildErrorEventArgs
+{
+    public BuildAnalysisResultError(BuildAnalysisResult result)
+    {
+        this.Message = result.Message;
+    }
+
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
+
+public sealed class BuildAnalysisResultMessage : BuildMessageEventArgs
+{
+    public BuildAnalysisResultMessage(BuildAnalysisResult result)
+    {
+        this.Message = result.Message;
+    }
+
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
diff --git a/src/Analyzers/API/BuildAnalysisResultSeverity.cs b/src/Analyzers/API/BuildAnalysisResultSeverity.cs
new file mode 100644
index 00000000000..d3eeb7c7bd1
--- /dev/null
+++ b/src/Analyzers/API/BuildAnalysisResultSeverity.cs
@@ -0,0 +1,11 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public enum BuildAnalysisResultSeverity
+{
+    Info,
+    Warning,
+    Error,
+}
diff --git a/src/Analyzers/API/BuildAnalysisRule.cs b/src/Analyzers/API/BuildAnalysisRule.cs
new file mode 100644
index 00000000000..8858b8dc44a
--- /dev/null
+++ b/src/Analyzers/API/BuildAnalysisRule.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public class BuildAnalysisRule
+{
+    public BuildAnalysisRule(string id, string title, string description, string category, string messageFormat,
+        BuildAnalyzerConfiguration defaultConfiguration)
+    {
+        Id = id;
+        Title = title;
+        Description = description;
+        Category = category;
+        MessageFormat = messageFormat;
+        DefaultConfiguration = defaultConfiguration;
+    }
+
+    public string Id { get; }
+    public string Title { get; }
+    public string Description { get; }
+
+    // or maybe enum? eval, syntax, etc
+    public string Category { get; }
+    public string MessageFormat { get; }
+    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+}
diff --git a/src/Analyzers/API/BuildAnalyzer.cs b/src/Analyzers/API/BuildAnalyzer.cs
new file mode 100644
index 00000000000..cbe39d9c8a6
--- /dev/null
+++ b/src/Analyzers/API/BuildAnalyzer.cs
@@ -0,0 +1,15 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Immutable;
+
+namespace Microsoft.Build.Experimental;
+
+public abstract class BuildAnalyzer
+{
+    public abstract string FriendlyName { get; }
+    public abstract ImmutableArray<BuildAnalysisRule> SupportedRules { get; }
+    public abstract void Initialize(ConfigurationContext configurationContext);
+
+    public abstract void RegisterActions(IBuildAnalyzerContext context);
+}
diff --git a/src/Analyzers/API/BuildAnalyzerConfiguration.cs b/src/Analyzers/API/BuildAnalyzerConfiguration.cs
new file mode 100644
index 00000000000..b9479d88cff
--- /dev/null
+++ b/src/Analyzers/API/BuildAnalyzerConfiguration.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public class BuildAnalyzerConfiguration
+{
+    public static BuildAnalyzerConfiguration Default { get; } = new()
+    {
+        LifeTimeScope = Experimental.LifeTimeScope.PerProject,
+        SupportedInvocationConcurrency = InvocationConcurrency.Parallel,
+        PerformanceWeightClass = Experimental.PerformanceWeightClass.Normal,
+        EvaluationAnalysisScope = Experimental.EvaluationAnalysisScope.AnalyzedProjectOnly,
+        Severity = BuildAnalysisResultSeverity.Info,
+        IsEnabled = false,
+    };
+
+    public static BuildAnalyzerConfiguration Null { get; } = new();
+
+    public LifeTimeScope? LifeTimeScope { get; internal init; }
+    public InvocationConcurrency? SupportedInvocationConcurrency { get; internal init; }
+    public PerformanceWeightClass? PerformanceWeightClass { get; internal init; }
+    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+    public BuildAnalysisResultSeverity? Severity { get; internal init; }
+    public bool? IsEnabled { get; internal init; }
+}
diff --git a/src/Analyzers/API/ConfigurationContext.cs b/src/Analyzers/API/ConfigurationContext.cs
new file mode 100644
index 00000000000..69e2ec43e28
--- /dev/null
+++ b/src/Analyzers/API/ConfigurationContext.cs
@@ -0,0 +1,16 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Experimental;
+
+/// <summary>
+/// Holder of an optional configuration from .editorconfig file (not recognized by infrastructure)
+/// </summary>
+public class ConfigurationContext
+{
+    public static ConfigurationContext Null { get; } = new();
+
+    public IReadOnlyDictionary<string, string>? ConfigurationData { get; init; }
+}
diff --git a/src/Analyzers/API/EvaluationAnalysisScope.cs b/src/Analyzers/API/EvaluationAnalysisScope.cs
new file mode 100644
index 00000000000..3fafe62e4d6
--- /dev/null
+++ b/src/Analyzers/API/EvaluationAnalysisScope.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public enum EvaluationAnalysisScope
+{
+    AnalyzedProjectOnly,
+    AnalyzedProjectWithImportsFromCurrentWorkTree,
+    AnalyzedProjectWithImportsWithoutSdks,
+    AnalyzedProjectWithAllImports,
+}
diff --git a/src/Analyzers/API/InvocationConcurrency.cs b/src/Analyzers/API/InvocationConcurrency.cs
new file mode 100644
index 00000000000..f4e8bc61ad6
--- /dev/null
+++ b/src/Analyzers/API/InvocationConcurrency.cs
@@ -0,0 +1,10 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public enum InvocationConcurrency
+{
+    Sequential,
+    Parallel,
+}
diff --git a/src/Analyzers/API/LifeTimeScope.cs b/src/Analyzers/API/LifeTimeScope.cs
new file mode 100644
index 00000000000..34f85355050
--- /dev/null
+++ b/src/Analyzers/API/LifeTimeScope.cs
@@ -0,0 +1,11 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public enum LifeTimeScope
+{
+    Stateless,
+    PerProject,
+    PerBuild,
+}
diff --git a/src/Analyzers/API/PerformanceWeightClass.cs b/src/Analyzers/API/PerformanceWeightClass.cs
new file mode 100644
index 00000000000..ea2d5aa2469
--- /dev/null
+++ b/src/Analyzers/API/PerformanceWeightClass.cs
@@ -0,0 +1,11 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public enum PerformanceWeightClass
+{
+    Lightweight,
+    Normal,
+    Heavyweight,
+}
diff --git a/src/Analyzers/Analyzers/SharedOutputPathAnalyzer.cs b/src/Analyzers/Analyzers/SharedOutputPathAnalyzer.cs
new file mode 100644
index 00000000000..a49e4769ed9
--- /dev/null
+++ b/src/Analyzers/Analyzers/SharedOutputPathAnalyzer.cs
@@ -0,0 +1,99 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental;
+
+namespace Microsoft.Build.Analyzers.Analyzers;
+
+// Some background on ids:
+//  * https://github.com/dotnet/roslyn-analyzers/blob/main/src/Utilities/Compiler/DiagnosticCategoryAndIdRanges.txt
+//  * https://github.com/dotnet/roslyn/issues/40351
+//
+// quick suggestion now - let's force external ids to start with 'X', for ours - avoid 'MSB'
+//  maybe - BS - build styling; BA - build authoring; BE - build execution/environment; BC - build configuration
+
+internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
+{
+    public static BuildAnalysisRule SupportedRule = new BuildAnalysisRule("BC0101", "ConflictingOutputPath",
+        "Two projects should not share their OutputPath nor IntermediateOutputPath locations", "Configuration",
+        "Projects {0} and {1} have conflicting output paths: {2}.",
+        new BuildAnalyzerConfiguration() { Severity = BuildAnalysisResultSeverity.Warning, IsEnabled = true });
+
+    public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
+
+    public override ImmutableArray<BuildAnalysisRule> SupportedRules { get; } =[SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        /* This is it - no custom configuration */
+    }
+
+    public override void RegisterActions(IBuildAnalyzerContext context)
+    {
+        context.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+    }
+
+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
+    private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
+
+    private void EvaluatedPropertiesAction(EvaluatedPropertiesContext context)
+    {
+        if (!_projects.Add(context.ProjectFilePath))
+        {
+            return;
+        }
+
+        string? binPath, objPath;
+
+        context.EvaluatedProperties.TryGetValue("OutputPath", out binPath);
+        context.EvaluatedProperties.TryGetValue("IntermediateOutputPath", out objPath);
+
+        string? absoluteBinPath = CheckAndAddFullOutputPath(binPath, context);
+        if (
+            !string.IsNullOrEmpty(objPath) && !string.IsNullOrEmpty(absoluteBinPath) &&
+            !objPath.Equals(binPath, StringComparison.CurrentCultureIgnoreCase)
+            && !objPath.Equals(absoluteBinPath, StringComparison.CurrentCultureIgnoreCase)
+        )
+        {
+            CheckAndAddFullOutputPath(objPath, context);
+        }
+    }
+
+    private string? CheckAndAddFullOutputPath(string? path, EvaluatedPropertiesContext context)
+    {
+        if (string.IsNullOrEmpty(path))
+        {
+            return path;
+        }
+
+        string projectPath = context.ProjectFilePath;
+
+        if (!Path.IsPathRooted(path))
+        {
+            path = Path.Combine(Path.GetDirectoryName(projectPath)!, path);
+        }
+
+        if (_projectsPerOutputPath.TryGetValue(path!, out string? conflictingProject))
+        {
+            context.ReportResult(BuildAnalysisResult.Create(
+                SupportedRule,
+                // TODO: let's support transmitting locations of specific properties
+                ElementLocation.EmptyLocation,
+                Path.GetFileName(projectPath),
+                Path.GetFileName(conflictingProject),
+                path!));
+        }
+        else
+        {
+            _projectsPerOutputPath[path!] = projectPath;
+        }
+
+        return path;
+    }
+}
diff --git a/src/Analyzers/Infrastructure/AnalyzersConnectorLogger.cs b/src/Analyzers/Infrastructure/AnalyzersConnectorLogger.cs
new file mode 100644
index 00000000000..eb3170f1d52
--- /dev/null
+++ b/src/Analyzers/Infrastructure/AnalyzersConnectorLogger.cs
@@ -0,0 +1,52 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Analyzers.Infrastructure;
+internal sealed class AnalyzersConnectorLogger(IBuildAnalysisLoggingContextFactory loggingContextFactory, IBuildAnalysisManager buildAnalysisManager)
+    : ILogger
+{
+    public LoggerVerbosity Verbosity { get; set; }
+    public string? Parameters { get; set; }
+
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+    }
+
+    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
+    {
+        if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs &&
+            !(projectEvaluationFinishedEventArgs.ProjectFile?.EndsWith(".metaproj") ?? false))
+        {
+            // Debugger.Launch();
+
+            try
+            {
+                buildAnalysisManager.ProcessEvaluationFinishedEventArgs(
+                    loggingContextFactory.CreateLoggingContext(e.BuildEventContext!),
+                    projectEvaluationFinishedEventArgs);
+            }
+            catch (Exception exception)
+            {
+                Debugger.Launch();
+                Console.WriteLine(exception);
+                throw;
+            }
+        }
+        // here handling of other event types
+    }
+
+    public void Shutdown()
+    {
+        // TODO: here flush the tracing stats: https://github.com/dotnet/msbuild/issues/9629
+    }
+}
diff --git a/src/Analyzers/Infrastructure/BuildAnalysisManager.cs b/src/Analyzers/Infrastructure/BuildAnalysisManager.cs
new file mode 100644
index 00000000000..3693dec4f44
--- /dev/null
+++ b/src/Analyzers/Infrastructure/BuildAnalysisManager.cs
@@ -0,0 +1,111 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Analyzers.Analyzers;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.Analyzers;
+
+namespace Microsoft.Build.Analyzers.Infrastructure;
+
+internal sealed class BuildAnalysisManager : IBuildAnalysisManager
+{
+    private readonly List<BuildAnalyzerTracingWrapper> _analyzers = new();
+    private readonly CentralBuildAnalyzerContext _centralContext = new();
+
+    private BuildAnalysisManager() { }
+
+    internal static IBuildAnalysisManager Instance => CreateBuildAnalysisManager();
+
+    public void RegisterAnalyzer(BuildAnalyzer analyzer)
+    {
+        if (!analyzer.SupportedRules.Any())
+        {
+            // error out
+            return;
+        }
+
+        IEnumerable<BuildAnalyzerConfigurationInternal> configuration = analyzer.SupportedRules.Select(ConfigurationProvider.GetMergedConfiguration);
+
+        if (configuration.All(c => !c.IsEnabled))
+        {
+            return;
+        }
+
+        // TODO: the config module should return any possible user configurations per rule
+        ConfigurationContext configurationContext = ConfigurationContext.Null;
+        analyzer.Initialize(configurationContext);
+        var wrappedAnalyzer = new BuildAnalyzerTracingWrapper(analyzer);
+        var wrappedContext = new BuildAnalyzerContext(wrappedAnalyzer, _centralContext);
+        analyzer.RegisterActions(wrappedContext);
+        _analyzers.Add(wrappedAnalyzer);
+    }
+
+    // TODO: all this processing should be queued and done async. We might even want to run analyzers in parallel
+
+    private SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
+
+    // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
+    public void ProcessEvaluationFinishedEventArgs(IBuildAnalysisLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+    {
+        LoggingContext? loggingContext = (buildAnalysisContext as AnalyzerLoggingContext)!;
+
+        if (loggingContext == null)
+        {
+            // error out
+            return;
+        }
+
+        Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
+        Internal.Utilities.EnumerateProperties(evaluationFinishedEventArgs.Properties, propertiesLookup,
+            static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
+
+        EvaluatedPropertiesContext context = new EvaluatedPropertiesContext(loggingContext,
+            new ReadOnlyDictionary<string, string>(propertiesLookup),
+            evaluationFinishedEventArgs.ProjectFile!);
+
+        _centralContext.RunEvaluatedPropertiesActions(context);
+
+        if (_centralContext.HasParsedItemsActions)
+        {
+            ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(evaluationFinishedEventArgs.ProjectFile!, /*unused*/
+                null, /*unused*/null, _cache, false /*Not explicitly loaded - unused*/);
+
+            ParsedItemsContext parsedItemsContext = new ParsedItemsContext(loggingContext,
+                new ItemsHolder(xml.Items, xml.ItemGroups));
+
+            _centralContext.RunParsedItemsActions(parsedItemsContext);
+        }
+    }
+
+    // TODO: tracing: https://github.com/dotnet/msbuild/issues/9629
+    // should have infra as well, should log to AnalyzersConnectorLogger upon shutdown (if requested)
+    internal string CreateTracingStats()
+    {
+        return string.Join(Environment.NewLine,
+            _analyzers.Select(a => GetAnalyzerDescriptor(a.BuildAnalyzer) + ": " + a.Elapsed));
+
+        string GetAnalyzerDescriptor(BuildAnalyzer buildAnalyzer)
+            => buildAnalyzer.FriendlyName + " (" + buildAnalyzer.GetType() + ")";
+    }
+
+    internal static BuildAnalysisManager CreateBuildAnalysisManager()
+    {
+        var buildAnalysisManager = new BuildAnalysisManager();
+        buildAnalysisManager.RegisterAnalyzer(new SharedOutputPathAnalyzer());
+        // ... Register other internal analyzers
+        return buildAnalysisManager;
+    }
+}
diff --git a/src/Analyzers/Infrastructure/BuildAnalyzerConfigurationInternal.cs b/src/Analyzers/Infrastructure/BuildAnalyzerConfigurationInternal.cs
new file mode 100644
index 00000000000..cef5165db2f
--- /dev/null
+++ b/src/Analyzers/Infrastructure/BuildAnalyzerConfigurationInternal.cs
@@ -0,0 +1,24 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental;
+
+namespace Microsoft.Build.Analyzers.Infrastructure;
+
+/// <summary>
+/// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
+/// </summary>
+internal sealed class BuildAnalyzerConfigurationInternal
+{
+    public LifeTimeScope LifeTimeScope { get; internal init; }
+    public InvocationConcurrency SupportedInvocationConcurrency { get; internal init; }
+    public PerformanceWeightClass PerformanceWeightClass { get; internal init; }
+    public EvaluationAnalysisScope EvaluationAnalysisScope { get; internal init; }
+    public BuildAnalysisResultSeverity Severity { get; internal init; }
+    public bool IsEnabled { get; internal init; }
+}
diff --git a/src/Analyzers/Infrastructure/BuildAnalyzerContext.cs b/src/Analyzers/Infrastructure/BuildAnalyzerContext.cs
new file mode 100644
index 00000000000..832bb94872a
--- /dev/null
+++ b/src/Analyzers/Infrastructure/BuildAnalyzerContext.cs
@@ -0,0 +1,99 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Experimental;
+
+public delegate void EvaluatedPropertiesAction(EvaluatedPropertiesContext context);
+public delegate void ParsedItemsAction(ParsedItemsContext context);
+
+internal sealed class CentralBuildAnalyzerContext
+{
+    private EvaluatedPropertiesAction? _evaluatedPropertiesActions;
+    private ParsedItemsAction? _parsedItemsActions;
+
+    // This we can potentially use to subscribe for receiving evaluated props in the
+    //  build event args. However - this needs to be done early on, when analyzers might not be known yet
+    internal bool HasEvaluatedPropertiesActions => _evaluatedPropertiesActions != null;
+    internal bool HasParsedItemsActions => _parsedItemsActions != null;
+
+    internal void RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction evaluatedPropertiesAction)
+    {
+        // Here we might want to communicate to node that props need to be sent.
+        //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
+        _evaluatedPropertiesActions += evaluatedPropertiesAction;
+    }
+
+    internal void RegisterParsedItemsAction(ParsedItemsAction parsedItemsAction)
+    {
+        _parsedItemsActions += parsedItemsAction;
+    }
+
+    internal void RunEvaluatedPropertiesActions(EvaluatedPropertiesContext evaluatedPropertiesContext)
+    {
+        _evaluatedPropertiesActions?.Invoke(evaluatedPropertiesContext);
+    }
+
+    internal void RunParsedItemsActions(ParsedItemsContext parsedItemsContext)
+    {
+        _parsedItemsActions?.Invoke(parsedItemsContext);
+    }
+}
+
+internal sealed class BuildAnalyzerTracingWrapper
+{
+    private readonly Stopwatch _stopwatch = new Stopwatch();
+
+    public BuildAnalyzerTracingWrapper(BuildAnalyzer buildAnalyzer)
+        => BuildAnalyzer = buildAnalyzer;
+
+    internal BuildAnalyzer BuildAnalyzer { get; }
+
+    internal TimeSpan Elapsed => _stopwatch.Elapsed;
+
+    internal IDisposable StartSpan()
+    {
+        _stopwatch.Start();
+        return new CleanupScope(_stopwatch.Stop);
+    }
+
+    internal readonly struct CleanupScope(Action disposeAction) : IDisposable
+    {
+        public void Dispose() => disposeAction();
+    }
+}
+
+public interface IBuildAnalyzerContext
+{
+    void RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction evaluatedPropertiesAction);
+    void RegisterParsedItemsAction(ParsedItemsAction parsedItemsAction);
+}
+
+internal sealed class BuildAnalyzerContext(BuildAnalyzerTracingWrapper analyzer, CentralBuildAnalyzerContext centralContext) : IBuildAnalyzerContext
+{
+    public void RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction evaluatedPropertiesAction)
+    {
+        void WrappedEvaluatedPropertiesAction(EvaluatedPropertiesContext context)
+        {
+            using var _ = analyzer.StartSpan();
+            evaluatedPropertiesAction(context);
+        }
+
+        centralContext.RegisterEvaluatedPropertiesAction(WrappedEvaluatedPropertiesAction);
+    }
+
+    public void RegisterParsedItemsAction(ParsedItemsAction parsedItemsAction)
+    {
+        void WrappedParsedItemsAction(ParsedItemsContext context)
+        {
+            using var _ = analyzer.StartSpan();
+            parsedItemsAction(context);
+        }
+
+        centralContext.RegisterParsedItemsAction(WrappedParsedItemsAction);
+    }
+}
diff --git a/src/Analyzers/Infrastructure/ConfigurationProvider.cs b/src/Analyzers/Infrastructure/ConfigurationProvider.cs
new file mode 100644
index 00000000000..f0935938997
--- /dev/null
+++ b/src/Analyzers/Infrastructure/ConfigurationProvider.cs
@@ -0,0 +1,114 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.Json.Serialization;
+using System.Text.Json;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental;
+
+namespace Microsoft.Build.Analyzers.Infrastructure;
+
+// TODO: https://github.com/dotnet/msbuild/issues/9628
+internal static class ConfigurationProvider
+{
+    // TODO: This module should have a mechanism for removing unneeded configurations
+    //  (disabled rules and analyzers that need to run in different node)
+    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
+
+    // This is just a testing implementation for quicker unblock of testing.
+    // Real implementation will use .editorconfig file.
+    // Sample json:
+    /////*lang=json,strict*/
+    ////"""
+    ////    {
+    ////        "ABC123": {
+    ////            "IsEnabled": true,
+    ////            "Severity": "Info"
+    ////        },
+    ////        "COND0543": {
+    ////            "IsEnabled": false,
+    ////            "Severity": "Error",
+    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
+    ////    		"CustomSwitch": "QWERTY"
+    ////        },
+    ////        "BLA": {
+    ////            "IsEnabled": false
+    ////        }
+    ////    }
+    ////    """
+    //
+    // Plus there will need to be a mechanism of distinguishing different configs in different folders
+    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
+    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
+    {
+        const string configFileName = "editorconfig.json";
+        string configPath = configFileName;
+
+        if (!File.Exists(configPath))
+        {
+            // TODO: pass the current project path
+            var dir = Environment.CurrentDirectory;
+            configPath = Path.Combine(dir, configFileName);
+
+            if (!File.Exists(configPath))
+            {
+                return new Dictionary<string, BuildAnalyzerConfiguration>();
+            }
+        }
+
+        var json = File.ReadAllText(configPath);
+        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
+        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
+               new Dictionary<string, BuildAnalyzerConfiguration>();
+    }
+
+    /// <summary>
+    /// Gets effective configuration for the given analyzer rule.
+    /// The configuration values are guaranteed to be non-null upon this merge operation.
+    /// </summary>
+    /// <param name="analyzerRule"></param>
+    /// <returns></returns>
+    public static BuildAnalyzerConfigurationInternal GetMergedConfiguration(BuildAnalysisRule analyzerRule)
+    {
+        if (!_editorConfig.TryGetValue(analyzerRule.Id, out BuildAnalyzerConfiguration? editorConfig))
+        {
+            editorConfig = BuildAnalyzerConfiguration.Null;
+        }
+
+        var defaultConfig = analyzerRule.DefaultConfiguration;
+
+        return new BuildAnalyzerConfigurationInternal()
+        {
+            SupportedInvocationConcurrency = GetConfigValue(editorConfig, defaultConfig, cfg => cfg.SupportedInvocationConcurrency),
+            EvaluationAnalysisScope = GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
+            IsEnabled = GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
+            LifeTimeScope = GetConfigValue(editorConfig, defaultConfig, cfg => cfg.LifeTimeScope),
+            PerformanceWeightClass = GetConfigValue(editorConfig, defaultConfig, cfg => cfg.PerformanceWeightClass),
+            Severity = GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity)
+        };
+
+        T GetConfigValue<T>(
+            BuildAnalyzerConfiguration editorConfigValue,
+            BuildAnalyzerConfiguration defaultValue,
+            Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
+            => propertyGetter(editorConfigValue) ??
+               propertyGetter(defaultValue) ??
+               EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
+
+        T EnsureNonNull<T>(T? value) where T : struct
+        {
+            if (value is null)
+            {
+                throw new InvalidOperationException("Value is null");
+            }
+
+            return value.Value;
+        }
+    }
+}
diff --git a/src/Analyzers/Microsoft.Build.Analyzers.csproj b/src/Analyzers/Microsoft.Build.Analyzers.csproj
new file mode 100644
index 00000000000..96a3bf34bb5
--- /dev/null
+++ b/src/Analyzers/Microsoft.Build.Analyzers.csproj
@@ -0,0 +1,21 @@
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
+    <TargetFrameworks Condition="'$(MonoBuild)'=='true'">$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
+    <RootNamespace>Microsoft.Build.Analyzers</RootNamespace>
+    <AssemblyName>Microsoft.Build.Analyzers</AssemblyName>
+    <PackageDescription>This package contains the $(AssemblyName) assembly which contains build analyzers logic and API.</PackageDescription>
+    <IsPackable>true</IsPackable>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
+  </PropertyGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
+    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <PackageReference Include="System.Collections.Immutable" />
+  </ItemGroup>
+  
+</Project>
diff --git a/src/Analyzers/OM/EvaluatedPropertiesContext.cs b/src/Analyzers/OM/EvaluatedPropertiesContext.cs
new file mode 100644
index 00000000000..282b9a73ddb
--- /dev/null
+++ b/src/Analyzers/OM/EvaluatedPropertiesContext.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
+
+namespace Microsoft.Build.Experimental;
+public class EvaluatedPropertiesContext : BuildAnalysisContext
+{
+    internal EvaluatedPropertiesContext(
+        LoggingContext loggingContext,
+        IReadOnlyDictionary<string, string> evaluatedProperties,
+        string projectFilePath) :
+        base(loggingContext) => (EvaluatedProperties, ProjectFilePath) =
+        (evaluatedProperties, projectFilePath);
+
+    public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
+
+    public string ProjectFilePath { get; }
+}
diff --git a/src/Analyzers/OM/ParsedItemsContext.cs b/src/Analyzers/OM/ParsedItemsContext.cs
new file mode 100644
index 00000000000..5a29a628627
--- /dev/null
+++ b/src/Analyzers/OM/ParsedItemsContext.cs
@@ -0,0 +1,56 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Experimental;
+public enum ItemType
+{
+    ProjectReference,
+    PackageReference,
+    Compile,
+    EmbeddedResource
+}
+
+public static class ItemTypeExtensions
+{
+    public static IEnumerable<ProjectItemElement> GetItemsOfType(this IEnumerable<ProjectItemElement> items, ItemType itemType)
+        => GetItemsOfType(items, itemType.ToString());
+
+    public static IEnumerable<ProjectItemElement> GetItemsOfType(this IEnumerable<ProjectItemElement> items,
+        string itemType)
+    {
+        return items.Where(i =>
+            i.ItemType.Equals(itemType, StringComparison.CurrentCultureIgnoreCase));
+    }
+}
+
+public class ItemsHolder(IEnumerable<ProjectItemElement> items, IEnumerable<ProjectItemGroupElement> itemGroups)
+{
+    public IEnumerable<ProjectItemElement> Items { get; } = items;
+    public IEnumerable<ProjectItemGroupElement> ItemGroups { get; } = itemGroups;
+
+    public IEnumerable<ProjectItemElement> GetItemsOfType(ItemType itemType)
+        => Items.GetItemsOfType(itemType);
+
+    public IEnumerable<ProjectItemElement> GetItemsOfType(string itemType)
+    {
+        return Items.GetItemsOfType(itemType);
+    }
+}
+
+public class ParsedItemsContext : BuildAnalysisContext
+{
+    internal ParsedItemsContext(
+        LoggingContext loggingContext,
+        ItemsHolder itemsHolder) :
+        base(loggingContext) => ItemsHolder = itemsHolder;
+
+    public ItemsHolder ItemsHolder { get; }
+}
diff --git a/src/Analyzers/README.md b/src/Analyzers/README.md
new file mode 100644
index 00000000000..e09acbf1bcf
--- /dev/null
+++ b/src/Analyzers/README.md
@@ -0,0 +1,3 @@
+# Microsoft.Build.Analyzers
+
+TBD
\ No newline at end of file
diff --git a/src/Analyzers/Utilities/IsExternalInit.cs b/src/Analyzers/Utilities/IsExternalInit.cs
new file mode 100644
index 00000000000..92d5c4c320a
--- /dev/null
+++ b/src/Analyzers/Utilities/IsExternalInit.cs
@@ -0,0 +1,7 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace System.Runtime.CompilerServices
+{
+    internal static class IsExternalInit { }
+}
diff --git a/src/Build.UnitTests/Analyzers/EndToEndTests.cs b/src/Build.UnitTests/Analyzers/EndToEndTests.cs
new file mode 100644
index 00000000000..79ecd1addc9
--- /dev/null
+++ b/src/Build.UnitTests/Analyzers/EndToEndTests.cs
@@ -0,0 +1,124 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Engine.UnitTests.Analyzers
+{
+    public class EndToEndTests
+    {
+        private readonly TestEnvironment _env;
+        public EndToEndTests(ITestOutputHelper output)
+        {
+            _env = TestEnvironment.Create(output);
+
+            // this is needed to ensure the binary logger does not pollute the environment
+            _env.WithEnvironmentInvariant();
+        }
+
+        [Fact]
+        // WARNING!: this test is using a bootstrap - so a build.cmd needs to be run prior this test can properly capture the
+        //  changes in the production code
+        public void SampleAnalyzerIntegrationTest()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                string contents = $"""
+                    <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
+                    
+                      <PropertyGroup>
+                        <OutputType>Exe</OutputType>
+                        <TargetFramework>net8.0</TargetFramework>
+                        <ImplicitUsings>enable</ImplicitUsings>
+                        <Nullable>enable</Nullable>
+                      </PropertyGroup>
+                      
+                      <PropertyGroup Condition="$(Test) == true">
+                     <TestProperty>Test</TestProperty>
+                     </PropertyGroup>
+                     
+                     <ItemGroup>
+                      <ProjectReference Include=".\FooBar-Copy.csproj" />
+                      </ItemGroup>
+                      
+                      <Target Name="Hello">
+                      <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                    </Target>
+                    
+                    </Project>
+                    """;
+
+                string contents2 = $"""
+                                   <Project Sdk="Microsoft.NET.Sdk">
+                                   
+                                     <PropertyGroup>
+                                       <OutputType>Exe</OutputType>
+                                       <TargetFramework>net8.0</TargetFramework>
+                                       <ImplicitUsings>enable</ImplicitUsings>
+                                       <Nullable>enable</Nullable>
+                                     </PropertyGroup>
+                                     
+                                     <PropertyGroup Condition="$(Test) == true">
+                                    <TestProperty>Test</TestProperty>
+                                    </PropertyGroup>
+                                    
+                                    <ItemGroup>
+                                   <Reference Include="bin/foo.dll" />
+                                   </ItemGroup>
+                                    
+                                    <Target Name="Hello">
+                                     <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                                   </Target>
+                                   
+                                   </Project>
+                                   """;
+                TransientTestFolder workFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(workFolder, "FooBar.csproj", contents);
+                TransientTestFile projectFile2 = env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+
+                // var cache = new SimpleProjectRootElementCache();
+                // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
+
+
+                TransientTestFile config = env.CreateFile(workFolder, "editorconfig.json",
+                    /*lang=json,strict*/
+                    """
+                    {
+                        "BC0101": {
+                            "IsEnabled": true,
+                            "Severity": "Error"
+                        },
+                        "COND0543": {
+                            "IsEnabled": false,
+                            "Severity": "Error",
+                    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
+                    		"CustomSwitch": "QWERTY"
+                        },
+                        "BLA": {
+                            "IsEnabled": false
+                        }
+                    }
+                    """);
+
+                // env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+                env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
+                // string output = RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m:1 -nr:False", out bool success);
+                string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} /m:1 -nr:False -restore", out bool success);
+                _env.Output.WriteLine(output);
+                success.ShouldBeTrue();
+                // The conflicting outputs warning appears
+                output.ShouldContain("BC0101");
+            }
+        }
+    }
+}
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 6e57337863d..fc70072ee54 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -21,6 +21,7 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.UnitTests.Shared, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
+[assembly: InternalsVisibleTo("Microsoft.Build.Analyzers, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Cop, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 // DO NOT expose Internals to "Microsoft.Build.UnitTests.OM.OrcasCompatibility" as this assembly is supposed to only see public interface
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 3d2088d264c..8a8cb91f608 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -32,6 +32,7 @@
 using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
+using Microsoft.Build.Logging.Analyzers;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.NET.StringTools;
@@ -628,6 +629,7 @@ ILoggingService InitializeLoggingService()
             {
                 ILoggingService loggingService = CreateLoggingService(
                     AppendDebuggingLoggers(_buildParameters.Loggers),
+                    _buildParameters.BuildAnalysisLoggerFactory,
                     _buildParameters.ForwardingLoggers,
                     _buildParameters.WarningsAsErrors,
                     _buildParameters.WarningsNotAsErrors,
@@ -2943,7 +2945,13 @@ private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
         /// <summary>
         /// Creates a logging service around the specified set of loggers.
         /// </summary>
-        private ILoggingService CreateLoggingService(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> forwardingLoggers, ISet<string> warningsAsErrors, ISet<string> warningsNotAsErrors, ISet<string> warningsAsMessages)
+        private ILoggingService CreateLoggingService(
+            IEnumerable<ILogger> loggers,
+            IBuildAnalysisLoggerFactory buildAnalysisLoggerFactory,
+            IEnumerable<ForwardingLoggerRecord> forwardingLoggers,
+            ISet<string> warningsAsErrors,
+            ISet<string> warningsNotAsErrors,
+            ISet<string> warningsAsMessages)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
@@ -2967,6 +2975,15 @@ private ILoggingService CreateLoggingService(IEnumerable<ILogger> loggers, IEnum
             loggingService.WarningsNotAsErrors = warningsNotAsErrors;
             loggingService.WarningsAsMessages = warningsAsMessages;
 
+            if (buildAnalysisLoggerFactory != null)
+            {
+                loggers = (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[]
+                {
+                    buildAnalysisLoggerFactory.CreateBuildAnalysisLogger(
+                        new AnalyzerLoggingContextFactory(loggingService))
+                });
+            }
+
             try
             {
                 if (loggers != null)
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 582532e5795..697387a5f73 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -309,6 +310,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
             Question = other.Question;
+            BuildAnalysisLoggerFactory = other.BuildAnalysisLoggerFactory;
             ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
@@ -834,6 +836,11 @@ public bool Question
             set => _question = value;
         }
 
+        /// <summary>
+        /// Gets or sets a factory for build analysis infrastructure logger
+        /// </summary>
+        public IBuildAnalysisLoggerFactory BuildAnalysisLoggerFactory { get; set; }
+
         /// <summary>
         /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
         /// in addition to any potential project caches described in each project.
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 2dd2bb89a95..c9bf42b48b2 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -80,7 +80,7 @@ public string LocationString
         /// It is to be used for the project location when the project has not been given a name.
         /// In that case, it exists, but can't have a specific location.
         /// </summary>
-        internal static ElementLocation EmptyLocation
+        public static ElementLocation EmptyLocation
         {
             get { return s_emptyElementLocation; }
         }
diff --git a/src/Build/Logging/Analyzers/AnalyzerLoggingContext.cs b/src/Build/Logging/Analyzers/AnalyzerLoggingContext.cs
new file mode 100644
index 00000000000..efb07dcffed
--- /dev/null
+++ b/src/Build/Logging/Analyzers/AnalyzerLoggingContext.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.Analyzers;
+
+internal class AnalyzerLoggingContext : LoggingContext, IBuildAnalysisLoggingContext
+{
+    public AnalyzerLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+        : base(loggingService, eventContext)
+    {
+        IsValid = true;
+    }
+
+    public AnalyzerLoggingContext(LoggingContext baseContext) : base(baseContext)
+    {
+        IsValid = true;
+    }
+}
diff --git a/src/Build/Logging/Analyzers/AnalyzerLoggingContextFactory.cs b/src/Build/Logging/Analyzers/AnalyzerLoggingContextFactory.cs
new file mode 100644
index 00000000000..ae60ac0d061
--- /dev/null
+++ b/src/Build/Logging/Analyzers/AnalyzerLoggingContextFactory.cs
@@ -0,0 +1,18 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.Analyzers;
+internal class AnalyzerLoggingContextFactory(ILoggingService loggingService) : IBuildAnalysisLoggingContextFactory
+{
+    public IBuildAnalysisLoggingContext CreateLoggingContext(BuildEventContext eventContext) =>
+        new AnalyzerLoggingContext(loggingService, eventContext);
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6d41abd7891..68c4aa736e3 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -160,6 +160,8 @@
     <Compile Include="FileAccess\ProcessData.cs" />
     <Compile Include="FileAccess\ReportedFileOperation.cs" />
     <Compile Include="FileAccess\RequestedAccess.cs" />
+    <Compile Include="Logging\Analyzers\AnalyzerLoggingContext.cs" />
+    <Compile Include="Logging\Analyzers\AnalyzerLoggingContextFactory.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -682,11 +684,7 @@
   <!-- Extract binding redirects for MSBuild and dependencies from MSBuild.exe.config into a source file.
        This allows us to create secondary AppDomains with the same redirects at run-time, see
        https://github.com/dotnet/msbuild/blob/main/documentation/NETFramework-NGEN.md#nugetframeworks -->
-  <Target Name="GenerateAppDomainConfig"
-          Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config;$(MSBuildThisFileFullPath)"
-          Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)"
-          BeforeTargets="CoreCompile"
-          Condition="'$(FeatureAppDomain)' == 'true'">
+  <Target Name="GenerateAppDomainConfig" Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config;$(MSBuildThisFileFullPath)" Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)" BeforeTargets="CoreCompile" Condition="'$(FeatureAppDomain)' == 'true'">
     <PropertyGroup>
       <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>
       <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/*</BindingRedirectXPath>
diff --git a/src/Framework/Analyzers/IBuildAnalysisLoggerFactory.cs b/src/Framework/Analyzers/IBuildAnalysisLoggerFactory.cs
new file mode 100644
index 00000000000..2f7fae150aa
--- /dev/null
+++ b/src/Framework/Analyzers/IBuildAnalysisLoggerFactory.cs
@@ -0,0 +1,11 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental;
+
+public interface IBuildAnalysisLoggerFactory
+{
+    ILogger CreateBuildAnalysisLogger(IBuildAnalysisLoggingContextFactory loggingContextFactory);
+}
diff --git a/src/Framework/Analyzers/IBuildAnalysisLoggingContext.cs b/src/Framework/Analyzers/IBuildAnalysisLoggingContext.cs
new file mode 100644
index 00000000000..ef15d1b48a2
--- /dev/null
+++ b/src/Framework/Analyzers/IBuildAnalysisLoggingContext.cs
@@ -0,0 +1,7 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental;
+
+public interface IBuildAnalysisLoggingContext
+{ }
diff --git a/src/Framework/Analyzers/IBuildAnalysisLoggingContextFactory.cs b/src/Framework/Analyzers/IBuildAnalysisLoggingContextFactory.cs
new file mode 100644
index 00000000000..da1a99b6ddb
--- /dev/null
+++ b/src/Framework/Analyzers/IBuildAnalysisLoggingContextFactory.cs
@@ -0,0 +1,11 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental;
+
+public interface IBuildAnalysisLoggingContextFactory
+{
+    IBuildAnalysisLoggingContext CreateLoggingContext(BuildEventContext eventContext);
+}
diff --git a/src/Framework/Analyzers/IBuildAnalysisManager.cs b/src/Framework/Analyzers/IBuildAnalysisManager.cs
new file mode 100644
index 00000000000..c49fa515708
--- /dev/null
+++ b/src/Framework/Analyzers/IBuildAnalysisManager.cs
@@ -0,0 +1,18 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental;
+
+public interface IBuildAnalysisManager
+{
+    internal void ProcessEvaluationFinishedEventArgs(
+        IBuildAnalysisLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
+}
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 1f0b9011081..6dbcdaaf37e 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -39,6 +39,7 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
+[assembly: InternalsVisibleTo("Microsoft.Build.Analyzers, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("MSBuild, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 53e4555fcf2..e680e3f20c5 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1185,6 +1185,7 @@ public void InvalidToolsVersionErrors()
                                         graphBuildOptions: null,
                                         lowPriority: false,
                                         question: false,
+                                        buildAnalysisLoggerFactory: null,
                                         inputResultsCaches: null,
                                         outputResultsCache: null,
                                         saveProjectResult: false,
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 0415842c6b7..eb8736e53fb 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -196,6 +196,7 @@
     <PackageReference Include="System.Runtime" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup>
+    <ProjectReference Include="..\Analyzers\Microsoft.Build.Analyzers.csproj" />
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" PrivateAssets="All" />
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 545fdbc9844..3e33bfd9e96 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -19,6 +19,7 @@
 using System.Text.Json.Nodes;
 using System.Text.RegularExpressions;
 using System.Threading;
+using Microsoft.Build.Analyzers.Infrastructure;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -717,6 +718,7 @@ public static ExitType Execute(
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
                 bool question = false;
+                IBuildAnalysisLoggerFactory buildAnalysisLoggerFactory = null;
                 string[] getProperty = Array.Empty<string>();
                 string[] getItem = Array.Empty<string>();
                 string[] getTargetResult = Array.Empty<string>();
@@ -763,6 +765,7 @@ public static ExitType Execute(
 #endif
                                             ref lowPriority,
                                             ref question,
+                                            ref buildAnalysisLoggerFactory,
                                             ref getProperty,
                                             ref getItem,
                                             ref getTargetResult,
@@ -863,6 +866,7 @@ public static ExitType Execute(
                                     graphBuildOptions,
                                     lowPriority,
                                     question,
+                                    buildAnalysisLoggerFactory,
                                     inputResultsCaches,
                                     outputResultsCache,
                                     saveProjectResult: outputPropertiesItemsOrTargetResults,
@@ -1244,6 +1248,7 @@ internal static bool BuildProject(
             GraphBuildOptions graphBuildOptions,
             bool lowPriority,
             bool question,
+            IBuildAnalysisLoggerFactory buildAnalysisLoggerFactory,
             string[] inputResultsCaches,
             string outputResultsCache,
             bool saveProjectResult,
@@ -1445,6 +1450,7 @@ internal static bool BuildProject(
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
                     parameters.Question = question;
+                    parameters.BuildAnalysisLoggerFactory = buildAnalysisLoggerFactory;
 #if FEATURE_REPORTFILEACCESSES
                     parameters.ReportFileAccesses = reportFileAccesses;
 #endif
@@ -2416,6 +2422,7 @@ private static bool ProcessCommandLineSwitches(
 #endif
             ref bool lowPriority,
             ref bool question,
+            ref IBuildAnalysisLoggerFactory buildAnalysisLoggerFactory,
             ref string[] getProperty,
             ref string[] getItem,
             ref string[] getTargetResult,
@@ -2557,6 +2564,7 @@ private static bool ProcessCommandLineSwitches(
 #endif
                                                            ref lowPriority,
                                                            ref question,
+                                                           ref buildAnalysisLoggerFactory,
                                                            ref getProperty,
                                                            ref getItem,
                                                            ref getTargetResult,
@@ -2638,6 +2646,8 @@ private static bool ProcessCommandLineSwitches(
 
                     question = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Question);
 
+                    buildAnalysisLoggerFactory = ProcessBuildAnalysisLoggerFactorySwitch(commandLineSwitches);
+
                     inputResultsCaches = ProcessInputResultsCaches(commandLineSwitches);
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
@@ -2712,6 +2722,13 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
+        private static IBuildAnalysisLoggerFactory ProcessBuildAnalysisLoggerFactorySwitch(CommandLineSwitches commandLineSwitches)
+        {
+            // todo: opt-in behavior: https://github.com/dotnet/msbuild/issues/9723
+            bool isAnalysisEnabled = true;
+            return isAnalysisEnabled ? new BuildAnalysisLoggerFactory() : null;
+        }
+
         private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
         {
             aggregatedParameters = AggregateParameters(commandLineSwitches);
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index c1e96f7a6cb..f836a7be6bd 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
+using System.IO;
 using Xunit.Abstractions;
 
 #nullable disable
@@ -32,6 +33,24 @@ public static string ExecMSBuild(string msbuildParameters, out bool successfulEx
             return ExecMSBuild(PathToCurrentlyRunningMsBuildExe, msbuildParameters, out successfulExit, outputHelper: outputHelper);
         }
 
+        /// <summary>
+        /// Invoke the currently running msbuild and return the stdout, stderr, and process exit status.
+        /// This method may invoke msbuild via other runtimes.
+        /// </summary>
+        public static string ExecBootstrapedMSBuild(string msbuildParameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
+        {
+            // TODO: use proper way of passing the bootsrtrap location: https://github.com/dotnet/msbuild/issues/9729
+            string basePath = PathToCurrentlyRunningMsBuildExe.Substring(0, PathToCurrentlyRunningMsBuildExe.IndexOf(@"artifacts\bin", StringComparison.InvariantCultureIgnoreCase));
+#if NET
+            string pathToExecutable = EnvironmentProvider.GetDotnetExePath();
+            msbuildParameters = Path.Combine(basePath, @"artifacts\bin\bootstrap\net8.0\MSBuild\msbuild.dll") + " " + msbuildParameters;
+#else
+            string pathToExecutable =
+                Path.Combine(basePath, @"artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\amd64\msbuild.exe");
+#endif
+            return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
+        }
+
         /// <summary>
         /// Invoke msbuild.exe with the given parameters and return the stdout, stderr, and process exit status.
         /// This method may invoke msbuild via other runtimes.
@@ -108,7 +127,7 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 p.BeginErrorReadLine();
                 p.StandardInput.Dispose();
 
-                if (!p.WaitForExit(30_000))
+                if (!p.WaitForExit(30_000_000))
                 {
                     // Let's not create a unit test for which we need more than 30 sec to execute.
                     // Please consider carefully if you would like to increase the timeout.
