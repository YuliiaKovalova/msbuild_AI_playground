diff --git a/eng/Common.globalconfig b/eng/Common.globalconfig
index 49de8011d44..35bb600e9cf 100644
--- a/eng/Common.globalconfig
+++ b/eng/Common.globalconfig
@@ -328,7 +328,7 @@ dotnet_diagnostic.CA2000.severity = none
 dotnet_diagnostic.CA2002.severity = none
 
 # Consider calling ConfigureAwait on the awaited task
-dotnet_diagnostic.CA2007.severity = suggestion
+dotnet_diagnostic.CA2007.severity = warning
 
 # Do not create tasks without passing a TaskScheduler
 dotnet_diagnostic.CA2008.severity = suggestion
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index ed4766f5450..0ad3f852107 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -210,7 +210,7 @@ public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logg
 
             public override async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken)
             {
-                return await _getCacheResultDelegate(buildRequest, logger, cancellationToken);
+                return await _getCacheResultDelegate(buildRequest, logger, cancellationToken).ConfigureAwait(false);
             }
 
             public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)
@@ -305,7 +305,7 @@ public override async Task<CacheResult> GetCacheResultAsync(
 
                 if (_projectQuerySleepTime is not null)
                 {
-                    await Task.Delay(_projectQuerySleepTime.Value, cancellationToken);
+                    await Task.Delay(_projectQuerySleepTime.Value, cancellationToken).ConfigureAwait(false);
                 }
 
                 QueryStartStops.Enqueue(queryId);
@@ -1449,7 +1449,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
                     {
                         if (projectNumber == 2)
                         {
-                            await task2Completion.Task;
+                            await task2Completion.Task.ConfigureAwait(false);
                         }
 
                         return testData.GetExpectedCacheResultForProjectNumber(projectNumber);
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 711627b304c..02ba66264db 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -729,7 +729,7 @@ public async Task RunPacketReadLoopAsync()
                 {
                     try
                     {
-                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, _headerByte, _headerByte.Length);
+                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, _headerByte, _headerByte.Length).ConfigureAwait(false);
                         if (!ProcessHeaderBytesRead(bytesRead))
                         {
                             return;
@@ -751,7 +751,7 @@ public async Task RunPacketReadLoopAsync()
 
                     try
                     {
-                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, packetData, packetLength);
+                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, packetData, packetLength).ConfigureAwait(false);
                         if (!ProcessBodyBytesRead(bytesRead, packetLength, packetType))
                         {
                             return;
@@ -915,7 +915,7 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
                 {
                     // Wait up to 100ms until all remaining packets are sent.
                     // We don't need to wait long, just long enough for the Task to start running on the ThreadPool.
-                    await Task.WhenAny(_packetWriteDrainTask, Task.Delay(100));
+                    await Task.WhenAny(_packetWriteDrainTask, Task.Delay(100)).ConfigureAwait(false);
                 }
                 if (_exitPacketState == ExitPacketState.ExitPacketSent)
                 {
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 3fdbf100f25..007155ea723 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -94,7 +94,7 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
             // further information (set by VS) from it required by the plugin.
             if (!pluginDescriptor.VsWorkaround)
             {
-                await service.BeginBuildAsync();
+                await service.BeginBuildAsync().ConfigureAwait(false);
             }
 
             return service;
@@ -124,7 +124,7 @@ await _projectCachePlugin.BeginBuildAsync(
                         projectDescriptor.ProjectGraph,
                         projectDescriptor.EntryPoints),
                     pluginLogger,
-                    _cancellationToken);
+                    _cancellationToken).ConfigureAwait(false);
             }
             catch (Exception e)
             {
@@ -220,7 +220,7 @@ public void PostCacheRequest(CacheRequest cacheRequest)
             {
                 try
                 {
-                    (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequest(cacheRequest);
+                    (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequest(cacheRequest).ConfigureAwait(false);
                     _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
                 }
                 catch (Exception e)
@@ -272,13 +272,13 @@ public void PostCacheRequest(CacheRequest cacheRequest)
                             new TaskCompletionSource<bool>(),
                             null) is null)
                     {
-                        await LateInitializePluginForVsWorkaround(request);
+                        await LateInitializePluginForVsWorkaround(request).ConfigureAwait(false);
                         LateInitializationForVSWorkaroundCompleted.SetResult(true);
                     }
                     else
                     {
                         // Can't be null. If the thread got here it means another thread initialized the completion source.
-                        await LateInitializationForVSWorkaroundCompleted!.Task;
+                        await LateInitializationForVSWorkaroundCompleted!.Task.ConfigureAwait(false);
                     }
                 }
 
@@ -299,7 +299,7 @@ LateInitializationForVSWorkaroundCompleted is null ||
                 CacheResult cacheResult;
                 try
                 {
-                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext);
+                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext).ConfigureAwait(false);
                 }
                 catch (Exception ex)
                 {
@@ -383,7 +383,7 @@ await BeginBuildAsync(
                         _projectCacheDescriptor.PluginAssemblyPath!,
                         graphEntryPointsFromSolutionConfig,
                         projectGraph: null,
-                        _projectCacheDescriptor.PluginSettings));
+                        _projectCacheDescriptor.PluginSettings)).ConfigureAwait(false);
             }
 
             static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
@@ -503,7 +503,7 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
             try
             {
                 MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(_projectCachePluginTypeName, buildRequest.ProjectFullPath, targetNames);
-                cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, pluginLogger, _cancellationToken);
+                cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, pluginLogger, _cancellationToken).ConfigureAwait(false);
             }
             catch (Exception e)
             {
@@ -589,7 +589,7 @@ public async Task ShutDown()
                 _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheEndBuild");
                 MSBuildEventSource.Log.ProjectCacheEndBuildStart(_projectCachePluginTypeName);
 
-                await _projectCachePlugin.EndBuildAsync(pluginLogger, _cancellationToken);
+                await _projectCachePlugin.EndBuildAsync(pluginLogger, _cancellationToken).ConfigureAwait(false);
 
                 if (pluginLogger.HasLoggedErrors)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index e05113ea688..184733dffc0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -351,7 +351,7 @@ public async Task<bool> ExecuteInternal()
                                                 UnloadProjectsOnCompletion,
                                                 ToolsVersion,
                                                 SkipNonexistentTargets
-                                                );
+                                                ).ConfigureAwait(false);
 
                         if (!executeResult)
                         {
@@ -381,7 +381,7 @@ public async Task<bool> ExecuteInternal()
             // We need to build all the projects that were not skipped
             if (BuildInParallel)
             {
-                success = await BuildProjectsInParallel(propertiesTable, undefinePropertiesArray, targetLists, success, skipProjects);
+                success = await BuildProjectsInParallel(propertiesTable, undefinePropertiesArray, targetLists, success, skipProjects).ConfigureAwait(false);
             }
 
             return success;
@@ -421,7 +421,7 @@ private async Task<bool> BuildProjectsInParallel(Dictionary<string, string> prop
                 UnloadProjectsOnCompletion,
                 ToolsVersion,
                 SkipNonexistentTargets
-            );
+            ).ConfigureAwait(false);
 
             if (!executeResult)
             {
@@ -648,7 +648,7 @@ internal static async Task<bool> ExecuteTargets(
                 // as the *calling* project file.
 
                 var taskHost = (TaskHost)buildEngine;
-                BuildEngineResult result = await taskHost.InternalBuildProjects(projectNames, targetList, projectProperties, undefinePropertiesPerProject, toolsVersions, true /* ask that target outputs are returned in the buildengineresult */, skipNonexistentTargets);
+                BuildEngineResult result = await taskHost.InternalBuildProjects(projectNames, targetList, projectProperties, undefinePropertiesPerProject, toolsVersions, true /* ask that target outputs are returned in the buildengineresult */, skipNonexistentTargets).ConfigureAwait(false);
 
                 bool currentTargetResult = result.Result;
                 IList<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = result.TargetOutputsPerProject;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 328bb76db85..f89f38f3479 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -374,7 +374,7 @@ public async Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDi
             }
 
             // Send the requests off
-            BuildResult[] results = await StartNewBuildRequests(requests);
+            BuildResult[] results = await StartNewBuildRequests(requests).ConfigureAwait(false);
 
             ErrorUtilities.VerifyThrow(requests.Length == results.Length, "# results != # requests");
 
@@ -406,7 +406,7 @@ public async Task BlockOnTargetInProgress(int blockingGlobalRequestId, string bl
             }
             else
             {
-                handle = await handles.ToTask();
+                handle = await handles.ToTask().ConfigureAwait(false);
             }
 
             RestoreOperatingEnvironment();
@@ -772,7 +772,7 @@ private async Task RequestThreadProc(bool setThreadParameters)
                     SetCommonWorkerThreadParameters();
                 }
                 MSBuildEventSource.Log.RequestThreadProcStart();
-                await BuildAndReport();
+                await BuildAndReport().ConfigureAwait(false);
                 MSBuildEventSource.Log.RequestThreadProcStop();
             }
             catch (ThreadAbortException)
@@ -807,7 +807,7 @@ private async Task BuildAndReport()
             // Start the build request            
             try
             {
-                result = await BuildProject();
+                result = await BuildProject().ConfigureAwait(false);
             }
             catch (InvalidProjectFileException ex)
             {
@@ -950,7 +950,7 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
                     CultureInfo savedCulture = CultureInfo.CurrentCulture;
                     CultureInfo savedUICulture = CultureInfo.CurrentUICulture;
 
-                    handle = await handles.ToTask();
+                    handle = await handles.ToTask().ConfigureAwait(false);
 
                     CultureInfo.CurrentCulture = savedCulture;
                     CultureInfo.CurrentUICulture = savedUICulture;
@@ -1155,14 +1155,14 @@ private async Task<BuildResult> BuildProject()
                 (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
             {
                 // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
-                await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+                await BlockOnTargetInProgress(BackEnd.BuildRequest.InvalidGlobalRequestId, null).ConfigureAwait(false);
 
                 // All of the results should now be on this node.
                 ErrorUtilities.VerifyThrow(_requestEntry.RequestConfiguration.ResultsNodeId == _componentHost.BuildParameters.NodeId, "Results for configuration {0} were not retrieved from node {1}", _requestEntry.RequestConfiguration.ConfigurationId, _requestEntry.RequestConfiguration.ResultsNodeId);
             }
 
             // Build the targets
-            BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this, allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
+            BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this, allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token).ConfigureAwait(false);
 
             result = _requestEntry.Request.ProxyTargets == null
                 ? result
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 87604dfba2e..05c684f4686 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -159,13 +159,13 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
 
             // Push targets onto the stack.  This method will reverse their push order so that they
             // get built in the same order specified in the array.
-            await PushTargets(targets, null, baseLookup, false, false, TargetBuiltReason.None);
+            await PushTargets(targets, null, baseLookup, false, false, TargetBuiltReason.None).ConfigureAwait(false);
 
             // Now process the targets
             ITaskBuilder taskBuilder = _componentHost.GetComponent(BuildComponentType.TaskBuilder) as ITaskBuilder;
             try
             {
-                await ProcessTargetStack(taskBuilder);
+                await ProcessTargetStack(taskBuilder).ConfigureAwait(false);
             }
             finally
             {
@@ -276,9 +276,9 @@ async Task<ITargetResult[]> ITargetBuilderCallback.LegacyCallTarget(string[] tar
                         targetToPush.Add(new TargetSpecification(targets[i], taskLocation));
 
                         // We push the targets one at a time to emulate the original CallTarget behavior.
-                        bool pushed = await PushTargets(targetToPush, currentTargetEntry, callTargetLookup, false, true, TargetBuiltReason.None);
+                        bool pushed = await PushTargets(targetToPush, currentTargetEntry, callTargetLookup, false, true, TargetBuiltReason.None).ConfigureAwait(false);
                         ErrorUtilities.VerifyThrow(pushed, "Failed to push any targets onto the stack.  Target: {0} Current Target: {1}", targets[i], currentTargetEntry.Target.Name);
-                        await ProcessTargetStack(taskBuilder);
+                        await ProcessTargetStack(taskBuilder).ConfigureAwait(false);
 
                         if (!_cancellationToken.IsCancellationRequested)
                         {
@@ -322,7 +322,7 @@ async Task<ITargetResult[]> ITargetBuilderCallback.LegacyCallTarget(string[] tar
         /// </summary>
         async Task<BuildResult[]> IRequestBuilderCallback.BuildProjects(string[] projectFiles, Microsoft.Build.Collections.PropertyDictionary<ProjectPropertyInstance>[] properties, string[] toolsVersions, string[] targets, bool waitForResults, bool skipNonexistentTargets)
         {
-            return await _requestBuilderCallback.BuildProjects(projectFiles, properties, toolsVersions, targets, waitForResults, skipNonexistentTargets);
+            return await _requestBuilderCallback.BuildProjects(projectFiles, properties, toolsVersions, targets, waitForResults, skipNonexistentTargets).ConfigureAwait(false);
         }
 
         /// <summary>
@@ -432,7 +432,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
 
                             // Push our after targets, if any.  Our parent is the parent of the target after which we are running.
                             IList<TargetSpecification> afterTargets = _requestEntry.RequestConfiguration.Project.GetTargetsWhichRunAfter(currentTargetEntry.Name);
-                            bool didPushTargets = await PushTargets(afterTargets, currentTargetEntry.ParentEntry, currentTargetEntry.Lookup, currentTargetEntry.ErrorTarget, currentTargetEntry.StopProcessingOnCompletion, TargetBuiltReason.AfterTargets);
+                            bool didPushTargets = await PushTargets(afterTargets, currentTargetEntry.ParentEntry, currentTargetEntry.Lookup, currentTargetEntry.ErrorTarget, currentTargetEntry.StopProcessingOnCompletion, TargetBuiltReason.AfterTargets).ConfigureAwait(false);
 
                             // If we have after targets, the last one to run will inherit the stopProcessing flag and we will reset ours.  If we didn't push any targets, then we shouldn't clear the
                             // flag because it means we are still on the bottom of this CallTarget stack.
@@ -453,7 +453,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             // inherit the stop processing flag and we will reset it.
                             // Our parent is the target before which we run, just like a depends-on target.
                             IList<TargetSpecification> beforeTargets = _requestEntry.RequestConfiguration.Project.GetTargetsWhichRunBefore(currentTargetEntry.Name);
-                            bool pushedTargets = await PushTargets(beforeTargets, currentTargetEntry, currentTargetEntry.Lookup, currentTargetEntry.ErrorTarget, stopProcessingStack, TargetBuiltReason.BeforeTargets);
+                            bool pushedTargets = await PushTargets(beforeTargets, currentTargetEntry, currentTargetEntry.Lookup, currentTargetEntry.ErrorTarget, stopProcessingStack, TargetBuiltReason.BeforeTargets).ConfigureAwait(false);
                             if (beforeTargets.Count != 0 && pushedTargets)
                             {
                                 stopProcessingStack = false;
@@ -462,7 +462,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             // And if we have dependencies to run, push them now.
                             if (dependencies != null)
                             {
-                                await PushTargets(dependencies, currentTargetEntry, currentTargetEntry.Lookup, false, false, TargetBuiltReason.DependsOn);
+                                await PushTargets(dependencies, currentTargetEntry, currentTargetEntry.Lookup, false, false, TargetBuiltReason.DependsOn).ConfigureAwait(false);
                             }
                         }
 
@@ -473,7 +473,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                         // It's possible that our target got pushed onto the stack for one build and had dependencies process, then a re-entrant build started actively building
                         // the target, encountered a legacy CallTarget, pushed new work onto the stack, and yielded back to here. Instead of starting the already-partially-
                         // built target, wait for the other one to complete. Then CheckSkipTarget will skip it here.
-                        bool wasActivelyBuilding = await CompleteOutstandingActiveRequests(currentTargetEntry.Name);
+                        bool wasActivelyBuilding = await CompleteOutstandingActiveRequests(currentTargetEntry.Name).ConfigureAwait(false);
 
                         // It's possible that our target got pushed onto the stack for one build and had its dependencies process, then a re-entrant build came in and
                         // actually built this target while we were waiting, so that by the time we get here, it's already been finished.  In this case, just blow it away.
@@ -486,7 +486,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
 
                             // Execute all of the tasks on this target.
                             MSBuildEventSource.Log.TargetStart(currentTargetEntry.Name);
-                            await currentTargetEntry.ExecuteTarget(taskBuilder, _requestEntry, _projectLoggingContext, _cancellationToken);
+                            await currentTargetEntry.ExecuteTarget(taskBuilder, _requestEntry, _projectLoggingContext, _cancellationToken).ConfigureAwait(false);
                             MSBuildEventSource.Log.TargetStop(currentTargetEntry.Name);
                         }
 
@@ -501,7 +501,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             try
                             {
                                 await PushTargets(errorTargets, currentTargetEntry, currentTargetEntry.Lookup, true,
-                                    false, TargetBuiltReason.None);
+                                    false, TargetBuiltReason.None).ConfigureAwait(false);
                             }
                             catch
                             {
@@ -686,7 +686,7 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
                     if (idOfAlreadyBuildingRequest != _requestEntry.Request.GlobalRequestId)
                     {
                         // Another request elsewhere is building it.  We need to wait.
-                        await _requestBuilderCallback.BlockOnTargetInProgress(idOfAlreadyBuildingRequest, targetSpecification.TargetName, null);
+                        await _requestBuilderCallback.BlockOnTargetInProgress(idOfAlreadyBuildingRequest, targetSpecification.TargetName, null).ConfigureAwait(false);
 
                         // If we come out of here and the target is *still* active, it means the scheduler detected a circular dependency and told us to
                         // continue so we could throw the exception.
@@ -766,7 +766,7 @@ private async Task<bool> CompleteOutstandingActiveRequests(string targetName)
                 {
                     // Another request is building the target. Wait for that, sending partial results
                     // for this request, which may be required to unblock it.
-                    await _requestBuilderCallback.BlockOnTargetInProgress(idOfAlreadyBuildingRequest, targetName, _buildResult);
+                    await _requestBuilderCallback.BlockOnTargetInProgress(idOfAlreadyBuildingRequest, targetName, _buildResult).ConfigureAwait(false);
 
                     return true;
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index dde1f2f56de..064eb701b42 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -505,7 +505,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                 }
 
                                 // We either have some work to do or at least we need to infer outputs from inputs.
-                                bucketResult = await ProcessBucket(taskBuilder, targetLoggingContext, GetTaskExecutionMode(dependencyResult), lookupForInference, lookupForExecution);
+                                bucketResult = await ProcessBucket(taskBuilder, targetLoggingContext, GetTaskExecutionMode(dependencyResult), lookupForInference, lookupForExecution).ConfigureAwait(false);
 
                                 // Now aggregate the result with the existing known results.  There are four rules, assuming the target was not 
                                 // skipped due to being up-to-date:
@@ -819,7 +819,7 @@ private async Task<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, Targe
                     ProjectTargetInstanceChild targetChildInstance = _target.Children[currentTask];
 
                     // Execute the task.
-                    lastResult = await taskBuilder.ExecuteTask(targetLoggingContext, _requestEntry, _targetBuilderCallback, targetChildInstance, mode, lookupForInference, lookupForExecution, _cancellationToken);
+                    lastResult = await taskBuilder.ExecuteTask(targetLoggingContext, _requestEntry, _targetBuilderCallback, targetChildInstance, mode, lookupForInference, lookupForExecution, _cancellationToken).ConfigureAwait(false);
 
                     if (lastResult.ResultCode == WorkUnitResultCode.Failed)
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b5c40b3cc79..e4572fd82aa 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -177,12 +177,12 @@ public async Task<WorkUnitResult> ExecuteTask(TargetLoggingContext loggingContex
             WorkUnitResult taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null);
             if ((mode & TaskExecutionMode.InferOutputsOnly) == TaskExecutionMode.InferOutputsOnly)
             {
-                taskResult = await ExecuteTask(TaskExecutionMode.InferOutputsOnly, inferLookup);
+                taskResult = await ExecuteTask(TaskExecutionMode.InferOutputsOnly, inferLookup).ConfigureAwait(false);
             }
 
             if ((mode & TaskExecutionMode.ExecuteTaskAndGatherOutputs) == TaskExecutionMode.ExecuteTaskAndGatherOutputs)
             {
-                taskResult = await ExecuteTask(TaskExecutionMode.ExecuteTaskAndGatherOutputs, executeLookup);
+                taskResult = await ExecuteTask(TaskExecutionMode.ExecuteTaskAndGatherOutputs, executeLookup).ConfigureAwait(false);
             }
 
             return taskResult;
@@ -328,7 +328,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 for (int i = 0; i < buckets.Count; i++)
                 {
                     // Execute the batch bucket, pass in which bucket we are executing so that we know when to get a new taskId for the bucket.
-                    taskResult = await ExecuteBucket(taskHost, (ItemBucket)buckets[i], mode, lookupHash);
+                    taskResult = await ExecuteBucket(taskHost, (ItemBucket)buckets[i], mode, lookupHash).ConfigureAwait(false);
 
                     aggregateResult = aggregateResult.AggregateResult(taskResult);
 
@@ -440,7 +440,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                             }
                             else
                             {
-                                taskResult = await InitializeAndExecuteTask(taskLoggingContext, bucket, taskIdentityParameters, taskHost, howToExecuteTask);
+                                taskResult = await InitializeAndExecuteTask(taskLoggingContext, bucket, taskIdentityParameters, taskHost, howToExecuteTask).ConfigureAwait(false);
                             }
 
                             if (lookupHash != null)
@@ -658,7 +658,7 @@ private async Task<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext t
             {
                 // UNDONE: Move this and the task host.
                 taskHost.LoggingContext = taskLoggingContext;
-                WorkUnitResult executionResult = await ExecuteInstantiatedTask(_taskExecutionHost, taskLoggingContext, taskHost, bucket, howToExecuteTask);
+                WorkUnitResult executionResult = await ExecuteInstantiatedTask(_taskExecutionHost, taskLoggingContext, taskHost, bucket, howToExecuteTask).ConfigureAwait(false);
 
                 ErrorUtilities.VerifyThrow(executionResult != null, "Unexpected null execution result");
 
@@ -791,7 +791,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
 
                             try
                             {
-                                taskResult = await msbuildTask.ExecuteInternal();
+                                taskResult = await msbuildTask.ExecuteInternal().ConfigureAwait(false);
                             }
                             finally
                             {
@@ -802,7 +802,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     else if (taskType == typeof(CallTarget))
                     {
                         CallTarget callTargetTask = host.TaskInstance as CallTarget;
-                        taskResult = await callTargetTask.ExecuteInternal();
+                        taskResult = await callTargetTask.ExecuteInternal().ConfigureAwait(false);
                     }
                     else
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index fc7de19ac50..3516571eabc 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -929,7 +929,7 @@ public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileN
                 List<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = null;
 
                 // This is really a legacy CallTarget invocation
-                ITargetResult[] results = await _targetBuilderCallback.LegacyCallTarget(targetNames, ContinueOnError, _taskLocation);
+                ITargetResult[] results = await _targetBuilderCallback.LegacyCallTarget(targetNames, ContinueOnError, _taskLocation).ConfigureAwait(false);
 
                 if (returnTargetOutputs)
                 {
@@ -952,7 +952,7 @@ public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileN
             else
             {
                 // Post the request, then yield up the thread.
-                result = await BuildProjectFilesInParallelAsync(projectFileNames, targetNames, globalProperties, undefineProperties, toolsVersion, true /* ask that target outputs are returned in the buildengineresult */, skipNonexistentTargets);
+                result = await BuildProjectFilesInParallelAsync(projectFileNames, targetNames, globalProperties, undefineProperties, toolsVersion, true /* ask that target outputs are returned in the buildengineresult */, skipNonexistentTargets).ConfigureAwait(false);
             }
 
             return result;
@@ -1102,7 +1102,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                 if (projectFileNames.Length == 1 && projectFileNames[0] == null && globalProperties[0] == null && (undefineProperties == null || undefineProperties[0] == null) && toolsVersion[0] == null)
                 {
                     // This is really a legacy CallTarget invocation
-                    ITargetResult[] results = await _targetBuilderCallback.LegacyCallTarget(targetNames, ContinueOnError, _taskLocation);
+                    ITargetResult[] results = await _targetBuilderCallback.LegacyCallTarget(targetNames, ContinueOnError, _taskLocation).ConfigureAwait(false);
 
                     if (returnTargetOutputs)
                     {
@@ -1157,7 +1157,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                         toolsVersion ?? Array.Empty<string>(),
                         targetNames ?? Array.Empty<string>(),
                         waitForResults: true,
-                        skipNonexistentTargets: skipNonexistentTargets);
+                        skipNonexistentTargets: skipNonexistentTargets).ConfigureAwait(false);
 
                     // Even if one of the projects fails to build and therefore has no outputs, it should still have an entry in the results array (albeit with an empty list in it)
                     ErrorUtilities.VerifyThrow(results.Length == projectFileNames.Length, "{0}!={1}.", results.Length, projectFileNames.Length);
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index bd3661c89d2..d0c7a70d94f 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -656,15 +656,15 @@ private void Cancel()
                 // Kick off a task to log the message so that we don't block the calling thread.
                 Task.Run(async delegate
                 {
-                    await _taskExecutionIdle.ToTask(CancelFirstWarningWaitInterval);
+                    await _taskExecutionIdle.ToTask(CancelFirstWarningWaitInterval).ConfigureAwait(false);
                     if (!_taskExecutionIdle.WaitOne(0))
                     {
                         DisplayCancelWaitMessage();
-                        await _taskExecutionIdle.ToTask(CancelWarningWaitInterval);
+                        await _taskExecutionIdle.ToTask(CancelWarningWaitInterval).ConfigureAwait(false);
                         while (!_taskExecutionIdle.WaitOne(0))
                         {
                             DisplayCancelWaitMessage();
-                            await _taskExecutionIdle.ToTask(CancelWarningWaitInterval);
+                            await _taskExecutionIdle.ToTask(CancelWarningWaitInterval).ConfigureAwait(false);
                         }
                     }
                 });
diff --git a/src/Build/Graph/ParallelWorkSet.cs b/src/Build/Graph/ParallelWorkSet.cs
index 15010e607b6..08f9e1944de 100644
--- a/src/Build/Graph/ParallelWorkSet.cs
+++ b/src/Build/Graph/ParallelWorkSet.cs
@@ -150,7 +150,7 @@ private Task CreateProcessorItemTask()
 
                     while (!shouldStopAllWorkers)
                     {
-                        await _semaphore.WaitAsync(_cancellationToken);
+                        await _semaphore.WaitAsync(_cancellationToken).ConfigureAwait(false);
 
                         try
                         {
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 670ba076324..f61c0966a18 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -465,7 +465,7 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
             int totalBytesRead = 0;
             while (totalBytesRead < bytesToRead)
             {
-                int bytesRead = await stream.ReadAsync(buffer.AsMemory(totalBytesRead, bytesToRead - totalBytesRead), CancellationToken.None);
+                int bytesRead = await stream.ReadAsync(buffer.AsMemory(totalBytesRead, bytesToRead - totalBytesRead), CancellationToken.None).ConfigureAwait(false);
                 if (bytesRead == 0)
                 {
                     return totalBytesRead;
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index d6c10b453e0..66522ffc321 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1976,7 +1976,7 @@ public async Task<BuildResult> BuildProjectFileAsync(
                     completion.SetResult(submission.BuildResult);
                 }, null);
 
-                return await completion.Task;
+                return await completion.Task.ConfigureAwait(false);
             }
 
             public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
diff --git a/src/Tasks.UnitTests/DownloadFile_Tests.cs b/src/Tasks.UnitTests/DownloadFile_Tests.cs
index 81a47c77412..797c94e97e0 100644
--- a/src/Tasks.UnitTests/DownloadFile_Tests.cs
+++ b/src/Tasks.UnitTests/DownloadFile_Tests.cs
@@ -300,10 +300,10 @@ public async Task NoRunawayLoop()
             };
 
             var runaway = Task.Run(() => downloadFile.Execute());
-            await Task.Delay(TimeSpan.FromSeconds(1));
+            await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);
             runaway.IsCompleted.ShouldBeTrue("Task did not cancel");
 
-            var result = await runaway;
+            var result = await runaway.ConfigureAwait(false);
             result.ShouldBeFalse(() => _mockEngine.Log);
         }
 
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index c55eedb3974..aee339f8804 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -92,7 +92,7 @@ private async Task<bool> ExecuteAsync()
             {
                 try
                 {
-                    await DownloadAsync(uri, cancellationToken);
+                    await DownloadAsync(uri, cancellationToken).ConfigureAwait(false);
                     break;
                 }
                 catch (OperationCanceledException e) when (e.CancellationToken == cancellationToken)
diff --git a/src/Utilities.UnitTests/ProcessExtensions_Tests.cs b/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
index f549235ca90..3a0d437edb5 100644
--- a/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
@@ -25,7 +25,7 @@ public async Task KillTree()
             Process p = Process.Start(psi); // sleep 10m.
 
             // Verify the process is running.
-            await Task.Delay(500);
+            await Task.Delay(500).ConfigureAwait(false);
             p.HasExited.ShouldBe(false);
 
             // Kill the process.
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
index 85ccedf6f8b..08052351d5d 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestAssemblyRunnerWithAssemblyFixture.cs
@@ -26,7 +26,7 @@ public XunitTestAssemblyRunnerWithAssemblyFixture(ITestAssembly testAssembly,
         protected override async Task AfterTestAssemblyStartingAsync()
         {
             // Let everything initialize
-            await base.AfterTestAssemblyStartingAsync();
+            await base.AfterTestAssemblyStartingAsync().ConfigureAwait(false);
 
             // Go find all the AssemblyFixtureAttributes adorned on the test assembly
             Aggregator.Run(() =>
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
index 6b64d7f4e42..5366fe96d07 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
@@ -27,7 +27,7 @@ public XunitTestClassRunnerWithAssemblyFixture(
 
         protected override async Task AfterTestClassStartingAsync()
         {
-            await base.AfterTestClassStartingAsync();
+            await base.AfterTestClassStartingAsync().ConfigureAwait(false);
 
             Aggregator.Run(() =>
             {
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs
index 42d906d9e97..386008747da 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestFrameworkExecutorWithAssemblyFixture.cs
@@ -16,7 +16,7 @@ public XunitTestFrameworkExecutorWithAssemblyFixture(AssemblyName assemblyName,
         protected override async void RunTestCases(IEnumerable<IXunitTestCase> testCases, IMessageSink executionMessageSink, ITestFrameworkExecutionOptions executionOptions)
         {
             using (var assemblyRunner = new XunitTestAssemblyRunnerWithAssemblyFixture(TestAssembly, testCases, DiagnosticMessageSink, executionMessageSink, executionOptions))
-                await assemblyRunner.RunAsync();
+                await assemblyRunner.RunAsync().ConfigureAwait(false);
         }
     }
 }
