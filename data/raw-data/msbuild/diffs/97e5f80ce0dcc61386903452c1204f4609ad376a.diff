diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 73732f6d3ba..e59c4d7d780 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -33,8 +33,8 @@ public ProjectCacheTests(ITestOutputHelper output)
             _output = output;
             _env = TestEnvironment.Create(output);
 
-            BuildManager.ProjectCacheItems.ShouldBeEmpty();
-            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheItems.IsEmpty));
+            BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
+            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheDescriptors.IsEmpty));
         }
 
         public void Dispose()
@@ -461,10 +461,7 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
             // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
             buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    mockCache,
-                    null,
-                    graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             MockLogger logger;
@@ -477,8 +474,6 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             AssertCacheBuild(graph, testData, mockCache, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
@@ -489,10 +484,7 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
             var graph = testData.CreateGraph(_env);
             var mockCache = new InstanceMockCache(testData);
 
-            var projectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                null,
-                graph);
+            var projectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache);
 
             // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
             buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
@@ -516,7 +508,6 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
                 }
             }
 
-            logger.FullLog.ShouldContain("Static graph based");
 
             AssertCacheBuild(graph, testData, mockCache, logger, nodesToBuildResults, targets: null);
         }
@@ -549,28 +540,6 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
             logger.FullLog.ShouldContain($"EntryPoint: {graph.GraphRoots.First().ProjectReferences.First().ProjectInstance.FullPath}");
         }
 
-        [Fact]
-        public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
-        {
-            var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]?>
-                {
-                    {1, Array.Empty<int>()}
-                },
-                extraContentPerProjectNumber: new Dictionary<int, string>()
-                {
-                    {1, $"<PropertyGroup> <ProjectDependency>{Guid.NewGuid()}</ProjectDependency> </PropertyGroup>"}
-                });
-
-            (_, _, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) = BuildGraphVsScenario(testData, assertBuildResults: false);
-
-            nodesToBuildResults.ShouldHaveSingleItem();
-
-            var buildResult = nodesToBuildResults.First().Value;
-            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-            buildResult.Exception.Message.ShouldContain("Project cache service does not support solution only dependencies when running under Visual Studio.");
-        }
-
         private (MockLogger logger, ProjectGraph projectGraph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphVsScenario(
             GraphCacheResponse testData,
             BuildParameters? buildParameters = null,
@@ -598,14 +567,14 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
                     ? new BuildParameters()
                     : new BuildParameters(buildParameters, resetEnvironment: true);
 
-                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+                BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
 
                 graph = testData.CreateGraph(_env);
 
-                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+                BuildManager.ProjectCacheDescriptors.ShouldHaveSingleItem();
 
                 // VS sets this global property on every project it builds.
-                var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
+                string solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
                 using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
                 {
@@ -613,15 +582,14 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
 
                     foreach (var node in graph.ProjectNodesTopologicallySorted)
                     {
-                        var buildResult = buildSession.BuildProjectFile(
+                        BuildResult buildResult = buildSession.BuildProjectFile(
                             node.ProjectInstance.FullPath,
                             globalProperties:
                                 new Dictionary<string, string>
                                 {
-                                { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
-                                { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
-                                { PropertyNames.InnerBuildProperty, "TheInnerBuildProperty"},
-                                { "TheInnerBuildProperty", "FooBar"},
+                                    { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
+                                    { PropertyNames.InnerBuildProperty, "TheInnerBuildProperty"},
+                                    { "TheInnerBuildProperty", "FooBar"},
                                 });
 
                         if (assertBuildResults)
@@ -635,8 +603,6 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
 
                 if (assertBuildResults)
                 {
-                    logger.FullLog.ShouldContain("Visual Studio Workaround based");
-
                     foreach (var node in graph.ProjectNodes)
                     {
                         var projectPath = node.ProjectInstance.FullPath;
@@ -656,7 +622,7 @@ public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
 
             return (logger, graph, nodesToBuildResults);
@@ -696,8 +662,6 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
-            var designTimeBuildProperty = $"<PropertyGroup> <{DesignTimeProperties.DesignTimeBuild}>true</{DesignTimeProperties.DesignTimeBuild}> </PropertyGroup>";
-
             // Use a few references to stress test the design time build workaround logic.
             var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount()).ToArray();
 
@@ -705,9 +669,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                 graphEdges: new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
-                },
-                nonCacheMissResults: null,
-                extraContentPerProjectNumber: referenceNumbers.ToDictionary(r => r, _ => designTimeBuildProperty));
+                });
 
             try
             {
@@ -722,7 +684,11 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                 var graph = testData.CreateGraph(_env);
 
                 var rootNode = graph.GraphRoots.First();
-                var globalProperties = new Dictionary<string, string> { { "SolutionPath", rootNode.ProjectInstance.FullPath } };
+
+                var globalProperties = new Dictionary<string, string>
+                {
+                    { DesignTimeProperties.DesignTimeBuild, "true" },
+                };
 
                 MockLogger logger;
                 using (var buildSession = new Helpers.BuildManagerSession(_env))
@@ -731,9 +697,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
 
                     // Build references in parallel.
                     var referenceBuildTasks = rootNode.ProjectReferences.Select(
-                        r => buildSession.BuildProjectFileAsync(
-                            r.ProjectInstance.FullPath,
-                            globalProperties: globalProperties));
+                        r => buildSession.BuildProjectFileAsync(r.ProjectInstance.FullPath, globalProperties: globalProperties));
 
                     foreach (var task in referenceBuildTasks)
                     {
@@ -746,23 +710,16 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                         .ShouldHaveSucceeded();
                 }
 
-                logger.FullLog.ShouldContain("Visual Studio Workaround based");
-
-                // Design time builds should not initialize the plugin.
-                logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
-
-                // Cache doesn't get initialized and queried.
+                // Cache doesn't get initialized, queried, or disposed.
                 logger.FullLog.ShouldNotContain("BeginBuildAsync");
                 logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
                 logger.FullLog.ShouldNotContain("Querying project cache for project");
-
-                // Cache does get disposed.
-                StringShouldContainSubstring(logger.FullLog, "EndBuildAsync", 1);
+                logger.FullLog.ShouldNotContain("EndBuildAsync");
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
         }
 
@@ -788,10 +745,7 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
             var buildParameters = new BuildParameters
             {
                 MaxNodeCount = Environment.ProcessorCount,
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    mockCache,
-                    null,
-                    graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             if (disableInprocNodeViaEnvironmentVariable)
@@ -813,8 +767,6 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             logger.AssertMessageCount("MSB4274", 1);
         }
 
@@ -828,18 +780,12 @@ private void AssertCacheBuild(
         {
             if (instanceMockCache != null)
             {
-                mockLogger.FullLog.ShouldContain("Instance based");
-                mockLogger.FullLog.ShouldNotContain("Assembly path based");
-
                 instanceMockCache.BeginBuildCalled.ShouldBeTrue();
                 instanceMockCache.Requests.Count.ShouldBe(graph.ProjectNodes.Count);
                 instanceMockCache.EndBuildCalled.ShouldBeTrue();
             }
             else
             {
-                mockLogger.FullLog.ShouldContain("Assembly path based");
-                mockLogger.FullLog.ShouldNotContain("Instance based");
-
                 mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
                 Regex.Matches(mockLogger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for").Count.ShouldBe(graph.ProjectNodes.Count);
                 mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
@@ -941,10 +887,7 @@ public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters build
                     </Project>".Cleanup());
 
             var mockCache = new InstanceMockCache();
-            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                new[] {new ProjectGraphEntryPoint(project1.Path)},
-                null);
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache);
 
             MockLogger logger;
             using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
@@ -976,10 +919,7 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             var buildParameters = new BuildParameters
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                    SamplePluginAssemblyPath.Value,
-                    graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
-                    null)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(SamplePluginAssemblyPath.Value)
             };
 
             MockLogger logger;
@@ -992,7 +932,7 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Explicit entry-point based");
+            logger.FullLog.ShouldContain($"Loading the following project cache plugin: {AssemblyMockCache}");
 
             AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
@@ -1019,8 +959,6 @@ public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
 
             graphResult.ShouldHaveSucceeded();
 
-            logger.FullLog.ShouldContain("Static graph based");
-
             AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
@@ -1061,7 +999,7 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
 
             var buildParameters = new BuildParameters
             {
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache)
             };
 
             MockLogger logger;
@@ -1083,8 +1021,9 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
         }
 
         [Fact]
-        public void GraphBuildErrorsIfMultiplePluginsAreFound()
+        public void MultiplePlugins()
         {
+            // One from the project, one from BuildParameters.
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 new Dictionary<int, int[]?>
@@ -1093,23 +1032,29 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()
                 },
                 extraContentForAllNodes: @$"
 <ItemGroup>
-   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+   <{ItemTypeNames.ProjectCachePlugin} Include='{SamplePluginAssemblyPath.Value}' />
 </ItemGroup>
 ");
+            var mockCache = new InstanceMockCache();
+
+            var buildParameters =  new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache),
+            };
 
             MockLogger logger;
             GraphBuildResult graphResult;
-            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
             
-            graphResult.ShouldHaveFailed("A single project cache plugin must be specified but multiple where found:");
+            graphResult.ShouldHaveSucceeded();
         }
 
         [Fact]
-        public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
+        public void NotAllNodeDefineAPlugin()
         {
             var graph = Helpers.CreateProjectGraph(
                 _env,
@@ -1123,7 +1068,7 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                         2,
                         @$"
 <ItemGroup>
-   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+   <{ItemTypeNames.ProjectCachePlugin} Include='{SamplePluginAssemblyPath.Value}' />
 </ItemGroup>
 "
                     }
@@ -1136,8 +1081,8 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
-            
-            graphResult.ShouldHaveFailed("When any static graph node defines a project cache, all nodes must define the same project cache.");
+
+            graphResult.ShouldHaveSucceeded();
         }
 
         public static IEnumerable<object[]> CacheExceptionLocationsTestData
@@ -1185,10 +1130,7 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
                     new BuildParameters
                     {
                         UseSynchronousLogging = true,
-                        ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                            SamplePluginAssemblyPath.Value,
-                            new[] {new ProjectGraphEntryPoint(project.Path)},
-                            null)
+                        ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(SamplePluginAssemblyPath.Value)
                     });
 
                 logger = buildSession.Logger;
@@ -1285,6 +1227,8 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
+            const ErrorLocations exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
+
             SetEnvironmentForErrorLocations(errorLocations, errorKind);
 
             var graph = Helpers.CreateProjectGraph(
@@ -1320,36 +1264,51 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocati
             {
                 buildResult = buildSession.BuildGraph(graph);
 
-                logger.FullLog.ShouldContain("Loading the following project cache plugin:");
-
-                // Static graph build initializes and tears down the cache plugin so all cache plugin exceptions should end up in the GraphBuildResult
-                buildResult.ShouldHaveFailed();
-
-                buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
+                if (!errorLocations.HasFlag(ErrorLocations.Constructor))
+                {
+                    logger.FullLog.ShouldContain("Loading the following project cache plugin:");
+                }
 
-                if (errorKind == ErrorKind.Exception)
+                // EndBuildAsync isn't until the build manager is shut down, so the build result itself is successful if that's the only error.
+                if (errorLocations == ErrorLocations.EndBuildAsync)
                 {
-                    buildResult.Exception.InnerException!.ShouldNotBeNull();
-                    buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    buildResult.ShouldHaveSucceeded();
                 }
+                else
+                {
+                    buildResult.ShouldHaveFailed();
 
-                logger.FullLog.ShouldNotContain("Cache plugin exception from");
+                    buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
 
-                if (errorKind == ErrorKind.LoggedError)
-                {
-                    logger.FullLog.ShouldContain("Cache plugin logged error from");
+                    if (errorKind == ErrorKind.Exception)
+                    {
+                        buildResult.Exception.InnerException!.ShouldNotBeNull();
+                        buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    }
+
+                    logger.FullLog.ShouldNotContain("Cache plugin exception from");
+
+                    if (errorKind == ErrorKind.LoggedError)
+                    {
+                        logger.FullLog.ShouldContain("Cache plugin logged error from");
+                    }
                 }
             }
             finally
             {
-                // Since all plugin exceptions during a graph build end up in the GraphBuildResult, they should not get rethrown by BM.EndBuild
-                Should.NotThrow(() => buildSession.Dispose());
+                if (errorLocations.HasFlag(ErrorLocations.EndBuildAsync)
+                    && (exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) == 0)
+                {
+                    Should.Throw<ProjectCacheException>(() => buildSession.Dispose());
+                }
+                else
+                {
+                    Should.NotThrow(() => buildSession.Dispose());
+                }
             }
 
             logger.BuildFinishedEvents.First().Succeeded.ShouldBeFalse();
 
-            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
-
             if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) != 0)
             {
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
@@ -1390,19 +1349,12 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                 UseSynchronousLogging = true
             };
 
-            MockLogger logger;
-            GraphBuildResult graphResult;
-            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
-            {
-                logger = buildSession.Logger;
-                graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
-            }
+            var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            GraphBuildResult graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
 
-            graphResult.ShouldHaveFailed();
-            graphResult.Exception.InnerException!.ShouldNotBeNull();
-            graphResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            Should.Throw<ProjectCacheException>(() => buildSession.Dispose()).InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
 
-            StringShouldContainSubstring(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
+            StringShouldContainSubstring(buildSession.Logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
         }
 
         [Theory]
@@ -1449,10 +1401,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
             var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    cache,
-                    entryPoints: null,
-                    graph),
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(cache),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
             };
@@ -1504,7 +1453,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
-                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+                BuildManager.ProjectCacheDescriptors.ShouldBeEmpty();
 
                 var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
 
@@ -1518,11 +1467,9 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
 
                 var graph = testData.CreateGraph(_env);
 
-                // Even though the assembly cache is discovered, we'll be overriding it with a descriptor based cache.
-                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+                BuildManager.ProjectCacheDescriptors.ShouldHaveSingleItem();
 
-                var solutionConfigurationGlobalProperty =
-                    CreateSolutionConfigurationProperty(graph.ProjectNodes);
+                var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
                 var buildParameters = new BuildParameters
                 {
@@ -1539,13 +1486,12 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
 
                     foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
                     {
-                        var buildResultTask = buildSession.BuildProjectFileAsync(
+                        Task<BuildResult> buildResultTask = buildSession.BuildProjectFileAsync(
                             node.ProjectInstance.FullPath,
                             globalProperties:
                             new Dictionary<string, string>
                             {
-                            { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
-                            { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
+                                { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
                             });
 
                         buildResultTasks.Add(buildResultTask);
@@ -1556,21 +1502,15 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         buildResultTask.Result.ShouldHaveSucceeded();
                     }
 
-                    buildSession.BuildProjectFile(
-                            graph.GraphRoots.First().ProjectInstance.FullPath,
-                            globalProperties:
-                            new Dictionary<string, string> { { "SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath } })
-                        .ShouldHaveSucceeded();
+                    buildSession.BuildProjectFile(graph.GraphRoots.First().ProjectInstance.FullPath).ShouldHaveSucceeded();
                 }
 
                 StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
-
-                logger.FullLog.ShouldContain("Visual Studio Workaround based");
             }
             finally
             {
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
-                BuildManager.ProjectCacheItems.Clear();
+                BuildManager.ProjectCacheDescriptors.Clear();
             }
         }
 
@@ -1595,10 +1535,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
-                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                    cache,
-                    entryPoints: null,
-                    graph),
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(cache),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
             };
@@ -1676,9 +1613,7 @@ public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
                                         new ProxyTargets(new Dictionary<string, string> {{proxyTarget, cacheHitTarget}})));
                             }
                         }
-                    },
-                    projectPaths.Select(p => new ProjectGraphEntryPoint(p)).ToArray(),
-                    projectGraph: null),
+                    }),
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount()
             };
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 606d1008930..6da14bb6c7d 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -20,7 +20,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -46,8 +45,10 @@ namespace Microsoft.Build.Execution
     [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Refactoring at the end of Beta1 is not appropriate.")]
     public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
     {
-        // TODO: Remove this when VS gets updated to setup project cache plugins.
-        internal static ConcurrentDictionary<string, ProjectCacheItem> ProjectCacheItems { get; } = new ConcurrentDictionary<string, ProjectCacheItem>();
+        // TODO: Figure out a more elegant way to do this.
+        //       The rationale for this is that we can detect during design-time builds in the Evaluator (which populates this) that the project cache will be used so that we don't
+        //       need to evaluate the project at build time just to figure that out, which would regress perf for scenarios which don't use the project cache.
+        internal static ConcurrentDictionary<ProjectCacheDescriptor, ProjectCacheDescriptor> ProjectCacheDescriptors { get; } = new (ProjectCacheDescriptorEqualityComparer.Instance);
 
         /// <summary>
         /// The object used for thread-safe synchronization of static members.
@@ -131,6 +132,11 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private bool _shuttingDown;
 
+        /// <summary>
+        /// CancellationTokenSource to use for async operations. This will be cancelled when we are shutting down to cancel any async operations.
+        /// </summary>
+        private CancellationTokenSource _executionCancellationTokenSource;
+
         /// <summary>
         /// The current state of the BuildManager.
         /// </summary>
@@ -234,11 +240,6 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private ActionBlock<Action> _workQueue;
 
-        /// <summary>
-        /// A cancellation token source used to cancel graph build scheduling
-        /// </summary>
-        private CancellationTokenSource _graphSchedulingCancellationSource;
-
         /// <summary>
         /// Flag indicating we have disposed.
         /// </summary>
@@ -250,7 +251,8 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         private DateTime _instantiationTimeUtc;
 
         private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
-        private Task<ProjectCacheService> _projectCacheService;
+
+        private ProjectCacheService _projectCacheService;
 
 #if DEBUG
         /// <summary>
@@ -483,6 +485,8 @@ public void BeginBuild(BuildParameters parameters)
                     Strings.EnableDiagnostics();
                 }
 
+                _executionCancellationTokenSource = new CancellationTokenSource();
+
                 _overallBuildSuccess = true;
 
                 // Clone off the build parameters.
@@ -510,11 +514,10 @@ public void BeginBuild(BuildParameters parameters)
 
                 InitializeCaches();
 
-                if (_buildParameters.ProjectCacheDescriptor != null)
-                {
-                    // TODO: Implement cancellation.
-                    InitializeProjectCacheService(_buildParameters.ProjectCacheDescriptor, CancellationToken.None);
-                }
+                _projectCacheService = new ProjectCacheService(
+                    this,
+                    loggingService,
+                    _buildParameters.ProjectCacheDescriptor);
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
                 _scheduler = ((IBuildComponentHost)this).GetComponent(BuildComponentType.Scheduler) as IScheduler;
@@ -666,26 +669,6 @@ private static void AttachDebugger()
             }
         }
 
-        private void InitializeProjectCacheService(
-            ProjectCacheDescriptor pluginDescriptor,
-            CancellationToken cancellationToken)
-        {
-            Debug.Assert(Monitor.IsEntered(_syncLock));
-
-            if (_projectCacheService != null)
-            {
-                ErrorUtilities.ThrowInternalError("Only one project cache plugin may be set on the BuildManager during a begin / end build session");
-            }
-
-            LogMessage(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LoadingProjectCachePlugin", pluginDescriptor.GetDetailedDescription()));
-
-            _projectCacheService = ProjectCacheService.FromDescriptorAsync(
-                pluginDescriptor,
-                this,
-                ((IBuildComponentHost) this).LoggingService,
-                cancellationToken);
-        }
-
         /// <summary>
         /// Cancels all outstanding submissions asynchronously.
         /// </summary>
@@ -917,10 +900,7 @@ public void EndBuild()
                     _workQueue.Completion.Wait();
                 }
 
-                // Stop the graph scheduling thread(s)
-                _graphSchedulingCancellationSource?.Cancel();
-
-                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();
+                Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
 
                 ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0, "All submissions not yet complete.");
                 ErrorUtilities.VerifyThrow(_activeNodes.Count == 0, "All nodes not yet shut down.");
@@ -930,7 +910,7 @@ public void EndBuild()
                     SerializeCaches();
                 }
 
-                projectCacheShutdown?.Wait();
+                projectCacheDispose.Wait();
 
 #if DEBUG
                 if (_projectStartedEvents.Count != 0)
@@ -1246,7 +1226,16 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     shuttingDown = _shuttingDown;
                     if (!shuttingDown)
                     {
-                        if (ProjectCacheIsPresent())
+                        if (BuildEnvironmentHelper.Instance.RunningInVisualStudio && !ProjectCacheDescriptors.IsEmpty)
+                        {
+                            _projectCacheService.InitializePluginsForVsScenario(
+                                ProjectCacheDescriptors.Values,
+                                submission,
+                                resolvedConfiguration,
+                                _executionCancellationTokenSource.Token);
+                        }
+
+                        if (_projectCacheService.ShouldUseCache(resolvedConfiguration))
                         {
                             IssueCacheRequestForBuildSubmission(new CacheRequest(submission, resolvedConfiguration));
                         }
@@ -1258,11 +1247,6 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     }
                 }
             }
-            catch (ProjectCacheException ex)
-            {
-                ErrorUtilities.VerifyThrow(resolvedConfiguration is not null, "Cannot call project cache without having BuildRequestConfiguration");
-                CompleteSubmissionWithException(submission, resolvedConfiguration, ex);
-            }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
                 if (resolvedConfiguration is not null)
@@ -1286,28 +1270,6 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             }
         }
 
-        bool ProjectCacheIsPresent()
-        {
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            // TODO: no need to access the service when there's no design time builds.
-            var projectCacheService = GetProjectCacheService();
-
-            if (projectCacheService != null && projectCacheService.DesignTimeBuildsDetected)
-            {
-                return false;
-            }
-
-            return
-                projectCacheService != null ||
-                _buildParameters.ProjectCacheDescriptor != null ||
-                ProjectCachePresentViaVisualStudioWorkaround();
-        }
-
-        private static bool ProjectCachePresentViaVisualStudioWorkaround()
-        {
-            return BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Any();
-        }
-
         // Cache requests on configuration N do not block future build submissions depending on configuration N.
         // It is assumed that the higher level build orchestrator (static graph scheduler, VS, quickbuild) submits a
         // project build request only when its references have finished building.
@@ -1319,17 +1281,7 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
             {
                 try
                 {
-                    var projectCacheService = GetProjectCacheService();
-
-                    ErrorUtilities.VerifyThrow(
-                        projectCacheService != null,
-                        "This method should not get called if there's no project cache.");
-
-                    ErrorUtilities.VerifyThrow(
-                        !projectCacheService.DesignTimeBuildsDetected,
-                        "This method should not get called if design time builds are detected.");
-
-                    projectCacheService.PostCacheRequest(cacheRequest);
+                    _projectCacheService.PostCacheRequest(cacheRequest, _executionCancellationTokenSource.Token);
                 }
                 catch (Exception e)
                 {
@@ -1338,57 +1290,6 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
             });
         }
 
-        private ProjectCacheService GetProjectCacheService()
-        {
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio();
-
-            try
-            {
-                return _projectCacheService?.Result;
-            }
-            catch(Exception ex)
-            {
-                if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
-                {
-                    ex = ae.InnerExceptions.First();
-                }
-
-                // These are exceptions thrown during project cache startup (assembly load issues or cache BeginBuild exceptions).
-                // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.
-                Interlocked.Exchange(ref _projectCacheService, null);
-                throw ex;
-            }
-        }
-
-        private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio()
-        {
-            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&
-                ProjectCacheItems.Any() &&
-                _projectCacheService == null &&
-                _buildParameters.ProjectCacheDescriptor == null)
-            {
-                lock (_syncLock)
-                {
-                    if (_projectCacheService != null)
-                    {
-                        return;
-                    }
-
-                    if (ProjectCacheItems.Count != 1)
-                    {
-                        ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                            "OnlyOneCachePluginMustBeSpecified",
-                            string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
-                    }
-
-                    var projectCacheItem = ProjectCacheItems.First().Value;
-
-                    InitializeProjectCacheService(ProjectCacheDescriptor.FromVisualStudioWorkaround(projectCacheItem), CancellationToken.None);
-                }
-            }
-        }
-
         /// <summary>
         /// This method adds the graph build request in the specified submission to the set of requests being handled by the scheduler.
         /// </summary>
@@ -1411,12 +1312,6 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                         return;
                     }
 
-                    // Lazily create a cancellation token source to be used for all graph scheduling tasks running from this build manager.
-                    if (_graphSchedulingCancellationSource == null)
-                    {
-                        _graphSchedulingCancellationSource = new CancellationTokenSource();
-                    }
-
                     // Do the scheduling in a separate thread to unblock the calling thread
                     Task.Factory.StartNew(
                         () =>
@@ -1430,7 +1325,7 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                                 HandleSubmissionException(submission, ex);
                             }
                         },
-                        _graphSchedulingCancellationSource.Token,
+                        _executionCancellationTokenSource.Token,
                         TaskCreationOptions.LongRunning,
                         TaskScheduler.Default);
                 }
@@ -1957,13 +1852,13 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+                // Kick off project cache initialization frontloading
+                Task.Run(() => _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token));
+
                 var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
                 DumpGraph(projectGraph, targetListTask);
 
-                using DisposablePluginService cacheService = cacheServiceTask.Result;
-
                 resultsPerNode = BuildGraph(projectGraph, targetListTask, submission.BuildRequestData);
             }
             else
@@ -2079,104 +1974,6 @@ GraphBuildRequestData graphBuildRequestData
             return resultsPerNode;
         }
 
-        private DisposablePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
-        {
-            // TODO: Consider allowing parallel graph submissions, each with its own separate cache plugin. Right now the second graph submission with a cache will fail.
-
-            if (_buildParameters.ProjectCacheDescriptor != null)
-            {
-                // Build parameter specified project cache takes precedence.
-                return new DisposablePluginService(null);
-            }
-
-            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(
-                n => n,
-                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)
-                    .Select(
-                        i =>
-                        {
-                            var metadataDictionary = i.Metadata.ToDictionary(
-                                m => ((IKeyed) m).Key,
-                                m => ((IValued) m).EscapedValue);
-
-                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);
-
-                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
-
-                            return projectCacheItem;
-                        })
-                    .ToArray());
-
-            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();
-
-            if (cacheItems.Count == 0)
-            {
-                return new DisposablePluginService(null);
-            }
-
-            if (cacheItems.Count != 1)
-            {
-                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                    "OnlyOneCachePluginMustBeSpecified",
-                    string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
-            }
-
-            var nodesWithoutCacheItems = nodeToCacheItems.Where(kvp => kvp.Value.Length == 0).ToArray();
-
-            if (nodesWithoutCacheItems.Length > 0)
-            {
-                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
-                    "NotAllNodesDefineACacheItem",
-                    ItemTypeNames.ProjectCachePlugin,
-                    string.Join(", ", nodesWithoutCacheItems.Select(kvp => kvp.Key.ProjectInstance.FullPath)));
-            }
-
-            var cacheItem = cacheItems.First();
-
-            lock (_syncLock)
-            {
-                InitializeProjectCacheService(
-                    ProjectCacheDescriptor.FromAssemblyPath(
-                        cacheItem.PluginPath,
-                        entryPoints: null,
-                        projectGraph,
-                        cacheItem.PluginSettings),
-                    _graphSchedulingCancellationSource.Token);
-            }
-
-            return new DisposablePluginService(this);
-        }
-
-        private class DisposablePluginService : IDisposable
-        {
-            private readonly BuildManager _buildManager;
-
-            public DisposablePluginService(BuildManager buildManager)
-            {
-                _buildManager = buildManager;
-            }
-
-            public void Dispose()
-            {
-                if (_buildManager == null)
-                {
-                    return;
-                }
-
-                lock (_buildManager._syncLock)
-                {
-                    try
-                    {
-                        _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
-                    }
-                    finally
-                    {
-                        _buildManager._projectCacheService = null;
-                    }
-                }
-            }
-        }
-
         /// <summary>
         /// Asks the nodeManager to tell the currently connected nodes to shut down and sets a flag preventing all non-shutdown-related packets from
         /// being processed.
@@ -2186,6 +1983,7 @@ private void ShutdownConnectedNodes(bool abort)
             lock (_syncLock)
             {
                 _shuttingDown = true;
+                _executionCancellationTokenSource.Cancel();
 
                 // If we are aborting, we will NOT reuse the nodes because their state may be compromised by attempts to shut down while the build is in-progress.
                 _nodeManager.ShutdownConnectedNodes(!abort && _buildParameters.EnableNodeReuse);
@@ -2253,6 +2051,8 @@ private void Reset()
             _nodeManager = null;
 
             _shuttingDown = false;
+            _executionCancellationTokenSource.Dispose();
+            _executionCancellationTokenSource = null;
             _nodeConfiguration = null;
             _buildSubmissions.Clear();
             _graphBuildSubmissions.Clear();
@@ -2260,7 +2060,6 @@ private void Reset()
             _scheduler.Reset();
             _scheduler = null;
             _workQueue = null;
-            _graphSchedulingCancellationSource = null;
             _projectCacheService = null;
             _acquiredProjectRootElementCacheFromProjectInstance = false;
 
@@ -2547,6 +2346,7 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
             _shuttingDown = true;
+            _executionCancellationTokenSource.Cancel();
             ErrorUtilities.VerifyThrow(_activeNodes.Contains(node), "Unexpected shutdown from node {0} which shouldn't exist.", node);
             _activeNodes.Remove(node);
 
@@ -3157,10 +2957,10 @@ private void Dispose(bool disposing)
                             _workQueue = null;
                         }
 
-                        if (_graphSchedulingCancellationSource != null)
+                        if (_executionCancellationTokenSource != null)
                         {
-                            _graphSchedulingCancellationSource.Cancel();
-                            _graphSchedulingCancellationSource = null;
+                            _executionCancellationTokenSource.Cancel();
+                            _executionCancellationTokenSource = null;
                         }
 
                         if (_noActiveSubmissionsEvent != null)
@@ -3276,6 +3076,7 @@ private void CancelAndMarkAsFailure()
             // CancelAllSubmissions also ends up setting _shuttingDown and _overallBuildSuccess but it does so in a separate thread to avoid deadlocks.
             // This might cause a race with the first builds which might miss the shutdown update and succeed instead of fail.
             _shuttingDown = true;
+            _executionCancellationTokenSource.Cancel();
             _overallBuildSuccess = false;
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1fec6f1c510..fca7476b2d5 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -791,10 +791,8 @@ public string OutputResultsCacheFile
         public bool LowPriority { get; set; }
 
         /// <summary>
-        /// If set, the BuildManager will query all
-        /// incoming <see cref="BuildSubmission"/> requests against the specified project cache.
-        /// Any <see cref="GraphBuildSubmission"/> requests will also use this project cache instead of
-        /// the potential project caches described in graph node's evaluations.
+        /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
+        /// in addition to any potential project caches described in each project.
         /// </summary>
         public ProjectCacheDescriptor ProjectCacheDescriptor { get; set; }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
index 6ac1b6b6b2a..c5751c5875e 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
@@ -2,130 +2,34 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
-using System.Linq;
-using Microsoft.Build.Graph;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     public class ProjectCacheDescriptor
     {
-        /// <summary>
-        ///     The path to the assembly containing the project cache plugin.
-        /// </summary>
-        public string? PluginAssemblyPath { get; }
-
-        /// <summary>
-        ///     The entry points with which the plugin will be initialized.
-        /// </summary>
-        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }
-
-        /// <summary>
-        ///     The graph with which the plugin will be initialized.
-        /// </summary>
-        public ProjectGraph? ProjectGraph { get; }
-
-        public IReadOnlyDictionary<string, string> PluginSettings { get; }
-
-        public ProjectCachePluginBase? PluginInstance { get; }
-
-        internal bool VsWorkaround { get; }
-
         private ProjectCacheDescriptor(
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings)
-        {
-            ErrorUtilities.VerifyThrowArgument(
-                (entryPoints == null) ^ (projectGraph == null),
-                "EitherEntryPointsOrTheProjectGraphIsSet");
-
-            EntryPoints = entryPoints;
-            ProjectGraph = projectGraph;
-            PluginSettings = pluginSettings ?? new Dictionary<string, string>();
-        }
-
-        private ProjectCacheDescriptor(
-            string pluginAssemblyPath,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
+            string? pluginAssemblyPath,
+            IReadOnlyDictionary<string, string>? pluginSettings,
+            ProjectCachePluginBase? pluginInstance)
         {
             PluginAssemblyPath = pluginAssemblyPath;
-        }
-
-        private ProjectCacheDescriptor(
-            ProjectCachePluginBase pluginInstance,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
-        {
+            PluginSettings = pluginSettings ?? new Dictionary<string, string>(0);
             PluginInstance = pluginInstance;
         }
 
-        private ProjectCacheDescriptor(ProjectCacheItem projectCacheItem)
-        {
-            VsWorkaround = true;
-            PluginAssemblyPath = projectCacheItem.PluginPath;
-            PluginSettings = projectCacheItem.PluginSettings;
-        }
-
-        // TODO: remove after we change VS to set the cache descriptor via build parameters.
-        internal static ProjectCacheDescriptor FromVisualStudioWorkaround(ProjectCacheItem projectCacheItem)
-        {
-            return new ProjectCacheDescriptor(projectCacheItem);
-        }
-
-        public static ProjectCacheDescriptor FromAssemblyPath(
-            string pluginAssemblyPath,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings = null)
-        {
-            return new ProjectCacheDescriptor(pluginAssemblyPath, entryPoints, projectGraph, pluginSettings);
-        }
-
-        public static ProjectCacheDescriptor FromInstance(
-            ProjectCachePluginBase pluginInstance,
-            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
-            ProjectGraph? projectGraph,
-            IReadOnlyDictionary<string, string>? pluginSettings = null)
-        {
-            return new ProjectCacheDescriptor(pluginInstance, entryPoints, projectGraph, pluginSettings);
-        }
-
-        public string GetDetailedDescription()
-        {
-            var loadStyle = PluginInstance != null
-                ? $"Instance based: {PluginInstance.GetType().AssemblyQualifiedName}"
-                : $"Assembly path based: {PluginAssemblyPath}";
+        /// <summary>
+        /// Gets the path to the assembly containing the project cache plugin.
+        /// </summary>
+        public string? PluginAssemblyPath { get; }
 
-            var entryPointStyle = EntryPoints != null
-                ? "Explicit entry-point based"
-                : ProjectGraph != null
-                    ? "Static graph based"
-                    : "Visual Studio Workaround based";
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
 
-            var entryPoints = EntryPoints != null
-                ? string.Join(
-                    "\n",
-                    EntryPoints.Select(e => $"{e.ProjectFile} {{{FormatGlobalProperties(e.GlobalProperties)}}}"))
-                : ProjectGraph != null
-                    ? string.Join(
-                        "\n",
-                        ProjectGraph!.EntryPointNodes.Select(
-                            n =>
-                                $"{n.ProjectInstance.FullPath} {{{FormatGlobalProperties(n.ProjectInstance.GlobalProperties)}}}"))
-                    : "Solution file";
+        public ProjectCachePluginBase? PluginInstance { get; }
 
-            return $"{loadStyle}\nEntry-point style: {entryPointStyle}\nEntry-points:\n{entryPoints}";
+        public static ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, IReadOnlyDictionary<string, string>? pluginSettings = null)
+            => new ProjectCacheDescriptor(pluginAssemblyPath, pluginSettings, pluginInstance: null);
 
-            static string FormatGlobalProperties(IDictionary<string, string>? globalProperties)
-            {
-                return globalProperties == null
-                    ? string.Empty
-                    : string.Join(", ", globalProperties.Select(gp => $"{gp.Key}={gp.Value}"));
-            }
-        }
+        public static ProjectCacheDescriptor FromInstance(ProjectCachePluginBase pluginInstance, IReadOnlyDictionary<string, string>? pluginSettings = null)
+            => new ProjectCacheDescriptor(pluginAssemblyPath: null, pluginSettings, pluginInstance);
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
new file mode 100644
index 00000000000..6eef723d25d
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
@@ -0,0 +1,62 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    internal sealed class ProjectCacheDescriptorEqualityComparer : IEqualityComparer<ProjectCacheDescriptor>
+    {
+        private ProjectCacheDescriptorEqualityComparer()
+        {
+        }
+
+        public static ProjectCacheDescriptorEqualityComparer Instance { get; } = new ProjectCacheDescriptorEqualityComparer();
+
+        public bool Equals(ProjectCacheDescriptor? x, ProjectCacheDescriptor? y)
+        {
+            if (ReferenceEquals(x, y))
+            {
+                return true;
+            }
+
+            if (x is null || y is null)
+            {
+                return false;
+            }
+
+            return string.Equals(x.PluginAssemblyPath, y.PluginAssemblyPath, StringComparison.OrdinalIgnoreCase)
+                && ReferenceEquals(x.PluginInstance, y.PluginInstance)
+                && CollectionHelpers.DictionaryEquals(x.PluginSettings, y.PluginSettings);
+        }
+
+        public int GetHashCode(ProjectCacheDescriptor obj)
+        {
+            int hashCode = -1043047289;
+
+            if (obj.PluginAssemblyPath != null)
+            {
+                hashCode = (hashCode * -1521134295) + StringComparer.OrdinalIgnoreCase.GetHashCode(obj.PluginAssemblyPath);
+            }
+
+            if (obj.PluginInstance != null)
+            {
+                hashCode = (hashCode * -1521134295) + obj.PluginInstance.GetHashCode();
+            }
+
+            if (obj.PluginSettings.Count > 0)
+            {
+                foreach (var pluginSetting in obj.PluginSettings.OrderBy(_ => _.Key))
+                {
+                    hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();
+                    hashCode = (hashCode * -1521134295) + pluginSetting.Value.GetHashCode();
+                }
+            }
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
deleted file mode 100644
index 2982c7508d9..00000000000
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Experimental.ProjectCache
-{
-    internal class ProjectCacheItem : IEquatable<ProjectCacheItem>
-    {
-        private readonly IReadOnlyCollection<KeyValuePair<string, string>> _pluginSettingsSorted;
-
-        public ProjectCacheItem(string pluginPath, IReadOnlyDictionary<string, string> pluginSettings)
-        {
-            PluginPath = pluginPath;
-
-            PluginSettings = pluginSettings;
-
-            // Sort by key to avoid doing it during hashcode computation.
-            _pluginSettingsSorted = pluginSettings.OrderBy(_ => _.Key).ToArray();
-        }
-
-        public string PluginPath { get; }
-        public IReadOnlyDictionary<string, string> PluginSettings { get; }
-
-        public bool Equals(ProjectCacheItem? other)
-        {
-            if (ReferenceEquals(this, other))
-            {
-                return true;
-            }
-
-            return PluginPath == other?.PluginPath &&
-                   CollectionHelpers.DictionaryEquals(PluginSettings, other.PluginSettings);
-        }
-
-        public override bool Equals(object? obj)
-        {
-            if (ReferenceEquals(this, obj))
-            {
-                return true;
-            }
-
-            if (obj?.GetType() != GetType())
-            {
-                return false;
-            }
-
-            return Equals((ProjectCacheItem) obj);
-        }
-
-        public override int GetHashCode()
-        {
-            int hashCode = -1043047289;
-
-            hashCode = (hashCode * -1521134295) + PluginPath.GetHashCode();
-
-            foreach (var pluginSetting in _pluginSettingsSorted)
-            {
-                hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();
-                hashCode = (hashCode * -1521134295) + pluginSetting.Value.GetHashCode();
-            }
-
-            return hashCode;
-        }
-    }
-}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 8c3cdb46bb8..54ad725b1d0 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -2,9 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
 using System.Xml;
@@ -18,90 +21,139 @@
 using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     internal record CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);
 
-    internal record NullableBool(bool Value)
+    internal sealed class ProjectCacheService : IAsyncDisposable
     {
-        public static implicit operator bool(NullableBool? d) => d is not null && d.Value;
-    }
-
-    internal enum ProjectCacheServiceState
-    {
-        NotInitialized,
-        BeginBuildStarted,
-        BeginBuildFinished,
-        ShutdownStarted,
-        ShutdownFinished
-    }
+        private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };
 
-    internal class ProjectCacheService
-    {
         private readonly BuildManager _buildManager;
         private readonly ILoggingService _loggingService;
-        private readonly ProjectCacheDescriptor _projectCacheDescriptor;
-        private readonly CancellationToken _cancellationToken;
-        private readonly ProjectCachePluginBase _projectCachePlugin;
-        private readonly string _projectCachePluginTypeName;
-        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;
+
+        private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;
+
+        private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);
+
+        private bool _isVsScenario;
+
+        private bool _isDisposed;
+
+        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
         /// i.e. falling back to FileSystem.Default.
         /// </summary>
-        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }
-
-        // Use NullableBool to make it work with Interlock.CompareExchange (doesn't accept bool?).
-        // Assume that if one request is a design time build, all of them are.
-        // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.
-        // TODO: remove after we change VS to set the cache descriptor via build parameters.
-        public volatile NullableBool? DesignTimeBuildsDetected;
-        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;
-
-        private ProjectCacheService(
-            ProjectCachePluginBase projectCachePlugin,
-            string pluginTypeName,
+        private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase
+        {
+            private DefaultMSBuildFileSystem()
+            {
+            }
+
+            public static DefaultMSBuildFileSystem Instance { get; } = new();
+        }
+
+        public ProjectCacheService(
             BuildManager buildManager,
             ILoggingService loggingService,
-            ProjectCacheDescriptor projectCacheDescriptor,
-            CancellationToken cancellationToken
-        )
+            ProjectCacheDescriptor? globalProjectCacheDescriptor)
         {
-            _projectCachePlugin = projectCachePlugin;
-            _projectCachePluginTypeName = pluginTypeName;
             _buildManager = buildManager;
             _loggingService = loggingService;
-            _projectCacheDescriptor = projectCacheDescriptor;
-            _cancellationToken = cancellationToken;
+            _globalProjectCacheDescriptor = globalProjectCacheDescriptor;
         }
 
-        public static async Task<ProjectCacheService> FromDescriptorAsync(
-            ProjectCacheDescriptor pluginDescriptor,
-            BuildManager buildManager,
-            ILoggingService loggingService,
+        /// <summary>
+        /// Optimization which frontloads plugin initialization since we have an entire graph.
+        /// </summary>
+        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)
+        {
+            EnsureNotDisposed();
+
+            Parallel.ForEach(
+                projectGraph.ProjectNodes,
+                s_parallelOptions,
+                node =>
+                {
+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                    {
+                        // Intentionally fire-and-forget
+                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, graphEntryPoints: null, cancellationToken)
+                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                    }
+                });
+        }
+
+        public void InitializePluginsForVsScenario(
+            IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,
+            BuildSubmission submission,
+            BuildRequestConfiguration buildRequestConfiguration,
             CancellationToken cancellationToken)
         {
-            (ProjectCachePluginBase plugin, string pluginTypeName) = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)
-                .ConfigureAwait(false);
+            EnsureNotDisposed();
 
-            var service = new ProjectCacheService(plugin, pluginTypeName, buildManager, loggingService, pluginDescriptor, cancellationToken);
+            _isVsScenario = true;
 
-            // TODO: remove the if after we change VS to set the cache descriptor via build parameters and always call BeginBuildAsync in FromDescriptorAsync.
-            // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
-            // further information (set by VS) from it required by the plugin.
-            if (!pluginDescriptor.VsWorkaround)
+            // Bail out for design-time builds
+            if (IsDesignTimeBuild(buildRequestConfiguration))
             {
-                await service.BeginBuildAsync();
+                return;
             }
 
-            return service;
+            EvaluateProjectIfNecessary(submission, buildRequestConfiguration);
+
+            IReadOnlyCollection<ProjectGraphEntryPoint> graphEntryPoints = GetGraphEntryPoints(buildRequestConfiguration);
+
+            Parallel.ForEach(
+                projectCacheDescriptors,
+                s_parallelOptions,
+                projectCacheDescriptor =>
+                {
+                    // Intentionally fire-and-forget
+                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, graphEntryPoints, cancellationToken)
+                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                });
         }
 
-        // TODO: remove vsWorkaroundOverrideDescriptor after we change VS to set the cache descriptor via build parameters.
-        private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideDescriptor = null)
+        private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
+            ProjectCacheDescriptor projectCacheDescriptor,
+            ProjectGraph? projectGraph,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints,
+            CancellationToken cancellationToken)
+            => _projectCachePlugins.GetOrAdd(
+                projectCacheDescriptor,
+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, graphEntryPoints, cancellationToken))).Value;
+
+        private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectInstance projectInstance)
+        {
+            if (_globalProjectCacheDescriptor != null)
+            {
+                yield return _globalProjectCacheDescriptor;
+            }
+
+            ICollection<ProjectItemInstance> items = projectInstance.GetItems(ItemTypeNames.ProjectCachePlugin);
+            foreach (ProjectItemInstance item in items)
+            {
+                string pluginPath = FileUtilities.NormalizePath(Path.Combine(item.Project.Directory, item.EvaluatedInclude));
+
+                var pluginSettings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectMetadataInstance metadatum in item.Metadata)
+                {
+                    pluginSettings.Add(metadatum.Name, metadatum.EvaluatedValue);
+                }
+
+                yield return ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings);
+            }
+        }
+
+        private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
+            ProjectCacheDescriptor projectCacheDescriptor,
+            ProjectGraph? projectGraph,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints,
+            CancellationToken cancellationToken)
         {
             BuildEventContext buildEventContext = BuildEventContext.Invalid;
             BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
@@ -109,57 +161,69 @@ private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideD
                 _loggingService,
                 buildEventContext,
                 buildEventFileInfo);
-            ProjectCacheDescriptor projectDescriptor = vsWorkaroundOverrideDescriptor ?? _projectCacheDescriptor;
 
-            try
-            {
-                SetState(ProjectCacheServiceState.BeginBuildStarted);
-                _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheBeginBuild");
-                MSBuildEventSource.Log.ProjectCacheBeginBuildStart(_projectCachePluginTypeName);
+            ProjectCachePluginBase pluginInstance;
+            string pluginTypeName;
 
-                await _projectCachePlugin.BeginBuildAsync(
-                    new CacheContext(
-                        projectDescriptor.PluginSettings,
-                        new DefaultMSBuildFileSystem(),
-                        projectDescriptor.ProjectGraph,
-                        projectDescriptor.EntryPoints),
-                    pluginLogger,
-                    _cancellationToken);
-            }
-            catch (Exception e)
+            if (projectCacheDescriptor.PluginInstance != null)
             {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.BeginBuildAsync));
+                pluginInstance = projectCacheDescriptor.PluginInstance;
+                pluginTypeName = projectCacheDescriptor.PluginInstance.GetType().Name;
             }
-            finally
+            else
             {
-                MSBuildEventSource.Log.ProjectCacheBeginBuildStop(_projectCachePluginTypeName);
-                SetState(ProjectCacheServiceState.BeginBuildFinished);
+                ErrorUtilities.VerifyThrowArgumentNull(projectCacheDescriptor.PluginAssemblyPath, nameof(projectCacheDescriptor.PluginAssemblyPath));
+
+                string pluginAssemblyPath = projectCacheDescriptor.PluginAssemblyPath!;
+                pluginTypeName = pluginAssemblyPath; // Just in case the assembly can't be loaded, the path would be helpful to help identify the problem.
+                try
+                {
+                    MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStart(pluginAssemblyPath);
+
+                    Type pluginType = GetTypeFromAssemblyPath(pluginAssemblyPath);
+                    pluginTypeName = pluginType.Name;
+
+                    pluginInstance = GetPluginInstanceFromType(pluginType);
+                }
+                catch (Exception e)
+                {
+                    return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                }
+                finally
+                {
+                    MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStop(pluginAssemblyPath, pluginTypeName);
+                }
             }
 
-            if (pluginLogger.HasLoggedErrors)
+            _loggingService.LogComment(buildEventContext, MessageImportance.High, "LoadingProjectCachePlugin", pluginTypeName);
+            MSBuildEventSource.Log.ProjectCacheBeginBuildStart(pluginTypeName);
+
+            try
             {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
-            }
-        }
+                await pluginInstance.BeginBuildAsync(
+                    new CacheContext(
+                        projectCacheDescriptor.PluginSettings,
+                        DefaultMSBuildFileSystem.Instance,
+                        projectGraph,
+                        graphEntryPoints),
+                    pluginLogger,
+                    cancellationToken);
 
-        private static (ProjectCachePluginBase PluginInstance, string PluginTypeName) GetPluginInstance(ProjectCacheDescriptor pluginDescriptor)
-        {
-            if (pluginDescriptor.PluginInstance != null)
+                if (pluginLogger.HasLoggedErrors)
+                {
+                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
+                }
+
+                return new ProjectCachePlugin(pluginTypeName, pluginInstance);
+            }
+            catch (Exception e)
             {
-                return (pluginDescriptor.PluginInstance, pluginDescriptor.PluginInstance.GetType().Name);
+                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
             }
-
-            if (pluginDescriptor.PluginAssemblyPath != null)
+            finally
             {
-                MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStart(pluginDescriptor.PluginAssemblyPath);
-                Type pluginType = GetTypeFromAssemblyPath(pluginDescriptor.PluginAssemblyPath);
-                ProjectCachePluginBase pluginInstance = GetPluginInstanceFromType(pluginType);
-                MSBuildEventSource.Log.ProjectCacheCreatePluginInstanceStop(pluginDescriptor.PluginAssemblyPath, pluginType.Name);
-                return (pluginInstance, pluginType.Name);
+                MSBuildEventSource.Log.ProjectCacheBeginBuildStop(pluginTypeName);
             }
-
-            ErrorUtilities.ThrowInternalErrorUnreachable();
-            return (null!, null!); // Unreachable
         }
 
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
@@ -214,78 +278,64 @@ IEnumerable<Type> GetTypes<T>(Assembly assembly)
         private static readonly CoreClrAssemblyLoader s_loader = new CoreClrAssemblyLoader();
 #endif
 
-        public void PostCacheRequest(CacheRequest cacheRequest)
+        public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
         {
-            Task.Run(async () =>
+            if (IsDesignTimeBuild(buildRequestConfiguration))
             {
-                try
-                {
-                    (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequest(cacheRequest);
-                    _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
-                }
-                catch (Exception e)
-                {
-                    _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
-                }
-            }, _cancellationToken);
+                return false;
+            }
 
-            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequest(CacheRequest request)
+            if (_globalProjectCacheDescriptor != null)
             {
-                // Prevent needless evaluation if design time builds detected.
-                if (_projectCacheDescriptor.VsWorkaround && DesignTimeBuildsDetected)
-                {
-                    // The BuildManager should disable the cache when it finds its servicing design time builds.
-                    return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
-                }
+                return true;
+            }
 
-                EvaluateProjectIfNecessary(request);
+            // We've determined it's the VS scenario and know that there are project cache plugins.
+            if (_isVsScenario)
+            {
+                return true;
+            }
 
-                // Detect design time builds.
-                if (_projectCacheDescriptor.VsWorkaround)
-                {
-                    var isDesignTimeBuild = IsDesignTimeBuild(request.Configuration.Project);
+            // If the project isn't loaded, don't force it to be just to check if it's cacheable as this may not be very performant.
+            if (!buildRequestConfiguration.IsLoaded)
+            {
+                return false;
+            }
 
-                    var previousValue = Interlocked.CompareExchange(
-                        ref DesignTimeBuildsDetected,
-                        new NullableBool(isDesignTimeBuild),
-                        null);
+            // Check if there are any project cache items defined in the project
+            return GetProjectCacheDescriptors(buildRequestConfiguration.Project).Any();
+        }
 
-                    ErrorUtilities.VerifyThrowInternalError(
-                        previousValue is null || previousValue == false || isDesignTimeBuild,
-                        "Either all builds in a build session or design time builds, or none");
+        private bool IsDesignTimeBuild(BuildRequestConfiguration buildRequestConfiguration)
+        {
+            string? designTimeBuild = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.DesignTimeBuild]?.EvaluatedValue;
+            string? buildingProject = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
+            return ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true)
+                || (buildingProject != null && !ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true));
+        }
 
-                    // No point progressing with expensive plugin initialization or cache query if design time build detected.
-                    if (DesignTimeBuildsDetected)
-                    {
-                        // The BuildManager should disable the cache when it finds its servicing design time builds.
-                        return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
-                    }
-                }
+        public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancellationToken)
+        {
+            EnsureNotDisposed();
 
-                // TODO: remove after we change VS to set the cache descriptor via build parameters.
-                // VS workaround needs to wait until the first project is evaluated to extract enough information to initialize the plugin.
-                // No cache request can progress until late initialization is complete.
-                if (_projectCacheDescriptor.VsWorkaround)
+            Task.Run(
+                async () =>
                 {
-                    if (Interlocked.CompareExchange(
-                            ref LateInitializationForVSWorkaroundCompleted,
-                            new TaskCompletionSource<bool>(),
-                            null) is null)
+                    try
                     {
-                        await LateInitializePluginForVsWorkaround(request);
-                        LateInitializationForVSWorkaroundCompleted.SetResult(true);
+                        (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequestAsync();
+                        _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
                     }
-                    else
+                    catch (Exception e)
                     {
-                        // Can't be null. If the thread got here it means another thread initialized the completion source.
-                        await LateInitializationForVSWorkaroundCompleted!.Task;
+                        _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
                     }
-                }
+                },
+                cancellationToken);
 
-                ErrorUtilities.VerifyThrowInternalError(
-                    LateInitializationForVSWorkaroundCompleted is null ||
-                    (_projectCacheDescriptor.VsWorkaround && LateInitializationForVSWorkaroundCompleted.Task.IsCompleted),
-                    "Completion source should be null when this is not the VS workaround");
+            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequestAsync()
+            {
+                EvaluateProjectIfNecessary(cacheRequest.Submission, cacheRequest.Configuration);
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
@@ -299,7 +349,7 @@ LateInitializationForVSWorkaroundCompleted is null ||
                 CacheResult cacheResult;
                 try
                 {
-                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext);
+                    cacheResult = await GetCacheResultAsync(buildRequest, cacheRequest.Configuration, buildEventContext, cancellationToken);
                 }
                 catch (Exception ex)
                 {
@@ -309,48 +359,156 @@ LateInitializationForVSWorkaroundCompleted is null ||
 
                 return (cacheResult, buildEventContext.ProjectContextId);
             }
+        }
 
-            static bool IsDesignTimeBuild(ProjectInstance project)
+        private void EvaluateProjectIfNecessary(BuildSubmission submission, BuildRequestConfiguration configuration)
+        {
+            lock (configuration)
             {
-                var designTimeBuild = project.GetPropertyValue(DesignTimeProperties.DesignTimeBuild);
-                var buildingProject = project.GlobalPropertiesDictionary[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
+                if (!configuration.IsLoaded)
+                {
+                    configuration.LoadProjectIntoConfiguration(
+                        _buildManager,
+                        submission.BuildRequestData.Flags,
+                        submission.SubmissionId,
+                        Scheduler.InProcNodeId
+                    );
+
+                    // If we're taking the time to evaluate, avoid having other nodes to repeat the same evaluation.
+                    // Based on the assumption that ProjectInstance serialization is faster than evaluating from scratch.
+                    configuration.Project.TranslateEntireState = true;
+                }
+            }
+        }
+
+        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
+
+            var buildEventFileInfo = new BuildEventFileInfo(buildRequest.ProjectFullPath);
+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
 
-                return MSBuildStringIsTrue(designTimeBuild) ||
-                       (buildingProject != null && !MSBuildStringIsTrue(buildingProject));
+            string? targetNames = buildRequest.TargetNames != null && buildRequest.TargetNames.Count > 0
+                ? string.Join(", ", buildRequest.TargetNames)
+                : null;
+            if (string.IsNullOrEmpty(targetNames))
+            {
+                _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheQueryStartedWithDefaultTargets", buildRequest.ProjectFullPath);
+            }
+            else
+            {
+                _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheQueryStartedWithTargetNames", buildRequest.ProjectFullPath, targetNames);
             }
 
-            void EvaluateProjectIfNecessary(CacheRequest request)
+            IReadOnlyCollection<ProjectGraphEntryPoint> graphEntryPoints = GetGraphEntryPoints(buildRequestConfiguration);
+
+            HashSet<ProjectCacheDescriptor> queriedCaches = new(ProjectCacheDescriptorEqualityComparer.Instance);
+            CacheResult? cacheResult = null;
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(buildRequest.ProjectInstance))
             {
-                // TODO: only do this if the project cache requests evaluation. QB needs evaluations, but the Anybuild implementation
-                // TODO: might not need them, so no point evaluating if it's not necessary. As a caveat, evaluations would still be optimal
-                // TODO: when proxy builds are issued by the plugin ( scheduled on the inproc node, no point re-evaluating on out-of-proc nodes).
-                lock (request.Configuration)
+                // Ensure each unique plugin is only queried once
+                if (!queriedCaches.Add(projectCacheDescriptor))
+                {
+                    continue;
+                }
+
+                ProjectCachePlugin plugin = await GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, graphEntryPoints, cancellationToken);
+                try
                 {
-                    if (!request.Configuration.IsLoaded)
+                    // Rethrow any initialization exception.
+                    plugin.InitializationException?.Throw();
+
+                    ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
+
+                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(plugin.Name, buildRequest.ProjectFullPath, targetNames);
+                    cacheResult = await plugin.Instance!.GetCacheResultAsync(buildRequest, pluginLogger, cancellationToken);
+
+                    if (pluginLogger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
                     {
-                        request.Configuration.LoadProjectIntoConfiguration(
-                            _buildManager,
-                            request.Submission.BuildRequestData.Flags,
-                            request.Submission.SubmissionId,
-                            Scheduler.InProcNodeId
-                        );
-
-                        // If we're taking the time to evaluate, avoid having other nodes to repeat the same evaluation.
-                        // Based on the assumption that ProjectInstance serialization is faster than evaluating from scratch.
-                        request.Configuration.Project.TranslateEntireState = true;
+                        ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", buildRequest.ProjectFullPath);
+                    }
+
+                    if (cacheResult.ResultType == CacheResultType.CacheHit)
+                    {
+                        break;
+                    }
+                }
+                catch (Exception e) when (e is not ProjectCacheException)
+                {
+                    HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
+                    return null!; // Unreachable
+                }
+                finally
+                {
+                    if (MSBuildEventSource.Log.IsEnabled())
+                    {
+                        string cacheResultType = cacheResult?.ResultType.ToString() ?? nameof(CacheResultType.None);
+                        MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(plugin.Name, buildRequest.ProjectFullPath, targetNames, cacheResultType);
                     }
                 }
             }
 
-            async Task LateInitializePluginForVsWorkaround(CacheRequest request)
+            // Handle the case of no configured plugins.
+            cacheResult ??= CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
+
+            switch (cacheResult.ResultType)
             {
-                var (_, configuration) = request;
-                var solutionConfigurationXml = configuration.Project.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
+                case CacheResultType.CacheHit:
+                    if (string.IsNullOrEmpty(targetNames))
+                    {
+                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheHitWithDefaultTargets", buildRequest.ProjectFullPath);
+                    }
+                    else
+                    {
+                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheHitWithTargetNames", buildRequest.ProjectFullPath, targetNames);
+                    }
 
-                ErrorUtilities.VerifyThrow(
-                    string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,
-                    "Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.");
+                    // Similar to CopyFilesToOutputDirectory from Microsoft.Common.CurrentVersion.targets, so that progress can be seen.
+                    // TODO: This should be indented by the console logger. That requires making these log events structured.
+                    if (!buildRequestConfiguration.IsTraversal)
+                    {
+                        _loggingService.LogComment(buildEventContext, MessageImportance.High, "ProjectCacheHitWithOutputs", buildRequest.ProjectInstance.GetPropertyValue(ReservedPropertyNames.projectName));
+                    }
 
+                    break;
+                case CacheResultType.CacheMiss:
+                    if (string.IsNullOrEmpty(targetNames))
+                    {
+                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheMissWithDefaultTargets", buildRequest.ProjectFullPath);
+                    }
+                    else
+                    {
+                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheMissWithTargetNames", buildRequest.ProjectFullPath, targetNames);
+                    }
+
+                    break;
+                case CacheResultType.CacheNotApplicable:
+                    if (string.IsNullOrEmpty(targetNames))
+                    {
+                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheNotApplicableWithDefaultTargets", buildRequest.ProjectFullPath);
+                    }
+                    else
+                    {
+                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheNotApplicableWithTargetNames", buildRequest.ProjectFullPath, targetNames);
+                    }
+
+                    break;
+                case CacheResultType.None: // Should not get here based on the throw above
+                default:
+                    throw new ArgumentOutOfRangeException();
+            }
+
+            return cacheResult;
+        }
+
+        private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildRequestConfiguration configuration)
+        {
+            string solutionConfigurationXml = configuration.Project.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
+            if (!string.IsNullOrWhiteSpace(solutionConfigurationXml))
+            {
                 // A solution supports multiple solution configurations (different values for Configuration and Platform).
                 // Each solution configuration generates a different static graph.
                 // Therefore, plugin implementations that rely on creating static graphs in their BeginBuild methods need access to the
@@ -365,16 +523,11 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)
                 //
                 // Ideally, when the VS workaround is removed from MSBuild and moved into VS, VS should create ProjectGraphDescriptors with the solution path as
                 // the graph entrypoint file, and the VS solution configuration as the entry point's global properties.
-                var graphEntryPointsFromSolutionConfig = GenerateGraphEntryPointsFromSolutionConfigurationXml(
-                    solutionConfigurationXml,
-                    configuration.Project);
-
-                await BeginBuildAsync(
-                    ProjectCacheDescriptor.FromAssemblyPath(
-                        _projectCacheDescriptor.PluginAssemblyPath!,
-                        graphEntryPointsFromSolutionConfig,
-                        projectGraph: null,
-                        _projectCacheDescriptor.PluginSettings));
+                return GenerateGraphEntryPointsFromSolutionConfigurationXml(solutionConfigurationXml, configuration.Project);
+            }
+            else
+            {
+                return new[] { new ProjectGraphEntryPoint(configuration.Project.FullPath, configuration.Project.GlobalProperties) };
             }
 
             static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
@@ -410,10 +563,6 @@ ProjectInstance project
                         continue;
                     }
 
-                    ErrorUtilities.VerifyThrow(
-                        node.ChildNodes.OfType<XmlElement>().FirstOrDefault(e => e.Name == "ProjectDependency") is null,
-                        "Project cache service does not support solution only dependencies when running under Visual Studio.");
-
                     var projectPathAttribute = node.Attributes!["AbsolutePath"];
                     ErrorUtilities.VerifyThrow(projectPathAttribute is not null, "Expected VS to set the project path on each ProjectConfiguration element.");
 
@@ -436,12 +585,12 @@ ProjectInstance project
                 return graphEntryPoints;
 
                 // If any project specific property is set, it will propagate down the project graph and force all nodes to that property's specific side effects, which is incorrect.
-                void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)
+                static void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProperties, ProjectInstance project)
                 {
                     // InnerBuildPropertyName is TargetFramework for the managed sdk.
                     var innerBuildPropertyName = ProjectInterpretation.GetInnerBuildPropertyName(project);
 
-                    IEnumerable<string> projectSpecificPropertyNames = new []{innerBuildPropertyName, "Configuration", "Platform", "TargetPlatform", "OutputType"};
+                    IEnumerable<string> projectSpecificPropertyNames = new[] { innerBuildPropertyName, "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
                     foreach (var propertyName in projectSpecificPropertyNames)
                     {
@@ -452,156 +601,74 @@ void RemoveProjectSpecificGlobalProperties(Dictionary<string, string> globalProp
                     }
                 }
             }
-
-            static bool MSBuildStringIsTrue(string msbuildString) =>
-                ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
         }
 
-        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext)
+        public async ValueTask DisposeAsync()
         {
-            lock (this)
+            if (_isDisposed)
             {
-                CheckNotInState(ProjectCacheServiceState.NotInitialized);
-                CheckNotInState(ProjectCacheServiceState.BeginBuildStarted);
-
-                if (_serviceState is ProjectCacheServiceState.ShutdownStarted or ProjectCacheServiceState.ShutdownFinished)
-                {
-                    return CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
-                }
+                return;
             }
 
-            ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
+            _isDisposed = true;
 
-            var buildEventFileInfo = new BuildEventFileInfo(buildRequest.ProjectFullPath);
+            if (_projectCachePlugins.IsEmpty)
+            {
+                return;
+            }
+
+            BuildEventContext buildEventContext = BuildEventContext.Invalid;
+            BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
             var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
                 _loggingService,
                 buildEventContext,
                 buildEventFileInfo);
 
-            string? targetNames = buildRequest.TargetNames != null && buildRequest.TargetNames.Count > 0
-                ? string.Join(", ", buildRequest.TargetNames)
-                : null;
-            if (string.IsNullOrEmpty(targetNames))
-            {
-                _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheQueryStartedWithDefaultTargets", buildRequest.ProjectFullPath);
-            }
-            else
-            {
-                _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheQueryStartedWithTargetNames", buildRequest.ProjectFullPath, targetNames);
-            }
+            _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheEndBuild");
 
-            CacheResult? cacheResult = null;
-            try
-            {
-                MSBuildEventSource.Log.ProjectCacheGetCacheResultStart(_projectCachePluginTypeName, buildRequest.ProjectFullPath, targetNames);
-                cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, pluginLogger, _cancellationToken);
-            }
-            catch (Exception e)
-            {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
-                return null!; // Unreachable
-            }
-            finally
+            Task[] cleanupTasks = new Task[_projectCachePlugins.Count];
+            int idx = 0;
+            foreach (KeyValuePair<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> kvp in _projectCachePlugins)
             {
-                if (MSBuildEventSource.Log.IsEnabled())
+                cleanupTasks[idx++] = Task.Run(async () =>
                 {
-                    string cacheResultType = cacheResult?.ResultType.ToString() ?? nameof(CacheResultType.None);
-                    MSBuildEventSource.Log.ProjectCacheGetCacheResultStop(_projectCachePluginTypeName, buildRequest.ProjectFullPath, targetNames, cacheResultType);
-                }
-            }
-
-            if (pluginLogger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
-            {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", buildRequest.ProjectFullPath);
-            }
+                    ProjectCachePlugin plugin = await kvp.Value.Value;
 
-            switch (cacheResult.ResultType)
-            {
-                case CacheResultType.CacheHit:
-                    if (string.IsNullOrEmpty(targetNames))
+                    // If there is no instance, the exceptions would have bubbled up already, so skip cleanup for this one.
+                    if (plugin.Instance == null)
                     {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheHitWithDefaultTargets", buildRequest.ProjectFullPath);
-                    }
-                    else
-                    {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheHitWithTargetNames", buildRequest.ProjectFullPath, targetNames);
+                        return;
                     }
 
-                    // Similar to CopyFilesToOutputDirectory from Microsoft.Common.CurrentVersion.targets, so that progress can be seen.
-                    // TODO: This should be indented by the console logger. That requires making these log events structured.
-                    if (!buildRequestConfiguration.IsTraversal)
+                    MSBuildEventSource.Log.ProjectCacheEndBuildStart(plugin.Name);
+                    try
                     {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.High, "ProjectCacheHitWithOutputs", buildRequest.ProjectInstance.GetPropertyValue(ReservedPropertyNames.projectName));
+                        await plugin.Instance.EndBuildAsync(pluginLogger, CancellationToken.None);
                     }
-
-                    break;
-                case CacheResultType.CacheMiss:
-                    if (string.IsNullOrEmpty(targetNames))
+                    catch (Exception e) when (e is not ProjectCacheException)
                     {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheMissWithDefaultTargets", buildRequest.ProjectFullPath);
+                        HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
                     }
-                    else
+                    finally
                     {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheMissWithTargetNames", buildRequest.ProjectFullPath, targetNames);
+                        MSBuildEventSource.Log.ProjectCacheEndBuildStop(plugin.Name);
                     }
-
-                    break;
-                case CacheResultType.CacheNotApplicable:
-                    if (string.IsNullOrEmpty(targetNames))
-                    {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheNotApplicableWithDefaultTargets", buildRequest.ProjectFullPath);
-                    }
-                    else
-                    {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "ProjectCacheNotApplicableWithTargetNames", buildRequest.ProjectFullPath, targetNames);
-                    }
-
-                    break;
-                case CacheResultType.None: // Should not get here based on the throw above
-                default:
-                    throw new ArgumentOutOfRangeException();
+                });
             }
 
-            return cacheResult;
-        }
+            await Task.WhenAll(cleanupTasks);
 
-        public async Task ShutDown()
-        {
-            bool shouldInitiateShutdownState = _serviceState != ProjectCacheServiceState.ShutdownStarted && _serviceState != ProjectCacheServiceState.ShutdownFinished;
-
-            if (!shouldInitiateShutdownState)
+            if (pluginLogger.HasLoggedErrors)
             {
-                return;
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
             }
+        }
 
-            BuildEventContext buildEventContext = BuildEventContext.Invalid;
-            BuildEventFileInfo buildEventFileInfo = BuildEventFileInfo.Empty;
-            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
-                _loggingService,
-                BuildEventContext.Invalid,
-                BuildEventFileInfo.Empty);
-            
-            try
-            {
-                SetState(ProjectCacheServiceState.ShutdownStarted);
-                _loggingService.LogComment(buildEventContext, MessageImportance.Low, "ProjectCacheEndBuild");
-                MSBuildEventSource.Log.ProjectCacheEndBuildStart(_projectCachePluginTypeName);
-
-                await _projectCachePlugin.EndBuildAsync(pluginLogger, _cancellationToken);
-
-                if (pluginLogger.HasLoggedErrors)
-                {
-                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
-                }
-            }
-            catch (Exception e) when (e is not ProjectCacheException)
-            {
-                HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
-            }
-            finally
+        private void EnsureNotDisposed()
+        {
+            if (_isDisposed)
             {
-                MSBuildEventSource.Log.ProjectCacheEndBuildStop(_projectCachePluginTypeName);
-                SetState(ProjectCacheServiceState.ShutdownFinished);
+                throw new ObjectDisposedException(nameof(ProjectCacheService));
             }
         }
 
@@ -618,52 +685,6 @@ private static void HandlePluginException(Exception e, string apiExceptionWasThr
                 apiExceptionWasThrownFrom);
         }
 
-        private void SetState(ProjectCacheServiceState newState)
-        {
-            lock (this)
-            {
-                switch (newState)
-                {
-                    case ProjectCacheServiceState.NotInitialized:
-                        ErrorUtilities.ThrowInternalError($"Cannot transition to {ProjectCacheServiceState.NotInitialized}");
-                        break;
-                    case ProjectCacheServiceState.BeginBuildStarted:
-                        CheckInState(ProjectCacheServiceState.NotInitialized);
-                        break;
-                    case ProjectCacheServiceState.BeginBuildFinished:
-                        CheckInState(ProjectCacheServiceState.BeginBuildStarted);
-                        break;
-                    case ProjectCacheServiceState.ShutdownStarted:
-                        CheckNotInState(ProjectCacheServiceState.ShutdownStarted);
-                        CheckNotInState(ProjectCacheServiceState.ShutdownFinished);
-                        break;
-                    case ProjectCacheServiceState.ShutdownFinished:
-                        CheckInState(ProjectCacheServiceState.ShutdownStarted);
-                        break;
-                    default:
-                        throw new ArgumentOutOfRangeException(nameof(newState), newState, null);
-                }
-
-                _serviceState = newState;
-            }
-        }
-
-        private void CheckInState(ProjectCacheServiceState expectedState)
-        {
-            lock (this)
-            {
-                ErrorUtilities.VerifyThrowInternalError(_serviceState == expectedState, $"Expected state {expectedState}, actual state {_serviceState}");
-            }
-        }
-
-        private void CheckNotInState(ProjectCacheServiceState unexpectedState)
-        {
-            lock (this)
-            {
-                ErrorUtilities.VerifyThrowInternalError(_serviceState != unexpectedState, $"Unexpected state {_serviceState}");
-            }
-        }
-
         private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
         {
             private readonly ILoggingService _loggingService;
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b3154221e9f..4cd52b0b8a1 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -767,7 +767,7 @@ private void Evaluate()
 
                     if (BuildEnvironmentHelper.Instance.RunningInVisualStudio)
                     {
-                        // TODO: Remove this when VS gets updated to setup project cache plugins.
+                        // TODO: Figure out a more elegant way to do this. See the comment on BuildManager.ProjectCacheDescriptors for explanation.
                         CollectProjectCachePlugins();
                     }
 
@@ -822,13 +822,17 @@ private void CollectProjectCachePlugins()
         {
             foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
             {
-                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);
+                string pluginPath = FileUtilities.NormalizePath(Path.Combine(_data.Directory, item.EvaluatedInclude));
 
-                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);
+                var pluginSettings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                foreach (M metadatum in item.Metadata)
+                {
+                    pluginSettings.Add(metadatum.Key, metadatum.EscapedValue);
+                }
 
-                var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
+                var projectCacheItem = ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings);
 
-                BuildManager.ProjectCacheItems[pluginPath] = projectCacheItem;
+                BuildManager.ProjectCacheDescriptors.TryAdd(projectCacheItem, projectCacheItem);
             }
         }
 
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
index a4ec0aaf92d..b006f76520c 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
@@ -1335,12 +1335,9 @@ Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> M
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
 static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
 static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
 static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
@@ -1836,4 +1833,4 @@ virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index 93740b15de2..38f8853c43d 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1335,12 +1335,9 @@ Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> M
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
 Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.EntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.GetDetailedDescription() -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
 Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
@@ -1786,8 +1783,8 @@ static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Mi
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
 static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
+static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
 static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
 static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
 static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
@@ -1836,4 +1833,4 @@ virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
 virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
\ No newline at end of file
+virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 10018e5f8f1..b79d63e4d78 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1,17 +1,17 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!--
-    Microsoft ResX Schema
-
+  <!-- 
+    Microsoft ResX Schema 
+    
     Version 2.0
-
-    The primary goals of this format is to allow a simple XML format
-    that is mostly human readable. The generation and parsing of the
-    various data types are done through the TypeConverter classes
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
     associated with the data types.
-
+    
     Example:
-
+    
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-
-    There are any number of "resheader" rows that contain simple
+                
+    There are any number of "resheader" rows that contain simple 
     name/value pairs.
-
-    Each data row contains a name, and value. The row also contains a
-    type or mimetype. Type corresponds to a .NET class that support
-    text/value conversion through the TypeConverter architecture.
-    Classes that don't support this are serialized and stored with the
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
     mimetype set.
-
-    The mimetype is used for serialized objects, and tells the
-    ResXResourceReader how to depersist the object. This is currently not
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
     extensible. For a given mimetype the value must be set accordingly:
-
-    Note - application/x-microsoft.net.object.binary.base64 is the format
-    that the ResXResourceWriter will generate, however the reader can
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
     read any of the formats listed below.
-
+    
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-
+    
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with
+    value   : The object must be serialized with 
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array
+    value   : The object must be serialized into a byte array 
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -1877,15 +1877,11 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</value>
   </data>
   <data name="LoadingProjectCachePlugin" xml:space="preserve">
-    <value>Loading the following project cache plugin:
-    {0}</value>
+    <value>Loading the following project cache plugin: {0}</value>
   </data>
   <data name="SolutionPathPropertyMustBeSetOnVSSubmissions" xml:space="preserve">
     <value>"MSB4264: Invalid $(SolutionPath) property: {0}"</value>
   </data>
-  <data name="OnlyOneCachePluginMustBeSpecified" xml:space="preserve">
-    <value>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</value>
-  </data>
   <data name="ProjectCacheInitializationFailed" xml:space="preserve">
     <value>MSB4266: Failed to initialize the project cache.</value>
   </data>
@@ -1895,9 +1891,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectCacheShutdownFailed" xml:space="preserve">
     <value>MSB4268: The project cache failed to shut down properly.</value>
   </data>
-  <data name="NotAllNodesDefineACacheItem" xml:space="preserve">
-    <value>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</value>
-  </data>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
@@ -1910,9 +1903,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProxyRequestNotScheduledOnInprocNode" xml:space="preserve">
     <value>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</value>
   </data>
-  <data name="ProjectCacheBeginBuild" xml:space="preserve">
-    <value>Initializing project cache plugin.</value>
-  </data>
   <data name="ProjectCacheEndBuild" xml:space="preserve">
     <value>Shutting down project cache plugin.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index bc4f28a26e1..7c730756eb2 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Načítá se následující modul plug-in mezipaměti projektu:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: V sestavení {0} se nenašly žádné moduly plug-in mezipaměti projektu. Modul plug-in se očekával.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Pokud jakýkoli uzel statického grafu definuje mezipaměť projektu, musí všechny uzly definovat stejnou mezipaměť projektu. Následující projekty neobsahují deklaraci položky {0}: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Požadované sestavení NuGet se nenašlo. Očekávaná cesta: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Musí se zadat jeden modul plug-in mezipaměti projektu, ale našlo se jich více: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Vytvořilo se přepsání pomocí úlohy: {0} v {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializuje se modul plug-in mezipaměti projektu.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Vypíná se modul plug-in mezipaměti projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 2d5371cd4e4..eb593a39379 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Folgendes Projektcache-Plug-In wird geladen:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Folgendes Projektcache-Plug-In wird geladen:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: In der Assembly "{0}" wurde ein Projektcache-Plug-In erwartet, aber keines gefunden.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Wenn ein statischer Graphknoten einen Projektcache definiert, müssen alle Knoten denselben Projektcache definieren. Die folgenden Projekte enthalten keine Deklaration des Elements "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Ein einzelnes Projektcache-Plug-In muss angegeben werden, es wurden jedoch mehrere gefunden: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Außerkraftsetzung mit Task erstellt: {0} bei {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Das Projektcache-Plug-in wird initialisiert.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Das Projektcache-Plug-in wird heruntergefahren.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ae8a6a1e189..6da57b4a460 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Cargando el complemento de caché de proyectos siguiente:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Cargando el complemento de caché de proyectos siguiente:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: No se encontró ningún complemento de caché de proyectos en el ensamblado "{0}". Se esperaba uno.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Cuando un nodo de gráfico estático define una memoria caché de proyectos, todos los nodos deben definir la misma caché de proyectos. Los proyectos siguientes no contienen ninguna declaración de elemento "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">No se encontró un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Debe especificarse un solo complemento de caché de proyectos, pero se encontraron varios: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Se creó una invalidación mediante la tarea: {0} en {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializando complemento de caché de proyecto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Cerrando complemento de caché de proyecto.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 0ffddfbe011..d3bcbfc3137 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Chargement du plug-in de cache de projet suivant:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Chargement du plug-in de cache de projet suivant:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: plug-ins de cache de projet introuvables dans l'assembly "{0}". Un plug-in est attendu.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quand un nœud de graphe statique définit un cache de projet, tous les nœuds doivent définir le même cache de projet. Le ou les projets suivants ne contiennent pas de déclaration d'élément "{0}" : {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu : {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: un seul plug-in de cache de projet doit être spécifié, mais plusieurs plug-ins ont été trouvés : {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Remplacement créé à l’aide de la tâche : {0} au {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Initialisation du plug-in du cache de projet.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Arrêt du plug-in du cache de projet.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 11aec49efc6..857340bb3fe 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Caricamento del plug-in seguente della cache del progetto:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Caricamento del plug-in seguente della cache del progetto:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: non sono stati trovati plug-in della cache del progetto nell'assembly "{0}". Ne è previsto uno.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quando un nodo di grafo statico definisce una cache del progetto, tutti i nodi devono definire la stessa cache del progetto. Il progetto o i progetti seguenti non contengono una dichiarazione di elemento "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obbligatorio non è stato trovato. Percorso previsto: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: è necessario specificare un singolo plug-in della cache del progetto, ma ne sono trovati più di uno: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">È stata creata una sostituzione con l'attività: {0} in {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inizializzazione del plug-in della cache del progetto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Arresto del plug-in della cache del progetto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 1bf7a2f0d24..19d3064e39b 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">次のプロジェクト キャッシュ プラグインを読み込んでいます。
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">次のプロジェクト キャッシュ プラグインを読み込んでいます。
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: プロジェクト キャッシュのプラグインがアセンブリ "{0}" に見つかりませんでした。プラグインが 1 つ必要です。</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 静的グラフ ノードでプロジェクト キャッシュが定義されている場合、すべてのノードで同じプロジェクト キャッシュを定義する必要があります。プロジェクト {1} には、"{0}" 項目宣言が含まれていません</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">必要な NuGet アセンブリが見つかりませんでした。想定されるパス: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 単一のプロジェクト キャッシュ プラグインを指定する必要がありますが、複数指定されています。{0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">タスクを使用してオーバーライドを作成しました: {1} の {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">プロジェクト キャッシュ プラグインを初期化しています。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">プロジェクト キャッシュ プラグインをシャットダウンしています。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 8f5d34f5cce..c51bdeb544d 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">다음 프로젝트 캐시 플러그 인을 로드하는 중:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">다음 프로젝트 캐시 플러그 인을 로드하는 중:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: "{0}" 어셈블리에서 프로젝트 캐시 플러그 인을 찾을 수 없습니다. 1개가 필요합니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 정적 그래프 노드에서 프로젝트 캐시를 정의할 때 모든 노드는 같은 프로젝트 캐시를 정의해야 합니다. {1} 프로젝트에는 "{0}" 항목 선언이 포함되어 있지 않습니다.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">필요한 NuGet 어셈블리를 찾을 수 없습니다. 예상 경로: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 단일 프로젝트 캐시 플러그 인이 지정되어야 하지만, {0}에서 여러 개를 찾았습니다.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">다음 작업을 사용하여 재정의를 만들었습니다. {1}의 {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">프로젝트 캐시 플러그인을 초기화 중입니다.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">프로젝트 캐시 플러그인을 종료합니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b893482a44e..1d28f828861 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Ładowanie następującej wtyczki pamięci podręcznej projektu: 
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Ładowanie następującej wtyczki pamięci podręcznej projektu: 
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: nie znaleziono wtyczek pamięci podręcznej projektu w zestawie „{0}”. Oczekiwano jednej.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: gdy dowolny węzeł wykresu statycznego definiuje pamięć podręczną projektu, wszystkie węzły muszą definiować tę samą pamięć podręczną projektu. Następujące projekty nie zawierają deklaracji elementu „{0}”: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ścieżki {0}.</target>
@@ -219,21 +213,11 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: należy określić jedną wtyczkę pamięci podręcznej projektu, ale znaleziono ich wiele: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Utworzono zastąpienie przy użyciu zadania: {0} o {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicjowanie wtyczki pamięci podręcznej projektu.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Zamykanie wtyczki pamięci podręcznej projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index ad14ba37ca1..7b937edcdce 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Carregando o seguinte plug-in do projeto:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Carregando o seguinte plug-in do projeto:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: não foi encontrado nenhum plug-in de cache do projeto no assembly "{0}". Era esperado um plug-in.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: quando algum nó de grafo estático define um cache do projeto, todos os nós precisam definir o mesmo cache do projeto. Os seguintes projetos não contêm uma declaração de item "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Um assembly NuGet necessário não foi encontrado. Caminho Esperado: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: é necessário especificar só um plug-in de cache do projeto, mas foram encontrados vários: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Criou uma substituição usando a tarefa: {0} em {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Inicializando o plugin de cache do projeto.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Desligando o plug-in de cache do projeto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 04004fbdfe1..67f955868cb 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Идет загрузка следующего подключаемого модуля кэша проектов:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Идет загрузка следующего подключаемого модуля кэша проектов:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: не найдены подключаемые модули кэша проектов в сборке "{0}". Должен быть указан один модуль.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: если для какого-либо узла статического графа определен кэш проектов, этот кэш должен быть указан для всех узлов. Следующие проекты не содержат объявление элемента "{0}": {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Не найдена обязательная сборка NuGet. Ожидаемый путь: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: должен быть указан один подключаемый модуль кэша проектов, но найдено несколько: {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Создано переопределение с помощью задачи {0} в {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Инициализация подключаемого модуля кэша проекта.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Завершение работы подключаемого модуля кэша проекта.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 5fc8f54ba4e..9e5ecbf1224 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">Şu proje önbelleği eklentisi yükleniyor:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">Şu proje önbelleği eklentisi yükleniyor:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: "{0}" bütünleştirilmiş kodunda proje önbelleği eklentisi bulunamadı. Bir eklenti bekleniyordu.</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: Herhangi bir statik graf düğümünde proje önbelleği tanımlandığında tüm düğümler aynı proje önbelleğini tanımlamalıdır. Şu projeler "{0}" öğe bildirimini içermiyor: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Gereken NuGet derlemesi bulunamadı. Beklenen Yol: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: Tek bir proje önbellek eklentisi belirtilmelidir ancak birden çok eklenti bulundu: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">{0} görevi kullanılarak geçersiz kılma işlemi oluşturuldu, saat: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">Proje önbellek eklentisi başlatılıyor.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">Proje önbellek eklentisi kapatılıyor.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 4a9d18a374e..910a4d1b585 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">正在加载以下项目缓存插件: 
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">正在加载以下项目缓存插件: 
     {0}”</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: 在程序集 "{0}" 中未找到项目缓存插件。应有一个插件。</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 当任何静态关系图节点定义项目缓存时，所有节点必须定义相同的项目缓存。以下项目不包含 "{0}" 项声明: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">未找到所需的 NuGet 程序集。所需路径: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 必须指定单个项目缓存插件，但找到多个位置: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用任务创建替代: {0} 位于 {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">正在初始化项目缓存插件。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">正在关闭项目缓存插件。</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 214240db01c..7f1c66f04f0 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -143,9 +143,8 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>Loading the following project cache plugin:
-    {0}</source>
-        <target state="translated">正在載入下列專案快取外掛程式:
+        <source>Loading the following project cache plugin: {0}</source>
+        <target state="needs-review-translation">正在載入下列專案快取外掛程式:
     {0}</target>
         <note />
       </trans-unit>
@@ -176,11 +175,6 @@
         <target state="translated">MSB4270: 在組件 "{0}" 中找不到任何專案快取外掛程式，但應該要有一個外掛程式。</target>
         <note />
       </trans-unit>
-      <trans-unit id="NotAllNodesDefineACacheItem">
-        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="translated">MSB4269: 當任何靜態圖表節點定義了專案快取時，所有節點都必須定義相同的專案快取。下列專案不包含 "{0}" 項目宣告: {1}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">找不到必要的 NuGet 元件。預期的路徑: {0}</target>
@@ -219,21 +213,11 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
-      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
-        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="translated">MSB4265: 只可指定單一專案快取外掛程式，但發現多個指定項目: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用下列工作建立覆寫: 於 {1} 的 {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectCacheBeginBuild">
-        <source>Initializing project cache plugin.</source>
-        <target state="translated">正在初始化專案快取外掛程式。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ProjectCacheEndBuild">
         <source>Shutting down project cache plugin.</source>
         <target state="translated">正在關閉專案快取外掛程式。</target>
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 3cb530afca4..24f1c3d74a2 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -2059,20 +2059,25 @@ public BuildResult BuildProjectFile(
                 return buildTask.Result;
             }
 
-            public async Task<BuildResult> BuildProjectFileAsync(
+            public Task<BuildResult> BuildProjectFileAsync(
                 string projectFile,
                 string[] entryTargets = null,
                 Dictionary<string, string> globalProperties = null)
             {
-                var buildRequestData = new BuildRequestData(projectFile,
+                var buildRequestData = new BuildRequestData(
+                    projectFile,
                     globalProperties ?? new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
                     entryTargets ?? Array.Empty<string>(),
                     null);
+                return BuildAsync(buildRequestData);
+            }
 
+            public async Task<BuildResult> BuildAsync(BuildRequestData requestData)
+            {
                 var completion = new TaskCompletionSource<BuildResult>();
 
-                _buildManager.PendBuildRequest(buildRequestData).ExecuteAsync(submission =>
+                _buildManager.PendBuildRequest(requestData).ExecuteAsync(submission =>
                 {
                     completion.SetResult(submission.BuildResult);
                 }, null);
