diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
index 207e0ae8d32..e68725deee1 100644
--- a/documentation/release-checklist.md
+++ b/documentation/release-checklist.md
@@ -19,6 +19,15 @@ OR
   - [ ]  If the release is being cut more than couple of weeks modify [YAML](https://github.com/dotnet/msbuild/tree/main/azure-pipelines/vs-insertion.yml) (and merge to affected MSBuild branches) of the [VS insertion pipeline](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=24295) so that it schedules insertions from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main`. Keep scheduled daily insertions to simplify your workflow and exclude `vs{{THIS_RELEASE_VERSION}}` from triggering insertion on each commit.
 
 ### Branching from main
+- [ ] Ensure planned branch association to the channel
+  - [ ] Check if the association exist (it is now recommended to create it as a part of the previous release checklist):\
+  `darc get-default-channels  --channel "VS {{THIS_RELEASE_VERSION}}" --branch vs{{THIS_RELEASE_VERSION}} --source-repo https://github.com/dotnet/msbuild`
+     - [ ] This step is done if output shows active expected association such as:\
+     `(5997) https://github.com/dotnet/msbuild @ vs17.13 -> VS 17.13`
+     - [ ] If the association is missing - we'll see output similar to:\
+     `No matching channels were found.`
+        - [ ] In such case - associate the `vs{{THIS_RELEASE_VERSION}}` branch with the next VS {{THIS_RELEASE_VERSION}} release channel \
+        `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch vs{{THIS_RELEASE_VERSION}} --repo https://github.com/dotnet/msbuild`
 - [ ]  If the new version's branch was created before the Visual Studio fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
 e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
 _(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
@@ -30,17 +39,19 @@ _(This is for the case where we create the branch too early and want it to be ba
     - [ ]  Update AutoTargetBranch selection in the [YAML](../azure-pipelines/vs-insertion.yml) (add to parameters and make new AutoTargetBranch rule by copying it from existing ones) of the [MSBuild VS Insertion pipeline](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=24295) to insert MSBuild `vs{{THIS_RELEASE_VERSION}}` to the corresponding VS branch `rel/d{{THIS_RELEASE_VERSION}}`.
     - [ ] Add `rel/d{{THIS_RELEASE_VERSION}}` case to TargetBranch parameter in [Experimental insertion](../azure-pipelines/vs-insertion-experimental.yml)
     - [ ] Set scheduled insertion for main and remove exclusion of `vs{{THIS_RELEASE_VERSION}}` triggering on each commit if added earlier.
-- [ ]  Merge {{NEXT_VERSION}} branding PR
+- [ ] Merge {{NEXT_VERSION}} branding PR
 
 ### Adjust DARC channels and subscriptions
 - [ ]  Remove the `main` to old release channel ({{THIS_RELEASE_VERSION}}) default channel \
 `darc delete-default-channel --repo https://github.com/dotnet/msbuild --branch main --channel "VS {{THIS_RELEASE_VERSION}}"`
 - [ ]  Associate the `main` branch with the next release channel \
-`darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch main --repo https://github.com/dotnet/msbuild`
+`darc add-default-channel  --channel "VS {{NEXT_VERSION}}" --branch main --repo https://github.com/dotnet/msbuild`
+- [ ]  Prepare the same channel association as well for the next release branch (vs{{NEXT_VERSION}}) - as a preparation for a next release:\
+  `darc add-default-channel  --channel "VS {{NEXT_VERSION}}" --branch vs{{NEXT_VERSION}} --repo https://github.com/dotnet/msbuild`
 - [ ]  Check subscriptions for the forward-looking channel `VS {{NEXT_VERSION}}` and update as necessary (for instance, SDK's `main` branch should usually be updated, whereas release branches often should not be \
 `darc get-subscriptions --exact --source-repo https://github.com/dotnet/msbuild --channel "VS {{THIS_RELEASE_VERSION}}"`
-- [ ]  Update channel VS {{THIS_RELEASE_VERSION}} to VS {{NEXT_VERSION}} for the sdk main subscription and any others from the previous step
-`darc update-subscription --id sdk_main_branch_id`
+   - [ ]  Update channel VS {{THIS_RELEASE_VERSION}} to VS {{NEXT_VERSION}} for the sdk main subscription and any others from the previous step
+     `darc update-subscription --id <subscription_id_of_msbuild_main_to_sdk_main> --channel "VS {{NEXT_VERSION}}"`
 - [ ]  Ensure that the current release channel `VS {{THIS_RELEASE_VERSION}}` is associated with the correct release branch\
 `darc get-default-channels --source-repo https://github.com/dotnet/msbuild --branch vs{{THIS_RELEASE_VERSION}}` \
 if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch vs{{THIS_RELEASE_VERSION}} --repo https://github.com/dotnet/msbuild`
@@ -57,6 +68,8 @@ if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}"
   - [ ] Arcade:
     - Based on .NET version channel--does not change every MSBuild release
     - `darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --source-repo https://github.com/dotnet/arcade`
+- [ ] Make sure the non-infrastructure dependencies (currently Roslyn and Nuget) are set to 'disabled' (`  - Enabled: False` in the `darc get-subscriptions` output) - we do not want to automatically bump them. The version updates should be explicitly driven by SDK or VS.
+- [ ] Any missing subscription need to be added via `darc add-subscription` command, any misconfigured subscription needs to be edit via `darc update-subscription` command (for additional required and optional parameters run with `--help`)
 
 ### Adjust pipelines / releases
 - [ ]  Fix OptProf data flow for the new vs{{THIS_RELEASE_VERSION}} branch
@@ -72,14 +85,17 @@ if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}"
 - [ ]  Create and merge a PR in main to update a localization version comment in setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/main/.vsts-dotnet.yml) to set up the merge conflict when this line will be updated in the release branch.
 
 ### Final branding
-- [ ]  Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}}
+- [ ] Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}} \
+      Edit Version.props file - add `<DotNetFinalVersionKind>release</DotNetFinalVersionKind>` as a suffix (on same line! - to intentionaly make it merge conflict on flows to main) after the `VersionPrefix`  \
+      e.g.: #11130, #10697
 - [ ]  Merge final branding to `vs{{THIS_RELEASE_VERSION}}` branch
 - [ ]  Update perfstar MSBuild insertions configuration: [example PR](https://dev.azure.com/devdiv/DevDiv/_git/dotnet-perfstar/pullrequest/522843): {{URL_OF_PERFSTAR_PR}}
-- [ ] Note down the build (will be helpful for requesting nuget packages publishing): {{URL_OF_BUILD}}
 - [ ] Get M2 or QB approval as necessary per the VS schedule
 - [ ]  Merge to VS (babysit the automatically generated VS insertion PR https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequests for the MSBuild commit noted in above step): {{URL_OF_VS_INSERTION}}
+     The PR will be helpful for requesting nuget packages publishing - as it contains the inserted packages versions
+    - [ ] Respond to the 'VS xyz package stabilization' email - with the merged insertion PR (as nowVS is on stable version).
 - [ ] Update the PackageValidationBaselineVersion to the latest released version ({{THIS_RELEASE_VERSION}}.0) - this might require temporary addition of the [build artifacts feed](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) as the new version is not yet added to the official feeds (this is post release). This can trigger a high severity CG error (https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/secure-supply-chain/how-to-securely-configure-package-source-files) - however it should be fine to keep this temporary feed untill the release.
-- [ ] Update the requested SDK version for bootstrap folder (the `BootstrapSdkVersion` property in [Versions.props](https://github.com/dotnet/msbuild/blob/main/eng/Versions.props)) and buildToolCommand/_InitializeBuildToolCommand values in cibuild_bootstrapped_msbuild scripts if a fresh sdk was released (released runtimes and associated sdk versions can be checked here - https://dotnet.microsoft.com/download/visual-studio-sdks - make sure to always check the details of the appropriate targeted version of .NET for the matching latest version of SDK).
+- [ ] Update the requested SDK version for bootstrap folder (the `BootstrapSdkVersion` property in [Versions.props](https://github.com/dotnet/msbuild/blob/main/eng/Versions.props)) if a fresh sdk was released (released runtimes and associated sdk versions can be checked here - https://dotnet.microsoft.com/download/visual-studio-sdks - make sure to always check the details of the appropriate targeted version of .NET for the matching latest version of SDK).
 
 ## ASAP On/After GA:
 
@@ -87,7 +103,7 @@ Timing based on the [(Microsoft-internal) release schedule](https://dev.azure.co
 
 - [ ]  Push packages to nuget.org (not currently automated, contact dnceng - search "Publish MSBuild 17.6 to NuGet.org" email subject for template).
 
-  Following packages should be published (`THIS_RELEASE_EXACT_VERSION` is equal to `VersionPrefix` that comes form the eng\Version.props, that were part of the build we are trying to get published):
+  Following packages should be published (`THIS_RELEASE_EXACT_VERSION` is equal to `VersionPrefix` that comes form the eng\Version.props, that were part of the build we are trying to get published, it is as well part of the VS insertion PR noted above):
     - Microsoft.Build.Utilities.Core.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
     - Microsoft.Build.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
     - Microsoft.Build.Framework.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
diff --git a/documentation/specs/proposed/BuildCheck-net10-polishing.md b/documentation/specs/proposed/BuildCheck-net10-polishing.md
new file mode 100644
index 00000000000..55dc5366f08
--- /dev/null
+++ b/documentation/specs/proposed/BuildCheck-net10-polishing.md
@@ -0,0 +1,69 @@
+# BuildCheck Net10 polishing 
+
+In net 9.0 we delivered initial preview of BuildCheck feature. 
+ * Spec: https://github.com/dotnet/msbuild/blob/main/documentation/specs/BuildCheck/BuildCheck.md
+ * Work track:  https://github.com/orgs/dotnet/projects/373
+
+In addition to that we have an item tracking possible improvements and extensions of the feature: https://github.com/dotnet/msbuild/issues/10548
+
+This doc focuses on a minimal investment path that would allow driving adoption of the BuildChecks feature and collecting feedback from real life usage.
+
+## Goals and Motivation 
+
+* Making sure the feature can be used in the real life scenarios.
+* Driving adoption.
+
+## Impact 
+
+* MSBuild team has a venue to evangelise best practices for the build.
+* Customers have a tool to formalize and distribute their view of best practices.
+* MSBuild team can improving end-user build perf and security with high leverage by providing new Checks notifying about problems.
+
+
+## Stakeholders 
+- PM (@baronfel) - as a customer advocate
+- Selected internal partner repo owners (details https://github.com/dotnet/msbuild/issues/10726)
+
+### Successful handover
+- Internal partner teams' ideas around BuildChecks collected and considered.
+- Selected internal partner teams are using BuildChecks in their build pipelines.
+- BuildChecks being evangelized externaly, adoption numbers grow up.
+
+## Risks 
+- Performance degradation is unacceptable on real scale project.
+- There are multiple hard to investigate and/or hard to fix bugs identified during initial adoptions.
+- Unsatisfactory specificity and/or sensitivity - leading to diminishing the perceived value of Checks and endangering the motivation to adopt them.
+- Low perceived value of best practices enforced by the checks.
+- Confusing diagnostics/documentation leading to lowering the educational value.
+
+
+## Scope
+
+### Goals
+* MSBuild team runs buildchecks on selected partner repos (via private runs), identifying and fixing issues
+* MSBuild team helps selected partner teams to enable buildchecks on their repos (in official runs), and providing initial support
+
+### Non-Goals
+
+* Measuring and defining the perf impact, detecting the sources of it
+  This doc doesn't cover the perf measurement and analysis - see [the PerfStar one page for this topic](https://github.com/dotnet/msbuild/pull/11045/files#diff-dcbd46135c1492f7b8f0c1221118a6ec7c241b86e6493d5a93f2c2f83b50b7bfR21)
+* Providing additional helpful low-hanging-fruit checks
+
+### Out of scope
+
+* OM/API enriching
+* Configuration and other features improvements
+* VS, VS-Code integrations
+
+## Cost 
+
+The below plan is expected with 0.25 Dev / Month investment (except for Month #2, that will realistically need ~0.5-2 Dev / Month)
+
+## Suggested plan 
+* Month #1 - Running build checks on selected partner repos and identifying issues
+* Month #2 - Resolve identified adoption blockers
+* Month #2 optional - run perf tests and define perf profile for build with Checks.
+* Month #3 - Enabling buildchecks on partner repos, providing initial support
+* Month #4 - Evangelization and driving the adoption in external community
+
+ 
\ No newline at end of file
diff --git a/documentation/specs/proposed/General_perf_onepager.md b/documentation/specs/proposed/General_perf_onepager.md
new file mode 100644
index 00000000000..347b5fb0de2
--- /dev/null
+++ b/documentation/specs/proposed/General_perf_onepager.md
@@ -0,0 +1,41 @@
+# General performance improvements
+MSBuild is the main tool used for building various types of projects. It is used by Visual Studio, the .NET CLI, and other build tools. The performance of MSBuild is critical to the productivity of developers. This document outlines our goals to improve overall performance of MSBuild.
+
+## Goals and Motivation
+
+We are aiming for:
+ - Searching for opportunities to improve evaluation and build times. We can utilize the data collected by ETW traces, the VS perf lab, and previously identified performance issues.
+ - Reducing MSBuild overhead in the Visual Studio IDE.
+ - Collecting data to understand the current performance bottlenecks.
+
+This document does not cover specific performance improvements, but rather outlines the general goals and motivation for the performance improvements.
+
+## Impact
+    
+ - Opening project/solution, branch switching and other operations using MSBuild code in VS should be less impacted by the MSBuild.
+ - Overall build times should be reduced. 
+ - Even a small improvement can save a lot of time and computing resources across all builds done daily worldwide.
+
+## Stakeholders
+
+    - Chet Husk (PM) - as a customer advocate
+    - David Kean - as a VS performance expert
+
+## Risks
+
+ - Performance improvements might not be as significant as expected.
+ - We can break existing functionality while making changes.
+ - Some ideas and performance measurement findings might need to be skipped due to technical limitations or complexity/improvements ratio.
+
+## Cost
+
+Performance improvements are a long-term investment. We need to balance the cost of the improvements with the expected benefits.
+We will need to invest time in collecting data, analyzing the data, and implementing improvements.
+
+Our goal in this scope is to find small and medium size opprotunities (Achievable within a single sprint with 1-2 dev investment). Bigger functionalities such as evaluation caching and RAR caching are described in separate documents.
+
+## Plan
+    
+ - Collect data on the current performance bottlenecks.
+ - Identify opportunities for improvements.
+ - Implement improvements in time-boxed iterations.
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 22715bc8adc..0a45a310295 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,9 +2,9 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.24619.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25066.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>e2b1d16fd66540b3a5813ec0ac1fd166688c3e0a</Sha>
+      <Sha>93a3395781d30f69201367371c28cfc5005c0264</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
@@ -75,36 +75,36 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25058.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>8cc6ecd76c24ef6665579a5c5e386a211a1e7c54</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25058.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>8cc6ecd76c24ef6665579a5c5e386a211a1e7c54</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25058.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>8cc6ecd76c24ef6665579a5c5e386a211a1e7c54</Sha>
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.13.0-rc.108">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>89781a27ff255553766e4b9403ea7947072b4335</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.13.0-3.24614.4">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.13.0-3.25057.3">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>633f34af4fe019eaf0c2e830bdc07c891ecd49f7</Sha>
+      <Sha>911cf5f462960bdd01df1ea3c0d0c217b3c3838b</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.13.0-3.24614.4">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.13.0-3.25057.3">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>633f34af4fe019eaf0c2e830bdc07c891ecd49f7</Sha>
+      <Sha>911cf5f462960bdd01df1ea3c0d0c217b3c3838b</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25058.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>8cc6ecd76c24ef6665579a5c5e386a211a1e7c54</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 9cdbfba3b2e..5bccc1acc05 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -65,8 +65,8 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24623.3</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.13.0-3.24614.4</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25058.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.13.0-3.25057.3</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.13.0-rc.108</NuGetBuildTasksVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
diff --git a/global.json b/global.json
index 8d2ec6f0928..54f518939c6 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24623.3"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25058.5"
   }
 }
diff --git a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
index 829eae89400..5cc7e4309cc 100644
--- a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
@@ -1,4 +1,4 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Globalization;
@@ -11,6 +11,7 @@
 
 using Xunit;
 using Xunit.Abstractions;
+using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
 
 namespace Microsoft.Build.Engine.UnitTests.Evaluation
 {
@@ -25,7 +26,7 @@ public class ExpanderFunction_Tests
         [Fact]
         public void TryConvertToIntGivenNull()
         {
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(null, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(null, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -33,7 +34,7 @@ public void TryConvertToIntGivenNull()
         public void TryConvertToIntGivenDouble()
         {
             const double value = 10.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -41,7 +42,7 @@ public void TryConvertToIntGivenDouble()
         public void TryConvertToIntGivenLong()
         {
             const long value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -49,7 +50,7 @@ public void TryConvertToIntGivenLong()
         public void TryConvertToIntGivenInt()
         {
             const int value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -57,7 +58,7 @@ public void TryConvertToIntGivenInt()
         public void TryConvertToIntGivenString()
         {
             const string value = "10";
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -66,7 +67,7 @@ public void TryConvertToIntGivenDoubleWithIntMinValue()
         {
             const int expected = int.MinValue;
             const double value = expected;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -75,7 +76,7 @@ public void TryConvertToIntGivenDoubleWithIntMaxValue()
         {
             const int expected = int.MaxValue;
             const double value = expected;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -83,7 +84,7 @@ public void TryConvertToIntGivenDoubleWithIntMaxValue()
         public void TryConvertToIntGivenDoubleWithLessThanIntMinValue()
         {
             const double value = int.MinValue - 1.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -91,7 +92,7 @@ public void TryConvertToIntGivenDoubleWithLessThanIntMinValue()
         public void TryConvertToIntGivenDoubleWithGreaterThanIntMaxValue()
         {
             const double value = int.MaxValue + 1.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -99,7 +100,7 @@ public void TryConvertToIntGivenDoubleWithGreaterThanIntMaxValue()
         public void TryConvertToIntGivenLongWithGreaterThanIntMaxValue()
         {
             const long value = int.MaxValue + 1L;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -108,7 +109,7 @@ public void TryConvertToIntGivenLongWithGreaterThanIntMaxValue()
         [Fact]
         public void TryConvertToLongGivenNull()
         {
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(null, out long actual).ShouldBeFalse();
+            ParseArgs.TryConvertToLong(null, out long actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -116,7 +117,7 @@ public void TryConvertToLongGivenNull()
         public void TryConvertToLongGivenDouble()
         {
             const double value = 10.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -124,7 +125,7 @@ public void TryConvertToLongGivenDouble()
         public void TryConvertToLongGivenLong()
         {
             const long value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -132,7 +133,7 @@ public void TryConvertToLongGivenLong()
         public void TryConvertToLongGivenInt()
         {
             const int value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -140,7 +141,7 @@ public void TryConvertToLongGivenInt()
         public void TryConvertToLongGivenString()
         {
             const string value = "10";
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -149,7 +150,7 @@ public void TryConvertToLongGivenDoubleWithLongMinValue()
         {
             const long expected = long.MinValue;
             const double value = expected;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -159,14 +160,14 @@ public void TryConvertToLongGivenDoubleWithLongMaxValueShouldNotThrow()
             // An OverflowException should not be thrown from TryConvertToLong().
             // Convert.ToInt64(double) has a defect and will throw an OverflowException
             // for values >= (long.MaxValue - 511) and <= long.MaxValue.
-            _ = Should.NotThrow(() => Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)long.MaxValue, out _));
+            _ = Should.NotThrow(() => ParseArgs.TryConvertToLong((double)long.MaxValue, out _));
         }
 
         [WindowsFullFrameworkOnlyFact]
         public void TryConvertToLongGivenDoubleWithLongMaxValueFramework()
         {
             const long longMaxValue = long.MaxValue;
-            bool result = Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)longMaxValue, out long actual);
+            bool result = ParseArgs.TryConvertToLong((double)longMaxValue, out long actual);
 
             // Because of loss of precision, long.MaxValue will not 'round trip' from long to double to long.
             result.ShouldBeFalse();
@@ -177,7 +178,7 @@ public void TryConvertToLongGivenDoubleWithLongMaxValueFramework()
         public void TryConvertToLongGivenDoubleWithLongMaxValueDotNet()
         {
             const long longMaxValue = long.MaxValue;
-            bool result = Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)longMaxValue, out long actual);
+            bool result = ParseArgs.TryConvertToLong((double)longMaxValue, out long actual);
 
             // Testing on macOS 12 on Apple Silicon M1 Pro produces different result.
             result.ShouldBeTrue();
@@ -192,7 +193,7 @@ public void TryConvertToLongGivenDoubleWithVeryLargeLongValue()
             const long veryLargeLong = long.MaxValue - 512;
             const double value = veryLargeLong;
             const long expected = 9223372036854774784L;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -200,7 +201,7 @@ public void TryConvertToLongGivenDoubleWithVeryLargeLongValue()
         public void TryConvertToLongGivenDoubleWithLessThanLongMinValue()
         {
             const double value = -92233720368547758081D;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeFalse();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -208,7 +209,7 @@ public void TryConvertToLongGivenDoubleWithLessThanLongMinValue()
         public void TryConvertToLongGivenDoubleWithGreaterThanLongMaxValue()
         {
             const double value = (double)long.MaxValue + long.MaxValue;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeFalse();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -217,7 +218,7 @@ public void TryConvertToLongGivenDoubleWithGreaterThanLongMaxValue()
         [Fact]
         public void TryConvertToDoubleGivenNull()
         {
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(null, out double actual).ShouldBeFalse();
+            ParseArgs.TryConvertToDouble(null, out double actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -225,7 +226,7 @@ public void TryConvertToDoubleGivenNull()
         public void TryConvertToDoubleGivenDouble()
         {
             const double value = 10.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -233,7 +234,7 @@ public void TryConvertToDoubleGivenDouble()
         public void TryConvertToDoubleGivenLong()
         {
             const long value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -241,7 +242,7 @@ public void TryConvertToDoubleGivenLong()
         public void TryConvertToDoubleGivenInt()
         {
             const int value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -249,7 +250,7 @@ public void TryConvertToDoubleGivenInt()
         public void TryConvertToDoubleGivenString()
         {
             const string value = "10";
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -267,7 +268,7 @@ public void TryConvertToDoubleGivenStringAndLocale()
                 // The invariant culture should be used and "1,2" should be 12.0 not 1.2.
                 var cultureEnglishSouthAfrica = CultureInfo.CreateSpecificCulture("en-ZA");
                 currentThread.CurrentCulture = cultureEnglishSouthAfrica;
-                Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+                ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
                 actual.ShouldBe(12.0);
             }
             finally
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 05ad3902a6f..84b34d5c67a 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Evaluation.Expander;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
@@ -24,6 +25,7 @@
 using Microsoft.Win32;
 using AvailableStaticMethods = Microsoft.Build.Internal.AvailableStaticMethods;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
@@ -3496,7 +3498,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
 
                         // For our intrinsic function we need to support calling of internal methods
                         // since we don't want them to be public
-                        if (_receiverType == typeof(Microsoft.Build.Evaluation.IntrinsicFunctions))
+                        if (_receiverType == typeof(IntrinsicFunctions))
                         {
                             _bindingFlags |= BindingFlags.NonPublic;
                         }
@@ -3538,8 +3540,8 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         {
                             // Unescape the value since we're about to send it out of the engine and into
                             // the function being called. If a file or a directory function, fix the path
-                            if (_receiverType == typeof(System.IO.File) || _receiverType == typeof(System.IO.Directory)
-                                || _receiverType == typeof(System.IO.Path))
+                            if (_receiverType == typeof(File) || _receiverType == typeof(Directory)
+                                || _receiverType == typeof(Path))
                             {
                                 argumentValue = FileUtilities.FixFilePath(argumentValue);
                             }
@@ -3561,7 +3563,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", _methodMethodName, StringComparison.OrdinalIgnoreCase)))
                     {
                         // Support comparison when the lhs is an integer
-                        if (IsFloatingPointRepresentation(args[0]))
+                        if (ParseArgs.IsFloatingPointRepresentation(args[0]))
                         {
                             if (double.TryParse(objectInstance.ToString(), NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double result))
                             {
@@ -3592,7 +3594,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     // need to locate an appropriate constructor and invoke it
                     if (String.Equals("new", _methodMethodName, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (!TryExecuteWellKnownConstructorNoThrow(out functionResult, args))
+                        if (!WellKnownFunctions.TryExecuteWellKnownConstructorNoThrow(_receiverType, out functionResult, args))
                         {
                             functionResult = LateBindExecute(null /* no previous exception */, BindingFlags.Public | BindingFlags.Instance, null /* no instance for a constructor */, args, true /* is constructor */);
                         }
@@ -3605,12 +3607,12 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         {
                             // First attempt to recognize some well-known functions to avoid binding
                             // and potential first-chance MissingMethodExceptions.
-                            wellKnownFunctionSuccess = TryExecuteWellKnownFunction(out functionResult, objectInstance, args);
+                            wellKnownFunctionSuccess = WellKnownFunctions.TryExecuteWellKnownFunction(_methodMethodName, _receiverType, _fileSystem, out functionResult, objectInstance, args);
 
                             if (!wellKnownFunctionSuccess)
                             {
                                 // Some well-known functions need evaluated value from properties.
-                                wellKnownFunctionSuccess = TryExecuteWellKnownFunctionWithPropertiesParam(properties, out functionResult, objectInstance, args);
+                                wellKnownFunctionSuccess = WellKnownFunctions.TryExecuteWellKnownFunctionWithPropertiesParam(_methodMethodName, _receiverType, _loggingContext, properties, out functionResult, objectInstance, args);
                             }
                         }
                         // we need to preserve the same behavior on exceptions as the actual binder
@@ -3717,1342 +3719,46 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                 }
             }
 
-            private bool TryExecuteWellKnownFunctionWithPropertiesParam(IPropertyProvider<T> properties, out object returnVal, object objectInstance, object[] args)
-            {
-                returnVal = null;
-
-                if (_receiverType == typeof(IntrinsicFunctions))
-                {
-                    if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
-                    {
-                        string projectPath = properties.GetProperty("MSBuildProjectFullPath")?.EvaluatedValue ?? string.Empty;
-                        ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = IntrinsicFunctions.RegisterBuildCheck(projectPath, arg0, _loggingContext);
-                            return true;
-                        }
-                    }
-                }
-
-                return false;
-            }
-
-            private object GetMethodResult(object objectInstance, IEnumerable<MethodInfo> methods, object[] args, int index)
-            {
-                for (int i = index; i < args.Length; i++)
-                {
-                    if (args[i].Equals("out _"))
-                    {
-                        object toReturn = null;
-                        foreach (MethodInfo method in methods)
-                        {
-                            Type t = method.GetParameters()[i].ParameterType;
-                            args[i] = t.IsValueType ? Activator.CreateInstance(t) : null;
-                            object currentReturnValue = GetMethodResult(objectInstance, methods, args, i + 1);
-                            if (currentReturnValue is not null)
-                            {
-                                if (toReturn is null)
-                                {
-                                    toReturn = currentReturnValue;
-                                }
-                                else if (!toReturn.Equals(currentReturnValue))
-                                {
-                                    // There were multiple methods that seemed viable and gave different results. We can't differentiate between them so throw.
-                                    ErrorUtilities.ThrowArgument("CouldNotDifferentiateBetweenCompatibleMethods", _methodMethodName, args.Length);
-                                    return null;
-                                }
-                            }
-                        }
-
-                        return toReturn;
-                    }
-                }
-
-                try
-                {
-                    return _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture) ?? "null";
-                }
-                catch (Exception)
-                {
-                    // This isn't a viable option, but perhaps another set of parameters will work.
-                    return null;
-                }
-            }
-
-            /// <summary>
-            /// Shortcut to avoid calling into binding if we recognize some most common functions.
-            /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
-            /// bad for debugging experience and has a performance cost.
-            /// A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
-            /// (rough numbers just for comparison).
-            /// See https://github.com/dotnet/msbuild/issues/2217.
-            /// </summary>
-            /// <param name="returnVal">The value returned from the function call.</param>
-            /// <param name="objectInstance">Object that the function is called on.</param>
-            /// <param name="args">arguments.</param>
-            /// <returns>True if the well known function call binding was successful.</returns>
-            private bool TryExecuteWellKnownFunction(out object returnVal, object objectInstance, object[] args)
-            {
-                returnVal = null;
-
-                if (objectInstance is string text)
-                {
-                    if (string.Equals(_methodMethodName, nameof(string.StartsWith), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.StartsWith(arg0);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Replace), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArgs(args, out string arg0, out string arg1))
-                        {
-                            returnVal = text.Replace(arg0, arg1);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Contains), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.Contains(arg0);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.ToUpperInvariant), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.ToUpperInvariant();
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.ToLowerInvariant), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.ToLowerInvariant();
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.EndsWith), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.EndsWith(arg0);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.ToLower), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.ToLower();
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.IndexOf), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArgs(args, out string arg0, out StringComparison arg1))
-                        {
-                            returnVal = text.IndexOf(arg0, arg1);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.IndexOfAny), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.IndexOfAny(arg0.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.LastIndexOf), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.LastIndexOf(arg0);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out arg0, out int startIndex))
-                        {
-                            returnVal = text.LastIndexOf(arg0, startIndex);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out arg0, out StringComparison arg1))
-                        {
-                            returnVal = text.LastIndexOf(arg0, arg1);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.LastIndexOfAny), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.LastIndexOfAny(arg0.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.Length;
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Substring), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int startIndex))
-                        {
-                            returnVal = text.Substring(startIndex);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out startIndex, out int length))
-                        {
-                            returnVal = text.Substring(startIndex, length);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Split), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string separator) && separator.Length == 1)
-                        {
-                            returnVal = text.Split(separator[0]);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.PadLeft), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int totalWidth))
-                        {
-                            returnVal = text.PadLeft(totalWidth);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out totalWidth, out string paddingChar) && paddingChar.Length == 1)
-                        {
-                            returnVal = text.PadLeft(totalWidth, paddingChar[0]);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.PadRight), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int totalWidth))
-                        {
-                            returnVal = text.PadRight(totalWidth);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out totalWidth, out string paddingChar) && paddingChar.Length == 1)
-                        {
-                            returnVal = text.PadRight(totalWidth, paddingChar[0]);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.TrimStart), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string trimChars) && trimChars.Length > 0)
-                        {
-                            returnVal = text.TrimStart(trimChars.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.TrimEnd), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string trimChars) && trimChars.Length > 0)
-                        {
-                            returnVal = text.TrimEnd(trimChars.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, "get_Chars", StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int index))
-                        {
-                            returnVal = text[index];
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Equals), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.Equals(arg0);
-                            return true;
-                        }
-                    }
-                }
-                else if (objectInstance is string[] stringArray)
-                {
-                    if (string.Equals(_methodMethodName, "GetValue", StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int index))
-                        {
-                            returnVal = stringArray[index];
-                            return true;
-                        }
-                    }
-                }
-                else if (objectInstance == null) // Calling a well-known static function
-                {
-                    if (_receiverType == typeof(string))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(string.IsNullOrWhiteSpace), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = string.IsNullOrWhiteSpace(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(string.IsNullOrEmpty), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = string.IsNullOrEmpty(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(string.Copy), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = arg0;
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Math))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Math.Max), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out var arg0, out double arg1))
-                            {
-                                returnVal = Math.Max(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Math.Min), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out double arg0, out var arg1))
-                            {
-                                returnVal = Math.Min(arg0, arg1);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(IntrinsicFunctions))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.EnsureTrailingSlash(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ValueOrDefault), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.ValueOrDefault(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.NormalizePath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (ElementsOfType(args, typeof(string)))
-                            {
-                                returnVal = IntrinsicFunctions.NormalizePath(Array.ConvertAll(args, o => (string)o));
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetDirectoryNameOfFileAbove), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.GetDirectoryNameOfFileAbove(arg0, arg1, _fileSystem);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetRegistryValueFromView), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length >= 4 &&
-                                TryGetArgs(args, out string arg0, out string arg1, enforceLength: false))
-                            {
-                                returnVal = IntrinsicFunctions.GetRegistryValueFromView(arg0, arg1, args[2], new ArraySegment<object>(args, 3, args.Length - 3));
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsRunningFromVisualStudio), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.IsRunningFromVisualStudio();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Escape), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.Escape(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Unescape), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.Unescape(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetPathOfFileAbove), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.GetPathOfFileAbove(arg0, arg1, _fileSystem);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Add), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Add, IntrinsicFunctions.Add, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Subtract), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Subtract, IntrinsicFunctions.Subtract, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Multiply), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Multiply, IntrinsicFunctions.Multiply, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Divide), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Divide, IntrinsicFunctions.Divide, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Modulo), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Modulo, IntrinsicFunctions.Modulo, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetCurrentToolsDirectory), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetCurrentToolsDirectory();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetToolsDirectory32), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetToolsDirectory32();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetToolsDirectory64), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetToolsDirectory64();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetMSBuildSDKsPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetMSBuildSDKsPath();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetVsInstallRoot), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetVsInstallRoot();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetMSBuildExtensionsPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetMSBuildExtensionsPath();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetProgramFiles32), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetProgramFiles32();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionNotEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionNotEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionGreaterThan), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionGreaterThan(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionGreaterThanOrEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionGreaterThanOrEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionLessThan), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionLessThan(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionLessThanOrEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionLessThanOrEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkIdentifier), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetFrameworkIdentifier(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkVersion), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
-                                return true;
-                            }
-                            if (TryGetArgs(args, out string arg1, out int arg2))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg1, arg2);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.IsTargetFrameworkCompatible(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformIdentifier), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetPlatformIdentifier(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformVersion), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg0);
-                                return true;
-                            }
-                            if (TryGetArgs(args, out string arg1, out int arg2))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg1, arg2);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ConvertToBase64), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.ConvertToBase64(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ConvertFromBase64), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.ConvertFromBase64(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.StableStringHash), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                // Prevent loading methods refs from StringTools if ChangeWave opted out.
-                                returnVal = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
-                                    ? IntrinsicFunctions.StableStringHash(arg0)
-                                    : IntrinsicFunctions.StableStringHashLegacy(arg0);
-                                return true;
-                            }
-                            else if (TryGetArgs(args, out string arg1, out string arg2) && Enum.TryParse<IntrinsicFunctions.StringHashingAlgorithm>(arg2, true, out var hashAlgorithm))
-                            {
-                                returnVal = IntrinsicFunctions.StableStringHash(arg1, hashAlgorithm);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.AreFeaturesEnabled), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out Version arg0))
-                            {
-                                returnVal = IntrinsicFunctions.AreFeaturesEnabled(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.SubstringByAsciiChars), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out int arg1, out int arg2))
-                            {
-                                returnVal = IntrinsicFunctions.SubstringByAsciiChars(arg0, arg1, arg2);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.CheckFeatureAvailability), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.CheckFeatureAvailability(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseOr), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseOr(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseAnd), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseAnd(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseXor), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseXor(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseNot), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseNot(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.LeftShift), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.LeftShift(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShift), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.RightShift(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShiftUnsigned), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.RightShiftUnsigned(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.NormalizeDirectory), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.NormalizeDirectory(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsOSPlatform), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.IsOSPlatform(arg0);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Path))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Path.Combine), StringComparison.OrdinalIgnoreCase))
-                        {
-                            string arg0, arg1, arg2, arg3;
-
-                            // Combine has fast implementations for up to 4 parameters: https://github.com/dotnet/corefx/blob/2c55db90d622fa6279184e6243f0470a3755d13c/src/Common/src/CoreLib/System/IO/Path.cs#L293-L317
-                            switch (args.Length)
-                            {
-                                case 0:
-                                    return false;
-                                case 1:
-                                    if (TryGetArg(args, out arg0))
-                                    {
-                                        returnVal = Path.Combine(arg0);
-                                        return true;
-                                    }
-                                    break;
-                                case 2:
-                                    if (TryGetArgs(args, out arg0, out arg1))
-                                    {
-                                        returnVal = Path.Combine(arg0, arg1);
-                                        return true;
-                                    }
-                                    break;
-                                case 3:
-                                    if (TryGetArgs(args, out arg0, out arg1, out arg2))
-                                    {
-                                        returnVal = Path.Combine(arg0, arg1, arg2);
-                                        return true;
-                                    }
-                                    break;
-                                case 4:
-                                    if (TryGetArgs(args, out arg0, out arg1, out arg2, out arg3))
-                                    {
-                                        returnVal = Path.Combine(arg0, arg1, arg2, arg3);
-                                        return true;
-                                    }
-                                    break;
-                                default:
-                                    if (ElementsOfType(args, typeof(string)))
-                                    {
-                                        returnVal = Path.Combine(Array.ConvertAll(args, o => (string)o));
-                                        return true;
-                                    }
-                                    break;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.DirectorySeparatorChar), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = Path.DirectorySeparatorChar;
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetFullPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetFullPath(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.IsPathRooted), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.IsPathRooted(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetTempPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = Path.GetTempPath();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetFileName), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetFileName(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetDirectoryName), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetDirectoryName(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetFileNameWithoutExtension), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetFileNameWithoutExtension(arg0);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Version))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Version.Parse), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Version.Parse(arg0);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Guid))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Guid.NewGuid), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = Guid.NewGuid();
-                                return true;
-                            }
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(Regex.Replace), StringComparison.OrdinalIgnoreCase) && args.Length == 3)
-                    {
-                        if (TryGetArg([args[0]], out string arg1) && TryGetArg([args[1]], out string arg2) && TryGetArg([args[2]], out string arg3))
-                        {
-                            returnVal = Regex.Replace(arg1, arg2, arg3);
-                            return true;
-                        }
-                    }
-                }
-                else if (string.Equals(_methodMethodName, nameof(Version.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is Version v)
-                {
-                    if (TryGetArg(args, out int arg0))
-                    {
-                        returnVal = v.ToString(arg0);
-                        return true;
-                    }
-                }
-                else if (string.Equals(_methodMethodName, nameof(Int32.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is int i)
-                {
-                    if (TryGetArg(args, out string arg0))
-                    {
-                        returnVal = i.ToString(arg0);
-                        return true;
-                    }
-                }
-                if (Traits.Instance.LogPropertyFunctionsRequiringReflection)
-                {
-                    LogFunctionCall("PropertyFunctionsRequiringReflection", objectInstance, args);
-                }
-
-                return false;
-            }
-
-            /// <summary>
-            /// Shortcut to avoid calling into binding if we recognize some most common constructors.
-            /// Analogous to TryExecuteWellKnownFunction but guaranteed to not throw.
-            /// </summary>
-            /// <param name="returnVal">The instance as created by the constructor call.</param>
-            /// <param name="args">Arguments.</param>
-            /// <returns>True if the well known constructor call binding was successful.</returns>
-            private bool TryExecuteWellKnownConstructorNoThrow(out object returnVal, object[] args)
-            {
-                returnVal = null;
-
-                if (_receiverType == typeof(string))
-                {
-                    if (args.Length == 0)
-                    {
-                        returnVal = String.Empty;
-                        return true;
-                    }
-                    if (TryGetArg(args, out string arg0))
-                    {
-                        returnVal = arg0;
-                        return true;
-                    }
-                }
-                return false;
-            }
-
-            private bool ElementsOfType(object[] args, Type type)
+            private object GetMethodResult(object objectInstance, IEnumerable<MethodInfo> methods, object[] args, int index)
             {
-                for (var i = 0; i < args.Length; i++)
+                for (int i = index; i < args.Length; i++)
                 {
-                    if (args[i].GetType() != type)
+                    if (args[i].Equals("out _"))
                     {
-                        return false;
-                    }
-                }
-
-                return true;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out string arg1, bool enforceLength = true)
-            {
-                arg0 = null;
-                arg1 = null;
-
-                if (enforceLength && args.Length != 2)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private bool TryGetArgs(object[] args, out string arg0, out string arg1, out string arg2)
-            {
-                arg0 = null;
-                arg1 = null;
-                arg2 = null;
-
-                if (args.Length != 3)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1 &&
-                    args[2] is string value2)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-                    arg2 = value2;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private bool TryGetArgs(object[] args, out string arg0, out string arg1, out string arg2, out string arg3)
-            {
-                arg0 = null;
-                arg1 = null;
-                arg2 = null;
-                arg3 = null;
-
-                if (args.Length != 4)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1 &&
-                    args[2] is string value2 &&
-                    args[3] is string value3)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-                    arg2 = value2;
-                    arg3 = value3;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private bool TryGetArgs(object[] args, out string arg0, out string arg1)
-            {
-                arg0 = null;
-                arg1 = null;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out int arg1, out int arg2)
-            {
-                arg0 = null;
-                arg1 = 0;
-                arg2 = 0;
-
-                if (args.Length != 3)
-                {
-                    return false;
-                }
-
-                var value1 = args[1] as string;
-                var value2 = args[2] as string;
-                arg0 = args[0] as string;
-                if (value1 != null &&
-                    value2 != null &&
-                    arg0 != null &&
-                    int.TryParse(value1, out arg1) &&
-                    int.TryParse(value2, out arg2))
-                {
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool TryGetArg(object[] args, out int arg0)
-            {
-                if (args.Length != 1)
-                {
-                    arg0 = 0;
-                    return false;
-                }
-
-                return TryConvertToInt(args[0], out arg0);
-            }
-
-            private static bool TryGetArg(object[] args, out Version arg0)
-            {
-                if (args.Length != 1)
-                {
-                    arg0 = default;
-                    return false;
-                }
-
-                return TryConvertToVersion(args[0], out arg0);
-            }
-
-            private static bool TryConvertToVersion(object value, out Version arg0)
-            {
-                string val = value as string;
-
-                if (string.IsNullOrEmpty(val) || !Version.TryParse(val, out arg0))
-                {
-                    arg0 = default;
-                    return false;
-                }
-
-                return true;
-            }
-
-            /// <summary>
-            /// Try to convert value to int.
-            /// </summary>
-            internal static bool TryConvertToInt(object value, out int arg)
-            {
-                switch (value)
-                {
-                    case double d:
-                        if (d >= int.MinValue && d <= int.MaxValue)
-                        {
-                            arg = Convert.ToInt32(d);
-                            if (Math.Abs(arg - d) == 0)
-                            {
-                                return true;
-                            }
-                        }
-
-                        break;
-                    case long l:
-                        if (l >= int.MinValue && l <= int.MaxValue)
-                        {
-                            arg = Convert.ToInt32(l);
-                            return true;
-                        }
-
-                        break;
-                    case int i:
-                        arg = i;
-                        return true;
-                    case string s when int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
-                        return true;
-                }
-
-                arg = 0;
-                return false;
-            }
-
-            /// <summary>
-            /// Try to convert value to long.
-            /// </summary>
-            internal static bool TryConvertToLong(object value, out long arg)
-            {
-                switch (value)
-                {
-                    case double d:
-                        if (d >= long.MinValue && d <= long.MaxValue)
+                        object toReturn = null;
+                        foreach (MethodInfo method in methods)
                         {
-                            arg = (long)d;
-                            if (Math.Abs(arg - d) == 0)
+                            Type t = method.GetParameters()[i].ParameterType;
+                            args[i] = t.IsValueType ? Activator.CreateInstance(t) : null;
+                            object currentReturnValue = GetMethodResult(objectInstance, methods, args, i + 1);
+                            if (currentReturnValue is not null)
                             {
-                                return true;
+                                if (toReturn is null)
+                                {
+                                    toReturn = currentReturnValue;
+                                }
+                                else if (!toReturn.Equals(currentReturnValue))
+                                {
+                                    // There were multiple methods that seemed viable and gave different results. We can't differentiate between them so throw.
+                                    ErrorUtilities.ThrowArgument("CouldNotDifferentiateBetweenCompatibleMethods", _methodMethodName, args.Length);
+                                    return null;
+                                }
                             }
                         }
 
-                        break;
-                    case long l:
-                        arg = l;
-                        return true;
-                    case int i:
-                        arg = i;
-                        return true;
-                    case string s when long.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
-                        return true;
-                }
-
-                arg = 0;
-                return false;
-            }
-
-            /// <summary>
-            /// Try to convert value to double.
-            /// </summary>
-            internal static bool TryConvertToDouble(object value, out double arg)
-            {
-                switch (value)
-                {
-                    case double unboxed:
-                        arg = unboxed;
-                        return true;
-                    case long l:
-                        arg = l;
-                        return true;
-                    case int i:
-                        arg = i;
-                        return true;
-                    case string str when double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out arg):
-                        return true;
-                    default:
-                        arg = 0;
-                        return false;
-                }
-            }
-
-            private static bool TryGetArg(object[] args, out string arg0)
-            {
-                if (args.Length != 1)
-                {
-                    arg0 = null;
-                    return false;
-                }
-
-                arg0 = args[0] as string;
-                return arg0 != null;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out StringComparison arg1)
-            {
-                if (args.Length != 2)
-                {
-                    arg0 = null;
-                    arg1 = default;
-
-                    return false;
-                }
-
-                arg0 = args[0] as string;
-
-                // reject enums as ints. In C# this would require a cast, which is not supported in msbuild expressions
-                if (arg0 == null || !(args[1] is string comparisonTypeName) || int.TryParse(comparisonTypeName, out _))
-                {
-                    arg1 = default;
-                    return false;
-                }
-
-                // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
-                if (comparisonTypeName.Contains('.'))
-                {
-                    comparisonTypeName = comparisonTypeName.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
-                }
-
-                return Enum.TryParse(comparisonTypeName, out arg1);
-            }
-
-            private static bool TryGetArgs(object[] args, out int arg0)
-            {
-                arg0 = 0;
-
-                if (args.Length != 1)
-                {
-                    return false;
-                }
-
-                return TryConvertToInt(args[0], out arg0);
-            }
-
-            private static bool TryGetArgs(object[] args, out int arg0, out int arg1)
-            {
-                arg0 = 0;
-                arg1 = 0;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                return TryConvertToInt(args[0], out arg0) &&
-                       TryConvertToInt(args[1], out arg1);
-            }
-
-            private static bool TryGetArgs(object[] args, out double arg0, out double arg1)
-            {
-                arg0 = 0;
-                arg1 = 0;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                return TryConvertToDouble(args[0], out arg0) &&
-                       TryConvertToDouble(args[1], out arg1);
-            }
-
-            private static bool TryGetArgs(object[] args, out int arg0, out string arg1)
-            {
-                arg0 = 0;
-                arg1 = null;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                arg1 = args[1] as string;
-                if (arg1 == null && args[1] is char ch)
-                {
-                    arg1 = ch.ToString();
-                }
-
-                if (TryConvertToInt(args[0], out arg0) &&
-                    arg1 != null)
-                {
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out int arg1)
-            {
-                arg0 = null;
-                arg1 = 0;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                var value1 = args[1] as string;
-                arg0 = args[0] as string;
-                if (value1 != null &&
-                    arg0 != null &&
-                    int.TryParse(value1, out arg1))
-                {
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool IsFloatingPointRepresentation(object value)
-            {
-                return value is double || (value is string str && double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double _));
-            }
-
-            private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object resultValue)
-            {
-                resultValue = null;
-
-                if (args.Length != 2)
-                {
-                    return false;
+                        return toReturn;
+                    }
                 }
 
-                if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
+                try
                 {
-                    resultValue = integerOperation(argLong0, argLong1);
-                    return true;
+                    return _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture) ?? "null";
                 }
-
-                if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
+                catch (Exception)
                 {
-                    resultValue = realOperation(argDouble0, argDouble1);
-                    return true;
+                    // This isn't a viable option, but perhaps another set of parameters will work.
+                    return null;
                 }
-
-                return false;
-            }
-
-            [MethodImpl(MethodImplOptions.AggressiveInlining)]
-            private void LogFunctionCall(string fileName, object objectInstance, object[] args)
-            {
-                var logFile = Path.Combine(Directory.GetCurrentDirectory(), fileName);
-
-                var argSignature = args != null
-                    ? string.Join(", ", args.Select(a => a?.GetType().Name ?? "null"))
-                    : string.Empty;
-
-                File.AppendAllText(logFile, $"ReceiverType={_receiverType?.FullName}; ObjectInstanceType={objectInstance?.GetType().FullName}; MethodName={_methodMethodName}({argSignature})\n");
             }
 
             /// <summary>
@@ -5405,7 +4111,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         {
                             coercedArguments[n] = args[n].ToString().ToCharArray();
                         }
-                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string && ((string)args[n]).Contains("."))
+                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
                         {
                             Type enumType = parameters[n].ParameterType;
                             string typeLeafName = enumType.Name + ".";
@@ -5488,7 +4194,7 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
 
                     // We don't want to expose the real type name of our intrinsics
                     // so we'll replace it with "MSBuild"
-                    if (_receiverType == typeof(Microsoft.Build.Evaluation.IntrinsicFunctions))
+                    if (_receiverType == typeof(IntrinsicFunctions))
                     {
                         typeName = "MSBuild";
                     }
@@ -5521,7 +4227,7 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
             /// </summary>
             private static bool IsStaticMethodAvailable(Type receiverType, string methodName)
             {
-                if (receiverType == typeof(Microsoft.Build.Evaluation.IntrinsicFunctions))
+                if (receiverType == typeof(IntrinsicFunctions))
                 {
                     // These are our intrinsic functions, so we're OK with those
                     return true;
diff --git a/src/Build/Evaluation/Expander/ArgumentParser.cs b/src/Build/Evaluation/Expander/ArgumentParser.cs
new file mode 100644
index 00000000000..ca4039aae5d
--- /dev/null
+++ b/src/Build/Evaluation/Expander/ArgumentParser.cs
@@ -0,0 +1,422 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Evaluation.Expander
+{
+    internal class ArgumentParser
+    {
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1, bool enforceLength = true)
+        {
+            arg0 = null;
+            arg1 = null;
+
+            if (enforceLength && args.Length != 2)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1)
+            {
+                arg0 = value0;
+                arg1 = value1;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1, out string? arg2)
+        {
+            arg0 = null;
+            arg1 = null;
+            arg2 = null;
+
+            if (args.Length != 3)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1 &&
+                args[2] is string value2)
+            {
+                arg0 = value0;
+                arg1 = value1;
+                arg2 = value2;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1, out string? arg2, out string? arg3)
+        {
+            arg0 = null;
+            arg1 = null;
+            arg2 = null;
+            arg3 = null;
+
+            if (args.Length != 4)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1 &&
+                args[2] is string value2 &&
+                args[3] is string value3)
+            {
+                arg0 = value0;
+                arg1 = value1;
+                arg2 = value2;
+                arg3 = value3;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1)
+        {
+            arg0 = null;
+            arg1 = null;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1)
+            {
+                arg0 = value0;
+                arg1 = value1;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out int arg1, out int arg2)
+        {
+            arg0 = null;
+            arg1 = 0;
+            arg2 = 0;
+
+            if (args.Length != 3)
+            {
+                return false;
+            }
+
+            var value1 = args[1] as string;
+            var value2 = args[2] as string;
+            arg0 = args[0] as string;
+            if (value1 != null &&
+                value2 != null &&
+                arg0 != null &&
+                int.TryParse(value1, out arg1) &&
+                int.TryParse(value2, out arg2))
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArg(object[] args, out int arg0)
+        {
+            if (args.Length != 1)
+            {
+                arg0 = 0;
+                return false;
+            }
+
+            return TryConvertToInt(args[0], out arg0);
+        }
+
+        internal static bool TryGetArg(object[] args, out Version? arg0)
+        {
+            if (args.Length != 1)
+            {
+                arg0 = default;
+                return false;
+            }
+
+            return TryConvertToVersion(args[0], out arg0);
+        }
+
+        internal static bool TryConvertToVersion(object value, out Version? arg0)
+        {
+            string? val = value as string;
+
+            if (string.IsNullOrEmpty(val) || !Version.TryParse(val, out arg0))
+            {
+                arg0 = default;
+                return false;
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Try to convert value to int.
+        /// </summary>
+        internal static bool TryConvertToInt(object? value, out int arg)
+        {
+            switch (value)
+            {
+                case double d:
+                    if (d >= int.MinValue && d <= int.MaxValue)
+                    {
+                        arg = Convert.ToInt32(d);
+                        if (Math.Abs(arg - d) == 0)
+                        {
+                            return true;
+                        }
+                    }
+
+                    break;
+                case long l:
+                    if (l >= int.MinValue && l <= int.MaxValue)
+                    {
+                        arg = Convert.ToInt32(l);
+                        return true;
+                    }
+
+                    break;
+                case int i:
+                    arg = i;
+                    return true;
+                case string s when int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                    return true;
+            }
+
+            arg = 0;
+            return false;
+        }
+
+        /// <summary>
+        /// Try to convert value to long.
+        /// </summary>
+        internal static bool TryConvertToLong(object? value, out long arg)
+        {
+            switch (value)
+            {
+                case double d:
+                    if (d >= long.MinValue && d <= long.MaxValue)
+                    {
+                        arg = (long)d;
+                        if (Math.Abs(arg - d) == 0)
+                        {
+                            return true;
+                        }
+                    }
+
+                    break;
+                case long l:
+                    arg = l;
+                    return true;
+                case int i:
+                    arg = i;
+                    return true;
+                case string s when long.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                    return true;
+            }
+
+            arg = 0;
+            return false;
+        }
+
+        /// <summary>
+        /// Try to convert value to double.
+        /// </summary>
+        internal static bool TryConvertToDouble(object? value, out double arg)
+        {
+            switch (value)
+            {
+                case double unboxed:
+                    arg = unboxed;
+                    return true;
+                case long l:
+                    arg = l;
+                    return true;
+                case int i:
+                    arg = i;
+                    return true;
+                case string str when double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                    return true;
+                default:
+                    arg = 0;
+                    return false;
+            }
+        }
+
+        internal static bool TryGetArg(object[] args, out string? arg0)
+        {
+            if (args.Length != 1)
+            {
+                arg0 = null;
+                return false;
+            }
+
+            arg0 = args[0] as string;
+            return arg0 != null;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out StringComparison arg1)
+        {
+            if (args.Length != 2)
+            {
+                arg0 = null;
+                arg1 = default;
+
+                return false;
+            }
+
+            arg0 = args[0] as string;
+
+            // reject enums as ints. In C# this would require a cast, which is not supported in msbuild expressions
+            if (arg0 == null || !(args[1] is string comparisonTypeName) || int.TryParse(comparisonTypeName, out _))
+            {
+                arg1 = default;
+                return false;
+            }
+
+            // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
+            if (comparisonTypeName.Contains('.'))
+            {
+                comparisonTypeName = comparisonTypeName.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
+            }
+
+            return Enum.TryParse(comparisonTypeName, out arg1);
+        }
+
+        internal static bool TryGetArgs(object[] args, out int arg0)
+        {
+            arg0 = 0;
+
+            if (args.Length != 1)
+            {
+                return false;
+            }
+
+            return TryConvertToInt(args[0], out arg0);
+        }
+
+        internal static bool TryGetArgs(object[] args, out int arg0, out int arg1)
+        {
+            arg0 = 0;
+            arg1 = 0;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            return TryConvertToInt(args[0], out arg0) &&
+                   TryConvertToInt(args[1], out arg1);
+        }
+
+        internal static bool TryGetArgs(object[] args, out double arg0, out double arg1)
+        {
+            arg0 = 0;
+            arg1 = 0;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            return TryConvertToDouble(args[0], out arg0) &&
+                   TryConvertToDouble(args[1], out arg1);
+        }
+
+        internal static bool TryGetArgs(object[] args, out int arg0, out string? arg1)
+        {
+            arg0 = 0;
+            arg1 = null;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            arg1 = args[1] as string;
+            if (arg1 == null && args[1] is char ch)
+            {
+                arg1 = ch.ToString();
+            }
+
+            if (TryConvertToInt(args[0], out arg0) &&
+                arg1 != null)
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out int arg1)
+        {
+            arg0 = null;
+            arg1 = 0;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            var value1 = args[1] as string;
+            arg0 = args[0] as string;
+            if (value1 != null &&
+                arg0 != null &&
+                int.TryParse(value1, out arg1))
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool IsFloatingPointRepresentation(object value)
+        {
+            return value is double || (value is string str && double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double _));
+        }
+
+        internal static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object? resultValue)
+        {
+            resultValue = null;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
+            {
+                resultValue = integerOperation(argLong0, argLong1);
+                return true;
+            }
+
+            if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
+            {
+                resultValue = realOperation(argDouble0, argDouble1);
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Evaluation/Expander/WellKnownFunctions.cs b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
new file mode 100644
index 00000000000..72f8b247933
--- /dev/null
+++ b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
@@ -0,0 +1,951 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
+
+
+namespace Microsoft.Build.Evaluation.Expander
+{
+    internal class WellKnownFunctions
+    {
+
+        internal static bool ElementsOfType(object[] args, Type type)
+        {
+            for (var i = 0; i < args.Length; i++)
+            {
+                if (args[i].GetType() != type)
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        internal static void LogFunctionCall(Type receiverType, string methodName, string fileName, object? objectInstance, object[] args)
+        {
+            var logFile = Path.Combine(Directory.GetCurrentDirectory(), fileName);
+
+            var argSignature = args != null
+                ? string.Join(", ", args.Select(a => a?.GetType().Name ?? "null"))
+                : string.Empty;
+
+            File.AppendAllText(logFile, $"ReceiverType={receiverType?.FullName}; ObjectInstanceType={objectInstance?.GetType().FullName}; MethodName={methodName}({argSignature})\n");
+        }
+
+        internal static bool TryExecutePathFunction(string methodName, out object? returnVal, object[] args)
+        {
+            returnVal = default;
+            if (string.Equals(methodName, nameof(Path.Combine), StringComparison.OrdinalIgnoreCase))
+            {
+                string? arg0, arg1, arg2, arg3;
+
+                // Combine has fast implementations for up to 4 parameters: https://github.com/dotnet/corefx/blob/2c55db90d622fa6279184e6243f0470a3755d13c/src/Common/src/CoreLib/System/IO/Path.cs#L293-L317
+                switch (args.Length)
+                {
+                    case 0:
+                        return false;
+                    case 1:
+                        if (ParseArgs.TryGetArg(args, out arg0) && arg0 != null)
+                        {
+                            returnVal = Path.Combine(arg0);
+                            return true;
+                        }
+                        break;
+                    case 2:
+                        if (ParseArgs.TryGetArgs(args, out arg0, out arg1) && arg0 != null && arg1 != null)
+                        {
+                            returnVal = Path.Combine(arg0, arg1);
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (ParseArgs.TryGetArgs(args, out arg0, out arg1, out arg2) && arg0 != null && arg1 != null && arg2 != null)
+                        {
+                            returnVal = Path.Combine(arg0, arg1, arg2);
+                            return true;
+                        }
+                        break;
+                    case 4:
+                        if (ParseArgs.TryGetArgs(args, out arg0, out arg1, out arg2, out arg3) && arg0 != null && arg1 != null && arg2 != null && arg3 != null)
+                        {
+                            returnVal = Path.Combine(arg0, arg1, arg2, arg3);
+                            return true;
+                        }
+                        break;
+                    default:
+                        if (ElementsOfType(args, typeof(string)))
+                        {
+                            returnVal = Path.Combine(Array.ConvertAll(args, o => (string)o));
+                            return true;
+                        }
+                        break;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.DirectorySeparatorChar), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = Path.DirectorySeparatorChar;
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetFullPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetFullPath(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.IsPathRooted), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.IsPathRooted(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetTempPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = Path.GetTempPath();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetFileName), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetFileName(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetDirectoryName), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetDirectoryName(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetFileNameWithoutExtension), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetFileNameWithoutExtension(arg0);
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Handler for executing well known string functions
+        /// </summary>
+        /// <param name="methodName"></param>
+        /// <param name="returnVal"></param>
+        /// <param name="text"></param>
+        /// <param name="args"></param>
+        /// <returns></returns>
+        internal static bool TryExecuteStringFunction(string methodName, out object? returnVal, string text, object[] args)
+        {
+            returnVal = null;
+            if (string.Equals(methodName, nameof(string.StartsWith), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.StartsWith(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Replace), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1) && arg0 != null)
+                {
+                    returnVal = text.Replace(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Contains), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.Contains(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.ToUpperInvariant), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.ToUpperInvariant();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.ToLowerInvariant), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.ToLowerInvariant();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.EndsWith), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.EndsWith(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.ToLower), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.ToLower();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.IndexOf), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out StringComparison arg1) && arg0 != null)
+                {
+                    returnVal = text.IndexOf(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.IndexOfAny), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.IndexOfAny(arg0.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.LastIndexOf), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOf(arg0);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out arg0, out int startIndex) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOf(arg0, startIndex);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out arg0, out StringComparison arg1) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOf(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.LastIndexOfAny), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOfAny(arg0.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.Length;
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Substring), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int startIndex))
+                {
+                    returnVal = text.Substring(startIndex);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out startIndex, out int length))
+                {
+                    returnVal = text.Substring(startIndex, length);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Split), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? separator) && separator?.Length == 1)
+                {
+                    returnVal = text.Split(separator[0]);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.PadLeft), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int totalWidth))
+                {
+                    returnVal = text.PadLeft(totalWidth);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out totalWidth, out string? paddingChar) && paddingChar?.Length == 1)
+                {
+                    returnVal = text.PadLeft(totalWidth, paddingChar[0]);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.PadRight), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int totalWidth))
+                {
+                    returnVal = text.PadRight(totalWidth);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out totalWidth, out string? paddingChar) && paddingChar?.Length == 1)
+                {
+                    returnVal = text.PadRight(totalWidth, paddingChar[0]);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.TrimStart), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? trimChars) && trimChars?.Length > 0)
+                {
+                    returnVal = text.TrimStart(trimChars.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.TrimEnd), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? trimChars) && trimChars?.Length > 0)
+                {
+                    returnVal = text.TrimEnd(trimChars.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, "get_Chars", StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int index))
+                {
+                    returnVal = text[index];
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Equals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = text.Equals(arg0);
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        internal static bool TryExecuteIntrinsicFunction(string methodName, out object? returnVal, IFileSystem fileSystem, object[] args)
+        {
+            returnVal = default;
+            if (string.Equals(methodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.EnsureTrailingSlash(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.ValueOrDefault), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.ValueOrDefault(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.NormalizePath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ElementsOfType(args, typeof(string)))
+                {
+                    returnVal = IntrinsicFunctions.NormalizePath(Array.ConvertAll(args, o => (string)o));
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetDirectoryNameOfFileAbove), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.GetDirectoryNameOfFileAbove(arg0, arg1, fileSystem);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetRegistryValueFromView), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length >= 4 &&
+                    ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.GetRegistryValueFromView(arg0, arg1, args[2], new ArraySegment<object>(args, 3, args.Length - 3));
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.IsRunningFromVisualStudio), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.IsRunningFromVisualStudio();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Escape), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.Escape(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Unescape), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.Unescape(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetPathOfFileAbove), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.GetPathOfFileAbove(arg0, arg1, fileSystem);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Add), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Add, IntrinsicFunctions.Add, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Subtract), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Subtract, IntrinsicFunctions.Subtract, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Multiply), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Multiply, IntrinsicFunctions.Multiply, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Divide), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Divide, IntrinsicFunctions.Divide, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Modulo), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Modulo, IntrinsicFunctions.Modulo, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetCurrentToolsDirectory), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetCurrentToolsDirectory();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetToolsDirectory32), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetToolsDirectory32();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetToolsDirectory64), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetToolsDirectory64();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetMSBuildSDKsPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetMSBuildSDKsPath();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetVsInstallRoot), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetVsInstallRoot();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetMSBuildExtensionsPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetMSBuildExtensionsPath();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetProgramFiles32), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetProgramFiles32();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionNotEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionNotEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionGreaterThan), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionGreaterThan(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionGreaterThanOrEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionGreaterThanOrEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionLessThan), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionLessThan(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionLessThanOrEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionLessThanOrEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetFrameworkIdentifier), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetFrameworkIdentifier(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetFrameworkVersion), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
+                    return true;
+                }
+                if (ParseArgs.TryGetArgs(args, out string? arg1, out int arg2))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg1, arg2);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.IsTargetFrameworkCompatible(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetPlatformIdentifier), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetPlatformIdentifier(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetPlatformVersion), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg0);
+                    return true;
+                }
+                if (ParseArgs.TryGetArgs(args, out string? arg1, out int arg2))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg1, arg2);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.ConvertToBase64), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.ConvertToBase64(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.ConvertFromBase64), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.ConvertFromBase64(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.StableStringHash), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    // Prevent loading methods refs from StringTools if ChangeWave opted out.
+                    returnVal = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
+                        ? IntrinsicFunctions.StableStringHash(arg0)
+                        : IntrinsicFunctions.StableStringHashLegacy(arg0);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out string? arg1, out string? arg2) && Enum.TryParse<IntrinsicFunctions.StringHashingAlgorithm>(arg2, true, out var hashAlgorithm) && arg1 != null && arg2 != null)
+                {
+                    returnVal = IntrinsicFunctions.StableStringHash(arg1, hashAlgorithm);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.AreFeaturesEnabled), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out Version? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.AreFeaturesEnabled(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.SubstringByAsciiChars), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out int arg1, out int arg2) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.SubstringByAsciiChars(arg0, arg1, arg2);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.CheckFeatureAvailability), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.CheckFeatureAvailability(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseOr), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseOr(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseAnd), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseAnd(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseXor), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseXor(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseNot), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int arg0))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseNot(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.LeftShift), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.LeftShift(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.RightShift), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.RightShift(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.RightShiftUnsigned), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.RightShiftUnsigned(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.NormalizeDirectory), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.NormalizeDirectory(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.IsOSPlatform), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.IsOSPlatform(arg0);
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Shortcut to avoid calling into binding if we recognize some most common functions.
+        /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
+        /// bad for debugging experience and has a performance cost.
+        /// A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
+        /// (rough numbers just for comparison).
+        /// See https://github.com/dotnet/msbuild/issues/2217.
+        /// </summary>
+        /// <param name="methodName"> </param>
+        /// <param name="receiverType"> </param>
+        /// <param name="fileSystem"> </param>
+        /// <param name="returnVal">The value returned from the function call.</param>
+        /// <param name="objectInstance">Object that the function is called on.</param>
+        /// <param name="args">arguments.</param>
+        /// <returns>True if the well known function call binding was successful.</returns>
+        internal static bool TryExecuteWellKnownFunction(string methodName, Type receiverType, IFileSystem fileSystem, out object? returnVal, object objectInstance, object[] args)
+        {
+            returnVal = null;
+
+            if (objectInstance is string text)
+            {
+                return TryExecuteStringFunction(methodName, out returnVal, text, args);
+            }
+            else if (objectInstance is string[] stringArray)
+            {
+                if (string.Equals(methodName, "GetValue", StringComparison.OrdinalIgnoreCase))
+                {
+                    if (ParseArgs.TryGetArg(args, out int index))
+                    {
+                        returnVal = stringArray[index];
+                        return true;
+                    }
+                }
+            }
+            else if (objectInstance == null) // Calling a well-known static function
+            {
+                if (receiverType == typeof(string))
+                {
+                    if (string.Equals(methodName, nameof(string.IsNullOrWhiteSpace), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0))
+                        {
+                            returnVal = string.IsNullOrWhiteSpace(arg0);
+                            return true;
+                        }
+                    }
+                    else if (string.Equals(methodName, nameof(string.IsNullOrEmpty), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0))
+                        {
+                            returnVal = string.IsNullOrEmpty(arg0);
+                            return true;
+                        }
+                    }
+                    else if (string.Equals(methodName, nameof(string.Copy), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0))
+                        {
+                            returnVal = arg0;
+                            return true;
+                        }
+                    }
+                }
+                else if (receiverType == typeof(Math))
+                {
+                    if (string.Equals(methodName, nameof(Math.Max), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArgs(args, out double arg0, out double arg1))
+                        {
+                            returnVal = Math.Max(arg0, arg1);
+                            return true;
+                        }
+                    }
+                    else if (string.Equals(methodName, nameof(Math.Min), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArgs(args, out double arg0, out double arg1))
+                        {
+                            returnVal = Math.Min(arg0, arg1);
+                            return true;
+                        }
+                    }
+                }
+                else if (receiverType == typeof(IntrinsicFunctions))
+                {
+                    return TryExecuteIntrinsicFunction(methodName, out returnVal, fileSystem, args);
+                }
+                else if (receiverType == typeof(Path))
+                {
+                    return TryExecutePathFunction(methodName, out returnVal, args);
+                }
+                else if (receiverType == typeof(Version))
+                {
+                    if (string.Equals(methodName, nameof(Version.Parse), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                        {
+                            returnVal = Version.Parse(arg0);
+                            return true;
+                        }
+                    }
+                }
+                else if (receiverType == typeof(Guid))
+                {
+                    if (string.Equals(methodName, nameof(Guid.NewGuid), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (args.Length == 0)
+                        {
+                            returnVal = Guid.NewGuid();
+                            return true;
+                        }
+                    }
+                }
+                else if (string.Equals(methodName, nameof(Regex.Replace), StringComparison.OrdinalIgnoreCase) && args.Length == 3)
+                {
+                    if (ParseArgs.TryGetArgs(args, out string? arg1, out string? arg2, out string? arg3) && arg1 != null && arg2 != null && arg3 != null)
+                    {
+                        returnVal = Regex.Replace(arg1, arg2, arg3);
+                        return true;
+                    }
+                }
+            }
+            else if (string.Equals(methodName, nameof(Version.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is Version v)
+            {
+                if (ParseArgs.TryGetArg(args, out int arg0))
+                {
+                    returnVal = v.ToString(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Int32.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is int i)
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = i.ToString(arg0);
+                    return true;
+                }
+            }
+            if (Traits.Instance.LogPropertyFunctionsRequiringReflection)
+            {
+                LogFunctionCall(receiverType, methodName, "PropertyFunctionsRequiringReflection", objectInstance, args);
+            }
+
+            return false;
+        }
+
+        internal static bool TryExecuteWellKnownFunctionWithPropertiesParam<T>(string methodName, Type receiverType, LoggingContext loggingContext,
+                                                                            IPropertyProvider<T> properties, out object? returnVal, object objectInstance, object[] args)
+            where T : class, IProperty
+        {
+            returnVal = null;
+
+            if (receiverType == typeof(IntrinsicFunctions))
+            {
+                if (string.Equals(methodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
+                {
+                    string projectPath = properties.GetProperty("MSBuildProjectFullPath")?.EvaluatedValue ?? string.Empty;
+                    ErrorUtilities.VerifyThrow(loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
+                    if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                    {
+                        returnVal = IntrinsicFunctions.RegisterBuildCheck(projectPath, arg0, loggingContext);
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Shortcut to avoid calling into binding if we recognize some most common constructors.
+        /// Analogous to TryExecuteWellKnownFunction but guaranteed to not throw.
+        /// </summary>
+        /// <param name="receiverType"> Receiver type for the constructor. </param>
+        /// <param name="returnVal">The instance as created by the constructor call.</param>
+        /// <param name="args">Arguments.</param>
+        /// <returns>True if the well known constructor call binding was successful.</returns>
+        internal static bool TryExecuteWellKnownConstructorNoThrow(Type? receiverType, out object? returnVal, object[] args)
+        {
+            returnVal = null;
+
+            if (receiverType == typeof(string))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = String.Empty;
+                    return true;
+                }
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = arg0;
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d3faea7600a..66d6c38d007 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -499,6 +499,8 @@
     <Compile Include="Evaluation\Evaluator.cs" />
     <Compile Include="Evaluation\Expander.cs" />
     <Compile Include="Evaluation\ToolsetProvider.cs" />
+    <Compile Include="Evaluation\Expander\ArgumentParser.cs" />
+    <Compile Include="Evaluation\Expander\WellKnownFunctions.cs" />
     <Compile Include="Globbing\CompositeGlob.cs" />
     <Compile Include="Globbing\Extensions\MSBuildGlobExtensions.cs" />
     <Compile Include="Globbing\Visitor\GlobVisitor.cs" />
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 39eb6abf59b..de10f0f34a9 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">PÅi rozbalovÃ¡nÃ­ specifikace fileSpec o globs doÅ¡lo k vÃ½jimce: fileSpec: "{0}", pÅedpoklÃ¡dÃ¡ se, Å¾e se jednÃ¡ o nÃ¡zev souboru. VÃ½jimka: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Chyby: {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">{1} nerozumÃ­ {0} typu protokolovÃ¡nÃ­.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 562e6cf79a4..7ae4ff64846 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">Ausnahme beim Erweitern einer fileSpec mit globs: fileSpec: "{0}", vorausgesetzt, es handelt sich um einen Dateinamen. Ausnahme: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Fehler: {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">Der Protokollierungstyp {0} wird von {1} nicht erkannt.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index acf41a0614b..f94a047df5b 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">Se produjo una excepciÃ³n al expandir fileSpec con globs: fileSpec: "{0}", suponiendo que es un nombre de archivo. ExcepciÃ³n: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Errores: {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">{1} no entiende el tipo de registro {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 8ae68d28c9a..56c560c71f7 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">Une exception sâest produite lors du dÃ©veloppement dâun fileSpec avec globsÂ : fileSpecÂ : "{0}", en supposant quâil sâagit dâun nom de fichier. Exception : {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ ErreursÂ : {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">Le type de journalisation {0} nâest pas compris par {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 38a6b294dbd..c70a79dbe40 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">Si Ã¨ verificata un'eccezione durante l'espansione di un fileSpec con GLOBS: fileSpec: "{0}", presupponendo che si tratti di un nome di file. Eccezione: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Errori: {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">Il tipo di registrazione {0} non Ã¨ riconosciuto da {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 56810f3ed64..0981d946bbb 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">globs: fileSpec: "{0}" ã® fileSpec ãå±éä¸­ã«ä¾å¤ãçºçãã¾ããããã¡ã¤ã«åã¨è¦ãªããã¾ããä¾å¤: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">ã­ã°ã®ç¨®é¡ {0} ã¯ {1} ã§ã¯èªè­ããã¾ããã</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 0723a92a40c..bc6bd7f0df2 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">globs: fileSpec: "{0}" fileSpecì íì¼ ì´ë¦ì¼ë¡ ê°ì íì¬ fileSpecì íì¥íë ëì ìì¸ê° ë°ìíìµëë¤. ìì¸: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">ë¡ê¹ ì í {0} {1} ì´í´í  ì ììµëë¤.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 0b361364a94..197d5dd80b1 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">WystÄpiÅ wyjÄtek podczas rozwijania elementu fileSpec o wartoÅci globs: fileSpec: "{0}", zakÅadajÄc, Å¼e jest to nazwa pliku. WyjÄtek: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ BÅÄdy: {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">{1} nie {0} typu rejestrowania.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 58991d03486..2a5e78cb408 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">ExceÃ§Ã£o ao expandir um fileSpec com globs: fileSpec: "{0}", presumindo que seja um nome de arquivo. ExceÃ§Ã£o: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Erros: {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">O tipo {0} registro em log nÃ£o Ã© compreendido por {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 706ebf44436..82bb6700ee8 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">ÐÐ¾Ð·Ð½Ð¸ÐºÐ»Ð¾ Ð¸ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð¿ÑÐ¸ ÑÐ°Ð·Ð²ÐµÑÑÑÐ²Ð°Ð½Ð¸Ð¸ fileSpec Ñ globs: fileSpec: "{0}", Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°Ñ, ÑÑÐ¾ ÑÑÐ¾ Ð¸Ð¼Ñ ÑÐ°Ð¹Ð»Ð°. ÐÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">Ð¢Ð¸Ð¿ {0} Ð½Ðµ ÑÐ°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½ {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index a69937c4f88..a7d019b7276 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">bir fileSpec globs ile geniÅletilirken Ã¶zel durum oluÅtu: fileSpec: "{0}", dosya adÄ± olduÄu varsayÄ±lÄ±yor. Ãzel durum: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Hatalar: {3}</target>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">GÃ¼nlÃ¼k kaydÄ± {0} gÃ¼nlÃ¼k kaydÄ± tÃ¼rÃ¼ {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 834338f18c1..66127cb659d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">å±å¼ glob ä¸º fileSpecï¼ fileSpecï¼ "{0}" ç fileSpec æ¶åçå¼å¸¸ï¼åå®å®æ¯æä»¶åãå¼å¸¸ï¼ {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">{1} æ æ³çè§£æ¥å¿è®°å½ç±»å {0}ã</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index dc7ee7f1b47..c10b95fe378 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -415,7 +415,7 @@
       </trans-unit>
       <trans-unit id="GlobExpansionFailed">
         <source>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</source>
-        <target state="new">An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</target>
+        <target state="translated">å±éå·æ globï¼ fileSpecï¼ "{0}" ç fileSpec æç¼çä¾å¤çæ³ï¼åè¨­å®æ¯æªåãä¾å¤çæ³ï¼ {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -815,7 +815,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="UnknownLoggingType">
         <source>Logging type {0} is not understood by {1}.</source>
-        <target state="new">Logging type {0} is not understood by {1}.</target>
+        <target state="translated">{1} ç¡æ³äºè§£è¨éé¡å {0}ã</target>
         <note />
       </trans-unit>
       <trans-unit id="UsingInputCaches">
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index fcd8630dbd6..fa1e17b716c 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -39,7 +39,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)BuildXL.Native.dll
   file source=$(X86BinPath)BuildXL.Processes.dll
   file source=$(X86BinPath)BuildXL.Utilities.Core.dll
-  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll
+  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 8901b0def29..b0b620ad68a 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -1392,8 +1392,8 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 // Context: https://github.com/dotnet/msbuild/pull/7689
                 if (this._hasMsBuild &&
                     generatedPathToDotNetFramework != null &&
-                    (!FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")) &&
-                     !FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, "Microsoft.Build.dll"))))
+                    (!File.Exists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")) &&
+                     !File.Exists(Path.Combine(generatedPathToDotNetFramework, "Microsoft.Build.dll"))))
                 {
                     return null;
                 }
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index f83d4981c84..6112e7fc577 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: NepodaÅilo se odstranit doÄasnÃ½ soubor {0}. {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 49b58cee7b5..be05ce4a4ed 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: Fehler beim LÃ¶schen der temporÃ¤ren Datei â{0}â. {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 08d33dab795..f8c5d9b5028 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: No se pudo eliminar el archivo temporal "{0}". {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 1d6ae593dd2..89b1346466e 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: Impossible de supprimer le fichier temporaire Â«Â {0}Â Â». {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index b2c529f8083..943424a181a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: non Ã¨ stato possibile eliminare il file temporaneo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index ddb12079e94..e392ac1eff6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: ä¸æãã¡ã¤ã« "{0}" ãåé¤ã§ãã¾ããã§ããã{1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 5e2a4ba3eb3..b03debaa45e 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: ìì íì¼ "{0}"ì(ë¥¼) ì­ì íì§ ëª»íìµëë¤. {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 42d5fd9471b..6731c418bbc 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: nie moÅ¼na usunÄÄ pliku tymczasowego â{0}â. {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 1dfd6b8a934..f8cc9843098 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: falha ao excluir o arquivo temporÃ¡rio "{0}". {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index ea7f93db86d..bbffde258e5 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: Ð½Ðµ ÑÐ´Ð°Ð»Ð¾ÑÑ ÑÐ´Ð°Ð»Ð¸ÑÑ Ð²ÑÐµÐ¼ÐµÐ½Ð½ÑÐ¹ ÑÐ°Ð¹Ð» "{0}". {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 922afedef85..72a139c0b26 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: "{0}" geÃ§ici dosyasÄ± silinemedi. {1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index f0a83a9508d..8be5cf61c86 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: æªè½å é¤ä¸´æ¶æä»¶â{0}âã{1} {2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index ca5e3c799df..e08a6eea736 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -127,7 +127,7 @@
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1} {2}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1} {2}</target>
+        <target state="translated">MSB5018: ç¡æ³åªé¤æ«å­æª "{0}"ã{1}{2}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
diff --git a/src/StringTools/WeakStringCache.Concurrent.cs b/src/StringTools/WeakStringCache.Concurrent.cs
index bf9373e798c..423cd0f1389 100644
--- a/src/StringTools/WeakStringCache.Concurrent.cs
+++ b/src/StringTools/WeakStringCache.Concurrent.cs
@@ -14,6 +14,7 @@ namespace Microsoft.NET.StringTools
     internal sealed partial class WeakStringCache : IDisposable
     {
         private readonly ConcurrentDictionary<int, StringWeakHandle> _stringsByHashCode;
+        private int _count;
 
         public WeakStringCache()
         {
@@ -62,11 +63,15 @@ public string GetOrCreateEntry(ref InternableString internable, out bool cacheHi
 
             handle = new StringWeakHandle();
             handle.SetString(result);
-            _stringsByHashCode.TryAdd(hashCode, handle);
+            if (_stringsByHashCode.TryAdd(hashCode, handle))
+            {
+                Interlocked.Increment(ref _count);
+            }
+
 
             // Remove unused handles if our heuristic indicates that it would be productive.
             int scavengeThreshold = _scavengeThreshold;
-            if (_stringsByHashCode.Count >= scavengeThreshold)
+            if (_count >= scavengeThreshold)
             {
                 // Before we start scavenging set _scavengeThreshold to a high value to effectively lock other threads from
                 // running Scavenge at the same time.
@@ -81,6 +86,12 @@ public string GetOrCreateEntry(ref InternableString internable, out bool cacheHi
                     {
                         // And do this again when the number of handles reaches double the current after-scavenge number.
                         _scavengeThreshold = _stringsByHashCode.Count * 2;
+
+                        // This count is not exact, since there can be some Interlocked.Increment(ref _count);
+                        // calls happening due to this not being behind a lock.
+                        // e.g. code checks if (_stringsByHashCode.TryAdd(hashCode, handle)), we set the _count here and the code increments
+                        // however since this is just a threshold to scavenge, it should be fine to be off by few even if that happens.
+                        _count = _stringsByHashCode.Count;
                     }
                 }
             }
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 3fdfff8ac43..df4ff892a0a 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -497,7 +497,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <!-- Output location for publish target. -->
   <PropertyGroup>
     <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
-    <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
+    <PublishDir Condition="'$(PublishDir)'==''">$([MSBuild]::EnsureTrailingSlash($([MSBuild]::NormalizePath('$(OutputPath)', 'app.publish'))))</PublishDir>
   </PropertyGroup>
 
   <!--
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 341e85c7e55..7b4874be583 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1169,7 +1169,7 @@
     <comment>{StrBegin="MSB3824: "}</comment>
   </data>
   <data name="GenerateResource.BinaryFormatterUse">
-    <value>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+    <value>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</value>
     <comment>{StrBegin="MSB3825: "}</comment>
   </data>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index ed494375293..2186229d6fc 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: ProstÅedek {0} typu {1} mÅ¯Å¾e bÃ½t deserializovÃ¡n pÅes BinaryFormatter za bÄhu. BinaryFormatter je zastaralÃ½ kvÅ¯li znÃ¡mÃ½m bezpeÄnostnÃ­m rizikÅ¯m a byl odebrÃ¡n z rozhranÃ­ .NET 9+. Pokud ho chcete dÃ¡l pouÅ¾Ã­vat, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false.
+        <target state="needs-review-translation">MSB3825: ProstÅedek {0} typu {1} mÅ¯Å¾e bÃ½t deserializovÃ¡n pÅes BinaryFormatter za bÄhu. BinaryFormatter je zastaralÃ½ kvÅ¯li znÃ¡mÃ½m bezpeÄnostnÃ­m rizikÅ¯m a byl odebrÃ¡n z rozhranÃ­ .NET 9+. Pokud ho chcete dÃ¡l pouÅ¾Ã­vat, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false.
            DalÅ¡Ã­ informace: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 8bd7effeaef..32b27ed86f2 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: Die Ressource "{0}" vom Typ "{1}" kann zur Laufzeit Ã¼ber BinaryFormatter deserialisiert werden. BinaryFormatter ist aufgrund bekannter Sicherheitsrisiken veraltet und wird aus .NET 9 und hÃ¶her entfernt. Wenn Sie ihn weiterhin verwenden mÃ¶chten, legen Sie die Eigenschaft "GenerateResourceWarnOnBinaryFormatterUse" auf "false" fest.
+        <target state="needs-review-translation">MSB3825: Die Ressource "{0}" vom Typ "{1}" kann zur Laufzeit Ã¼ber BinaryFormatter deserialisiert werden. BinaryFormatter ist aufgrund bekannter Sicherheitsrisiken veraltet und wird aus .NET 9 und hÃ¶her entfernt. Wenn Sie ihn weiterhin verwenden mÃ¶chten, legen Sie die Eigenschaft "GenerateResourceWarnOnBinaryFormatterUse" auf "false" fest.
            Weitere Informationen finden Sie unter: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 15ef00ad1aa..7e9245e6e3a 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: El recurso "{0}" del tipo "{1}" puede que se haya deserializado a travÃ©s de BinaryFormatter en el tiempo de ejecuciÃ³n. BinaryFormatter estÃ¡ en desuso debido a riesgos de seguridad conocidos y se ha eliminado de .NET 9+. Si desea seguir usÃ¡ndolo, establezca la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en false.
+        <target state="needs-review-translation">MSB3825: El recurso "{0}" del tipo "{1}" puede que se haya deserializado a travÃ©s de BinaryFormatter en el tiempo de ejecuciÃ³n. BinaryFormatter estÃ¡ en desuso debido a riesgos de seguridad conocidos y se ha eliminado de .NET 9+. Si desea seguir usÃ¡ndolo, establezca la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en false.
            MÃ¡s informaciÃ³n: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 023466072c9..b264b07daee 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: La ressource Â«Â {0} Â» de type Â«Â {1} Â» peut Ãªtre dÃ©sÃ©rialisÃ©e via BinaryFormatter lors de l'exÃ©cution. BinaryFormatter est obsolÃ¨te en raison de risques de sÃ©curitÃ© connus et est supprimÃ© de .NET 9+. Si vous souhaitez continuer Ã  l'utiliser, dÃ©finissez la propriÃ©tÃ© Â« GenerateResourceWarnOnBinaryFormatterUse Â» sur false.
+        <target state="needs-review-translation">MSB3825: La ressource Â«Â {0} Â» de type Â«Â {1} Â» peut Ãªtre dÃ©sÃ©rialisÃ©e via BinaryFormatter lors de l'exÃ©cution. BinaryFormatter est obsolÃ¨te en raison de risques de sÃ©curitÃ© connus et est supprimÃ© de .NET 9+. Si vous souhaitez continuer Ã  l'utiliser, dÃ©finissez la propriÃ©tÃ© Â« GenerateResourceWarnOnBinaryFormatterUse Â» sur false.
            Plus d'informations : https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 8724e9b865a..ee8f4c59f2e 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: la risorsa "{0}" di tipo "{1}" puÃ² essere deserializzata tramite BinaryFormatter in fase di esecuzione. BinaryFormatter Ã¨ deprecato a causa di rischi noti per la sicurezza ed Ã¨ stato rimosso da .NET 9+. Se si desidera continuare a usarlo, impostare la proprietÃ  "GenerateResourceWarnOnBinaryFormatterUse" su false.
+        <target state="needs-review-translation">MSB3825: la risorsa "{0}" di tipo "{1}" puÃ² essere deserializzata tramite BinaryFormatter in fase di esecuzione. BinaryFormatter Ã¨ deprecato a causa di rischi noti per la sicurezza ed Ã¨ stato rimosso da .NET 9+. Se si desidera continuare a usarlo, impostare la proprietÃ  "GenerateResourceWarnOnBinaryFormatterUse" su false.
            Altre informazioni: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index fb42f9471c7..94f882b57ab 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: å®è¡æã« BinaryFormatter ãä½¿ç¨ãã¦ãåã "{1}" ã®ãªã½ã¼ã¹ "{0}" ãéã·ãªã¢ã«åããã¦ããå¯è½æ§ãããã¾ããBinaryFormatter ã¯ãæ¢ç¥ã®ã»ã­ã¥ãªãã£ ãªã¹ã¯ã«ããéæ¨å¥¨ã¨ãªãã.NET 9 ä»¥éã§ã¯åé¤ããã¾ããå¼ãç¶ãä½¿ç¨ããå ´åã¯ããã­ããã£ "GenerateResourceWarnOnBinaryFormatterUse" ã false ã«è¨­å®ãã¾ãã
+        <target state="needs-review-translation">MSB3825: å®è¡æã« BinaryFormatter ãä½¿ç¨ãã¦ãåã "{1}" ã®ãªã½ã¼ã¹ "{0}" ãéã·ãªã¢ã«åããã¦ããå¯è½æ§ãããã¾ããBinaryFormatter ã¯ãæ¢ç¥ã®ã»ã­ã¥ãªãã£ ãªã¹ã¯ã«ããéæ¨å¥¨ã¨ãªãã.NET 9 ä»¥éã§ã¯åé¤ããã¾ããå¼ãç¶ãä½¿ç¨ããå ´åã¯ããã­ããã£ "GenerateResourceWarnOnBinaryFormatterUse" ã false ã«è¨­å®ãã¾ãã
            è©³ç´°æå ±: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 488674964ff..a6259a05841 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: "{1}" íìì ë¦¬ìì¤ "{0}"ì(ë) ë°íì ì BinaryFormatterë¥¼ íµí´ ì­ì§ë ¬íë  ì ììµëë¤. BinaryFormatterë ìë ¤ì§ ë³´ì ìíì¼ë¡ ì¸í´ ì¬ì©ëì§ ìì¼ë©° .NET 9 ì´ììì ì ê±°ë©ëë¤. ê³ì ì¬ì©íë ¤ë©´ "GenerateResourceWarnOnBinaryFormatterUse" ìì±ì falseë¡ ì¤ì í©ëë¤.
+        <target state="needs-review-translation">MSB3825: "{1}" íìì ë¦¬ìì¤ "{0}"ì(ë) ë°íì ì BinaryFormatterë¥¼ íµí´ ì­ì§ë ¬íë  ì ììµëë¤. BinaryFormatterë ìë ¤ì§ ë³´ì ìíì¼ë¡ ì¸í´ ì¬ì©ëì§ ìì¼ë©° .NET 9 ì´ììì ì ê±°ë©ëë¤. ê³ì ì¬ì©íë ¤ë©´ "GenerateResourceWarnOnBinaryFormatterUse" ìì±ì falseë¡ ì¤ì í©ëë¤.
            ì¶ê° ì ë³´: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 1be6493ac7e..4da6d1540bb 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: zasÃ³b â{0}â typu â{1}â moÅ¼e byÄ deserializowany za poÅrednictwem elementu BinaryFormatter w czasie wykonywania. Element BinaryFormatter jest przestarzaÅy ze wzglÄdu na znane zagroÅ¼enia bezpieczeÅstwa i zostaÅ usuniÄty z platformy .NET 9 lub nowszej. JeÅli chcesz nadal go uÅ¼ywaÄ, ustaw wÅaÅciwoÅÄ âGenerateResourceWarnOnBinaryFormatterUseâ na false.
+        <target state="needs-review-translation">MSB3825: zasÃ³b â{0}â typu â{1}â moÅ¼e byÄ deserializowany za poÅrednictwem elementu BinaryFormatter w czasie wykonywania. Element BinaryFormatter jest przestarzaÅy ze wzglÄdu na znane zagroÅ¼enia bezpieczeÅstwa i zostaÅ usuniÄty z platformy .NET 9 lub nowszej. JeÅli chcesz nadal go uÅ¼ywaÄ, ustaw wÅaÅciwoÅÄ âGenerateResourceWarnOnBinaryFormatterUseâ na false.
            WiÄcej informacji: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index dbf2d3b1507..5f75aa1a1c6 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: O recurso "{0}" do tipo "{1}" pode ser desserializado via BinaryFormatter em tempo de execuÃ§Ã£o. O BinaryFormatter foi preterido devido a riscos de seguranÃ§a conhecidos e foi removido do .NET 9+. Se desejar continuar usando, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como false.
+        <target state="needs-review-translation">MSB3825: O recurso "{0}" do tipo "{1}" pode ser desserializado via BinaryFormatter em tempo de execuÃ§Ã£o. O BinaryFormatter foi preterido devido a riscos de seguranÃ§a conhecidos e foi removido do .NET 9+. Se desejar continuar usando, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como false.
            MaisÂ informaÃ§Ãµes: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 1458e4be35d..7873387dffa 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: Ð´Ð»Ñ ÑÐµÑÑÑÑÐ° "{0}" Ñ ÑÐ¸Ð¿Ð¾Ð¼ "{1}" Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð° Ð´ÐµÑÐµÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ BinaryFormatter Ð²Ð¾ Ð²ÑÐµÐ¼Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ. BinaryFormatter ÑÐ²Ð»ÑÐµÑÑÑ Ð½ÐµÑÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑÐµÐ¼ÑÐ¼ Ð¸Ð·-Ð·Ð° Ð¸Ð·Ð²ÐµÑÑÐ½ÑÑ ÑÐ¸ÑÐºÐ¾Ð² Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑÐ¸ Ð¸ ÑÐ´Ð°Ð»ÐµÐ½ Ð¸Ð· .NET 9+. ÐÑÐ»Ð¸ Ð²Ñ ÑÐ¾ÑÐ¸ÑÐµ Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶Ð¸ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÐµÐ³Ð¾, Ð·Ð°Ð´Ð°Ð¹ÑÐµ Ð´Ð»Ñ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° GenerateResourceWarnOnBinaryFormatterUse Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ false.
+        <target state="needs-review-translation">MSB3825: Ð´Ð»Ñ ÑÐµÑÑÑÑÐ° "{0}" Ñ ÑÐ¸Ð¿Ð¾Ð¼ "{1}" Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð° Ð´ÐµÑÐµÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ BinaryFormatter Ð²Ð¾ Ð²ÑÐµÐ¼Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ. BinaryFormatter ÑÐ²Ð»ÑÐµÑÑÑ Ð½ÐµÑÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑÐµÐ¼ÑÐ¼ Ð¸Ð·-Ð·Ð° Ð¸Ð·Ð²ÐµÑÑÐ½ÑÑ ÑÐ¸ÑÐºÐ¾Ð² Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑÐ¸ Ð¸ ÑÐ´Ð°Ð»ÐµÐ½ Ð¸Ð· .NET 9+. ÐÑÐ»Ð¸ Ð²Ñ ÑÐ¾ÑÐ¸ÑÐµ Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶Ð¸ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÐµÐ³Ð¾, Ð·Ð°Ð´Ð°Ð¹ÑÐµ Ð´Ð»Ñ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° GenerateResourceWarnOnBinaryFormatterUse Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ false.
            ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐµ ÑÐ²ÐµÐ´ÐµÐ½Ð¸Ñ ÑÐ¼. Ð² ÑÑÐºÐ¾Ð²Ð¾Ð´ÑÑÐ²Ðµ Ð¿Ð¾ Ð¼Ð¸Ð³ÑÐ°ÑÐ¸Ð¸ Ð¿Ð¾ ÑÑÑÐ»ÐºÐµ https://aka.ms/binaryformatter.</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 5e21f464b5d..0258fb53cd2 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: "{1}" tÃ¼rÃ¼ndeki "{0}" kaynaÄÄ± Ã§alÄ±Åma zamanÄ±nda BinaryFormatter aracÄ±lÄ±ÄÄ±yla seri duruma getiriliyor olabilir. BinaryFormatter, bilinen gÃ¼venlik riskleri nedeniyle kullanÄ±m dÄ±ÅÄ±dÄ±r ve .NET 9+'dan kaldÄ±rÄ±lÄ±r. Kullanmaya devam etmek istiyorsanÄ±z "GenerateResourceWarnOnBinaryFormatterUse" Ã¶zelliÄini false olarak ayarlayÄ±n.
+        <target state="needs-review-translation">MSB3825: "{1}" tÃ¼rÃ¼ndeki "{0}" kaynaÄÄ± Ã§alÄ±Åma zamanÄ±nda BinaryFormatter aracÄ±lÄ±ÄÄ±yla seri duruma getiriliyor olabilir. BinaryFormatter, bilinen gÃ¼venlik riskleri nedeniyle kullanÄ±m dÄ±ÅÄ±dÄ±r ve .NET 9+'dan kaldÄ±rÄ±lÄ±r. Kullanmaya devam etmek istiyorsanÄ±z "GenerateResourceWarnOnBinaryFormatterUse" Ã¶zelliÄini false olarak ayarlayÄ±n.
            Daha fazla bilgi iÃ§in bkz. https://aka.ms/binaryformatter-migration-guide.</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index df77a4fa0d8..95eda751b26 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: å¯å¨è¿è¡æ¶éè¿ BinaryFormatter ååºååç±»åä¸ºâ{1}âçèµæºâ{0}âãç±äºå·²ç¥çå®å¨é£é©ï¼BinaryFormatter å·²è¢«å¼ç¨ï¼å¹¶ä» .NET 9+ ä¸­å é¤ãå¦æè¦ç»§ç»­ä½¿ç¨å®ï¼è¯·å°å±æ§âGenerateResourceWarnOnBinaryFormatterUseâè®¾ç½®ä¸º falseã
+        <target state="needs-review-translation">MSB3825: å¯å¨è¿è¡æ¶éè¿ BinaryFormatter ååºååç±»åä¸ºâ{1}âçèµæºâ{0}âãç±äºå·²ç¥çå®å¨é£é©ï¼BinaryFormatter å·²è¢«å¼ç¨ï¼å¹¶ä» .NET 9+ ä¸­å é¤ãå¦æè¦ç»§ç»­ä½¿ç¨å®ï¼è¯·å°å±æ§âGenerateResourceWarnOnBinaryFormatterUseâè®¾ç½®ä¸º falseã
            æå³è¯¦ç»ä¿¡æ¯ï¼è¯·åéï¼https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index cb6e2af101c..4fb4af8fc3a 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" of type "{1}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: å¨å·è¡éæ®µï¼å¯è½æéé BinaryFormatter å°é¡åçºã{1}ãçè³æºã{0}ãåæ¶åå§åãBinaryFormatter å·²å å·²ç¥çå®å¨æ§é¢¨éªèè¢«æ£ç¨ï¼ä¸å·²å¾ .NET 9+ ä¸­ç§»é¤ãå¦ææ¨æ³è¦ç¹¼çºä½¿ç¨å®ï¼è«å°å±¬æ§ "GenerateResourceWarnOnBinaryFormatterUse" è¨­çº falseã
+        <target state="needs-review-translation">MSB3825: å¨å·è¡éæ®µï¼å¯è½æéé BinaryFormatter å°é¡åçºã{1}ãçè³æºã{0}ãåæ¶åå§åãBinaryFormatter å·²å å·²ç¥çå®å¨æ§é¢¨éªèè¢«æ£ç¨ï¼ä¸å·²å¾ .NET 9+ ä¸­ç§»é¤ãå¦ææ¨æ³è¦ç¹¼çºä½¿ç¨å®ï¼è«å°å±¬æ§ "GenerateResourceWarnOnBinaryFormatterUse" è¨­çº falseã
            è©³ç´°è³è¨: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 76198ed413a..0d45b676cd8 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -3584,7 +3584,7 @@ public static string GetPathToBuildToolsFile(string fileName, string toolsVersio
             {
                 toolPath = Path.Combine(toolPath, fileName);
 
-                if (!FileSystems.Default.FileExists(toolPath))
+                if (!File.Exists(toolPath))
                 {
                     toolPath = null;
                 }
