diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index eaf5e31be4f..9f6a100769c 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -70,6 +70,8 @@ internal ProjectLoggingContext(
         {
         }
 
+        internal string ProjectFullPath { get => _projectFullPath; }
+
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 3d9a25df6cc..500cbed5cab 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.BackEnd.Logging
     /// <summary>
     /// A logging context for building a specific target within a project.
     /// </summary>
-    internal class TargetLoggingContext : BuildLoggingContext
+    internal class TargetLoggingContext : BuildLoggingContext, IHasProjectFullPath
     {
         /// <summary>
         /// Should target outputs be logged also.
@@ -86,6 +86,8 @@ internal ProjectTargetInstance Target
             }
         }
 
+        public string ProjectFullPath => _projectLoggingContext.ProjectFullPath;
+
         /// <summary>
         /// Log that a target has finished
         /// </summary>
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 1fbad6a47b6..23eff6007e6 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -24,7 +24,7 @@ internal class TaskFactoryLoggingHost :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IBuildEngine
+        IBuildEngine, IHasProjectFullPath
     {
         /// <summary>
         /// Location of the task node in the original file
@@ -55,6 +55,8 @@ internal class TaskFactoryLoggingHost :
         /// </summary>
         private bool _activeProxy;
 
+        private string _projectFullPath;
+
         /// <summary>
         /// Constructor
         /// </summary>
@@ -67,6 +69,11 @@ public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation e
             _isRunningWithMultipleNodes = isRunningWithMultipleNodes;
             _loggingContext = loggingContext;
             _elementLocation = elementLocation;
+
+            if (_loggingContext is IHasProjectFullPath logThatHasProjectFullPath)
+            {
+                _projectFullPath = logThatHasProjectFullPath.ProjectFullPath;
+            }
         }
 
         /// <summary>
@@ -146,6 +153,8 @@ internal BuildLoggingContext LoggingContext
             { return _loggingContext; }
         }
 
+        public string ProjectFullPath => _projectFullPath;
+
         #region IBuildEngine Members
 
         /// <summary>
diff --git a/src/Framework/IHasProjectFullPath.cs b/src/Framework/IHasProjectFullPath.cs
new file mode 100644
index 00000000000..5b3373f75c2
--- /dev/null
+++ b/src/Framework/IHasProjectFullPath.cs
@@ -0,0 +1,10 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework
+{
+    internal interface IHasProjectFullPath
+    {
+        string? ProjectFullPath { get; }
+    }
+}
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
new file mode 100644
index 00000000000..778aa9cf861
--- /dev/null
+++ b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
@@ -0,0 +1,137 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.IO.Compression;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Logging;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    internal enum FactoryType
+    {
+        CodeTaskFactory,
+        RoslynCodeTaskFactory,
+    }
+
+    internal static class CodeTaskFactoryEmbeddedFileInBinlogTestHelper
+    {
+        internal static void BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+            FactoryType factoryType,
+            string taskName,
+            string sourceContent,
+            bool buildShouldSucceed)
+        {
+            using var env = TestEnvironment.Create();
+
+            TransientTestFolder folder = env.CreateFolder(createFolder: true);
+
+            var sourceClass = env.CreateFile(folder, $"{taskName}.cs", sourceContent);
+
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="{factoryType}"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    <Task>
+                      <Code Type="Class" Language="cs" Source="{sourceClass.Path}">
+                      </Code>
+                    </Task>
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result, out string projecDirectoryPath);
+
+            Assert.Equal(buildShouldSucceed, result);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            // For unix-based systems path uses '/'
+            projecDirectoryPath = NativeMethodsShared.IsWindows ? projecDirectoryPath.Replace(":\\", "\\") : projecDirectoryPath.Replace("/", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(
+                zE => zE.FullName.StartsWith(projecDirectoryPath) && zE.Name.EndsWith($"{taskName}-compilation-file.tmp"),
+                $"Binlog's embedded files didn't have the expected '{projecDirectoryPath}/{{guid}}-{taskName}-compilation-file.tmp'.");
+        }
+
+        internal static void BuildAndCheckForEmbeddedFileInBinlog(
+            FactoryType factoryType,
+            string taskName,
+            string taskXml,
+            bool buildShouldSucceed)
+        {
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="{factoryType}"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    {taskXml}
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            using var env = TestEnvironment.Create();
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result, out string projectDirectory);
+
+            Assert.Equal(buildShouldSucceed, result);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            // For unix-based systems path uses '/'
+            projectDirectory = NativeMethodsShared.IsWindows ? projectDirectory.Replace(":\\", "\\") : projectDirectory.Replace("/", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(
+                zE => zE.FullName.StartsWith(projectDirectory) && zE.Name.EndsWith($"{taskName}-compilation-file.tmp"),
+                $"Binlog's embedded files didn't have the expected '{projectDirectory}/{{guid}}-{taskName}-compilation-file.tmp'.");
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 9b273fa870d..ae7d8617771 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -19,6 +19,7 @@ namespace Microsoft.Build.UnitTests
     using System.Globalization;
     using System.IO.Compression;
     using Microsoft.Build.Logging;
+    using Microsoft.Build.Tasks.UnitTests;
     using Shouldly;
 
     public sealed class CodeTaskFactoryTests
@@ -1130,9 +1131,7 @@ public void EmbedsGeneratedFromSourceFileInBinlog()
         {
             string taskName = "HelloTask";
 
-            using var env = TestEnvironment.Create();
-            var folder = env.CreateFolder(createFolder: true);
-            var taskClass = env.CreateFile(folder, $"{taskName}.cs", $$"""
+            string sourceContent = $$"""
                 namespace InlineTask
                 {
                     using Microsoft.Build.Utilities;
@@ -1146,56 +1145,10 @@ public override bool Execute()
                         }
                     }
                 }
-                """);
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="CodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                      <Code Type="Class" Language="cs" Source="{taskClass.Path}">
-                      </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
                 """;
 
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeTrue();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
-            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, taskName, sourceContent, true);
         }
 
         [Fact]
@@ -1203,185 +1156,49 @@ public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
         {
             string taskName = "HelloTask";
 
-            using var env = TestEnvironment.Create();
-            var folder = env.CreateFolder(createFolder: true);
-            var classThatFailsToCompile = env.CreateFile(folder, $"{taskName}.cs", $$"""
+            string sourceContent =  $$"""
                 namespace InlineTask
                 {
                     using Microsoft.Build.Utilities;
 
                     public class {{taskName}} : Task
                     {
-                """);
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="CodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                      <Code Type="Class" Language="cs" Source="{classThatFailsToCompile.Path}">
-                      </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
                 """;
 
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeFalse();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
-            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, taskName, sourceContent, false);
         }
 
         [Fact]
         public void EmbedsGeneratedFileInBinlog()
         {
-            string taskName = "HelloTask";
-
-            using var env = TestEnvironment.Create();
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="CodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                	    <Code Type="Fragment" Language="cs">
-                		    <![CDATA[
-                		      Log.LogMessage("Hello, World!");
-                		    ]]>
-                	    </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
-                """;
-
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeTrue();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
-            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!"");
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, "HelloTask", taskXml, true);
         }
 
         [Fact]
         public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
         {
-            string taskName = "HelloTask";
-
-            using var env = TestEnvironment.Create();
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="CodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                	    <Code Type="Fragment" Language="cs">
-                		    <![CDATA[
-                		      Log.LogMessage("Hello, World!
-                		    ]]>
-                	    </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
-                """;
-
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeFalse();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
-            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, "HelloTask", taskXml, false);
         }
     }
 #else
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 7f592543d58..938e4517afd 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -23,6 +23,7 @@
 using Xunit;
 
 using static VerifyXunit.Verifier;
+using System.IO.Compression;
 
 #nullable disable
 
@@ -650,9 +651,7 @@ public void EmbedsGeneratedFromSourceFileInBinlog()
         {
             string taskName = "HelloTask";
 
-            using var env = TestEnvironment.Create();
-            var folder = env.CreateFolder(createFolder: true);
-            var taskClass = env.CreateFile(folder, $"{taskName}.cs", $$"""
+            string sourceContent = $$"""
                 namespace InlineTask
                 {
                     using Microsoft.Build.Utilities;
@@ -666,56 +665,10 @@ public override bool Execute()
                         }
                     }
                 }
-                """);
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="RoslynCodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                      <Code Type="Class" Language="cs" Source="{taskClass.Path}">
-                      </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
                 """;
 
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeTrue();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
-            using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, taskName, sourceContent, true);
         }
 
         [Fact]
@@ -723,185 +676,49 @@ public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
         {
             string taskName = "HelloTask";
 
-            using var env = TestEnvironment.Create();
-            var folder = env.CreateFolder(createFolder: true);
-            var classThatFailsToCompile = env.CreateFile(folder, $"{taskName}.cs", $$"""
+            string sourceContent =  $$"""
                 namespace InlineTask
                 {
                     using Microsoft.Build.Utilities;
 
                     public class {{taskName}} : Task
                     {
-                """);
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="RoslynCodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                      <Code Type="Class" Language="cs" Source="{classThatFailsToCompile.Path}">
-                      </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
                 """;
 
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeFalse();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
-            using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, taskName, sourceContent, false);
         }
 
         [Fact]
         public void EmbedsGeneratedFileInBinlog()
         {
-            string taskName = "HelloTask";
-
-            using var env = TestEnvironment.Create();
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="RoslynCodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                	    <Code Type="Fragment" Language="cs">
-                		    <![CDATA[
-                		      Log.LogMessage("Hello, World!");
-                		    ]]>
-                	    </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
-                """;
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!"");
+                		   ]]>
+                    </Code>
+                </Task>";
 
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeTrue();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
-            using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-               $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, "HelloTask", taskXml, true);
         }
 
         [Fact]
         public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
         {
-            string taskName = "HelloTask";
-
-            using var env = TestEnvironment.Create();
-
-            string projectFileContents = $"""
-                <Project>
-
-                  <UsingTask
-                    TaskName="{taskName}"
-                    TaskFactory="RoslynCodeTaskFactory"
-                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
-                    <Task>
-                	    <Code Type="Fragment" Language="cs">
-                		    <![CDATA[
-                		      Log.LogMessage("Hello, World!
-                		    ]]>
-                	    </Code>
-                    </Task>
-                  </UsingTask>
-
-                    <Target Name="SayHello">
-                        <{taskName} />
-                    </Target>
-
-                </Project>
-                """;
-
-            TransientTestFile binlog = env.ExpectFile(".binlog");
-
-            var binaryLogger = new BinaryLogger()
-            {
-                Parameters = $"LogFile={binlog.Path}",
-                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
-            };
-
-            MockLogger mockLogger = Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result);
-
-            result.ShouldBeFalse();
-
-            // Get the file path from the logs
-            // Then check if it is in the binlog
-            mockLogger.AssertLogContainsMessageWithParameter(ResourceUtilities.GetResourceString("CodeTaskFactory.FindSourceFileInBinlogAt"), out string filePath);
-
-            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
-            using var fileStream = new System.IO.FileStream(projectImportsZipPath, System.IO.FileMode.Open);
-            using var zipArchive = new System.IO.Compression.ZipArchive(fileStream, System.IO.Compression.ZipArchiveMode.Read);
-
-            // A path like "C:\path" in ZipArchive is saved as "C\path"
-            // For unix-based systems path uses '/'
-            filePath = NativeMethodsShared.IsWindows ? filePath.Replace(":\\", "\\") : filePath.Replace("/", "\\");
-
-            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
-            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.FullName.EndsWith(filePath),
-                $"Binlog's embedded files didn't have the expected '{filePath}'.");
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, "HelloTask", taskXml, false);
         }
 
 #if !FEATURE_RUN_EXE_IN_TESTS
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 885de9fdac8..873ea43c980 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -126,6 +126,11 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         /// </summary>
         private string _nameOfTask;
 
+        /// <summary>
+        /// The directory of the current project
+        /// </summary>
+        private string _projectDirectory;
+
         /// <summary>
         /// Path to source that is outside the project file
         /// </summary>
@@ -183,6 +188,11 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
                 HelpKeywordPrefix = "MSBuild."
             };
 
+            if (taskFactoryLoggingHost is IHasProjectFullPath logThatHasProjectFullPath)
+            {
+                _projectDirectory = Path.GetDirectoryName(logThatHasProjectFullPath.ProjectFullPath);
+            }
+
             XmlNode taskContent = ExtractTaskContent(taskElementContents);
             if (taskContent == null)
             {
@@ -791,15 +801,14 @@ private Assembly CompileInMemoryAssembly()
                 // Our code generation is complete, grab the source from the builder ready for compilation
                 string fullCode = codeBuilder.ToString();
 
-                string tempDirectory = FileUtilities.TempFileDirectory;
-                string fileName = Guid.NewGuid().ToString() + ".txt";
-                string outputPath = Path.Combine(tempDirectory, fileName);
-
                 // Embed generated file in the binlog
-                _log.LogIncludeGeneratedFile(outputPath, fullCode);
+                if (_projectDirectory != null)
+                {
+                    string fileNameInBinlog = $"{Guid.NewGuid()}-{_nameOfTask}-compilation-file.tmp";
+                    string outputPathInBinlog = Path.Combine(_projectDirectory, fileNameInBinlog);
 
-                // Log the location of the code file in binlog
-                _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileInBinlogAt", outputPath);
+                    _log.LogIncludeGeneratedFile(outputPathInBinlog, fullCode);
+                }
 
                 var fullSpec = new FullTaskSpecification(finalReferencedAssemblies, fullCode);
                 if (!s_compiledTaskCache.TryGetValue(fullSpec, out Assembly existingAssembly))
@@ -807,8 +816,12 @@ private Assembly CompileInMemoryAssembly()
                     // Invokes compilation.
                     CompilerResults compilerResults = provider.CompileAssemblyFromSource(compilerParameters, fullCode);
 
+                    string outputPath = null;
                     if (compilerResults.Errors.Count > 0 || Environment.GetEnvironmentVariable("MSBUILDLOGCODETASKFACTORYOUTPUT") != null)
-                    {                        
+                    {
+                        string tempDirectory = FileUtilities.TempFileDirectory;
+                        string fileName = Guid.NewGuid().ToString() + ".txt";
+                        outputPath = Path.Combine(tempDirectory, fileName);
                         File.WriteAllText(outputPath, fullCode);
                     }
 
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index d0d22a35a89..a969d1dc8de 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2513,9 +2513,6 @@
   <data name="CodeTaskFactory.FindSourceFileAt" xml:space="preserve">
     <value>The source file for this compilation can be found at: "{0}"</value>
   </data>
-  <data name="CodeTaskFactory.FindSourceFileInBinlogAt" xml:space="preserve">
-    <value>The source file for this compilation can be found embedded in binlog at: "{0}"</value>
-  </data>
   <data name="CodeTaskFactory.HaveReflectionOnlyAssembly" xml:space="preserve">
     <value>The reference assembly "{0}" is a metadata only assembly.</value>
   </data>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index ef82617989f..b4fc18d7e3f 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: Pozdržené podepisování požaduje, aby byl určen alespoň veřejný klíč.  Zadejte veřejný klíč pomocí vlastnosti KeyFile nebo KeyContainer, nebo zakažte pozdržené podepisování.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: Hodnota {0} není nastavena nebo je prázdná. Pokud {1} má hodnotu false, nezapomeňte pro hodnotu {0} nastavit neprázdnou hodnotu.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 56f3842d730..a185f1c58dc 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: Für verzögertes Signieren muss mindestens ein öffentlicher Schlüssel angegeben werden.  Geben Sie entweder einen öffentlichen Schlüssel mithilfe der KeyFile- oder KeyContainer-Eigenschaft an, oder deaktivieren Sie verzögertes Signieren.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: „{0}“ ist nicht festgelegt oder leer. Wenn {1} falsch ist, legen Sie für „{0}“ auf keinen Fall einen leeren Wert fest.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index f9ebccfaee3..eef9d9a6a5e 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: "{0}" no se ha establecido o está vacío. Cuando {1} sea false, asegúrese de establecer un valor que no esté vacío para "{0}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 475c908614a..0a38e39c972 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: La signature différée nécessite qu'au moins une clé publique soit spécifiée.  Indiquez une clé publique à l'aide des propriétés KeyFile ou KeyContainer, ou désactivez la signature différée.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: « {0} » n’est pas défini ou vide. Quand la valeur de {1} est false, veillez à définir une valeur non vide pour « {0} ».</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 2b7b256c01f..27b03e70d2e 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: la firma ritardata richiede che sia specificata almeno una chiave pubblica. Fornire una chiave pubblica usando le proprietà KeyFile o KeyContainer oppure disabilitare la firma ritardata.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: '{0}' non è impostato o è vuoto. Quando {1} è false, assicurarsi di impostare un valore non vuoto per '{0}'.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 9390ac142f5..855a8a09ef6 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: 遅延署名には、最低でも 1 つの公開キーを指定する必要があります。KeyFile または KeyContainer プロパティを使用して公開キーを提供するか、遅延署名を無効にしてください。</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: '{0}' が設定されていないか、空です。{1} が false の場合は、'{0}' に空でない値を設定してください。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 9c8f0e94a92..9e7d5d6eabc 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: 서명을 연기하려면 적어도 공개 키를 지정해야 합니다.  KeyFile 또는 KeyContainer 속성을 사용하여 공개 키를 제공하거나 서명 연기를 비활성화하세요.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: '{0}'이(가) 설정되지 않았거나 비어 있습니다. {1}이(가) false인 경우 '{0}'에 비어 있지 않은 값을 설정해야 합니다.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 154b79c271b..6f0ed65f8bc 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: Podpisywanie opóźnione wymaga określenia przynajmniej klucza publicznego.  Podaj klucz publiczny przy użyciu właściwości KeyFile lub KeyContainer albo wyłącz podpisywanie opóźnione.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: „{0}” nie jest ustawiony ani pusty. Jeśli {1} ma wartość false, ustaw wartość, która nie jest pusta dla „{0}”.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index b99774cd02f..d6bccad1740 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: A assinatura atrasada requer que pelo menos uma chave pública seja especificada.  Forneça uma chave pública usando as propriedades KeyFile ou KeyContainer ou desabilite a assinatura atrasada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: '{0}' não está definido ou está vazio. Quando {1} for falso, certifique-se de definir um valor não vazio para '{0}'.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 5682fd0d169..13636f628c9 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: для отложенного подписывания необходимо указать хотя бы один открытый ключ.  Укажите открытый ключ с помощью свойства KeyFile или KeyContainer либо отключите отложенное подписывание.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: "{0}" не настроено или пусто. Если для {1} присвоено значение false, настройте непустое значение для "{0}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index f4f194dac8e..80e916c9578 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: Gecikmeli imzalama, en azından bir ortak anahtar belirtilmesini gerektirir.  Lütfen KeyFile veya KeyContainer özelliklerini kullanarak bir ortak anahtar sağlayın veya gecikmeli imzalamayı devre dışı bırakın.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: '{0}' ayarlanmamış veya boş. {1} yanlış olduğunda, '{0}' için boş olmayan bir değer ayarlandığından emin olun.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 1cfff57d959..fb45fb03527 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: 延迟签名要求至少指定一个公钥。请使用 KeyFile 或 KeyContainer 属性提供一个公钥，或者禁用延迟签名。</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: "{0}" 未设置或为空。如果 {1} 为 false，请确保为 "{0}" 设置非空值。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 65fb1b7f0e8..1ce29e770f5 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -121,11 +121,6 @@
         <target state="translated">MSB3654: 延遲簽署需要至少指定一個公開金鑰。請使用 KeyFile 或 KeyContainer 屬性提供公開金鑰，或停用延遲簽署。</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
-      <trans-unit id="CodeTaskFactory.FindSourceFileInBinlogAt">
-        <source>The source file for this compilation can be found embedded in binlog at: "{0}"</source>
-        <target state="new">The source file for this compilation can be found embedded in binlog at: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
         <target state="translated">MSB3991: 未設定 '{0}' 或空白。當 {1} 為 false 時，請務必將 '{0}' 設定非空白值。</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 7f89cca13af..df7f10415f0 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -111,6 +111,8 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// </summary>
         private string _taskName;
 
+        private string _projectDirectory;
+
         /// <inheritdoc cref="ITaskFactory.FactoryName"/>
         public string FactoryName => "Roslyn Code Task Factory";
 
@@ -151,6 +153,11 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
                 HelpKeywordPrefix = "MSBuild."
             };
 
+            if (taskFactoryLoggingHost is IHasProjectFullPath logThatHasProjectFullPath)
+            {
+                _projectDirectory = Path.GetDirectoryName(logThatHasProjectFullPath.ProjectFullPath);
+            }
+
             _taskName = taskName;
 
             _parameters = parameterGroup.Values.ToArray();
@@ -686,11 +693,14 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
             try
             {
                 // Embed generated file in the binlog
-                _log.LogIncludeGeneratedFile(sourceCodePath, taskInfo.SourceCode);
-
-                // Log the location of the code file in binlog
-                _log.LogMessageFromResources(MessageImportance.Low, "CodeTaskFactory.FindSourceFileInBinlogAt", sourceCodePath);
-
+                if (_projectDirectory != null)
+                {
+                    string fileNameInBinlog = $"{Guid.NewGuid()}-{_taskName}-compilation-file.tmp";
+                    string outputPathInBinlog = Path.Combine(_projectDirectory, fileNameInBinlog);
+                    
+                    _log.LogIncludeGeneratedFile(outputPathInBinlog, taskInfo.SourceCode);
+                }
+                
                 // Create the code
                 File.WriteAllText(sourceCodePath, taskInfo.SourceCode);
 
diff --git a/src/UnitTests.Shared/MockLogger.cs b/src/UnitTests.Shared/MockLogger.cs
index ea638a0bbb2..dab6b5e32d0 100644
--- a/src/UnitTests.Shared/MockLogger.cs
+++ b/src/UnitTests.Shared/MockLogger.cs
@@ -504,52 +504,6 @@ public void AssertLogContains(bool isCaseSensitive, params string[] contains)
             }
         }
 
-        /// <summary>
-        /// Asserts that log file contains a message with a single parameter.
-        /// </summary>
-        /// <param name="message">The message that contains '{0}' substring.</param>
-        /// <param name="parameter">The parameter.</param>
-        public void AssertLogContainsMessageWithParameter(string message, out string parameter)
-        {
-            parameter = "";
-            string placeholder = "{0}";
-
-            string regexPattern = "";
-            if (message.Contains(placeholder))
-            {
-                regexPattern = message.Replace(placeholder, "(.*)");
-            }
-            else
-            {
-                Assert.True(
-                        false,
-                        $"'{message}' was expected to contain a substring '{{0}}'.");
-            }
-
-            lock (_lockObj)
-            {
-                var reader = new StringReader(FullLog);
-                string currentLine = reader.ReadLine();
-
-                while (currentLine != null)
-                {
-                    var match = Regex.Match(currentLine, regexPattern);
-
-                    if (match.Success && match.Groups.Count > 1)
-                    {
-                        parameter = match.Groups[1].Value;
-                        return;
-                    }
-
-                    currentLine = reader.ReadLine();
-                }
-
-                Assert.True(
-                        false,
-                        $"Log was expected to contain '{message}', but did not. Full log:\n=======\n{FullLog}\n=======");
-            }
-        }
-
         /// <summary>
         /// Assert that the log file does not contain the given string.
         /// </summary>
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index 0643f993db6..ce51be22785 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -1359,20 +1359,18 @@ private static void BuildProjectWithNewOM(string content, ref MockLogger logger,
             result = project.Build(loggers);
         }
 
-        public static MockLogger BuildProjectWithNewOMAndBinaryLogger(string content, BinaryLogger binaryLogger, out bool result)
+        public static void BuildProjectWithNewOMAndBinaryLogger(string content, BinaryLogger binaryLogger, out bool result, out string projectDirectory)
         {
             // Replace the nonstandard quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             Project project = new Project(XmlReader.Create(new StringReader(content)), null, toolsVersion: null);
 
-            var mockLogger = new MockLogger();
-
-            List<ILogger> loggers = new List<ILogger>() { binaryLogger, mockLogger };
+            List<ILogger> loggers = new List<ILogger>() { binaryLogger };
 
             result = project.Build(loggers);
 
-            return mockLogger;
+            projectDirectory = project.DirectoryPath;
         }
 
         public static MockLogger BuildProjectContentUsingBuildManagerExpectResult(string content, BuildResultCode expectedResult)
