diff --git a/.config/git-merge-flow-config.jsonc b/.config/git-merge-flow-config.jsonc
index e9fac7f230c..a58d3e867ea 100644
--- a/.config/git-merge-flow-config.jsonc
+++ b/.config/git-merge-flow-config.jsonc
@@ -10,24 +10,16 @@
         "vs17.0": {
             "MergeToBranch": "vs17.3"
         },
-        // Automate opening PRs to merge msbuild's vs17.3 (SDK 6.0.4xx) into vs17.4 (SDK 7.0.1xx until 5/2024, VS until 7/2024)
+        // Automate opening PRs to merge msbuild's vs17.3 (SDK 6.0.4xx) into vs17.6 (VS until 1/2025)
         "vs17.3": {
-            "MergeToBranch": "vs17.4"
-        },
-        // Automate opening PRs to merge msbuild's vs17.4 into vs17.6 (VS until 1/2025)
-        "vs17.4": {
             "MergeToBranch": "vs17.6"
         },
         // Automate opening PRs to merge msbuild's vs17.6 into vs17.8 (VS until 7/2025)
         "vs17.6": {
             "MergeToBranch": "vs17.8"
         },
-        // Automate opening PRs to merge msbuild's vs17.8 (SDK 8.0.1xx) into vs17.9 (SDK 8.0.2xx)
+        // Automate opening PRs to merge msbuild's vs17.8 (SDK 8.0.1xx) into vs17.10 (SDK 8.0.3xx)
         "vs17.8": {
-            "MergeToBranch": "vs17.9"
-        },
-        // Automate opening PRs to merge msbuild's vs17.9 (SDK 8.0.2xx) into vs17.10 (SDK 8.0.3xx)
-        "vs17.9": {
             "MergeToBranch": "vs17.10"
         },
         // Automate opening PRs to merge msbuild's vs17.10 (SDK 8.0.3xx) into vs17.11 (SDK 8.0.4xx)
diff --git a/.config/guardian/.gdnbaselines b/.config/guardian/.gdnbaselines
index 7d8206c7975..cd66fbded9f 100644
--- a/.config/guardian/.gdnbaselines
+++ b/.config/guardian/.gdnbaselines
@@ -11,48 +11,6 @@
     }
   },
   "results": {
-    "1757d0179485ad6618415e151de2453f25d5484071f7bae328fa9ca9d4d54688": {
-      "signature": "1757d0179485ad6618415e151de2453f25d5484071f7bae328fa9ca9d4d54688",
-      "alternativeSignatures": [],
-      "target": "src/Tasks.UnitTests/TestResources/mycert.pfx",
-      "line": 1,
-      "memberOf": [
-        "default"
-      ],
-      "tool": "credscan",
-      "ruleId": "CSCAN-GENERAL0020",
-      "createdDate": "2024-03-14 11:30:33Z",
-      "expirationDate": "2024-08-31 12:48:32Z",
-      "justification": "This error is baselined with an expiration date of 180 days from 2024-03-14 12:48:32Z"
-    },
-    "60d4d52e838e08dc19d3ac2b43b7c809b080db55f9c754b80bd60f30624e9687": {
-      "signature": "60d4d52e838e08dc19d3ac2b43b7c809b080db55f9c754b80bd60f30624e9687",
-      "alternativeSignatures": [],
-      "target": "artifacts/bin/Microsoft.Build.Tasks.UnitTests/Release/net472/TestResources/mycert.pfx",
-      "line": 1,
-      "memberOf": [
-        "default"
-      ],
-      "tool": "credscan",
-      "ruleId": "CSCAN-GENERAL0020",
-      "createdDate": "2024-03-14 12:01:14Z",
-      "expirationDate": "2024-08-31 12:48:32Z",
-      "justification": "This error is baselined with an expiration date of 180 days from 2024-03-14 12:48:32Z"
-    },
-    "7cb5d42a8744e4a214149aa27d3d8a1b7989914d1a2fee8cea13287368cbafff": {
-      "signature": "7cb5d42a8744e4a214149aa27d3d8a1b7989914d1a2fee8cea13287368cbafff",
-      "alternativeSignatures": [],
-      "target": "artifacts/bin/Microsoft.Build.Tasks.UnitTests/Release/net8.0/TestResources/mycert.pfx",
-      "line": 1,
-      "memberOf": [
-        "default"
-      ],
-      "tool": "credscan",
-      "ruleId": "CSCAN-GENERAL0020",
-      "createdDate": "2024-03-14 12:01:14Z",
-      "expirationDate": "2024-08-31 12:48:32Z",
-      "justification": "This error is baselined with an expiration date of 180 days from 2024-03-14 12:48:32Z"
-    },
     "24491acb7bf0f8b072d9fbd2f6efcf1bdf6e9506ff3f7a9f9c803445c55b7bd9": {
       "signature": "24491acb7bf0f8b072d9fbd2f6efcf1bdf6e9506ff3f7a9f9c803445c55b7bd9",
       "alternativeSignatures": [
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
index acee0786cb0..40aa1dda370 100644
--- a/.exp-insertions.yml
+++ b/.exp-insertions.yml
@@ -155,6 +155,21 @@ jobs:
       nugetConfigPath: '$(Build.SourcesDirectory)\NuGet.config'
       restoreDirectory: '$(Build.SourcesDirectory)\.packages'
 
+  # https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/1es-security-configuration/configuration-guides/pat-burndown-guidance#authentication-from-pipelines
+  # Requires Azure client 2.x
+  - task: AzureCLI@2
+    displayName: 'Set AzDO.DotnetPerfStarToken'
+    enabled: true
+    inputs:
+      azureSubscription: 'dotnet-perfstar at app.vssps.visualstudio.com'   # Azure DevOps service connection
+      scriptType: 'pscore'
+      scriptLocation: 'inlineScript'
+      inlineScript: |
+        # '499b84ac-1321-427f-aa17-267ca6975798' for Azure DevOps
+        $token = az account get-access-token --query accessToken --resource 499b84ac-1321-427f-aa17-267ca6975798 -o tsv
+        Write-Host "Setting AzDO.DotnetPerfStarToken"
+        Write-Host "##vso[task.setvariable variable=AzDO.DotnetPerfStarToken]${token}"
+
   - powershell: |
       mkdir "$(Pipeline.Workspace)/artifacts"
 
@@ -166,7 +181,7 @@ jobs:
       Write-Host "Detected drop.exe path: $dropExePath"
 
       Write-Host "Downloading VS msbuild"
-      $patAuthEnvVar = "SYSTEM_ACCESSTOKEN"
+      $patAuthEnvVar = "patVariable"
       & "$dropExePath" get --patAuthEnvVar $patAuthEnvVar -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
       Write-Host "Download of VS msbuild finished"
 
@@ -175,7 +190,7 @@ jobs:
       Write-Host "Copy of VS msbuild finished"
     displayName: Download msbuild vs drop
     env:
-      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
+      patVariable: $(AzDO.DotnetPerfStarToken)
 
   - task: DownloadBuildArtifacts@1
     inputs:
diff --git a/.gitattributes b/.gitattributes
index af9d9e931ae..964a7141374 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -24,3 +24,6 @@ eng/common/** linguist-vendored linguist-generated
 
 # Display XLF files collapsed by default in PR diffs
 *.xlf linguist-generated=true
+
+# VerifyTests
+*.verified.txt text eol=lf working-tree-encoding=UTF-8
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
new file mode 100644
index 00000000000..7af03649c5e
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
@@ -0,0 +1,27 @@
+name: 💡 BuildCheck Suggestion
+description: Suggesting a diagnostic check (AKA [BuildCheck](https://github.com/dotnet/msbuild/blob/main/documentation/specs/BuildCheck/BuildCheck.md)) that MSBuild could provide.
+title: "[BuildCheck Suggestion]: "
+labels: ["BuildCheck Suggestion", "Area: BuildCheck"]
+body:
+  - type: textarea
+    attributes:
+      label: Summary
+      description: Brief summary of what this proposal is about.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Background and Motivation
+      description: What is the problem MSBuild should be flagging and in what context did you encounter it?
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Sample issue or antipattern that the check should be flagging
+      description: Please provide as specific as possible sample that you envision to be catched by the check.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Sample output
+      description: If you have an idea what and how to report - please try to provide possible sample.
diff --git a/.github/workflows/inter-branch-merge-flow.yml b/.github/workflows/inter-branch-merge-flow.yml
new file mode 100644
index 00000000000..68fdef4127b
--- /dev/null
+++ b/.github/workflows/inter-branch-merge-flow.yml
@@ -0,0 +1,15 @@
+name: Inter-branch merge workflow
+on:
+  push:
+    branches:
+      - vs1**
+
+permissions:
+  contents: write
+  pull-requests: write
+
+jobs:
+  Merge:
+    uses: dotnet/arcade/.github/workflows/inter-branch-merge-base.yml@main
+    with:
+      configuration_file_path: '.config/git-merge-flow-config.jsonc'
\ No newline at end of file
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index daf200ae88e..6df5156b632 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -15,11 +15,11 @@ jobs:
       $isVersionBumped = $false
       if ($changedVersionsFile -ne $null) {
         $difference = git diff HEAD~1 $versionsFile
-        $changedContent = $difference -join " "
+        $changedContent = $difference -join "%"
         # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
-        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix> \+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>.*<DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
         $isInitialCommit = $changedContent -match $initialCommitPattern
-        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.* \+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
         if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
           try {
             $previousPatch = [Convert]::ToInt32($Matches.previous)
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index ad33fce26d1..568f2af4ae9 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -60,6 +60,9 @@ extends:
       codeSignValidation:
         enabled: true
         break: true
+        additionalTargetsGlobPattern: -|**\bootstrapper\**\vs_enterprise.exe
+      credscan:
+        suppressionsFile: $(Build.SourcesDirectory)/eng/CredScanSuppressions.json
 
     stages:
     - stage: build
@@ -182,12 +185,6 @@ extends:
           displayName: 'OptProf - Build VS bootstrapper'
           condition: succeeded()
 
-        - task: PowerShell@2
-          displayName: Delete the file
-          inputs:
-            targetType: 'inline'
-            script: Get-ChildItem -Path "$(Build.SourcesDirectory)\artifacts\VSSetup\$(BuildConfiguration)\Insertion\bootstrapper" -Recurse -Filter "vs_enterprise.exe" | Remove-Item -Verbose
-
         # Publish run settings
         - task: PowerShell@2
           inputs:
diff --git a/NuGet.config b/NuGet.config
index 62eb43f0c28..d7187b4d64a 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <configuration>
   <packageSources>
     <clear />
diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
index 4f00f360e55..80d9467259d 100644
--- a/documentation/release-checklist.md
+++ b/documentation/release-checklist.md
@@ -14,7 +14,7 @@
 ## At release time
 
 - [ ] If the release is being cut more than a few days before the VS-side snap, do these two steps. Otherwise check them off.
-  - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases) Edit -> Schedule set under Artifacts -> disable toggle
+  - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases). Alternatively, if the release being cut no more than couple of weeks, disable the scheduled releases and create releases from `vs{{THIS_RELEASE_VERSION}}` manually until the VS-side snap: Edit -> Schedule set under Artifacts -> disable toggle
 AND
   - [ ]  Disable automated run of [the MSBuild-main-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) (because our {{NEXT_VERSION}} builds don't have a place to go in VS yet)
 - [ ]  Remove the `main` to old release channel ({{THIS_RELEASE_VERSION}}) default channel \
@@ -31,22 +31,19 @@ if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}"
 - [ ]  If the branch was created before the fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
 e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
 _(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
-- [ ]  Update the branch merge flow in `dotnet/versions` to have the currently-in-servicing branches: {{URL_OF_VERSIONS_PR}}
+- [ ]  Update the branch merge flow in `.config/git-merge-flow-config.jsonc` file to have the currently-in-servicing branches.
 - [ ]  Fix OptProf data flow for the new vs{{THIS_RELEASE_VERSION}} branch
-  - [ ] Manually run [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline for vs{{THIS_RELEASE_VERSION}} ('Run pipeline' in upper right)
-  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`) or alternatively with the latest Opt-Prof collected for the main branch (set `Optional OptProfDrop Override` to the drop path of the collected data, which could be found in the logs of the pipeline: Windows_NT -> Build -> search for `OptimizationData`). 
+  - [ ] Check that the [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline run is triggered for vs{{THIS_RELEASE_VERSION}}. If not, run manually ('Run pipeline' in upper right)
   - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} with no extra customization - OptProf should succeed now
-- [ ]  Create {{NEXT_VERSION}} branding PR (in main): {{URL_OF_NEXT_VERSION_BRANDING_PR}}
-- [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to add localization for {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
-https://ceapex.visualstudio.com/CEINTL/_workitems/edit/957875 (DONE)
+- [ ]  Create {{NEXT_VERSION}} branding PR (in main) including public API baseline package version change: {{URL_OF_NEXT_VERSION_BRANDING_PR}}. In the file `eng/Versions.props` Update the `VersionPrefix` to `{{NEXT_VERSION}}` and `PackageValidationBaselineVersion` set to a latest internally available {{THIS_RELEASE_VERSION}} preview version in the internal dnceng dotnet-tools feed. It might be needed to update `CompatibilitySuppressions.xml` files. See [this documentation](https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/overview) for more details. You can update `CompatibilitySuppressions.xml` files by running
+`dotnet pack MSBuild.Dev.slnf /p:ApiCompatGenerateSuppressionFile=true`. 
+- [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to switch localization from {{PREVIOUS_RELEASE_VERSION}} to {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
 - [ ]  Enable {{THIS_RELEASE_VERSION}} localization - by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{THIS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `true`
-- [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false` clarify with @JanKrivanek
+- [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false`. Update the comment on the same line.
 - [ ]  Merge {{NEXT_VERSION}} branding PR
-- [ ]  Create and merge PR including public API baseline package version change (see https://github.com/dotnet/msbuild/pull/8116#discussion_r1049386978): #8949
-- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, modify the VS insertion so that it flows from MSBuild main to VS main.
-- [ ]  Create {{PREVIOUS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to remove localization for {{PREVIOUS_RELEASE_VERSION}})
-{{URL_OF_LOCALIZATION_DISABLE_TICKET}}
-- [ ]  Remove MSBuild main from the experimental VS insertion flow.
+- [ ]  Create and merge a PR in main to update a localization version comment in setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/main/.vsts-dotnet.yml) to set up the merge conflict when this line will be updated in the release branch.
+- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, turn on / modify the VS insertion so that it flows from MSBuild main to VS main.
 - [ ]  Update the [release-branch insertion release definition](https://dev.azure.com/devdiv/DevDiv/_releaseDefinition?definitionId=2153&_a=definition-variables) to have `InsertTargetBranch` `rel/d{{THIS_RELEASE_VERSION}}`.
 - [ ]  Turn [the release pipeline](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) back on.
 - [ ]  Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}}
diff --git a/documentation/specs/proposed/BuildCheck-Architecture.md b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
similarity index 99%
rename from documentation/specs/proposed/BuildCheck-Architecture.md
rename to documentation/specs/BuildCheck/BuildCheck-Architecture.md
index 2e2a673e08c..017a25eafe4 100644
--- a/documentation/specs/proposed/BuildCheck-Architecture.md
+++ b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
@@ -51,7 +51,7 @@ One example of rich data that might be helpful for internal analyses is [`Projec
 
 ## Execution Modes
 
-**Replay Mode** - so that users can choose to perform analyses post build, without impacting the performance of the build. And so that some level of analysis can be run on artifacts from builds produced by older versions of MSBuild.
+**Replay Mode** - so that users can choose to perform analyses post build, without impacting the performance of the build. And so that some level of analysis can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
 
 **Live mode** - this is what users are used to from compilation analyses. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
 
diff --git a/documentation/specs/proposed/BuildCheck-feature-threat-model.md b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
similarity index 100%
rename from documentation/specs/proposed/BuildCheck-feature-threat-model.md
rename to documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
diff --git a/documentation/specs/proposed/BuildCheck.md b/documentation/specs/BuildCheck/BuildCheck.md
similarity index 99%
rename from documentation/specs/proposed/BuildCheck.md
rename to documentation/specs/BuildCheck/BuildCheck.md
index 4fa78061b78..ea5c4f80376 100644
--- a/documentation/specs/proposed/BuildCheck.md
+++ b/documentation/specs/BuildCheck/BuildCheck.md
@@ -75,15 +75,13 @@ Majority of following cases are included in appropriate context within the scena
 ```ini
 # I expect this to apply to all projects within my solution, but not to projects which are not part of the solution
 [ContosoFrontEnd.sln]
-build_check.BC0101.IsEnabled=true
 build_check.BC0101.Severity=warning
 ```
 * Attributing `.editorconfig` configurations to lower granularity than whole projects. E.g.:
 ```ini
 # I expect this to apply only to a scope of the imported file. Or possibly I expect this to apply to all projects importing this project.
 [ContosoCommonImport.proj]
-buildcheck.BC0101.IsEnabled=true
-buildcheck.BC0101.Severity=warning
+build_check.BC0101.Severity=warning
 ```
 * Respecting `.editorconfig` file in msbuild import locations (unless they are in the parent folders hierarchy of particular project file).
 * CodeFixes are not supported in V1
diff --git a/documentation/specs/proposed/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
similarity index 73%
rename from documentation/specs/proposed/BuildCheck/Codes.md
rename to documentation/specs/BuildCheck/Codes.md
index 329c03563dd..6698d20a2dc 100644
--- a/documentation/specs/proposed/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -7,6 +7,7 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 | 0 | Success |
 | [BC0101](#BC0101) | Shared output path. |
 | [BC0102](#BC0102) | Double writes. |
+| [BC0103](#BC0103) | Used environment variable. |
 
 
 To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview)
@@ -33,7 +34,14 @@ This is a similar problem as ['BC0101 - Shared output path'](#BC0101) - however
 
 If you want multiple tasks to update file in a one-by-one pipeline fashion, it is recommended to give each intermediate output a distinct name - preventing silent mixups if any of the tasks in the chain are skipped or removed.
 
+## <a name="BC0103"></a>BC0103 - Used environment variable.
 
+"Environment variables should not be used as a value source for the properties"
+
+Using environment variables as a data source in MSBuild is problematic and can lead to nondeterministic builds.
+Relying on environment variables introduces variability and unpredictability, as their values can change between builds or environments.
+
+This practice can result in inconsistent build outcomes and makes debugging difficult, since environment variables are external to project files and build scripts. To ensure consistent and reproducible builds, avoid using environment variables. Instead, explicitly pass properties using the /p option, which offers better control and traceability.
 
 <BR/>
 <BR/>
diff --git a/documentation/specs/proposed/BuildCheck/cross-node-remoted-data.png b/documentation/specs/BuildCheck/cross-node-remoted-data.png
similarity index 100%
rename from documentation/specs/proposed/BuildCheck/cross-node-remoted-data.png
rename to documentation/specs/BuildCheck/cross-node-remoted-data.png
diff --git a/documentation/specs/proposed/BuildCheck/in-node-direct-data.png b/documentation/specs/BuildCheck/in-node-direct-data.png
similarity index 100%
rename from documentation/specs/proposed/BuildCheck/in-node-direct-data.png
rename to documentation/specs/BuildCheck/in-node-direct-data.png
diff --git a/documentation/specs/proposed/interactive-package-references.md b/documentation/specs/BuildCheck/interactive-package-references.md
similarity index 100%
rename from documentation/specs/proposed/interactive-package-references.md
rename to documentation/specs/BuildCheck/interactive-package-references.md
diff --git a/documentation/specs/proposed/packagessourcing-control-flow.jpg b/documentation/specs/BuildCheck/packagessourcing-control-flow.jpg
similarity index 100%
rename from documentation/specs/proposed/packagessourcing-control-flow.jpg
rename to documentation/specs/BuildCheck/packagessourcing-control-flow.jpg
diff --git a/documentation/specs/proposed/security-metadata.md b/documentation/specs/BuildCheck/security-metadata.md
similarity index 100%
rename from documentation/specs/proposed/security-metadata.md
rename to documentation/specs/BuildCheck/security-metadata.md
diff --git a/documentation/specs/proposed/sourcing-vs-context.png b/documentation/specs/BuildCheck/sourcing-vs-context.png
similarity index 100%
rename from documentation/specs/proposed/sourcing-vs-context.png
rename to documentation/specs/BuildCheck/sourcing-vs-context.png
diff --git a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
new file mode 100644
index 00000000000..b92a45f36a4
--- /dev/null
+++ b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
@@ -0,0 +1,24 @@
+# BuildCheck - Perf and Acquisition Challenge
+
+This is an internal engineering document. For general overview and user-oriented information please refer to [BuildCheck - Design Spec](BuildCheck.md).
+
+# Challenge
+
+Let's recall some details of BuildCheck analyzers acquisition. There might be two types of the build analyzer: build-in and custom. 
+The build-in analyzers are configured in the `.editorconfig` file. The custom analyzers are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
+Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the analyzer is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the analyzer that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
+
+![analyzers-acquisition](analyzers-acquisition.png)
+
+There are two issues that arise from such a design:
+1. The configuration of the logging system should be ideally dependent on the set of the applied build analyzers. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the analyzers to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
+2. There is no synchronization between build manager and logging service. When the build check acquisition events get to the main node, most of the build might have been already finished on worker nodes.
+
+# Solution ideas
+
+- When analyzers are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
+- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom analysers we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
+- Change the initial confuguration of the logging system (in particular, forwardning loggers) during the build. 
+    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom analyzers in the worker node in order to find which events are needed for the custom analyzers. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
+    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the analyzers.  
+- As an addition the previous ideas, we may initialize the loggers from cache (either in-process cache or cache file in file system). We might have a strict mode which in case of cache miss invalidates and restarts a corresponding build.
diff --git a/documentation/specs/proposed/analyzers-acquisition.png b/documentation/specs/proposed/analyzers-acquisition.png
new file mode 100644
index 00000000000..865871d9c4a
Binary files /dev/null and b/documentation/specs/proposed/analyzers-acquisition.png differ
diff --git a/eng/Packages.props b/eng/Packages.props
index 6f4d99b91a9..e9c77ff48f9 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -19,6 +19,7 @@
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+    <PackageVersion Include="System.Formats.Asn1" Version="$(SystemFormatsAsn1Version)" />
     <PackageVersion Include="System.Memory" Version="$(SystemMemoryVersion)" />
     <PackageVersion Include="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageVersion Include="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 477458641a0..765f504dee0 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -8,14 +8,14 @@
     <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
     <UsagePattern IdentityGlob="System.Reflection.Metadata/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Resources.Extensions/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*8.0.3*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*8.0.4*" />
     <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
   </IgnorePatterns>
   <Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 37bf1602547..39ce47029a4 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,9 +2,9 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24257.2">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24367.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>6ed73280a6d70f7e7ac39c86f2abe8c10983f0bb</Sha>
+      <Sha>68d6cef51f1c82d71b435af0f040d72fdd1a782f</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
@@ -53,9 +53,9 @@
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
       <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="8.0.3">
+    <Dependency Name="System.Text.Json" Version="8.0.4">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>9f4b1f5d664afdfc80e1508ab7ed099dff210fbd</Sha>
+      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
     </Dependency>
     <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
@@ -65,6 +65,10 @@
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
       <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
+    <Dependency Name="System.Formats.Asn1" Version="8.0.1">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
+    </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
     <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24311.3">
@@ -91,9 +95,9 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>c0d441fc5e99e6765c9e0b2f77de162b9866b305</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.11.0-3.24329.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.11.0-3.24352.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>92051d4c24bc13ff58232104a647910bf22cd105</Sha>
+      <Sha>e6021ed45fa138501d126703ecd15d02a1ccc9c1</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24311.3">
diff --git a/eng/Versions.props b/eng/Versions.props
index 3e55bcad1c1..f040cfde8db 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -26,6 +26,7 @@
   <PropertyGroup>
     <SystemCollectionsImmutableVersion>8.0.0</SystemCollectionsImmutableVersion>
     <SystemConfigurationConfigurationManagerVersion>8.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemFormatsAsn1Version>8.0.1</SystemFormatsAsn1Version>
     <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
         When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
@@ -38,7 +39,7 @@
     <SystemResourcesExtensionsVersion>8.0.0</SystemResourcesExtensionsVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
-    <SystemTextJsonVersion>8.0.3</SystemTextJsonVersion>
+    <SystemTextJsonVersion>8.0.4</SystemTextJsonVersion>
     <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
     <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
@@ -50,8 +51,8 @@
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
     <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24311.3</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.11.0-3.24329.1</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.11.0-3.24352.5</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.11.0-rc.122</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
diff --git a/src/Build.UnitTests/BackEnd/BuildOMCompatibility_Tests.cs b/src/Build.UnitTests/BackEnd/BuildOMCompatibility_Tests.cs
new file mode 100644
index 00000000000..53a87ab27a7
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/BuildOMCompatibility_Tests.cs
@@ -0,0 +1,117 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Reflection;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Graph;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Engine.UnitTests.BackEnd
+{
+    public class BuildOMCompatibility_Tests
+    {
+        [Theory]
+        [InlineData("ProjectInstance")]
+        [InlineData("ProjectFullPath")]
+        [InlineData("TargetNames")]
+        [InlineData("Flags")]
+        [InlineData("GlobalProperties")]
+        [InlineData("ExplicitlySpecifiedToolsVersion")]
+        [InlineData("HostServices")]
+        [InlineData("PropertiesToTransfer")]
+        [InlineData("RequestedProjectState")]
+        public void BuildRequestDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildRequestData), propertyName);
+
+        [Theory]
+        [InlineData("ProjectGraph")]
+        [InlineData("ProjectGraphEntryPoints")]
+        [InlineData("TargetNames")]
+        [InlineData("Flags")]
+        [InlineData("GraphBuildOptions")]
+        [InlineData("HostServices")]
+        public void GraphBuildRequestDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(GraphBuildRequestData), propertyName);
+
+        [Theory]
+        [InlineData("BuildManager")]
+        [InlineData("SubmissionId")]
+        [InlineData("AsyncContext")]
+        [InlineData("WaitHandle")]
+        [InlineData("IsCompleted")]
+        [InlineData("BuildResult")]
+        public void BuildSubmissionDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildSubmission), propertyName);
+
+        [Theory]
+        [InlineData("Execute")]
+        [InlineData("ExecuteAsync")]
+        public void BuildSubmissionDataMethodCompatTest(string methodName)
+            => VerifyMethodExists(typeof(BuildSubmission), methodName);
+
+        [Theory]
+        [InlineData("BuildManager")]
+        [InlineData("SubmissionId")]
+        [InlineData("AsyncContext")]
+        [InlineData("WaitHandle")]
+        [InlineData("IsCompleted")]
+        [InlineData("BuildResult")]
+        public void GraphBuildSubmissionDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildSubmission), propertyName);
+
+        [Theory]
+        [InlineData("Execute")]
+        [InlineData("ExecuteAsync")]
+        public void GraphBuildSubmissionDataMethodCompatTest(string methodName)
+            => VerifyMethodExists(typeof(BuildSubmission), methodName);
+
+        [Theory]
+        [InlineData("SubmissionId")]
+        [InlineData("ConfigurationId")]
+        [InlineData("GlobalRequestId")]
+        [InlineData("ParentGlobalRequestId")]
+        [InlineData("NodeRequestId")]
+        [InlineData("Exception")]
+        [InlineData("CircularDependency")]
+        [InlineData("OverallResult")]
+        [InlineData("ResultsByTarget")]
+        [InlineData("ProjectStateAfterBuild")]
+        [InlineData("BuildRequestDataFlags")]
+        public void BuildResultPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildResult), propertyName);
+
+        [Theory]
+        [InlineData("AddResultsForTarget")]
+        [InlineData("MergeResults")]
+        [InlineData("HasResultsForTarget")]
+        public void BuildResultMethodCompatTest(string methodName)
+            => VerifyMethodExists(typeof(BuildResult), methodName);
+
+        [Theory]
+        [InlineData("SubmissionId")]
+        [InlineData("Exception")]
+        [InlineData("CircularDependency")]
+        [InlineData("OverallResult")]
+        [InlineData("ResultsByNode")]
+        public void GraphBuildResultPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(GraphBuildResult), propertyName);
+
+        private void VerifyPropertyExists(Type type, string propertyName)
+        {
+            type.GetProperty(
+                    propertyName,
+                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)
+                .ShouldNotBeNull();
+        }
+
+        private void VerifyMethodExists(Type type, string propertyName)
+        {
+            type.GetMethod(
+                    propertyName,
+                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)
+                .ShouldNotBeNull();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 67eba7e0b12..60c356dc515 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -73,7 +73,7 @@ public void VerifyEventType()
             PropertyReassignmentEventArgs propReassign = new("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal);
             ResponseFileUsedEventArgs responseFileUsed = new("path");
             UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
-            EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "help", "sender", MessageImportance.Normal);
+            EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "file", 0, 0);
             GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
@@ -251,7 +251,7 @@ public void TestTranslation()
                 {
                     new ResponseFileUsedEventArgs("path"),
                     new UninitializedPropertyReadEventArgs("prop", "message", "help", "sender", MessageImportance.Normal),
-                    new EnvironmentVariableReadEventArgs("env", "message", "help", "sender", MessageImportance.Normal) { BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6) },
+                    new EnvironmentVariableReadEventArgs("env", "message", "file", 0, 0) { BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6) },
                     new PropertyReassignmentEventArgs("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal),
                     new PropertyInitialValueSetEventArgs("prop", "val", "propsource", "message", "help", "sender", MessageImportance.Normal),
                     new MetaprojectGeneratedEventArgs("metaName", "path", "message"),
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index ac421399121..7fc43eccc59 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -383,6 +383,7 @@ public static IEnumerable<object[]> CacheSerializationTestData
             }
         }
 
+        // Serialize latest version and deserialize latest version of the cache
         [Theory]
         [MemberData(nameof(CacheSerializationTestData))]
         public void TestResultsCacheTranslation(object obj)
@@ -393,12 +394,49 @@ public void TestResultsCacheTranslation(object obj)
 
             var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());
 
-            copy.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();
+            CompareResultsCache(resultsCache, copy);
+        }
+
+        [Theory]
+        [InlineData(1, 1)] // Serialize version 0 and deserialize version 0 
+        [InlineData(1, 0)] // Serialize version 0 and deserialize latest version
+        public void TestResultsCacheTranslationAcrossVersions(int envValue1, int envValue2)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MSBUILDDONOTVERSIONBUILDRESULT", $"{envValue1}");
+
+                // Create a ResultsCache
+                var request1 = new BuildRequest(1, 2, 3, new[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request2 = new BuildRequest(4, 5, 6, new[] { "target2" }, null, BuildEventContext.Invalid, null);
+
+                var br1 = new BuildResult(request1);
+                var br2 = new BuildResult(request2);
+                br2.AddResultsForTarget("target2", BuildResultUtilities.GetEmptyFailingTargetResult());
+
+                var resultsCache = new ResultsCache();
+                resultsCache.AddResult(br1.Clone());
+                resultsCache.AddResult(br2.Clone());
+
+                resultsCache.Translate(TranslationHelpers.GetWriteTranslator());
+
+                env.SetEnvironmentVariable("MSBUILDDONOTVERSIONBUILDRESULT", $"{envValue2}");
+                Traits.UpdateFromEnvironment();
+
+                var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());
+
+                CompareResultsCache(resultsCache, copy);
+            }
+        }
+
+        private void CompareResultsCache(ResultsCache resultsCache1, ResultsCache resultsCache2)
+        {
+            resultsCache2.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache1.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();
 
-            foreach (var configId in copy.ResultsDictionary.Keys)
+            foreach (var configId in resultsCache2.ResultsDictionary.Keys)
             {
-                var copiedBuildResult = copy.ResultsDictionary[configId];
-                var initialBuildResult = resultsCache.ResultsDictionary[configId];
+                var copiedBuildResult = resultsCache2.ResultsDictionary[configId];
+                var initialBuildResult = resultsCache1.ResultsDictionary[configId];
 
                 copiedBuildResult.SubmissionId.ShouldBe(initialBuildResult.SubmissionId);
                 copiedBuildResult.ConfigurationId.ShouldBe(initialBuildResult.ConfigurationId);
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 656f906ccfa..7f855ca0350 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -209,7 +209,7 @@ public void RoundtripTaskStartedEventArgs()
         [Fact]
         public void RoundtripEnvironmentVariableReadEventArgs()
         {
-            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue");
+            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue", "file", 10, 20);
             args.BuildEventContext = new BuildEventContext(4, 5, 6, 7);
             Roundtrip(args,
                 e => e.Message,
@@ -800,22 +800,6 @@ public void RoundtripTargetSkippedEventArgs()
                 e => e.OriginallySucceeded.ToString());
         }
 
-        [Fact]
-        public void RoundTripEnvironmentVariableReadEventArgs()
-        {
-            var args = new EnvironmentVariableReadEventArgs(
-                environmentVariableName: Guid.NewGuid().ToString(),
-                message: Guid.NewGuid().ToString(),
-                helpKeyword: Guid.NewGuid().ToString(),
-                senderName: Guid.NewGuid().ToString());
-
-            Roundtrip(args,
-                e => e.EnvironmentVariableName,
-                e => e.Message,
-                e => e.HelpKeyword,
-                e => e.SenderName);
-        }
-
         [Fact]
         public void RoundTripPropertyReassignmentEventArgs()
         {
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 64c352cd512..3fd8d86a18a 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -21,7 +21,6 @@
 using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
@@ -51,6 +50,23 @@ public void Dispose()
             GC.Collect();
         }
 
+        [Fact]
+        public void EnsureProjectEvaluationFinishedIsLogged()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile projectFile = env.CreateFile("project.proj", $@"
+<Project Sdk=""Microsoft.NETT.Sdk"">
+  <Target Name=""DefaultTarget"">
+  </Target>
+</Project>
+");
+
+            MockLogger logger = new();
+            using ProjectCollection collection = new(new Dictionary<string, string>(), [logger], ToolsetDefinitionLocations.Default);
+            Assert.Throws<InvalidProjectFileException>(() => collection.LoadProject(projectFile.Path));
+            logger.EvaluationFinishedEvents.ShouldNotBeEmpty();
+        }
+
         [Theory]
         [MemberData(nameof(ImportLoadingScenarioTestData))]
         public void VerifyLoadingImportScenarios(string importParameter, bool shouldSucceed)
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 25187464656..61fc11171d9 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1294,6 +1294,39 @@ public void StaticMethodErrorMessageHaveMethodName1()
 
             Assert.True(false);
         }
+
+        [Fact]
+        public void StaticMethodWithThrowawayParameterSupported()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.Int32]::TryParse(""3"", _))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is True");
+        }
+
+        [Fact]
+        public void StaticMethodWithThrowawayParameterSupported2()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.Int32]::TryParse(""notANumber"", _))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is False");
+        }
+
         /// <summary>
         /// Creates a set of complicated item metadata and properties, and items to exercise
         /// the Expander class.  The data here contains escaped characters, metadata that
@@ -5064,6 +5097,41 @@ public void GetTypeMethod_ShouldBeAllowed_EnabledByEnvVariable(string methodName
             }
         }
 
+        [Theory]
+        [InlineData("$([System.Version]::Parse('17.12.11.10').ToString(2))")]
+        [InlineData("$([System.Text.RegularExpressions.Regex]::Replace('abc123def', 'abc', ''))")]
+        [InlineData("$([System.String]::new('Hi').Equals('Hello'))")]
+        [InlineData("$([System.IO.Path]::GetFileNameWithoutExtension('C:\\folder\\file.txt'))")]
+        [InlineData("$([System.Int32]::new(123).ToString('mm')")]
+        [InlineData("$([Microsoft.Build.Evaluation.IntrinsicFunctions]::NormalizeDirectory('C:/folder1/./folder2/'))")]
+        [InlineData("$([Microsoft.Build.Evaluation.IntrinsicFunctions]::IsOSPlatform('Windows'))")]
+        public void FastPathValidationTest(string methodInvocationMetadata)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                // Setting this env variable allows to track if expander was using reflection for a function invocation. 
+                env.SetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection", "1");
+
+                var logger = new MockLogger();
+                ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+                loggingService.RegisterLogger(logger);
+                var loggingContext = new MockLoggingContext(
+                    loggingService,
+                    new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
+
+                _ = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                    new PropertyDictionary<ProjectPropertyInstance>(),
+                    FileSystems.Default,
+                    loggingContext)
+                    .ExpandIntoStringLeaveEscaped(methodInvocationMetadata, ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+
+                string reflectionInfoPath = Path.Combine(Directory.GetCurrentDirectory(), "PropertyFunctionsRequiringReflection");
+
+                // the fast path was successfully resolved without reflection.
+                File.Exists(reflectionInfoPath).ShouldBeFalse();
+            }
+        }
+
         /// <summary>
         /// Determines if ICU mode is enabled.
         /// Copied from: https://learn.microsoft.com/en-us/dotnet/core/extensions/globalization-icu#determine-if-your-app-is-using-icu
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 510498ed694..b9a221afbd9 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -301,5 +301,18 @@ internal override BuildSubmissionBase<BuildRequestData, BuildResult> CreateSubmi
         /// <inheritdoc cref="BuildRequestDataBase"/>
         public override IReadOnlyDictionary<string, string?> GlobalPropertiesLookup => _globalPropertiesLookup ??=
             Execution.GlobalPropertiesLookup.ToGlobalPropertiesLookup(GlobalPropertiesDictionary);
+
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
+
+        /// <inheritdoc cref="BuildRequestDataBase.TargetNames"/>
+        public new ICollection<string> TargetNames => base.TargetNames;
+
+        /// <inheritdoc cref="BuildRequestDataBase.Flags"/>
+        public new BuildRequestDataFlags Flags => base.Flags;
+
+        /// <inheritdoc cref="BuildRequestDataBase.HostServices"/>
+        public new HostServices? HostServices => base.HostServices;
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 77def07e7bb..e96185fc640 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -78,14 +78,15 @@ private protected void ExecuteAsync(
         internal void CompleteResults(TResultData result)
         {
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
-            ErrorUtilities.VerifyThrow(result.SubmissionId == SubmissionId,
-                "GraphBuildResult's submission id doesn't match GraphBuildSubmission's");
+            CheckResultValidForCompletion(result);
 
             BuildResult ??= result;
 
             CheckForCompletion();
         }
 
+        protected internal abstract void CheckResultValidForCompletion(TResultData result);
+
         protected internal abstract TResultData CreateFailedResult(Exception exception);
 
         internal override BuildResultBase CompleteResultsWithException(Exception exception)
@@ -207,7 +208,19 @@ protected internal override BuildResult CreateFailedResult(Exception exception)
                 "BuildRequest is not populated while reporting failed result.");
             return new(BuildRequest!, exception);
         }
-        
+
+        protected internal override void CheckResultValidForCompletion(BuildResult result)
+        {
+            // We verify that we got results from the same configuration, but not necessarily the same request, because we are
+            // rather flexible in how users are allowed to submit multiple requests for the same configuration.  In this case, the
+            // request id of the result will match the first request, even though it will contain results for all requests (including
+            // this one.)
+            if (result.ConfigurationId != BuildRequest?.ConfigurationId)
+            {
+                ErrorUtilities.ThrowInternalError("BuildResult configuration ({0}) doesn't match BuildRequest configuration ({1})",
+                    result.ConfigurationId, BuildRequest?.ConfigurationId);
+            }
+        }
 
         protected internal override void OnCompletition()
         {
@@ -219,5 +232,27 @@ protected internal override void OnCompletition()
                 BuildResult.SetOverallResult(overallResult: false);
             }
         }
+
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
+
+        /// <inheritdoc cref="BuildSubmissionBase{BuildRequestData, BuildResult}.BuildResult"/>
+        public new BuildResult? BuildResult => base.BuildResult;
+
+        /// <inheritdoc cref="BuildSubmissionBase.BuildManager"/>
+        public new BuildManager BuildManager => base.BuildManager;
+
+        /// <inheritdoc cref="BuildSubmissionBase.SubmissionId"/>
+        public new int SubmissionId => base.SubmissionId;
+
+        /// <inheritdoc cref="BuildSubmissionBase.AsyncContext"/>
+        public new object? AsyncContext => base.AsyncContext;
+
+        /// <inheritdoc cref="BuildSubmissionBase.WaitHandle"/>
+        public new WaitHandle WaitHandle => base.WaitHandle;
+
+        /// <inheritdoc cref="BuildSubmissionBase.IsCompleted"/>
+        public new bool IsCompleted => base.IsCompleted;
     }
 }
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 34480ff2142..e34dd90c5b1 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -350,9 +350,14 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
         /// <param name="buildResult">The candidate build result.</param>
         /// <returns>True if the flags and project state filter of the build request is compatible with the build result.</returns>
         private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, BuildResult buildResult)
-        {
+        { 
+            if (buildResult.BuildRequestDataFlags is null)
+            {
+                return true;
+            }
+
             BuildRequestDataFlags buildRequestDataFlags = buildRequest.BuildRequestDataFlags;
-            BuildRequestDataFlags buildResultDataFlags = buildResult.BuildRequestDataFlags;
+            BuildRequestDataFlags buildResultDataFlags = (BuildRequestDataFlags) buildResult.BuildRequestDataFlags;
 
             if ((buildRequestDataFlags & FlagsAffectingBuildResults) != (buildResultDataFlags & FlagsAffectingBuildResults))
             {
diff --git a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
index 387b4db9841..7577db70433 100644
--- a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
@@ -59,7 +59,7 @@ public bool IsInProcNode
         /// <param name="taskName">The task in which the error occurred</param>
         internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, string taskName)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogFatalTaskError(BuildEventContext, exception, file, taskName);
             _hasLoggedErrors = true;
         }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index a8bd09069fb..e06b2a85864 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -124,7 +124,7 @@ protected set
         /// <param name="messageArgs">string resource arguments</param>
         internal void LogComment(MessageImportance importance, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogComment(_eventContext, importance, messageResourceName, messageArgs);
         }
 
@@ -137,7 +137,7 @@ internal void LogComment(MessageImportance importance, string messageResourceNam
         /// <param name="messageArgs">string resource arguments</param>
         internal void LogComment(MessageImportance importance, BuildEventFileInfo file, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
 
             _loggingService.LogBuildEvent(new BuildMessageEventArgs(
                 null,
@@ -165,7 +165,7 @@ internal void LogComment(MessageImportance importance, BuildEventFileInfo file,
         /// <param name="message">message to log</param>
         internal void LogCommentFromText(MessageImportance importance, string message)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogCommentFromText(_eventContext, importance, message);
         }
 
@@ -177,7 +177,7 @@ internal void LogCommentFromText(MessageImportance importance, string message)
         /// <param name="messageArgs">Format string arguments</param>
         internal void LogCommentFromText(MessageImportance importance, string message, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogCommentFromText(_eventContext, importance, message, messageArgs);
         }
 
@@ -189,7 +189,7 @@ internal void LogCommentFromText(MessageImportance importance, string message, p
         /// <param name="messageArgs">Parameters for the resource string</param>
         internal void LogError(BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogError(_eventContext, file, messageResourceName, messageArgs);
             _hasLoggedErrors = true;
         }
@@ -203,7 +203,7 @@ internal void LogError(BuildEventFileInfo file, string messageResourceName, para
         /// <param name="messageArgs">Parameters for the resource string</param>
         internal void LogErrorWithSubcategory(string? subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogError(_eventContext, subcategoryResourceName, file, messageResourceName, messageArgs);
             _hasLoggedErrors = true;
         }
@@ -218,7 +218,7 @@ internal void LogErrorWithSubcategory(string? subcategoryResourceName, BuildEven
         /// <param name="message">Error message</param>
         internal void LogErrorFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogErrorFromText(_eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
             _hasLoggedErrors = true;
         }
@@ -229,7 +229,7 @@ internal void LogErrorFromText(string? subcategoryResourceName, string? errorCod
         /// <param name="invalidProjectFileException">The invalid Project File Exception which is to be logged</param>
         internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProjectFileException)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogInvalidProjectFileError(_eventContext, invalidProjectFileException);
             _hasLoggedErrors = true;
         }
@@ -243,14 +243,14 @@ internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProj
         /// <param name="messageArgs">The arguments for the error message</param>
         internal void LogFatalError(Exception exception, BuildEventFileInfo file, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogFatalError(_eventContext, exception, file, messageResourceName, messageArgs);
             _hasLoggedErrors = true;
         }
 
         internal void LogWarning(string messageResourceName, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogWarning(_eventContext, null, BuildEventFileInfo.Empty, messageResourceName, messageArgs);
         }
 
@@ -263,7 +263,7 @@ internal void LogWarning(string messageResourceName, params object[] messageArgs
         /// <param name="messageArgs">parameters for the string resource</param>
         internal void LogWarning(string? subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogWarning(_eventContext, subcategoryResourceName, file, messageResourceName, messageArgs);
         }
 
@@ -277,7 +277,7 @@ internal void LogWarning(string? subcategoryResourceName, BuildEventFileInfo fil
         /// <param name="message">The message to be logged as a warning</param>
         internal void LogWarningFromText(string? subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogWarningFromText(_eventContext, subcategoryResourceName, warningCode, helpKeyword, file, message);
         }
 
@@ -287,7 +287,7 @@ internal void LogWarningFromText(string? subcategoryResourceName, string warning
         /// <param name="buildEvent">The event to log</param>
         internal void LogBuildEvent(BuildEventArgs buildEvent)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogBuildEvent(buildEvent);
         }
 
@@ -298,7 +298,7 @@ internal void LogBuildEvent(BuildEventArgs buildEvent)
         /// <param name="file">The file in which the error occurred</param>
         internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogFatalBuildError(BuildEventContext, exception, file);
             _hasLoggedErrors = true;
         }
@@ -309,7 +309,7 @@ internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         /// <param name="filePath">Path to response file</param>
         internal void LogIncludeFile(string filePath)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             _loggingService.LogIncludeFile(BuildEventContext, filePath);
         }
 
@@ -322,5 +322,14 @@ public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo)
             => _loggingService.BuildEngineDataRouter.ProcessPropertyWrite(
                     propertyWriteInfo,
                     new AnalysisLoggingContext(_loggingService, BuildEventContext));
+
+        private protected void CheckValidity()
+        {
+            if (!_isValid)
+            {
+                ErrorUtilities.ThrowInternalError("LoggingContext (type: {0}) was not valid during logging attempt.",
+                    this.GetType());
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 8cbf643802e..aa34bd3cafa 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using Microsoft.Build.Experimental.BuildCheck;
 
 #nullable disable
 
@@ -1597,6 +1598,12 @@ private void RouteBuildEvent(object loggingEvent)
                 _buildSubmissionIdsThatHaveLoggedErrors.Add(errorEvent.BuildEventContext?.SubmissionId ?? BuildEventContext.InvalidSubmissionId);
             }
 
+            if (buildEventArgs is BuildCheckResultError checkResultError)
+            {
+                // If the specified BuildCheckResultError was issued, an empty ISet<string> signifies that the specified build check warnings should be treated as errors.
+                AddWarningsAsErrors(checkResultError.BuildEventContext, new HashSet<string>());
+            }
+
             if (buildEventArgs is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
             {
                 WarningsConfigKey key = GetWarningsConfigKey(projectFinishedEvent);
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 79c24fd6668..d68f04e2bfa 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -101,7 +101,7 @@ internal ProjectTargetInstance Target
         /// </summary>
         internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnumerable<TaskItem> targetOutputs)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "Should be valid");
+            this.CheckValidity();
 
             TargetOutputItemsInstanceEnumeratorProxy targetOutputWrapper = null;
 
@@ -120,7 +120,7 @@ internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnum
         /// </summary>
         internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "Should be valid");
+            this.CheckValidity();
 
             return new TaskLoggingContext(this, projectFullPath, task, taskAssemblyLocation);
         }
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index 33016e59e9b..43d668805e4 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -147,7 +147,7 @@ internal void LogTaskBatchFinished(string projectFullPath, bool success)
         /// <param name="taskName">The task in which the warning occurred</param>
         internal void LogTaskWarningFromException(Exception exception, BuildEventFileInfo file, string taskName)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogTaskWarningFromException(BuildEventContext, exception, file, taskName);
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 14150696614..8835f4278ca 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -171,7 +171,9 @@ private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs a
             if (_loggingContext?.BuildEventContext != null)
             {
                 buildArgs.BuildEventContext = _loggingContext.BuildEventContext;
-                _loggingContext.LogBuildEvent(buildArgs);
+                // bypass the logging context validity check: it's possible that the load happened
+                // on a thread unrelated to the context we're tracking loads in
+                _loggingContext.LoggingService.LogBuildEvent(buildArgs);
             }
             _loggingService?.LogBuildEvent(buildArgs);
         }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 56458bc630c..776179d0f03 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Execution
 {
@@ -31,6 +32,9 @@ public enum BuildResultCode
     /// <summary>
     /// Contains the current results for all of the targets which have produced results for a particular configuration.
     /// </summary>
+    /// <remarks>
+    /// When modifying serialization/deserialization, bump the version and support previous versions in order to keep <see cref="ResultsCache"/> backwards compatible.
+    /// </remarks>
     public class BuildResult : BuildResultBase, INodePacket, IBuildResults
     {
         /// <summary>
@@ -75,6 +79,14 @@ public class BuildResult : BuildResultBase, INodePacket, IBuildResults
         /// </summary>
         private ConcurrentDictionary<string, TargetResult> _resultsByTarget;
 
+        /// <summary>
+        /// Version of the build result.
+        /// </summary>
+        /// <remarks>
+        /// Allows to serialize and deserialize different versions of the build result.
+        /// </remarks>
+        private int _version = Traits.Instance.EscapeHatches.DoNotVersionBuildResult ? 0 : 1;
+
         /// <summary>
         /// The request caused a circular dependency in scheduling.
         /// </summary>
@@ -98,6 +110,16 @@ public class BuildResult : BuildResultBase, INodePacket, IBuildResults
         /// </summary>
         private Dictionary<string, string>? _savedEnvironmentVariables;
 
+        /// <summary>
+        /// When this key is in the dictionary <see cref="_savedEnvironmentVariables"/>, serialize the build result version.
+        /// </summary>
+        private const string SpecialKeyForVersion = "=MSBUILDFEATUREBUILDRESULTHASVERSION=";
+
+        /// <summary>
+        /// Set of additional keys tat might be added to the dictionary <see cref="_savedEnvironmentVariables"/>.
+        /// </summary>
+        private static readonly HashSet<string> s_additionalEntriesKeys = new HashSet<string> { SpecialKeyForVersion };
+
         /// <summary>
         /// Snapshot of the current directory from the configuration this result comes from.
         /// This should only be populated when the configuration for this result is moved between nodes.
@@ -117,6 +139,9 @@ public class BuildResult : BuildResultBase, INodePacket, IBuildResults
         /// <summary>
         /// The flags provide additional control over the build results and may affect the cached value.
         /// </summary>
+        /// <remarks>
+        /// Is optional, the field is expected to be present starting <see cref="_version"/> 1.
+        /// </remarks>
         private BuildRequestDataFlags _buildRequestDataFlags;
 
         private string? _schedulerInducedError;
@@ -395,7 +420,10 @@ public ProjectInstance? ProjectStateAfterBuild
         /// Gets the flags that were used in the build request to which these results are associated.
         /// See <see cref="Execution.BuildRequestDataFlags"/> for examples of the available flags.
         /// </summary>
-        public BuildRequestDataFlags BuildRequestDataFlags => _buildRequestDataFlags;
+        /// <remarks>
+        /// Is optional, this property exists starting <see cref="_version"/> 1.
+        /// </remarks>
+        public BuildRequestDataFlags? BuildRequestDataFlags => (_version > 0) ? _buildRequestDataFlags : null;
 
         /// <summary>
         /// Returns the node packet type.
@@ -597,8 +625,62 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);
             translator.Translate(ref _savedCurrentDirectory);
             translator.Translate(ref _schedulerInducedError);
-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
+
+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208
+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.
+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.
+            //
+            // 1st step (done): Add a special key to the _savedEnvironmentVariables dictionary during the serialization. A workaround overload of the TranslateDictionary function is created to achieve it.
+            // The presence of this key will indicate that the version is serialized next.
+            // When serializing, add a key to the dictionary and serialize a version field.
+            // Do not actually save the special key to dictionary during the deserialization, but read a version as a next field if it presents.
+            //
+            // 2nd step: Stop serialize a special key with the dictionary _savedEnvironmentVariables using the TranslateDictionary function workaround overload. Always serialize and de-serialize the version field.
+            // Continue to deserialize _savedEnvironmentVariables with the TranslateDictionary function workaround overload in order not to deserialize dictionary with the special keys.
+            //
+            // 3rd step: Stop using the TranslateDictionary function workaround overload during _savedEnvironmentVariables deserialization.
+            if (_version == 0)
+            {
+                // Escape hatch: serialize/deserialize without version field.
+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
+            }
+            else
+            {
+                Dictionary<string, string> additionalEntries = new();
+
+                if (translator.Mode == TranslationDirection.WriteToStream)
+                {
+                    // Add the special key SpecialKeyForVersion to additional entries indicating the presence of a version to the _savedEnvironmentVariables dictionary.
+                    additionalEntries.Add(SpecialKeyForVersion, String.Empty);
+
+                    // Serialize the special key together with _savedEnvironmentVariables dictionary using the workaround overload of TranslateDictionary:
+                    translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase, ref additionalEntries, s_additionalEntriesKeys);
+
+                    // Serialize version
+                    translator.Translate(ref _version);
+                }
+                else if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    // Read the dictionary using the workaround overload of TranslateDictionary: special keys (additionalEntriesKeys) would be read to additionalEntries instead of the _savedEnvironmentVariables dictionary.
+                    translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase, ref additionalEntries, s_additionalEntriesKeys);
+
+                    // If the special key SpecialKeyForVersion present in additionalEntries, also read a version, otherwise set it to 0.
+                    if (additionalEntries is not null && additionalEntries.ContainsKey(SpecialKeyForVersion))
+                    {
+                        translator.Translate(ref _version);
+                    }
+                    else
+                    {
+                        _version = 0;
+                    }
+                }
+            }
+
+            // Starting version 1 this _buildRequestDataFlags field is present.
+            if (_version > 0)
+            {
+                translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
index ab817077725..f36ff6a0f3c 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
@@ -21,8 +21,7 @@ public class BuildAnalyzerConfiguration
     public static BuildAnalyzerConfiguration Default { get; } = new()
     {
         EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectOnly,
-        Severity = BuildAnalyzerResultSeverity.Info,
-        IsEnabled = false,
+        Severity = BuildAnalyzerResultSeverity.None
     };
 
     public static BuildAnalyzerConfiguration Null { get; } = new();
@@ -45,7 +44,18 @@ public class BuildAnalyzerConfiguration
     /// If all rules within the analyzer are not enabled, it will not be run.
     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
     /// </summary>
-    public bool? IsEnabled { get; internal init; }
+    public bool? IsEnabled {
+        get
+        {
+            // Do not consider Default as enabled, because the default severity of the rule coule be set to None
+            if (Severity.HasValue && Severity.Value != BuildAnalyzerResultSeverity.Default)
+            {
+                return !Severity.Value.Equals(BuildAnalyzerResultSeverity.None);
+            }
+
+            return null;
+        }
+    }
 
     /// <summary>
     /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
@@ -59,8 +69,7 @@ internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? co
         return new()
         {
             EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,
-            Severity = TryExtractValue(nameof(Severity), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,
-            IsEnabled = TryExtractValue(nameof(IsEnabled), configDictionary, out bool isEnabled) ? isEnabled : null,
+            Severity = TryExtractValue(nameof(Severity), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null
         };
     }
 
@@ -83,31 +92,6 @@ private static bool TryExtractValue<T>(string key, Dictionary<string, string>? c
         return isParsed;
     }
 
-    private static bool TryExtractValue(string key, Dictionary<string, string>? config, out bool value)
-    {
-        value = default;
-
-        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
-        {
-            return false;
-        }
-
-        bool isParsed = false;
-        
-        if (bool.TryParse(stringValue, out bool boolValue))
-        {
-            value = boolValue;
-            isParsed = true;
-        }
-        
-        if (!isParsed)
-        {
-            ThrowIncorrectValueException(key, stringValue);
-        }
-
-        return isParsed;
-    }
-
     private static void ThrowIncorrectValueException(string key, string value)
     {
         // TODO: It will be nice to have the filename where the incorrect configuration was placed. 
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs b/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
index 412a014be06..cd98bdbbf22 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
@@ -8,7 +8,28 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// </summary>
 public enum BuildAnalyzerResultSeverity
 {
-    Info,
+    /// <summary>
+    /// When set, the default value of the BuildCheck rule will be used.
+    /// </summary>
+    Default,
+
+    /// <summary>
+    /// When set to None the rule will not run.
+    /// </summary>
+    None,
+
+    /// <summary>
+    /// Information level message.
+    /// </summary>
+    Suggestion,
+
+    /// <summary>
+    /// Results a warning in build if the BuildCheck rule applied.
+    /// </summary>
     Warning,
-    Error,
+
+    /// <summary>
+    /// Results an error in build if the BuildCheck rule applied.
+    /// </summary>
+    Error
 }
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index f6b54e1ed99..b6cb67e7d56 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -31,9 +31,9 @@ public BuildCheckResult(BuildAnalyzerRule buildAnalyzerRule, ElementLocation loc
     internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
         => severity switch
         {
-            BuildAnalyzerResultSeverity.Info => new BuildCheckResultMessage(this),
-            BuildAnalyzerResultSeverity.Warning => new BuildCheckResultWarning(this),
-            BuildAnalyzerResultSeverity.Error => new BuildCheckResultError(this),
+            BuildAnalyzerResultSeverity.Suggestion => new BuildCheckResultMessage(this),
+            BuildAnalyzerResultSeverity.Warning => new BuildCheckResultWarning(this, BuildAnalyzerRule.Id),
+            BuildAnalyzerResultSeverity.Error => new BuildCheckResultError(this, BuildAnalyzerRule.Id),
             _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
         };
 
@@ -51,7 +51,7 @@ internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
 
     // Here we will provide different link for built-in rules and custom rules - once we have the base classes differentiated.
     public string FormatMessage() =>
-        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}{BuildAnalyzerRule.Id}: https://aka.ms/buildcheck/codes#{BuildAnalyzerRule.Id} - {string.Format(BuildAnalyzerRule.MessageFormat, MessageArgs)}";
+        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{BuildAnalyzerRule.Id} - {string.Format(BuildAnalyzerRule.MessageFormat, MessageArgs)}";
 
     private string? _message;
 }
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
index d8ad5a396ef..b34ab8f726b 100644
--- a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -8,6 +8,8 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 public interface IBuildCheckRegistrationContext
 {
     void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+
     void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+
     void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction);
 }
diff --git a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs b/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
index e5fc6b22cfd..0804d6d76c3 100644
--- a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
+++ b/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
@@ -20,10 +20,12 @@ namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
 
 internal sealed class DoubleWritesAnalyzer : BuildAnalyzer
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0102", "DoubleWrites",
+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        "BC0102",
+        "DoubleWrites",
         "Two tasks should not write the same file",
         "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.DoubleWritesAnalyzer";
 
diff --git a/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs b/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
new file mode 100644
index 00000000000..6c3cd071d7b
--- /dev/null
+++ b/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
@@ -0,0 +1,84 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+
+internal sealed class NoEnvironmentVariablePropertyAnalyzer : BuildAnalyzer
+{
+    /// <summary>
+    /// Contains the list of reported environment variables.
+    /// </summary>
+    private readonly HashSet<EnvironmentVariableIdentityKey> _environmentVariablesReported = new HashSet<EnvironmentVariableIdentityKey>();
+
+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        "BC0103",
+        "NoEnvironmentVariablePropertyAnalyzer",
+        "No implicit property derived from an environment variable should be used during the build",
+        "Property is derived from environment variable: '{0}' with value: '{1}'. Properties should be passed explicitly using the /p option.",
+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Suggestion });
+
+    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyAnalyzer";
+
+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        // No custom configuration
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);
+
+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    {
+        if (context.Data.EvaluatedEnvironmentVariables.Count != 0)
+        {
+            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)
+            {
+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);
+                if (!_environmentVariablesReported.Contains(identityKey))
+                {
+                    context.ReportResult(BuildCheckResult.Create(
+                        SupportedRule,
+                        ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),
+                        envVariableData.Key,
+                        envVariableData.Value.EnvVarValue));
+
+                    _environmentVariablesReported.Add(identityKey);
+                }
+            }
+        }
+    }
+
+    internal class EnvironmentVariableIdentityKey(string environmentVariableName, string file, int line, int column) : IEquatable<EnvironmentVariableIdentityKey>
+    {
+        public string EnvironmentVariableName { get; } = environmentVariableName;
+
+        public string File { get; } = file;
+
+        public int Line { get; } = line;
+
+        public int Column { get; } = column;
+
+        public override bool Equals(object? obj) => Equals(obj as EnvironmentVariableIdentityKey);
+
+        public bool Equals(EnvironmentVariableIdentityKey? other) =>
+            other != null &&
+            EnvironmentVariableName == other.EnvironmentVariableName &&
+            File == other.File &&
+            Line == other.Line &&
+            Column == other.Column;
+
+        public override int GetHashCode()
+        {
+            int hashCode = 17;
+            hashCode = hashCode * 31 + (File != null ? File.GetHashCode() : 0);
+            hashCode = hashCode * 31 + Line.GetHashCode();
+            hashCode = hashCode * 31 + Column.GetHashCode();
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
index 74d0ba579a9..5da98f08463 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
@@ -18,7 +18,7 @@ internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
     public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0101", "ConflictingOutputPath",
         "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
         "Projects {0} and {1} have conflicting output paths: {2}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
index 9d7738922e7..b5ecb7c3f48 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
@@ -1,6 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using Microsoft.Build.Experimental.BuildCheck;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
@@ -10,18 +11,25 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// </summary>
 internal sealed class BuildAnalyzerConfigurationInternal
 {
-    public BuildAnalyzerConfigurationInternal(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity, bool isEnabled)
+    public BuildAnalyzerConfigurationInternal(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity)
     {
+        if (severity == BuildAnalyzerResultSeverity.Default)
+        {
+            throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
+        }
+
         RuleId = ruleId;
         EvaluationAnalysisScope = evaluationAnalysisScope;
         Severity = severity;
-        IsEnabled = isEnabled;
     }
 
     public string RuleId { get; }
+
     public EvaluationAnalysisScope EvaluationAnalysisScope { get; }
+
     public BuildAnalyzerResultSeverity Severity { get; }
-    public bool IsEnabled { get; }
+
+    public bool IsEnabled => Severity >= BuildAnalyzerResultSeverity.Suggestion;
 
     // Intentionally not checking the RuleId
     //  as for analyzers with multiple rules, we can squash config to a single one,
@@ -29,6 +37,5 @@ public BuildAnalyzerConfigurationInternal(string ruleId, EvaluationAnalysisScope
     public bool IsSameConfigurationAs(BuildAnalyzerConfigurationInternal? other) =>
         other != null &&
         Severity == other.Severity &&
-        IsEnabled == other.IsEnabled &&
         EvaluationAnalysisScope == other.EvaluationAnalysisScope;
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index 75dd0930d0e..c872f4673f3 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -31,6 +31,7 @@ internal BuildCheckBuildEventHandler(
         {
             { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
             { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
+            { typeof(EnvironmentVariableReadEventArgs), (BuildEventArgs e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
             { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
             { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
             { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
@@ -107,6 +108,11 @@ private void HandleBuildCheckAcquisitionEvent(BuildCheckAcquisitionEventArgs eve
                 eventArgs.ToAnalyzerAcquisitionData(),
                 _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
 
+    private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs eventArgs)
+        => _buildCheckManager.ProcessEnvironmentVariableReadEventArgs(
+                _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)),
+                eventArgs);
+
     private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
 
     private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 0ae82410400..ef101011a1f 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -46,7 +46,9 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
     // This we can potentially use to subscribe for receiving evaluated props in the
     //  build event args. However - this needs to be done early on, when analyzers might not be known yet
     internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Count > 0;
+
     internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Count > 0;
+
     internal bool HasTaskInvocationActions => _globalCallbacks.TaskInvocationActions.Count > 0;
     internal bool HasPropertyReadActions => _globalCallbacks.PropertyReadActions.Count > 0;
     internal bool HasPropertyWriteActions => _globalCallbacks.PropertyWriteActions.Count > 0;
@@ -151,51 +153,46 @@ private void RunRegisteredActions<T>(
     {
         string projectFullPath = analysisData.ProjectFilePath;
 
-        // Alternatively we might want to actually do this all in serial, but asynchronously (blocking queue)
-        Parallel.ForEach(
-            registeredCallbacks,
-            new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount },
-            /* (BuildAnalyzerWrapper2, Action<BuildAnalysisContext<T>>) */
-            analyzerCallback =>
-            {
-                // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
-                //  to the relevant analyzer (with only the currently accounted part as being the 'core-execution' subspan)
+        foreach (var analyzerCallback in registeredCallbacks)
+        {
+            // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
+            //  to the relevant analyzer (with only the currently accounted part as being the 'core-execution' subspan)
 
-                BuildAnalyzerConfigurationInternal? commonConfig = analyzerCallback.Item1.CommonConfig;
-                BuildAnalyzerConfigurationInternal[] configPerRule;
+            BuildAnalyzerConfigurationInternal? commonConfig = analyzerCallback.Item1.CommonConfig;
+            BuildAnalyzerConfigurationInternal[] configPerRule;
 
-                if (commonConfig != null)
+            if (commonConfig != null)
+            {
+                if (!commonConfig.IsEnabled)
                 {
-                    if (!commonConfig.IsEnabled)
-                    {
-                        return;
-                    }
-
-                    configPerRule = new[] { commonConfig };
+                    return;
                 }
-                else
+
+                configPerRule = new[] { commonConfig };
+            }
+            else
+            {
+                configPerRule =
+                    _configurationProvider.GetMergedConfigurations(projectFullPath,
+                        analyzerCallback.Item1.BuildAnalyzer);
+                if (configPerRule.All(c => !c.IsEnabled))
                 {
-                    configPerRule =
-                        _configurationProvider.GetMergedConfigurations(projectFullPath,
-                            analyzerCallback.Item1.BuildAnalyzer);
-                    if (configPerRule.All(c => !c.IsEnabled))
-                    {
-                        return;
-                    }
+                    return;
                 }
+            }
 
-                // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
-                // The decision and implementation depends on the outcome of the investigation tracked in:
-                // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
+            // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
+            // The decision and implementation depends on the outcome of the investigation tracked in:
+            // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
 
-                BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
-                    analyzerCallback.Item1,
-                    analysisContext,
-                    configPerRule,
-                    resultHandler,
-                    analysisData);
+            BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
+                analyzerCallback.Item1,
+                analysisContext,
+                configPerRule,
+                resultHandler,
+                analysisData);
 
-                analyzerCallback.Item2(context);
-            });
+            analyzerCallback.Item2(context);
+        }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 769b500bbd6..8499a3dfa63 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -140,6 +140,7 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzer
             [
                 ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>),
                 ([DoubleWritesAnalyzer.SupportedRule.Id], DoubleWritesAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesAnalyzer>),
+                ([NoEnvironmentVariablePropertyAnalyzer.SupportedRule.Id], NoEnvironmentVariablePropertyAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyAnalyzer>)
             ],
             // BuildCheckDataSource.Execution
             []
@@ -338,6 +339,19 @@ public void ProcessEvaluationFinishedEventArgs(
             => _buildEventsProcessor
                 .ProcessEvaluationFinishedEventArgs(analysisContext, evaluationFinishedEventArgs);
 
+        public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+        {
+            if (projectEvaluationEventArgs is EnvironmentVariableReadEventArgs evr)
+            {
+                _buildEventsProcessor.ProcessEnvironmentVariableReadEventArgs(
+                    evr.EnvironmentVariableName,
+                    evr.Message ?? string.Empty,
+                    evr.File,
+                    evr.LineNumber,
+                    evr.ColumnNumber);
+            }
+        }
+
         public void ProcessTaskStartedEventArgs(
             IAnalysisContext analysisContext,
             TaskStartedEventArgs taskStartedEventArgs)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 4de3fd80593..d4535bf161e 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -3,20 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Diagnostics;
-using System.Diagnostics.Tracing;
-using System.IO;
 using System.Linq;
-using System.Runtime.ConstrainedExecution;
-using Microsoft.Build.BackEnd;
-using Microsoft.Build.BackEnd.Components.Caching;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -49,6 +38,7 @@ public TaskKey(BuildEventContext context)
 
     private readonly SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
     private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
+    private Dictionary<string, (string EnvVarValue, string File, int Line, int Column)> _evaluatedEnvironmentVariables = new Dictionary<string, (string EnvVarValue, string File, int Line, int Column)>();
 
     /// <summary>
     /// Keeps track of in-flight tasks. Keyed by task ID as passed in <see cref="BuildEventContext.TaskId"/>.
@@ -65,7 +55,7 @@ internal void ProcessEvaluationFinishedEventArgs(
             static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
 
         EvaluatedPropertiesAnalysisData analysisData =
-            new(evaluationFinishedEventArgs.ProjectFile!, propertiesLookup);
+            new(evaluationFinishedEventArgs.ProjectFile!, propertiesLookup, _evaluatedEnvironmentVariables);
 
         _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, analysisContext, ReportResult);
 
@@ -82,6 +72,17 @@ internal void ProcessEvaluationFinishedEventArgs(
         }
     }
 
+    /// <summary>
+    /// The method collects events associated with the used environment variables in projects.
+    /// </summary>
+    internal void ProcessEnvironmentVariableReadEventArgs(string envVarName, string envVarValue, string file, int line, int column)
+    {
+        if (!_evaluatedEnvironmentVariables.ContainsKey(envVarName))
+        {
+            _evaluatedEnvironmentVariables.Add(envVarName, (envVarValue, file, line, column));
+        }
+    }
+
     internal void ProcessTaskStartedEventArgs(
         IAnalysisContext analysisContext,
         TaskStartedEventArgs taskStartedEventArgs)
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index ab2e298879b..1a06fc08ee1 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -33,7 +33,6 @@ internal sealed class ConfigurationProvider
 
     private readonly string[] _infrastructureConfigurationKeys = new string[] {
         nameof(BuildAnalyzerConfiguration.EvaluationAnalysisScope).ToLower(),
-        nameof(BuildAnalyzerConfiguration.IsEnabled).ToLower(),
         nameof(BuildAnalyzerConfiguration.Severity).ToLower()
     };
 
@@ -263,8 +262,7 @@ internal BuildAnalyzerConfigurationInternal MergeConfiguration(
         => new BuildAnalyzerConfigurationInternal(
             ruleId: ruleId,
             evaluationAnalysisScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
-            isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
-            severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
+            severity: GetSeverityValue(editorConfig, defaultConfig));
 
     private BuildAnalyzerConfigurationInternal GetMergedConfiguration(
         string projectFullPath,
@@ -280,6 +278,22 @@ private T GetConfigValue<T>(
            propertyGetter(defaultValue) ??
            EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
 
+    private BuildAnalyzerResultSeverity GetSeverityValue(BuildAnalyzerConfiguration editorConfigValue, BuildAnalyzerConfiguration defaultValue)
+    {
+        BuildAnalyzerResultSeverity? resultSeverity = null;
+
+        // Consider Default as null, so the severity from the default value could be selected.
+        // Default severity is not recognized by the infrastructure and serves for configuration purpuses only. 
+        if (editorConfigValue.Severity != null && editorConfigValue.Severity != BuildAnalyzerResultSeverity.Default)
+        {
+            resultSeverity = editorConfigValue.Severity;
+        }
+
+        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(BuildAnalyzerConfiguration.Default.Severity);
+
+        return resultSeverity.Value;
+    }
+
     private static T EnsureNonNull<T>(T? value) where T : struct
     {
         if (value is null)
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 183fd78de05..37f3b681faf 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -39,6 +39,10 @@ void ProcessEvaluationFinishedEventArgs(
         IAnalysisContext analysisContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
+    void ProcessEnvironmentVariableReadEventArgs(
+        IAnalysisContext analysisContext,
+        EnvironmentVariableReadEventArgs envVariableReadEventArgs);
+
     void ProcessTaskStartedEventArgs(
         IAnalysisContext analysisContext,
         TaskStartedEventArgs taskStartedEventArgs);
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index a8a27a9348a..2c2c88c9616 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -95,4 +95,7 @@ public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggi
 
     public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext buildEventContext)
     { }
+	
+    public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+    { }
 }
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
index f3a336a41ec..af2b5fef481 100644
--- a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
@@ -13,8 +13,21 @@ public class EvaluatedPropertiesAnalysisData : AnalysisData
 {
     internal EvaluatedPropertiesAnalysisData(
         string projectFilePath,
-        IReadOnlyDictionary<string, string> evaluatedProperties) :
-        base(projectFilePath) => EvaluatedProperties = evaluatedProperties;
+        IReadOnlyDictionary<string, string> evaluatedProperties,
+        IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> evaluatedEnvironmentVariables)
+        : base(projectFilePath)
+    {
+        EvaluatedProperties = evaluatedProperties;
+        EvaluatedEnvironmentVariables = evaluatedEnvironmentVariables;
+    }
 
+    /// <summary>
+    /// Gets the evaluated properties of the project.
+    /// </summary>
     public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
+
+    /// <summary>
+    /// Gets the evaluated environment variables and their metadata.
+    /// </summary>
+    public IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> EvaluatedEnvironmentVariables { get; }
 }
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..8aa3259bc7b
--- /dev/null
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -0,0 +1,120 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- BuildResult.get_BuildRequestDataFlags backward compat -->
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+
+  <!-- BuildCheck API refactor -->
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0011</DiagnosticId>
+    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+
+</Suppressions>
\ No newline at end of file
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 6a05f7dadbc..43c7b7a3826 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -33,6 +33,11 @@ public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<P
         /// </summary>
         private string _evaluatedValueEscaped;
 
+        /// <summary>
+        /// Property location in xml file. Can be empty.
+        /// </summary>
+        private (string File, int Line, int Column) _location;
+
         internal ProjectProperty(Project project)
         {
             ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
@@ -100,7 +105,7 @@ string IProperty.EvaluatedValueEscaped
             {
                 if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
                 {
-                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal);
+                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal, string.Empty, 0, 0);
                     args.BuildEventContext = loggingContext.BuildEventContext;
                     loggingContext.LogBuildEvent(args);
                     environmentProperty._loggedEnvProperty = true;
@@ -110,6 +115,27 @@ string IProperty.EvaluatedValueEscaped
             }
         }
 
+        /// <summary>
+        /// Gets object's location in xml file.
+        /// </summary>
+        public (string File, int Line, int Column) Location { get => _location; }
+
+        string IProperty.GetEvaluatedValueEscaped(IElementLocation location)
+        {
+            if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
+            {
+                EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal, location.File, location.Line, location.Column);
+                args.BuildEventContext = loggingContext.BuildEventContext;
+                loggingContext.LogBuildEvent(args);
+                environmentProperty._loggedEnvProperty = true;
+            }
+
+            // the location is handy in BuildCheck messages.
+            _location = (location.File, location.Line, location.Column);
+
+            return EvaluatedValueEscapedInternal;
+        }
+
         /// <summary>
         /// Gets or sets the unevaluated property value.
         /// Updates the evaluated value in the project, although this is not sure to be correct until re-evaluation.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index f44dc13a691..d4d0e961465 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -333,7 +333,26 @@ internal static void Evaluate(
                 loggingService,
                 buildEventContext);
 
-            evaluator.Evaluate();
+            try
+            {
+                evaluator.Evaluate();
+            }
+            finally
+            {
+                IEnumerable globalProperties = null;
+                IEnumerable properties = null;
+                IEnumerable items = null;
+
+                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
+                {
+                    globalProperties = evaluator._data.GlobalPropertiesDictionary;
+                    properties = Traits.LogAllEnvironmentVariables ? evaluator._data.Properties : evaluator.FilterOutEnvironmentDerivedProperties(evaluator._data.Properties);
+                    items = evaluator._data.Items;
+                }
+
+                evaluator._evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, evaluator._evaluationProfiler.ProfiledResult);
+            }
+
             MSBuildEventSource.Log.EvaluateStop(root.ProjectFileLocation.File);
         }
 
@@ -797,19 +816,6 @@ private void Evaluate()
             }
 
             ErrorUtilities.VerifyThrow(_evaluationProfiler.IsEmpty(), "Evaluation profiler stack is not empty.");
-
-            IEnumerable globalProperties = null;
-            IEnumerable properties = null;
-            IEnumerable items = null;
-
-            if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
-            {
-                globalProperties = _data.GlobalPropertiesDictionary;
-                properties = Traits.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);
-                items = _data.Items;
-            }
-
-            _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
         private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index c64d877596a..3f41c96969e 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1583,7 +1583,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                         environmentDerivedProperty.loggingContext = propertiesUseTracker.LoggingContext;
                     }
 
-                    propertyValue = property.EvaluatedValueEscaped;
+                    propertyValue = property.GetEvaluatedValueEscaped(elementLocation);
                 }
 
                 return propertyValue;
@@ -3593,8 +3593,17 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             // otherwise there is the potential of running a function twice!
                             try
                             {
-                                // First use InvokeMember using the standard binder - this will match and coerce as needed
-                                functionResult = _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
+                                // If there are any out parameters, try to figure out their type and create defaults for them as appropriate before calling the method.
+                                if (args.Any(a => "_".Equals(a)))
+                                {
+                                    IEnumerable<MethodInfo> methods = _receiverType.GetMethods(_bindingFlags).Where(m => m.Name.Equals(_methodMethodName) && m.GetParameters().Length == args.Length);
+                                    functionResult = GetMethodResult(objectInstance, methods, args, 0);
+                                }
+                                else
+                                {
+                                    // If there are no out parameters, use InvokeMember using the standard binder - this will match and coerce as needed
+                                    functionResult = _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
+                                }
                             }
                             // If we're invoking a method, then there are deeper attempts that can be made to invoke the method.
                             // If not, we were asked to get a property or field but found that we cannot locate it. No further argument coercion is possible, so throw.
@@ -3669,6 +3678,48 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                 }
             }
 
+            private object GetMethodResult(object objectInstance, IEnumerable<MethodInfo> methods, object[] args, int index)
+            {
+                for (int i = index; i < args.Length; i++)
+                {
+                    if (args[i].Equals("_"))
+                    {
+                        object toReturn = null;
+                        foreach (MethodInfo method in methods)
+                        {
+                            Type t = method.GetParameters()[i].ParameterType;
+                            args[i] = t.IsValueType ? Activator.CreateInstance(t) : null;
+                            object currentReturnValue = GetMethodResult(objectInstance, methods, args, i + 1);
+                            if (currentReturnValue is not null)
+                            {
+                                if (toReturn is null)
+                                {
+                                    toReturn = currentReturnValue;
+                                }
+                                else if (!toReturn.Equals(currentReturnValue))
+                                {
+                                    // There were multiple methods that seemed viable and gave different results. We can't differentiate between them so throw.
+                                    ErrorUtilities.ThrowArgument("CouldNotDifferentiateBetweenCompatibleMethods", _methodMethodName, args.Length);
+                                    return null;
+                                }
+                            }
+                        }
+
+                        return toReturn;
+                    }
+                }
+
+                try
+                {
+                    return _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
+                }
+                catch (Exception)
+                {
+                    // This isn't a viable option, but perhaps another set of parameters will work.
+                    return null;
+                }
+            }
+
             /// <summary>
             /// Shortcut to avoid calling into binding if we recognize some most common functions.
             /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
@@ -3864,6 +3915,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(string.Equals), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = text.Equals(arg0);
+                            return true;
+                        }
+                    }
                 }
                 else if (objectInstance is string[] stringArray)
                 {
@@ -4310,6 +4369,22 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.NormalizeDirectory), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.NormalizeDirectory(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsOSPlatform), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.IsOSPlatform(arg0);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4407,6 +4482,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(Path.GetFileNameWithoutExtension), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = Path.GetFileNameWithoutExtension(arg0);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Version))
                     {
@@ -4419,7 +4502,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             }
                         }
                     }
-                    else if (_receiverType == typeof(System.Guid))
+                    else if (_receiverType == typeof(Guid))
                     {
                         if (string.Equals(_methodMethodName, nameof(Guid.NewGuid), StringComparison.OrdinalIgnoreCase))
                         {
@@ -4430,8 +4513,31 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             }
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(Regex.Replace), StringComparison.OrdinalIgnoreCase) && args.Length == 3)
+                    {
+                        if (TryGetArg([args[0]], out string arg1) && TryGetArg([args[1]], out string arg2) && TryGetArg([args[2]], out string arg3))
+                        {
+                            returnVal = Regex.Replace(arg1, arg2, arg3);
+                            return true;
+                        }
+                    }
+                }
+                else if (string.Equals(_methodMethodName, nameof(Version.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is Version v)
+                {
+                    if (TryGetArg(args, out int arg0))
+                    {
+                        returnVal = v.ToString(arg0);
+                        return true;
+                    }
+                }
+                else if (string.Equals(_methodMethodName, nameof(Int32.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is int i)
+                {
+                    if (TryGetArg(args, out string arg0))
+                    {
+                        returnVal = i.ToString(arg0);
+                        return true;
+                    }
                 }
-
                 if (Traits.Instance.LogPropertyFunctionsRequiringReflection)
                 {
                     LogFunctionCall("PropertyFunctionsRequiringReflection", objectInstance, args);
diff --git a/src/Build/Evaluation/IProperty.cs b/src/Build/Evaluation/IProperty.cs
index da311eb95dc..d20249ce349 100644
--- a/src/Build/Evaluation/IProperty.cs
+++ b/src/Build/Evaluation/IProperty.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -13,7 +14,7 @@ namespace Microsoft.Build.Evaluation
     internal interface IProperty : IKeyed
     {
         /// <summary>
-        /// Name of the property
+        /// Name of the property.
         /// </summary>
         string Name
         {
@@ -29,11 +30,24 @@ string EvaluatedValue
         }
 
         /// <summary>
-        /// Returns the evaluated, escaped value for the property
+        /// Returns the evaluated, escaped value for the property.
         /// </summary>
         string EvaluatedValueEscaped
         {
             get;
         }
+
+        /// <summary>
+        /// Returns the evaluated, escaped value for the property and sets up the property location if it is available.
+        /// </summary>
+        string GetEvaluatedValueEscaped(IElementLocation location);
+
+        /// <summary>
+        /// Returns property location in xml file. Can be empty.
+        /// </summary>
+        (string File, int Line, int Column) Location
+        {
+            get;
+        }
     }
 }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index e9b381b5aa1..ce2c28494ff 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -569,7 +569,9 @@ public override IEnumerable<string> GetReferencedItems()
     /// </summary>
     /// <typeparam name="P">Property type</typeparam>
     /// <typeparam name="I">Item type</typeparam>
-    internal sealed class MetadataTrie<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable
+    internal sealed class MetadataTrie<P, I>
+        where P : class, IProperty
+        where I : class, IItem, IMetadataTable
     {
         private readonly Dictionary<string, MetadataTrie<P, I>> _children;
         private readonly Func<string, string> _normalize;
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 2ffa5251309..23630119bcb 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -216,7 +216,10 @@ private void TrackEnvironmentVariableRead(string name)
 
             var args = new EnvironmentVariableReadEventArgs(
                 name,
-                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentVariableRead", name));
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentVariableRead", name),
+                string.Empty,
+                0,
+                0);
             args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
 
             _evaluationLoggingContext.LogBuildEvent(args);
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index 7a173627c99..7762547528b 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -167,7 +167,7 @@ public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEnt
         private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags, GraphBuildOptions? graphBuildOptions = null)
         : base(targetsToBuild, flags, hostServices)
         {
-            Flags = flags;
+            base.Flags = flags;
             GraphBuildOptions = graphBuildOptions ?? new GraphBuildOptions();
         }
 
@@ -235,5 +235,18 @@ public override IEnumerable<string> EntryProjectsFullPath
         /// Options for how the graph should be built.
         /// </summary>
         public GraphBuildOptions GraphBuildOptions { get; }
+
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
+
+        /// <inheritdoc cref="BuildRequestDataBase.TargetNames"/>
+        public new ICollection<string> TargetNames => base.TargetNames;
+
+        /// <inheritdoc cref="BuildRequestDataBase.Flags"/>
+        public new BuildRequestDataFlags Flags => base.Flags;
+
+        /// <inheritdoc cref="BuildRequestDataBase.HostServices"/>
+        public new HostServices? HostServices => base.HostServices;
     }
 }
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index 6e45cc0231d..270134614f5 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -62,7 +62,35 @@ public override GraphBuildResult Execute()
             return BuildResult!;
         }
 
+        protected internal override void CheckResultValidForCompletion(GraphBuildResult result)
+        {
+            ErrorUtilities.VerifyThrow(result.SubmissionId == SubmissionId,
+                "GraphBuildResult's submission id doesn't match GraphBuildSubmission's");
+        }
+
         protected internal override GraphBuildResult CreateFailedResult(Exception exception)
             => new(SubmissionId, exception);
+
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
+
+        /// <inheritdoc cref="BuildSubmissionBase{GraphBuildRequestData, GraphBuildResult}.BuildResult"/>
+        public new GraphBuildResult? BuildResult => base.BuildResult;
+
+        /// <inheritdoc cref="BuildSubmissionBase.BuildManager"/>
+        public new BuildManager BuildManager => base.BuildManager;
+
+        /// <inheritdoc cref="BuildSubmissionBase.SubmissionId"/>
+        public new int SubmissionId => base.SubmissionId;
+
+        /// <inheritdoc cref="BuildSubmissionBase.AsyncContext"/>
+        public new object? AsyncContext => base.AsyncContext;
+
+        /// <inheritdoc cref="BuildSubmissionBase.WaitHandle"/>
+        public new WaitHandle WaitHandle => base.WaitHandle;
+
+        /// <inheritdoc cref="BuildSubmissionBase.IsCompleted"/>
+        public new bool IsCompleted => base.IsCompleted;
     }
 }
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index 9c2d9ed766e..13b3c076958 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -33,6 +33,11 @@ public class ProjectPropertyInstance : IKeyed, IValued, IProperty, IEquatable<Pr
         /// </summary>
         private string _escapedValue;
 
+        /// <summary>
+        /// Property location in xml file. Can be empty.
+        /// </summary>
+        private (string File, int Line, int Column) _location;
+
         /// <summary>
         /// Private constructor
         /// </summary>
@@ -80,6 +85,11 @@ public string EvaluatedValue
         /// </summary>
         public virtual bool IsImmutable => false;
 
+        /// <summary>
+        /// Gets or sets object's location in xml file.
+        /// </summary>
+        public (string File, int Line, int Column) Location { get => _location; }
+
         /// <summary>
         /// Evaluated value of the property, escaped as necessary.
         /// Setter assumes caller has protected global properties, if necessary.
@@ -91,7 +101,7 @@ string IProperty.EvaluatedValueEscaped
             {
                 if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
                 {
-                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);
+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue, string.Empty, 0, 0);
                     args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
                     envProperty.loggingContext.LogBuildEvent(args);
                     envProperty._loggedEnvProperty = true;
@@ -100,8 +110,25 @@ string IProperty.EvaluatedValueEscaped
                 return _escapedValue;
             }
         }
+
+        string IProperty.GetEvaluatedValueEscaped(IElementLocation location)
+        {
+            if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
+            {
+                EnvironmentVariableReadEventArgs args = new(Name, _escapedValue, location.File, location.Line, location.Column);
+                args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
+                envProperty.loggingContext.LogBuildEvent(args);
+                envProperty._loggedEnvProperty = true;
+            }
+
+            // the location is handy in BuildCheck messages.
+            _location = (location.File, location.Line, location.Column);
+
+            return _escapedValue;
+        }
+
         /// <summary>
-        /// Implementation of IKeyed exposing the property name
+        /// Implementation of IKeyed exposing the property name.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
         string IKeyed.Key => Name;
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index cbcc460e73c..fb21e16522d 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -73,14 +73,15 @@ public sealed class BinaryLogger : ILogger
         //   - TaskStartedEventArgs: Added TaskAssemblyLocation property
         // version 21:
         //   - TaskParameterEventArgs: Added ParameterName and PropertyName properties
-
+        // version 22:
+        //    - extend EnvironmentVariableRead with location where environment variable was used.
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
         internal const int ForwardCompatibilityMinimalVersion = 18;
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 21;
+        internal const int FileFormatVersion = 22;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 358c410265f..0acec68a4a0 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -2,12 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.IO.Compression;
-using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
 using System.Text;
@@ -1093,16 +1091,19 @@ private BuildEventArgs ReadCriticalBuildMessageEventArgs()
 
         private BuildEventArgs ReadEnvironmentVariableReadEventArgs()
         {
-            var fields = ReadBuildEventArgsFields(readImportance: true);
+            var fields = ReadBuildEventArgsFields();
 
-            var environmentVariableName = ReadDeduplicatedString();
+            string? environmentVariableName = ReadDeduplicatedString();
+            int line = ReadInt32();
+            int column = ReadInt32();
+            string? fileName = ReadDeduplicatedString();
 
-            var e = new EnvironmentVariableReadEventArgs(
-                environmentVariableName,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Importance);
+            BuildEventArgs e = new EnvironmentVariableReadEventArgs(
+                    environmentVariableName ?? string.Empty,
+                    fields.Message,
+                    fileName ?? string.Empty,
+                    line,
+                    column);
             SetCommonFields(e, fields);
 
             return e;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index a9a734b1638..6ee4aff9d74 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
@@ -15,7 +14,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 
 #nullable disable
@@ -547,10 +545,15 @@ private BinaryLogRecordKind Write(PropertyInitialValueSetEventArgs e)
 
         private BinaryLogRecordKind Write(EnvironmentVariableReadEventArgs e)
         {
-            WriteMessageFields(e, writeImportance: true);
+            WriteMessageFields(e, writeImportance: false);
             WriteDeduplicatedString(e.EnvironmentVariableName);
+            Write(e.LineNumber);
+            Write(e.ColumnNumber);
+            WriteDeduplicatedString(e.File);
+
             return BinaryLogRecordKind.EnvironmentVariableRead;
         }
+
         private BinaryLogRecordKind Write(ResponseFileUsedEventArgs e)
         {
             WriteMessageFields(e);
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 7f0185eee30..49573c943fb 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -517,8 +517,8 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
+                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty
+                    ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
                     : e.Message ?? String.Empty;
 
                 // Include file information if present.
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 741e731b9ad..1932df4be9b 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -604,6 +604,9 @@
       LOCALIZATION: "{0}" is the expression that was bad. "{1}" is a message from an FX exception that describes why the expression is bad.
     </comment>
   </data>
+  <data name="CouldNotDifferentiateBetweenCompatibleMethods">
+    <value>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</value>
+  </data>
   <data name="InvalidFunctionPropertyExpression" xml:space="preserve">
     <value>MSB4184: The expression "{0}" cannot be evaluated. {1}</value>
     <comment>{StrBegin="MSB4184: "}
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index a0d4aa03e9b..44e6d7cd8b4 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Pokus o zrušení sestavování...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">Pro tento build je povolena funkce BuildCheck.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">Bylo nalezeno více přetížení pro metodu {0} s tímto počtem parametrů: {1}. To v současné době není podporováno.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
+        <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Nepodařilo se načíst vlastní typ analyzátoru: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Pokud se nemá jednat o vlastní analyzátor, neměl by být odkrytý. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Nepodařilo se načíst typ vlastního analyzátoru: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Pokud se nemá jednat o vlastní analyzátor, neměl by být exponovaný. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
+        <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Nepovedlo se vytvořit instanci pravidla vlastního analyzátoru s následující výjimkou: {0}.</target>
+        <target state="translated">Nepovedlo se vytvořit instanci pravidla vlastního analyzátoru s následující výjimkou: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">Vlastní analyzátor {0} je pro build zaregistrován z umístění: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Pravidlo vlastního analyzátoru: {0} se úspěšně zaregistrovalo.</target>
+        <target state="translated">Pravidlo vlastního analyzátoru: {0} se úspěšně zaregistrovalo.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 614eebf6d2c..2ed2094252b 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Es wird versucht, den Buildvorgang abzubrechen...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">BuildCheck ist für diesen Build aktiviert.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">Es wurden mehrere Überladungen für die Methode „{0}“ mit {1} Parametern gefunden. Dies wird derzeit nicht unterstützt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
+        <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Fehler beim Laden des benutzerdefinierten Analysetooltyps „{0}“ aus der Assembly „{1}“. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer“ erbt. Wenn es sich nicht um ein benutzerdefiniertes Analysetool handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Fehler beim Laden des benutzerdefinierten Analysetooltyps „{0}“ aus der Assembly: {1}. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer“ erbt. Wenn es sich nicht um ein benutzerdefiniertes Analysetool handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
+        <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Fehler beim Instanziieren der benutzerdefinierten Analysetoolregel mit der folgenden Ausnahme: {0}.</target>
+        <target state="translated">Fehler beim Instanziieren der benutzerdefinierten Analyseregel. Ausnahme: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">Das benutzerdefinierte Analysetool „{0}“ ist für den Build vom Folgenden aus registriert: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Benutzerdefinierte Analysetoolregel {0} wurde erfolgreich registriert.</target>
+        <target state="translated">Die benutzerdefinierte Analyseregel „{0}“ wurde erfolgreich registriert.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 753cb86e0ef..b65536dcab6 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Intentando cancelar la compilación...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">BuildCheck está habilitado para esta compilación.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">Encontradas múltiples sobrecargas para el método "{0}" con {1} parámetro(s). Esto no se admite actualmente.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">No se ha podido encontrar el ensamblado del analizador personalizado especificado: {0}. Compruebe si existe.</target>
+        <target state="translated">No se pudo encontrar el ensamblado del analizador personalizado especificado: '{0}'. Compruebe si existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">No se pudo cargar el tipo de analizador personalizado: {0} del ensamblado: {1}. Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Si no está pensado para ser un analizador personalizado, entonces no debería exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">No se pudo cargar el tipo de analizador personalizado: '{0}' del ensamblado: '{1}'. Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Si no está pensado para ser un analizador personalizado, no debe exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">No se ha podido registrar el analizador personalizado: {0}.</target>
+        <target state="translated">No se pudo registrar el analizador personalizado: '{0}'.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">No se ha podido crear una instancia de la regla del analizador personalizado con la siguiente excepción: {0}.</target>
+        <target state="translated">No se pudo crear una instancia de la regla del analizador personalizado con la siguiente excepción: '{0}'.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">El analizador personalizado: '{0}' está registrado para la compilación desde la ubicación: '{1}'.</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Regla del analizador personalizado: {0} se ha registrado correctamente.</target>
+        <target state="translated">La regla del analizador personalizado: '{0}' se ha registrado correctamente.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 95ef0f97ce4..c758233a8e2 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Tentative d'annulation de la génération en cours...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">BuildCheck est activé pour cette build.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">Plusieurs surcharges ont été trouvées pour la méthode « {0} » avec le(s) paramètre(s) {1}. Cela n’est actuellement pas pris en charge.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Impossible de trouver l’assemblée d'analyseur personnalisé spécifié : {0}. Vérifiez s’il existe.</target>
+        <target state="translated">Désolé... Nous n’avons pas pu trouver l’assembly d’analyseur personnalisé : « {0} ». Veuillez vérifier s’il existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Échec du chargement du type d’analyseur personnalisé : {0} à partir de l’assembly : {1}. Assurez-vous qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. S’il ne doit pas être un analyseur personnalisé, il ne doit pas être exposé. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Désolé... Nous n’avons pas pu charger le type d’analyseur personnalisé : « {0} » à partir de l’assembly : « {1} ». Vérifiez qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. S’il n’est pas destiné à être un analyseur personnalisé, il ne doit pas être exposé. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Échec de l’inscription de l’analyseur personnalisé : {0}.</target>
+        <target state="translated">Désolé... Nous n’avons pas pu inscrire l’analyseur personnalisé : « {0} ».</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Échec de l’instanciation de la règle d’analyseur personnalisé avec l’exception suivante : {0}.</target>
+        <target state="translated">Désolé... Nous n’avons pas pu instancier la règle d’analyseur personnalisé avec l’exception suivante : « {0} ».</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">L’analyseur personnalisé : « {0} » est inscrit pour la build à partir de l’emplacement : « {1} ».</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Règle de l’analyseur personnalisé : {0} a été correctement inscrit.</target>
+        <target state="translated">Règle de l’analyseur personnalisé : {0} a été correctement inscrit.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 60793747d08..756348e42c3 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Tentativo di annullare la compilazione in corso...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">BuildCheck è abilitato per questa compilazione.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: {0}. Verificare se esiste.</target>
+        <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: '{0}'. Verificare se esiste.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Non è stato possibile caricare il tipo di analizzatore diagnostico personalizzato: {0} dall'assembly: {1}. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se non è destinato a essere un analizzatore personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Non è stato possibile caricare il tipo di analizzatore diagnostico personalizzato: '{0}' dall'assembly: '{1}'. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se non è destinato a essere un analizzatore personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Impossibile registrare l'analizzatore personalizzato: {0}.</target>
+        <target state="translated">Impossibile registrare l'analizzatore personalizzato: '{0}'.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Impossibile creare un'istanza della regola dell'analizzatore personalizzato con l'eccezione seguente: {0}.</target>
+        <target state="translated">Impossibile creare un'istanza della regola dell'analizzatore personalizzato con l'eccezione seguente: '{0}'.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">Analizzatore personalizzato: '{0}' registrato per la compilazione dal percorso: '{1}'.</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Regola dell'analizzatore personalizzato: {0} è stata registrata.</target>
+        <target state="translated">Regola dell'analizzatore personalizzato: '{0}' è stata registrata.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 6efeee512f8..f14554ef79d 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">ビルドを取り消そうとしています...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">BuildCheck は、このビルドに対して有効になっています。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">{1} パラメーターを持つメソッド "{0}" に対して複数のオーバーロードが見つかりました。これは現在サポートされていません。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">指定されたカスタム アナライザー アセンブリが見つかりませんでした: {0}。存在するかどうか確認してください。</target>
+        <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: '{0}'。存在するかどうか確認してください。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">カスタム アナライザーの種類を読み込めませんでした: アセンブリ {1} の {0}。Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底クラスを継承していることを確認してください。カスタム アナライザーを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">カスタム アナライザーの種類を読み込めませんでした: アセンブリ '{1}' の '{0}'。Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底クラスを継承していることを確認してください。カスタム アナライザーを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">カスタム アナライザーを登録できませんでした: {0}</target>
+        <target state="translated">カスタム アナライザーを登録できませんでした: '{0}'。</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">次の例外により、カスタム アナライザー ルールのインスタンスを作成できませんでした: {0}。</target>
+        <target state="translated">次の例外により、カスタム アナライザー ルールのインスタンスを作成できませんでした: '{0}'。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">カスタム アナライザー'{0}' は、場所 '{1}' からビルドに登録されています。</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">カスタム アナライザー ルール: {0} が正常に登録されました。</target>
+        <target state="translated">カスタム アナライザー ルール: '{0}' が正常に登録されました。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index ff7b0ebe082..552f411f14d 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">빌드를 취소하는 중...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">이 빌드에 대해 BuildCheck를 사용할 수 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">{1} 매개 변수가 있는 "{0}" 메서드에 오버로드가 여러 개 발견되었습니다. 이는 현재 지원되지 않습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">지정한 사용자 지정 분석기 어셈블리를 찾지 못했습니다. {0}. 존재하는지 확인하세요.</target>
+        <target state="translated">지정한 사용자 지정 분석기 어셈블리 '{0}'을(를) 찾지 못했습니다. 있는지 확인하세요.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">사용자 지정 분석기 형식을 로드하지 못했습니다. 어셈블리에서 {0} : {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 기본 클래스를 상속해야 합니다. 사용자 지정 분석기가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">'{1}' 어셈블리에서 사용자 지정 분석기 유형 '{0}'을(를) 로드하지 못했습니다. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 기본 클래스를 상속해야 합니다. 사용자 지정 분석기가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">사용자 지정 분석기를 등록하지 못했습니다. {0}.</target>
+        <target state="translated">사용자 지정 분석기 '{0}'을(를) 등록하지 못했습니다.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">다음 예외로 인해 사용자 지정 분석기 규칙을 인스턴스화하지 못했습니다. {0}.</target>
+        <target state="translated">'{0}' 예외로 인해 사용자 지정 분석기 규칙을 인스턴스화하지 못했습니다.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">사용자 지정 분석기 '{0}'이(가) '{1}' 위치의 빌드에 등록되었습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">사용자 지정 분석기 규칙: {0}이(가) 등록되었습니다.</target>
+        <target state="translated">사용자 지정 분석기 규칙 '{0}'이(가) 등록되었습니다.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 6d2af5ea7ef..f4a35ecf6fc 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Trwa próba anulowania kompilacji...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">Dla tej kompilacji włączono funkcję BuildCheck.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Nie można odnaleźć określonego zestawu analizatora niestandardowego: {0}. Sprawdź, czy istnieje.</target>
+        <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: „{0}”. Sprawdź, czy istnieje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Nie udało się załadować niestandardowego analizatora typu: {0} z zestawu: {1}. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Jeśli nie jest przeznaczony do niestandardowego analizatora, nie powinien być ujawniany. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Nie udało się załadować niestandardowego analizatora typu: „{0}” z zestawu: „{1}”. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Jeśli nie jest przeznaczony do niestandardowego analizatora, nie powinien być ujawniany. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Nie można zarejestrować analizatora niestandardowego: {0}.</target>
+        <target state="translated">Nie można zarejestrować analizatora niestandardowego: „{0}”.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Nie można utworzyć wystąpienia niestandardowej reguły analizatora z następującym wyjątkiem: {0}.</target>
+        <target state="translated">Nie można utworzyć wystąpienia niestandardowej reguły analizatora z następującym wyjątkiem: „{0}”.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">Analizator niestandardowy „{0}” jest zarejestrowany dla kompilacji z lokalizacji: „{1}”.</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Niestandardowa reguła analizatora: {0} została pomyślnie zarejestrowana.</target>
+        <target state="translated">Niestandardowa reguła analizatora: „{0}” została pomyślnie zarejestrowana.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 196d130c74a..a3fc797a87c 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Tentando cancelar a compilação...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">O BuildCheck está habilitado para esse build.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">Foram encontradas várias sobrecargas para o método "{0}" com parâmetros {1}. No momento, não há suporte para isso.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Falha ao localizar o assembly do analisador personalizado especificado: {0}. Verifique se existe.</target>
+        <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: "{0}". Verifique se existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Falha ao carregar o tipo de analisador personalizado: {0} do assembly: {1}. Certifique-se de que ele herde a classe base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se não se destina a ser um analisador personalizado, ele não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Falha ao carregar o tipo de analisador personalizado: "{0}" do assembly: "{1}". Certifique-se de que ele herde a classe base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se não se destina a ser um analisador personalizado, ele não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Falha ao registrar o analisador personalizado: {0}.</target>
+        <target state="translated">Falha ao registrar o analisador personalizado: "{0}".</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Falha ao criar uma instância da regra do analisador personalizado com a seguinte exceção: {0}.</target>
+        <target state="translated">Falha ao criar uma instância da regra do analisador personalizado com a seguinte exceção: "{0}".</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">O analisador personalizado: "{0}"está registrado para o build do local: "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Regra do analisador personalizado: {0} foi registrado com sucesso.</target>
+        <target state="translated">Regra do analisador personalizado: "{0}" foi registrado com sucesso.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index a1d5a6ad5d0..4c52cee8fa4 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Попытка отменить сборку...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">Для этой сборки включен параметр BuildCheck.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">Обнаружено несколько перегрузок для метода "{0}" с параметрами {1}. Это сейчас не поддерживается.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Не удалось найти указанную сборку настраиваемого анализатора: {0}. Убедитесь, что она существует.</target>
+        <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора "{0}". Убедитесь, что она существует.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Не удалось загрузить настраиваемый тип анализатора {0} из сборки {1}. Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Если он не предназначен для настраиваемого анализатора, его не следует предоставлять. Дополнительные сведения: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Не удалось загрузить тип настраиваемого анализатора "{0}" из сборки "{1}". Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Если он не предназначен для настраиваемого анализатора, его не следует предоставлять. Подробнее: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Не удалось зарегистрировать настраиваемый анализатор: {0}.</target>
+        <target state="translated">Не удалось зарегистрировать настраиваемый анализатор "{0}".</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Не удалось создать экземпляр правила настраиваемого анализатора со следующим исключением: {0}.</target>
+        <target state="translated">Не удалось создать экземпляр правила настраиваемого анализатора со следующим исключением: "{0}".</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">Настраиваемый анализатор "{0}" включен для сборки из расположения "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">Зарегистрировано правило настраиваемого анализатора: {0}.</target>
+        <target state="translated">Правило настраиваемого анализатора "{0}" успешно зарегистрировано.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 62f7c89d8d9..4e0b4061aab 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">Oluşturma iptal edilmeye çalışılıyor...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">BuildCheck bu derleme için etkinleştirildi.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">{1} parametreye sahip "{0}" yöntemi için birden çok aşırı yükleme bulundu. Bu şu anda desteklenmiyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">Belirtilen {0} özel çözümleyici derlemesi bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
+        <target state="translated">Belirtilen özel çözümleyici derlemesi: ‘{0}’ bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">Özel çözümleyici türü yüklenemedi: {0} derlemeden: {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer temel sınıf devralınmış olduğundan emin olun. Özel bir çözümleyici olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">Özel çözümleyici türü: ‘{0}’ şu derlemeden: ‘{1}’ yüklenemedi. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer temel sınıfını devralmış olduğundan emin olun. Özel bir çözümleyici olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">Özel çözümleyici kaydedilemedi: {0}.</target>
+        <target state="translated">Özel çözümleyici: ‘{0}’ kaydedilemedi.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">Özel çözümleyici kuralı şu özel durumla başlatılamadı: {0}.</target>
+        <target state="translated">Özel çözümleyici kuralı şu özel durumla başlatılamadı: ‘{0}’.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">Özel çözümleyici: '{0}' derleme için şu konumdan kaydedildi: '{1}'.</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">{0} özel çözümleyici kuralı başarıyla kaydedildi.</target>
+        <target state="translated">Özel çözümleyici kuralı: ‘{0}’ başarıyla kaydedildi.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index e7fba5a5610..6f1311d574e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">正在尝试取消生成...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">已为此内部版本启用 BuildCheck。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">找不到指定的自定义分析器程序集: {0}。请检查它是否存在。</target>
+        <target state="translated">找不到指定的自定义分析器程序集 "{0}"。请检查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">未能从程序集 {1} 加载自定义分析器类型 {0}。请确保它继承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基类。如果不打算将其作为自定义分析器，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">未能从程序集 "{1}" 加载自定义分析器类型 "{0}"。请确保它继承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基类。如果不打算将其作为自定义分析器，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">无法注册自定义分析器: {0}。</target>
+        <target state="translated">未能注册自定义分析器 "{0}"。</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">无法实例化自定义分析器规则，出现以下异常: {0}。</target>
+        <target state="translated">未能实例化自定义分析器规则，出现以下异常: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">已从位置 "{1}" 为内部版本注册自定义分析器 "{0}"。</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">自定义分析器规则: {0} 已成功注册。</target>
+        <target state="translated">已成功注册自定义分析器规则 "{0}"。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 0469d4796b0..11725f11a13 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -4,7 +4,7 @@
     <body>
       <trans-unit id="AbortingBuild">
         <source>Attempting to cancel the build...</source>
-        <target state="new">Attempting to cancel the build...</target>
+        <target state="translated">正在嘗試取消建置...</target>
         <note />
       </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
@@ -133,7 +133,7 @@
       </trans-unit>
       <trans-unit id="BuildCheckEnabled">
         <source>The BuildCheck is enabled for this build.</source>
-        <target state="new">The BuildCheck is enabled for this build.</target>
+        <target state="translated">已為此組建啟用 BuildCheck。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
@@ -217,34 +217,39 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="translated">在具有 {1} 參數的方法 "{0}" 發現多個多載。目前不支援此功能。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="needs-review-translation">找不到指定的自訂分析器組件: {0}。請檢查它是否存在。</target>
+        <target state="translated">找不到指定的自訂分析器組件: '{0}'。請確認其是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
         <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="needs-review-translation">無法從組件 {1} 載入自訂分析器類型 {0}。請確定它繼承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基類。如果不是要作為自訂分析器，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <target state="translated">無法從組件: '{1}'載入自訂分析器類型: '{0}'。請確認其繼承了 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底類別。如非作為自訂分析器，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="needs-review-translation">無法登錄自訂分析器: {0}。</target>
+        <target state="translated">無法註冊自訂分析器: '{0}'。</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="needs-review-translation">無法具現化自訂分析器規則，發生下列例外狀況: {0}。</target>
+        <target state="translated">無法具現化自訂分析器規則，發生下列例外狀況: '{0}'。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerRegistered">
         <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="new">The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</target>
+        <target state="translated">已從 '{1}' 位置為組建註冊自訂分析器 '{0}'。</target>
         <note />
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="needs-review-translation">自訂分析器規則: 已成功登錄 {0}。</target>
+        <target state="translated">已成功註冊自訂分析器規則: '{0}'。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
index 7bd57f8014b..2c559ffbe29 100644
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -5,34 +5,59 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 using Shouldly;
+using System;
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
 public class BuildAnalyzerConfigurationInternalTests
 {
     [Theory]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
-    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Error, true, false)]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning,  true)]
+    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning,  true)]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Error, false)]
     public void IsSameConfigurationAsTest(
         string secondRuleId,
         EvaluationAnalysisScope secondScope,
         BuildAnalyzerResultSeverity secondSeverity,
-        bool secondEnabled,
         bool isExpectedToBeSame)
     {
         BuildAnalyzerConfigurationInternal configuration1 = new BuildAnalyzerConfigurationInternal(
                        ruleId: "ruleId",
                        evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
-                       severity: BuildAnalyzerResultSeverity.Warning,
-                       isEnabled: true);
+                       severity: BuildAnalyzerResultSeverity.Warning);
 
         BuildAnalyzerConfigurationInternal configuration2 = new BuildAnalyzerConfigurationInternal(
             ruleId: secondRuleId,
             evaluationAnalysisScope: secondScope,
-            severity: secondSeverity,
-            isEnabled: secondEnabled);
+            severity: secondSeverity);
 
         configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
     }
+
+    [Theory]
+    [InlineData( BuildAnalyzerResultSeverity.Warning, true)]
+    [InlineData(BuildAnalyzerResultSeverity.Suggestion, true)]
+    [InlineData(BuildAnalyzerResultSeverity.Error, true)]
+    [InlineData(BuildAnalyzerResultSeverity.None, false)]
+    public void BuildAnalyzerConfigurationInternal_Constructor_SeverityConfig(BuildAnalyzerResultSeverity severity, bool isEnabledExpected)
+    {
+        BuildAnalyzerConfigurationInternal configuration = new BuildAnalyzerConfigurationInternal(
+                       ruleId: "ruleId",
+                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
+                       severity: severity);
+
+        configuration.IsEnabled.ShouldBe(isEnabledExpected);
+    }
+
+    [Fact]
+    public void BuildAnalyzerConfigurationInternal_Constructor_SeverityConfig_Fails()
+    {
+        Should.Throw<ArgumentOutOfRangeException>(() =>
+        {
+            new BuildAnalyzerConfigurationInternal(
+                        ruleId: "ruleId",
+                        evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
+                        severity: BuildAnalyzerResultSeverity.Default);
+        });
+    }
 }
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
index edfdfaf4589..f1aff479f9e 100644
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
@@ -33,43 +33,45 @@ public void CreateWithEmpty_ReturnsObjectWithNullValues()
 
     [Theory]
     [InlineData("error", BuildAnalyzerResultSeverity.Error)]
-    [InlineData("info", BuildAnalyzerResultSeverity.Info)]
+    [InlineData("ERROR", BuildAnalyzerResultSeverity.Error)]
+    [InlineData("suggestion", BuildAnalyzerResultSeverity.Suggestion)]
+    [InlineData("SUGGESTION", BuildAnalyzerResultSeverity.Suggestion)]
     [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
     [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
+    [InlineData("NONE", BuildAnalyzerResultSeverity.None)]
+    [InlineData("none", BuildAnalyzerResultSeverity.None)]
+    [InlineData("default", BuildAnalyzerResultSeverity.Default)]
+    [InlineData("DEFAULT", BuildAnalyzerResultSeverity.Default)]
     public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
     {
         var config = new Dictionary<string, string>()
         {
             { "severity" , parameter },
         };
+
         var buildConfig = BuildAnalyzerConfiguration.Create(config);
 
         buildConfig.ShouldNotBeNull();
         buildConfig.Severity.ShouldBe(expected);
-
-        buildConfig.IsEnabled.ShouldBeNull();
         buildConfig.EvaluationAnalysisScope.ShouldBeNull();
     }
 
     [Theory]
-    [InlineData("true", true)]
-    [InlineData("TRUE", true)]
-    [InlineData("false", false)]
-    [InlineData("FALSE", false)]
-    public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
+    [InlineData("error", true)]
+    [InlineData("warning", true)]
+    [InlineData("suggestion", true)]
+    [InlineData("none", false)]
+    [InlineData("default", null)]
+    public void CreateBuildAnalyzerConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
     {
         var config = new Dictionary<string, string>()
         {
-            { "isenabled" , parameter },
+            { "severity", parameter },
         };
-
+        
         var buildConfig = BuildAnalyzerConfiguration.Create(config);
 
-        buildConfig.ShouldNotBeNull();
         buildConfig.IsEnabled.ShouldBe(expected);
-
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
     }
 
     [Theory]
@@ -96,7 +98,6 @@ public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string para
 
     [Theory]
     [InlineData("evaluationanalysisscope", "incorrec-value")]
-    [InlineData("isenabled", "incorrec-value")]
     [InlineData("severity", "incorrec-value")]
     public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
     {
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
index d559e1724b1..d4fdb9d49df 100644
--- a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -76,7 +76,6 @@ public void GetRuleIdConfiguration_CustomConfigurationData()
         [*.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
         build_check.rule_id.isEnabled2=true
         any_other_key1=any_other_value1
         any_other_key2=any_other_value2
@@ -106,7 +105,6 @@ public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
         root=true
 
         [*.csproj]
-        build_check.rule_id.isEnabled=true
         build_check.rule_id.Severity=Error
         build_check.rule_id.EvaluationAnalysisScope=ProjectOnly
         """);
@@ -134,13 +132,11 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_Differen
         [*.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
         build_check.rule_id.isEnabled2=true
 
         [test123.csproj]
         build_check.rule_id.property1=value2
         build_check.rule_id.property2=value3
-        build_check.rule_id.isEnabled=true
         build_check.rule_id.isEnabled2=tru1
         """);
 
@@ -199,13 +195,11 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
         [*.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
         build_check.rule_id.isEnabled2=true
 
         [test123.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
         build_check.rule_id.isEnabled2=true
         """);
 
@@ -218,4 +212,29 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
             configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
         });
     }
+
+    [Theory]
+    [InlineData(BuildAnalyzerResultSeverity.Warning, BuildAnalyzerResultSeverity.Warning, true)]
+    [InlineData(BuildAnalyzerResultSeverity.Error, BuildAnalyzerResultSeverity.Error, true)]
+    [InlineData(BuildAnalyzerResultSeverity.Default, BuildAnalyzerResultSeverity.Warning, true)]
+    [InlineData(BuildAnalyzerResultSeverity.Suggestion, BuildAnalyzerResultSeverity.Suggestion, true)]
+    [InlineData(BuildAnalyzerResultSeverity.None, BuildAnalyzerResultSeverity.None, false)]
+    [InlineData(null, BuildAnalyzerResultSeverity.Warning, true)]
+    public void GetConfigurationProvider_MergesSeverity_Correctly(BuildAnalyzerResultSeverity? buildAnalyzerResultSeverity, BuildAnalyzerResultSeverity expectedSeverity, bool expectedEnablment)
+    {
+        var configurationProvider = new ConfigurationProvider();
+        BuildAnalyzerConfiguration buildAnalyzerConfiguration = new BuildAnalyzerConfiguration()
+        {
+            Severity = buildAnalyzerResultSeverity
+        };
+
+        BuildAnalyzerConfiguration defaultValue = new BuildAnalyzerConfiguration()
+        {
+            Severity = BuildAnalyzerResultSeverity.Warning
+        };
+
+        var internalBuildAnalyzer = configurationProvider.MergeConfiguration("ruleId", defaultValue, buildAnalyzerConfiguration);
+        internalBuildAnalyzer.Severity.ShouldBe(expectedSeverity);
+        internalBuildAnalyzer.IsEnabled.ShouldBe(expectedEnablment);
+    }
 }
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index d3b68e4a80d..c8c14113148 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -31,7 +31,7 @@ public EndToEndTests(ITestOutputHelper output)
 
     public void Dispose() => _env.Dispose();
 
-    [Theory(Skip = "https://github.com/dotnet/msbuild/issues/10036")]
+    [Theory]
     [InlineData(true, true)]
     [InlineData(false, true)]
     [InlineData(false, false)]
@@ -51,21 +51,23 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBuild(bool buildInOutOfProces
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
+            output.ShouldContain("BC0103");
         }
         else
         {
             output.ShouldNotContain("BC0101");
             output.ShouldNotContain("BC0102");
+            output.ShouldNotContain("BC0103");
         }
     }
 
-    [Theory(Skip = "https://github.com/dotnet/msbuild/issues/10036")]
+    [Theory]
     [InlineData(true, true, "warning")]
     [InlineData(true, true, "error")]
-    [InlineData(true, true, "info")]
+    [InlineData(true, true, "suggestion")]
     [InlineData(false, true, "warning")]
     [InlineData(false, true, "error")]
-    [InlineData(false, true, "info")]
+    [InlineData(false, true, "suggestion")]
     [InlineData(false, false, "warning")]
     public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool buildInOutOfProcessNode, bool analysisRequested, string BC0101Severity)
     {
@@ -74,7 +76,7 @@ public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool bu
         var projectDirectory = Path.GetDirectoryName(projectFile.Path);
         string logFile = _env.ExpectFile(".binlog").Path;
 
-        RunnerUtilities.ExecBootstrapedMSBuild(
+        _ = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(analysisRequested ? "-analyze" : string.Empty)} -bl:{logFile}",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
@@ -93,15 +95,44 @@ public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool bu
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
+            output.ShouldContain("BC0103");
         }
         else
         {
             output.ShouldNotContain("BC0101");
             output.ShouldNotContain("BC0102");
+            output.ShouldNotContain("BC0103");
+        }
+    }
+
+    [Theory]
+    [InlineData("warning", "warning BC0101", new string[] { "error BC0101" })]
+    [InlineData("error", "error BC0101", new string[] { "warning BC0101" })]
+    [InlineData("suggestion", "BC0101", new string[] { "error BC0101", "warning BC0101" })]
+    [InlineData("default", "warning BC0101", new string[] { "error BC0101" })]
+    [InlineData("none", null, new string[] { "BC0101"})]
+    public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string expectedOutputValues, string[] unexpectedOutputValues)
+    {
+        PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, BC0101Severity);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze",
+            out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+
+        success.ShouldBeTrue();
+
+        if (!string.IsNullOrEmpty(expectedOutputValues))
+        {
+            output.ShouldContain(expectedOutputValues);
+        }
+
+        foreach (string unexpectedOutputValue in unexpectedOutputValues)
+        {
+            output.ShouldNotContain(unexpectedOutputValue);
         }
     }
 
-    [Theory(Skip = "https://github.com/dotnet/msbuild/issues/10036")]
+    [Theory]
     [InlineData(true, true)]
     [InlineData(false, true)]
     [InlineData(false, false)]
@@ -109,10 +140,10 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBinaryLogReplay(bool buildInO
     {
         PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile);
 
-        var projectDirectory = Path.GetDirectoryName(projectFile.Path);
+        string? projectDirectory = Path.GetDirectoryName(projectFile.Path);
         string logFile = _env.ExpectFile(".binlog").Path;
 
-        RunnerUtilities.ExecBootstrapedMSBuild(
+        _ = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -bl:{logFile}",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
@@ -131,100 +162,16 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBinaryLogReplay(bool buildInO
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
+            output.ShouldContain("BC0103");
         }
         else
         {
             output.ShouldNotContain("BC0101");
             output.ShouldNotContain("BC0102");
+            output.ShouldNotContain("BC0103");
         }
     }
 
-    private void PrepareSampleProjectsAndConfig(
-        bool buildInOutOfProcessNode,
-        out TransientTestFile projectFile,
-        string BC0101Severity = "warning")
-    {
-        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
-        TransientTestFile testFile = _env.CreateFile(workFolder, "somefile");
-
-        string contents = $"""
-            <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
-                
-                <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                </PropertyGroup>
-                  
-                <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                </PropertyGroup>
-                 
-                <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    <Copy SourceFiles="{testFile.Path}" DestinationFolder="{workFolder.Path}" />
-                    <MSBuild Projects=".\FooBar-Copy.csproj" Targets="Hello" />
-                </Target>
-                
-            </Project>
-            """;
-
-        string contents2 = $"""
-            <Project Sdk="Microsoft.NET.Sdk">
-                <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                </PropertyGroup>
-                                 
-                <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                </PropertyGroup>
-                                
-                <ItemGroup>
-                    <Reference Include="bin/foo.dll" />
-                </ItemGroup>
-                                
-                <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    <Copy SourceFiles="{testFile.Path}" DestinationFolder="{workFolder.Path}" />
-                </Target>
-                               
-            </Project>
-            """;
-        projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
-        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
-
-        TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
-            $"""
-            root=true
-
-            [*.csproj]
-            build_check.BC0101.IsEnabled=true
-            build_check.BC0101.Severity={BC0101Severity}
-
-            build_check.BC0102.IsEnabled=true
-            build_check.BC0102.Severity=warning
-
-            build_check.COND0543.IsEnabled=false
-            build_check.COND0543.Severity=Error
-            build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
-            build_check.COND0543.CustomSwitch=QWERTY
-
-            build_check.BLA.IsEnabled=false
-            """);
-
-        // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
-        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
-        // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
-        _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
-
-        _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
-        _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
-    }
-
     [Theory]
     [InlineData("AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
     [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
@@ -290,4 +237,46 @@ private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attribut
         attribute.Value = attributeValue;
         node.Attributes!.Append(attribute);
     }
+
+    private void PrepareSampleProjectsAndConfig(
+    bool buildInOutOfProcessNode,
+    out TransientTestFile projectFile,
+    string? BC0101Severity = null)
+    {
+        string testAssetsFolderName = "SampleAnalyzerIntegrationTest";
+        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile testFile = _env.CreateFile(workFolder, "somefile");
+
+        string contents = ReadAndAdjustProjectContent("Project1");
+        string contents2 = ReadAndAdjustProjectContent("Project2");
+
+        projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
+        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+
+        CreateEditorConfig(BC0101Severity, testAssetsFolderName, workFolder);
+
+        // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
+        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
+        // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
+        _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
+
+        _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
+        _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
+
+        _env.SetEnvironmentVariable("TEST", "FromEnvVariable");
+
+        string ReadAndAdjustProjectContent(string fileName) =>
+            File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, fileName))
+                .Replace("TestFilePath", testFile.Path)
+                .Replace("WorkFolderPath", workFolder.Path);
+    }
+
+    private void CreateEditorConfig(string? BC0101Severity, string testAssetsFolderName, TransientTestFolder workFolder)
+    {
+        string configContent = string.IsNullOrEmpty(BC0101Severity)
+            ? File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, ".editorconfigbasic"))
+            : File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, ".editorconfigcustomised")).Replace("BC0101Severity", BC0101Severity);
+
+        _ = _env.CreateFile(workFolder, ".editorconfig", configContent);
+    }
 }
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
index b6210248c0d..99d52c7f9f1 100644
--- a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -24,7 +24,7 @@ internal sealed class TestAnalyzer : BuildAnalyzer
             #region BuildAnalyzer initialization
 
             public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0000", "TestRule", "TestDescription", "TestMessage",
-                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
 
             public override string FriendlyName => "MSBuild.TestAnalyzer";
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigbasic b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigbasic
new file mode 100644
index 00000000000..6943aa8dd95
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigbasic
@@ -0,0 +1,11 @@
+root=true
+
+[*.csproj]
+build_check.BC0101.Severity=warning
+
+build_check.BC0102.Severity=warning
+build_check.BC0103.Severity=warning
+
+build_check.COND0543.Severity=Error
+build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised
new file mode 100644
index 00000000000..28ca732c908
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised
@@ -0,0 +1,11 @@
+root=true
+
+[*.csproj]
+build_check.BC0101.Severity=BC0101Severity
+
+build_check.BC0102.Severity=warning
+build_check.BC0103.Severity=warning
+
+build_check.COND0543.Severity=Error
+build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1 b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1
new file mode 100644
index 00000000000..15f7efc4ff6
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1
@@ -0,0 +1,28 @@
+<Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
+                
+   <PropertyGroup>
+       <OutputType>Exe</OutputType>
+       <TargetFramework>net8.0</TargetFramework>
+       <ImplicitUsings>enable</ImplicitUsings>
+       <Nullable>enable</Nullable>
+   </PropertyGroup>
+     
+   <PropertyGroup Condition="$(Test) == true">
+       <TestProperty>Test</TestProperty>
+   </PropertyGroup>
+
+
+   <Target Name="Hello">
+       <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+       <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
+       <MSBuild Projects=".\FooBar-Copy.csproj" Targets="Hello" />
+
+       <PropertyGroup>
+         <ReadFromEnvVariable>$(TEST)</ReadFromEnvVariable>
+       </PropertyGroup>
+
+       <Message Importance="High" Text="$(ReadFromEnvVariable)" />
+
+   </Target>
+                
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2 b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2
new file mode 100644
index 00000000000..17b8d3da249
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2
@@ -0,0 +1,22 @@
+<Project Sdk="Microsoft.NET.Sdk">
+    <PropertyGroup>
+        <OutputType>Exe</OutputType>
+        <TargetFramework>net8.0</TargetFramework>
+        <ImplicitUsings>enable</ImplicitUsings>
+        <Nullable>enable</Nullable>
+    </PropertyGroup>
+                     
+    <PropertyGroup Condition="$(Test) == true">
+        <TestProperty>Test</TestProperty>
+    </PropertyGroup>
+                    
+    <ItemGroup>
+        <Reference Include="bin/foo.dll" />
+    </ItemGroup>
+                    
+    <Target Name="Hello">
+        <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+        <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
+    </Target>
+                   
+</Project>
\ No newline at end of file
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index d3ae3878226..a2a72ede9eb 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -22,6 +22,14 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal static class BinaryTranslator
     {
+        /// <summary>
+        /// Presence of this key in the dictionary indicates that it was null.
+        /// </summary>
+        /// <remarks>
+        /// This constant is needed for a workaround concerning serializing BuildResult with a version.
+        /// </remarks>
+        private const string SpecialKeyForDictionaryBeingNull = "=MSBUILDDICTIONARYWASNULL=";
+
 #nullable enable
         /// <summary>
         /// Returns a read-only serializer.
@@ -590,6 +598,53 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua
                 dictionary = (Dictionary<string, string>)copy;
             }
 
+            /// <summary>
+            /// Translates a dictionary of { string, string } with additional entries. The dictionary might be null despite being populated.
+            /// </summary>
+            /// <param name="dictionary">The dictionary to be translated.</param>
+            /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
+            /// <param name="additionalEntries">Additional entries to be translated</param>
+            /// <param name="additionalEntriesKeys">Additional entries keys</param>
+            /// <remarks>
+            /// This overload is needed for a workaround concerning serializing BuildResult with a version.
+            /// It deserializes additional entries together with the main dictionary.
+            /// </remarks>
+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)
+            {
+                if (!TranslateNullable(dictionary))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                dictionary = new Dictionary<string, string>(count, comparer);
+                additionalEntries = new();
+
+                for (int i = 0; i < count; i++)
+                {
+                    string key = null;
+                    Translate(ref key);
+                    string value = null;
+                    Translate(ref value);
+                    if (additionalEntriesKeys.Contains(key))
+                    {
+                        additionalEntries[key] = value;
+                    }
+                    else if (comparer.Equals(key, SpecialKeyForDictionaryBeingNull))
+                    {
+                        // Presence of special key SpecialKeyForDictionaryBeingNull indicates that the dictionary was null.
+                        dictionary = null;
+
+                        // If the dictionary is null, we should have only two keys: SpecialKeyForDictionaryBeingNull, SpecialKeyForVersion
+                        Debug.Assert(count == 2);
+                    }
+                    else if (dictionary is not null)
+                    {
+                        dictionary[key] = value;
+                    }
+                }
+            }
+
             public void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> dictionaryCreator)
             {
                 if (!TranslateNullable(dictionary))
@@ -1261,6 +1316,72 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua
                 TranslateDictionary(ref copy, (NodePacketCollectionCreator<IDictionary<string, string>>)null);
             }
 
+            /// <summary>
+            /// Translates a dictionary of { string, string } adding additional entries.
+            /// </summary>
+            /// <param name="dictionary">The dictionary to be translated.</param>
+            /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
+            /// <param name="additionalEntries">Additional entries to be translated.</param>
+            /// <param name="additionalEntriesKeys">Additional entries keys.</param>
+            /// <remarks>
+            /// This overload is needed for a workaround concerning serializing BuildResult with a version.
+            /// It serializes additional entries together with the main dictionary.
+            /// </remarks>
+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)
+            {
+                // Translate whether object is null
+                if ((dictionary is null) && ((additionalEntries is null) || (additionalEntries.Count == 0)))
+                {
+                    _writer.Write(false);
+                    return;
+                }
+                else
+                {
+                    // Translate that object is not null
+                    _writer.Write(true);
+                }
+
+                // Writing a dictionary, additional entries and special key if dictionary was null. We need the special key for distinguishing whether the initial dictionary was null or empty.
+                int count = (dictionary is null ? 1 : 0) +
+                            (additionalEntries is null ? 0 : additionalEntries.Count) +
+                            (dictionary is null ? 0 : dictionary.Count);
+
+                _writer.Write(count);
+
+                // If the dictionary was null, serialize a special key SpecialKeyForDictionaryBeingNull.
+                if (dictionary is null)
+                {
+                    string key = SpecialKeyForDictionaryBeingNull;
+                    Translate(ref key);
+                    string value = string.Empty;
+                    Translate(ref value);
+                }
+
+                // Serialize additional entries
+                if (additionalEntries is not null)
+                {
+                    foreach (KeyValuePair<string, string> pair in additionalEntries)
+                    {
+                        string key = pair.Key;
+                        Translate(ref key);
+                        string value = pair.Value;
+                        Translate(ref value);
+                    }
+                }
+
+                // Serialize dictionary
+                if (dictionary is not null)
+                {
+                    foreach (KeyValuePair<string, string> pair in dictionary)
+                    {
+                        string key = pair.Key;
+                        Translate(ref key);
+                        string value = pair.Value;
+                        Translate(ref value);
+                    }
+                }
+            }
+
             public void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> dictionaryCreator)
             {
                 if (!TranslateNullable(dictionary))
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 8cc9dfbd691..9a8c3459b87 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -107,7 +107,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
 }
 internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
 {
-    public BuildCheckResultWarning(IBuildCheckResult result)
+    public BuildCheckResultWarning(IBuildCheckResult result, string code)
+        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null)
     {
         RawMessage = result.FormatMessage();
     }
@@ -131,7 +132,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
 
 internal sealed class BuildCheckResultError : BuildErrorEventArgs
 {
-    public BuildCheckResultError(IBuildCheckResult result)
+    public BuildCheckResultError(IBuildCheckResult result, string code)
+        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null)
     {
         RawMessage = result.FormatMessage();
     }
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index ca01f781d2f..37d6ff1c3d1 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -215,6 +215,20 @@ public BuildMessageEventArgs(
             this.endColumnNumber = endColumnNumber;
         }
 
+        protected BuildMessageEventArgs(
+           string message,
+           string file,
+           int lineNumber,
+           int columnNumber,
+           MessageImportance importance)
+            : base(message, helpKeyword: null, senderName: null)
+        {
+            this.importance = importance;
+            this.file = file;
+            this.lineNumber = lineNumber;
+            this.columnNumber = columnNumber;
+        }
+
         private MessageImportance importance;
 
         [OptionalField(VersionAdded = 2)]
@@ -311,7 +325,11 @@ public MessageImportance Importance
         /// <summary>
         /// File associated with event.
         /// </summary>
-        public string File => file;
+        public string File
+        {
+            get => file;
+            internal set => file = value;
+        }
 
         /// <summary>
         /// Line number of interest in associated file.
diff --git a/src/Framework/EnvironmentVariableReadEventArgs.cs b/src/Framework/EnvironmentVariableReadEventArgs.cs
index 3d246fb6c03..ef5bb651404 100644
--- a/src/Framework/EnvironmentVariableReadEventArgs.cs
+++ b/src/Framework/EnvironmentVariableReadEventArgs.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -10,7 +13,6 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for the environment variable read event.
     /// </summary>
-    [Serializable]
     public class EnvironmentVariableReadEventArgs : BuildMessageEventArgs
     {
         /// <summary>
@@ -33,14 +35,49 @@ public EnvironmentVariableReadEventArgs(
             string message,
             string helpKeyword = null,
             string senderName = null,
-            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
-        {
-            this.EnvironmentVariableName = environmentVariableName;
-        }
+            MessageImportance importance = MessageImportance.Low)
+            : base(message, helpKeyword, senderName, importance) => EnvironmentVariableName = environmentVariableName;
+
+        /// <summary>
+        /// Initializes an instance of the EnvironmentVariableReadEventArgs class.
+        /// </summary>
+        /// <param name="environmentVarName">The name of the environment variable that was read.</param>
+        /// <param name="environmentVarValue">The value of the environment variable that was read.</param>
+        /// <param name="file">file associated with the event</param>
+        /// <param name="line">line number (0 if not applicable)</param>
+        /// <param name="column">column number (0 if not applicable)</param>
+        public EnvironmentVariableReadEventArgs(
+            string environmentVarName,
+            string environmentVarValue,
+            string file,
+            int line,
+            int column)
+            : base(environmentVarValue, file, line, column, MessageImportance.Low) => EnvironmentVariableName = environmentVarName;
 
         /// <summary>
         /// The name of the environment variable that was read.
         /// </summary>
         public string EnvironmentVariableName { get; set; }
+
+        // <summary>
+        // The file name where environment variable is used.
+        // </summary>
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+            writer.Write(EnvironmentVariableName);
+            writer.Write7BitEncodedInt(LineNumber);
+            writer.Write7BitEncodedInt(ColumnNumber);
+            writer.WriteOptionalString(File);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+            EnvironmentVariableName = reader.ReadString();
+            LineNumber = reader.Read7BitEncodedInt();
+            ColumnNumber = reader.Read7BitEncodedInt();
+            File = reader.ReadOptionalString() ?? string.Empty;
+        }
     }
 }
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index edb6e96dfc7..edf5b47765e 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -319,6 +319,19 @@ void TranslateArray<T>(ref T[] array)
         /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
         void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer);
 
+        /// <summary>
+        /// Translates a dictionary of { string, string } adding additional entries.
+        /// </summary>
+        /// <param name="dictionary">The dictionary to be translated.</param>
+        /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
+        /// <param name="additionalEntries">Additional entries to be translated</param>
+        /// <param name="additionalEntriesKeys">Additional entries keys</param>
+        /// <remarks>
+        /// This overload is needed for a workaround concerning serializing BuildResult with a version.
+        /// It serializes/deserializes additional entries together with the main dictionary.
+        /// </remarks>
+        void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys);
+
         void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> collectionCreator);
 
         void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer);
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 8e9d1e09d00..9bca9afa1a5 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -359,6 +359,14 @@ public bool? LogPropertiesAndItemsAfterEvaluation
         /// </remarks>
         public readonly bool UseMinimalResxParsingInCoreScenarios = Environment.GetEnvironmentVariable("MSBUILDUSEMINIMALRESX") == "1";
 
+        /// <summary>
+        /// Escape hatch to ensure msbuild produces the compatible build results cache without versioning.
+        /// </summary>
+        /// <remarks>
+        /// Escape hatch for problems arising from https://github.com/dotnet/msbuild/issues/10208.
+        /// </remarks>
+        public readonly bool DoNotVersionBuildResult = Environment.GetEnvironmentVariable("MSBUILDDONOTVERSIONBUILDRESULT") == "1";
+
         private bool _sdkReferencePropertyExpansionInitialized;
         private SdkReferencePropertyExpansionMode? _sdkReferencePropertyExpansionValue;
 
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 8edfbcb9363..2307688888d 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -138,11 +138,11 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Vypíše hodnotu jedné nebo více zadaných vlastností
+                     po vyhodnocení bez provedení sestavení, nebo pokud je
+                     použita volba -targets nebo volba -getTargetResult,
+                     vypíše hodnoty po sestavení.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -157,12 +157,12 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Vypíše hodnotu jedné nebo více zadaných položek
+                     a jejich přidružená metadata po vyhodnocení bez
+                     provedení sestavení, nebo pokud je použita volba -targets
+                     nebo volba -getTargetResult, vypíše hodnoty
+                     po sestavení.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -174,9 +174,9 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Vypíše výstupní hodnotu jednoho nebo více cílů a
+                     zadané cíle se provedou.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -199,20 +199,20 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+        <target state="translated">  -featureAvailability:featureName,...
+                     Zkontroluje dostupnost funkce. Výsledkem je jeden
+                     z řetězců Undefined, Available, NotAvailable a
+                     Preview.
+                     - Undefined – Dostupnost funkce je nedefinovaná
+                     (název funkce je pro kontrolu dostupnosti funkce
+                     neznámý).
+                     - NotAvailable – Funkce není k dispozici (na rozdíl
+                     od možnosti Undefined je název funkce nástroji pro
+                     kontrolu dostupnosti funkce znám a ten ví, že funkce není
+                     podporována aktuálním modulem MSBuild).
+                     - Available – Funkce je k dispozici.
+                     - Preview – Funkce je ve verzi Preview (není stabilní).
+                     (Krátký tvar: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -232,17 +232,17 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Povolí nebo zakáže protokolovací nástroj terminálu. Protokolovací nástroj
+                     terminálu poskytuje v konzole v reálném čase rozšířený výstup
+                     sestavení, který je logicky uspořádán podle projektů a je navržen tak,
+                     aby zvýrazňoval informace s možností reakce. Pokud chcete, aby byl protokolovací nástroj terminálu použit,
+                     pouze pokud není přesměrován standardní výstup, zadejte
+                     auto (nebo použijte volbu bez argumentů). Výstup neparsujte
+                     ani jinak nespoléhejte na to, že v budoucích verzích zůstane
+                     beze změny. Tato možnost je dostupná v MSBuildu 17.8 a
+                     novějších verzích.
+                     (Krátký tvar: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -269,23 +269,23 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parametry pro protokolovací nástroj terminálu. (Krátký tvar: -tlp)
+                     Dostupné parametry.
+                        default – Určuje výchozí chování protokolovacího
+                        nástroje terminálu. Vyžaduje jednu z následujících hodnot:
+                           - on, true vynutí použití TerminalLoggeru,
+                            i kdyby byl zakázaný.
+                           - off, false vynutí nepoužívání TerminalLoggeru,
+                            i kdyby byl povolený.
+                           - auto povolí TerminalLogger, když to terminál
+                            podporuje a relace nemá přesměrované
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosity – Přepíše nastavení -verbosity pro tento
+                        protokolovací nástroj.
+                        showCommandLine – Zobrazí zprávy TaskCommandLineEvent.
 
-                      Example:
+                      Příklad:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -301,12 +301,12 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Přesměruje výstup get* do souboru.
 
-                     Example:
+                     Příklad:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Tím se zapíše hodnota vlastnosti Bar do souboru Biz.txt.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1545,7 +1545,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: Je nutné zadat název funkce pro přepínač featureAvailability.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 271903d0a37..d18271f2f41 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -138,11 +138,11 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Schreiben Sie den Wert einer oder mehrerer angegebener Eigenschaften
+                     nach der Auswertung aus, ohne den Build auszuführen, oder wenn entweder
+                     die Option "-getTargetResult" oder die Option "-getTargetResult" verwendet
+                     wird, schreiben Sie die Werte nach dem Build aus.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -157,12 +157,12 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Schreiben Sie den Wert eines oder mehrerer angegebener Elemente und
+                     die zugehörigen Metadaten nach der Auswertung ohne
+                     Ausführen des Builds aus, oder wenn entweder die Option "-targets"
+                     oder die Option "-getTargetResult" verwendet wird, schreiben Sie
+                     die Werte nach dem Build aus.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -174,9 +174,9 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Schreiben Sie den Ausgabewert eines oder mehrerer Ziele aus und
+                     die angegebenen Ziele werden ausgeführt.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -199,20 +199,20 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
+        <target state="translated">  -featureAvailability:featureName,...
+                     Überprüft die Verfügbarkeit von Features. Das Ergebnis ist eine der
+                     Zeichenfolgen "Undefined", "Available", "NotAvailable" und
                      "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+                     –Undefinied: Die Verfügbarkeit des Features ist nicht definiert
+                     (der Featurename ist für den Prüfer der Featureverfügbarkeit
+                     unbekannt)
+                     -NotAvailable: Das Feature ist nicht verfügbar (im Gegensatz zu
+                     "Undefined", wo der Featurename für den Prüfer der Featureverfügbarkeit
+                     bekannt ist und er weiß, dass das Feature von der
+                     aktuellen MSBuild-Engine nicht unterstützt wird)
+                     -Available: Das Feature ist verfügbar
+                     -Preview: Das Feature befindet sich in der Vorschau (nicht stabil)
+                     (Kurzform: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -232,17 +232,17 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Aktiviert oder deaktiviert die Terminalprotokollierung. Terminal-Logger
+                     bietet verbesserte Buildausgabe auf der Konsole in Echtzeit,
+                     logisch nach Projekt organisiert und entwickelt, um
+                     verwertbare Informationen hervorzuheben. Geben Sie "auto" an (oder verwenden Sie die Option
+                     ohne Argumente), um den Terminal-Logger nur zu verwenden, wenn die
+                     Standardausgabe nicht umgeleitet wird. Analysieren Sie die Ausgabe nicht
+                     oder vertrauen Sie darauf, dass sie in zukünftigen
+                     Versionen unverändert bleibt. Diese Option ist in MSBuild 17.8 und
+                     später verfügbar.
+                     (Kurzform: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -269,23 +269,23 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameter für Terminal-Logger. (Kurzform: -tlp)
+                     Die verfügbaren Parameter.
+                        default: Gibt das Standardverhalten des Terminal-
+                        Loggers an. Erfordert einen der folgenden Werte:
+                           – "on", "true" erzwingt die Verwendung von TerminalLogger, auch
+                            wenn er deaktiviert werden sollte.
+                           – "off", "true" erzwingt die Nichtverwendung von TerminalLogger, auch
+                            wenn er aktiviert werden sollte.
+                           – "auto" aktiviert TerminalLogger, wenn das Terminal
+                            dies unterstützt, und die Sitzung nicht umgeleitet wurde
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosity: Überschreiben Sie die Einstellung "-verbosity" für diesen
+                        Logger
+                        showCommandLine: TaskCommandLineEvent-Meldungen anzeigen
 
-                      Example:
+                      Beispiel: 
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -301,12 +301,12 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Leiten Sie die Ausgabe von get* in eine Datei um.
 
-                     Example:
+                     Beispiel: 
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Dadurch wird der Wert der Eigenschaftsleiste in Biz.txt geschrieben.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1533,7 +1533,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: Es muss ein Featurename für den featureAvailability-Schalter angegeben werden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 4f462539022..cd2d91be5ab 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -137,11 +137,11 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Escriba el valor de una o varias propiedades especificadas
+                     después de la evaluación, sin ejecutar la compilación, o si se usa
+                     la opción -targets o la opción -getTargetResult,
+                     escriba los valores después de la compilación.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Escriba el valor de uno o varios elementos especificados y
+                     sus metadatos asociados después de la evaluación sin
+                     ejecutar la compilación, o si se usa la opción -targets
+                     o la opción -getTargetResult, escriba
+                     los valores después de la compilación.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Escriba el valor de salida de uno o varios destinos y
+                     los destinos especificados se ejecutarán.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,20 +198,20 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
+        <target state="translated">  -featureAvailability:featureName,...
+                     Compruebe la disponibilidad de la característica. El resultado es una de las
+                     cadenas "Undefined", "Available", "NotAvailable" y
                      "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+                     - Undefined: la disponibilidad de la característica no está definida
+                     (el nombre de la característica es desconocido para el comprobador de disponibilidad
+                     de características)
+                     - NotAvailable: la característica no está disponible (a diferencia de
+                     Undefined, el nombre de la característica es conocido para el comprobador
+                     de disponibilidad de características y sabe que la característica no
+                     se admite en el motor de MSBuild actual)
+                     - Available: la característica está disponible
+                     - Preview: la característica está en versión preliminar (no estable)
+                     (Forma corta: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -231,17 +231,17 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Habilite o deshabilite el registrador de terminal. El registrador de terminal
+                     proporciona una salida de compilación mejorada en la consola en tiempo real,
+                     organizada lógicamente por proyecto y diseñada para resaltar
+                     la información accionable. Especifique auto (o use la opción
+                     sin argumentos) para utilizar el registrador de terminal solo si la
+                     salida estándar no se redirige. No analice la salida
+                     ni confíe en que permanezca sin cambios en versiones
+                     futuras. Esta opción está disponible en MSBuild 17.8 y
+                     posteriores.
+                     (Forma corta: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -268,23 +268,23 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parámetros para el registrador de terminal. (Forma corta: -tlp)
+                     Los parámetros disponibles.
+                        default--Especifica el comportamiento predeterminado del registrador
+                        de terminal. Requiere uno de los siguientes valores:
+                           - `on`, `true` fuerza el uso de TerminalLogger aunque
+                            esté deshabilitado.
+                           - `off`, `false` fuerza que no se utilice TerminalLogger
+                            aunque esté habilitado.
+                           - `auto` habilita TerminalLogger cuando el terminal
+                            lo admite y la sesión no ha redirigido
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosity--Reemplaza el valor -verbosity de este
+                        registrador
+                        showCommandLine--Muestra los mensajes de TaskCommandLineEvent
 
-                      Example:
+                      Ejemplo:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +300,12 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Redirija la salida de get* a un archivo.
 
-                     Example:
+                     Ejemplo:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Esto escribe el valor de la propiedad Bar en Biz.txt.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1539,7 +1539,7 @@ Esta marca es experimental y puede que no funcione según lo previsto.
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: debe proporcionar un nombre de característica para el conmutador featureAvailability.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 8735df374b9..26e94894cf4 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -137,11 +137,11 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Notez la valeur d’une ou de plusieurs propriétés spécifiées
+                     après l’évaluation, sans exécuter la build, ou si
+                     l’option -targets ou l’option -getTargetResult est
+                     utilisé, écrivez les valeurs après la génération.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Notez la valeur d’un ou de plusieurs éléments spécifiés et
+                     leurs métadonnées associées après l’évaluation sans
+                     l’exécution de la build, ou si l’option -targets
+                     ou l’option -getTargetResult est utilisée, écrivez
+                     les valeurs après la génération.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Notez la valeur de sortie d’une ou de plusieurs cibles et
+                     les cibles spécifiées seront exécutées.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,20 +198,20 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+        <target state="translated">  -featureAvailability:featureName,...
+                     Vérifiez la disponibilité des fonctionnalités. Le résultat est l’une des
+                     chaînes « Undefined », « Available », « NotAvailable » et
+                     « Aperçu ».
+                     - Non défini : la disponibilité de la fonctionnalité n’est pas définie
+                     (le nom de la fonctionnalité est inconnu de la disponibilité des fonctionnalités
+                     vérificateur)
+                     - NotAvailable : la fonctionnalité n’est pas disponible (contrairement à
+                     Non défini, le nom de la fonctionnalité est connu de la fonctionnalité
+                     et sait que la fonctionnalité n’est pas
+                     prise en charge par le moteur MSBuild actuel)
+                     - Disponible : la fonctionnalité est disponible
+                     - Préversion : la fonctionnalité est en préversion (non stable)
+                     (Forme abrégée : -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -231,17 +231,18 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Activez ou désactivez l’enregistreur d’événements du terminal. Enregistreur d’événements terminal
+                     fournit une sortie de build améliorée sur la console en temps réel,
+                     organisé logiquement par projet et conçu pour mettre en évidence
+                     les informations exploitables. Spécifier automatiquement (ou utiliser l’option
+                     sans arguments) pour utiliser l’enregistreur d’événements de terminal uniquement si le
+                     la sortie standard n’est pas redirigée. N’analysez pas la sortie
+                     ou reposez-vous sur le fait qu’il reste inchangé dans les
+futures
+                     versions. Cette option est disponible dans MSBuild 17.8 et
+                     ultérieures.
+                     (Forme abrégée : -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -268,23 +269,23 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Paramètres de l’enregistreur d’événements de terminal. (Forme abrégée : -tlp)
+                     Paramètres disponibles.
+                        default --Spécifie le comportement par défaut du terminal
+                        enregistreur. Elle nécessite l’une des valeurs suivantes :
+                           - 'on', 'true' force TerminalLogger à être utilisé même
+                            quand il serait désactivé.
+                           - 'off', 'false' force TerminalLogger à ne pas être utilisé
+                            même lorsqu’il serait activé.
+                           - « auto » active TerminalLogger lorsque le terminal
+                            la prend en charge et la session n’a pas redirigée
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosity--Remplacer le paramètre -verbosity pour cet
+                        enregistreur
+                        showCommandLine--Afficher les messages TaskCommandLineEvent
 
-                      Example:
+                      Exemple :
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +301,12 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Rediriger la sortie de get* vers un fichier.
 
-                     Example:
+                     Exemple :
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Cette opération écrit la valeur de la barre de propriétés dans Biz.txt.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1532,7 +1533,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: doit fournir un nom de fonctionnalité pour le commutateur featureAvailability.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index a04f253b4d2..bc718c445d7 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -137,11 +137,11 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Scrivere il valore di una o più proprietà specificate
+                     dopo la valutazione, senza eseguire la compilazione o se
+                     si usa sia l'opzione -targets che l’opzione -getTargetResult
+                     scrivere i valori dopo la compilazione.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Scrivere il valore di uno o più elementi specificati e
+                     i metadati associati dopo la valutazione senza
+                     eseguire la compilazione o in caso si usi l’opzione -targets
+                     oppure l'opzione -getTargetResult, scrivere
+                     i valori dopo la compilazione.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Scrivere il valore di output di una o più destinazioni
+                     per eseguire le destinazioni specificate.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,20 +198,21 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+        <target state="translated">  -featureAvailability:featureName,...
+                     Verificare la disponibilità delle funzionalità. Il risultato è uno delle
+                     stringhe "Non definito", "Disponibile", "Non disponibile" e
+                     "Anteprima".
+                     - Non definito: la disponibilità della funzionalità non è definita
+                     (Il nome della funzionalità non è noto al controllo
+                     della disponibilità delle funzionalità)
+                     - Non disponibile: la funzionalità non è disponibile (a differenza di
+                     Non definito, dove il nome della funzionalità è noto al controllo della disponibilità della funzionalità
+,
+                     che sa che la funzionalità non è
+                     supportata dal motore MSBuild corrente)
+                     - Disponibile: la funzionalità è disponibile
+                     - Anteprima : la funzionalità è in anteprima (non stabile)
+                     (Forma breve: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -231,17 +232,17 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:automatico, attivato, disattivato]
+                     Abilitare o disabilitare il logger del terminale. Logger del terminale
+                     fornisce output di compilazione avanzati in tempo reale sulla console,
+                     organizzato in maniera logica in base al progetto e progettato per evidenziare
+                     dati analitici interattivi. Specificare automatico (o usare l'opzione
+                     senza argomenti) per usare il logger del terminale solo se l’
+                     output standard non viene reindirizzato. Non analizzare l'output
+                     oppure affidarsi al fatto che non verrà modificato nelle future
+                     versioni. Questa opzione è disponibile in MSBuild 17.8 e
+                     versioni successive.
+                     Forma breve: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -268,23 +269,23 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parametri per il logger del terminale. Forma breve: -tlp)
+                     Parametri disponibili.
+                        impostazione predefinita- Specifica il comportamento predefinito del terminale
+                        logger. Richiede uno dei valori seguenti:
+                           - 'attivato', 'vero' forza l'uso di TerminalLogger anche
+                            se venisse disabilitato.
+                           - 'disattivato', 'falso' forza l'uso di TerminalLogger anche
+                            se venisse abilitato.
+                           - 'automatico' abilita TerminalLogger quando il terminale
+                            lo supporta e la sessione non ha reindirizzato il livello di dettaglio
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
+                        -- Eseguire l'override dell'impostazione del livello di dettaglio per questo
                         logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        showCommandLine--Mostra i messaggi TaskCommandLineEvent
 
-                      Example:
+                      Esempio:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +301,12 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Reindirizza l'output da get* in un file.
 
-                     Example:
-                     -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Esempio:
+                     -getProperty:barra -getResultOutputFile:Biz.txt
+                     Il valore della barra delle proprietà viene scritto in Biz.txt.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1543,7 +1544,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: È necessario fornire un nome funzionalità per l’opzione featureAvailability.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 91331e97550..8d9e93d6915 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -137,12 +137,12 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
-    </target>
+        <target state="translated">  -getProperty:propertyName,...
+                    1 つ以上の指定されたプロパティの値を書き出し
+                    評価後、ビルドを実行せずに、または
+                    -targets オプションまたは -getTargetResult オプションが
+                    使用して、ビルド後に値を書き出します。
+   </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -156,13 +156,13 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
-    </target>
+        <target state="translated">  -getItem:itemName,...
+                    1 つ以上の指定された項目の値を書き出し、
+                    評価後に関連付けられたメタデータを
+                    ビルドを実行せずに、または -targets オプション
+                    または -getTargetResult オプションが使用されている場合は、書き込み
+                    ビルド後の値。
+   </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -173,10 +173,10 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
-    </target>
+        <target state="translated">  -getTargetResult:targetName,...
+                    1 つ以上のターゲットの出力値を書き出し、
+                    指定したターゲットが実行されます。
+   </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -198,21 +198,21 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
-    </target>
+        <target state="translated">  -featureAvailability:featureName,...
+                    機能の可用性を確認します。結果は、次のいずれかになります。
+                    文字列 "Undefined"、"Available"、"NotAvailable"、および
+                    "Preview" です。
+                    - Undefined - 機能の可用性は未定義です
+                    (機能名が機能の可用性に関して不明です
+                    チェッカー)
+                    - NotAvailable - この機能は使用できません
+                    Undefined とは異なり、機能名は機能に認識されています
+                    可用性チェッカーは、この機能が
+                    現在の MSBuild エンジンでサポートされていないことを理解しています)
+                    - Available - この機能は使用可能です
+                    - Preview - 機能はプレビュー段階です (安定していません)
+                    (短い形式: -fa)
+   </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -231,18 +231,18 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
-    </target>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                    ターミナル ロガーを有効または無効にします。ターミナル ロガーは
+                    本体のビルド出力がリアルタイムで強化され、
+                    プロジェクトごとに論理的に整理され、強調表示するように設計されています
+                    アクション可能な情報です。auto を指定する (またはオプションを使用する)
+                    引数を指定せずに) ターミナル ロガーを使用する場合は、
+                    標準出力はリダイレクトされません。出力を解析しないでください
+                    それ以外の場合は、将来変更されずに残っている
+                    バージョン。このオプションは、MSBuild 17.8 以降で利用可能です
+                    以降で。
+                    (短い形式: -tl)
+   </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -268,25 +268,26 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
-                            stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                    ターミナル ロガーへのパラメーター。(短い形式: -tlp) 
+                    使用可能なパラメーター。
+                       default -- ターミナル 
+ の既定の動作を指定します
+                       ロガー。次のいずれかの値が必要です:
+                          - `on`、`true` は TerminalLogger を強制的に使用します
+                           無効である場合も同様です。
+                          - `off`、`false` は TerminalLogger を使用しないように強制します
+                           有効である場合も同様です。
+                          - `auto` は、次の場合にターミナルで TerminalLogger を有効にします
+                           サポートされており、セッションがリダイレクトされていない場合です
+                           stdout/stderr
+                       verbosity-- 下記の verbosity 設定をオーバーライドします
+                       logger
+                       showCommandLine -- TaskCommandLineEvent メッセージを表示します
 
-                      Example:
-                        -tlp:default=auto;verbosity=diag;shownCommandLine
-    </target>
+                     例: 
+                       -tlp:default=auto;verbosity=diag;shownCommandLine
+   </target>
         <note>
       LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -300,13 +301,13 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                    get* からの出力をファイルにリダイレクトします。
 
-                     Example:
-                     -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
-    </target>
+                    例: 
+                    -getProperty:Bar -getResultOutputFile:Biz.txt
+                    これにより、プロパティ Bar の値が Biz.txt に書き込まれます。
+   </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -1532,7 +1533,7 @@
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: featureAvailability スイッチの機能名を指定する必要があります。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index fd626b83709..822652c6a46 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -137,11 +137,11 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     빌드를 실행하지 않고 평가 후
+                     지정된 속성 중 하나 이상의 값을 작성하거나,
+                     -targets 옵션 또는 -getTargetResult 옵션을 사용하는 경우
+                     빌드 후 값을 작성합니다.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     빌드를 실행하지 않고 평가 후
+                     지정된 항목 중 하나 이상의 값 및
+                     연결된 해당 메타데이터를 작성하거나,
+                     -targets 옵션 또는 -getTargetResult 옵션을 사용하는 경우
+                     빌드 후 값을 작성합니다.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     대상 하나 이상의 출력 값을 작성하면
+                     지정된 대상이 실행됩니다.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,20 +198,20 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+        <target state="translated">  -featureAvailability:featureName,...
+                     기능 가용성을 확인합니다. 결과는
+                     문자열 "Undefined", "Available", "NotAvailable" 및
+                     "Preview" 중 하나입니다.
+                     - 정의되지 않음 - 기능의 가용성이 정의되지 않았습니다
+                     (기능 가용성 검사기에서 기능 이름을 인식할 수
+                     없음).
+                     - NotAvailable - 기능을 사용할 수 없습니다(
+                     정의되지 않음과는 달리, 기능 가용성 검사가에서 기능 이름을
+                     인식할 수 있으며 기능이 현재 MSBuild 엔진에서 지원되지
+                     않는 것으로 인식하고 있음).
+                     - Available - 기능을 사용할 수 있습니다.
+                     - Preview - 기능이 미리 보기 상태로 제공됩니다(안정적이지 않음).
+                     (약식: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -231,17 +231,17 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     터미널 로거를 사용하거나 사용하지 않도록 설정합니다. 터미널 로거
+                     는 콘솔에서 향상된 빌드 출력을 실시간으로 제공합니다.
+                     이러한 출력은 프로젝트별로 논리적으로 구성되고 실행 가능한 정보를
+                     강조 표시하도록 설계되어 있습니다. 자동을 지정(또는 인수 없이 옵션
+                     사용)하여 터미널 로거를 사용합니다. 단, 이 경우
+                     표준 출력이 리디렉션되지 않아야 합니다. 출력을 구문 분석하지 않습니다.
+                     그렇지 않을 경우 이후 버전에서 변경되지 않은 상태로
+                     유지됩니다. 이 옵션은 MSBuild 17.8 이상 버전에서
+                     제공됩니다.
+                     (약식: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -268,23 +268,24 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     터미널 로거에 대한 매개 변수입니다. (약식: -tlp)
+                     사용 가능한 매개 변수입니다.
+                        default--터미널의 기본 동작을 지정합니다.
+                        로거입니다. 다음 값 중 하나가 필요합니다.
+                           - 'on', 'true'는 terminalLogger를 사용하도록 강제하며,
+                            이는 사용하지 않도록 설정된 경우에도 마찬가지입니다.
+                           - 'off', 'false'는 terminalLogger를 사용하지 않도록 강제하며,
+                            이는 사용하도록 설정된 경우에도 마찬가지입니다.
+                           - 'auto'는 터미널이
+                            지원하고 세션이 리디렉션되지 않을 때 TerminalLogger를 사용하도록 설정합니다.
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosity--이
+로거에 대한 -verbosity 설정을
+                        재정의합니다.
+                        showCommandLine--TaskCommandLineEvent 메시지를 표시합니다.
 
-                      Example:
+                      예:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +301,12 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     get*에서 파일로 출력을 리디렉션합니다.
 
-                     Example:
+                     예:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     그러면 속성 Bar의 값이 Biz.txt에 기록됩니다.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1532,7 +1533,7 @@
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: featureAvailability 스위치에 대한 기능 이름을 제공해야 합니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 13bdf510744..d628509728e 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -137,11 +137,11 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Zapisz wartość co najmniej jednej określonej właściwości
+                     po zakończeniu oceny, bez wykonywania kompilacji lub jeśli
+                     któraś z opcji -targets lub -getTargetResult jest
+                     użyta, zapisz wartości po kompilacji.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Zapisz wartość co najmniej jednego określonego elementu i
+                     ich skojarzonych metadanych po ocenie bez
+                     wykonywania kompilacji lub jeśli jest użyta któraś z opcji -targets
+                     lub -getTargetResult, zapisz
+                     wartości po kompilacji.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Zapisz wartość wyjściową co najmniej jednego elementu docelowego, a
+                     określone elementy docelowe zostaną wykonane.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,20 +198,20 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+        <target state="translated">  -featureAvailability:featureName,...
+                     Sprawdź dostępność funkcji. Wynikiem jest jeden z
+                     ciągów „Undefined”, „Available”, „NotAvailable” i
+                     „Preview”.
+                     — Undefined — dostępność funkcji jest niezdefiniowana
+                     (nazwa funkcji jest nieznana dla dostępności funkcji
+                     kontroler)
+                     — NotAvailable — funkcja jest niedostępna (w przeciwieństwie do
+                     Undefined, nazwa funkcji jest znana kontrolerowi
+                     dostępności funkcji i wie on, że funkcja nie jest
+                     obsługiwana przez bieżący aparat MSBuild)
+                     — Available — funkcja jest dostępna
+                     — Preview — funkcja jest w wersji zapoznawczej (niestabilna)
+                     (Krótka forma: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -231,17 +231,17 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Włącz lub wyłącz rejestrator terminali. Rejestrator terminali
+                     udostępnia ulepszone dane wyjściowe kompilacji na konsoli w czasie rzeczywistym,
+                     uporządkowane logicznie według projektu i zaprojektowane do wyróżniania
+                     informacji umożliwiających podejmowanie działań. Określ auto (lub użyj opcji
+                     bez argumentów), aby używać rejestratora terminali tylko wtedy, gdy
+                     standardowe dane wyjściowe nie są przekierowywane. Nie analizowanie danych wyjściowych
+                     lub inaczej – poleganie na nich pozostanie niezmienione w przyszłych
+                     wersjach. Ta opcja jest dostępna w wersji MSBuild 17.8 i
+                     późniejszych.
+                     (Krótka forma: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -268,23 +268,23 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parametry rejestratora terminali. (Krótka forma: -tlp)
+                     Dostępne parametry.
+                        default-- określa domyślne zachowanie rejestratora
+                        terminalu. Wymaga jednej z następujących wartości:
+                           — „on”, „true” wymusza użycie elementu TerminalLogger nawet
+                            kiedy zostanie on wyłączony.
+                           — „off”, „false” wymusza nieużywanie elementu TerminalLogger
+                            nawet wtedy, gdy zostanie on włączony.
+                           — „auto” włącza element TerminalLogger, gdy terminal
+                            go obsługuje, a sesja nie została przekierowana
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosity-- zastąp ustawienie -verbosity dla tego
+                        rejestratora
+                        showCommandLine-- pokaż komunikaty TaskCommandLineEvent
 
-                      Example:
+                      Przykład:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +300,12 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Przekieruj dane wyjściowe z polecenia get* do pliku.
 
-                     Example:
+                     Przykład:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Spowoduje to zapisywanie wartości paska właściwości w pliku Biz.txt.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1543,7 +1543,7 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: należy podać nazwę funkcji dla przełącznika dostępności funkcji.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 7b3e9bfa84d..46b4219c1ce 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -137,11 +137,11 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Grava o valor de uma ou mais propriedades especificadas
+                     após a avaliação, sem executar a compilação, ou se
+                     a opção -targets ou a opção -getTargetResult for
+                     for usada, escreva os valores após a compilação.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Escreve o valor de um ou mais itens especificados e
+                     seus metadados associados após a avaliação sem
+                     executar a compilação, ou se a opção -targets
+                     ou a opção -getTargetResult for usada, escreva
+                     os valores após a compilação.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Escreve o valor da saída de um ou mais destinos e
+                     os destinos especificados serão executados.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,20 +198,20 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+        <target state="translated">  -featureAvailability:featureName,...
+                     Verifica a disponibilidade do recurso. O resultado é uma das 
+                     cadeias de caracteres "Indefinido", "Disponível", "Não Disponível" e
+                     "Visualizar".
+                     - Indefinido - a disponibilidade do recurso é indefinida
+                     (o nome do recurso é desconhecido para o verificador de disponibilidade do recurso
+                     verificador)
+                     - NotAvailable - o recurso não está disponível (ao contrário de
+                     Indefinido, o nome do recurso é conhecido pelo verificador de disponibilidade do recurso
+                     verificador de disponibilidade e ele sabe que o recurso não
+                     tem suporte pelo mecanismo MSBuild atual)
+                     - Disponível - o recurso está disponível
+                     - Visualização - o recurso está em pré-visualização (não é estável)
+                     (Forma abreviada: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -231,17 +231,17 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Habilitar ou desabilitar o registrador de terminal. O agente do terminal
+                     fornece saída de compilação aprimorada no console em tempo real,
+                     organizada logicamente por projeto e projetada para destacar
+                     informações acionáveis. Especificar automaticamente (ou use a opção
+                     sem argumentos) para usar o registrador de terminal somente se a
+                     a saída padrão não for redirecionada. Não analise a saída
+                     nem confie que ela permanecerá inalterada em futuras
+                     versões. Essa opção está disponível no MSBuild 17.8 e
+                     posterior.
+                     (Forma abreviada: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -268,23 +268,23 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parâmetros para o registrador de terminal. (Forma abreviada: -tlp)
+                     Os parâmetros disponíveis.
+                        default--Especifica o comportamento padrão do agente de
+                        terminal. Requer um dos seguintes valores:
+                           - `on`, `true` força o TerminalLogger a ser usado mesmo
+                            quando ele estiver desabilitado.
+                           - `off`, `false` força o TerminalLogger a não ser usado
+                            mesmo quando estiver habilitado.
+                           - `auto` ativa o TerminalLogger quando o terminal
+                            der suporte e a sessão não tiver redirecionado
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosidade--Substitui a configuração de -verbosidade para esse
+                        agente
+                        showCommandLine--Mostra mensagens de TaskCommandLineEvent
 
-                      Example:
+                      Exemplo:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +300,12 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Redirecionar a saída de get* para um arquivo.
 
-                     Example:
+                     Exemplo:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Isso grava o valor da propriedade Bar em Biz.txt.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1533,7 +1533,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: É necessário fornecer um nome de recurso para a chave featureAvailability.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 1bd2774c5e0..647519e7158 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -137,11 +137,11 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Запишите значение одного или нескольких указанных свойств 
+                     после оценки, не выполняя сборку, или, если 
+                     опция -targets или опция -getTargetResult 
+                     используется, запишите значения после сборки.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Запишите значение одного или нескольких указанных элементов и 
+                     связанных с ними метаданных после оценки без 
+                     выполнения сборки или, если используется опция -targets 
+                     или опция -getTargetResult, запишите 
+                     значения после сборки. 
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Запишите выходное значение одной или нескольких целей и 
+                     указанные цели будут выполнены. 
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,19 +198,19 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
+        <target state="translated">  -featureAvailability:featureName,...
+                     Проверьте доступность функции. Результатом является одна из 
+                     строк "Неопределено", "Доступно", "Недоступно" и 
+                     "Предварительный просмотр". 
+                     - Не определено — доступность функции не определена 
+                     (имя функции неизвестно средству проверки доступности 
+                     функции) 
+                     - NotAvailable — функция недоступна (в отличие от 
+                     Не определено, имя функции известно средству проверки 
+                     доступности функции, и ему известно, что функция не 
+                     поддерживается текущим механизмом MSBuild) 
+                     - Доступно – функция доступна 
+                     - Предварительная версия — функция находится в предварительной версии (не стабильна) 
                      (Short form: -fa)
     </target>
         <note>
@@ -231,16 +231,16 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
+        <target state="translated">  -terminalLogger[:авто,вкл,выкл] 
+                     Включите или отключите регистратор терминала. Регистратор терминала 
+                     обеспечивает расширенный вывод сборки на консоль в режиме реального времени, 
+                     логически организованный по проектам и предназначенный для выделения 
+                     полезной информации. Укажите авто (или используйте опцию 
+                     без аргументов), чтобы использовать регистратор терминала только в том случае, если 
+                     стандартный вывод не перенаправляется. Не анализируйте выходные данные 
+                     и не полагайтесь на то, что они останутся неизменными в будущих 
+                     версиях. Этот параметр будет доступен в MSBuild 17.8 и 
+                     позже. 
                      (Short form: -tl)
     </target>
         <note>
@@ -268,23 +268,23 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Параметры для логгера терминала. (Short form: -tlp)
+                     Доступные параметры. 
+                        по умолчанию — определяет поведение логгера 
+                        терминала. Требуется одно из следующих значений: 
+                           - `on`, `true` заставляет использовать TerminalLogger даже 
+                            когда он будет отключен. 
+                           - `off`, `false` запрещает использование TerminalLogger 
+                            даже если бы он был включен. 
+                           - `auto` включает TerminalLogger, когда терминал 
+                            поддерживает это, и в сеансе нет перенаправления
                             stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+                        verbosity – Переопределить параметр -verbosity для этого 
+                        терминала 
+                        showCommandLine — Показать сообщения TaskCommandLineEvent 
 
-                      Example:
+                      Пример: 
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +300,12 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     Перенаправить вывод get* в файл. 
 
-                     Example:
+                     Пример:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     При этом значение свойства Bar будет записано в Biz.txt. 
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1531,7 +1531,7 @@
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: необходимо указать имя функции для переключателя FeatureAvailability.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index eab5ee82511..8db8d02b47a 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -137,11 +137,11 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
+        <target state="translated">  -getProperty:propertyName,...
+                     Belirtilen bir veya daha fazla özelliğin değerini
+                     değerlendirmeden sonra, derlemeyi yürütmeden yaz veya
+                     -targets ya da -getTargetResult seçeneklerinden biri
+                     kullanıldıysa, değerleri derlemeden sonra yaz.
     </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
@@ -156,12 +156,12 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
+        <target state="translated">  -getItem:itemName,...
+                     Belirtilen bir veya daha fazla öğenin değerini ve
+                     değerlendirmeden sonraki ilişkili meta değerini derlemeyi
+                     yürütmeden yaz veya -targets ya da -getTargetResult
+                     seçeneklerinden biri kullanıldıysa, değerleri
+                     derlemeden sonra yaz.
     </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
@@ -173,9 +173,9 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
+        <target state="translated">  -getTargetResult:targetName,...
+                     Bir veya daha fazla hedefin çıktı değerini yazın,
+                     belirtilen hedefler yürütülür.
     </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
@@ -198,20 +198,20 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
+        <target state="translated">  -featureAvailability:featureName,...
+                     Özellik kullanılabilirliğini denetle. Sonuç "Undefined",
+                     "Available", "NotAvailable" ve "Preview" dizelerinden
+                     biridir.
+                     - Undefined - özelliğin kullanılabilirliği tanımlanmamış
+                     (özelliğin adı özellik kullanılabilirliği tarafından
+                     bilinmiyor)
+                     - NotAvailable - özellik kullanılamıyor (Undefined’dan
+                     farklı olarak, özellik kullanılabilirliği denetleyicisi özelliğin adını
+                     biliyor ancak özelliğin geçerli MSBuild altyapısı tarafından
+                     desteklenmediğini de biliyor)
+                     - Available - özellik kullanılabilir
+                     - Önizleme - özellik önizleme aşamasında (kararlı değil)
+                     (Kısa biçimi: -fa)
     </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
@@ -231,17 +231,17 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Terminal günlükçüsünü etkinleştir veya devre dışı bırak. Terminal günlükçüsü
+                     konsolda gerçek zamanlı olarak gelişmiş derleme çıktısı sağlar,
+                     projeye göre mantıksal olarak düzenler ve eyleme
+                     dönüştürülebilir bilgileri vurgular. Sadece standart çıktı yeniden yönlendirilmiyorsa
+                     terminal günlükçüsünü kullanmak için otomatik olarak ayarlayın
+                     (veya bu seçeneği bağımsız değişken olmadan kullanın). Çıktı verilerini ayrıştırmayın
+                     veya gelecek sürümlerde değişmeden kalacak şekilde
+                     kullanın. Bu seçenek MSBuild 17.8 ve sonraki sürümlerde
+                     kullanılabilir.
+                     (Kısa biçimi: -tl)
     </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
@@ -268,23 +268,23 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
-                            stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Terminal günlükçüsü için parametreler. (Kısa biçimi: -tlp)
+                     Mevcut parametreler.
+                        default--Terminalin davranışını varsayılan olarak ayarlar
+                        günlükçü. Şu değerlerden birini gerektirir: 
+                           - `on`, `true` TerminalLogger’ı devre dışı olsa bile
+                            kullanılmaya zorlar.
+                           - `on`, `true` TerminalLogger’ı etkinleştirilmiş olsa bile
+                            kullanılmamaya zorlar.
+                           - 'auto' terminal desteklediğinde ve oturumda
+                            yeniden yönlendirilmiş stdout/stderr bulunmadığında
+                            TerminalLogger’ı etkinleştirir
+                        verbosity--Bu günlükçü için -verbosity ayarını
+                        geçersiz kıl
+                        showCommandLine--TaskCommandLineEvent iletilerini göster
 
-                      Example:
+                      Örnek:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -300,12 +300,12 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                     get* çıktısını bir dosyaya yeniden yönlendir.
 
-                     Example:
+                     Örnek:
                      -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
+                     Bu, Bar özelliğinin değerini Biz.txt dosyasına yazar.
     </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
@@ -1536,7 +1536,7 @@
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: featureAvailability anahtarı için özellik adı belirtilmelidir.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 1dfbac00adc..ad8b40cb534 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -137,12 +137,12 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
-    </target>
+        <target state="translated">  -getProperty:propertyName,...
+                    在计算后写出一个或多个指定属性的值，
+                    但不执行生成，或者如果使用的是
+                    -targets 选项或 -getTargetResult 选项，
+                    则在生成后写出这些值。
+   </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -156,13 +156,13 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
-    </target>
+        <target state="translated">  -getItem:itemName,...
+                    在计算后写出一个或多个指定项的值及其
+                    关联的元数据，但不
+                    执行生成，或者如果使用的是 -targets 选项
+                    或 -getTargetResult 选项，则在生成后写出
+                    这些值。
+   </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -173,10 +173,10 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
-    </target>
+        <target state="translated">  -getTargetResult:targetName,...
+                    写出一个或多个目标的输出值，
+                    并且将执行指定的目标。
+   </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -198,21 +198,21 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
-    </target>
+        <target state="translated">  -featureAvailability:featureName,...
+                    检查功能可用性。结果是以下字符串之一:
+                    "Undefined"、"Available"、"NotAvailable" 和
+                    "Preview"。
+                    - Undefined - 未定义功能的可用性
+                    (功能可用性检查器不知道
+                    该功能名称)
+                    - NotAvailable - 功能不可用(不同于
+                    Undefined，功能可用性检查器知道
+                    该功能名称，并且还知道该功能不
+                    受当前 MSBuild 引擎支持)
+                    - Available - 功能可用
+                    - Preview - 功能处于预览状态(不稳定)
+                    (缩写: -fa)
+   </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -231,18 +231,18 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
-    </target>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                    启用或禁用终端记录器。终端记录器
+                    在控制台上实时提供增强的生成输出，
+                    这些输出在逻辑上按项目进行整理，旨在突出显示
+                    可操作信息。指定 auto (或使用
+                    不带参数的选项)，仅在标准输出未重定向的情况下
+                    使用终端记录器。不要分析输出，
+                    也不要依赖于它在将来的版本中保持
+                    不变。此选项在 MSBuild 17.8 和
+                    更高版本中提供。
+                    (缩写: -tl)
+   </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -268,25 +268,25 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
-                            stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                    终端记录器的参数。(缩写: -tlp)
+                    可用参数。
+                       default - 指定终端
+                       记录器的默认行为。它需要以下值之一:
+                          - `on`、`true` 可强制使用 TerminalLogger，
+                           即使它已禁用也是如此。
+                          - `off`、`false` 可强制不使用 TerminalLogger，
+                           即使它已启用也是如此。
+                          - `auto` 可在终端支持 TerminalLogger
+                           且会话没有重定向的 stdout/stderr 时
+                           启用 TerminalLogger
+                       verbosity - 替代此记录器的 -verbosity
+                       设置
+                       showCommandLine - 显示 TaskCommandLineEvent 消息
 
-                      Example:
-                        -tlp:default=auto;verbosity=diag;shownCommandLine
-    </target>
+                     示例:
+                       -tlp:default=auto;verbosity=diag;shownCommandLine
+   </target>
         <note>
       LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -300,13 +300,13 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                    将 get* 的输出重定向到文件中。
 
-                     Example:
-                     -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
-    </target>
+                    示例:
+                    -getProperty:Bar -getResultOutputFile:Biz.txt
+                    这会将属性 Bar 的值写入 Biz.txt。
+   </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -1532,7 +1532,7 @@
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: 必须为 featureAvailability 开关提供功能名称。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index cf405b8c8a5..2efffebc5f8 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -137,12 +137,12 @@
                      the -targets option or the -getTargetResult option is
                      used, write out the values after the build.
     </source>
-        <target state="new">  -getProperty:propertyName,...
-                     Write out the value of one or more specified properties
-                     after evaluation, without executing the build, or if either
-                     the -targets option or the -getTargetResult option is
-                     used, write out the values after the build.
-    </target>
+        <target state="translated">  -getProperty:propertyName,...
+                    於評估後，寫出一或多個指定屬性的值，以及
+                    但不執行建置；如有使用
+                    -targets 選項或 -getTargetResult 選項，
+                    便於建置之後，再寫出這些值。
+   </target>
         <note>
       LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -156,13 +156,13 @@
                      or the -getTargetResult option is used, write out
                      the values after the build.
     </source>
-        <target state="new">  -getItem:itemName,...
-                     Write out the value of one or more specified items and
-                     their associated metadata after evaluation without
-                     executing the build, or if either the -targets option
-                     or the -getTargetResult option is used, write out
-                     the values after the build.
-    </target>
+        <target state="translated">  -getItem:itemName,...
+                    於評估後，寫出一或多個指定項目的值，以及
+                    其相關的中繼資料，但不
+                    執行建置；如有使用 -targets 選項
+                    或 -getTargetResult 選項，
+                    便於建置之後，再寫出這些值。
+   </target>
         <note>
       LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -173,10 +173,10 @@
                      Write out the output value of one or more targets and
                      the specified targets will be executed.
     </source>
-        <target state="new">  -getTargetResult:targetName,...
-                     Write out the output value of one or more targets and
-                     the specified targets will be executed.
-    </target>
+        <target state="translated">  -getTargetResult:targetName,...
+                    寫出一或多個目標的輸出值，然後
+                    執行指定的目標。
+   </target>
         <note>
       LOCALIZATION: "-getTargetResult" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -198,21 +198,21 @@
                      - Preview - the feature is in preview (not stable)
                      (Short form: -fa)
     </source>
-        <target state="new">  -featureAvailability:featureName,...
-                     Check feature availability. The result is one of the
-                     strings "Undefined", "Available", "NotAvailable" and
-                     "Preview".
-                     - Undefined - the availability of the feature is undefined
-                     (the feature name is unknown to the feature availability
-                     checker)
-                     - NotAvailable - the feature is not available (unlike
-                     Undefined, the feature name is known to the feature
-                     availability checker and it knows the feature is not
-                     supported by current MSBuild engine)
-                     - Available - the feature is available
-                     - Preview - the feature is in preview (not stable)
-                     (Short form: -fa)
-    </target>
+        <target state="translated">  -featureAvailability:featureName,...
+                    檢查功能可用性。結果會是下列其中一個字串:
+                    “Undefined”、“Available”、“NotAvailable” 和
+                    "Preview"。
+                    - Undefined - 功能的可用性未定義
+                    (功能可用性檢查程式不知道
+                    該功能名稱)
+                    - NotAvailable - 此功能無法使用 (不同於
+                    Undefined，功能可用性檢查程式知道該功能名稱，
+                    並知道功能目前的
+                    MSBuild 引擎不支援該功能)
+                    - Available - 此功能可以使用
+                    - Preview - 此功能目前為預覽狀態 (不穩定)
+                    (簡短形式: -fa)
+   </target>
         <note>
       LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -231,18 +231,18 @@
                      later.
                      (Short form: -tl)
     </source>
-        <target state="new">  -terminalLogger[:auto,on,off]
-                     Enable or disable the terminal logger. Terminal logger
-                     provides enhanced build output on the console in real time,
-                     organized logically by project, and designed to highlight
-                     actionable information. Specify auto (or use the option
-                     without arguments) to use the terminal logger only if the
-                     standard output is not redirected. Don't parse the output
-                     or otherwise rely on it remaining unchanged in future
-                     versions. This option is available in MSBuild 17.8 and
-                     later.
-                     (Short form: -tl)
-    </target>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                    啟用或停用終端機記錄器。終端機記錄器
+                    會即時在主機上，提供更進一步的組建輸出，
+                    並依照專案的邏輯編排，並會醒目提示
+                    可採取動作的資訊。指定自動 (或只使用選項，
+                    不使用引數) 只在使用標準輸出
+                    未重新導向時，才使用終端機記錄器。不剖析輸出，
+                    或以其他方式據此在
+                    未來的版本中保持不變。此選項可在 MSBuild 17.8 和
+                    更新版本中使用。
+                    (簡短形式: -tl)
+   </target>
         <note>
       LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -268,24 +268,25 @@
                       Example:
                         -tlp:default=auto;verbosity=diag;shownCommandLine
     </source>
-        <target state="new">  -terminalLoggerParameters: &lt;parameters&gt;
-                     Parameters to terminal logger. (Short form: -tlp)
-                     The available parameters.
-                        default--Specifies the default behavior of the terminal
-                        logger. It requires one of the following values:
-                           - `on`, `true`  forces TerminalLogger to be used even
-                            when it would be disabled.
-                           - `off`, `false` forces TerminalLogger to not be used
-                            even when it would be enabled.
-                           - `auto` enables TerminalLogger when the terminal
-                            supports it and the session doesn't have redirected
-                            stdout/stderr
-                        verbosity--Override the -verbosity setting for this
-                        logger
-                        showCommandLine--Show TaskCommandLineEvent messages
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                    終端機記錄器的參數。(簡短形式: -tlp)
+                    可用的參數。
+                       default -- 指定終端機記錄器的預設值。
+                       其需要下列其中一值: 
+。
+                          - 'on'、'true' 會強制使用 TerminalLogger，即使
+                           其之後可能會停用。
+                          - 'off'、'false' 會強制使用 TerminalLogger，即使
+                           其之後可能會啟用。
+                          - `auto` 會啟用 terminalLogger，但終端機必須能夠
+                           提供支援，且工作階段未經重新導向
+                           stdout/stderr
+                       verbosity -- 覆寫上記錄器的
+                       -verbosity
+                       showCommandLine -- 顯示 TaskCommandLineEvent 訊息
 
-                      Example:
-                        -tlp:default=auto;verbosity=diag;shownCommandLine
+                     範例: 
+                       -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
       LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
@@ -300,13 +301,13 @@
                      -getProperty:Bar -getResultOutputFile:Biz.txt
                      This writes the value of property Bar into Biz.txt.
     </source>
-        <target state="new">  -getResultOutputFile:file
-                     Redirect output from get* into a file.
+        <target state="translated">  -getResultOutputFile:file
+                    將輸出從 get* 重新導向至檔案。
 
-                     Example:
-                     -getProperty:Bar -getResultOutputFile:Biz.txt
-                     This writes the value of property Bar into Biz.txt.
-    </target>
+                    範例: 
+                    -getProperty:Bar -getResultOutputFile:Biz.txt
+                    這會將屬性列的值寫入 Biz.txt。
+   </target>
         <note>
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -1532,7 +1533,7 @@
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
-        <target state="new">MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</target>
+        <target state="translated">MSBUILD : error MSB1067: 必須提供 featureAvailability 切換的功能名稱。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureAvailability:blah".
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 38ae4cbb8d4..330ab7d914e 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -49,8 +49,8 @@
 
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.0" />
-          <codeBase version="6.0.0.0" href="..\Microsoft.IO.Redist.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.1" />
+          <codeBase version="6.0.0.1" href="..\Microsoft.IO.Redist.dll"/>
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
@@ -134,8 +134,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.3" newVersion="8.0.0.3" />
-          <codeBase version="8.0.0.3" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
+          <codeBase version="8.0.0.4" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 6fc1459176b..8372bfd8727 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -43,6 +43,10 @@
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.1" newVersion="6.0.0.1" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
@@ -90,7 +94,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.3" newVersion="8.0.0.3" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index a7bea630847..db9503bd9e5 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -40,10 +40,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <!-- EnvironmentVariableReadEventArgs shouldn't be used in TaskHosts, but it means we need fewer ifdefs. -->
-    <Compile Include="..\Framework\EnvironmentVariableReadEventArgs.cs">
-      <Link>EnvironmentVariableReadEventArgs.cs</Link>
-    </Compile>
     <Compile Include="..\Framework\BuildEnvironmentState.cs">
       <Link>BuildEnvironmentState.cs</Link>
     </Compile>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 3770b80c09d..bb41a07dcbb 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -11,7 +11,6 @@
 
 #if !TASKHOST
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 #endif
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
@@ -215,7 +214,7 @@ internal enum LoggingEventType : int
         /// Event is a <see cref="GeneratedFileUsedEventArgs"/>
         /// </summary>
         GeneratedFileUsedEvent = 34,
-        
+
         /// <summary>
         /// Event is <see cref="BuildCheckResultMessage"/>
         /// </summary>
@@ -435,7 +434,6 @@ internal void WriteToStream(ITranslator translator)
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs
                     or ProjectEvaluationFinishedEventArgs
-                    or EnvironmentVariableReadEventArgs
                     or ResponseFileUsedEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
@@ -623,8 +621,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
-                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
-                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),               
+                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),
 
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.AssemblyLoadEvent => new AssemblyLoadBuildEventArgs(),
@@ -652,6 +649,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.BuildCheckErrorEvent => new BuildCheckResultError(),
                 LoggingEventType.BuildCheckAcquisitionEvent => new BuildCheckAcquisitionEventArgs(),
                 LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
+                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -787,6 +785,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildCheckTracingEvent;
             }
+            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
+            {
+                return LoggingEventType.EnvironmentVariableReadEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -820,10 +822,6 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildErrorEvent;
             }
-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
-            {
-                return LoggingEventType.EnvironmentVariableReadEvent;
-            }
             else if (eventType == typeof(ResponseFileUsedEventArgs))
             {
                 return LoggingEventType.ResponseFileUsedEvent;
@@ -879,36 +877,12 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.BuildWarningEvent:
                     WriteBuildWarningEventToStream((BuildWarningEventArgs)buildEvent, translator);
                     break;
-                case LoggingEventType.EnvironmentVariableReadEvent:
-                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
-                    break;
                 default:
                     ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
                     break;
             }
         }
 
-        /// <summary>
-        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being
-        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.
-        /// </summary>
-        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
-        {
-            string name = environmentVariableReadEventArgs.EnvironmentVariableName;
-            MessageImportance importance = environmentVariableReadEventArgs.Importance;
-
-            translator.Translate(ref name);
-            translator.TranslateEnum(ref importance, (int)importance);
-
-#if !CLR2COMPATIBILITY
-            DateTime timestamp = environmentVariableReadEventArgs.RawTimestamp;
-            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
-
-            translator.Translate(ref timestamp);
-            translator.Translate(ref context);
-#endif
-        }
-
         #region Writes to Stream
 
         /// <summary>
@@ -1241,35 +1215,10 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
                 LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.ResponseFileUsedEvent => ReadResponseFileUsedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
                 _ => null,
             };
         }
 
-        /// <summary>
-        /// Read and reconstruct an EnvironmentVariableReadEventArgs from the stream. This message should never be called from a TaskHost, so although the context translation does not work, that's ok.
-        /// </summary>
-        private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string environmentVariableName = null;
-            MessageImportance importance = default;
-
-            translator.Translate(ref environmentVariableName);
-            translator.TranslateEnum(ref importance, (int)importance);
-
-            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message, helpKeyword, senderName, importance);
-
-#if !CLR2COMPATIBILITY
-            DateTime timestamp = default;
-            BuildEventContext context = null;
-            translator.Translate(ref timestamp);
-            translator.Translate(ref context);
-            args.RawTimestamp = timestamp;
-            args.BuildEventContext = context;
-#endif
-            return args;
-        }
-
         /// <summary>
         /// Read and reconstruct a BuildWarningEventArgs from the stream
         /// </summary>
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 35018eb1918..98e70e97581 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -104,6 +104,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.ZipDirectory"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
   <!-- Roslyn tasks are now in an assembly owned and shipped by Roslyn -->
+  <!-- NOTE: Keep in sync with SDK: src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Sdk.targets -->
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
