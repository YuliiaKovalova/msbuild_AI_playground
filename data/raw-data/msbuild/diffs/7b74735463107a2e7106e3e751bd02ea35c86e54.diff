diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 1e25829f60b..b5ec4e3736b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,6 +27,7 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 - [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
 - [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
+- [Fail restore operations when there is no `Restore` target or an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6312)
 ### 17.0
 
 ## Change Waves No Longer In Rotation
diff --git a/eng/Packages.props b/eng/Packages.props
index 91058315eaa..d6917bd7207 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,4 +1,8 @@
 <Project>
+  <!--
+    Make sure to update the binding redirects (in src\MSBuild\app.config and src\MSBuild\app.amd64.config) for any changes to
+    the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
+     -->
   <ItemGroup>
     <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 0eefd4337d0..ed8dbcd29e3 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21221.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21226.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e304b1672084f2274b5d838893d894fa5cf8abea</Sha>
+      <Sha>c58c5dd7f2e9e106368caafb0d4a7a29f4b2e1e9</Sha>
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="5.9.1-rc.8">
       <Uri>https://github.com/nuget/nuget.client</Uri>
diff --git a/eng/common/generate-locproject.ps1 b/eng/common/generate-locproject.ps1
index 24c00b5be98..2907f916d6f 100644
--- a/eng/common/generate-locproject.ps1
+++ b/eng/common/generate-locproject.ps1
@@ -38,7 +38,7 @@ if ($allXlfFiles) {
     $langXlfFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory\*\*.$firstLangCode.xlf"
 }
 $langXlfFiles | ForEach-Object {
-    $null = $_.Name -Match "(.+)\.[\w-]+\.xlf" # matches '[filename].[langcode].xlf
+    $null = $_.Name -Match "(.+)\.[\w-]+\.xlf" # matches '[filename].[langcode].xlf'
     
     $destinationFile = "$($_.Directory.FullName)\$($Matches.1).xlf"
     $xlfFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
diff --git a/eng/common/templates/job/onelocbuild.yml b/eng/common/templates/job/onelocbuild.yml
index d2b271ec1ac..27c31b208fa 100644
--- a/eng/common/templates/job/onelocbuild.yml
+++ b/eng/common/templates/job/onelocbuild.yml
@@ -17,6 +17,7 @@ parameters:
   LclSource: lclFilesInRepo
   LclPackageId: ''
   RepoType: gitHub
+  condition: ''
 
 jobs:
 - job: OneLocBuild
@@ -44,6 +45,7 @@ jobs:
         filePath: $(Build.SourcesDirectory)/eng/common/generate-locproject.ps1
         arguments: $(_GenerateLocProjectArguments)
       displayName: Generate LocProject.json
+      condition: ${{ parameters.condition }}
 
     - task: OneLocBuild@2
       displayName: OneLocBuild
@@ -62,7 +64,7 @@ jobs:
         ${{ if eq(parameters.RepoType, 'gitHub') }}:
           repoType: ${{ parameters.RepoType }}
           gitHubPatVariable: "${{ parameters.GithubPat }}"
-      condition: always()
+      condition: ${{ parameters.condition }}
 
     - task: PublishBuildArtifacts@1
       displayName: Publish Localization Files
@@ -70,7 +72,7 @@ jobs:
         PathtoPublish: '$(Build.ArtifactStagingDirectory)/loc'
         PublishLocation: Container
         ArtifactName: Loc
-      condition: always()
+      condition: ${{ parameters.condition }}
 
     - task: PublishBuildArtifacts@1
       displayName: Publish LocProject.json
@@ -78,4 +80,4 @@ jobs:
         PathtoPublish: '$(Build.SourcesDirectory)/Localize/'
         PublishLocation: Container
         ArtifactName: Loc
-      condition: always()
\ No newline at end of file
+      condition: ${{ parameters.condition }}
diff --git a/global.json b/global.json
index 25f7aa05985..baac5529cfe 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21221.5"
+    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21226.1"
   }
 }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 53c843c112a..0c3ab22d801 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1475,6 +1475,12 @@ internal ProjectCacheDescriptor() { }
         public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
         public string GetDetailedDescription() { throw null; }
     }
+    public sealed partial class ProjectCacheException : System.Exception
+    {
+        internal ProjectCacheException() { }
+        public string ErrorCode { get { throw null; } }
+        public bool HasBeenLoggedByProjectCache { get { throw null; } }
+    }
     public abstract partial class ProjectCachePluginBase
     {
         protected ProjectCachePluginBase() { }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index b1f8429b5cb..9dc716a4007 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1469,6 +1469,12 @@ internal ProjectCacheDescriptor() { }
         public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
         public string GetDetailedDescription() { throw null; }
     }
+    public sealed partial class ProjectCacheException : System.Exception
+    {
+        internal ProjectCacheException() { }
+        public string ErrorCode { get { throw null; } }
+        public bool HasBeenLoggedByProjectCache { get { throw null; } }
+    }
     public abstract partial class ProjectCachePluginBase
     {
         protected ProjectCachePluginBase() { }
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 4a800918f77..8ccde2767a9 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -192,7 +192,7 @@ char Chr(int projectNumber)
         }
 
         [Flags]
-        public enum ExceptionLocations
+        public enum ErrorLocations
         {
             Constructor = 1 << 0,
             BeginBuildAsync = 1 << 1,
@@ -200,6 +200,12 @@ public enum ExceptionLocations
             EndBuildAsync = 1 << 3
         }
 
+        public enum ErrorKind
+        {
+            Exception,
+            LoggedError
+        }
+
         public class InstanceMockCache : ProjectCachePluginBase
         {
             private readonly GraphCacheResponse? _testData;
@@ -791,27 +797,31 @@ public static IEnumerable<object[]> CacheExceptionLocationsTestData
         {
             get
             {
-                yield return new object[]{ExceptionLocations.Constructor};
+                // Plugin constructors cannot log errors, they can only throw exceptions.
+                yield return new object[] { ErrorLocations.Constructor, ErrorKind.Exception };
 
-                yield return new object[]{ExceptionLocations.BeginBuildAsync};
-                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync};
-                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
-                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.EndBuildAsync};
+                foreach (var errorKind in new[]{ErrorKind.Exception, ErrorKind.LoggedError})
+                {
+                    yield return new object[] { ErrorLocations.BeginBuildAsync, errorKind };
+                    yield return new object[] { ErrorLocations.BeginBuildAsync | ErrorLocations.GetCacheResultAsync, errorKind };
+                    yield return new object[] { ErrorLocations.BeginBuildAsync | ErrorLocations.GetCacheResultAsync | ErrorLocations.EndBuildAsync, errorKind };
+                    yield return new object[] { ErrorLocations.BeginBuildAsync | ErrorLocations.EndBuildAsync, errorKind };
 
-                yield return new object[]{ExceptionLocations.GetCacheResultAsync};
-                yield return new object[]{ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
+                    yield return new object[] { ErrorLocations.GetCacheResultAsync, errorKind };
+                    yield return new object[] { ErrorLocations.GetCacheResultAsync | ErrorLocations.EndBuildAsync, errorKind };
 
-                yield return new object[]{ExceptionLocations.EndBuildAsync};
+                    yield return new object[] { ErrorLocations.EndBuildAsync, errorKind };
+                }
             }
         }
 
         [Theory]
         [MemberData(nameof(CacheExceptionLocationsTestData))]
-        public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ExceptionLocations exceptionLocations)
+        public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorLocations errorLocations, ErrorKind errorKind)
         {
             _env.DoNotLaunchDebugger();
 
-            SetEnvironmentForExceptionLocations(exceptionLocations);
+            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
 
             var project = _env.CreateFile("1.proj", @$"
                     <Project>
@@ -842,36 +852,59 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(Except
                 // Plugin construction, initialization, and query all end up throwing in BuildManager.ExecuteSubmission and thus
                 // mark the submission as failed with exception.
                 var exceptionsThatEndUpInBuildResult =
-                    ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync;
+                    ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync | ErrorLocations.GetCacheResultAsync;
 
-                if ((exceptionsThatEndUpInBuildResult & exceptionLocations) != 0)
+                if ((exceptionsThatEndUpInBuildResult & errorLocations) != 0)
                 {
-                    buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-                    buildResult.Exception.Message.ShouldContain("Cache plugin exception from");
+                    buildResult.Exception.ShouldNotBeNull();
+                    buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
+
+                    if (errorKind == ErrorKind.Exception)
+                    {
+                        buildResult.Exception.InnerException!.ShouldNotBeNull();
+                        buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    }
+                    else
+                    {
+                        buildResult.Exception.InnerException.ShouldBeNull();
+                    }
                 }
 
                 // BuildManager.EndBuild calls plugin.EndBuild, so if only plugin.EndBuild fails it means everything else passed,
                 // so the build submission should be successful.
-                if (exceptionLocations == ExceptionLocations.EndBuildAsync)
+                if (errorLocations == ErrorLocations.EndBuildAsync)
                 {
                     buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
                 }
+                else
+                {
+                    buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+                }
             }
             finally
             {
                 // These exceptions prevent the creation of a plugin so there's no plugin to shutdown.
-                var exceptionsThatPreventEndBuildFromThrowing = ExceptionLocations.Constructor |
-                                                                ExceptionLocations.BeginBuildAsync;
+                var exceptionsThatPreventEndBuildFromThrowing = ErrorLocations.Constructor |
+                                                                ErrorLocations.BeginBuildAsync;
 
-                if ((exceptionLocations & exceptionsThatPreventEndBuildFromThrowing) != 0 ||
-                    !exceptionLocations.HasFlag(ExceptionLocations.EndBuildAsync))
+                if ((errorLocations & exceptionsThatPreventEndBuildFromThrowing) != 0 ||
+                    !errorLocations.HasFlag(ErrorLocations.EndBuildAsync))
                 {
                     Should.NotThrow(() => buildSession!.Dispose());
                 }
-                else if (exceptionLocations.HasFlag(ExceptionLocations.EndBuildAsync))
+                else if (errorLocations.HasFlag(ErrorLocations.EndBuildAsync))
                 {
-                    var e = Should.Throw<Exception>(() => buildSession!.Dispose());
-                    e.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+                    var e = Should.Throw<ProjectCacheException>(() => buildSession!.Dispose());
+
+                    if (errorKind == ErrorKind.Exception)
+                    {
+                        e.InnerException!.ShouldNotBeNull();
+                        e.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+                    }
+                    else
+                    {
+                        e.InnerException.ShouldBeNull();
+                    }
                 }
                 else
                 {
@@ -882,9 +915,9 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(Except
             logger.BuildFinishedEvents.First().Succeeded.ShouldBeFalse();
 
             // Plugin query must happen after plugin init. So if plugin init fails, then the plugin should not get queried.
-            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync;
+            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
 
-            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & exceptionLocations) != 0)
+            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) != 0)
             {
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: EndBuildAsync");
@@ -895,17 +928,21 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(Except
                 StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: EndBuildAsync", expectedOccurrences: 1);
             }
 
-            // TODO: this ain't right now is it?
-            logger.FullLog.ShouldNotContain("Cache plugin exception");
+            logger.FullLog.ShouldNotContain("Cache plugin exception from");
+
+            if (errorKind == ErrorKind.LoggedError)
+            {
+                logger.FullLog.ShouldContain("Cache plugin logged error from");
+            }
         }
 
         [Theory]
         [MemberData(nameof(CacheExceptionLocationsTestData))]
-        public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ExceptionLocations exceptionLocations)
+        public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
             _env.DoNotLaunchDebugger();
 
-            SetEnvironmentForExceptionLocations(exceptionLocations);
+            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
 
             var graph = Helpers.CreateProjectGraph(
                 _env,
@@ -945,10 +982,21 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ExceptionLo
 
                 // Static graph build initializes and tears down the cache plugin so all cache plugin exceptions should end up in the GraphBuildResult
                 buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-                buildResult.Exception.Message.ShouldContain("Cache plugin exception from");
 
-                // TODO: this ain't right now is it?
-                logger.FullLog.ShouldNotContain("Cache plugin exception");
+                buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
+
+                if (errorKind == ErrorKind.Exception)
+                {
+                    buildResult.Exception.InnerException!.ShouldNotBeNull();
+                    buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                }
+
+                logger.FullLog.ShouldNotContain("Cache plugin exception from");
+
+                if (errorKind == ErrorKind.LoggedError)
+                {
+                    logger.FullLog.ShouldContain("Cache plugin logged error from");
+                }
             }
             finally
             {
@@ -958,9 +1006,9 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ExceptionLo
 
             logger.BuildFinishedEvents.First().Succeeded.ShouldBeFalse();
 
-            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync;
+            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
 
-            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & exceptionLocations) != 0)
+            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) != 0)
             {
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: EndBuildAsync");
@@ -968,7 +1016,7 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ExceptionLo
             else
             {
                 // There's two projects, so there should be two cache queries logged ... unless a cache queries throws an exception. That ends the build.
-                var expectedQueryOccurrences = exceptionLocations.HasFlag(ExceptionLocations.GetCacheResultAsync)
+                var expectedQueryOccurrences = errorLocations.HasFlag(ErrorLocations.GetCacheResultAsync)
                     ? 1
                     : 2;
 
@@ -995,7 +1043,7 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                         </Target>
                     </Project>".Cleanup());
 
-            SetEnvironmentForExceptionLocations(ExceptionLocations.EndBuildAsync);
+            SetEnvironmentForErrorLocations(ErrorLocations.EndBuildAsync, ErrorKind.Exception.ToString());
 
             using var buildSession = new Helpers.BuildManagerSession(
                 _env,
@@ -1014,7 +1062,8 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                 });
 
             buildResult!.OverallResult.ShouldBe(BuildResultCode.Failure);
-            buildResult.Exception.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            buildResult.Exception.InnerException!.ShouldNotBeNull();
+            buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
 
             buildSession.Dispose();
 
@@ -1027,15 +1076,15 @@ private static void StringShouldContainSubstring(string aString, string substrin
             Regex.Matches(aString, substring).Count.ShouldBe(expectedOccurrences);
         }
 
-        private void SetEnvironmentForExceptionLocations(ExceptionLocations exceptionLocations)
+        private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, string errorKind)
         {
-            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
+            foreach (var enumValue in Enum.GetValues(typeof(ErrorLocations)))
             {
-                var typedValue = (ExceptionLocations) enumValue;
-                if (exceptionLocations.HasFlag(typedValue))
+                var typedValue = (ErrorLocations) enumValue;
+                if (errorLocations.HasFlag(typedValue))
                 {
                     var exceptionLocation = typedValue.ToString();
-                    _env.SetEnvironmentVariable(exceptionLocation, "1");
+                    _env.SetEnvironmentVariable(exceptionLocation, errorKind);
                     _output.WriteLine($"Set exception location: {exceptionLocation}");
                 }
             }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 7242201d335..ef032ea7791 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1279,11 +1279,14 @@ private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio
                 _buildParameters.ProjectCacheDescriptor == null)
             {
                 _projectCacheServiceInstantiatedByVSWorkaround = true;
-                ErrorUtilities.VerifyThrowInvalidOperation(
-                    ProjectCacheItems.Count == 1,
-                    "OnlyOneCachePluginMustBeSpecified",
-                    string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
 
+                if (ProjectCacheItems.Count != 1)
+                {
+                    ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
+                        "OnlyOneCachePluginMustBeSpecified",
+                        string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
+                }
+                
                 // Plugin needs the graph root (aka top BuildSubmission path, aka the solution path when in VS) which, under VS, is accessible
                 // only by evaluating the submission and retrieving the 'SolutionPath' property set by VS. This is also the reason why
                 // this method cannot be called from BeginBuild, because no build submissions are available there to extract the solution path from.
@@ -1300,6 +1303,7 @@ private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio
                 ErrorUtilities.VerifyThrow(
                     solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != "*Undefined*",
                     $"Expected VS to set a valid SolutionPath property but got: {solutionPath}");
+
                 ErrorUtilities.VerifyThrow(
                     FileSystems.Default.FileExists(solutionPath),
                     $"Solution file does not exist: {solutionPath}");
@@ -1943,16 +1947,18 @@ private DisposablePluginService SearchAndInitializeProjectCachePluginFromGraph(P
                 return new DisposablePluginService(null);
             }
 
-            ErrorUtilities.VerifyThrowInvalidOperation(
-                cacheItems.Count == 1,
-                "OnlyOneCachePluginMustBeSpecified",
-                string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
+            if (cacheItems.Count != 1)
+            {
+                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
+                    "OnlyOneCachePluginMustBeSpecified",
+                    string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
+            }
 
             var nodesWithoutCacheItems = nodeToCacheItems.Where(kvp => kvp.Value.Length == 0).ToArray();
 
             if (nodesWithoutCacheItems.Length > 0)
             {
-                ErrorUtilities.ThrowInvalidOperation(
+                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
                     "NotAllNodesDefineACacheItem",
                     ItemTypeNames.ProjectCachePlugin,
                     string.Join(", ", nodesWithoutCacheItems.Select(kvp => kvp.Key.ProjectInstance.FullPath)));
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
new file mode 100644
index 00000000000..994c9da77a8
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
@@ -0,0 +1,87 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    /// This exception is used to wrap an unhandled exception from a project cache plugin. This exception aborts the build, and it can only be
+    /// thrown by the MSBuild engine.
+    /// </summary>
+    public sealed class ProjectCacheException : Exception
+    {
+        private ProjectCacheException()
+        {
+            ErrorUtilities.ThrowInternalErrorUnreachable();
+        }
+
+        private ProjectCacheException(
+            string message,
+            Exception innerException,
+            bool hasBeenLoggedByProjectCache,
+            string errorCode
+        )
+            : base(message, innerException)
+        {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+
+            HasBeenLoggedByProjectCache = hasBeenLoggedByProjectCache;
+            ErrorCode = errorCode;
+        }
+
+        /// <summary>
+        /// The project cache has already logged this as an error.
+        /// Should not get logged again.
+        /// </summary>
+        public bool HasBeenLoggedByProjectCache { get; }
+
+        /// <summary>
+        /// Gets the error code associated with this exception's message (not the inner exception).
+        /// </summary>
+        /// <value>The error code string.</value>
+        public string ErrorCode { get; }
+
+        internal static void ThrowAsUnhandledException
+        (
+            Exception innerException,
+            string messageResourceName,
+            params string[] messageArgs
+        )
+        {
+            ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out var errorCode, out _, messageResourceName, messageArgs);
+
+            throw new ProjectCacheException(message, innerException, hasBeenLoggedByProjectCache: false, errorCode);
+        }
+
+        internal static void ThrowForErrorLoggedInsideTheProjectCache
+        (
+            string messageResourceName,
+            params string[] messageArgs
+        )
+        {
+            ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out var errorCode, out _, messageResourceName, messageArgs);
+
+            throw new ProjectCacheException(message: message, innerException: null, hasBeenLoggedByProjectCache: true, errorCode: errorCode);
+        }
+
+        internal static void ThrowForMSBuildIssueWithTheProjectCache
+        (
+            string messageResourceName,
+            params string[] messageArgs
+        )
+        {
+            ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out var errorCode, out _, messageResourceName, messageArgs);
+
+            throw new ProjectCacheException(message: message, innerException: null, hasBeenLoggedByProjectCache: false, errorCode: errorCode);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 3103b05ddf6..ad7259723ce 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
     internal class ProjectCacheService
     {
         private readonly BuildManager _buildManager;
-        private readonly PluginLoggerBase _logger;
+        private readonly Func<PluginLoggerBase> _loggerFactory;
         private readonly ProjectCacheDescriptor _projectCacheDescriptor;
         private readonly CancellationToken _cancellationToken;
         private readonly ProjectCachePluginBase _projectCachePlugin;
@@ -28,13 +28,14 @@ internal class ProjectCacheService
         private ProjectCacheService(
             ProjectCachePluginBase projectCachePlugin,
             BuildManager buildManager,
-            PluginLoggerBase logger,
+            Func<PluginLoggerBase> loggerFactory,
             ProjectCacheDescriptor projectCacheDescriptor,
-            CancellationToken cancellationToken)
+            CancellationToken cancellationToken
+        )
         {
             _projectCachePlugin = projectCachePlugin;
             _buildManager = buildManager;
-            _logger = logger;
+            _loggerFactory = loggerFactory;
             _projectCacheDescriptor = projectCacheDescriptor;
             _cancellationToken = cancellationToken;
         }
@@ -49,25 +50,33 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
                 .ConfigureAwait(false);
 
             // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.
-            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);
-
-            await plugin.BeginBuildAsync(
-                new CacheContext(
-                    pluginDescriptor.PluginSettings,
-                    new IFileSystemAdapter(FileSystems.Default),
-                    pluginDescriptor.ProjectGraph,
-                    pluginDescriptor.EntryPoints),
-                // TODO: Detect verbosity from logging service.
-                logger,
-                cancellationToken);
+            var loggerFactory = new Func<PluginLoggerBase>(() => new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService));
+
+            var logger = loggerFactory();
+
+            try
+            {
+                await plugin.BeginBuildAsync(
+                    new CacheContext(
+                        pluginDescriptor.PluginSettings,
+                        new IFileSystemAdapter(FileSystems.Default),
+                        pluginDescriptor.ProjectGraph,
+                        pluginDescriptor.EntryPoints),
+                    // TODO: Detect verbosity from logging service.
+                    logger,
+                    cancellationToken);
+            }
+            catch (Exception e)
+            {
+                HandlePluginException(e, nameof(ProjectCachePluginBase.BeginBuildAsync));
+            }
 
             if (logger.HasLoggedErrors)
             {
-                throw new Exception(
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheInitializationFailed"));
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
             }
 
-            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);
+            return new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
         }
 
         private static ProjectCachePluginBase GetPluginInstance(ProjectCacheDescriptor pluginDescriptor)
@@ -83,9 +92,7 @@ private static ProjectCachePluginBase GetPluginInstance(ProjectCacheDescriptor p
 
             ErrorUtilities.ThrowInternalErrorUnreachable();
 
-#pragma warning disable CS8603 // Possible null reference return.
-            return null;
-#pragma warning restore CS8603 // Possible null reference return.
+            return null!;
         }
 
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
@@ -96,8 +103,10 @@ private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
             }
             catch (TargetInvocationException e) when (e.InnerException != null)
             {
-                throw e.InnerException;
+                HandlePluginException(e.InnerException, "Constructor");
             }
+
+            return null!;
         }
 
         private static Type GetTypeFromAssemblyPath(string pluginAssemblyPath)
@@ -106,7 +115,10 @@ private static Type GetTypeFromAssemblyPath(string pluginAssemblyPath)
 
             var type = GetTypes<ProjectCachePluginBase>(assembly).FirstOrDefault();
 
-            ErrorUtilities.VerifyThrow(type != null, "NoProjectCachePluginFoundInAssembly", pluginAssemblyPath);
+            if (type == null)
+            {
+                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache("NoProjectCachePluginFoundInAssembly", pluginAssemblyPath);
+            }
 
             return type!;
 
@@ -143,16 +155,25 @@ public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest
                                    $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
                                    $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
 
-            _logger.LogMessage(
+            var logger = _loggerFactory();
+
+            logger.LogMessage(
                 "\n====== Querying project cache for project " + queryDescription,
                 MessageImportance.High);
 
-            var cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, _logger, _cancellationToken);
+            CacheResult cacheResult = null!;
+            try
+            {
+                cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, logger, _cancellationToken);
+            }
+            catch (Exception e)
+            {
+                HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
+            }
 
-            if (_logger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
+            if (logger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
             {
-                throw new Exception(
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheQueryFailed", queryDescription));
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", queryDescription);
             }
 
             var message = $"Plugin result: {cacheResult.ResultType}.";
@@ -172,7 +193,7 @@ public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest
                     throw new ArgumentOutOfRangeException();
             }
 
-            _logger.LogMessage(
+            logger.LogMessage(
                 message,
                 MessageImportance.High);
 
@@ -181,13 +202,34 @@ public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest
 
         public async Task ShutDown()
         {
-            await _projectCachePlugin.EndBuildAsync(_logger, _cancellationToken);
+            var logger = _loggerFactory();
 
-            if (_logger.HasLoggedErrors)
+            try
+            {
+                await _projectCachePlugin.EndBuildAsync(logger, _cancellationToken);
+            }
+            catch (Exception e)
             {
-                throw new Exception(
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheShutdownFailed"));
+                HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
             }
+
+            if (logger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+            }
+        }
+
+        private static void HandlePluginException(Exception e, string apiExceptionWasThrownFrom)
+        {
+            if (ExceptionHandling.IsCriticalException(e))
+            {
+                throw e;
+            }
+
+            ProjectCacheException.ThrowAsUnhandledException(
+                e,
+                "ProjectCacheException",
+                apiExceptionWasThrownFrom);
         }
 
         private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 8398cb68479..659066306cc 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -466,7 +466,7 @@ internal void LoadProjectIntoConfiguration(
                     projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
                 }
 
-                if (buildRequestDataFlags.HasFlag(buildRequestDataFlags & BuildRequestDataFlags.FailOnUnresolvedSdk))
+                if (buildRequestDataFlags.HasFlag(BuildRequestDataFlags.FailOnUnresolvedSdk))
                 {
                     projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
                 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 2dff53cc972..43d9b794046 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -800,5 +800,4 @@
   <ItemGroup>
     <Compile Remove="Collections\RetrievableEntryHashSet\Originals\*" />
   </ItemGroup>
-
 </Project>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index ed692c7d2c3..9bce56de852 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1864,8 +1864,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</value>
   </data>
   <data name="LoadingProjectCachePlugin" xml:space="preserve">
-    <value>"Loading the following project cache plugin:
-    {0}"</value>
+    <value>Loading the following project cache plugin:
+    {0}</value>
   </data>
   <data name="SolutionPathPropertyMustBeSetOnVSSubmissions" xml:space="preserve">
     <value>"MSB4264: Invalid $(SolutionPath) property: {0}"</value>
@@ -1888,6 +1888,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
+  <data name="ProjectCacheException" xml:space="preserve">
+    <value>MSB4273: The project cache threw an unhandled exception from the {0} method.</value>
+  </data>
   <data name="KillingProcessWithPid" xml:space="preserve">
     <value>Killing process with pid = {0}.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 460d8c51045..a005bbc5a4e 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">Načítá se následující modul plug-in mezipaměti projektu:
     {0}</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Musí se zadat jeden modul plug-in mezipaměti projektu, ale našlo se jich více: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: Nepovedlo se inicializovat mezipaměť projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 7856dd8038a..91850b56a54 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Folgendes Projektcache-Plug-In wird geladen:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Folgendes Projektcache-Plug-In wird geladen:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Ein einzelnes Projektcache-Plug-In muss angegeben werden, es wurden jedoch mehrere gefunden: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: Fehler beim Initialisieren des Projektcache.</target>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index a030cd7e6bd..035b1fdf1cb 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -138,10 +138,10 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
-    {0}"</target>
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="new">Loading the following project cache plugin:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -219,6 +219,11 @@
         <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="new">MSB4266: Failed to initialize the project cache.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 10135514f9e..8e6962329b5 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Cargando el complemento de caché de proyectos siguiente:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Cargando el complemento de caché de proyectos siguiente:
     {0} "</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Debe especificarse un solo complemento de caché de proyectos, pero se encontraron varios: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: No se pudo inicializar la caché de proyectos.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 77795f49d65..b5ee6552148 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Chargement du plug-in de cache de projet suivant :
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Chargement du plug-in de cache de projet suivant :
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: un seul plug-in de cache de projet doit être spécifié, mais plusieurs plug-ins ont été trouvés : {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: échec de l'initialisation du cache de projet.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 2c8d2e9d4ae..dd24c5f953f 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Caricamento del plug-in seguente della cache del progetto:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Caricamento del plug-in seguente della cache del progetto:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: è necessario specificare un singolo plug-in della cache del progetto, ma ne sono trovati più di uno: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: non è stato possibile inizializzare la cache del progetto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index f91a15b4459..9bb48532bc8 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"次のプロジェクト キャッシュ プラグインを読み込んでいます。
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"次のプロジェクト キャッシュ プラグインを読み込んでいます。
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 単一のプロジェクト キャッシュ プラグインを指定する必要がありますが、複数指定されています。{0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: プロジェクト キャッシュを初期化できませんでした。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 3480d5aa9e1..5d7d4163bd2 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"다음 프로젝트 캐시 플러그 인을 로드하는 중:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"다음 프로젝트 캐시 플러그 인을 로드하는 중:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 단일 프로젝트 캐시 플러그 인이 지정되어야 하지만, {0}에서 여러 개를 찾았습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: 프로젝트 캐시를 초기화하지 못했습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index f2ae7700434..1d00d687697 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">„Ładowanie następującej wtyczki pamięci podręcznej projektu:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">„Ładowanie następującej wtyczki pamięci podręcznej projektu:
     {0}”</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: należy określić jedną wtyczkę pamięci podręcznej projektu, ale znaleziono ich wiele: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: nie można zainicjować pamięci podręcznej projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index d386fdc902b..423af0d4199 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Carregando o seguinte plug-in de cache do projeto:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Carregando o seguinte plug-in de cache do projeto:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: é necessário especificar só um plug-in de cache do projeto, mas foram encontrados vários: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: falha ao inicializar o cache do projeto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index a2a3ffc13fb..2381c6ed244 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Идет загрузка следующего подключаемого модуля кэша проектов:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Идет загрузка следующего подключаемого модуля кэша проектов:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: должен быть указан один подключаемый модуль кэша проектов, но найдено несколько: {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: не удалось инициализировать кэш проектов.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 0e7ece86344..51c4e1c7d52 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Şu proje önbelleği eklentisi yükleniyor:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Şu proje önbelleği eklentisi yükleniyor:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Tek bir proje önbellek eklentisi belirtilmelidir ancak birden çok eklenti bulundu: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: Proje önbelleği başlatılamadı.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 7157572b7e0..2bf484357b9 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">“正在加载以下项目缓存插件:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">“正在加载以下项目缓存插件:
     {0}”</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 必须指定单个项目缓存插件，但找到多个位置: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: 未能初始化项目缓存。</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index d8fb2e4baa4..f4f05481636 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"正在載入下列專案快取外掛程式:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"正在載入下列專案快取外掛程式:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 只可指定單一專案快取外掛程式，但發現多個指定項目: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: 無法將專案快取初始化。</target>
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 4bf4944e94c..424e7dea8a9 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -1,8 +1,11 @@
 ﻿using System;
+using System.Diagnostics;
 using System.IO;
+using System.Reflection;
 using System.Text;
 using System.Xml;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Internal
 {
@@ -26,6 +29,16 @@ internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly)
         private readonly Stream _stream;
         private readonly StreamReader _streamReader;
 
+        /// <summary>
+        /// Caches a <see cref="PropertyInfo"/> representing the "Normalization" internal property on the <see cref="XmlReader"/>-derived
+        /// type returned from <see cref="XmlReader.Create(TextReader, XmlReaderSettings, string)"/>. The cache is process/AppDomain-wide
+        /// and lock-free, so we use volatile access for thread safety, i.e. to ensure that when the field is updated the PropertyInfo
+        /// it's pointing to is seen as fully initialized by all CPUs.
+        /// </summary>
+        private static volatile PropertyInfo _normalizationPropertyInfo;
+
+        private static bool _disableReadOnlyLoad;
+
         private XmlReaderExtension(string file, bool loadAsReadOnly)
         {
             try
@@ -71,15 +84,61 @@ public void Dispose()
             _stream?.Dispose();
         }
 
+        /// <summary>
+        /// Returns <see cref="PropertyInfo"/> of the "Normalization" internal property on the given <see cref="XmlReader"/>-derived type.
+        /// </summary>
+        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)
+        {
+            PropertyInfo propertyInfo = _normalizationPropertyInfo;
+            if (propertyInfo == null)
+            {
+                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;
+                propertyInfo = xmlReaderType.GetProperty("Normalization", bindingFlags);
+                _normalizationPropertyInfo = propertyInfo;
+            }
+
+            return propertyInfo;
+        }
+
         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)
         {
             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();
 
-            
-            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes
-            // of attribute text, specifically newline removal.
-            // https://github.com/Microsoft/msbuild/issues/4210
-            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
+            XmlReader reader = null;
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) && loadAsReadOnly && !_disableReadOnlyLoad)
+            {
+                // Create an XML reader with IgnoreComments and IgnoreWhitespace set if we know that we won't be asked
+                // to write the DOM back to a file. This is a performance optimization.
+                XmlReaderSettings settings = new XmlReaderSettings
+                {
+                    DtdProcessing = DtdProcessing.Ignore,
+                    IgnoreComments = true,
+                    IgnoreWhitespace = true,
+                };
+                reader = XmlReader.Create(input, settings, uri);
+
+                // Try to set Normalization to false. We do this to remain compatible with earlier versions of MSBuild
+                // where we constructed the reader with 'new XmlTextReader()' which has normalization enabled by default.
+                PropertyInfo normalizationPropertyInfo = GetNormalizationPropertyInfo(reader.GetType());
+                if (normalizationPropertyInfo != null)
+                {
+                    normalizationPropertyInfo.SetValue(reader, false);
+                }
+                else
+                {
+                    // Fall back to using XmlTextReader if the prop could not be bound.
+                    Debug.Fail("Could not set Normalization to false on the result of XmlReader.Create");
+                    _disableReadOnlyLoad = true;
+
+                    reader.Dispose();
+                    reader = null;
+                }
+            }
+
+            if (reader == null)
+            {
+                reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
+            }
 
             reader.Read();
             encoding = input.CurrentEncoding;
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index e014f5652e3..1513d20e3f9 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -19,6 +19,7 @@
 using Shouldly;
 using System.IO.Compression;
 using System.Reflection;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -2127,6 +2128,31 @@ public void RestoreFailsOnUnresolvedSdk()
             logContents.ShouldContain("error MSB4236: The SDK 'UnresolvedSdk' specified could not be found.");
         }
 
+        /// <summary>
+        /// When specifying /t:restore under an old changewave, do not fail when an SDK can't be resolved.
+        /// Previous behavior was to try and continue anyway but then "restore" would succeed and build workflows continue on.
+        /// </summary>
+        [Fact]
+        public void RestorePassesOnUnresolvedSdkUnderChangewave()
+        {
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+$@"<Project>
+  <Sdk Name=""UnresolvedSdk"" />
+  <Target Name=""Restore"">
+    <Message Text=""Restore target ran"" />
+  </Target>
+</Project>");
+
+            using TestEnvironment env = Microsoft.Build.UnitTests.TestEnvironment.Create();
+
+            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents,
+                envsToCreate: new Dictionary<string, string>() { ["MSBUILDDISABLEFEATURESFROMVERSION"]=ChangeWaves.Wave16_10.ToString() },
+                arguments: " /t:restore");
+
+            logContents.ShouldNotContain("MSB4236");
+        }
+
+
         /// <summary>
         /// Verifies a non-existent target doesn't fail restore as long as its not considered an entry target, in this case Restore.
         /// </summary>
@@ -2181,6 +2207,26 @@ public void RestoreFailsWhenEntryTargetIsNonExistent()
             logContents.ShouldContain("error MSB4057: The target \"Restore\" does not exist in the project.");
         }
 
+        /// <summary>
+        /// Verifies restore will not fail if the entry target doesn't exist, when changewave applied.
+        /// </summary>
+        [Fact]
+        public void RestorePassesWhenEntryTargetIsNonExistentUnderChangewave()
+        {
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+@"<Project DefaultTargets=""Build"">
+  <Target Name=""Build"">
+    <Message Text=""Build target ran&quot;"" />
+  </Target>
+</Project>");
+
+            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents,
+                envsToCreate: new Dictionary<string, string>() { ["MSBUILDDISABLEFEATURESFROMVERSION"] = ChangeWaves.Wave16_10.ToString() },
+                arguments: "/t:restore");
+
+            logContents.ShouldNotContain("MSB4057");
+        }
+
         /// <summary>
         /// Verifies restore will run InitialTargets.
         /// </summary>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 3acef1dea3c..b86c58acce1 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -20,6 +20,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Logging;
@@ -81,7 +82,11 @@ public enum ExitType
             /// The build stopped unexpectedly, for example,
             /// because a child died or hung.
             /// </summary>
-            Unexpected
+            Unexpected,
+            /// <summary>
+            /// A project cache failed unexpectedly.
+            /// </summary>
+            ProjectCacheFailure
         }
 
         /// <summary>
@@ -786,6 +791,24 @@ string [] commandLine
                     exitType = ExitType.InitializationError;
                 }
             }
+            catch (ProjectCacheException e)
+            {
+                Console.WriteLine($"MSBUILD : error {e.ErrorCode}: {e.Message}");
+
+#if DEBUG
+                if (!e.HasBeenLoggedByProjectCache && e.InnerException != null)
+                {
+                    Console.WriteLine("This is an unhandled exception from a project cache -- PLEASE OPEN A BUG AGAINST THE PROJECT CACHE OWNER.");
+                }
+#endif
+
+                if (e.InnerException is not null)
+                {
+                    Console.WriteLine(e.InnerException.ToString());
+                }
+
+                exitType = ExitType.ProjectCacheFailure;
+            }
             catch (BuildAbortedException e)
             {
                 Console.WriteLine(
@@ -1262,21 +1285,17 @@ string outputResultsCache
                         success = false;
 
                         // InvalidProjectFileExceptions and its aggregates have already been logged.
-                        if (exception.GetType() != typeof(InvalidProjectFileException)
+                        if (exception is not InvalidProjectFileException
                             && !(exception is AggregateException aggregateException && aggregateException.InnerExceptions.All(innerException => innerException is InvalidProjectFileException)))
                         {
-                            if
-                                (
-                                exception.GetType() == typeof(LoggerException) ||
-                                exception.GetType() == typeof(InternalLoggerException)
-                                )
+                            if (exception is LoggerException or InternalLoggerException or ProjectCacheException)
                             {
-                                // We will rethrow this so the outer exception handler can catch it, but we don't
+                                // We will rethrow these so the outer exception handler can catch them, but we don't
                                 // want to log the outer exception stack here.
                                 throw exception;
                             }
 
-                            if (exception.GetType() == typeof(BuildAbortedException))
+                            if (exception is BuildAbortedException)
                             {
                                 // this is not a bug and should not dump stack. It will already have been logged
                                 // appropriately, there is no need to take any further action with it.
@@ -1421,20 +1440,31 @@ private static (BuildResultCode result, Exception exception) ExecuteRestore(stri
             restoreGlobalProperties["MSBuildRestoreSessionId"] = Guid.NewGuid().ToString("D");
 
             // Create a new request with a Restore target only and specify:
-            //  - BuildRequestDataFlags.ClearCachesAfterBuild to ensure the projects will be reloaded from disk for subsequent builds
-            //  - BuildRequestDataFlags.SkipNonexistentNonEntryTargets to ignore missing non-entry targets since Restore does not require that all targets
-            //      exist, only top-level ones like Restore itself
-            //  - BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports to ignore imports that don't exist, are empty, or are invalid because restore might
-            //     make available an import that doesn't exist yet and the <Import /> might be missing a condition.
-            //  - BuildRequestDataFlags.FailOnUnresolvedSdk to still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
-            //     fail the build.
+            BuildRequestDataFlags flags;
+
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+            {
+                flags =   BuildRequestDataFlags.ClearCachesAfterBuild                // ensure the projects will be reloaded from disk for subsequent builds
+                        | BuildRequestDataFlags.SkipNonexistentNonEntryTargets       // ignore missing non-entry targets since Restore does not require that all targets
+                                                                                     // exist, only top-level ones like Restore itself
+                        | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports  // ignore imports that don't exist, are empty, or are invalid because restore might
+                                                                                     // make available an import that doesn't exist yet and the <Import /> might be missing a condition.
+                        | BuildRequestDataFlags.FailOnUnresolvedSdk;                 // still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
+                                                                                     // fail the build.
+            }
+            else
+            {
+                // pre-16.10 flags allowed `-restore` to pass when there was no `Restore` target
+                flags = BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports;
+            }
+
             BuildRequestData restoreRequest = new BuildRequestData(
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
                 targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
                 hostServices: null,
-                flags: BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentNonEntryTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk);
+                flags);
 
             return ExecuteBuild(buildManager, restoreRequest);
         }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 5e1dee0ffee..8c91cf21b7d 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -52,11 +52,64 @@
           <codeBase version="16.10.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
+        <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools.net35" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+      </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.5.0" newVersion="4.0.5.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.0" newVersion="4.0.1.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.6.3.0" newVersion="4.6.3.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.2.0.0" newVersion="4.2.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 4dc44912a1d..ea9ce9319cf 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -41,11 +41,64 @@
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
         </dependentAssembly>
 
+        <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools.net35" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+      </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.5.0" newVersion="4.0.5.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.0" newVersion="4.0.1.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.6.3.0" newVersion="4.6.3.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.2.0.0" newVersion="4.2.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
diff --git a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
index 8b0a83ecc8b..c89e8c9e3c6 100644
--- a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
+++ b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
@@ -14,14 +14,14 @@ public class AssemblyMockCache : ProjectCachePluginBase
     {
         public AssemblyMockCache()
         {
-            ThrowFrom("Constructor");
+            ErrorFrom("Constructor", pluginLoggerBase: null);
         }
 
         public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: BeginBuildAsync", MessageImportance.High);
 
-            ThrowFrom(nameof(BeginBuildAsync));
+            ErrorFrom(nameof(BeginBuildAsync), logger);
 
             return Task.CompletedTask;
         }
@@ -33,7 +33,7 @@ public override Task<CacheResult> GetCacheResultAsync(
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
 
-            ThrowFrom(nameof(GetCacheResultAsync));
+            ErrorFrom(nameof(GetCacheResultAsync), logger);
 
             return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
         }
@@ -42,16 +42,22 @@ public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken ca
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: EndBuildAsync", MessageImportance.High);
 
-            ThrowFrom(nameof(EndBuildAsync));
+            ErrorFrom(nameof(EndBuildAsync), logger);
 
             return Task.CompletedTask;
         }
 
-        private static void ThrowFrom(string throwFrom)
+        private static void ErrorFrom(string errorLocation, PluginLoggerBase pluginLoggerBase)
         {
-            if (Environment.GetEnvironmentVariable(throwFrom) != null)
+            var errorKind = Environment.GetEnvironmentVariable(errorLocation);
+
+            switch (errorKind)
             {
-                throw new Exception($"Cache plugin exception from {throwFrom}");
+                case "Exception":
+                    throw new Exception($"Cache plugin exception from {errorLocation}");
+                case "LoggedError":
+                    pluginLoggerBase?.LogError($"Cache plugin logged error from {errorLocation}");
+                    break;
             }
         }
     }
