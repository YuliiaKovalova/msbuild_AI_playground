diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 83ea156bfaf..dce7ac92550 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -228,47 +228,6 @@ jobs:
     continueOnError: true
     condition: always()
 
-- job: MonoOnMac
-  # Mono CI disabled until it can parse C# 9 syntax: https://github.com/dotnet/msbuild/issues/6058
-  condition: eq(1,2)
-  displayName: "macOS Mono"
-  pool:
-    vmImage: 'macOS-10.14'
-  steps:
-  # https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted?view=azure-devops&tabs=yaml#mono
-  - bash: |
-      SYMLINK=6_4_2
-      MONOPREFIX=/Library/Frameworks/Mono.framework/Versions/$SYMLINK
-      echo "##vso[task.setvariable variable=DYLD_FALLBACK_LIBRARY_PATH;]$MONOPREFIX/lib:/lib:/usr/lib:$DYLD_LIBRARY_FALLBACK_PATH"
-      echo "##vso[task.setvariable variable=PKG_CONFIG_PATH;]$MONOPREFIX/lib/pkgconfig:$MONOPREFIX/share/pkgconfig:$PKG_CONFIG_PATH"
-      echo "##vso[task.setvariable variable=PATH;]$MONOPREFIX/bin:$PATH"
-    displayName: Use Mono 6.4.2
-  - bash: 'eng/cibuild_bootstrapped_msbuild.sh --host_type mono /p:SuppressLicenseValidation=true'
-    displayName: CI Build
-  - task: PublishTestResults@2
-    displayName: Publish Mono Test Results
-    inputs:
-      testRunTitle: 'macOS Mono'
-      testRunner: XUnit
-      testResultsFiles: 'artifacts/TestResults/Debug-MONO/*UnitTests*.xml'
-      publishRunAttachments: true
-      mergeTestResults: true
-    continueOnError: true
-    condition: always()
-  - task: PublishBuildArtifacts@1
-    displayName: 'Publish Artifact: logs'
-    inputs:
-      PathtoPublish: 'artifacts/log'
-      ArtifactName: 'MonoOnMac build logs'
-    condition: always()
-  - task: PublishBuildArtifacts@1
-    displayName: 'Publish Artifact: TestResults'
-    inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'MonoOnMac test logs'
-    continueOnError: true
-    condition: always()
-
 - template: /eng/common/templates/job/source-build.yml
   parameters:
     platform:
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 3866762f1e3..b0a121aea92 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -16,7 +16,6 @@
     <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.0.4492" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
-    <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
     <PackageReference Update="StyleCop.Analyzers" Version="1.2.0-beta.164" PrivateAssets="all" />
   </ItemGroup>
 
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index 47f7a7b0333..821da0c00f4 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -20,72 +20,6 @@ namespace Microsoft.Build.UnitTests.Construction
     /// </summary>
     public class SolutionFile_Tests
     {
-        [Theory]
-        [InlineData(@"
-                {
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
-                    ""projects2"": [
-                      ""src\\Build\\Microsoft.Build.csproj"",
-                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
-                      ""src\\MSBuild\\MSBuild.csproj"",
-                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
-                    ]
-                    }
-                }
-                ", "MSBuild.SolutionFilterJsonParsingError")]
-        [InlineData(@"
-                [{
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
-                    ""projects"": [
-                      ""src\\Build\\Microsoft.Build.csproj"",
-                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
-                      ""src\\MSBuild\\MSBuild.csproj"",
-                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
-                    ]
-                    }
-                }]
-                ", "MSBuild.SolutionFilterJsonParsingError")]
-        [InlineData(@"
-                {
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
-                    ""projects"": [
-                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
-                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
-                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
-                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
-                    ]
-                    }
-                }
-                ", "MSBuild.SolutionFilterJsonParsingError")]
-        [InlineData(@"
-                {
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath2\\MSBuild.Dev.sln"",
-                    ""projects"": [
-                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
-                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
-                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
-                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
-                    ]
-                    }
-                }
-                ", "MSBuild.SolutionFilterMissingSolutionError")]
-        public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
-        {
-            Assert.False(File.Exists("C:\\notAPath2\\MSBuild.Dev.sln"));
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
-            {
-                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
-                TransientTestFile sln = testEnvironment.CreateFile(folder, "Dev.sln");
-                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf", slnfValue.Replace(@"C:\\notAPath\\MSBuild.Dev.sln", sln.Path.Replace("\\", "\\\\")));
-                InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() => SolutionFile.Parse(slnf.Path));
-                e.HelpKeyword.ShouldBe(exceptionReason);
-            }
-        }
-
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
index b8f69fc9af0..7ce55c62dbb 100644
--- a/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
@@ -137,7 +137,7 @@ public void TestTranslation()
             copy.ProjectFullPath.ShouldBe(initial.ProjectFullPath);
             copy.ToolsVersion.ShouldBe(initial.ToolsVersion);
 
-            Assert.Equal(copy.GlobalProperties.GetCopyOnReadEnumerable(), initial.GlobalProperties.GetCopyOnReadEnumerable(), EqualityComparer<ProjectPropertyInstance>.Default);
+            Assert.Equal(copy.GlobalProperties, initial.GlobalProperties, EqualityComparer<ProjectPropertyInstance>.Default);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Collections/CopyOnReadEnumerable_Tests.cs b/src/Build.UnitTests/Collections/CopyOnReadEnumerable_Tests.cs
index a9eda40bf93..59c625f5ddd 100644
--- a/src/Build.UnitTests/Collections/CopyOnReadEnumerable_Tests.cs
+++ b/src/Build.UnitTests/Collections/CopyOnReadEnumerable_Tests.cs
@@ -1,9 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
+using Shouldly;
 using Xunit;
 
 #nullable disable
@@ -15,63 +15,43 @@ namespace Microsoft.Build.UnitTests.OM.Collections
     /// </summary>
     public class CopyOnReadEnumerable_Tests
     {
-        /// <summary>
-        /// Verify basic case
-        /// </summary>
         [Fact]
-        public void NonCloneableBackingCollection()
+        public void EnumeratesBackingCollection()
         {
             List<int> values = new List<int>(new int[] { 1, 2, 3 });
 
-            CopyOnReadEnumerable<int> enumerable = new CopyOnReadEnumerable<int>(values, values);
+            CopyOnReadEnumerable<int, string> enumerable = new CopyOnReadEnumerable<int, string>(values, values, i => i.ToString());
 
             using (IEnumerator<int> enumerator = values.GetEnumerator())
             {
-                foreach (int i in enumerable)
+                foreach (string s in enumerable)
                 {
                     enumerator.MoveNext();
-                    Assert.Equal(i, enumerator.Current);
+                    enumerator.Current.ToString().ShouldBe(s);
                 }
+                enumerator.MoveNext().ShouldBeFalse();
             }
         }
 
-        /// <summary>
-        /// Verify cloning case
-        /// </summary>
         [Fact]
-        public void CloneableBackingCollection()
+        public void CopiesBackingCollection()
         {
-            List<Cloneable> values = new List<Cloneable>(new Cloneable[] { new Cloneable(), new Cloneable(), new Cloneable() });
+            List<string> values = new List<string>(new string[] { "a", "b", "c" });
 
-            CopyOnReadEnumerable<Cloneable> enumerable = new CopyOnReadEnumerable<Cloneable>(values, values);
+            CopyOnReadEnumerable<string, string> enumerable = new CopyOnReadEnumerable<string, string>(values, values, s => s);
 
-            using (IEnumerator<Cloneable> enumerator = values.GetEnumerator())
-            {
-                foreach (Cloneable i in enumerable)
-                {
-                    enumerator.MoveNext();
-                    Assert.False(Object.ReferenceEquals(i, enumerator.Current)); // "Enumerator copied references."
-                }
-            }
-        }
+            int expectedCount = values.Count;
+            var enumerator = enumerable.GetEnumerator();
 
-        /// <summary>
-        /// A class used for testing cloneable backing collections.
-        /// </summary>
-        private class Cloneable : IDeepCloneable<Cloneable>
-        {
-            #region IDeepCloneable<Cloneable> Members
+            // The list has been copied and adding to it has no effect on the enumerable.
+            values.Add("d");
 
-            /// <summary>
-            /// Clones the object.
-            /// </summary>
-            /// <returns>The new instance.</returns>
-            public Cloneable DeepClone()
+            int actualCount = 0;
+            while (enumerator.MoveNext())
             {
-                return new Cloneable();
+                actualCount++;
             }
-
-            #endregion
+            actualCount.ShouldBe(expectedCount);
         }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index af601518dfe..347e2bbab77 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -25,70 +25,6 @@ public SolutionFile_Tests(ITestOutputHelper testOutputHelper)
             TestOutputHelper = testOutputHelper;
         }
 
-        /// <summary>
-        /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
-        /// </summary>
-        [Fact]
-        public void ParseSolutionFilter()
-        {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
-            {
-                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
-                TransientTestFolder src = testEnvironment.CreateFolder(Path.Combine(folder.Path, "src"), createFolder: true);
-                TransientTestFile microsoftBuild = testEnvironment.CreateFile(src, "Microsoft.Build.csproj");
-                TransientTestFile msbuild = testEnvironment.CreateFile(src, "MSBuild.csproj");
-                TransientTestFile commandLineUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.CommandLine.UnitTests.csproj");
-                TransientTestFile tasksUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.Tasks.UnitTests.csproj");
-                // The important part of this .sln is that it has references to each of the four projects we just created.
-                TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
-                    @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio 15
-                    VisualStudioVersion = 15.0.27004.2009
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
-                    EndProject
-                    Global
-                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        EndGlobalSection
-                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(ExtensibilityGlobals) = postSolution
-                    EndGlobalSection
-                    EndGlobal
-                    ");
-                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
-                    @"
-                    {
-                      ""solution"": {
-                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
-                        ""projects"": [
-                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!).Replace("\\", "\\\\") + @""",
-                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!).Replace("\\", "\\\\") + @"""
-                        ]
-                        }
-                    }");
-                SolutionFile sp = SolutionFile.Parse(slnf.Path);
-                sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!)).ShouldBeTrue();
-                sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!)).ShouldBeTrue();
-
-                
-                (sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)!))
-                 || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path)!))
-                 || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")))
-                    .ShouldBeFalse();
-            }
-        }
-
         /// <summary>
         /// Test just the most basic, plain vanilla first project line.
         /// </summary>
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
new file mode 100644
index 00000000000..400c3f6af52
--- /dev/null
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -0,0 +1,287 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Graph;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Engine.UnitTests.Construction
+{
+    public class SolutionFilter_Tests : IDisposable
+    {
+        private readonly ITestOutputHelper output;
+
+        private static readonly BuildEventContext _buildEventContext = new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0);
+
+        public SolutionFilter_Tests(ITestOutputHelper output)
+        {
+            this.output = output;
+        }
+
+        public void Dispose()
+        {
+            ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
+        }
+
+        /// <summary>
+        /// Test that a solution filter file excludes projects not covered by its list of projects or their dependencies.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SolutionFilterFiltersProjects(bool graphBuild)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFolder classLibSubFolder = testEnvironment.CreateFolder(Path.Combine(classLibFolder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibSubFolder, "ClassLibrary.csproj",
+                    @"<Project>
+                  <Target Name=""ClassLibraryTarget"">
+                      <Message Text=""ClassLibraryBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFolder simpleProjectSubFolder = testEnvironment.CreateFolder(Path.Combine(simpleProjectFolder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectSubFolder, "SimpleProject.csproj",
+                    @"<Project DefaultTargets=""SimpleProjectTarget"">
+                  <Target Name=""SimpleProjectTarget"">
+                      <Message Text=""SimpleProjectBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+                // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
+                TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29326.124
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", ""SimpleProject\SimpleProject.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", ""..\ClassLibrary\ClassLibrary\ClassLibrary.csproj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Any CPU = Debug|Any CPU
+                            Release|Any CPU = Release|Any CPU
+                            EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                        GlobalSection(ExtensibilityGlobals) = postSolution
+                            SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
+                        EndGlobalSection
+                    EndGlobal
+                ");
+                TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
+                    @"
+                {
+                  ""solution"": {
+                    // I'm a comment
+                    ""path"": "".\\SimpleProject\\SimpleProject.sln"",
+                    ""projects"": [
+                    /* ""..\\ClassLibrary\\ClassLibrary\\ClassLibrary.csproj"", */
+                      ""SimpleProject\\SimpleProject.csproj"",
+                    ]
+                    }
+                }
+                ");
+                Directory.GetCurrentDirectory().ShouldNotBe(Path.GetDirectoryName(filterFile.Path));
+                if (graphBuild)
+                {
+                    ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+                    MockLogger logger = new();
+                    projectCollection.RegisterLogger(logger);
+                    ProjectGraphEntryPoint entryPoint = new(filterFile.Path, new Dictionary<string, string>());
+
+                    // We only need to construct the graph, since that tells us what would build if we were to build it.
+                    ProjectGraph graphFromSolution = new(entryPoint, projectCollection);
+                    logger.AssertNoErrors();
+                    graphFromSolution.ProjectNodes.ShouldHaveSingleItem();
+                    graphFromSolution.ProjectNodes.Single().ProjectInstance.ProjectFileLocation.LocationString.ShouldBe(simpleProject.Path);
+                }
+                else
+                {
+                    SolutionFile solution = SolutionFile.Parse(filterFile.Path);
+                    ILoggingService mockLogger = CreateMockLoggingService();
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, mockLogger);
+                    instances.ShouldHaveSingleItem();
+
+                    // Check that dependencies are built, and non-dependencies in the .sln are not.
+                    MockLogger logger = new(output);
+                    instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+                    logger.AssertLogContains(new string[] { "SimpleProjectBuilt" });
+                    logger.AssertLogDoesntContain("ClassLibraryBuilt");
+                }
+            }
+        }
+
+        [Theory]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects2"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                [{
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }]
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath2\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterMissingSolutionError")]
+        public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
+        {
+            Assert.False(File.Exists("C:\\notAPath2\\MSBuild.Dev.sln"));
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Dev.sln");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf", slnfValue.Replace(@"C:\\notAPath\\MSBuild.Dev.sln", sln.Path.Replace("\\", "\\\\")));
+                InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() => SolutionFile.Parse(slnf.Path));
+                e.HelpKeyword.ShouldBe(exceptionReason);
+            }
+        }
+
+        /// <summary>
+        /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
+        /// </summary>
+        [Fact]
+        public void ParseSolutionFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder src = testEnvironment.CreateFolder(Path.Combine(folder.Path, "src"), createFolder: true);
+                TransientTestFile microsoftBuild = testEnvironment.CreateFile(src, "Microsoft.Build.csproj");
+                TransientTestFile msbuild = testEnvironment.CreateFile(src, "MSBuild.csproj");
+                TransientTestFile commandLineUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.CommandLine.UnitTests.csproj");
+                TransientTestFile tasksUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.Tasks.UnitTests.csproj");
+                // The important part of this .sln is that it has references to each of the four projects we just created.
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 15
+                    VisualStudioVersion = 15.0.27004.2009
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(ExtensibilityGlobals) = postSolution
+                    EndGlobalSection
+                    EndGlobal
+                    ");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
+                    @"
+                    {
+                      ""solution"": {
+                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
+                        ""projects"": [
+                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!).Replace("\\", "\\\\") + @""",
+                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!).Replace("\\", "\\\\") + @"""
+                        ]
+                        }
+                    }");
+                SolutionFile sp = SolutionFile.Parse(slnf.Path);
+                sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!)).ShouldBeTrue();
+                sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!)).ShouldBeTrue();
+
+
+                (sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)!))
+                 || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path)!))
+                 || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")))
+                    .ShouldBeFalse();
+            }
+        }
+
+        private ILoggingService CreateMockLoggingService()
+        {
+            ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 0);
+            MockLogger logger = new(output);
+            loggingService.RegisterLogger(logger);
+            return loggingService;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 56d5d33a7b7..124fd26cc45 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -83,100 +83,6 @@ public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
             }
         }
 
-        /// <summary>
-        /// Test that a solution filter file excludes projects not covered by its list of projects or their dependencies.
-        /// </summary>
-        [Fact]
-        public void SolutionFilterFiltersProjects()
-        {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
-            {
-                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);              
-                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "ClassLibrary"), createFolder: true);
-                TransientTestFolder classLibSubFolder = testEnvironment.CreateFolder(Path.Combine(classLibFolder.Path, "ClassLibrary"), createFolder: true);
-                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibSubFolder, "ClassLibrary.csproj",
-                    @"<Project>
-                  <Target Name=""ClassLibraryTarget"">
-                      <Message Text=""ClassLibraryBuilt""/>
-                  </Target>
-                  </Project>
-                    ");
-
-                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "SimpleProject"), createFolder: true);
-                TransientTestFolder simpleProjectSubFolder = testEnvironment.CreateFolder(Path.Combine(simpleProjectFolder.Path, "SimpleProject"), createFolder: true);
-                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectSubFolder, "SimpleProject.csproj",
-                    @"<Project DefaultTargets=""SimpleProjectTarget"">
-                  <Target Name=""SimpleProjectTarget"">
-                      <Message Text=""SimpleProjectBuilt""/>
-                  </Target>
-                  </Project>
-                    ");
-
-                // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
-                TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
-                    @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio Version 16
-                    VisualStudioVersion = 16.0.29326.124
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", ""SimpleProject\SimpleProject.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", ""..\ClassLibrary\ClassLibrary\ClassLibrary.csproj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
-                    EndProject
-                    Global
-                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                            Debug|Any CPU = Debug|Any CPU
-                            Release|Any CPU = Release|Any CPU
-                            EndGlobalSection
-                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.Build.0 = Release|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.Build.0 = Release|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.Build.0 = Release|Any CPU
-                        EndGlobalSection
-                        GlobalSection(SolutionProperties) = preSolution
-                            HideSolutionNode = FALSE
-                        EndGlobalSection
-                        GlobalSection(ExtensibilityGlobals) = postSolution
-                            SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
-                        EndGlobalSection
-                    EndGlobal
-                ");
-                TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
-                    @"
-                {
-                  ""solution"": {
-                    // I'm a comment
-                    ""path"": "".\\SimpleProject\\SimpleProject.sln"",
-                    ""projects"": [
-                    /* ""..\\ClassLibrary\\ClassLibrary\\ClassLibrary.csproj"", */
-                      ""SimpleProject\\SimpleProject.csproj"",
-                    ]
-                    }
-                }
-                ");
-                Directory.GetCurrentDirectory().ShouldNotBe(Path.GetDirectoryName(filterFile.Path));
-                SolutionFile solution = SolutionFile.Parse(filterFile.Path);
-                ILoggingService mockLogger = CreateMockLoggingService();
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, mockLogger);
-                instances.ShouldHaveSingleItem();
-
-                // Check that dependencies are built, and non-dependencies in the .sln are not.
-                MockLogger logger = new MockLogger(output);
-                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
-                logger.AssertLogContains(new string[] { "SimpleProjectBuilt" });
-                logger.AssertLogDoesntContain("ClassLibraryBuilt");
-            }
-        }
-
         [Fact]
         public void BuildProjectAsTarget()
         {
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 5e7a14912d7..0920d71c8df 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Construction;
@@ -9,8 +10,12 @@
 using System.Xml;
 using Microsoft.Build.Framework;
 using System.IO;
+using System.Linq;
 using Xunit;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Shouldly;
 
 #nullable disable
 
@@ -21,6 +26,25 @@ namespace Microsoft.Build.UnitTests.OM.Instance
     /// </summary>
     public class TaskItem_Tests
     {
+        internal static readonly string[] s_builtInMetadataNames =
+        {
+            "FullPath",
+            "RootDir",
+            "Filename",
+            "Extension",
+            "RelativeDir",
+            "Directory",
+            "RecursiveDir",
+            "Identity",
+            "ModifiedTime",
+            "CreatedTime",
+            "AccessedTime",
+            "DefiningProjectFullPath",
+            "DefiningProjectDirectory",
+            "DefiningProjectName",
+            "DefiningProjectExtension"
+        };
+
         /// <summary>
         /// Test serialization
         /// </summary>
@@ -61,7 +85,7 @@ public void TestEquivalence()
             TaskItem right = new TaskItem("foo", "bar.proj");
 
             Assert.Equal(left, right);
-            Assert.Equal(left, right);
+            Assert.Equal(right, left);
         }
 
         /// <summary>
@@ -76,7 +100,7 @@ public void TestEquivalenceWithCustomMetadata()
             right.SetMetadata("a", "b");
 
             Assert.Equal(left, right);
-            Assert.Equal(left, right);
+            Assert.Equal(right, left);
         }
 
         /// <summary>
@@ -91,7 +115,7 @@ public void TestInequivalenceWithDifferentCustomMetadataValues()
             right.SetMetadata("a", "c");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -106,7 +130,7 @@ public void TestInequivalenceWithDifferentCustomMetadataKeys()
             right.SetMetadata("b", "b");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -120,7 +144,7 @@ public void TestInequivalenceWithDifferentCustomMetadataCount()
             TaskItem right = new TaskItem("foo", "bar.proj");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -136,7 +160,7 @@ public void TestInequivalenceWithDifferentCustomMetadataCount2()
             right.SetMetadata("c", "d");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -151,9 +175,65 @@ public void TestDeepClone()
 
             TaskItem clone = parent.DeepClone();
             Assert.True(parent.Equals(clone)); // "The parent and the clone should be equal"
+            Assert.True(clone.Equals(parent)); // "The parent and the clone should be equal"
             Assert.False(object.ReferenceEquals(parent, clone)); // "The parent and the child should not be the same object"
         }
 
+        /// <summary>
+        /// Validate the presentation of metadata on a TaskItem, both of direct values and those inherited from
+        /// item definitions.
+        /// </summary>
+        [Fact]
+        public void Metadata()
+        {
+            TaskItem item = BuildItem(
+                definitions: new[] { ("a", "base"), ("b", "base") },
+                metadata: new[] { ("a", "override") });
+
+            item.MetadataNames.Cast<string>().ShouldBeSetEquivalentTo(new[] { "a", "b" }.Concat(s_builtInMetadataNames));
+            item.MetadataCount.ShouldBe(s_builtInMetadataNames.Length + 2);
+            item.DirectMetadataCount.ShouldBe(1);
+
+            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
+            metadata.Count.ShouldBe(2);
+            metadata["a"].EvaluatedValue.ShouldBe("override");
+            metadata["b"].EvaluatedValue.ShouldBe("base");
+
+            item.EnumerateMetadata().ShouldBeSetEquivalentTo(new KeyValuePair<string, string>[] { new("a", "override"), new("b", "base") });
+
+            ((Dictionary<string, string>)item.CloneCustomMetadata()).ShouldBeSetEquivalentTo(new KeyValuePair<string, string>[] { new("a", "override"), new("b", "base") });
+
+            static TaskItem BuildItem(
+                IEnumerable<(string Name, string Value)> definitions = null,
+                IEnumerable<(string Name, string Value)> metadata = null)
+            {
+                List<ProjectItemDefinitionInstance> itemDefinitions = new();
+                if (definitions is not null)
+                {
+                    Project project = new();
+
+                    foreach ((string name, string value) in definitions)
+                    {
+                        ProjectItemDefinition projectItemDefinition = new ProjectItemDefinition(project, "MyItem");
+                        projectItemDefinition.SetMetadataValue(name, value);
+                        ProjectItemDefinitionInstance itemDefinition = new(projectItemDefinition);
+                        itemDefinitions.Add(itemDefinition);
+                    }
+                }
+
+                CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = new();
+                if (metadata is not null)
+                {
+                    foreach ((string name, string value) in metadata)
+                    {
+                        directMetadata.Set(new(name, value));
+                    }
+                }
+
+                return new TaskItem("foo", "foo", directMetadata, itemDefinitions, "dir", immutable: false, "bar.proj");
+            }
+        }
+
         /// <summary>
         /// Flushing an item through a task should not mess up special characters on the metadata. 
         /// </summary>
@@ -198,7 +278,7 @@ public void Escaping1()
 
             Project project = new Project(xml);
             MockLogger logger = new MockLogger();
-            project.Build("Build", new ILogger[] { logger });
+            project.Build("Build", new ILogger[] { logger }).ShouldBeTrue();
 
             logger.AssertLogContains("[i1m1]");
             logger.AssertLogContains("[i1m2]");
@@ -255,7 +335,7 @@ public void Escaping2()
 
             Project project = new Project(xml);
             MockLogger logger = new MockLogger();
-            project.Build("Build", new ILogger[] { logger });
+            project.Build("Build", new ILogger[] { logger }).ShouldBeTrue();
 
             logger.AssertLogContains("[i1m1]");
             logger.AssertLogContains("[i1m2]");
@@ -293,7 +373,7 @@ public void Escaping3()
 
             Project project = new Project(xml);
             MockLogger logger = new MockLogger();
-            project.Build("Build", new ILogger[] { logger });
+            project.Build("Build", new ILogger[] { logger }).ShouldBeTrue();
 
             logger.AssertLogContains("i1%2ai2");
         }
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 757b6d032d6..4c337378637 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -27,7 +27,8 @@ public static string SerializeCaches(IConfigCache configCache, IResultsCache res
 
                 Directory.CreateDirectory(Path.GetDirectoryName(fullPath));
 
-                using (var fileStream = File.OpenWrite(fullPath))
+                // Use FileStream constructor (File.OpenWrite should not be used as it doesn't reset the length of the file!)
+                using (var fileStream = new FileStream(fullPath, FileMode.Create, FileAccess.Write, FileShare.None))
                 {
                     var translator = BinaryTranslator.GetWriteTranslator(fileStream);
 
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index a2973596f22..bc39a5ccd32 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
@@ -91,11 +90,8 @@ private ProjectLoggingContext(
         {
             _projectFullPath = projectFullPath;
 
-            ProjectPropertyInstanceEnumeratorProxy properties = null;
-            ProjectItemInstanceEnumeratorProxy items = null;
-
-            IEnumerable<ProjectPropertyInstance> projectPropertiesEnumerator = projectProperties == null ? Enumerable.Empty<ProjectPropertyInstance>() : null;
-            IEnumerable<ProjectItemInstance> projectItemsEnumerator = projectItems == null ? Enumerable.Empty<ProjectItemInstance>() : null;
+            IEnumerable<DictionaryEntry> properties = null;
+            IEnumerable<DictionaryEntry> items = null;
 
             string[] propertiesToSerialize = LoggingService.PropertiesToSerialize;
 
@@ -104,18 +100,8 @@ private ProjectLoggingContext(
                 !LoggingService.IncludeEvaluationPropertiesAndItems &&
                 (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
-                if (projectProperties != null)
-                {
-                    projectPropertiesEnumerator = projectProperties.GetCopyOnReadEnumerable();
-                }
-
-                if (projectItems != null)
-                {
-                    projectItemsEnumerator = projectItems.GetCopyOnReadEnumerable();
-                }
-
-                properties = new ProjectPropertyInstanceEnumeratorProxy(projectPropertiesEnumerator);
-                items = new ProjectItemInstanceEnumeratorProxy(projectItemsEnumerator);
+                properties = projectProperties?.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue)) ?? Enumerable.Empty<DictionaryEntry>();
+                items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
             }
 
             if (projectProperties != null &&
@@ -135,7 +121,7 @@ private ProjectLoggingContext(
                     }
                 }
 
-                properties = new ProjectPropertyInstanceEnumeratorProxy(projectPropertiesToSerialize);
+                properties = projectPropertiesToSerialize.Select((ProjectPropertyInstance property) => new DictionaryEntry(property.Name, property.EvaluatedValue));
             }
 
             this.BuildEventContext = LoggingService.LogProjectStarted
@@ -180,105 +166,5 @@ internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, Proj
             ErrorUtilities.VerifyThrow(this.IsValid, "invalid");
             return new TargetLoggingContext(this, projectFullPath, target, parentTargetName, buildReason);
         }
-
-        /// <summary>
-        /// An enumerable wrapper for items that clones items as they are requested,
-        /// so that writes have no effect on the items.
-        /// </summary>
-        /// <remarks>
-        /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when
-        /// a logger chooses to enumerate over it.
-        /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
-        /// </remarks>
-        private class ProjectItemInstanceEnumeratorProxy : IEnumerable<DictionaryEntry>
-        {
-            /// <summary>
-            /// Enumerable that this proxies
-            /// </summary>
-            private IEnumerable<ProjectItemInstance> _backingItems;
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            /// <param name="backingItems">Enumerator this class should proxy</param>
-            internal ProjectItemInstanceEnumeratorProxy(IEnumerable<ProjectItemInstance> backingItems)
-            {
-                _backingItems = backingItems;
-            }
-
-            /// <summary>
-            /// Returns an enumerator that provides copies of the items
-            /// in the backing store.
-            /// Each dictionary entry has key of the item type and value of an ITaskItem.
-            /// Type of the enumerator is imposed by backwards compatibility for ProjectStartedEvent.
-            /// </summary>
-            public IEnumerator<DictionaryEntry> GetEnumerator()
-            {
-                foreach (ProjectItemInstance item in _backingItems)
-                {
-                    yield return new DictionaryEntry(item.ItemType, new TaskItem(item));
-                }
-            }
-
-            /// <summary>
-            /// Returns an enumerator that provides copies of the items
-            /// in the backing store.
-            /// </summary>
-            IEnumerator IEnumerable.GetEnumerator()
-            {
-                return (IEnumerator)GetEnumerator();
-            }
-        }
-
-        /// <summary>
-        /// An enumerable wrapper for properties that clones properties as they are requested,
-        /// so that writes have no effect on the properties.
-        /// </summary>
-        /// <remarks>
-        /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when
-        /// a logger chooses to enumerate over it.
-        /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
-        /// </remarks>
-        private class ProjectPropertyInstanceEnumeratorProxy : IEnumerable<DictionaryEntry>
-        {
-            /// <summary>
-            /// Enumerable that this proxies
-            /// </summary>
-            private IEnumerable<ProjectPropertyInstance> _backingProperties;
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            /// <param name="backingProperties">Enumerator this class should proxy</param>
-            internal ProjectPropertyInstanceEnumeratorProxy(IEnumerable<ProjectPropertyInstance> backingProperties)
-            {
-                _backingProperties = backingProperties;
-            }
-
-            /// <summary>
-            /// Returns an enumerator that provides copies of the properties
-            /// in the backing store.
-            /// Each DictionaryEntry has key of the property name and value of the property value.
-            /// Type of the enumerator is imposed by backwards compatibility for ProjectStartedEvent.
-            /// </summary>
-            public IEnumerator<DictionaryEntry> GetEnumerator()
-            {
-                foreach (ProjectPropertyInstance property in _backingProperties)
-                {
-                    yield return new DictionaryEntry(property.Name, property.EvaluatedValue);
-                }
-            }
-
-            /// <summary>
-            /// Returns an enumerator that provides copies of the properties
-            /// in the backing store.
-            /// </summary>
-            IEnumerator IEnumerable.GetEnumerator()
-            {
-                return (IEnumerator)GetEnumerator();
-            }
-        }
     }
 }
diff --git a/src/Build/Collections/CopyOnReadEnumerable.cs b/src/Build/Collections/CopyOnReadEnumerable.cs
index 4a902ec1bcd..437d417df30 100644
--- a/src/Build/Collections/CopyOnReadEnumerable.cs
+++ b/src/Build/Collections/CopyOnReadEnumerable.cs
@@ -1,8 +1,10 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -10,38 +12,44 @@
 namespace Microsoft.Build.Collections
 {
     /// <summary>
-    /// A class which implements IEnumerable by creating an optionally-deep copy of the backing collection.
+    /// A class which implements IEnumerable by creating a copy of the backing collection.
     /// </summary>
     /// <remarks>
-    /// If the type contained in the collection implements IDeepCloneable then the copies will be deep clones instead
-    /// of mere reference copies.
     /// <see cref="GetEnumerator()"/> is thread safe for concurrent access.
     /// </remarks>
-    /// <typeparam name="T">The type contained in the backing collection.</typeparam>
-    internal class CopyOnReadEnumerable<T> : IEnumerable<T>
+    /// <typeparam name="TSource">The type contained in the backing collection.</typeparam>
+    /// <typeparam name="TResult">The type of items being enumerated.</typeparam>
+    internal class CopyOnReadEnumerable<TSource, TResult> : IEnumerable<TResult>
     {
         /// <summary>
         /// The backing collection.
         /// </summary>
-        private readonly IEnumerable<T> _backingEnumerable;
+        private readonly IEnumerable<TSource> _backingEnumerable;
 
         /// <summary>
         /// The object used to synchronize access for copying.
         /// </summary>
         private readonly object _syncRoot;
 
+        /// <summary>
+        /// The function to translate items in the backing collection to the resulting type.
+        /// </summary>
+        private readonly Func<TSource, TResult> _selector;
+
         /// <summary>
         /// Constructor.
         /// </summary>
         /// <param name="backingEnumerable">The collection which serves as a source for enumeration.</param>
         /// <param name="syncRoot">The object used to synchronize access for copying.</param>
-        public CopyOnReadEnumerable(IEnumerable<T> backingEnumerable, object syncRoot)
+        /// <param name="selector">function to translate items in the backing collection to the resulting type.</param>
+        public CopyOnReadEnumerable(IEnumerable<TSource> backingEnumerable, object syncRoot, Func<TSource, TResult> selector)
         {
             ErrorUtilities.VerifyThrowArgumentNull(backingEnumerable, nameof(backingEnumerable));
             ErrorUtilities.VerifyThrowArgumentNull(syncRoot, nameof(syncRoot));
 
             _backingEnumerable = backingEnumerable;
             _syncRoot = syncRoot;
+            _selector = selector;
         }
 
         #region IEnumerable<T> Members
@@ -50,37 +58,28 @@ public CopyOnReadEnumerable(IEnumerable<T> backingEnumerable, object syncRoot)
         /// Returns an enumerator over the collection.
         /// </summary>
         /// <returns>The enumerator.</returns>
-        public IEnumerator<T> GetEnumerator()
+        public IEnumerator<TResult> GetEnumerator()
         {
-            List<T> list;
+            List<TResult> list;
+
+#if NETCOREAPP
+            if (_backingEnumerable.TryGetNonEnumeratedCount(out int count))
+            {
+#else
             if (_backingEnumerable is ICollection backingCollection)
             {
-                list = new List<T>(backingCollection.Count);
+                int count = backingCollection.Count;
+#endif
+                list = new List<TResult>(count);
             }
             else
             {
-                list = new List<T>();
+                list = new List<TResult>();
             }
 
-            bool isCloneable = false;
-            bool checkForCloneable = true;
             lock (_syncRoot)
             {
-                foreach (T item in _backingEnumerable)
-                {
-                    if (checkForCloneable)
-                    {
-                        if (item is IDeepCloneable<T>)
-                        {
-                            isCloneable = true;
-                        }
-
-                        checkForCloneable = false;
-                    }
-
-                    T copiedItem = isCloneable ? (item as IDeepCloneable<T>).DeepClone() : item;
-                    list.Add(copiedItem);
-                }
+                list.AddRange(_backingEnumerable.Select(_selector));
             }
 
             return list.GetEnumerator();
@@ -96,7 +95,7 @@ public IEnumerator<T> GetEnumerator()
         /// <returns>The enumerator.</returns>
         IEnumerator IEnumerable.GetEnumerator()
         {
-            return ((IEnumerable<T>)this).GetEnumerator();
+            return ((IEnumerable<TResult>)this).GetEnumerator();
         }
 
         #endregion
diff --git a/src/Build/Collections/IDeepCloneable.cs b/src/Build/Collections/IDeepCloneable.cs
deleted file mode 100644
index 4e0c467fdff..00000000000
--- a/src/Build/Collections/IDeepCloneable.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-#nullable disable
-
-namespace Microsoft.Build.Collections
-{
-    /// <summary>
-    /// An interface representing an item which can clone itself.
-    /// </summary>
-    /// <typeparam name="T">The type returned by the clone operation.</typeparam>
-    internal interface IDeepCloneable<out T>
-    {
-        /// <summary>
-        /// Creates a clone of the item where no data references are shared.  Changes made to the clone
-        /// do not affect the original item.
-        /// </summary>
-        /// <returns>The cloned item.</returns>
-        T DeepClone();
-    }
-}
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index 3f0aa891501..10989b36622 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -148,9 +148,9 @@ public void Clear()
         /// <summary>
         /// Returns an enumerable which copies the underlying data on read.
         /// </summary>
-        public IEnumerable<T> GetCopyOnReadEnumerable()
+        public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
         {
-            return new CopyOnReadEnumerable<T>(this, _itemLists);
+            return new CopyOnReadEnumerable<T, TResult>(this, _itemLists, selector);
         }
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 9edb5b2211a..875be364ea0 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -205,12 +205,11 @@ internal T this[string name]
         }
 
         /// <summary>
-        /// Returns an enumerable which clones the properties 
+        /// Returns an enumerable which copies the underlying data on read.
         /// </summary>
-        /// <returns>Returns a cloning enumerable.</returns>
-        public IEnumerable<T> GetCopyOnReadEnumerable()
+        public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
         {
-            return new CopyOnReadEnumerable<T>(this, _properties);
+            return new CopyOnReadEnumerable<T, TResult>(this, _properties, selector);
         }
 
         /// <summary>
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 0e55dd3d119..f39c9230244 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -304,7 +304,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
             IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutionFile)
             {
-                return solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat).ToImmutableArray();
+                return solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat && solutionFile.ProjectShouldBuild(p.RelativePath)).ToImmutableArray();
             }
 
             SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, ImmutableDictionary<string, string> globalProperties)
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 2932b6dd942..4d5d9804805 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -34,7 +34,6 @@ public class ProjectItemInstance :
         ITaskItem2,
         IMetadataTable,
         ITranslatable,
-        IDeepCloneable<ProjectItemInstance>,
         IMetadataContainer
     {
         /// <summary>
@@ -582,19 +581,6 @@ void ITranslatable.Translate(ITranslator translator)
 
         #endregion
 
-        #region IDeepCloneable<T>
-
-        /// <summary>
-        /// Deep clone the item.
-        /// Any metadata inherited from item definitions are also copied.
-        /// </summary>
-        ProjectItemInstance IDeepCloneable<ProjectItemInstance>.DeepClone()
-        {
-            return DeepClone();
-        }
-
-        #endregion
-
         /// <summary>
         /// Set all the supplied metadata on all the supplied items.
         /// </summary>
@@ -796,7 +782,7 @@ internal sealed class TaskItem :
             /// Creates an instance of this class given the item-spec.
             /// </summary>
             internal TaskItem(string includeEscaped, string definingFileEscaped)
-                : this(includeEscaped, includeEscaped, null, null, null, /* mutable */ false, definingFileEscaped)
+                : this(includeEscaped, includeEscaped, null, null, null, immutable: false, definingFileEscaped)
             {
             }
 
@@ -835,13 +821,6 @@ internal TaskItem(ProjectItemInstance item)
             {
             }
 
-            /// <summary>
-            /// Constructor for deserialization only.
-            /// </summary>
-            private TaskItem()
-            {
-            }
-
             /// <summary>
             /// Creates an instance of this class given the backing item.
             /// Does not copy immutability, since there is no connection with the original.
@@ -930,13 +909,17 @@ public ICollection MetadataNames
             {
                 get
                 {
-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);
+                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
+
+                    List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);
 
-                    foreach (string name in FileUtilities.ItemSpecModifiers.All)
+                    foreach (ProjectMetadataInstance metadatum in metadataCollection)
                     {
-                        names.Add(name);
+                        names.Add(metadatum.Name);
                     }
 
+                    names.AddRange(FileUtilities.ItemSpecModifiers.All);
+
                     return names;
                 }
             }
@@ -950,37 +933,6 @@ public int MetadataCount
                 get { return MetadataNames.Count; }
             }
 
-            /// <summary>
-            /// Gets the names of custom metadata on the item.
-            /// If there is none, returns an empty collection.
-            /// Does not include built-in metadata.
-            /// Computed, not necessarily fast.
-            /// </summary>
-            public ICollection CustomMetadataNames
-            {
-                get
-                {
-                    List<string> names = new List<string>();
-
-                    foreach (ProjectMetadataInstance metadatum in MetadataCollection)
-                    {
-                        names.Add(metadatum.Name);
-                    }
-
-                    return names;
-                }
-            }
-
-            /// <summary>
-            /// Gets the number of custom metadata set on the item.
-            /// Does not include built-in metadata.
-            /// Computed, not necessarily fast.
-            /// </summary>
-            public int CustomMetadataCount
-            {
-                get { return CustomMetadataNames.Count; }
-            }
-
             /// <summary>
             /// Gets the evaluated include for this item, unescaped.
             /// </summary>
@@ -1158,7 +1110,7 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
                             }
                             else
                             {
-                                Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/microsoft/msbuild/issues/5267");
+                                Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/dotnet/msbuild/issues/5267");
                             }
                         }
                     }
@@ -1174,7 +1126,7 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
                             }
                             else
                             {
-                                Debug.Fail("metadatum in _directMetadata is null, see https://github.com/microsoft/msbuild/issues/5267");
+                                Debug.Fail("metadatum in _directMetadata is null, see https://github.com/dotnet/msbuild/issues/5267");
                             }
                         }
                     }
@@ -1576,9 +1528,8 @@ public bool Equals(TaskItem other)
                     return true;
                 }
 
-                // Since both sides are this class, we know both sides support ITaskItem2.
-                ITaskItem2 thisAsITaskItem2 = this as ITaskItem2;
-                ITaskItem2 otherAsITaskItem2 = other as ITaskItem2;
+                ITaskItem2 thisAsITaskItem2 = this;
+                ITaskItem2 otherAsITaskItem2 = other;
 
                 // This is case-insensitive. See GetHashCode().
                 if (!MSBuildNameIgnoreCaseComparer.Default.Equals(thisAsITaskItem2.EvaluatedIncludeEscaped, otherAsITaskItem2.EvaluatedIncludeEscaped))
@@ -1586,13 +1537,45 @@ public bool Equals(TaskItem other)
                     return false;
                 }
 
-                if (this.CustomMetadataCount != other.CustomMetadataCount)
+                // Metadata can come from both item definitions and direct values, and they must
+                // be applied in order, with later values overriding newer ones. Here we determine
+                // the set of metadata names on 'this', to avoid computing the full metadata collection
+                // of both 'this' and 'other'. Once we have the names for 'this', we enumerate 'other'
+                // and ensure the names we see there are set-equal to the names we produce here.
+                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+
+                if (_itemDefinitions is not null)
+                {
+                    foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)
+                    {
+                        thisNames.UnionWith(itemDefinition.MetadataNames);
+                    }
+                }
+
+                if (_directMetadata is not null)
+                {
+                    foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                    {
+                        thisNames.Add(metadatum.Name);
+                    }
+                }
+
+                CopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
+
+                if (otherMetadata.Count != thisNames.Count)
                 {
                     return false;
                 }
 
-                foreach (string name in this.CustomMetadataNames)
+                foreach (ProjectMetadataInstance metadatum in otherMetadata)
                 {
+                    string name = metadatum.Name;
+
+                    if (!thisNames.Remove(name))
+                    {
+                        return false;
+                    }
+
                     // This is case-insensitive, so that for example "en-US" and "en-us" match and are bucketed together.
                     // In this respect, therefore, we have to consider item metadata value case as not significant.
                     if (!String.Equals
@@ -1608,7 +1591,7 @@ public bool Equals(TaskItem other)
                 }
 
                 // Do not consider mutability for equality comparison
-                return true;
+                return thisNames.Count == 0;
             }
 
 #endregion
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index a6e9912f5f1..b60c69b1cf0 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Execution
     /// IMMUTABLE OBJECT.
     /// </summary>
     [DebuggerDisplay("{_name}={EvaluatedValue}")]
-    public class ProjectMetadataInstance : IEquatable<ProjectMetadataInstance>, ITranslatable, IMetadatum, IDeepCloneable<ProjectMetadataInstance>, IImmutable
+    public class ProjectMetadataInstance : IEquatable<ProjectMetadataInstance>, ITranslatable, IMetadatum, IImmutable
     {
         /// <summary>
         /// Name of the metadatum
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index 1eb578565e7..e935b611067 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Execution
     /// Added and removed via methods on the ProjectInstance object.
     /// </summary>
     [DebuggerDisplay("{_name}={_escapedValue}")]
-    public class ProjectPropertyInstance : IKeyed, IValued, IProperty, IEquatable<ProjectPropertyInstance>, ITranslatable, IDeepCloneable<ProjectPropertyInstance>
+    public class ProjectPropertyInstance : IKeyed, IValued, IProperty, IEquatable<ProjectPropertyInstance>, ITranslatable
     {
         /// <summary>
         /// Name of the property
@@ -140,18 +140,6 @@ void ITranslatable.Translate(ITranslator translator)
 
         #endregion
 
-        #region IDeepCloneable<T>
-
-        /// <summary>
-        /// Performs a deep clone
-        /// </summary>
-        ProjectPropertyInstance IDeepCloneable<ProjectPropertyInstance>.DeepClone()
-        {
-            return DeepClone();
-        }
-
-        #endregion
-
         /// <summary>
         /// String representation handy for tracing
         /// </summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 19c39093f3f..cd99bc84721 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -356,7 +356,6 @@
       <Link>Collections\CopyOnWriteDictionary.cs</Link>
     </Compile>
     <Compile Include="Collections\CopyOnWritePropertyDictionary.cs" />
-    <Compile Include="Collections\IDeepCloneable.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 870998c8d61..5d45a8377c2 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -207,6 +207,13 @@ elementFormDefault="qualified">
                   </xs:documentation>
                 </xs:annotation>
               </xs:element>
+              <xs:element name="GeneratePathProperty">
+                <xs:annotation>
+                  <xs:documentation>
+                    <!-- _locID_text="PackageReference_GeneratePathProperty" _locComment="" -->Set to true to generate a Pkg* property that points to the restored location of the NuGet package contents. If unset, does not create the property.
+                  </xs:documentation>
+                </xs:annotation>
+              </xs:element>
             </xs:choice>
           </xs:sequence>
           <xs:attribute name="Include" type="xs:string">
@@ -251,6 +258,13 @@ elementFormDefault="qualified">
               </xs:documentation>
             </xs:annotation>
           </xs:attribute>
+          <xs:attribute name="GeneratePathProperty" type="xs:string" use="optional">
+            <xs:annotation>
+              <xs:documentation>
+                <!-- _locID_text="PackageReference_Attribute_GeneratePathProperty" _locComment="" -->Set to true to generate a Pkg* property that points to the restored location of the NuGet package contents
+              </xs:documentation>
+            </xs:annotation>
+          </xs:attribute>
         </xs:extension>
       </xs:complexContent>
     </xs:complexType>
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index cc9f10fdb27..f56435ec284 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -210,7 +210,6 @@
   <ItemGroup>
     <!-- Disabled PdbGit because of warnings; it could/should be brought back.
     <PackageReference Include="PdbGit" /> -->
-    <PackageReference Include="SourceLink.Create.CommandLine" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index a47cdc11910..ea07be62ce7 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -3349,13 +3349,13 @@ private void WriteBinaryResources(ReaderInfo reader, string filename)
         {
             if (_usePreserializedResources && HaveSystemResourcesExtensionsReference)
             {
-                WriteResources(reader, new PreserializedResourceWriter(File.OpenWrite(filename))); // closes writer for us
+                WriteResources(reader, new PreserializedResourceWriter(new FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.None))); // closes writer for us
                 return;
             }
 
             try
             {
-                WriteResources(reader, new ResourceWriter(File.OpenWrite(filename))); // closes writer for us
+                WriteResources(reader, new ResourceWriter(new FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.None))); // closes writer for us
             }
             catch (PreserializedResourceWriterRequiredException)
             {
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index a4e0f73e445..f182975a6ac 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -5,7 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-
+using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -82,22 +82,20 @@ public void NullITaskItem()
             }
            );
         }
-        /// <summary>
-        /// Even without any custom metadata metadatanames should
-        /// return the built in metadata
-        /// </summary>
+
         [Fact]
-        public void MetadataNamesNoCustomMetadata()
+        public void MetadataNamesAndCount()
         {
             TaskItem taskItem = new TaskItem("x");
 
-            taskItem.MetadataNames.Count.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length);
+            // Without custom metadata, should return the built in metadata
+            taskItem.MetadataNames.Cast<string>().ShouldBeSetEquivalentTo(FileUtilities.ItemSpecModifiers.All);
             taskItem.MetadataCount.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length);
 
             // Now add one
             taskItem.SetMetadata("m", "m1");
 
-            taskItem.MetadataNames.Count.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length + 1);
+            taskItem.MetadataNames.Cast<string>().ShouldBeSetEquivalentTo(FileUtilities.ItemSpecModifiers.All.Concat(new[] { "m" }));
             taskItem.MetadataCount.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length + 1);
         }
 
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 3df50ef974a..6ee95e78c01 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -196,7 +196,15 @@ public ICollection MetadataNames
         {
             get
             {
-                var metadataNames = new List<string>(_metadata?.Keys ?? Array.Empty<string>());
+                int count = (_metadata?.Count ?? 0) + FileUtilities.ItemSpecModifiers.All.Length;
+
+                var metadataNames = new List<string>(capacity: count);
+
+                if (_metadata is not null)
+                {
+                    metadataNames.AddRange(_metadata.Keys);
+                }
+
                 metadataNames.AddRange(FileUtilities.ItemSpecModifiers.All);
 
                 return metadataNames;
