diff --git a/.gitignore b/.gitignore
index cf8134eada3..4b481121c52 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,6 +21,9 @@ artifacts/
 # Visual Studio 2015 cache/options directory
 .vs/
 
+# Verify result files
+*.received.*
+
 *_i.c
 *_p.c
 *_i.h
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 8ff78b900be..38f88c99b08 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -100,7 +100,12 @@ jobs:
 - job: FullReleaseOnWindows
   displayName: "Windows Full Release (no bootstrap)"
   pool:
-    vmImage: 'windows-2022'
+    ${{ if eq(variables['System.TeamProject'], 'public') }}:
+      name: NetCore-Public
+      demands: ImageOverride -equals windows.vs2022preview.amd64.open
+    ${{ if ne(variables['System.TeamProject'], 'public') }}:
+      name: VSEngSS-MicroBuild2022-1ES
+      demands: agent.os -equals Windows_NT
   steps:
   - task: BatchScript@1
     displayName: cibuild.cmd
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index c32ce098b34..62ce1c7f273 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -23,12 +23,9 @@ variables:
   - name: SourceBranch
     value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
-  # NOTE: the code is temporarily fixed. For the branches that should use opt-prof from the main branch we should use the latest working Opt-Prof collected from main 20230217.4.
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
-    - name: OptProfDrop
-      value: 'OptimizationData/DotNet-msbuild-Trusted/main/20230217.4/7352286/1'   
     - name: SourceBranch
-      value: ''
+      value: main
   # if OptProfDropName is set as a parameter, set OptProfDrop to the parameter and unset SourceBranch
   - ${{ if ne(parameters.OptProfDropName, 'default') }}:
     - name: OptProfDrop
@@ -39,6 +36,8 @@ variables:
     value: .NETCore
   - name: _DotNetValidationArtifactsCategory
     value: .NETCoreValidation
+  - name: EnableReleaseOneLocBuild
+    value: true
   - name: Codeql.Enabled
     value: true
 
@@ -47,13 +46,30 @@ stages:
   displayName: Build
 
   jobs:
-  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}: # should track next-release's active dev branch
-    - template: /eng/common/templates/job/onelocbuild.yml
-      parameters:
-        LclSource: lclFilesfromPackage
-        LclPackageId: 'LCL-JUNO-PROD-MSBUILD'
-        MirrorRepo: 'msbuild'
-        MirrorBranch: 'main' # should match condition above
+  - ${{ if and( ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    # The localization setup for release/ branches. Note difference in LclPackageId. main branch is handled separately below.
+    # Used for vs17.2, vs17.4, vs17.6 etc. branches only.
+    # When the branch is setup for localization (the localization ticket needs to be created - https://aka.ms/ceChangeLocConfig, requesting change from one release branch to another),
+    #  set 'EnableReleaseOneLocBuild' to true.
+    - ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/vs') }}:
+      - template: /eng/common/templates/job/onelocbuild.yml
+        parameters:
+          MirrorRepo: 'msbuild'
+          LclSource: lclFilesfromPackage
+          LclPackageId: 'LCL-JUNO-PROD-MSBUILDREL'
+          MirrorBranch: ${{ replace(variables['Build.SourceBranch'], 'refs/heads/', '') }}
+          JobNameSuffix: '_release'
+          condition: ${{ variables.EnableReleaseOneLocBuild }}
+    # The localization setup for main branch. Note difference in package ID. Should not be used with release/ branches.
+    - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
+      - template: /eng/common/templates/job/onelocbuild.yml
+        parameters:
+          MirrorRepo: 'msbuild'
+          LclSource: lclFilesfromPackage
+          LclPackageId: 'LCL-JUNO-PROD-MSBUILD'
+          MirrorBranch: 'main'
+          JobNameSuffix: '_main'
+          condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
 
   - job: Windows_NT
     pool:
@@ -147,7 +163,7 @@ stages:
 
     # Build VS bootstrapper
     # Generates $(Build.StagingDirectory)\MicroBuild\Output\BootstrapperInfo.json
-    - task: MicroBuildBuildVSBootstrapper@2
+    - task: MicroBuildBuildVSBootstrapper@3
       inputs:
         vsMajorVersion: $(VisualStudio.MajorVersion)
         channelName: $(VisualStudio.ChannelName)
@@ -249,6 +265,13 @@ stages:
     - task: ms-vseng.MicroBuildTasks.521a94ea-9e68-468a-8167-6dcf361ea776.MicroBuildCleanup@1
       displayName: Execute cleanup tasks
       condition: succeededOrFailed()
+      
+    - template: /eng/common/templates/steps/component-governance.yml
+      parameters:
+        ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), or(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))) }}:
+          disableComponentGovernance: false
+        ${{ else }}:
+          disableComponentGovernance: true
 
   - template: /eng/common/templates/job/source-build.yml
     parameters:
diff --git a/Directory.Build.props b/Directory.Build.props
index 43bebf10428..ae75c21fe50 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -24,8 +24,12 @@
           scripts/Deploy-MSBuild.ps1
           src/Framework/README.md
           src/Utilities/README.md
+
+        Special-case while MSBuild uses Arcade 6 to build: 17.7 should
+        continue to target .NET 7, so bump a 6 here to 7.
      -->
-    <LatestDotNetCoreForMSBuild>net7.0</LatestDotNetCoreForMSBuild>
+    <LatestDotNetCoreForMSBuild>$(NetCurrent)</LatestDotNetCoreForMSBuild>
+    <LatestDotNetCoreForMSBuild Condition=" '$(NetCurrent)' == 'net6.0' ">net7.0</LatestDotNetCoreForMSBuild>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -77,10 +81,6 @@
     <MachineIndependentBuild>true</MachineIndependentBuild>
   </PropertyGroup>
 
-  <PropertyGroup>
-    <AssemblyInformationCachePaths Condition="Exists('$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SdkPrecomputedAssemblyReferences.cache')">$(AssemblyInformationCachePaths);$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SDKPrecomputedAssemblyReferences.cache</AssemblyInformationCachePaths>
-  </PropertyGroup>
-
   <PropertyGroup>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.log</DefaultItemExcludes>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.binlog</DefaultItemExcludes>
diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
index 1157c36a866..4ae636a74a6 100644
--- a/MSBuild.Dev.slnf
+++ b/MSBuild.Dev.slnf
@@ -13,7 +13,8 @@
       "src\\Tasks\\Microsoft.Build.Tasks.csproj",
       "src\\Utilities.UnitTests\\Microsoft.Build.Utilities.UnitTests.csproj",
       "src\\Utilities\\Microsoft.Build.Utilities.csproj",
-      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
+      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj",
+      "src\\StringTools\\StringTools.csproj"
     ]
   }
 }
\ No newline at end of file
diff --git a/NuGet.config b/NuGet.config
index 9b4c6f6759c..744064495eb 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -6,6 +6,7 @@
     <add key="dotnet-public" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
     <add key="dotnet6" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json" />
+    <add key="msbuild17.7" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/darc-pub-DotNet-msbuild-Trusted-5785ed5c/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
 </configuration>
diff --git a/PublishToBlob.proj b/PublishToBlob.proj
deleted file mode 100644
index 3f37b55ba64..00000000000
--- a/PublishToBlob.proj
+++ /dev/null
@@ -1,34 +0,0 @@
-<Project>
-
-  <!--
-
-  This is for the internal orchestrated build scenarios and will likely never be run on a
-  developer's machine.  The official build definition builds this file directly.
-
-  -->
-
-  <PropertyGroup>
-    <FeedTasksPackage>Microsoft.DotNet.Build.Tasks.Feed</FeedTasksPackage>
-    <!-- This version should be kept in sync with `project.json` -->
-    <FeedTasksPackageVersion>2.1.0-prerelease-02419-02</FeedTasksPackageVersion>
-  </PropertyGroup>
-
-  <Import Project="$(MSBuildThisFileDirectory)packages\$(FeedTasksPackage)\$(FeedTasksPackageVersion)\build\$(FeedTasksPackage).targets" />
-
-  <ItemGroup>
-    <ItemsToPush Include="$(MSBuildThisFileDirectory)bin\Packages\*.nupkg" />
-  </ItemGroup>
-
-  <Target Name="Build">
-    <PushToBlobFeed ExpectedFeedUrl="$(ExpectedFeedUrl)"
-                    AccountKey="$(AccountKey)"
-                    ItemsToPush="@(ItemsToPush)"
-                    Overwrite="$(PublishOverwrite)"
-                    ManifestBranch="$(ManifestBranch)"
-                    ManifestBuildId="$(ManifestBuildId)"
-                    ManifestCommit="$(ManifestCommit)"
-                    ManifestName="msbuild"
-                    SkipCreateManifest="false" />
-  </Target>
-
-</Project>
diff --git a/build.sh b/build.sh
index 2d2a01b1ee0..f9a7889f52c 100755
--- a/build.sh
+++ b/build.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 SOURCE="${BASH_SOURCE[0]}"
 while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f2e6b6e4753..2497ff6eb37 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -47,7 +47,7 @@ When `Clean`ing the output of a project, `CleanReferencedProjects` ensures that
 
 ## Targets required to be referenceable
 
-These targets should exist in a project to be compatible with the common targets' `ProjectReference`. Some are called only conditionally.
+These targets should exist in a project to be compatible with the common targets' `ProjectReference` (unless [marked with the `SkipNonexistentTargets='true'` metadatum](#targets-marked-with-skipnonexistenttargetstrue-metadatum)). Some are called only conditionally.
 
 These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
 
@@ -85,6 +85,10 @@ If implementing a project with an “outer” (determine what properties to pass
   * As of 15.7, this is _optional_. If a project does not contain a `GetCopyToOutputDirectoryItems` target, projects that reference it will not copy any of its outputs to their own output folders, but the build can succeed.
 * `Clean` should delete all outputs of the project.
   * It is not called during a normal build, only during "Clean" and "Rebuild".
+
+### Targets Marked With `SkipNonexistentTargets='true'` Metadatum
+`GetTargetFrameworks` and `GetTargetFrameworksWithPlatformForSingleTargetFramework` are skippable if nonexistent since some project types (for example, `wixproj` projects) may not define them. See [this comment](https://github.com/dotnet/msbuild/blob/cc55017f88688cbe3f9aa810cdf44273adea76ea/src/Tasks/Microsoft.Managed.After.targets#L74-L77) for more details.
+
 ## Other protocol requirements
 
 As with all MSBuild logic, targets can be added to do other work with `ProjectReference`s.
diff --git a/documentation/README.md b/documentation/README.md
index 082fab41bb3..ec88f6bcae7 100644
--- a/documentation/README.md
+++ b/documentation/README.md
@@ -39,6 +39,7 @@ The folder contains collection of docs and references for MSBuild, detailed info
 ### Problems?
 
 * [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
+* [Controling References Behavior](wiki/Controlling-Dependencies-Behavior.md)
 * [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
 * [Some gotchas around the Microsoft.Build.Framework project/assembly](wiki/Microsoft.Build.Framework.md)
 * [GAC and MSBuild](wiki/UnGAC.md)
@@ -50,16 +51,17 @@ The folder contains collection of docs and references for MSBuild, detailed info
 * [`ProjectReference`](ProjectReference-Protocol.md)
 * [MSBuild Server](MSBuild-Server.md)
 * [Low priority nodes](specs/low-priority-switch.md)
+* [Threading in MSBuild worker nodes](specs/threading.md)
+* [Nodes orchestration](wiki/Nodes-Orchestration.md)
 * [Project cache plugin](specs/project-cache.md)
 * [Support for remote host objects](specs/remote-host-object.md)
 * [Static graph](specs/static-graph.md)
 * [Single project isolated builds: implementation details](specs/single-project-isolated-builds.md)
 * [Task isolation](specs/task-isolation-and-dependencies.md)
-* [Threading in MSBuild worker nodes](specs/threading.md)
 * [Target maps](wiki/Target-Maps.md)
 * [Managing parallelism in MSBuild](specs/resource-management.md)
 * [SDK resolution](specs/sdk-resolvers-algorithm.md)
-* [Nodes orchestration](wiki/Nodes-Orchestration.md)
+* [RAR core scenarios](specs/rar-core-scenarios.md)
 
 ### Tasks
 
@@ -74,11 +76,14 @@ The folder contains collection of docs and references for MSBuild, detailed info
 * [Binary log](wiki/Binary-Log.md)
 * [Live logger: how to opt in](livelogger/Opt-In-Mechanism.md)
 
-## Designs
-
-* [Resolve Assembly Reference as a service](design/rar-as-service.md)
+## Archived Designs
+* [Resolve Assembly Reference as a service](specs/rar-as-service.md)
    * Prototype: https://github.com/dotnet/msbuild/issues/6193
 
+## Proposed Designs
+* [Packages Sourcing](specs/proposed/interactive-package-references.md)
+* [Secrets Metadata](specs/proposed/security-metadata.md)
+
 ## Community contributions
 
 * [MSBuild overview](Contributions/MSBuild-overview.md)
diff --git a/documentation/design/rar-as-service.md b/documentation/specs/archive/rar-as-service.md
similarity index 100%
rename from documentation/design/rar-as-service.md
rename to documentation/specs/archive/rar-as-service.md
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index f646f120114..4eef03f279b 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -29,7 +29,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | RarComputeClosure | Resolves references from, for example, properties to explicit values. Used in resolving assembly references (RAR). |
 | RarLogResults | Logs the results from having resolved assembly references (RAR). |
 | RarOverall | Initiates the process of resolving assembly references (RAR). |
-| RarRemoveReferencesMarkedForExclusion | Removes blacklisted references from the reference table, putting primary and dependency references in invalid file lists. |
+| RarRemoveReferencesMarkedForExclusion | Removes denylisted references from the reference table, putting primary and dependency references in invalid file lists. |
 | RequestThreadProc | A function to requesting a new builder thread. |
 | ReusableStringBuilderFactory | Uses and resizes (if necessary) of ReusableStringBuilders. |
 | ReusableStringBuilderFactoryUnbalanced | Identifies improper usage from multiple threads or buggy code: multiple Gets were called without a Relase. |
diff --git a/documentation/specs/proposed/security-metadata.md b/documentation/specs/proposed/security-metadata.md
new file mode 100644
index 00000000000..e2ed58050b6
--- /dev/null
+++ b/documentation/specs/proposed/security-metadata.md
@@ -0,0 +1,253 @@
+
+# Security Metadata
+
+The feature is meant to improve the security of builds executed via MSBuild, by reducing the chances of spilling secrets (and possibly other sensitive data) from otherwise secured or/and inaccessible build environments.
+
+It builds upon the other efforts reducing the cases accidentaly logging secrets - ['not logging unused environemnt variables'](https://github.com/dotnet/msbuild/pull/7484), 'redacting known secret patterns' (internal, by @michaelcfanning). Distinction here is that we want to give users option how to configure their build scripts and build data so that they can indicate what contains secret/sensitive data and shouldn't get output into logs.
+
+The feature is envisioned to be delivered in multiple interations, while first itearation will be facilitated via global items and/or properties that will be indicating masking logging of specific types of data in log entries (hence no syntactic changes will be imposed for now).
+
+# North Star / Longer-term vision
+
+We envision MSBuild to have a first-class-citisen type system for it's data and tasks. 'Secret' would be one of the data types - allowable to be passed only to other variables or task inputs denoted as 'secret' (so e.g. it would not be possible to pass secrets to [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task)) and vice versa 'secret' task input or data type could be initialized/evaluated only from other 'secrets' or predefined external sources of data - environment variables, commandline arguments, files, apropriately denoted task output parameters.
+
+Such a strong typing would allow to hold to stronger guarantees of not spilling properly denoted sensitive data and redact them with minimal impact on build performance (as opposed to intermediate attempts that will need to perform string inspections).
+
+**Ilustrative sample:**
+
+```xml
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Secrets>
+    <!-- initialize from command line -->
+    <GH_token />
+    <!-- initialize from env -->
+    <ACR_login>$(ACR_login)</ACR_login>
+    <!-- initialize by task -->
+    <ACR_password />
+	</Secrets>
+
+  <UsingTask TaskName="ReadCreadentialFromValut" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
+  <UsingTask TaskName="PushImageToACR" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
+	
+  <Target Name='PushImage'> 
+    <Message Text="Pushin image to ACR" />
+    <ReadCreadentialFromValut 
+      Key="$(ACR_password_key)"
+    >
+      <Output TaskParameter="Value" PropertyName="ACR_password"/>
+    </ReadCreadentialFromValut>
+    <PushImageToACR 
+      Login="$(ACR_login)"
+      Password="$(ACR_password)"
+    />
+  </Target>
+</Project>
+```
+
+```cs
+ReadCreadentialFromValut : Task
+{
+  /// <summary>
+  /// Key to be fetched
+  /// </summary>
+  public string Key { get; set; }
+
+  /// <summary>
+  /// Fetched value
+  /// </summary>
+  [Output]
+  [Secret]
+  public string Value { get; set; }
+
+  // ... Execute() ...
+}
+```
+
+```cs
+PushImageToACR : Task
+{
+  /// <summary>
+  /// Azure Container Registry Login
+  /// </summary>
+  public Secret Login { get; set; }
+
+  /// <summary>
+  /// Azure Container Registry Password
+  /// </summary>
+  public Secret Password { get; set; }
+
+  // ... Execute() ...
+}
+```
+
+An opt-out mechanism would allow usage of properly denoted tasks with plain string input data (and vice versa) - to allow smoother gradual onboarding to the new type system, without the need to rework the entire build script suite at one shot.
+
+
+# Scope of initial iteration
+
+## In scope
+ * Following data can be opted-in for redacting:
+    * property values
+    * item values
+    * item metadata values
+    * all item metadata
+    * any combination of above
+    * task input parameters (to denote that task is requiring sensitive data and only such can be passed in)
+    * task OutputItems (This can be handy in cases similar to [`ReadLinesFromFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/readlinesfromfile-task))
+ * Redacting the above will happen in all log events before they are being sent to subscribed loggers. 
+ * Redacting will apply to data initializations and passing:
+    * task input parameters
+    * task OutputItems
+    * transfering value to other properties/items via evaluation, transforms, flattening, [Property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions), [Item functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-functions)
+    * initialization from environemnt variables or command line
+ * Redacting **will NOT** occure on:
+    * log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
+    * any other alternative output of tasks (direct writes to file system, network connections etc.)
+
+## Out of scope
+  * Redacting **will NOT** occure on:
+    * Log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
+    * Any other alternative output of tasks (direct writes to file system, network connections etc.)
+    * MSBuild xml nodes (elements/attributes) names. (Sensitive data within MSBuild script itself is strongly discouraged)
+    * Passing values to task and there embedding into additional text and passing out as output parameter - unless such is explicitly marked as containing sensitive data.
+    * Encrypting/securing data in memory during therun of the build.
+ 
+
+# User interaction
+
+There needs to be a way how user specifies which data should be redacted from logs. We have several options:
+
+ * New data type - this is part of the [North Star vision](#north-star--longer-term-vision), but is out of scope for the initial iteration.
+ * [Not recomended] Denoting those via some metadata on a definition of the data to be redacted - this has two main drawbacks - a) For some data types (properties, metadata) we'd need new constructs how to attach additional info (property metadata; item meta-metadata). b) some data can be defined implicitly or dynamicaly
+ * Property with global scope - e.g. 
+   ```xml
+   <DataToRedactFromLogs>Foo;Bar;Baz->SomeMetadata;MyItem->*</DataToRedactFromLogs>
+   ```
+   single property might look bit cryptic for denoting different data types. On the other hand it might be more efficient in simple redacting scenarios (pointing to a set of regexes; single sustom redactor etc.) and would allow limiting the log events pre-buffering needs.
+
+ * Item with global scope - e.g. 
+   ```xml
+   <ItemGroup>
+     <!-- Redacting property content based on the name of the property (or environment variable) -->
+     <DataToRedactFromLogs Include="Foo" Type="Property">
+     </DataToRedactFromLogs>
+     <!-- Redacting item content based on the name of the item. Metadat are not redacted -->
+     <DataToRedactFromLogs Include="Bar" Type="Item" RedactValue=True>
+     </DataToRedactFromLogs>
+     <!-- Redacting item metadata content based on the name. -->
+     <DataToRedactFromLogs Include="Baz" Type="Item" RedactValue=False Metadata="SomeMetadata">
+     </DataToRedactFromLogs>
+     <!-- Redacting all metadata content of specific item based on the name of the item. -->
+     <DataToRedactFromLogs Include="MyItem" Type="Item" RedactValue=False Metadata="*" />
+     <!-- Redacting property content passed from the task. At the same time requiring that the data receiving the output of the task are denoted as secret as well. -->
+     <DataToRedactFromLogs Include="OutputA" Type="TaskOutput" TaskName="TaskX" />
+     <!-- Redacting task parameter value. At the same time requiring that the data passed to the parameter of the task are denoted as secret as well. -->
+     <DataToRedactFromLogs Include="ParamA" Type="TaskParameter" TaskName="TaskX" />
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+   This can offer a more chatty, but better understandable (and possibly beter script generatable) way of denoting the redacting intent.
+ * A regex on *value* to redact above discused data types based on their content - e.g.:
+    ```xml
+   <ItemGroup>
+     <!-- Redact GH tokens based on https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available -->
+     <DataToRedactFromLogs Include="ghp_[A-Za-z0-9_]" Type="ValueRegex">
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+   This way we can give build architects a tool to define common `.props` files opting-in for redacting specific types strings known to be tokens/secrets/sensitive data, without the need to guess under which properties or items they would show within the build
+* A custom plugin flagging values for redaction. e.g.:
+    ```xml
+   <ItemGroup>
+     <DataToRedactFromLogs Include="MySecretsClassifier.dll,Contoso.Secrets.Classifier.ClassifySecrets" Type="ValueClassifierPlugin">
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+
+   where:
+
+   ```csharp
+   Contoso.Secrets;
+
+   public class Classifier: IValueClassifier
+   {
+      public ISet<string>? GetPartsToRedact(string value) {/* Logic goes here */}
+   }
+   ```
+   This option has additional security considerations, but allows most versatile secrets redaction.
+
+   The last option can possibly be allowed to be injected via other means, that MSBuild currently uses for injecting pluggable fnctionality (command line argument; environment variable; binary placed in a specific search location)
+* A built in redacting plugin - to be opted-in via env var or command line. Plugin will use same extension point as custom plugins - with extended interface allowing to provide redaction values as well:
+   ```csharp
+
+   public interface IValueRedactor
+   {
+      public ISet<Tuple<string, string>>? GetPartsToRedact(string value);
+   }
+   ```
+   This plugin will allow for no-touch redacting of most comon secret patterns by various providers. The default plugin is going to be provided as contribution by 1ES (by @michaelcfanning) and is currently out of scope of this document.
+
+
+First presented option is not to be used. All the other options will likely be supported.
+
+# Special considerations
+
+* There should be no (or very minimal) performance impact to cases where redacting is not opted-in and/or to cases where there is lower/minimal level of logging. In another words - we should not spend cycles detecting and redacting secrets on log events that are not going to be loged (todo: second case might be more problematic - as loggers can decide their level of logging).
+* Order of processing and imports is important here - if we indicate secret metadata in items, the properties are processed first and hence we can miss preanalyzing (or even redacting) some data. Same applies for order of processing of the properties.
+* Considering above two facts - we need a opt-in commandline switch or environemnt variable (or combination) to indicate that secrets metadata might be used - in which case we'll need to buffer build/log events before we have processed all the metadata indicating what needs to be redacted. Extra care will need to be given to sending command line args via EventSource ([source](https://github.com/dotnet/msbuild/blob/main/src/MSBuild/XMake.cs#L655))
+* There are no global items today - this can be simulated by putting those to directory.props
+* Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) 
+* `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).
+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).
+* Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).
+
+# Suggested Implementation
+
+* Need for explicit opt-in - command line switch or environment variable.
+* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.
+  * In the future version - with first-class citizen type for secrets, we can possibly frontload single pass through the script just for detection of the secret redaction declarations and avoid the buffering and post-process need.
+* Buffered events need to be post-processed in respect with the redaction requests, only then dispatched.
+* We'll maintain lookup of elements requested for redaction - those explicitly requested by the name of property/item and those identified as sensitive by value or by transfer of value from other sensitive element.
+* We'll intercept assigments of value to property ([`TrackPropertyWrite`](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L223)), item and task parameter
+  * If value is assigned to a task parameter and such is indicated by user as sensitive, the holder of the value (the R-value - parameter/item being assigned to the task input) needs to be as well tracked as sensitive, otherwise build waring/error will be issued.
+  * If value is assigned to a task parameter and such is not indicated by user as sensitive, but the holder of the value (the R-value - parameter/item being assigned to the task input) is tracked as sensitive (either because it was explicitly denoted by name, or it was later marked by MSBuild due to holding value matching a sensitivity value regex or callback) - a build warning/error will be issued.
+  * If value is assigned to property/item from a task output and such is indicated by user as sensitive, the L-value holder of the value (the property/item being assigned to) need to be as well tracked as sensitive, otherwise build waring/error will be issued.
+  * If value is being assigned to property or item
+    * and such is indicated by user as sensitive, the generated build event needs to be redacted.
+    * and such is not indicated by user as sensitive, but the R-value is indicated as sensitive - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
+    * and such is not indicated by user as sensitive, the value is passed to sensitivity indicating regex or callback (in case any of those are configured by user) and if matched - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
+* No other redacting of log events will be performed. This is not a strong requirement - we can introduce another opt-in level of strict inspection of all log events. The gain is very questionable though, while the performance impact is severe (internal experiments by @michaelcfanning measured by @rokonec indicate 4-times slow-down on mid-size build). Additionally to being perf-expensive, it can possibly get easily confused - e.g.:
+
+```xml
+<ItemGroup>
+  <DataToRedactFromLogs>MySecret</DataToRedactFromLogs>
+  <MySecret>a</MySecret>
+  <MyInnocentData>hahaha</MyInnocentData>
+  <SomeProp></SomeProp>
+</ItemGroup>
+
+<Target Name="Test">
+  <MyTask FirstInput="MySecret" SecondInput="MyInnocentData">
+    <Output PropertyName="SomeProp" TaskParameter="Result">
+  </MyTask>
+  <!-- Might log: 
+       Result from task: h<redacted>h<redacted>h<redacted>
+  -->
+  <Message Text="Result from task: $(SomeProp)">
+</Target>
+```
+
+In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.
+
+# Open questions
+ * What to use as a replacement of the data to be redacted? (Randomized hash, fixed token, etc.) - *very likely just a static pattern ('******'). The built-in redactor plugin will be allowed to provide custom replacements*
+ * Do we want to allow to supply custom replacement value for injectable redaction functionality? There would need to be very strong compeling reason, as this is easily suspectible to [log forging attack](https://owasp.org/www-community/attacks/Log_Injection) - *most likely no.*
+ * Balancing performance and accuracy - can we afford to not support arbitrary output of tasks? Otherwise we'd need to process all log events (similar experiments indicate 4 times slowdown of the build of mid-size project (Orchard)). On the other with explicit 'secret metadata' feature users might expect 100% correctness. Should we make this configurable as well (input data only vs all log entries)? Plus this might be suspectible to false positives (see above).
+
+
+# Links
+ * Nightfall data redaction syntax: https://docs.nightfall.ai/docs/redacting-sensitive-data-in-4-lines-of-code
+ * `spark.redaction.regex`: https://people.apache.org/~pwendell/spark-releases/latest/configuration.html
+ * Redacting secrets in k8s logs in ops tool `Komodor`: https://docs.komodor.com/Learn/Sensitive-Information-Redaction.html
+ * MSBuild opt-in functionality for properties/items/metadata logging disabling: https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs#L1199
+
diff --git a/documentation/design/rar-core-scenarios.md b/documentation/specs/rar-core-scenarios.md
similarity index 100%
rename from documentation/design/rar-core-scenarios.md
rename to documentation/specs/rar-core-scenarios.md
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
index e3f8b94670d..75b15fc5b82 100644
--- a/documentation/specs/single-project-isolated-builds.md
+++ b/documentation/specs/single-project-isolated-builds.md
@@ -1,54 +1,43 @@
-# Single project isolated builds: implementation details
+# Single Project Isolated Builds: Implementation Details
 
 <!-- workflow -->
 Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
 
-The input cache files contain the cached results of all the targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the BuildManager APIs) should build targets. Any referenced projects by the top level project should be provided from the input caches.
+The input cache files contain the cached `TargetResult`s of all targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the `BuildManager` APIs) should build targets; Any referenced projects by the top level project should be provided from the input caches.
 
-The output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.
-The output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.
+The output cache file tells MSBuild where to serialize the `TargetResult`s for a project's built targets and becomes an input cache for dependent projects.
 
 The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).
 
-## Input / Output cache implementation
+## Input / Output Cache Implementation
 <!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22).
-
-One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
+The cache files contain the serialized state of MSBuild's [`ConfigCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [`ResultsCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs), which have been traditionally used by the engine to cache build results. They ensure that a target is only built once per build submission. `ConfigCache` entries are instances of [`BuildRequestConfiguration`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25)s (a `(project path, global properties)` tuple), and `ResultsCache` entries are instances of [`BuildResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34)s, which contain [`TargetResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22)s. The `ConfigCache` entries and `ResultsCache` entries form a [bijection](https://en.wikipedia.org/wiki/Bijection).
 
 <!-- cache lifetime -->
-The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
+In a build, the input and output cache files have the same lifetime as the `ConfigCache` and  `ResultsCache`. The `ConfigCache` and  `ResultsCache` are owned by the [`BuildManager`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On command-line builds, the cache lifetime is the same as the entire process lifetime since `MSBuild.exe` uses one `BuildManager` with one `BeginBuild` / `EndBuild` session. When other processes (e.g. Visual Studio's `devenv.exe`) perform MSBuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
 
 <!-- constraints -->
 
-When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
-The following constraints are enforced during cache aggregation:
-- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)
-- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the "first one wins" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.
+When loading input cache files, MSBuild merges incoming instances of `ConfigCache`s and `ResultsCache`s into one instance of each with the help of the [`CacheAggregator`](https://github.com/dotnet/msbuild/blob/51df47643a8ee2715ac67fab8d652b25be070cd2/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L15), which enforces the following constraints:
+- No duplicate cache entries
+- Bijection:
+   - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+   - `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`
 
-The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
+Note that the output cache file contains a single `BuildResult` with the `TargetResult`s from the project specified to be built in the `BeginBuild` / `EndBuild` session, as any `BuildResult`s obtained through isolation exemption are excluded to prevent potential duplicate input cache entries; Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache).* In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
 
-## Isolation implementation
+## Isolation Implementation
 
-[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the `Scheduler` and  `TaskBuilder`. [`TaskBuilder.ExecuteInstantiatedTask`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in a `ProjectReference` item. [`Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
 
-### How isolation exemption complicates everything
-<!-- Potential cache scenarios caused by exemption -->
-Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.
+### Isolation Exemption
+The `Scheduler` [skips isolation constraints](static-graph.md#exempting-references-from-isolation-constraints) on project references via the:
 
-The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
+* `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
 
-The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:
-1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.
-2. a project can be both exempt and present in the graph at the same time. For example, given the graph `{A->B}`, both `A` and `B` are in the graph, but `A` can also mark `B` as exempt (meaning that `A` contains both a `ProjectReference` item to `B`, and a `GraphIsolationExemptReference` item to `B`). The fact that `B` is in the graph means that `A` will receive an input cache containing B's build results. There are two subcases here:
-   1.  `A` builds targets from `B` that already exist in the input cache file from `B`. In this case, all the builds of `B` will be cache hits, and no target results from `B` will make it into `A`'s output cache, since nothing new was built.
-   2.  `A` builds targets from `B` that do not exist in the input cache file from `B`. If `B` weren't exempt from isolation constraints, this scenario would lead to a build break, as cache misses are illegal under isolation. With `B` being exempt, the new builds of `B` will get included in `A`'s output cache. The results from `B`'s cache file won't get included in `A`'s output cache file, as they weren't built by `A`.
-3. A project, which is not in the graph, can be exempt by two parent/child projects from the graph. For example, given the graph `{A->B}`, both `A` and `B` can exempt project `D` (meaning that neither `A` nor `B` have a `ProjectReference` to `D`, but both `A` and `B` have a `GraphIsolationExemptReference` to `D`). The fact that `B` is in the graph means that `A` will receive an input cache containing `B`'s build results. Since `B` builds targets from `D`, it means that `B`'s output cache file also contains target results from `D`. There are two subcases here:
-   1. `A` builds targets from `D` that already exist in the input cache file from `B`. This is handled in the same way as the above case `2.1.`
-   2. `A` builds targets from `D` that do not exist in the input cache file from `B`, meaning that `A` builds additional targets from `D` which `B` didn't build. This is handled in the same way as teh above case `2.2.`
+* `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
 
-**Current issue:** if multiple nodes in the graph exempt the same project file, the build results of the exempt project will trickle up and conflict in the first parent that tries to merge them. Documented in issue [#4386](https://github.com/dotnet/msbuild/issues/4386).
+\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
\ No newline at end of file
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 1ad0c954695..49acebe57fe 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -360,7 +360,7 @@ namespace Microsoft.Build.Experimental.Graph
 ```
 
 ## Isolated builds
-Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any BuildResult objects for project references must be pre-computed and somehow provided as inputs to the referencing project.
+Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any `BuildResult` objects for project references must be precomputed and somehow provided as inputs to the referencing project.
 
 If a project uses the MSBuild task, the build result must be in MSBuild's build result cache instead of just-in-time executing targets on that referenced project. If it is not in the build result cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or the MSBuild task with a different set of global properties, this will be allowed to support multitargeting and other build dimensions implemented in a similar way.
 
@@ -369,7 +369,7 @@ Because referenced projects and their entry targets are guaranteed to be in the
 ### Isolated graph builds
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
+Furthermore, running in this mode enforces that each `(project, global properties)` pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
 
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
@@ -389,9 +389,9 @@ These incremental builds could be extended to the entire graph by keeping a proj
 Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
 #### APIs
-Cache file information is provided via [BuildParameters](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one BuildManager BeginBuild/EndBuild session.
+Cache file information is provided via [`BuildParameters`](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one `BuildManager` `BeginBuild`/`EndBuild` session.
 
-Isolation constraints are turned on via [BuildParameters.IsolateProjects](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used.
+Isolation constraints are turned on via [`BuildParameters.IsolateProjects`](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used, except when the `isolate:MessageUponIsolationViolation` switch is used.
 
 #### Command line
 Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
@@ -403,14 +403,21 @@ In certain situations one may want to exempt a reference from isolation constrai
 - exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
 - relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
 
-A project is exempt from isolation constraints by adding its full path to the `GraphIsolationExemptReference` item. For example, if project A.csproj references project B.csproj, the following snippet exempts B.csproj from isolation constraints while A.csproj is built:
-```xml
-<ItemGroup>
-  <GraphIsolationExemptReference Include="/Full/Path/To/B.csproj" />
-</ItemGroup>
-```
-
-A reference is exempt only in projects that add the reference in `GraphIsolationExemptReference`. If multiple projects need to exempt the same reference, all of them need to add the reference to `GraphIsolationExemptReference`.
+A project may be exempt from isolation constraints in two ways:
+
+<!-- List is encoded in HTML since XML code block
+and its following text won't be indented properly. -->
+<ul>
+<li>its full path is added to the <code>GraphIsolationExemptReference</code> item. For example, if project <code>A.csproj</code> references project <code>B.csproj</code>, the following snippet exempts <code>B.csproj</code> from isolation constraints while <code>A.csproj</code> is built:
+<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
+  <span class="hljs-tag">&lt;<span class="hljs-name">GraphIsolationExemptReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"/Full/Path/To/B.csproj"</span> /&gt;</span>
+<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
+</code></pre>
+If multiple projects need to exempt the same reference, all of them need to add the reference to <code>GraphIsolationExemptReference</code>.
+</li>
+<li> via the <code>isolate:MessageUponIsolationViolation</code> switch
+</li>
+</ul>
 
 For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
index de8d8e11725..7c0c0e86cf4 100644
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -1,4 +1,4 @@
-⚠ This doc is intended for internal teams.
+⚠ This doc is intended for internal teams. For information about how to deal with MSBuild Change Waves as an MSBuild _user_, see [ChangeWaves.md](ChangeWaves.md).
 
 # What are Change Waves?
 A Change Wave is a set of risky features developed under the same opt-out flag. The purpose of this is to warn developers of risky changes that will become standard functionality down the line. If there's something we think is worth the risk, we found that Change Waves were a good middle ground between making necessary changes and warning customers of what will soon be permanent.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index f96cbb83e99..b070e47ccfb 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -23,6 +23,11 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ## Current Rotation of Change Waves
 
+### 17.8
+- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
+- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
+- [New serialization approach for transferring build exceptions between processes](https://github.com/dotnet/msbuild/pull/8779)
+
 ### 17.6
 - [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
 - [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
diff --git a/documentation/wiki/Controlling-Dependencies-Behavior.md b/documentation/wiki/Controlling-Dependencies-Behavior.md
new file mode 100644
index 00000000000..ceafb75a2d1
--- /dev/null
+++ b/documentation/wiki/Controlling-Dependencies-Behavior.md
@@ -0,0 +1,264 @@
+# Controlling references behavior
+
+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.
+
+## .NET SDK projects and access to transitive references
+
+[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.
+
+This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.
+
+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.
+
+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.
+
+## Access to transitive project references
+
+Above described behavior can lead to easy unintentional breaking out of layering architecture separation. 
+
+This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.
+
+<a name="OnionArchSample"></a>*Example*:
+
+Let's imagine an `Onion Architecture` design:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> Domain[Domain Layer]
+```
+
+Service Layer definition:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" />
+  </ItemGroup>
+
+  <PropertyGroup>
+    <TargetFramework>net48</TargetFramework>
+    <LangVersion>10</LangVersion>
+    <!-- This prevents referencing types from transitive project references. -->
+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
+  </PropertyGroup>
+</Project>
+```
+
+```csharp
+namespace Service;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.
+    // private Domain.PersonTable _tbl;
+}
+```
+
+## Access to transitive package references
+
+The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).
+
+When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.
+
+*Example*:
+
+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]
+```
+
+We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.
+
+`Repository Layer`:
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This prevents the reference to be available to referencing types. -->
+    <PrivateAssets>compile</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+Unless opted out via `PrivateAssets=compile`, our `Service Layer` would have access to `newtonsoft.json`:
+
+```csharp
+namespace Service;
+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.
+//using Newtonsoft.Json;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+}
+```
+
+**Notes:**
+   `PrivateAssets` metadatum (and it's counterparts `IncludeAssets` and `ExcludeAssets`) is applicable to `PackageReference` and controls exposure of dependencies to the consuming projects, not the current project. It is currently not possible to prevent access to package references from within directly referencing project - this is purely decision of the package itself (as it can define it's dependencies as `PrivateAssets`).
+
+## Not copying dependencies to output
+
+By default the above mentioned dependency types are copied to the build output directory during the build. There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).
+
+Overriding this logic depends on the type of the dependency.
+
+### Not copying Assembly Reference
+
+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):
+
+```xml
+<ItemGroup>
+  <Reference Include="mydll">
+    <HintPath>..\somepath\mydll.dll</HintPath>
+    <!-- This indicates that the reference should not be copied to output folder. -->
+    <Private>false</Private>
+  </Reference>
+</ItemGroup>
+```
+
+### Not copying PackageReference
+
+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:
+
+**Not copying package dependency to the immediate output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->
+    <IncludeAssets>compile</IncludeAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency to the downstream dependants output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- The dependency is copied to output folder in current referencing project, 
+           but it's not copied to output folder of projects referencing current project. -->
+    <PrivateAssets>all</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency from the upstream dependencies:**
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->
+    <ExcludeAssets>all</ExcludeAssets>
+  </ProjectReference>
+</ItemGroup>
+```
+
+### Not copying ProjectReference
+
+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project output should not be copied to output folder. -->
+    <Private>false</Private>
+  </ProjectReference>
+</ItemGroup>
+```
+
+Same metadata and logic applies here as it is being inherited from the `Reference` Item definition and the logic treats it identicaly. 
+
+## ProjectReference without accessibility and copying to output
+
+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.
+
+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. 
+         This way we basically only indicate the build order.
+    -->
+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+  </ProjectReference>
+</ItemGroup>
+```
+
+**Note:** This technique has possibly unexpected behavior when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the output assembly (`.dll`) is still not copied and referenced (as the metadatum name implies) and hence the types defined within the project cannot be referenced, however other supplementary output (added as `content` or `none`) is copied to the current project output folder (for .NET Core this includes `deps.json`, `runtimeconfig.json` and mainly `<app>.exe`). In that case we can combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference). More details on this case [here](https://github.com/dotnet/msbuild/issues/4795#issuecomment-1442390297)
+
+## Forcing TargetFramework of a referenced multitargeted project
+
+Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/nuget/create-packages/multiple-target-frameworks-project-file). 
+
+Repository Layer:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'net48'">
+    <ProjectReference Include="..\Domain-net48\Domain-net48.csproj" />
+    <PackageReference Include="System.Text.Json" Version="7.0.2" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
+    <ProjectReference Include="..\Domain-netstd20\Domain-netstd20.csproj" />
+    <PackageReference Include="newtonsoft.json" Version="13.0.1">
+  </ItemGroup>
+</Project>
+```
+
+And it's going to be referenced by Service Layer:
+
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <OutputType>Exe</OutputType>
+    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj"  />
+  </ItemGroup>
+</Project>
+```
+
+Building the Service Layer will create output folders for `net7` and `net48`:
+
+```
+net48
+ |---- Repository.dll (targeted for net48)
+ |---- Domain-net48.dll
+ |---- System.Text.Json.dll
+
+net7
+ |---- Repository.dll (targeted for netstandard2.0)
+ |---- Domain-netstd20.dll
+ |---- Newtonsoft.Json.dll 
+```
+
+Should we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:
+
+```xml
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" SetTargetFramework="TargetFramework=netstandard2.0" />
+  </ItemGroup>
+```
+
+**Notes:** 
+
+`SetTargetFramework` is currently not honored by the NuGet client([nuget issue #12436](https://github.com/NuGet/Home/issues/12436)), so the output folder will contain binaries from nuget packages as if this metadata was not used. To workaround this the apropriate nuget needs to be directly referenced from the project enforcing reference framework via `SetTargetFramework`, or copied to output/publish folder via different means.
+
+
+`SetTargetFramework` will properly enforce the framework for the `ProjectReference` chain. Once the `TargetFramework` overriding is encountered it is passed down the reference chain and the `ProjectReference`s respect it during the `TargetFramework` resolution. Due to the nature of handling of [transitive references in .NET-SDK style projects](#net-sdk-projects-and-access-to-transitive-references) and the fact that NuGet client doesn't honor `SetTargetFramework`, the transitive references can get resolved and built for multiple `TargetFramework`s. This means the output folder will contain proper version of the direct dependency - Repository Layer. The transitive references might overbuild, and output folder of current project (Service Layer) might contain both versions of the transitive project dependency (Domain-net48.dll and Domain-netstd20.dll). This limitation can be workarounded by switching of the transitive project references via `DisableTransitiveProjectReferences` (same as shown in [Access to transitive project references](#access-to-transitive-project-references))
+
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index b9be0b3f59b..3fa12a84f6a 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -6,25 +6,39 @@ However, you should be aware what type of information is captured in the binary
 
 ⚠ NOTE: some build environments make secrets available using environment variables. Before sharing a binary log, make sure it does not expose API tokens or other important secrets.
 
+## Capturing Binary Logs for command-line builds
+
 You can create a binary log by passing the `-bl` parameter to MSBuild (`MSBuild.exe` or `dotnet build`). You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/) or in your browser using [Live Structured Log Viewer](https://live.msbuildlog.com). Note: We don't capture any data from binary logs viewed on your browser.
 
+Examples:
+
+```sh
+dotnet build -bl
+dotnet build -bl:SpecificStep.binlog
+MSBuild.exe -bl:ServiceRelease.binlog -p:Configuration=Release
+```
+
 [More details about binary logs](Binary-Log.md)
 
 ## Capturing Binary Logs Through Visual Studio
-### (Preferred way) Capturing logs for all MSBuild invocations
+
+### Capturing logs for all MSBuild invocations
+
 Set `MSBUILDDEBUGENGINE` environment variable to `'1'` and (optionally) set `MSBUILDDEBUGPATH` to an existing destination folder to store the captured logs. Then start Visual Studio from the same shell to inherit the environment:
 
 `cmd:`
-```
+
+```batch
 > SET MSBUILDDEBUGENGINE=1
 > SET MSBUILDDEBUGPATH=C:\MSBuildReproLogs
 > devenv.exe MySolution.sln
 ```
 
 `PowerShell:`
-```
+
+```powershell
 > $env:MSBUILDDEBUGENGINE = 1
-> $env:MSBUILDDEBUGPATH= C:\MSBuildReproLogs
+> $env:MSBUILDDEBUGPATH="C:\MSBuildReproLogs"
 > & "devenv.exe" MySolution.sln
 ```
 
@@ -33,8 +47,10 @@ MSBuild binary logs are then captured to a location specified via `MSBUILDDEBUGP
 ⚠ NOTE: logs are being recorded for each MSBuild invocation (including design time builds) and kept in the folder without removing older ones - so the number of log files can grow quickly. It is recommended to set the opt-in environment variable only for the short duration of reproducing the issue to be investigated (though it is understandable that some nondeterministic issues might need multiple reproduction attempts)
 
 Further reading:
+
 * [More technical info](Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#logs)
 * [Design time builds logs](https://github.com/dotnet/project-system/blob/main/docs/repo/debugging/design-time-builds.md#gathering-full-fidelity-binlogs)
 
 ### Capturing specific logs for chosen build invocations
+
 See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
diff --git a/eng/Packages.props b/eng/Packages.props
index 3b73eb59ecc..b3567d1fdc2 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -13,6 +13,7 @@
     <PackageVersion Include="Microsoft.CodeAnalysis.Collections" Version="$(MicrosoftCodeAnalysisCollectionsVersion)" />
     <PackageVersion Include="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageVersion Include="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
+    <PackageVersion Include="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" Condition="'$(UsingToolMicrosoftNetCompilers)' != 'true'" />
     <PackageVersion Include="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="NuGet.Build.Tasks.Console" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
diff --git a/eng/SourceBuild.props b/eng/SourceBuild.props
index 2bd3712f6ee..a7925ca3dc3 100644
--- a/eng/SourceBuild.props
+++ b/eng/SourceBuild.props
@@ -1,9 +1,10 @@
+<!-- Whenever altering this or other Source Build files, please include @dotnet/source-build-internal as a reviewer. -->
+
 <Project>
 
   <PropertyGroup>
     <GitHubRepositoryName>msbuild</GitHubRepositoryName>
     <SourceBuildManagedOnly>true</SourceBuildManagedOnly>
-    <SourceBuildTrimNetFrameworkTargets>true</SourceBuildTrimNetFrameworkTargets>
   </PropertyGroup>
 
   <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration">
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index c1b6dfbf053..548f4bd4db7 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -1,5 +1,37 @@
+<!-- Whenever altering this or other Source Build files, please include @dotnet/source-build-internal as a reviewer. -->
+<!-- See aka.ms/dotnet/prebuilts for guidance on what pre-builts are and how to eliminate them. -->
+
 <UsageData>
   <IgnorePatterns>
-    <UsagePattern IdentityGlob="*/*" />
+    <UsagePattern IdentityGlob="Microsoft.SourceBuild.Intermediate.*/*" />
+
+    <!-- These dependencies are a result of building for netframework TFMs. These are filtered out 
+         in full source-build, and would be filtered out if msbuild was using an 8.0 arcade + 8.0 SDK -->
+         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies/*1.0.3*" />
+         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies.net472/*1.0.3*" />
+
+    <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
+         These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
+    <UsagePattern IdentityGlob="Microsoft.Bcl.AsyncInterfaces/*7.0.0*" />
+    <UsagePattern IdentityGlob="Microsoft.Win32.SystemEvents/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.CodeDom/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Drawing.Common/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*7.0.2*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*7.0.1*" />
+    <UsagePattern IdentityGlob="System.Security.Permissions/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encodings.Web/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Windows.Extensions/*7.0.0*" />
+
   </IgnorePatterns>
 </UsageData>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 9d3c7cc4766..227c9435cab 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,50 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
+  <ProductDependencies>
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="7.0.0-alpha.1.23219.1">
+      <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
+      <Sha>525b6c35cc5c5c9b80b47044be2e4e77858d505a</Sha>
+      <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
+    </Dependency>
+    <!-- Necessary for source-build. This allows the packages to be retrieved from previously-source-built artifacts
+      and flow in as dependencies of the packages produced by msbuild. -->
+    <Dependency Name="System.Configuration.ConfigurationManager" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+  </ProductDependencies>
   <ToolsetDependencies>
     <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23213.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
       <Sha>fb14cae30eacbe844468ac297b3d4c61e0bb9dc0</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-rc.149">
+    <Dependency Name="Microsoft.SourceLink.GitHub" Version="1.1.0-beta-21480-02" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+      <Uri>https://github.com/dotnet/sourcelink</Uri>
+      <Sha>8031e5220baf2acad991e661d8308b783d2acf3e</Sha>
+      <SourceBuild RepoName="sourcelink" ManagedOnly="true" />
+    </Dependency>
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.21431.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+      <Uri>https://github.com/dotnet/xliff-tasks</Uri>
+      <Sha>bc3233146e1fcd393ed471d5005333c83363e0fe</Sha>
+      <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
+    </Dependency>
+    <Dependency Name="NuGet.Build.Tasks" Version="6.7.0-rc.106">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>ca5029046d7b6e55f322c45abb7b342054543710</Sha>
+      <Sha>4b6a87bfe90d247f961eba41d63dbf418a56fdcc</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-2.23171.5">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.7.0-3.23324.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>48b13597fee9df5ecfbd0b8c0758b3f46bc1d440</Sha>
+      <Sha>d0f4099ffa7f8ff31fd397a4a96f404e1cd7dfc7</Sha>
+      <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23167.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23313.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>92c39a4f0bacef20812f63e2e1d3f7aa8776038d</Sha>
+      <Sha>91616785a1a6578c83f7e93d98c34a1eb83d6223</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 7109c4f75a6..fa8dc8ab18e 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.7.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.6.0-preview-23178-11</PackageValidationBaselineVersion>
+    <VersionPrefix>17.8.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.7.0</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -48,14 +48,15 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23167.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23313.5</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.6.0-2.23171.5</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.5.0-rc.149</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.7.0-3.23324.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.7.0-rc.106</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
+    <XunitVersion>2.4.2</XunitVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index b214a31db23..7b714ec2a80 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -75,6 +75,10 @@ jobs:
   - ${{ if eq(parameters.enableRichCodeNavigation, 'true') }}:
     - name: EnableRichCodeNavigation
       value: 'true'
+  # Retry signature validation up to three times, waiting 2 seconds between attempts.
+  # See https://learn.microsoft.com/en-us/nuget/reference/errors-and-warnings/nu3028#retry-untrusted-root-failures
+  - name: NUGET_EXPERIMENTAL_CHAIN_BUILD_RETRY_POLICY
+    value: 3,2000
   - ${{ each variable in parameters.variables }}:
     # handle name-value variable syntax
     # example:
@@ -83,7 +87,7 @@ jobs:
     - ${{ if ne(variable.name, '') }}:
       - name: ${{ variable.name }}
         value: ${{ variable.value }}
-    
+
     # handle variable groups
     - ${{ if ne(variable.group, '') }}:
       - group: ${{ variable.group }}
@@ -164,7 +168,7 @@ jobs:
   - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
     - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
       - task: MicroBuildCleanup@1
-        displayName: Execute Microbuild cleanup tasks  
+        displayName: Execute Microbuild cleanup tasks
         condition: and(always(), in(variables['_SignType'], 'real', 'test'), eq(variables['Agent.Os'], 'Windows_NT'))
         continueOnError: ${{ parameters.continueOnError }}
         env:
@@ -214,7 +218,7 @@ jobs:
       displayName: Publish XUnit Test Results
       inputs:
         testResultsFormat: 'xUnit'
-        testResultsFiles: '*.xml' 
+        testResultsFiles: '*.xml'
         searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
         testRunTitle: ${{ coalesce(parameters.testRunTitle, parameters.name, '$(System.JobName)') }}-xunit
         mergeTestResults: ${{ parameters.mergeTestResults }}
@@ -225,7 +229,7 @@ jobs:
       displayName: Publish TRX Test Results
       inputs:
         testResultsFormat: 'VSTest'
-        testResultsFiles: '*.trx' 
+        testResultsFiles: '*.trx'
         searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
         testRunTitle: ${{ coalesce(parameters.testRunTitle, parameters.name, '$(System.JobName)') }}-trx
         mergeTestResults: ${{ parameters.mergeTestResults }}
diff --git a/eng/common/templates/steps/component-governance.yml b/eng/common/templates/steps/component-governance.yml
new file mode 100644
index 00000000000..babc2757d8d
--- /dev/null
+++ b/eng/common/templates/steps/component-governance.yml
@@ -0,0 +1,10 @@
+parameters:
+  disableComponentGovernance: false
+
+steps:
+- ${{ if eq(parameters.disableComponentGovernance, 'true') }}:
+  - script: "echo ##vso[task.setvariable variable=skipComponentGovernanceDetection]true"
+    displayName: Set skipComponentGovernanceDetection variable
+- ${{ if ne(parameters.disableComponentGovernance, 'true') }}:
+  - task: ComponentGovernanceComponentDetection@0
+    continueOnError: true
\ No newline at end of file
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index a68e0949b2c..b953ddad88b 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -40,7 +40,7 @@
     <PackageVersion Include="System.Runtime" Version="4.3.1" />
     <PackageVersion Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="7.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="7.0.2" />
     <PackageVersion Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
     <PackageVersion Include="System.Security.Cryptography.Xml" Version="7.0.1" />
@@ -48,11 +48,14 @@
 
     <PackageVersion Include="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
     <PackageVersion Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
+
+    <PackageVersion Include="Verify.Xunit" Version="19.14.1" />
+    <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.4" />
-    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.435" PrivateAssets="all"/>
+    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.507" PrivateAssets="all"/>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
diff --git a/eng/sdl-tsa-vars.config b/eng/sdl-tsa-vars.config
new file mode 100644
index 00000000000..a6303401812
--- /dev/null
+++ b/eng/sdl-tsa-vars.config
@@ -0,0 +1,11 @@
+-SourceToolsList @("policheck","credscan")
+-TsaInstanceURL https://devdiv.visualstudio.com/
+-TsaProjectName DEVDIV
+-TsaNotificationEmail dotnetdevexcli@microsoft.com
+-TsaCodebaseAdmin REDMOND\marcpop
+-TsaBugAreaPath "DevDiv\NET Tools\MSBuild"
+-TsaIterationPath DevDiv
+-TsaRepositoryName DotNet-msbuild-Trusted
+-TsaCodebaseName DotNet-msbuild-Trusted
+-TsaOnboard $True
+-TsaPublish $True
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index ac62b8e21d7..721a4521fdc 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -82,6 +82,30 @@ public void ReadNoChildren(string project)
             Assert.Equal(0, Helpers.Count(item.Metadata));
         }
 
+        [Fact]
+        public void ReadMetadataLocationPreserved()
+        {
+            string project = """
+                <Project>
+                    <Target Name='t'>
+                        <ItemGroup>
+                            <i Include='i' MetadataA='123' MetadataB='xyz' />
+                        </ItemGroup>
+                    </Target>
+                </Project>
+                """;
+
+            ProjectItemElement item = GetItemFromContent(project);
+            Assert.Equal(2, item.Metadata.Count);
+            ProjectMetadataElement metadatum1 = item.Metadata.First();
+            ProjectMetadataElement metadatum2 = item.Metadata.Skip(1).First();
+
+            Assert.Equal(4, metadatum1.Location.Line);
+            Assert.Equal(4, metadatum2.Location.Line);
+            Assert.Equal(27, metadatum1.Location.Column);
+            Assert.Equal(43, metadatum2.Location.Column);
+        }
+
         /// <summary>
         /// Read item with no include
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 1dcc2fb9fc2..57cba86c10c 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -15,8 +15,9 @@
   </PropertyGroup>
 
   <PropertyGroup>
-    <NuGetCommandLinePackageVersion>4.1.0</NuGetCommandLinePackageVersion>
-</PropertyGroup>
+    <!-- Managed manually since PackageDownload is not supported by dependabot https://github.com/dependabot/dependabot-core/issues/2920 -->
+    <NuGetCommandLinePackageVersion>4.9.6</NuGetCommandLinePackageVersion>
+  </PropertyGroup>
 
   <ItemGroup>
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
@@ -28,7 +29,7 @@
 
   <ItemGroup>
     <!-- GeneratePathProperty currently isn't enabled for PackageDownload. -->
-    <Content Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(Configuration)' == 'Release'" Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
+    <Content Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index c0a00cf572e..ee35a83c93a 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -1,13 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if !DEBUG
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using System.IO;
 using Xunit;
-#endif
 using Xunit.Abstractions;
 using Xunit.NetCore.Extensions;
 
@@ -21,9 +19,7 @@ public NugetRestoreTests(ITestOutputHelper output)
             _output = output;
         }
 
-        // This NuGet version cannot locate other assemblies when parsing solutions at restore time. This includes localized strings required in debug mode.
-        // NuGet version 4.1.0 was somewhat arbitrarily chosen. 3.5 breaks with an unrelated error, and 4.8.2 does not fail when a new dependency is introduced. This is a safe middle point.
-#if !DEBUG
+        // Tests proper loading of msbuild assemblies by nuget.exe
         [WindowsFullFrameworkOnlyFact]
         public void TestOldNuget()
         {
@@ -54,6 +50,5 @@ public void TestOldNuget()
             RunnerUtilities.RunProcessAndGetOutput(Path.Combine(msbuildExePath, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + msbuildExePath + "\"", out bool success, outputHelper: _output);
             success.ShouldBeTrue();
         }
-#endif
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index b1288952956..ba1e8c7b4eb 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -6,8 +6,13 @@
 using System.Configuration.Assemblies;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Shouldly;
 using Xunit;
 
@@ -20,6 +25,11 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class BinaryTranslator_Tests
     {
+        static BinaryTranslator_Tests()
+        {
+            SerializationContractInitializer.Initialize();
+        }
+
         /// <summary>
         /// Tests the SerializationMode property
         /// </summary>
@@ -27,7 +37,7 @@ public class BinaryTranslator_Tests
         public void TestSerializationMode()
         {
             MemoryStream stream = new MemoryStream();
-            using ITranslator readTranslator = BinaryTranslator.GetReadTranslator(stream, null);
+            using ITranslator readTranslator = BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
             Assert.Equal(TranslationDirection.ReadFromStream, readTranslator.Mode);
 
             using ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(stream);
@@ -183,7 +193,7 @@ public void TestSerializeDotNet()
             ArgumentNullException deserializedValue = null;
             TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
 
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
         }
 
         /// <summary>
@@ -198,7 +208,125 @@ public void TestSerializeDotNetNull()
             ArgumentNullException deserializedValue = null;
             TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
 
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeException()
+        {
+            Exception value = new ArgumentNullException("The argument was null");
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                // Intentionally throw a nested exception with a stack trace.
+                value = value.InnerException;
+            }
+            catch (Exception e)
+            {
+                value = new ArgumentNullException("The argument was null", e);
+            }
+
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeBuildException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                throw new InvalidProjectFileException("sample message");
+            }
+            catch (Exception e)
+            {
+                try
+                {
+                    throw new ArgumentNullException("The argument was null", e);
+                }
+                catch (Exception exception)
+                {
+                    value = new InternalErrorException("Another message", exception);
+                }
+            }
+
+            Assert.NotNull(value);
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        public static IEnumerable<object[]> GetBuildExceptionsAsTestData()
+            => AppDomain
+                .CurrentDomain
+                .GetAssemblies()
+                // TaskHost is copying code files - so has a copy of types with identical names.
+                .Where(a => !a.FullName!.StartsWith("MSBuildTaskHost", StringComparison.CurrentCultureIgnoreCase))
+                .SelectMany(s => s.GetTypes())
+                .Where(BuildExceptionSerializationHelper.IsSupportedExceptionType)
+                .Select(t => new object[] { t });
+
+        [Theory]
+        [MemberData(nameof(GetBuildExceptionsAsTestData))]
+        public void TestSerializationOfBuildExceptions(Type exceptionType)
+        {
+            Exception e = (Exception)Activator.CreateInstance(exceptionType, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.Instance, null, new object[]{"msg", new GenericBuildTransferredException() }, System.Globalization.CultureInfo.CurrentCulture);
+            Exception remote;
+            try
+            {
+                throw e;
+            }
+            catch (Exception exception)
+            {
+                remote = exception;
+            }
+
+            Assert.NotNull(remote);
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref remote);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(remote, deserializedValue, out string diffReason, true), $"Exception type {exceptionType.FullName} not properly de/serialized: {diffReason}");
+        }
+
+        [Fact]
+        public void TestInvalidProjectFileException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                throw new InvalidProjectFileException("sample message", new InternalErrorException("Another message"));
+            }
+            catch (Exception e)
+            {
+                value = e;
+            }
+
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason, true), diffReason);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 13269b5221a..02c1179e863 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -326,16 +326,16 @@ public void TestTranslation()
 
             Assert.Equal(result.ConfigurationId, deserializedResult.ConfigurationId);
             Assert.True(TranslationHelpers.CompareCollections(result.DefaultTargets, deserializedResult.DefaultTargets, StringComparer.Ordinal));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
             Assert.Equal(result.Exception.Message, deserializedResult.Exception.Message);
             Assert.Equal(result.GlobalRequestId, deserializedResult.GlobalRequestId);
             Assert.True(TranslationHelpers.CompareCollections(result.InitialTargets, deserializedResult.InitialTargets, StringComparer.Ordinal));
             Assert.Equal(result.NodeRequestId, deserializedResult.NodeRequestId);
             Assert.Equal(result["alpha"].ResultCode, deserializedResult["alpha"].ResultCode);
-            Assert.True(TranslationHelpers.CompareExceptions(result["alpha"].Exception, deserializedResult["alpha"].Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result["alpha"].Exception, deserializedResult["alpha"].Exception, out diffReason), diffReason);
             Assert.True(TranslationHelpers.CompareCollections(result["alpha"].Items, deserializedResult["alpha"].Items, TaskItemComparer.Instance));
             Assert.Equal(result["omega"].ResultCode, deserializedResult["omega"].ResultCode);
-            Assert.True(TranslationHelpers.CompareExceptions(result["omega"].Exception, deserializedResult["omega"].Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result["omega"].Exception, deserializedResult["omega"].Exception, out diffReason), diffReason);
             Assert.True(TranslationHelpers.CompareCollections(result["omega"].Items, deserializedResult["omega"].Items, TaskItemComparer.Instance));
         }
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 078aae2bb15..1bae3f8adde 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -1068,7 +1068,7 @@ public void ImportanceReflectsCentralForwardingLoggerVerbosity()
         public void ImportanceReflectsUnknownLoggerVerbosity()
         {
             // Minimum message importance is Low (i.e. we're logging everything) even when all registered loggers have
-            // Normal verbosity if at least of one them is not on our whitelist.
+            // Normal verbosity if at least of one them is not on our allowlist.
             _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
             _initializedService.RegisterLogger(new MockLogger() { Verbosity = LoggerVerbosity.Normal });
             _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Normal));
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 98d37bfc4cb..9b0a1eae9bb 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -824,7 +823,8 @@ public void ItemsRecursionWithinTarget()
                       </Target>
                     </Project>
                 """;
-            var projectFile = env.CreateFile("test.proj", ObjectModelHelpers.CleanupFileContents(projectContent));
+            string projFileName = "test.proj";
+            var projectFile = env.CreateFile(projFileName, ObjectModelHelpers.CleanupFileContents(projectContent));
 
             MockLogger logger = new MockLogger(_testOutput);
             ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
@@ -839,6 +839,10 @@ public void ItemsRecursionWithinTarget()
             logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Filename"));
             logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Extension"));
             logger.AssertMessageCount("MSB4120", 6);
+            // The location of the offending attribute (TargetPath) is transferred - for both metadatums (%(Filename) and %(Extension)) on correct locations in xml
+            logger.AssertMessageCount($"{projFileName}(4,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(5,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(6,34):", 2, false);
             Assert.Equal(0, logger.WarningCount);
             Assert.Equal(0, logger.ErrorCount);
         }
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 5c653497011..d9fb204fb78 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -102,7 +102,7 @@ public void TestTranslationNoException()
 
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
             Assert.Equal(result.OriginalBuildEventContext, deserializedResult.OriginalBuildEventContext);
         }
 
@@ -122,7 +122,7 @@ public void TestTranslationWithException()
 
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index 60f073a0cf2..7d4736837ce 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -9,6 +9,7 @@
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using Xunit;
 
 #nullable disable
 
@@ -40,7 +41,7 @@ internal static ITranslator GetWriteTranslator()
         internal static ITranslator GetReadTranslator()
         {
             s_serializationStream.Seek(0, SeekOrigin.Begin);
-            return BinaryTranslator.GetReadTranslator(s_serializationStream, null);
+            return BinaryTranslator.GetReadTranslator(s_serializationStream, InterningBinaryReader.PoolingBuffer);
         }
 
         /// <summary>
@@ -85,8 +86,9 @@ internal static bool CompareCollections<T>(ICollection<T> left, ICollection<T> r
         /// <summary>
         /// Compares two exceptions.
         /// </summary>
-        internal static bool CompareExceptions(Exception left, Exception right)
+        internal static bool CompareExceptions(Exception left, Exception right, out string diffReason, bool detailed = false)
         {
+            diffReason = null;
             if (ReferenceEquals(left, right))
             {
                 return true;
@@ -94,20 +96,74 @@ internal static bool CompareExceptions(Exception left, Exception right)
 
             if ((left == null) ^ (right == null))
             {
+                diffReason = "One exception is null and the other is not.";
                 return false;
             }
 
             if (left.Message != right.Message)
             {
+                diffReason = $"Exception messages are different ({left.Message} vs {right.Message}).";
                 return false;
             }
 
             if (left.StackTrace != right.StackTrace)
             {
+                diffReason = $"Exception stack traces are different ({left.StackTrace} vs {right.StackTrace}).";
                 return false;
             }
 
-            return CompareExceptions(left.InnerException, right.InnerException);
+            if (!CompareExceptions(left.InnerException, right.InnerException, out diffReason, detailed))
+            {
+                diffReason = "Inner exceptions are different: " + diffReason;
+                return false;
+            }
+
+            if (detailed)
+            {
+                if (left.GetType() != right.GetType())
+                {
+                    diffReason = $"Exception types are different ({left.GetType().FullName} vs {right.GetType().FullName}).";
+                    return false;
+                }
+
+                foreach (var prop in left.GetType().GetProperties())
+                {
+                    if (!IsSimpleType(prop.PropertyType))
+                    {
+                        continue;
+                    }
+
+                    object leftProp = prop.GetValue(left, null);
+                    object rightProp = prop.GetValue(right, null);
+
+                    if (leftProp == null && rightProp != null)
+                    {
+                        diffReason = $"Property {prop.Name} is null on left but not on right.";
+                        return false;
+                    }
+
+                    if (leftProp != null && !prop.GetValue(left, null).Equals(prop.GetValue(right, null)))
+                    {
+                        diffReason = $"Property {prop.Name} is different ({prop.GetValue(left, null)} vs {prop.GetValue(rightProp, null)}).";
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        internal static bool IsSimpleType(Type type)
+        {
+            // Nullables
+            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
+            {
+                return IsSimpleType(type.GetGenericArguments()[0]);
+            }
+            return type.IsPrimitive
+                   || type.IsEnum
+                   || type == typeof(string)
+                   || type == typeof(decimal);
         }
 
         internal static string GetPropertiesString(IEnumerable properties)
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index e16f3578b22..57e2bc3fa82 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -228,12 +228,24 @@ public void AssemblyLoadsDuringTaskRunLogged()
                 BinaryLogger logger = new();
                 logger.Parameters = _logFile;
                 env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters}", out bool success);
-                success.ShouldBeTrue();
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile2.log")};verbosity=normal", out bool success);
                 success.ShouldBeTrue();
+
+                string assemblyLoadedEventText =
+                    "Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug";
                 string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
-                text.ShouldContain("Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug");
+                text.ShouldContain(assemblyLoadedEventText);
+                // events should not be in logger with verbosity normal
+                string text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile2.log"));
+                text2.ShouldNotContain(assemblyLoadedEventText);
+
+                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
+                success.ShouldBeTrue();
+                text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile3.log"));
+                text.ShouldContain(assemblyLoadedEventText);
+                // events should not be in logger with verbosity normal
+                text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile4.log"));
+                text2.ShouldNotContain(assemblyLoadedEventText);
             }
         }
 
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 443871defb6..78cd0f31dc1 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -130,26 +130,44 @@ public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
             Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
         }
 
-        [Fact]
-        public void EvaluationShouldUseDirectoryCache()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void EvaluationShouldUseDirectoryCache(bool useProjectInstance)
         {
-            var projectFile = _env.CreateFile("1.proj", @"<Project> <ItemGroup Condition=`Exists('1.file')`> <Compile Include='*.cs'/> </ItemGroup> </Project>".Cleanup()).Path;
+            var projectFile = _env.CreateFile("1.proj", @"<Project> <Import Project='1.file' Condition=`Exists('1.file')`/> <ItemGroup><Compile Include='*.cs'/></ItemGroup> </Project>".Cleanup()).Path;
 
             var projectCollection = _env.CreateProjectCollection().Collection;
             var directoryCacheFactory = new Helpers.LoggingDirectoryCacheFactory();
 
-            var project = Project.FromFile(
-                projectFile,
-                new ProjectOptions
-                {
-                    ProjectCollection = projectCollection,
-                    DirectoryCacheFactory = directoryCacheFactory,
-                });
+            int expectedEvaluationId;
+            if (useProjectInstance)
+            {
+                var projectInstance = ProjectInstance.FromFile(
+                    projectFile,
+                    new ProjectOptions
+                    {
+                        ProjectCollection = projectCollection,
+                        DirectoryCacheFactory = directoryCacheFactory,
+                    });
+                expectedEvaluationId = projectInstance.EvaluationId;
+            }
+            else
+            {
+                var project = Project.FromFile(
+                    projectFile,
+                    new ProjectOptions
+                    {
+                        ProjectCollection = projectCollection,
+                        DirectoryCacheFactory = directoryCacheFactory,
+                    });
+                expectedEvaluationId = project.LastEvaluationId;
+            }
 
             directoryCacheFactory.DirectoryCaches.Count.ShouldBe(1);
             var directoryCache = directoryCacheFactory.DirectoryCaches[0];
 
-            directoryCache.EvaluationId.ShouldBe(project.LastEvaluationId);
+            directoryCache.EvaluationId.ShouldBe(expectedEvaluationId);
 
             directoryCache.ExistenceChecks.OrderBy(kvp => kvp.Key).ShouldBe(
                 new Dictionary<string, int>
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index e897cd174e3..3df737c387a 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -868,15 +868,15 @@ public void CanGetCorrectListOfItemsWithSemicolonsInThem()
                         <MyUserMacro>foo%3bbar</MyUserMacro>
                     </PropertyGroup>
                     <ItemGroup>
-                        <CrazyList Include=""a"" />
-                        <CrazyList Include=""b%3bc"" />
-                        <CrazyList Include=""$(MyUserMacro)"" />
+                        <DifferentList Include=""a"" />
+                        <DifferentList Include=""b%3bc"" />
+                        <DifferentList Include=""$(MyUserMacro)"" />
                     </ItemGroup>
                 </Project>";
 
             System.Xml.XmlReader reader = new System.Xml.XmlTextReader(new StringReader(projectString));
             Project project = new Project(reader);
-            IEnumerable<ProjectItem> items = project.GetItems("CrazyList");
+            IEnumerable<ProjectItem> items = project.GetItems("DifferentList");
 
             Assert.Equal(3, items.Count());
             Assert.Equal("a", items.ElementAt(0).EvaluatedInclude);
@@ -900,15 +900,15 @@ public void CanGetCorrectListOfItemsWithSemicolonsInThem2()
                         <MyUserMacro>foo;bar</MyUserMacro>
                     </PropertyGroup>
                     <ItemGroup>
-                        <CrazyList Include=""a"" />
-                        <CrazyList Include=""b%3bc"" />
-                        <CrazyList Include=""$(MyUserMacro)"" />
+                        <DifferentList Include=""a"" />
+                        <DifferentList Include=""b%3bc"" />
+                        <DifferentList Include=""$(MyUserMacro)"" />
                     </ItemGroup>
                 </Project>";
 
             System.Xml.XmlReader reader = new System.Xml.XmlTextReader(new StringReader(projectString));
             Project project = new Project(reader);
-            IEnumerable<ProjectItem> items = project.GetItems("CrazyList");
+            IEnumerable<ProjectItem> items = project.GetItems("DifferentList");
 
             Assert.Equal(4, items.Count());
             Assert.Equal("a", items.ElementAt(0).EvaluatedInclude);
@@ -1446,11 +1446,11 @@ public class Class1
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
-        /// have all sorts of crazy characters in their name. There
+        /// have all sorts of different characters in their name. There
         /// is even a P2P reference between the two projects in the .SLN.
         /// </summary>
         [Fact(Skip = "This is a known issue in Roslyn. This test should be enabled if Roslyn is updated for this scenario.")]
-        public void SolutionWithLotsaCrazyCharacters()
+        public void SolutionWithLotsaDifferentCharacters()
         {
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
@@ -1612,11 +1612,11 @@ public class Class1
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
-        /// have all sorts of crazy characters in their name. There
+        /// have all sorts of different characters in their name. There
         /// is even a P2P reference between the two projects in the .SLN.
         /// </summary>
         [Fact(Skip = "This is a known issue in Roslyn. This test should be enabled if Roslyn is updated for this scenario.")]
-        public void SolutionWithLotsaCrazyCharacters_UsingTaskHost()
+        public void SolutionWithLotsaDifferentCharacters_UsingTaskHost()
         {
             string originalOverrideTaskHostVariable = Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC");
 
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index f215d86d9ec..221ea0026e2 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4473,6 +4473,38 @@ public void ConditionWithShortCircuitAndErrorDoesNotFailBuild(string projectInne
             }
         }
 
+        [Theory]
+        [InlineData("$(Hello)", 0, 8, "Hello")]
+        [InlineData("$(Hello)|$(World)", 9, 8, "World")]
+        [InlineData("$(He()o)", 0, 8, null)]
+        [InlineData("$)Hello(", 0, 8, null)]
+        [InlineData("$(Helloo", 0, 8, null)]
+        [InlineData("$Heello)", 0, 8, null)]
+        [InlineData("$(He$$o)", 0, 8, null)]
+        [InlineData(" $(Helo)", 0, 8, null)]
+        [InlineData("$(Helo) ", 0, 8, null)]
+        [InlineData("$()", 0, 3, "")]
+        [InlineData("$( Hello )", 0, 10, " Hello ")]
+        [InlineData("$(He-ll-o)", 0, 10, "He-ll-o")]
+        [InlineData("$(He ll o)", 0, 10, "He ll o")]
+        [InlineData("aaa$(Hello)", 3, 8, "Hello")]
+        [InlineData("aaa$(Hello)bbb", 3, 8, "Hello")]
+        public void TryGetSingleProperty(string input, int start, int length, string expected)
+        {
+            bool result = ConditionEvaluator.TryGetSingleProperty(input.AsSpan(), start, length, out ReadOnlySpan<char> actual);
+
+            if (expected is null)
+            {
+                Assert.False(result);
+                Assert.True(actual.IsEmpty);
+            }
+            else
+            {
+                Assert.True(result);
+                Assert.Equal(expected, actual.ToString());
+            }
+        }
+
         [Fact]
         public void VerifyMSBuildLastModifiedProjectForImport()
         {
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index b55b0dec344..11a505c2fd4 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1118,6 +1118,37 @@ public void HasMetadata()
             logger.AssertLogContains("[One|Three|Four]");
         }
 
+
+        /// <summary>
+        /// Filter items by WithoutMetadataValue function
+        /// </summary>
+        [Fact]
+        public void WithoutMetadataValue()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess("""
+                <Project>
+                    <ItemGroup>
+                            <_Item Include="One">
+                                <A>true</A>
+                            </_Item>
+                            <_Item Include="Two">
+                                <A>false</A>
+                            </_Item>
+                            <_Item Include="Three">
+                                <A></A>
+                            </_Item>
+                            <_Item Include="Four">
+                                <B></B>
+                            </_Item>
+                    </ItemGroup>
+                    <Target Name="AfterBuild">
+                        <Message Text="[@(_Item->WithoutMetadataValue('a', 'true'),'|')]"/>
+                    </Target>
+                </Project>
+                """);
+
+            logger.AssertLogContains("[Two|Three|Four]");
+        }
         [Fact]
         public void DirectItemMetadataReferenceShouldBeCaseInsensitive()
         {
@@ -3180,17 +3211,17 @@ public void PropertyFunctionValueOrDefaultFromEnvironment()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
 
-            pg["BonkersTargetsPath"] = ProjectPropertyInstance.Create("BonkersTargetsPath", "Bonkers");
+            pg["DifferentTargetsPath"] = ProjectPropertyInstance.Create("DifferentTargetsPath", "Different");
 
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
 
-            string result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(BonkersTargetsPath)', '42'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            string result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(DifferentTargetsPath)', '42'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
-            Assert.Equal("Bonkers", result);
+            Assert.Equal("Different", result);
 
-            pg["BonkersTargetsPath"] = ProjectPropertyInstance.Create("BonkersTargetsPath", String.Empty);
+            pg["DifferentTargetsPath"] = ProjectPropertyInstance.Create("DifferentTargetsPath", String.Empty);
 
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(BonkersTargetsPath)', '43'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::ValueOrDefault('$(DifferentTargetsPath)', '43'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
             Assert.Equal("43", result);
         }
diff --git a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
new file mode 100644
index 00000000000..8ede8eec729
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
@@ -0,0 +1,42 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+
+using Xunit;
+
+namespace Microsoft.Build.Evaluation;
+
+public sealed class UsedUninitializedProperties_Tests
+{
+    [Fact]
+    public void Basics()
+    {
+        UsedUninitializedProperties props = new();
+
+        Assert.False(props.TryGetPropertyElementLocation("Hello", out IElementLocation? elementLocation));
+        Assert.Null(elementLocation);
+
+        props.RemoveProperty("Hello");
+
+        IElementLocation location1 = new MockElementLocation("File1");
+        IElementLocation location2 = new MockElementLocation("File2");
+
+        props.TryAdd("Hello", location1);
+        props.TryAdd("Hello", location2);
+
+        Assert.True(props.TryGetPropertyElementLocation("Hello", out elementLocation));
+        Assert.Same(location1, elementLocation);
+
+        Assert.True(props.TryGetPropertyElementLocation("Hello", out elementLocation));
+        Assert.Same(location1, elementLocation);
+
+        props.RemoveProperty("Hello");
+
+        Assert.False(props.TryGetPropertyElementLocation("Hello", out elementLocation));
+        Assert.Null(elementLocation);
+
+        props.RemoveProperty("Hello");
+    }
+}
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 3bc916aa4bb..997f7dd24dc 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Exceptions;
@@ -523,6 +524,39 @@ public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> ed
 
             var graphFromSolutionEdges = graphFromSolution.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
 
+            // These are global properties added by GraphBuilder when building a solution
+            HashSet<string> propertiesToIgnore = new(StringComparer.OrdinalIgnoreCase)
+            {
+                "CurrentSolutionConfigurationContents",
+                "BuildingSolutionFile",
+                "SolutionDir",
+                "SolutionExt",
+                "SolutionFileName",
+                "SolutionName",
+                SolutionProjectGenerator.SolutionPathPropertyName
+            };
+
+            // Solutions add these global properties
+            foreach (string propertyToIgnore in propertiesToIgnore)
+            {
+                foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+                {
+                    graphFromSolutionEdge.Item1.GlobalProperties.ShouldContainKey(propertyToIgnore);
+                    graphFromSolutionEdge.Item2.GlobalProperties.ShouldContainKey(propertyToIgnore);
+                }
+            }
+
+            // Remove some properties for comparison purposes as we are comparing a graph created from a solution against the graph (without solution properties) used to make the solution.
+            // This is done as a separate pass since some edges may be sharing an instance.
+            foreach (string propertyToIgnore in propertiesToIgnore)
+            {
+                foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+                {
+                    graphFromSolutionEdge.Item1.GlobalProperties.Remove(propertyToIgnore);
+                    graphFromSolutionEdge.Item2.GlobalProperties.Remove(propertyToIgnore);
+                }
+            }
+
             // Original edges get preserved.
             foreach (var graphEdge in graphEdges)
             {
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 644738a81fe..932c3c8e439 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -674,6 +675,160 @@ public void ConstructGraphWithDifferentEntryPointsAndGraphRoots()
             }
         }
 
+        [Fact]
+        public void ConstructGraphWithSolution()
+        {
+            // This test exercises two key features of solution-based builds from AssignProjectConfiguration:
+            // 1. Adding synthetic project references
+            // 2. Resolving project configuration based on the sln
+            // 3. Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=true
+            // 4. Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=false
+            using (var env = TestEnvironment.Create())
+            {
+                const string SolutionFileContents = """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 17
+                    VisualStudioVersion = 17.0.31903.59
+                    MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "Project1.csproj", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98} = {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}
+                        EndProjectSection
+                    EndProject
+                    Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Project2", "Project2.vcxproj", "{D638A8EF-3A48-45F2-913C-88B29FED03CB}"
+                    EndProject
+                    Project("{13B669BE-BB05-4DDF-9536-439F39A36129}") = "Project3", "Project3.vcxproj", "{52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Win32 = Debug|Win32
+                            Debug|x64 = Debug|x64
+                            Debug|x86 = Debug|x86
+                            Release|Win32 = Release|Win32
+                            Release|x64 = Release|x64
+                            Release|x86 = Release|x86
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.ActiveCfg = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.Build.0 = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x86.ActiveCfg = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x86.Build.0 = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|Win32.ActiveCfg = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|Win32.Build.0 = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x86.ActiveCfg = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x86.Build.0 = Release|x86
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|Win32.Build.0 = Debug|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|x64.ActiveCfg = Debug|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|x64.Build.0 = Debug|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|Win32.ActiveCfg = Release|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|Win32.Build.0 = Release|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|x64.ActiveCfg = Release|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.ActiveCfg = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.Build.0 = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.ActiveCfg = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.ActiveCfg = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.Build.0 = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.ActiveCfg = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.Build.0 = Release|Win32
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
+                TransientTestFile slnFile = env.CreateFile(@"Solution.sln", SolutionFileContents);
+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);
+
+                ProjectRootElement project1Xml = ProjectRootElement.Create();
+
+                // Project 1 depends on Project 2 using ProjectReference but there is a sln-based dependency defined on Project 3 as well.
+                project1Xml.AddItem("ProjectReference", "Project2.vcxproj");
+
+                ProjectRootElement project2Xml = ProjectRootElement.Create();
+
+                // Project 2 depends on Project 4, which is not in the solution and uses ShouldUnsetParentConfigurationAndPlatform=true (the default)
+                project2Xml.AddItem("ProjectReference", "Project4.vcxproj");
+                project2Xml.AddProperty("ShouldUnsetParentConfigurationAndPlatform", "true");
+
+                ProjectRootElement project3Xml = ProjectRootElement.Create();
+
+                // Project 3 depends on Project 5, which is not in the solution and uses ShouldUnsetParentConfigurationAndPlatform=false
+                project3Xml.AddItem("ProjectReference", "Project5.vcxproj");
+                project3Xml.AddProperty("ShouldUnsetParentConfigurationAndPlatform", "false");
+
+                ProjectRootElement project4Xml = ProjectRootElement.Create();
+                ProjectRootElement project5Xml = ProjectRootElement.Create();
+
+                string project1Path = Path.Combine(env.DefaultTestDirectory.Path, "Project1.csproj");
+                string project2Path = Path.Combine(env.DefaultTestDirectory.Path, "Project2.vcxproj");
+                string project3Path = Path.Combine(env.DefaultTestDirectory.Path, "Project3.vcxproj");
+                string project4Path = Path.Combine(env.DefaultTestDirectory.Path, "Project4.vcxproj");
+                string project5Path = Path.Combine(env.DefaultTestDirectory.Path, "Project5.vcxproj");
+
+                project1Xml.Save(project1Path);
+                project2Xml.Save(project2Path);
+                project3Xml.Save(project3Path);
+                project4Xml.Save(project4Path);
+                project5Xml.Save(project5Path);
+
+                var projectGraph = new ProjectGraph(slnFile.Path);
+                projectGraph.EntryPointNodes.Count.ShouldBe(3);
+                projectGraph.GraphRoots.Count.ShouldBe(1);
+                projectGraph.GraphRoots.First().ProjectInstance.FullPath.ShouldBe(project1Path);
+                projectGraph.ProjectNodes.Count.ShouldBe(5);
+
+                ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project1Path);
+                project1Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project1Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                project1Node.ProjectReferences.Count.ShouldBe(2);
+
+                ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project2Path);
+                project2Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project2Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project2Node.ProjectReferences.Count.ShouldBe(1);
+
+                ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project3Path);
+                project3Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project3Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project3Node.ProjectReferences.Count.ShouldBe(1);
+
+                // Configuration and Platform get unset
+                ProjectGraphNode project4Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project4Path);
+                project4Node.ProjectInstance.GlobalProperties.ContainsKey("Configuration").ShouldBeFalse();
+                project4Node.ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                project4Node.ProjectReferences.Count.ShouldBe(0);
+
+                // Configuration and Platform are inherited from the referencing project
+                ProjectGraphNode project5Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project5Path);
+                project5Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project5Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project5Node.ProjectReferences.Count.ShouldBe(0);
+            }
+        }
+
         [Fact]
         public void GetTargetListsAggregatesFromMultipleEdges()
         {
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 4751aef9ddd..8590a479da9 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -175,7 +175,7 @@ internal static void AssertBuildResultsEqual(BuildResult actualBuildResult, Buil
 
             internal static void AssertTargetResultsEqual(TargetResult a, TargetResult b)
             {
-                TranslationHelpers.CompareExceptions(a.Exception, b.Exception).ShouldBeTrue();
+                TranslationHelpers.CompareExceptions(a.Exception, b.Exception, out string diffReason).ShouldBeTrue(diffReason);
                 TranslationHelpers.CompareCollections(a.Items, b.Items, TaskItemComparer.Instance).ShouldBeTrue();
 
                 a.ResultCode.ShouldBe(b.ResultCode);
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 048cfd6ccc9..ff426e28362 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -15,6 +15,8 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 364c68081a9..36094ff2bec 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -898,10 +898,10 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
         }
 
         /// <summary>
-        /// Synthesizes Link metadata if the items are defined in an import and are on the whitelist
+        /// Synthesizes Link metadata if the items are defined in an import and are on the allowlist
         /// </summary>
         [Fact]
-        public void SynthesizeLinkMetadataForItemsOnWhitelist()
+        public void SynthesizeLinkMetadataForItemsOnAllowlist()
         {
             string outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
             string directoryToDelete = null;
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 9787ffe4a5c..66e67c82d3c 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -306,6 +306,7 @@ public BuildManager(string hostName)
             _nextUnnamedProjectId = 1;
             _componentFactories = new BuildComponentFactoryCollection(this);
             _componentFactories.RegisterDefaultFactories();
+            SerializationContractInitializer.Initialize();
             _projectStartedEvents = new Dictionary<int, BuildEventArgs>();
 
             _projectStartedEventHandler = OnProjectStarted;
@@ -2465,7 +2466,6 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
                     // shut down.
                     submission.CompleteLogging();
 
-                    _overallBuildSuccess = _overallBuildSuccess && (submission.BuildResult.OverallResult == BuildResultCode.Success);
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
 
@@ -2479,7 +2479,6 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
 
                     submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, new BuildAbortedException()));
 
-                    _overallBuildSuccess &= submission.BuildResult.OverallResult == BuildResultCode.Success;
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
 
@@ -2591,8 +2590,6 @@ private void ReportResultsToSubmission(BuildResult result)
 
                     submission.CompleteResults(result);
 
-                    _overallBuildSuccess = _overallBuildSuccess && (_buildSubmissions[result.SubmissionId].BuildResult.OverallResult == BuildResultCode.Success);
-
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
             }
@@ -2610,8 +2607,6 @@ private void ReportResultsToSubmission(GraphBuildResult result)
                 {
                     submission.CompleteResults(result);
 
-                    _overallBuildSuccess &= submission.BuildResult.OverallResult == BuildResultCode.Success;
-
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
             }
@@ -2627,6 +2622,7 @@ private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission)
                 // If the submission has completed or never started, remove it.
                 if (submission.IsCompleted || submission.BuildRequest == null)
                 {
+                    _overallBuildSuccess &= (submission.BuildResult?.OverallResult == BuildResultCode.Success);
                     _buildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
@@ -2647,6 +2643,7 @@ private void CheckSubmissionCompletenessAndRemove(GraphBuildSubmission submissio
                 // If the submission has completed or never started, remove it.
                 if (submission.IsCompleted || !submission.IsStarted)
                 {
+                    _overallBuildSuccess &= submission.BuildResult?.OverallResult == BuildResultCode.Success;
                     _graphBuildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 3fa59bfe28b..7003cce1c32 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -121,7 +121,7 @@ public static (IConfigCache ConfigCache, IResultsCache ResultsCache, Exception e
 
                 using (var fileStream = File.OpenRead(inputCacheFile))
                 {
-                    using var translator = BinaryTranslator.GetReadTranslator(fileStream, null);
+                    using var translator = BinaryTranslator.GetReadTranslator(fileStream, InterningBinaryReader.PoolingBuffer);
 
                     translator.Translate(ref configCache);
                     translator.Translate(ref resultsCache);
diff --git a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
index 657bfc4b4fb..aa7efb8cd72 100644
--- a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -19,7 +20,7 @@ namespace Microsoft.Build.BackEnd
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    internal class NodeFailedToLaunchException : Exception
+    internal class NodeFailedToLaunchException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
@@ -33,6 +34,10 @@ internal NodeFailedToLaunchException(Exception innerException)
             : base(innerException.Message, innerException)
         { }
 
+        public NodeFailedToLaunchException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 7346954557d..58105527c16 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -598,7 +598,7 @@ private enum ExitPacketState
             /// <summary>
             /// Per node read buffers
             /// </summary>
-            private SharedReadBuffer _sharedReadBuffer;
+            private BinaryReaderFactory _binaryReaderFactory;
 
             /// <summary>
             /// Constructor.
@@ -616,7 +616,7 @@ public NodeContext(int nodeId, Process process,
                 _readBufferMemoryStream = new MemoryStream();
                 _writeBufferMemoryStream = new MemoryStream();
                 _terminateDelegate = terminateDelegate;
-                _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
+                _binaryReaderFactory = InterningBinaryReader.CreateSharedBuffer();
             }
 
             /// <summary>
@@ -982,7 +982,7 @@ private bool ReadAndRoutePacket(NodePacketType packetType, byte[] packetData, in
                     // Since the buffer is publicly visible dispose right away to discourage outsiders from holding a reference to it.
                     using (var packetStream = new MemoryStream(packetData, 0, packetLength, /*writeable*/ false, /*bufferIsPubliclyVisible*/ true))
                     {
-                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _sharedReadBuffer);
+                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _binaryReaderFactory);
                         _packetFactory.DeserializeAndRoutePacket(_nodeId, packetType, readTranslator);
                     }
                 }
diff --git a/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs b/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs
new file mode 100644
index 00000000000..a0dc533bbd1
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal static class SerializationContractInitializer
+    {
+        public static void Initialize()
+        {
+            RegisterExceptions();
+            // reserved for future usage - BuildEventArgs, etc.
+        }
+
+        private static void RegisterExceptions()
+        {
+            // Any exception not contained int this list will be transferred as a GenericBuildTransferredException
+            BuildExceptionSerializationHelper.InitializeSerializationContract(
+                new(typeof(GenericBuildTransferredException), (msg, inner) => new GenericBuildTransferredException(msg, inner)),
+                new(typeof(SdkResolverException), (msg, inner) => new SdkResolverException(msg, inner)),
+                new(typeof(BuildAbortedException), BuildAbortedException.CreateFromRemote),
+                new(typeof(CircularDependencyException), (msg, inner) => new CircularDependencyException(msg, inner)),
+                new(typeof(InternalLoggerException), (msg, inner) => new InternalLoggerException(msg, inner)),
+                new(typeof(InvalidProjectFileException), (msg, inner) => new InvalidProjectFileException(msg, inner)),
+                new(typeof(InvalidToolsetDefinitionException), (msg, inner) => new InvalidToolsetDefinitionException(msg, inner)),
+                new(typeof(ProjectCacheException), (msg, inner) => new ProjectCacheException(msg, inner)),
+                new(typeof(InternalErrorException), InternalErrorException.CreateFromRemote),
+                new(typeof(LoggerException), (msg, inner) => new LoggerException(msg, inner)),
+                new(typeof(NodeFailedToLaunchException), (msg, inner) => new NodeFailedToLaunchException(msg, inner)),
+                new(typeof(SchedulerCircularDependencyException), (msg, inner) => new SchedulerCircularDependencyException(msg, inner)),
+                new(typeof(RegistryException), (msg, inner) => new RegistryException(msg, inner)),
+                new(typeof(HostObjectException), (msg, inner) => new HostObjectException(msg, inner)),
+                new(typeof(UnbuildableProjectTypeException), (msg, inner) => new UnbuildableProjectTypeException(msg, inner)));
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 8e6b9ef1c0e..dc8467773b0 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1438,7 +1438,7 @@ private void RouteBuildEvent(object loggingEvent)
             {
                 if (ShouldTreatWarningAsMessage(warningEvent))
                 {
-                    loggingEvent = new BuildMessageEventArgs(
+                    buildEventArgs = new BuildMessageEventArgs(
                         warningEvent.Subcategory,
                         warningEvent.Code,
                         warningEvent.File,
@@ -1458,7 +1458,7 @@ private void RouteBuildEvent(object loggingEvent)
                 }
                 else if (ShouldTreatWarningAsError(warningEvent))
                 {
-                    loggingEvent = new BuildErrorEventArgs(
+                    buildEventArgs = new BuildErrorEventArgs(
                         warningEvent.Subcategory,
                         warningEvent.Code,
                         warningEvent.File,
@@ -1477,13 +1477,13 @@ private void RouteBuildEvent(object loggingEvent)
                 }
             }
 
-            if (loggingEvent is BuildErrorEventArgs errorEvent)
+            if (buildEventArgs is BuildErrorEventArgs errorEvent)
             {
                 // Keep track of build submissions that have logged errors.  If there is no build context, add BuildEventContext.InvalidSubmissionId.
                 _buildSubmissionIdsThatHaveLoggedErrors.Add(errorEvent.BuildEventContext?.SubmissionId ?? BuildEventContext.InvalidSubmissionId);
             }
 
-            if (loggingEvent is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
+            if (buildEventArgs is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
             {
                 int key = GetWarningsAsErrorOrMessageKey(projectFinishedEvent);
                 _warningsAsErrorsByProject?.Remove(key);
@@ -1491,12 +1491,18 @@ private void RouteBuildEvent(object loggingEvent)
                 _warningsAsMessagesByProject?.Remove(key);
             }
 
-            if (loggingEvent is BuildEventArgs loggingEventBuildArgs)
+            if (loggingEvent is BuildEventArgs)
             {
-                RouteBuildEvent(loggingEventBuildArgs);
+                RouteBuildEvent(buildEventArgs);
             }
             else if (loggingEvent is KeyValuePair<int, BuildEventArgs> loggingEventKeyValuePair)
             {
+                if (loggingEventKeyValuePair.Value != buildEventArgs)
+                {
+                    // buildEventArgs has been altered, lets use that new one
+                    loggingEventKeyValuePair = new KeyValuePair<int, BuildEventArgs>(loggingEventKeyValuePair.Key, buildEventArgs);
+                }
+
                 RouteBuildEvent(loggingEventKeyValuePair);
             }
         }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
index 3b1a9bb3dca..d2f76b4c577 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
     /// This exception is used to wrap an unhandled exception from a project cache plugin. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    public sealed class ProjectCacheException : Exception
+    public sealed class ProjectCacheException : BuildExceptionBase
     {
         private ProjectCacheException()
         {
@@ -33,6 +34,10 @@ private ProjectCacheException(
             ErrorCode = errorCode;
         }
 
+        internal ProjectCacheException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// The project cache has already logged this as an error.
         /// Should not get logged again.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index fcf7564d228..096c90e5ff9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -185,7 +185,6 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 if (condition)
                 {
                     ExpanderOptions expanderOptions = ExpanderOptions.ExpandAll;
-                    ElementLocation location = metadataInstance.Location;
                     if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) &&
                         // If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
                         bucket.BucketSequenceNumber == 0 &&
@@ -193,11 +192,9 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                         child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
                     {
                         expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
-                        // Temporary workaround of unavailability of full Location info on metadata: https://github.com/dotnet/msbuild/issues/8579
-                        location = child.Location;
                     }
 
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
index 405d0290483..61ba3fabbaf 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -14,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Justification = "No point in adding the serialization constructors since BuildRequest is not serializable")]
     [SuppressMessage("Microsoft.Usage", "CA2237:MarkISerializableTypesWithSerializable", Justification = "No point in marking as ISerializable since BuildRequest is not. ")]
-    internal class SchedulerCircularDependencyException : Exception
+    internal class SchedulerCircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// The ancestors which led to this circular dependency.
@@ -35,6 +36,11 @@ public SchedulerCircularDependencyException(BuildRequest request, IList<Schedula
             _ancestors = ancestors;
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SchedulerCircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Gets an enumeration of the ancestors which led to this circular dependency.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
index bd8af074fb0..656cc7f4aab 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -12,7 +13,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// <summary>
     /// Represents an exception that occurs when an SdkResolver throws an unhandled exception.
     /// </summary>
-    public class SdkResolverException : Exception
+    public class SdkResolverException : BuildExceptionBase
     {
         public SdkResolver Resolver { get; private set; }
 
@@ -24,5 +25,10 @@ public SdkResolverException(string resourceName, SdkResolver resolver, SdkRefere
             Resolver = resolver;
             Sdk = sdk;
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SdkResolverException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index c0c3531ff34..83a74bee7d6 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -144,6 +144,7 @@ public OutOfProcNode()
 
             _componentFactories = new BuildComponentFactoryCollection(this);
             _componentFactories.RegisterDefaultFactories();
+            SerializationContractInitializer.Initialize();
             _packetFactory = new NodePacketFactory();
 
             _buildRequestEngine = (this as IBuildComponentHost).GetComponent(BuildComponentType.RequestEngine) as IBuildRequestEngine;
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index ab5d34af0e4..09f107a93f8 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -21,7 +23,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class BuildAbortedException : Exception
+    public class BuildAbortedException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -49,11 +51,40 @@ public BuildAbortedException(string message)
         /// Constructs a BuildAbortedException with an additional message attached and an inner exception.
         /// </summary>
         public BuildAbortedException(string message, Exception innerException)
-            : base(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message), innerException)
+            : this(message, innerException, false)
+        { }
+
+        internal static BuildAbortedException CreateFromRemote(string message, Exception innerException)
         {
-            ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+            return new BuildAbortedException(message, innerException, true /* calledFromDeserialization */);
+        }
 
-            ErrorCode = errorCode;
+        private BuildAbortedException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message),
+                innerException)
+        {
+            if (!calledFromDeserialization)
+            {
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+
+                ErrorCode = errorCode;
+            }
+        }
+
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(ErrorCode), ErrorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            ErrorCode = state[nameof(ErrorCode)];
         }
 
         /// <summary>
@@ -70,7 +101,7 @@ protected BuildAbortedException(SerializationInfo info, StreamingContext context
         /// Gets the error code (if any) associated with the exception message.
         /// </summary>
         /// <value>Error code string, or null.</value>
-        public string ErrorCode { get; }
+        public string ErrorCode { get; private set; }
 
         /// <summary>
         /// ISerializable method which we must override since Exception implements this interface
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 7fb5d26c006..838210573f6 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -1037,7 +1037,7 @@ private ITranslator GetConfigurationTranslator(TranslationDirection direction)
                 else
                 {
                     // Not using sharedReadBuffer because this is not a memory stream and so the buffer won't be used anyway.
-                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), null);
+                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
                 }
             }
             catch (Exception e) when (e is DirectoryNotFoundException || e is UnauthorizedAccessException)
diff --git a/src/Build/BackEnd/Shared/CircularDependencyException.cs b/src/Build/BackEnd/Shared/CircularDependencyException.cs
index 08cfb2a4783..11ea521d9ed 100644
--- a/src/Build/BackEnd/Shared/CircularDependencyException.cs
+++ b/src/Build/BackEnd/Shared/CircularDependencyException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -16,7 +17,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class CircularDependencyException : Exception
+    public class CircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -30,6 +31,11 @@ internal CircularDependencyException(string message)
         {
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal CircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructor for deserialization.
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 3136450178d..2840148876c 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -327,7 +327,7 @@ private void TranslateItems(ITranslator translator)
                 ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during translation.");
 
                 using MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true);
-                using var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
+                using var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, InterningBinaryReader.PoolingBuffer);
                 _items = new TaskItem[itemsCount];
                 for (int i = 0; i < _items.Length; i++)
                 {
@@ -355,7 +355,7 @@ private static ITranslator GetResultsCacheTranslator(int configId, string target
             }
             else
             {
-                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), null);
+                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
             }
         }
 
diff --git a/src/Build/Collections/ConvertingEnumerable.cs b/src/Build/Collections/ConvertingEnumerable.cs
index b4b3e1d7058..e5933cd53dc 100644
--- a/src/Build/Collections/ConvertingEnumerable.cs
+++ b/src/Build/Collections/ConvertingEnumerable.cs
@@ -82,7 +82,7 @@ internal ConvertingEnumerator(IEnumerator<TFrom2> backingEnumerator, Func<TFrom2
             /// <summary>
             /// Get the current element, converted
             /// </summary>
-            public TTo2 Current
+            public readonly TTo2 Current
             {
                 get
                 {
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index c4c04d802eb..34d1267a234 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
@@ -15,7 +16,7 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <typeparam name="K">Type of key</typeparam>
     /// <typeparam name="V">Type of value, without the WeakReference wrapper.</typeparam>
-    internal class WeakValueDictionary<K, V>
+    internal class WeakValueDictionary<K, V> : IEnumerable<KeyValuePair<K, V>>
         where V : class
     {
         /// <summary>
@@ -233,5 +234,22 @@ public void Clear()
         {
             _dictionary.Clear();
         }
+
+        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
+        {
+            foreach (KeyValuePair<K, WeakReference<V>> kvp in _dictionary)
+            {
+                if (kvp.Value is null)
+                {
+                    yield return new KeyValuePair<K, V>(kvp.Key, null);
+                }
+                else if (kvp.Value.TryGetTarget(out V target))
+                {
+                    yield return new KeyValuePair<K, V>(kvp.Key, target);
+                }
+            }
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
     }
 }
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..eebde973639
--- /dev/null
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -0,0 +1,39 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- Need to suppress due to AppCompat limitation https://github.com/dotnet/sdk/issues/32922	 -->
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.BuildAbortedException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.CircularDependencyException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.InternalLoggerException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.InvalidProjectFileException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.ProjectCache.ProjectCacheException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 4eb8f8edb91..6d8d7a394b6 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -742,7 +742,7 @@ internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards =
             /// <summary>
             /// Get enumerator
             /// </summary>
-            public IEnumerator<ProjectElement> GetEnumerator()
+            public readonly IEnumerator<ProjectElement> GetEnumerator()
             {
                 return _enumerator;
             }
@@ -808,7 +808,7 @@ object System.Collections.IEnumerator.Current
                 /// <summary>
                 /// Dispose. Do nothing.
                 /// </summary>
-                public void Dispose()
+                public readonly void Dispose()
                 {
                 }
 
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index a8ba5cd5c10..473f39c0476 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -100,13 +100,13 @@ public string Value
         /// Creates an unparented ProjectMetadataElement, wrapping an unparented XmlElement.
         /// Caller should then ensure the element is added to a parent.
         /// </summary>
-        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject)
+        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject, ElementLocation location = null)
         {
             XmlUtilities.VerifyThrowArgumentValidElementName(name);
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             ErrorUtilities.VerifyThrowInvalidOperation(!XMakeElements.ReservedItemNames.Contains(name), "CannotModifyReservedItemMetadata", name);
 
-            XmlElementWithLocation element = containingProject.CreateElement(name);
+            XmlElementWithLocation element = containingProject.CreateElement(name, location);
 
             return new ProjectMetadataElement(element, containingProject);
         }
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index b0ff4459c4a..626751e11cf 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1327,13 +1327,22 @@ public ProjectMetadataElement CreateMetadataElement(string name)
         /// Caller must add it to the location of choice in the project.
         /// </summary>
         public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue)
+        {
+            return this.CreateMetadataElement(name, unevaluatedValue, null);
+        }
+
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue, ElementLocation location)
         {
             if (Link != null)
             {
                 return RootLink.CreateMetadataElement(name, unevaluatedValue);
             }
 
-            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this);
+            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this, location);
 
             metadatum.Value = unevaluatedValue;
 
@@ -1785,14 +1794,23 @@ internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDicti
             return projectRootElement;
         }
 
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        internal ProjectMetadataElement CreateMetadataElement(XmlAttributeWithLocation attribute)
+        {
+            return CreateMetadataElement(attribute.Name, attribute.Value, attribute.Location);
+        }
+
         /// <summary>
         /// Creates a XmlElement with the specified name in the document
         /// containing this project.
         /// </summary>
-        internal XmlElementWithLocation CreateElement(string name)
+        internal XmlElementWithLocation CreateElement(string name, ElementLocation location = null)
         {
             ErrorUtilities.VerifyThrow(Link == null, "External project");
-            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace);
+            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace, location);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 1e11e628e65..7b3d3c05b43 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -239,6 +239,23 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
             msbuildProject.AppendChild(solutionConfigurationProperties);
             solutionConfigurationProperties.Condition = GetConditionStringForConfiguration(solutionConfiguration);
 
+            string escapedSolutionConfigurationContents = GetSolutionConfiguration(solutionFile, solutionConfiguration);
+
+            solutionConfigurationProperties.AddProperty("CurrentSolutionConfigurationContents", escapedSolutionConfigurationContents);
+
+            msbuildProject.AddItem(
+                "SolutionConfiguration",
+                solutionConfiguration.FullName,
+                new Dictionary<string, string>
+                {
+                    { "Configuration", solutionConfiguration.ConfigurationName },
+                    { "Platform", solutionConfiguration.PlatformName },
+                    { "Content", escapedSolutionConfigurationContents },
+                });
+        }
+
+        internal static string GetSolutionConfiguration(SolutionFile solutionFile, SolutionConfigurationInSolution solutionConfiguration)
+        {
             var solutionConfigurationContents = new StringBuilder(1024);
             var settings = new XmlWriterSettings
             {
@@ -292,19 +309,8 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
                 xw.WriteEndElement(); // </SolutionConfiguration>
             }
 
-            var escapedSolutionConfigurationContents = EscapingUtilities.Escape(solutionConfigurationContents.ToString());
-
-            solutionConfigurationProperties.AddProperty("CurrentSolutionConfigurationContents", escapedSolutionConfigurationContents);
-
-            msbuildProject.AddItem(
-                "SolutionConfiguration",
-                solutionConfiguration.FullName,
-                new Dictionary<string, string>
-                {
-                    { "Configuration", solutionConfiguration.ConfigurationName },
-                    { "Platform", solutionConfiguration.PlatformName },
-                    { "Content", escapedSolutionConfigurationContents },
-                });
+            string escapedSolutionConfigurationContents = EscapingUtilities.Escape(solutionConfigurationContents.ToString());
+            return escapedSolutionConfigurationContents;
         }
 
         /// <summary>
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 7db7747eea1..106b1ca08ee 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -1809,18 +1809,6 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
-        /// <summary>
-        /// Returns <see cref="IDirectoryCache"/> as provided by the <see cref="IDirectoryCacheFactory"/> passed when creating the
-        /// project, specific for a given evaluation ID.
-        /// </summary>
-        /// <param name="evaluationId">The evaluation ID for which the cache is requested.</param>
-        /// <returns>An <see cref="IDirectoryCache"/> implementation, or null if this project has no <see cref="IDirectoryCacheFactory"/>
-        /// associated with it or it returned null.</returns>
-        internal IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
-        {
-            return _directoryCacheFactory?.GetDirectoryCacheForEvaluation(evaluationId);
-        }
-
         /// <summary>
         /// Internal project evaluation implementation.
         /// </summary>
@@ -2558,7 +2546,7 @@ public static CumulativeRemoveElementData Create()
                     };
                 }
 
-                public void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
+                public readonly void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
                 {
                     IEnumerable<string> removeSpecFragmentStrings = removeSpec.FlattenFragmentsAsStrings();
                     var removeGlob = removeSpec.ToMSBuildGlob();
@@ -3737,6 +3725,7 @@ private void Reevaluate(
                     loggingServiceForEvaluation,
                     new ProjectItemFactory(Owner),
                     ProjectCollection,
+                    Owner._directoryCacheFactory,
                     ProjectCollection.ProjectRootElementCache,
                     s_buildEventContext,
                     evaluationContext.SdkResolverService,
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 1f24703fd5b..f016e922451 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -87,8 +87,8 @@ public class ProjectCollection : IToolsetProvider, IBuildComponent, IDisposable
         /// <remarks>
         /// ProjectCollection is highly reentrant - project creation, toolset and logger changes, and so on
         /// all need lock protection, but there are a lot of read cases as well, and calls to create Projects
-        /// call back to the ProjectCollection under locks. Use a RW lock, but default to always using
-        /// upgradable read locks to avoid adding reentrancy bugs.
+        /// call back to the ProjectCollection under locks. Use a RW lock with recursion support to avoid
+        /// adding reentrancy bugs.
         /// </remarks>
         private readonly ReaderWriterLockSlim _locker = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
 
@@ -508,7 +508,7 @@ public string DefaultToolsVersion
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     ErrorUtilities.VerifyThrow(_defaultToolsVersion != null, "Should have a default");
                     return _defaultToolsVersion;
@@ -558,7 +558,7 @@ public IDictionary<string, string> GlobalProperties
             {
                 Dictionary<string, string> dictionary;
 
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     if (_globalProperties.Count == 0)
                     {
@@ -591,7 +591,7 @@ public int Count
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _loadedProjects.Count;
                 }
@@ -609,7 +609,7 @@ public ICollection<ILogger> Loggers
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _loggingService.Loggers == null
                         ? (ICollection<ILogger>)ReadOnlyEmptyCollection<ILogger>.Instance
@@ -628,7 +628,7 @@ public ICollection<Toolset> Toolsets
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return new List<Toolset>(_toolsets.Values);
                 }
@@ -650,7 +650,7 @@ public bool IsBuildEnabled
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _isBuildEnabled;
                 }
@@ -683,7 +683,7 @@ public bool OnlyLogCriticalEvents
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _onlyLogCriticalEvents;
                 }
@@ -720,17 +720,20 @@ public HostServices HostServices
             get
             {
                 // Avoid write lock if possible, this getter is called a lot during Project construction.
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     if (_hostServices != null)
                     {
                         return _hostServices;
                     }
-
-                    using (_locker.EnterDisposableWriteLock())
+                }
+                using (_locker.EnterDisposableWriteLock())
+                {
+                    if (_hostServices == null)
                     {
-                        return _hostServices ?? (_hostServices = new HostServices());
+                        _hostServices = new HostServices();
                     }
+                    return _hostServices;
                 }
             }
 
@@ -763,7 +766,7 @@ public bool SkipEvaluation
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _skipEvaluation;
                 }
@@ -799,7 +802,7 @@ public bool DisableMarkDirty
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _disableMarkDirty;
                 }
@@ -849,7 +852,7 @@ internal ILoggingService LoggingService
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _loggingService;
                 }
@@ -867,7 +870,7 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
             {
                 var clone = new PropertyDictionary<ProjectPropertyInstance>();
 
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     foreach (ProjectPropertyInstance property in _globalProperties)
                     {
@@ -886,23 +889,24 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                // Retrieves the environment properties.
+                // This is only done once, when the project collection is created. Any subsequent
+                // environment changes will be ignored. Child nodes will be passed this set
+                // of properties in their build parameters.
+                using (_locker.EnterDisposableReadLock())
                 {
-                    // Retrieves the environment properties.
-                    // This is only done once, when the project collection is created. Any subsequent
-                    // environment changes will be ignored. Child nodes will be passed this set
-                    // of properties in their build parameters.
-                    if (_environmentProperties == null)
+                    if (_environmentProperties != null)
                     {
-                        using (_locker.EnterDisposableWriteLock())
-                        {
-                            if (_environmentProperties == null)
-                            {
-                                _environmentProperties = Utilities.GetEnvironmentProperties();
-                            }
-                        }
+                        return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
                     }
+                }
 
+                using (_locker.EnterDisposableWriteLock())
+                {
+                    if (_environmentProperties == null)
+                    {
+                        _environmentProperties = Utilities.GetEnvironmentProperties();
+                    }
                     return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
                 }
             }
@@ -917,7 +921,7 @@ internal int ToolsetsVersion
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _toolsetsVersion;
                 }
@@ -931,7 +935,7 @@ internal int MaxNodeCount
         {
             get
             {
-                using (_locker.EnterDisposableUpgradeableReadLock())
+                using (_locker.EnterDisposableReadLock())
                 {
                     return _maxNodeCount;
                 }
@@ -1419,7 +1423,7 @@ public void UnloadAllProjects()
         /// </summary>
         public ProjectPropertyInstance GetGlobalProperty(string name)
         {
-            using (_locker.EnterDisposableUpgradeableReadLock())
+            using (_locker.EnterDisposableReadLock())
             {
                 return _globalProperties[name];
             }
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 9c064f5e68f..d7d81e88dc6 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -817,7 +817,7 @@ private MSBuildExtensionsPathReferenceKind(string value)
         /// <summary>
         /// Returns the corresponding property name - eg. "$(MSBuildExtensionsPath32)"
         /// </summary>
-        public string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
+        public readonly string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
 
         /// <summary>
         /// Tries to find a reference to MSBuildExtensionsPath* property in the given string
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index bbc34c86a57..88b0de71dbb 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Threading;
 using System.Xml;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -59,6 +60,13 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// </summary>
         private bool? _loadAsReadOnly;
 
+        /// <summary>
+        /// Location of the element to be created via 'CreateElement' call. So that we can
+        ///  receive and use location from the caller up the stack even if we are being called via
+        /// <see cref="XmlDocument"/> internal methods.
+        /// </summary>
+        private readonly AsyncLocal<ElementLocation> _elementLocation = new AsyncLocal<ElementLocation>();
+
         /// <summary>
         /// Constructor
         /// </summary>
@@ -180,6 +188,31 @@ public override void Load(string fullPath)
             }
         }
 
+        /// <summary>
+        /// Called during parse, to add an element.
+        /// </summary>
+        /// <remarks>
+        /// We create our own kind of element, that we can give location information to.
+        /// In order to pass the location through the callchain, that contains XmlDocument function
+        ///  that then calls back to our XmlDocumentWithLocation (so we cannot use call stack via passing via parameters),
+        ///  we use async local field, that simulates variable on call stack.
+        /// </remarks>
+        internal XmlElement CreateElement(string localName, string namespaceURI, ElementLocation location)
+        {
+            if (location != null)
+            {
+                this._elementLocation.Value = location;
+            }
+            try
+            {
+                return CreateElement(localName, namespaceURI);
+            }
+            finally
+            {
+                this._elementLocation.Value = null;
+            }
+        }
+
         /// <summary>
         /// Called during load, to add an element.
         /// </summary>
@@ -192,6 +225,10 @@ public override XmlElement CreateElement(string prefix, string localName, string
             {
                 return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _reader.LineNumber, _reader.LinePosition);
             }
+            else if (_elementLocation?.Value != null)
+            {
+                return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _elementLocation.Value.Line, _elementLocation.Value.Column);
+            }
 
             // Must be a subsequent edit; we can't provide location information
             return new XmlElementWithLocation(prefix, localName, namespaceURI, this);
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 06daa610cd9..74fbd3dfb6f 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -9,6 +9,8 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
+using System.Collections.Generic;
 
 #nullable disable
 
@@ -22,7 +24,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InternalLoggerException : Exception
+    public sealed class InternalLoggerException : BuildExceptionBase
     {
         #region Unusable constructors
 
@@ -63,9 +65,7 @@ public InternalLoggerException(string message)
         /// <exception cref="InvalidOperationException"></exception>
         public InternalLoggerException(string message, Exception innerException)
             : base(message, innerException)
-        {
-            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
-        }
+        { }
 
         #endregion
 
@@ -136,6 +136,23 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("initializationException", initializationException);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(initializationException), initializationException.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            initializationException = bool.Parse(state[nameof(initializationException)]);
+        }
+
         /// <summary>
         /// Provide default values for optional members
         /// </summary>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 71c7d93d2cc..8a15be32d42 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -3,10 +3,11 @@
 
 using System;
 using System.Runtime.Serialization;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
-
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -21,7 +22,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InvalidProjectFileException : Exception
+    public sealed class InvalidProjectFileException : BuildExceptionBase
     {
         #region Basic constructors
 
@@ -122,6 +123,35 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("hasBeenLogged", hasBeenLogged);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(file), file },
+                { nameof(lineNumber), lineNumber.ToString() },
+                { nameof(columnNumber), columnNumber.ToString() },
+                { nameof(endLineNumber), endLineNumber.ToString() },
+                { nameof(endColumnNumber), endColumnNumber.ToString() },
+                { nameof(errorSubcategory), errorSubcategory },
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(hasBeenLogged), hasBeenLogged.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            file = state[nameof(file)];
+            lineNumber = int.Parse(state[nameof(lineNumber)]);
+            columnNumber = int.Parse(state[nameof(columnNumber)]);
+            endLineNumber = int.Parse(state[nameof(endLineNumber)]);
+            endColumnNumber = int.Parse(state[nameof(endColumnNumber)]);
+            errorSubcategory = state[nameof(errorSubcategory)];
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            hasBeenLogged = bool.Parse(state[nameof(hasBeenLogged)]);
+        }
+
         #endregion
 
         #region Rich constructors
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 9f7c51e0b61..be588b6e061 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -1,10 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
+using System;
 using System.Runtime.Serialization;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -17,7 +18,7 @@ namespace Microsoft.Build.Exceptions
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
     [Serializable]
-    public class InvalidToolsetDefinitionException : Exception
+    public class InvalidToolsetDefinitionException : BuildExceptionBase
     {
         /// <summary>
         /// The MSBuild error code corresponding with this exception.
@@ -103,6 +104,19 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("errorCode", errorCode);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+        }
+
         /// <summary>
         /// The MSBuild error code corresponding with this exception, or
         /// null if none was specified.
diff --git a/src/Build/Errors/RegistryException.cs b/src/Build/Errors/RegistryException.cs
index 13d4335634d..e3aee195277 100644
--- a/src/Build/Errors/RegistryException.cs
+++ b/src/Build/Errors/RegistryException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Exceptions
     /// Generic exception used to wrap exceptions thrown during Registry access.
     /// </summary>
     [Serializable]
-    internal class RegistryException : Exception
+    internal class RegistryException : BuildExceptionBase
     {
         /// <summary>
         /// Basic constructor.
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 3ff00696595..aeb2bc7414e 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -4,26 +4,20 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
 using System.Threading;
 
-#nullable disable
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using BuildEventContext = Microsoft.Build.Framework.BuildEventContext;
+using ElementLocation = Microsoft.Build.Construction.ElementLocation;
+using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
+using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 namespace Microsoft.Build.Evaluation
 {
-    using Microsoft.Build.BackEnd.Logging;
-    using Microsoft.Build.Shared;
-    using Microsoft.Build.Shared.FileSystem;
-    using BuildEventContext = Microsoft.Build.Framework.BuildEventContext;
-    using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-    using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
-    using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-
     internal static class ConditionEvaluator
     {
-        private static readonly Lazy<Regex> s_singlePropertyRegex = new Lazy<Regex>(
-            () => new Regex(@"^\$\(([^\$\(\)]*)\)$", RegexOptions.Compiled));
-
         /// <summary>
         /// Update our table which keeps track of all the properties that are referenced
         /// inside of a condition and the string values that they are being tested against.
@@ -61,9 +55,7 @@ internal static void UpdateConditionedPropertiesTable(
                     var lastPiece = pieceSeparator < 0;
                     var pieceEnd = lastPiece ? leftValue.Length : pieceSeparator;
 
-                    var singlePropertyMatch = s_singlePropertyRegex.Value.Match(leftValue, pieceStart, pieceEnd - pieceStart);
-
-                    if (singlePropertyMatch.Success)
+                    if (TryGetSingleProperty(leftValue.AsSpan(), pieceStart, pieceEnd - pieceStart, out ReadOnlySpan<char> propertyName))
                     {
                         // Find the first vertical bar on the right-hand-side expression.
                         var indexOfVerticalBar = rightValueExpanded.IndexOf('|');
@@ -88,18 +80,13 @@ internal static void UpdateConditionedPropertiesTable(
                             rightValueExpanded = rightValueExpanded.Substring(indexOfVerticalBar + 1);
                         }
 
-                        // Capture the property name out of the regular expression.
-                        var propertyName = singlePropertyMatch.Groups[1].ToString();
-
                         // Get the string collection for this property name, if one already exists.
-                        List<string> conditionedPropertyValues;
-
-                        // If this property is not already represented in the table, add a new entry
-                        // for it.
-                        if (!conditionedPropertiesTable.TryGetValue(propertyName, out conditionedPropertyValues))
+                        // If not already in the table, add a new entry for it.
+                        string propertyNameString = propertyName.ToString();
+                        if (!conditionedPropertiesTable.TryGetValue(propertyNameString, out List<string>? conditionedPropertyValues))
                         {
                             conditionedPropertyValues = new List<string>();
-                            conditionedPropertiesTable[propertyName] = conditionedPropertyValues;
+                            conditionedPropertiesTable[propertyNameString] = conditionedPropertyValues;
                         }
 
                         // If the "rightValueExpanded" is not already in the string collection
@@ -120,6 +107,32 @@ internal static void UpdateConditionedPropertiesTable(
             }
         }
 
+        // Internal for testing purposes
+        internal static bool TryGetSingleProperty(ReadOnlySpan<char> input, int beginning, int length, out ReadOnlySpan<char> propertyName)
+        {
+            // This code is simulating the regex pattern: ^\$\(([^\$\(\)]*)\)$
+            if (input.Length < beginning + 3 ||
+                input[beginning] != '$' ||
+                input[beginning + 1] != '(' ||
+                input[beginning + length - 1] != ')' ||
+                ContainsInvalidCharacter(input.Slice(beginning + 2, length - 3)))
+            {
+                propertyName = null;
+                return false;
+            }
+
+            propertyName = input.Slice(beginning + 2, length - 3);
+            return true;
+
+            static bool ContainsInvalidCharacter(ReadOnlySpan<char> span)
+            {
+                return
+                    span.IndexOf('$') != -1 ||
+                    span.IndexOf('(') != -1 ||
+                    span.IndexOf(')') != -1;
+            }
+        }
+
         // Implements a pool of expression trees for each condition.
         // This is because an expression tree is a mutually exclusive resource (has non thread safe state while it evaluates).
         // During high demand when all expression trees are busy evaluating, a new expression tree is created and added to the pool.
@@ -130,11 +143,11 @@ private struct ExpressionTreeForCurrentOptionsWithSize
             private readonly ConcurrentDictionary<string, ConcurrentStack<GenericExpressionNode>> _conditionPools;
             private int _mOptimisticSize;
 
-            public int OptimisticSize => _mOptimisticSize;
+            public readonly int OptimisticSize => _mOptimisticSize;
 
             public ExpressionTreeForCurrentOptionsWithSize(ConcurrentDictionary<string, ConcurrentStack<GenericExpressionNode>> conditionPools)
             {
-                this._conditionPools = conditionPools;
+                _conditionPools = conditionPools;
                 _mOptimisticSize = conditionPools.Count;
             }
 
@@ -176,8 +189,8 @@ internal static bool EvaluateCondition<P, I>(
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null)
+            ProjectRootElementCacheBase? projectRootElementCache = null,
+            LoggingContext? loggingContext = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -186,7 +199,7 @@ internal static bool EvaluateCondition<P, I>(
                 options,
                 expander,
                 expanderOptions,
-                null /* do not collect conditioned properties */,
+                conditionedPropertiesTable: null /* do not collect conditioned properties */,
                 evaluationDirectory,
                 elementLocation,
                 loggingServices,
@@ -208,14 +221,14 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
             ParserOptions options,
             Expander<P, I> expander,
             ExpanderOptions expanderOptions,
-            Dictionary<string, List<string>> conditionedPropertiesTable,
+            Dictionary<string, List<string>>? conditionedPropertiesTable,
             string evaluationDirectory,
             ElementLocation elementLocation,
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null)
+            ProjectRootElementCacheBase? projectRootElementCache = null,
+            LoggingContext? loggingContext = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -343,13 +356,13 @@ internal interface IConditionEvaluationState
             ///     If this is null, as it is for command line builds, conditioned properties
             ///     are not recorded.
             /// </summary>
-            Dictionary<string, List<string>> ConditionedPropertiesInProject { get; }
+            Dictionary<string, List<string>>? ConditionedPropertiesInProject { get; }
 
             /// <summary>
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -359,12 +372,12 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoString(string expression, LoggingContext? loggingContext = null);
 
             /// <summary>
             ///     PRE cache
             /// </summary>
-            ProjectRootElementCacheBase LoadedProjectsCache { get; }
+            ProjectRootElementCacheBase? LoadedProjectsCache { get; }
 
             IFileSystem FileSystem { get; }
         }
@@ -398,22 +411,22 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
             /// If this is null, as it is for command line builds, conditioned properties
             /// are not recorded.
             /// </summary>
-            public Dictionary<string, List<string>> ConditionedPropertiesInProject { get; }
+            public Dictionary<string, List<string>>? ConditionedPropertiesInProject { get; }
 
             /// <summary>
             /// PRE collection. 
             /// </summary>
-            public ProjectRootElementCacheBase LoadedProjectsCache { get; }
+            public ProjectRootElementCacheBase? LoadedProjectsCache { get; }
 
             internal ConditionEvaluationState(
                 string condition,
                 Expander<P, I> expander,
                 ExpanderOptions expanderOptions,
-                Dictionary<string, List<string>> conditionedPropertiesInProject,
+                Dictionary<string, List<string>>? conditionedPropertiesInProject,
                 string evaluationDirectory,
                 ElementLocation elementLocation,
                 IFileSystem fileSystem,
-                ProjectRootElementCacheBase projectRootElementCache = null)
+                ProjectRootElementCacheBase? projectRootElementCache = null)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
                 ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
@@ -434,7 +447,7 @@ internal ConditionEvaluationState(
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
@@ -467,7 +480,7 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// <param name="expression">The expression to expand.</param>
             /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoString(string expression, LoggingContext? loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 35097b0aeda..a5b3be796b7 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -202,6 +202,7 @@ private Evaluator(
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
+            IDirectoryCacheFactory directoryCacheFactory,
             ProjectRootElementCacheBase projectRootElementCache,
             ISdkResolverService sdkResolverService,
             int submissionId,
@@ -231,7 +232,7 @@ private Evaluator(
 
             // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
             _evaluationContext = evaluationContext;
-            IDirectoryCache directoryCache = project?.GetDirectoryCacheForEvaluation(_evaluationLoggingContext.BuildEventContext.EvaluationId);
+            IDirectoryCache directoryCache = directoryCacheFactory?.GetDirectoryCacheForEvaluation(_evaluationLoggingContext.BuildEventContext.EvaluationId);
             if (directoryCache is not null)
             {
                 IFileSystem fileSystem = new DirectoryCacheFileSystemWrapper(evaluationContext.FileSystem, directoryCache);
@@ -308,6 +309,7 @@ internal static void Evaluate(
             ILoggingService loggingService,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
+            IDirectoryCacheFactory directoryCacheFactory,
             ProjectRootElementCacheBase projectRootElementCache,
             BuildEventContext buildEventContext,
             ISdkResolverService sdkResolverService,
@@ -326,6 +328,7 @@ internal static void Evaluate(
                 environmentProperties,
                 itemFactory,
                 toolsetProvider,
+                directoryCacheFactory,
                 projectRootElementCache,
                 sdkResolverService,
                 submissionId,
@@ -1313,12 +1316,12 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 {
                     // Is the property we are currently setting in the list of properties which have been used but not initialized
                     IElementLocation elementWhichUsedProperty;
-                    bool isPropertyInList = _expander.UsedUninitializedProperties.Properties.TryGetValue(propertyElement.Name, out elementWhichUsedProperty);
+                    bool isPropertyInList = _expander.UsedUninitializedProperties.TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
 
                     if (isPropertyInList)
                     {
                         // Once we are going to warn for a property once, remove it from the list so we do not add it again.
-                        _expander.UsedUninitializedProperties.Properties.Remove(propertyElement.Name);
+                        _expander.UsedUninitializedProperties.RemoveProperty(propertyElement.Name);
                         _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty.LocationString);
                     }
                 }
diff --git a/src/Build/Evaluation/EvaluatorMetadataTable.cs b/src/Build/Evaluation/EvaluatorMetadataTable.cs
index d48f458465c..6405834f994 100644
--- a/src/Build/Evaluation/EvaluatorMetadataTable.cs
+++ b/src/Build/Evaluation/EvaluatorMetadataTable.cs
@@ -8,8 +8,6 @@
 using Microsoft.Build.Construction;
 using EscapingUtilities = Microsoft.Build.Shared.EscapingUtilities;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -22,19 +20,25 @@ internal class EvaluatorMetadataTable : IMetadataTable
         /// <summary>
         /// The actual metadata dictionary.
         /// </summary>
-        private Dictionary<string, EvaluatorMetadata> _metadata;
+        private Dictionary<string, EvaluatorMetadata>? _metadata;
 
         /// <summary>
         /// The type of item the metadata should be considered to apply to.
         /// </summary>
         private string _implicitItemType;
 
+        /// <summary>
+        /// The expected number of metadata entries in this table.
+        /// </summary>
+        private readonly int _capacity;
+
         /// <summary>
         /// Creates a new table using the specified item type.
         /// </summary>
-        public EvaluatorMetadataTable(string implicitItemType)
+        public EvaluatorMetadataTable(string implicitItemType, int capacity = 0)
         {
             _implicitItemType = implicitItemType;
+            _capacity = capacity;
         }
 
         /// <summary>
@@ -56,7 +60,7 @@ public string GetEscapedValue(string name)
         /// Retrieves any value we have in our metadata table for the metadata name and item type specified.
         /// If no value is available, returns empty string.
         /// </summary>
-        public string GetEscapedValue(string itemType, string name)
+        public string GetEscapedValue(string? itemType, string name)
         {
             return GetEscapedValueIfPresent(itemType, name) ?? String.Empty;
         }
@@ -65,21 +69,18 @@ public string GetEscapedValue(string itemType, string name)
         /// Retrieves any value we have in our metadata table for the metadata name and item type specified.
         /// If no value is available, returns null.
         /// </summary>
-        public string GetEscapedValueIfPresent(string itemType, string name)
+        public string? GetEscapedValueIfPresent(string? itemType, string name)
         {
             if (_metadata == null)
             {
                 return null;
             }
 
-            string value = null;
+            string? value = null;
 
             if (itemType == null || String.Equals(_implicitItemType, itemType, StringComparison.OrdinalIgnoreCase))
             {
-                EvaluatorMetadata metadatum;
-                _metadata.TryGetValue(name, out metadatum);
-
-                if (metadatum != null)
+                if (_metadata.TryGetValue(name, out EvaluatorMetadata? metadatum))
                 {
                     value = metadatum.EvaluatedValueEscaped;
                 }
@@ -95,7 +96,7 @@ internal void SetValue(ProjectMetadataElement xml, string evaluatedValueEscaped)
         {
             if (_metadata == null)
             {
-                _metadata = new Dictionary<string, EvaluatorMetadata>(MSBuildNameIgnoreCaseComparer.Default);
+                _metadata = new Dictionary<string, EvaluatorMetadata>(_capacity, MSBuildNameIgnoreCaseComparer.Default);
             }
 
             _metadata[xml.Name] = new EvaluatorMetadata(xml, evaluatedValueEscaped);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index d08d97b9588..6a0a4ffa731 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -210,7 +210,7 @@ public void Add(ReadOnlyMemory<char> span)
             /// concatenation of the string representation of the values, each additionally subjected
             /// to file path adjustment.
             /// </returns>
-            public object GetResult()
+            public readonly object GetResult()
             {
                 CheckDisposed();
                 if (_firstObject != null)
@@ -235,7 +235,7 @@ public void Dispose()
             /// <summary>
             /// Throws <see cref="ObjectDisposedException"/> if this concatenator is already disposed.
             /// </summary>
-            private void CheckDisposed() =>
+            private readonly void CheckDisposed() =>
                 ErrorUtilities.VerifyThrowObjectDisposed(!_disposed, nameof(SpanBasedConcatenator));
 
             /// <summary>
@@ -1521,18 +1521,16 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                     // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
                     // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
                     //
-                    // Another pattern used is where a property concatonates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
+                    // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
                     // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
                     if (usedUninitializedProperties.Warn && usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName != null)
                     {
                         // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
                         if (!MSBuildNameIgnoreCaseComparer.Default.Equals(usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
                         {
-                            string propertyTrimed = propertyName.Substring(startIndex, endIndex - startIndex + 1);
-                            if (!usedUninitializedProperties.Properties.ContainsKey(propertyTrimed))
-                            {
-                                usedUninitializedProperties.Properties.Add(propertyTrimed, elementLocation);
-                            }
+                            usedUninitializedProperties.TryAdd(
+                                propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
+                                elementLocation);
                         }
                     }
 
@@ -2583,12 +2581,9 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                             {
                                 metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                             }
-                            catch (ArgumentException ex) // Blank metadata name
-                            {
-                                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
-                            }
-                            catch (InvalidOperationException ex)
+                            catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                             {
+                                // Blank metadata name
                                 ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                             }
 
@@ -2788,12 +2783,9 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                         {
                             metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                         }
-                        catch (ArgumentException ex) // Blank metadata name
-                        {
-                            ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
-                        }
-                        catch (InvalidOperationException ex)
+                        catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                         {
+                            // Blank metadata name
                             ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                         }
 
@@ -2826,16 +2818,46 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                         {
                             metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                         }
-                        catch (ArgumentException ex) // Blank metadata name
+                        catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                         {
+                            // Blank metadata name
                             ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                         }
-                        catch (InvalidOperationException ex)
+
+                        if (metadataValue != null && String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
+                            // return a result through the enumerator
+                            yield return new Pair<string, S>(item.Key, item.Value);
+                        }
+                    }
+                }
+
+                /// <summary>
+                /// Intrinsic function that returns those items don't have the given metadata value
+                /// Using a case insensitive comparison.
+                /// </summary>
+                internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                {
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
+
+                    string metadataName = arguments[0];
+                    string metadataValueToFind = arguments[1];
+
+                    foreach (Pair<string, S> item in itemsOfType)
+                    {
+                        string metadataValue = null;
+
+                        try
+                        {
+                            metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
+                        }
+                        catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
+                        {
+                            // Blank metadata name
                             ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                         }
 
-                        if (metadataValue != null && String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
+                        if (!String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
                             yield return new Pair<string, S>(item.Key, item.Value);
@@ -2865,12 +2887,9 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                             {
                                 metadataValue = item.Value.GetMetadataValueEscaped(metadataName);
                             }
-                            catch (ArgumentException ex) // Blank metadata name
-                            {
-                                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
-                            }
-                            catch (InvalidOperationException ex)
+                            catch (Exception ex) when (ex is ArgumentException || ex is InvalidOperationException)
                             {
+                                // Blank metadata name
                                 ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotEvaluateItemMetadata", metadataName, ex.Message);
                             }
 
@@ -3142,7 +3161,7 @@ private struct FunctionBuilder<T>
             /// </summary>
             public UsedUninitializedProperties UsedUninitializedProperties { get; set; }
 
-            internal Function<T> Build()
+            internal readonly Function<T> Build()
             {
                 return new Function<T>(
                     ReceiverType,
@@ -4707,7 +4726,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
                     return null;
                 }
 
-                // Check if the type is in the whitelist cache. If it is, use it or load it.
+                // Check if the type is in the allowlist cache. If it is, use it or load it.
                 cachedTypeInformation = AvailableStaticMethods.GetTypeInformationFromTypeCache(typeName, simpleMethodName);
                 if (cachedTypeInformation != null)
                 {
@@ -4730,7 +4749,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
 
                         // If the type information from the cache is not loadable, it means the cache information got corrupted somehow
                         // Throw here to prevent adding null types in the cache
-                        ErrorUtilities.VerifyThrowInternalNull(receiverType, $"Type information for {typeName} was present in the whitelist cache as {assemblyQualifiedTypeName} but the type could not be loaded.");
+                        ErrorUtilities.VerifyThrowInternalNull(receiverType, $"Type information for {typeName} was present in the allowlist cache as {assemblyQualifiedTypeName} but the type could not be loaded.");
 
                         // If we've used it once, chances are that we'll be using it again
                         // We can record the type here since we know it's available for calling from the fact that is was in the AvailableStaticMethods table
@@ -4748,7 +4767,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
                     // DO NOT CACHE THE TYPE HERE!
                     // We don't add the resolved type here in the AvailableStaticMethods table. This is because that table is used
                     // during function parse, but only later during execution do we check for the ability to call specific methods on specific types.
-                    // Caching it here would load any type into the white list.
+                    // Caching it here would load any type into the allow list.
                     return receiverType;
                 }
 
@@ -5151,7 +5170,7 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
             }
 
             /// <summary>
-            /// Check the property function whitelist whether this method is available.
+            /// Check the property function allowlist whether this method is available.
             /// </summary>
             private static bool IsStaticMethodAvailable(Type receiverType, string methodName)
             {
@@ -5279,26 +5298,45 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
         }
     }
 
+#nullable enable
     /// <summary>
     /// This class wraps information about properties which have been used before they are initialized.
     /// </summary>
-    internal class UsedUninitializedProperties
+    internal sealed class UsedUninitializedProperties
     {
         /// <summary>
-        /// This class wraps information about properties which have been used before they are initialized.
+        /// Lazily allocated collection of properties and the element which used them.
         /// </summary>
-        internal UsedUninitializedProperties()
+        private Dictionary<string, IElementLocation>? _properties;
+
+        internal void TryAdd(string propertyName, IElementLocation elementLocation)
         {
-            Properties = new Dictionary<string, IElementLocation>(StringComparer.OrdinalIgnoreCase);
+            if (_properties is null)
+            {
+                _properties = new(StringComparer.OrdinalIgnoreCase);
+            }
+            else if (_properties.ContainsKey(propertyName))
+            {
+                return;
+            }
+
+            _properties.Add(propertyName, elementLocation);
         }
 
-        /// <summary>
-        /// Hash set of properties which have been used before being initialized.
-        /// </summary>
-        internal IDictionary<string, IElementLocation> Properties
+        internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
         {
-            get;
-            set;
+            if (_properties is null)
+            {
+                elementLocation = null;
+                return false;
+            }
+
+            return _properties.TryGetValue(propertyName, out elementLocation);
+        }
+
+        internal void RemoveProperty(string propertyName)
+        {
+            _properties?.Remove(propertyName);
         }
 
         /// <summary>
@@ -5313,7 +5351,7 @@ internal bool Warn
         /// <summary>
         ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
         /// </summary>
-        internal string CurrentlyEvaluatingPropertyElementName
+        internal string? CurrentlyEvaluatingPropertyElementName
         {
             get;
             set;
diff --git a/src/Build/Evaluation/IItem.cs b/src/Build/Evaluation/IItem.cs
index 1365978c41d..4483fb437e7 100644
--- a/src/Build/Evaluation/IItem.cs
+++ b/src/Build/Evaluation/IItem.cs
@@ -39,7 +39,7 @@ string ProjectDirectory
 
         /// <summary>
         /// Returns the metadata with the specified key.
-        /// Returns null if it does not exist.
+        /// Returns an empty string if it does not exist.
         /// Attempting to get built-in metadata on a value that is not a valid path throws InvalidOperationException.
         /// Metadata value is unescaped.
         /// </summary>
@@ -47,7 +47,7 @@ string ProjectDirectory
 
         /// <summary>
         /// Returns the metadata with the specified key.
-        /// Returns null if it does not exist.
+        /// Returns an empty string if it does not exist.
         /// Attempting to get built-in metadata on a value that is not a valid path throws InvalidOperationException.
         /// Metadata value is the escaped value initially set.
         /// </summary>
diff --git a/src/Build/Evaluation/IMetadataTable.cs b/src/Build/Evaluation/IMetadataTable.cs
index e7c20680216..85a5505cefc 100644
--- a/src/Build/Evaluation/IMetadataTable.cs
+++ b/src/Build/Evaluation/IMetadataTable.cs
@@ -1,8 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -21,12 +19,12 @@ internal interface IMetadataTable
         /// If item type is null, it is ignored.
         /// If no value is available, returns empty string.
         /// </summary>
-        string GetEscapedValue(string itemType, string name);
+        string GetEscapedValue(string? itemType, string name);
 
         /// <summary>
         /// Returns the value if it exists, null otherwise.
         /// If item type is null, it is ignored.
         /// </summary>
-        string GetEscapedValueIfPresent(string itemType, string name);
+        string? GetEscapedValueIfPresent(string? itemType, string name);
     }
 }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 89b2ffd1938..c45edf0764b 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -80,7 +80,7 @@ public ItemExpressionFragment(
 
             public override int MatchCount(string itemToMatch)
             {
-                return ReferencedItems.Count(v => v.ItemAsValueFragment.MatchCount(itemToMatch) > 0);
+                return ReferencedItems.Count(v => v.ItemAsValueFragment.IsMatch(itemToMatch));
             }
 
             public override bool IsMatch(string itemToMatch)
diff --git a/src/Build/Evaluation/ItemsAndMetadataPair.cs b/src/Build/Evaluation/ItemsAndMetadataPair.cs
index 3348d1b1662..9ff1f7c3354 100644
--- a/src/Build/Evaluation/ItemsAndMetadataPair.cs
+++ b/src/Build/Evaluation/ItemsAndMetadataPair.cs
@@ -40,7 +40,7 @@ internal ItemsAndMetadataPair(HashSet<string> items, Dictionary<string, Metadata
         /// </summary>
         internal HashSet<string> Items
         {
-            get
+            readonly get
             {
                 return _items;
             }
@@ -58,7 +58,7 @@ internal HashSet<string> Items
         /// </summary>
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get
+            readonly get
             {
                 return _metadata;
             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 6bda7df146c..74e43ce6c93 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Immutable;
+
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
@@ -19,13 +21,13 @@ internal partial class LazyItemEvaluator<P, I, M, D>
     {
         private class EvaluatorData : IEvaluatorData<P, I, M, D>
         {
-            private IEvaluatorData<P, I, M, D> _wrappedData;
-            private Func<string, ICollection<I>> _itemGetter;
+            private readonly IEvaluatorData<P, I, M, D> _wrappedData;
+            private readonly IReadOnlyDictionary<string, LazyItemList> _itemsByType;
 
-            public EvaluatorData(IEvaluatorData<P, I, M, D> wrappedData, Func<string, ICollection<I>> itemGetter)
+            public EvaluatorData(IEvaluatorData<P, I, M, D> wrappedData, IReadOnlyDictionary<string, LazyItemList> itemsByType)
             {
                 _wrappedData = wrappedData;
-                _itemGetter = itemGetter;
+                _itemsByType = itemsByType;
             }
 
             public ItemDictionary<I> Items
@@ -46,10 +48,11 @@ public List<ProjectItemElement> EvaluatedItemElements
 
             public ICollection<I> GetItems(string itemType)
             {
-                return _itemGetter(itemType);
+                return _itemsByType.TryGetValue(itemType, out LazyItemList items)
+                    ? items.GetMatchedItems(globsToIgnore: ImmutableHashSet<string>.Empty)
+                    : Array.Empty<I>();
             }
 
-
             public IDictionary<string, List<TargetSpecification>> AfterTargets
             {
                 get
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index f35b4cc322a..6adca4bf208 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -12,8 +12,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.CodeAnalysis.Collections;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     internal partial class LazyItemEvaluator<P, I, M, D>
@@ -21,9 +19,9 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         private class IncludeOperation : LazyItemOperation
         {
             private readonly int _elementOrder;
-            private readonly string _rootDirectory;
+            private readonly string? _rootDirectory;
             private readonly ImmutableSegmentedList<string> _excludes;
-            private readonly ImmutableList<ProjectMetadataElement> _metadata;
+            private readonly ImmutableArray<ProjectMetadataElement> _metadata;
 
             public IncludeOperation(IncludeOperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
                 : base(builder, lazyEvaluator)
@@ -35,11 +33,11 @@ public IncludeOperation(IncludeOperationBuilder builder, LazyItemEvaluator<P, I,
                 _metadata = builder.Metadata.ToImmutable();
             }
 
-            protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
-                var itemsToAdd = ImmutableList.CreateBuilder<I>();
+                ImmutableArray<I>.Builder? itemsToAdd = null;
 
-                Lazy<Func<string, bool>> excludeTester = null;
+                Lazy<Func<string, bool>>? excludeTester = null;
                 ImmutableList<string>.Builder excludePatterns = ImmutableList.CreateBuilder<string>();
                 if (_excludes != null)
                 {
@@ -57,7 +55,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                     }
                 }
 
-                ISet<string> excludePatternsForGlobs = null;
+                ISet<string>? excludePatternsForGlobs = null;
 
                 foreach (var fragment in _itemSpec.Fragments)
                 {
@@ -73,6 +71,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                             isTransformExpression: out _,
                             elementLocation: _itemElement.IncludeLocation);
 
+                        itemsToAdd ??= ImmutableArray.CreateBuilder<I>();
                         itemsToAdd.AddRange(
                             excludeTester != null
                                 ? itemsFromExpression.Where(item => !excludeTester.Value(item.EvaluatedInclude))
@@ -84,8 +83,8 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
 
                         if (excludeTester?.Value(EscapingUtilities.UnescapeAll(value)) != true)
                         {
-                            var item = _itemFactory.CreateItem(value, value, _itemElement.ContainingProject.FullPath);
-                            itemsToAdd.Add(item);
+                            itemsToAdd ??= ImmutableArray.CreateBuilder<I>();
+                            itemsToAdd.Add(_itemFactory.CreateItem(value, value, _itemElement.ContainingProject.FullPath));
                         }
                     }
                     else if (fragment is GlobFragment globFragment)
@@ -127,6 +126,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
 
                             foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
                             {
+                                itemsToAdd ??= ImmutableArray.CreateBuilder<I>();
                                 itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
                             }
                         }
@@ -137,7 +137,7 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                     }
                 }
 
-                return itemsToAdd.ToImmutable();
+                return itemsToAdd?.ToImmutable() ?? ImmutableArray<I>.Empty;
             }
 
             private static ISet<string> BuildExcludePatternsForGlobs(ImmutableHashSet<string> globsToIgnore, ImmutableList<string>.Builder excludePatterns)
@@ -153,12 +153,12 @@ private static ISet<string> BuildExcludePatternsForGlobs(ImmutableHashSet<string
                 return anyExcludes ? excludePatterns.ToImmutableHashSet() : globsToIgnore;
             }
 
-            protected override void MutateItems(ImmutableList<I> items)
+            protected override void MutateItems(ImmutableArray<I> items)
             {
                 DecorateItemsWithMetadata(items.Select(i => new ItemBatchingContext(i)), _metadata);
             }
 
-            protected override void SaveItems(ImmutableList<I> items, OrderedItemDataCollection.Builder listBuilder)
+            protected override void SaveItems(ImmutableArray<I> items, OrderedItemDataCollection.Builder listBuilder)
             {
                 foreach (var item in items)
                 {
@@ -170,7 +170,7 @@ protected override void SaveItems(ImmutableList<I> items, OrderedItemDataCollect
         private class IncludeOperationBuilder : OperationBuilderWithMetadata
         {
             public int ElementOrder { get; set; }
-            public string RootDirectory { get; set; }
+            public string? RootDirectory { get; set; }
 
             public ImmutableSegmentedList<string>.Builder Excludes { get; } = ImmutableSegmentedList.CreateBuilder<string>();
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index bd7933842b0..43fffb961a6 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -43,7 +43,7 @@ protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M,
 
                 _lazyEvaluator = lazyEvaluator;
 
-                _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, itemType => GetReferencedItems(itemType, ImmutableHashSet<string>.Empty));
+                _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, _referencedItemLists);
                 _itemFactory = new ItemFactoryWrapper(_itemElement, _lazyEvaluator._itemFactory);
                 _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.EvaluationContext);
 
@@ -72,28 +72,16 @@ protected virtual void ApplyImpl(OrderedItemDataCollection.Builder listBuilder,
             /// <summary>
             /// Produce the items to operate on. For example, create new ones or select existing ones
             /// </summary>
-            protected virtual ImmutableList<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            protected virtual ImmutableArray<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 return listBuilder.Select(itemData => itemData.Item)
-                                  .ToImmutableList();
+                                  .ToImmutableArray();
             }
 
             // todo Refactoring: MutateItems should clone each item before mutation. See https://github.com/dotnet/msbuild/issues/2328
-            protected virtual void MutateItems(ImmutableList<I> items) { }
+            protected virtual void MutateItems(ImmutableArray<I> items) { }
 
-            protected virtual void SaveItems(ImmutableList<I> items, OrderedItemDataCollection.Builder listBuilder) { }
-
-            private IList<I> GetReferencedItems(string itemType, ImmutableHashSet<string> globsToIgnore)
-            {
-                if (_referencedItemLists.TryGetValue(itemType, out var itemList))
-                {
-                    return itemList.GetMatchedItems(globsToIgnore);
-                }
-                else
-                {
-                    return ImmutableList<I>.Empty;
-                }
-            }
+            protected virtual void SaveItems(ImmutableArray<I> items, OrderedItemDataCollection.Builder listBuilder) { }
 
             [DebuggerDisplay(@"{DebugString()}")]
             protected readonly struct ItemBatchingContext
@@ -174,9 +162,9 @@ private string RouteCall(string itemType, string name, Func<IMetadataTable, stri
                 }
             }
 
-            protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBatchingContexts, ImmutableList<ProjectMetadataElement> metadata, bool? needToExpandMetadata = null)
+            protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBatchingContexts, ImmutableArray<ProjectMetadataElement> metadata, bool? needToExpandMetadata = null)
             {
-                if (metadata.Count > 0)
+                if (metadata.Length > 0)
                 {
                     ////////////////////////////////////////////////////
                     // UNDONE: Implement batching here.
@@ -238,11 +226,11 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                     {
                         // Metadata expressions are allowed here.
                         // Temporarily gather and expand these in a table so they can reference other metadata elements above.
-                        EvaluatorMetadataTable metadataTable = new EvaluatorMetadataTable(_itemType);
+                        EvaluatorMetadataTable metadataTable = new EvaluatorMetadataTable(_itemType, capacity: metadata.Length);
                         _expander.Metadata = metadataTable;
 
                         // Also keep a list of everything so we can get the predecessor objects correct.
-                        List<Pair<ProjectMetadataElement, string>> metadataList = new List<Pair<ProjectMetadataElement, string>>(metadata.Count);
+                        List<Pair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
 
                         foreach (var metadataElement in metadata)
                         {
@@ -282,7 +270,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                 }
             }
 
-            private static IEnumerable<string> GetMetadataValuesAndConditions(ImmutableList<ProjectMetadataElement> metadata)
+            private static IEnumerable<string> GetMetadataValuesAndConditions(ImmutableArray<ProjectMetadataElement> metadata)
             {
                 foreach (var metadataElement in metadata)
                 {
@@ -291,7 +279,7 @@ private static IEnumerable<string> GetMetadataValuesAndConditions(ImmutableList<
                 }
             }
 
-            protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElement> metadata, out ItemsAndMetadataPair itemsAndMetadataFound)
+            protected bool NeedToExpandMetadataForEachItem(ImmutableArray<ProjectMetadataElement> metadata, out ItemsAndMetadataPair itemsAndMetadataFound)
             {
                 itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetMetadataValuesAndConditions(metadata));
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index e773885225b..862e4e986a5 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -16,7 +16,7 @@ internal partial class LazyItemEvaluator<P, I, M, D>
     {
         private class UpdateOperation : LazyItemOperation
         {
-            private readonly ImmutableList<ProjectMetadataElement> _metadata;
+            private readonly ImmutableArray<ProjectMetadataElement> _metadata;
             private ImmutableList<ItemBatchingContext>.Builder _itemsToUpdate = null;
             private ItemSpecMatchesItem _matchItemSpec = null;
             private bool? _needToExpandMetadataForEachItem = null;
@@ -147,7 +147,7 @@ private void SetMatchItemSpec()
                 }
             }
 
-            private bool QualifiedMetadataReferencesExist(ImmutableList<ProjectMetadataElement> metadata, out bool? needToExpandMetadataForEachItem)
+            private bool QualifiedMetadataReferencesExist(ImmutableArray<ProjectMetadataElement> metadata, out bool? needToExpandMetadataForEachItem)
             {
                 needToExpandMetadataForEachItem = NeedToExpandMetadataForEachItem(metadata, out var itemsAndMetadataFound);
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index e02ef565869..bd34997b839 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -52,7 +52,7 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
         {
             _outerEvaluatorData = data;
             _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext);
-            _evaluatorData = new EvaluatorData(_outerEvaluatorData, itemType => GetItems(itemType));
+            _evaluatorData = new EvaluatorData(_outerEvaluatorData, _itemLists);
             _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
@@ -61,13 +61,6 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
             EvaluationContext = evaluationContext;
         }
 
-        private ImmutableList<I> GetItems(string itemType)
-        {
-            return _itemLists.TryGetValue(itemType, out LazyItemList itemList) ?
-                itemList.GetMatchedItems(ImmutableHashSet<string>.Empty) :
-                ImmutableList<I>.Empty;
-        }
-
         public bool EvaluateConditionWithCurrentState(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions)
         {
             return EvaluateCondition(element.Condition, element, expanderOptions, parserOptions, _expander, this);
@@ -135,7 +128,7 @@ public ItemData(I item, ProjectItemElement originatingItemElement, int elementOr
                 _normalizedItemValue = normalizedItemValue;
             }
 
-            public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
+            public readonly ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
             {
                 // setting the factory's item element to the original item element that produced the item
                 // otherwise you get weird things like items that appear to have been produced by update elements
@@ -492,7 +485,7 @@ public OperationBuilder(ProjectItemElement itemElement, bool conditionResult)
 
         private class OperationBuilderWithMetadata : OperationBuilder
         {
-            public ImmutableList<ProjectMetadataElement>.Builder Metadata = ImmutableList.CreateBuilder<ProjectMetadataElement>();
+            public readonly ImmutableArray<ProjectMetadataElement>.Builder Metadata = ImmutableArray.CreateBuilder<ProjectMetadataElement>();
 
             public OperationBuilderWithMetadata(ProjectItemElement itemElement, bool conditionResult) : base(itemElement, conditionResult)
             {
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index e622acbfdc5..5de3520dab8 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -324,7 +324,7 @@ private ProjectItemElement ParseProjectItemElement(XmlElementWithLocation elemen
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = item;
 
@@ -744,7 +744,7 @@ private ProjectItemDefinitionElement ParseProjectItemDefinitionXml(XmlElementWit
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = itemDefinition;
 
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 3303e62a056..0a910c0a334 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -522,25 +522,27 @@ internal override void DiscardImplicitReferences()
                 LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
                 _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (string projectPath in oldWeakCache.Keys)
+                foreach (KeyValuePair<string, ProjectRootElement> kvp in oldWeakCache)
                 {
-                    ProjectRootElement rootElement;
+                    if (kvp.Value is null)
+                    {
+                        continue;
+                    }
 
-                    if (oldWeakCache.TryGetValue(projectPath, out rootElement))
+                    if (kvp.Value.IsExplicitlyLoaded)
                     {
-                        if (rootElement.IsExplicitlyLoaded)
-                        {
-                            _weakCache[projectPath] = rootElement;
-                        }
+                        _weakCache[kvp.Key] = kvp.Value;
+                    }
 
-                        if (rootElement.IsExplicitlyLoaded && oldStrongCache.Contains(rootElement))
+                    if (oldStrongCache.Contains(kvp.Value))
+                    {
+                        if (kvp.Value.IsExplicitlyLoaded)
                         {
-                            _strongCache.AddFirst(rootElement);
+                            _strongCache.AddFirst(kvp.Value);
                         }
                         else
                         {
-                            _strongCache.Remove(rootElement);
-                            RaiseProjectRootElementRemovedFromStrongCache(rootElement);
+                            RaiseProjectRootElementRemovedFromStrongCache(kvp.Value);
                         }
                     }
                 }
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index a226c96acdf..553c0af61ad 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -5,6 +5,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+using System.IO;
 using System.Linq;
 using System.Text;
 using System.Threading;
@@ -254,11 +255,15 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
             ErrorUtilities.VerifyThrowArgument(entryPoints.Count == 1, "StaticGraphAcceptsSingleSolutionEntryPoint");
 
-            var solutionEntryPoint = entryPoints.Single();
-            var solutionGlobalProperties = ImmutableDictionary.CreateRange(
+            ProjectGraphEntryPoint solutionEntryPoint = entryPoints.Single();
+            ImmutableDictionary<string, string>.Builder solutionGlobalPropertiesBuilder = ImmutableDictionary.CreateBuilder(
                 keyComparer: StringComparer.OrdinalIgnoreCase,
-                valueComparer: StringComparer.OrdinalIgnoreCase,
-                items: solutionEntryPoint.GlobalProperties ?? ImmutableDictionary<string, string>.Empty);
+                valueComparer: StringComparer.OrdinalIgnoreCase);
+
+            if (solutionEntryPoint.GlobalProperties != null)
+            {
+                solutionGlobalPropertiesBuilder.AddRange(solutionEntryPoint.GlobalProperties);
+            }
 
             var solution = SolutionFile.Parse(solutionEntryPoint.ProjectFile);
 
@@ -272,29 +277,53 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                         string.Join(";", solution.SolutionParserErrorCodes)));
             }
 
-            var projectsInSolution = GetBuildableProjects(solution);
+            IReadOnlyCollection<ProjectInSolution> projectsInSolution = GetBuildableProjects(solution);
+
+            SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
+
+            // Mimic behavior of SolutionProjectGenerator
+            string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(solution, currentSolutionConfiguration);
+            solutionGlobalPropertiesBuilder["CurrentSolutionConfigurationContents"] = solutionConfigurationXml;
+            solutionGlobalPropertiesBuilder["BuildingSolutionFile"] = "true";
+
+            string solutionDirectoryName = solution.SolutionFileDirectory;
+            if (!solutionDirectoryName.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal))
+            {
+                solutionDirectoryName += Path.DirectorySeparatorChar;
+            }
+
+            solutionGlobalPropertiesBuilder["SolutionDir"] = EscapingUtilities.Escape(solutionDirectoryName);
+            solutionGlobalPropertiesBuilder["SolutionExt"] = EscapingUtilities.Escape(Path.GetExtension(solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionFileName"] = EscapingUtilities.Escape(Path.GetFileName(solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionName"] = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(solution.FullPath));
+            solutionGlobalPropertiesBuilder[SolutionProjectGenerator.SolutionPathPropertyName] = EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.FullPath)));
 
-            var currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionGlobalProperties);
+            // Project configurations are reused heavily, so cache the global properties for each
+            Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
 
             var newEntryPoints = new List<ProjectGraphEntryPoint>(projectsInSolution.Count);
 
-            foreach (var project in projectsInSolution)
+            foreach (ProjectInSolution project in projectsInSolution)
             {
                 if (project.ProjectConfigurations.Count == 0)
                 {
                     continue;
                 }
 
-                var projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
+                ProjectConfigurationInSolution projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
 
                 if (projectConfiguration.IncludeInBuild)
                 {
-                    newEntryPoints.Add(
-                        new ProjectGraphEntryPoint(
-                            project.AbsolutePath,
-                            solutionGlobalProperties
-                                .SetItem("Configuration", projectConfiguration.ConfigurationName)
-                                .SetItem("Platform", projectConfiguration.PlatformName)));
+                    if (!globalPropertiesForProjectConfiguration.TryGetValue(projectConfiguration.FullName, out ImmutableDictionary<string, string> projectGlobalProperties))
+                    {
+                        solutionGlobalPropertiesBuilder["Configuration"] = projectConfiguration.ConfigurationName;
+                        solutionGlobalPropertiesBuilder["Platform"] = projectConfiguration.PlatformName;
+
+                        projectGlobalProperties = solutionGlobalPropertiesBuilder.ToImmutable();
+                        globalPropertiesForProjectConfiguration.Add(projectConfiguration.FullName, projectGlobalProperties);
+                    }
+
+                    newEntryPoints.Add(new ProjectGraphEntryPoint(project.AbsolutePath, projectGlobalProperties));
                 }
             }
 
@@ -307,13 +336,13 @@ IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutio
                 return solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat && solutionFile.ProjectShouldBuild(p.RelativePath)).ToImmutableArray();
             }
 
-            SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, ImmutableDictionary<string, string> globalProperties)
+            SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
             {
-                var solutionConfiguration = globalProperties.TryGetValue("Configuration", out string configuration)
+                var solutionConfiguration = globalProperties != null && globalProperties.TryGetValue("Configuration", out string configuration)
                     ? configuration
                     : solutionFile.GetDefaultConfigurationName();
 
-                var solutionPlatform = globalProperties.TryGetValue("Platform", out string platform)
+                var solutionPlatform = globalProperties != null && globalProperties.TryGetValue("Platform", out string platform)
                     ? platform
                     : solutionFile.GetDefaultPlatformName();
 
@@ -545,7 +574,6 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
 
-
             foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
             {
                 if (FileUtilities.IsSolutionFilename(referenceInfo.ReferenceConfiguration.ProjectFullPath))
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 1e1248865be..39993e3a4fc 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -766,7 +766,7 @@ public ProjectGraphBuildRequest(ProjectGraphNode node, ImmutableList<string> tar
 
             public ImmutableList<string> RequestedTargets { get; }
 
-            public bool Equals(ProjectGraphBuildRequest other)
+            public readonly bool Equals(ProjectGraphBuildRequest other)
             {
                 if (Node != other.Node
                     || RequestedTargets.Count != other.RequestedTargets.Count)
@@ -786,12 +786,12 @@ public bool Equals(ProjectGraphBuildRequest other)
                 return true;
             }
 
-            public override bool Equals(object obj)
+            public override readonly bool Equals(object obj)
             {
                 return !(obj is null) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
             }
 
-            public override int GetHashCode()
+            public override readonly int GetHashCode()
             {
                 unchecked
                 {
diff --git a/src/Build/Graph/ProjectGraphEntryPoint.cs b/src/Build/Graph/ProjectGraphEntryPoint.cs
index 8e229b7bd61..6b0f4713494 100644
--- a/src/Build/Graph/ProjectGraphEntryPoint.cs
+++ b/src/Build/Graph/ProjectGraphEntryPoint.cs
@@ -61,7 +61,7 @@ internal static IEnumerable<ProjectGraphEntryPoint> CreateEnumerable(IEnumerable
             }
         }
 
-        internal IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
+        internal readonly IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
         {
             yield return this;
         }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 23b0fc15ad9..dd47dbadc85 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -6,8 +6,10 @@
 using System.Collections.Immutable;
 using System.Globalization;
 using System.Linq;
+using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -32,8 +34,11 @@ internal sealed class ProjectInterpretation
         private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
         private const string PlatformMetadataName = "Platform";
         private const string PlatformsMetadataName = "Platforms";
-        private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
+        private const string EnableDynamicPlatformResolutionPropertyName = "EnableDynamicPlatformResolution";
         private const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
+        private const string ShouldUnsetParentConfigurationAndPlatformPropertyName = "ShouldUnsetParentConfigurationAndPlatform";
+        private const string ProjectMetadataName = "Project";
+        private const string ConfigurationMetadataName = "Configuration";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -52,17 +57,7 @@ internal enum ProjectType
             NonMultitargeting,
         }
 
-        internal readonly struct ReferenceInfo
-        {
-            public ConfigurationMetadata ReferenceConfiguration { get; }
-            public ProjectItemInstance ProjectReferenceItem { get; }
-
-            public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemInstance projectReferenceItem)
-            {
-                ReferenceConfiguration = referenceConfiguration;
-                ProjectReferenceItem = projectReferenceItem;
-            }
-        }
+        internal readonly record struct ReferenceInfo(ConfigurationMetadata ReferenceConfiguration, ProjectItemInstance ProjectReferenceItem);
 
         private readonly struct TargetSpecification
         {
@@ -83,7 +78,7 @@ public TargetSpecification(string target, bool skipIfNonexistent)
             public bool SkipIfNonexistent { get; }
         }
 
-        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection _projectCollection, ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory)
+        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection projectCollection, ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory)
         {
             IEnumerable<ProjectItemInstance> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
@@ -105,7 +100,14 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     throw new ArgumentOutOfRangeException();
             }
 
-            foreach (var projectReferenceItem in projectReferenceItems)
+            SolutionConfiguration solutionConfiguration = null;
+            string solutionConfigurationXml = requesterInstance.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
+            if (!string.IsNullOrWhiteSpace(solutionConfigurationXml))
+            {
+                solutionConfiguration = new SolutionConfiguration(solutionConfigurationXml);
+            }
+
+            foreach (ProjectItemInstance projectReferenceItem in projectReferenceItems)
             {
                 if (!String.IsNullOrEmpty(projectReferenceItem.GetMetadataValue(ToolsVersionMetadataName)))
                 {
@@ -118,22 +120,60 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                             requesterInstance.FullPath));
                 }
 
-                var projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
+                string projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
+                bool enableDynamicPlatformResolution = ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionPropertyName));
 
-                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)), globalPropertiesModifiers);
+                PropertyDictionary<ProjectPropertyInstance> referenceGlobalProperties = GetGlobalPropertiesForItem(
+                    projectReferenceItem,
+                    requesterInstance.GlobalPropertiesDictionary,
+                    // Only allow reuse in scenarios where we will not mutate the collection.
+                    // TODO: Should these mutations be moved to globalPropertiesModifiers in the future?
+                    allowCollectionReuse: solutionConfiguration == null && !enableDynamicPlatformResolution,
+                    globalPropertiesModifiers);
 
-                var requesterPlatform = "";
-                var requesterPlatformLookupTable = "";
+                // Match what AssignProjectConfiguration does to resolve project references.
+                if (solutionConfiguration != null)
+                {
+                    string projectGuid = projectReferenceItem.GetMetadataValue(ProjectMetadataName);
+                    if (solutionConfiguration.TryGetProjectByGuid(projectGuid, out XmlElement projectElement)
+                        || solutionConfiguration.TryGetProjectByAbsolutePath(projectReferenceFullPath, out projectElement))
+                    {
+                        // Note: AssignProjectConfiguration sets various metadata on the ProjectReference item, but ultimately it just translates to the Configuration and Platform global properties on the MSBuild task.
+                        string projectConfiguration = projectElement.InnerText;
+                        string[] configurationPlatformParts = projectConfiguration.Split(SolutionConfiguration.ConfigPlatformSeparator[0]);
+                        SetProperty(referenceGlobalProperties, ConfigurationMetadataName, configurationPlatformParts[0]);
 
-                if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+                        if (configurationPlatformParts.Length > 1)
+                        {
+                            SetProperty(referenceGlobalProperties, PlatformMetadataName, configurationPlatformParts[1]);
+                        }
+                        else
+                        {
+                            referenceGlobalProperties.Remove(PlatformMetadataName);
+                        }
+                    }
+                    else
+                    {
+                        // Note: ShouldUnsetParentConfigurationAndPlatform defaults to true in the AssignProjectConfiguration target when building a solution, so check that it's not false instead of checking that it's true.
+                        bool shouldUnsetParentConfigurationAndPlatform = !ConversionUtilities.ValidBooleanFalse(requesterInstance.GetPropertyValue(ShouldUnsetParentConfigurationAndPlatformPropertyName));
+                        if (shouldUnsetParentConfigurationAndPlatform)
+                        {
+                            referenceGlobalProperties.Remove(ConfigurationMetadataName);
+                            referenceGlobalProperties.Remove(PlatformMetadataName);
+                        }
+                    }
+                }
+
+                // Note: Dynamic platform resolution is not enabled for sln-based builds.
+                else if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && enableDynamicPlatformResolution)
                 {
-                    requesterPlatform = requesterInstance.GetPropertyValue("Platform");
-                    requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+                    string requesterPlatform = requesterInstance.GetPropertyValue("Platform");
+                    string requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
 
-                    var projectInstance = _projectInstanceFactory(
+                    var projectInstance = projectInstanceFactory(
                         projectReferenceFullPath,
                         null, // Platform negotiation requires an evaluation with no global properties first
-                        _projectCollection);
+                        projectCollection);
 
                     string overridePlatformNegotiationMetadataValue = projectReferenceItem.GetMetadataValue(OverridePlatformNegotiationValue);
 
@@ -145,14 +185,19 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     }
                     else
                     {
-                        var platformPropertyInstance = ProjectPropertyInstance.Create(PlatformMetadataName, selectedPlatform);
-                        referenceGlobalProperties[PlatformMetadataName] = platformPropertyInstance;
+                        SetProperty(referenceGlobalProperties, PlatformMetadataName, selectedPlatform);
                     }
                 }
 
                 var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
 
                 yield return new ReferenceInfo(referenceConfig, projectReferenceItem);
+
+                static void SetProperty(PropertyDictionary<ProjectPropertyInstance> properties, string propertyName, string propertyValue)
+                {
+                    ProjectPropertyInstance propertyInstance = ProjectPropertyInstance.Create(propertyName, propertyValue);
+                    properties[propertyName] = propertyInstance;
+                }
             }
         }
 
@@ -327,8 +372,8 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
         private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
             ProjectItemInstance projectReference,
             PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
-            bool dynamicPlatformEnabled,
-            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers = null)
+            bool allowCollectionReuse,
+            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));
             ErrorUtilities.VerifyThrowArgumentNull(requesterGlobalProperties, nameof(requesterGlobalProperties));
@@ -341,7 +386,7 @@ private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesFo
 
             var globalPropertyParts = globalPropertyModifiers?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;
 
-            if (globalPropertyParts.AllEmpty() && !dynamicPlatformEnabled)
+            if (globalPropertyParts.AllEmpty() && allowCollectionReuse)
             {
                 return requesterGlobalProperties;
             }
diff --git a/src/Build/Instance/HostObjectException.cs b/src/Build/Instance/HostObjectException.cs
index a38d07726c0..ee4613d1b14 100644
--- a/src/Build/Instance/HostObjectException.cs
+++ b/src/Build/Instance/HostObjectException.cs
@@ -2,13 +2,14 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
 namespace Microsoft.Build.Execution
 {
     [Serializable]
-    internal sealed class HostObjectException : Exception
+    internal sealed class HostObjectException : BuildExceptionBase
     {
         private const string ErrorMessagePrefix = "Error for HostObject:";
         private const string ErrorMessageProjectTargetTask = "In Project '{0}', Target '{1}', Task '{2}'.";
@@ -56,5 +57,11 @@ internal HostObjectException(
                 + string.Format(ErrorMessageProjectTargetTask, projectFile, targetName, taskName) + message)
         {
         }
+
+        internal HostObjectException(string message, Exception innerException)
+            : base(
+                message,
+                innerException)
+        { }
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 9a301afd793..7619850d4a7 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -19,6 +19,7 @@
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -241,7 +242,7 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
@@ -260,9 +261,11 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="directoryCacheFactory">The directory cache factory to use for file I/O.</param>
         /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
+        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection,
+            ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -279,7 +282,8 @@ private ProjectInstance(string projectFile, IDictionary<string, string> globalPr
             BuildEventContext buildEventContext = new BuildEventContext(buildParameters.NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, true /*Explicitly Loaded*/);
 
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version provided */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version provided */, buildParameters, projectCollection.LoggingService, buildEventContext,
+                projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext, directoryCacheFactory: directoryCacheFactory);
         }
 
         /// <summary>
@@ -327,7 +331,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
@@ -399,9 +403,11 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="directoryCacheFactory">The directory cache factory to use for file I/O.</param>
         /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
+        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection,
+            ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
 
@@ -410,7 +416,8 @@ private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glob
                 Interactive = interactive
             };
 
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, buildParameters, projectCollection.LoggingService, buildEventContext,
+                projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext, directoryCacheFactory: directoryCacheFactory);
         }
 
         /// <summary>
@@ -602,7 +609,7 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                     _properties.Set(property.DeepClone(_isImmutable));
                 }
 
-                _items = new ItemDictionary<ProjectItemInstance>(that._items.ItemTypes.Count);
+                _items = new ItemDictionary<ProjectItemInstance>(that._items.Count);
 
                 foreach (ProjectItemInstance item in that.Items)
                 {
@@ -755,6 +762,7 @@ public static ProjectInstance FromFile(string file, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
+                options.DirectoryCacheFactory,
                 options.Interactive);
         }
 
@@ -773,6 +781,7 @@ public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElem
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
+                options.DirectoryCacheFactory,
                 options.Interactive);
         }
 
@@ -2702,7 +2711,8 @@ private void Initialize(
             ISdkResolverService sdkResolverService = null,
             int submissionId = BuildEventContext.InvalidSubmissionId,
             ProjectLoadSettings? projectLoadSettings = null,
-            EvaluationContext evaluationContext = null)
+            EvaluationContext evaluationContext = null,
+            IDirectoryCacheFactory directoryCacheFactory = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(explicitToolsVersion, "toolsVersion");
@@ -2792,8 +2802,8 @@ private void Initialize(
             evaluationContext = evaluationContext?.ContextForNewProject() ?? EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
 
             Evaluator<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Evaluate(
-                this,
-                null,
+                data: this,
+                project: null,
                 xml,
                 projectLoadSettings ?? buildParameters.ProjectLoadSettings, /* Use override ProjectLoadSettings if specified */
                 buildParameters.MaxNodeCount,
@@ -2801,6 +2811,7 @@ private void Initialize(
                 loggingService,
                 new ProjectItemInstanceFactory(this),
                 buildParameters.ToolsetProvider,
+                directoryCacheFactory,
                 ProjectRootElementCache,
                 buildEventContext,
                 sdkResolverService ?? evaluationContext.SdkResolverService, /* Use override ISdkResolverService if specified */
@@ -2942,11 +2953,9 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
                 if (item.DirectMetadata != null)
                 {
                     directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                    foreach (ProjectMetadata directMetadatum in item.DirectMetadata)
-                    {
-                        ProjectMetadataInstance directMetadatumInstance = new ProjectMetadataInstance(directMetadatum);
-                        directMetadata.Set(directMetadatumInstance);
-                    }
+
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                    directMetadata.ImportProperties(projectMetadataInstances);
                 }
 
                 // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 7a4bffd0290..fa41b3882ec 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -58,11 +59,9 @@ internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition)
             if (itemDefinition.MetadataCount > 0)
             {
                 _metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-            }
 
-            foreach (ProjectMetadata originalMetadata in itemDefinition.Metadata)
-            {
-                _metadata.Set(new ProjectMetadataInstance(originalMetadata));
+                IEnumerable<ProjectMetadataInstance> projectMetadataInstances = itemDefinition.Metadata.Select(originalMetadata => new ProjectMetadataInstance(originalMetadata));
+                _metadata.ImportProperties(projectMetadataInstances);
             }
         }
 
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index ab16a994eee..4bc5866687c 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -114,10 +114,8 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
             if (directMetadata?.GetEnumerator().MoveNext() == true)
             {
                 metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                foreach (KeyValuePair<string, string> metadatum in directMetadata)
-                {
-                    metadata.Set(new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
-                }
+                IEnumerable<ProjectMetadataInstance> directMetadataInstances = directMetadata.Select(metadatum => new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
+                metadata.ImportProperties(directMetadataInstances);
             }
 
             CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped);
@@ -587,11 +585,10 @@ void ITranslatable.Translate(ITranslator translator)
         internal static void SetMetadata(IEnumerable<KeyValuePair<string, string>> metadataList, IEnumerable<ProjectItemInstance> items)
         {
             // Set up a single dictionary that can be applied to all the items
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-            foreach (KeyValuePair<string, string> metadatum in metadataList)
-            {
-                metadata.Set(new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
-            }
+            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new();
+
+            IEnumerable<ProjectMetadataInstance> projectMetadataInstances = metadataList.Select(metadatum => new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
+            metadata.ImportProperties(projectMetadataInstances);
 
             foreach (ProjectItemInstance item in items)
             {
@@ -1096,40 +1093,45 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
 
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> allMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
 
-                    // Next, any inherited item definitions. Front of the list is highest priority,
-                    // so walk backwards.
-                    for (int i = _itemDefinitions.Count - 1; i >= 0; i--)
+                    allMetadata.ImportProperties(metaData());
+
+                    return allMetadata;
+
+                    IEnumerable<ProjectMetadataInstance> metaData()
                     {
-                        foreach (ProjectMetadataInstance metadatum in _itemDefinitions[i].Metadata)
+                        // Next, any inherited item definitions. Front of the list is highest priority,
+                        // so walk backwards.
+                        for (int i = _itemDefinitions.Count - 1; i >= 0; i--)
                         {
-                            if (metadatum != null)
-                            {
-                                allMetadata.Set(metadatum);
-                            }
-                            else
+                            foreach (ProjectMetadataInstance metadatum in _itemDefinitions[i].Metadata)
                             {
-                                Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                if (metadatum != null)
+                                {
+                                    yield return metadatum;
+                                }
+                                else
+                                {
+                                    Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                }
                             }
                         }
-                    }
 
-                    // Finally any direct metadata win.
-                    if (_directMetadata != null)
-                    {
-                        foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                        // Finally any direct metadata win.
+                        if (_directMetadata != null)
                         {
-                            if (metadatum != null)
+                            foreach (ProjectMetadataInstance metadatum in _directMetadata)
                             {
-                                allMetadata.Set(metadatum);
-                            }
-                            else
-                            {
-                                Debug.Fail("metadatum in _directMetadata is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                if (metadatum != null)
+                                {
+                                    yield return metadatum;
+                                }
+                                else
+                                {
+                                    Debug.Fail("metadatum in _directMetadata is null, see https://github.com/dotnet/msbuild/issues/5267");
+                                }
                             }
                         }
                     }
-
-                    return allMetadata;
                 }
             }
 
@@ -1694,12 +1696,21 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                     if (translator.TranslateNullable(_directMetadata))
                     {
                         int count = translator.Reader.ReadInt32();
-                        _directMetadata = (count == 0) ? null : new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                        for (int i = 0; i < count; i++)
+                        if (count > 0)
+                        {
+                            IEnumerable<ProjectMetadataInstance> metaData =
+                                Enumerable.Range(0, count).Select(_ =>
+                                {
+                                    int key = translator.Reader.ReadInt32();
+                                    int value = translator.Reader.ReadInt32();
+                                    return new ProjectMetadataInstance(interner.GetString(key), interner.GetString(value), allowItemSpecModifiers: true);
+                                });
+                            _directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                            _directMetadata.ImportProperties(metaData);
+                        }
+                        else
                         {
-                            int key = translator.Reader.ReadInt32();
-                            int value = translator.Reader.ReadInt32();
-                            _directMetadata.Set(new ProjectMetadataInstance(interner.GetString(key), interner.GetString(value), allowItemSpecModifiers: true));
+                            _directMetadata = null;
                         }
                     }
                 }
@@ -1962,10 +1973,8 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
                 {
                     // Set up a single dictionary that can be applied to all the items
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                    foreach (Pair<ProjectMetadataElement, string> metadatum in metadataList)
-                    {
-                        metadata.Set(new ProjectMetadataInstance(metadatum.Key.Name, metadatum.Value));
-                    }
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = metadataList.Select(metadatum => new ProjectMetadataInstance(metadatum.Key.Name, metadatum.Value));
+                    metadata.ImportProperties(projectMetadataInstances);
 
                     foreach (ProjectItemInstance item in destinationItems)
                     {
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 4df6b2830f9..7f90d035fd6 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -97,6 +97,7 @@ public void Initialize(IEventSource eventSource)
             ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
             ParseFileLoggerParameters();
             string fileName = _logFile;
+
             try
             {
                 // Create a new file logger and pass it some parameters to make the build log very detailed
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 156ee0c58e5..180d58a2a08 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -39,6 +39,11 @@ public FileLogger()
                 colorReset: BaseConsoleLogger.DontResetColor)
         {
             WriteHandler = Write;
+
+            if (EncodingUtilities.GetExternalOverriddenUILanguageIfSupportableWithEncoding() != null)
+            {
+                _encoding = Encoding.UTF8;
+            }
         }
 
         #endregion
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c73282b3df1..1bc5e67a847 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -49,7 +49,7 @@
     <PackageReference Include="System.Memory" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
@@ -110,9 +110,6 @@
     <Compile Include="..\Shared\INodePacket.cs" />
     <Compile Include="..\Shared\INodePacketFactory.cs" />
     <Compile Include="..\Shared\INodePacketHandler.cs" />
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\LogMessagePacketBase.cs" />
     <Compile Include="..\Shared\NodePacketFactory.cs" />
     <Compile Include="..\Shared\NodeBuildComplete.cs" />
@@ -155,6 +152,7 @@
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
+    <Compile Include="BackEnd\Components\Communications\SerializationContractInitializer.cs" />
     <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 5a8f8640a74..ca382f593d6 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -474,7 +474,7 @@
     <comment>{StrBegin="MSB4187: "}</comment>
   </data>
   <data name="UnhandledMSBuildError" xml:space="preserve">
-    <value>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+    <value>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</value>
   </data>
   <data name="IllFormedCondition" xml:space="preserve">
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 0f52b70e2b8..3513f26be0e 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Proměnná prostředí MSBUILDDISABLEFEATURESFROMVERSION je nastavena na neplatný formát. Povolování všech verzí Change Waves. Zadaná hodnota: {0}. Aktuální Change Waves: {1}</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Proměnná prostředí MSBUILDDISABLEFEATURESFROMVERSION je nastavena na verzi, která je mimo rotaci. Návrat k výchozí verzi Change Wave: {0}. Zadaná hodnota: {1}. Aktuální Change Waves: {2}</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: Výchozí překladač sady SDK nedokázal přeložit sadu SDK „{0}“, protože adresář „{1}“ neexistoval.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Vlastnost „{0}“ s hodnotou „{1}“ rozbalenou z prostředí.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Nepovedlo se přeložit sadu SDK „{0}“. Přesně jedna z níže uvedených zpráv o testování označuje, proč se nám nepovedlo přeložit sadu SDK. Prošetřete a vyřešte tuto zprávu, abyste správně určili sadu SDK.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: Definice položky „{0}“ v rámci cíle odkazuje sama na sebe prostřednictvím metadat (kvalifikovaného nebo nekvalifikovaného) „{1}“. To může vést k nezamýšlenému rozšíření a křížovému použití již existujících položek. Další informace: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Opakované použití {0} uzlu (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznán. Pokud jste chtěli, aby to byla vlastnost, uzavřete ji do elementu &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Překladač sady SDK „{0}“ vrátil hodnotu null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Sestavení načtené během {0}{1}: {2} (umístění: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Jedná se o neošetřenou výjimku v MSBuildu – HLASUJTE PROSÍM PRO EXISTUJÍCÍ PROBLÉM NEBO VYTVOŘTE NOVÝ NA https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Jedná se o neošetřenou výjimku v MSBuildu – HLASUJTE PROSÍM PRO EXISTUJÍCÍ PROBLÉM NEBO VYTVOŘTE NOVÝ NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
@@ -1465,7 +1465,7 @@
       </trans-unit>
       <trans-unit id="SolutionVenusProjectSkipped">
         <source>Skipping because the "$(AspNetConfiguration)" configuration is not supported for this web project.  You can use the AspNetConfiguration property to override the configuration used for building web projects, by adding /p:AspNetConfiguration=&lt;value&gt; to the command line. Currently web projects only support Debug and Release configurations.</source>
-        <target state="translated">Vynecháno, protože konfigurace $(AspNetConfiguration) není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
+        <target state="translated">Vynecháno, protože konfigurace "$(AspNetConfiguration)" není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
         <note>
     UE: This is not an error, so doesn't need an error code.
     LOCALIZATION: Do NOT localize "AspNetConfiguration", "Debug", "Release".
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 363edd349b7..12843156e44 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf ein ungültiges Format festgelegt. Alle Änderungszyklusversionen werden aktiviert. Eingegebener Wert: {0}. Aktuelle Änderungszyklen: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf eine nicht rotierende Version festgelegt und wird auf die Standard-Änderungszyklusversion gesetzt: {0}. Eingegebener Wert: {1}. Aktuelle Änderungszyklen: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: Der SDK-Standardresolver konnte SDK "{0}" nicht auflösen, da das Verzeichnis "{1}" nicht vorhanden war.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Die Eigenschaft "{0}" mit dem Wert "{1}" wurde aus der Umgebung erweitert.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Das SDK "{0}" konnte nicht aufgelöst werden. Genau eine der folgenden Testmeldungen gibt an, warum das SDK nicht aufgelöst werden konnte. Untersuchen und beheben Sie diese Meldung, um das SDK richtig anzugeben.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: Element "{0}" Definition innerhalb des Zielverweises selbst über (qualifiziertes oder nicht qualifiziertes) Metadatum "{1}". Dies kann zu einer unbeabsichtigten Erweiterung und einer kreuzseitigen Anwendung bereits vorhandener Elemente führen. Weitere Informationen: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Folgendes Projektcache-Plug-In wird geladen: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Der Knoten "{0}" wird wiederverwendet (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Das Element &lt;{0}&gt; unterhalb des Elements &lt;{1}&gt; ist unbekannt. Wenn dies eine Eigenschaft sein sollte, schließen Sie sie in ein &lt;PropertyGroup&gt;-Element ein.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Der SDK-Resolver "{0}" hat NULL zurückgegeben.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Assembly während {0}{1} geladen: {2} (Speicherort: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index b614cd5d41a..0ad80ad2762 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION está establecida en un formato no válido. Habilitando todas las versiones de oleadas de cambios. Valor especificado: {0}. Oleadas de cambios actuales: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION está establecida en una versión no incluida en la rotación. Se va a cambiar a la versión de oleada de cambios de forma predeterminada: {0}. Valor especificado: {1}. Oleadas de cambios actuales: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: La resolución predeterminada del SDK no pudo resolver el SDK "{0}" porque el directorio "{1}" no existía.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Propiedad "{0}" con el valor "{1}" expandido desde el entorno.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">No se ha podido resolver el SDK "{0}". Exactamente uno de los siguientes mensajes de sondeo indica por qué no se pudo resolver el SDK. Investigue y resuelva ese mensaje para especificar correctamente el SDK.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: Definición del elemento ''{0}'' dentro de las propias referencias de destino a través del metadato ''{1}'' (calificado o no calificado). Esto puede dar lugar a una expansión no deseada y la aplicación cruzada de elementos preexistente. Más información: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Cargando el complemento de caché de proyectos siguiente:{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Reutilizando nodo {0} (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: No se reconoce el elemento &lt;{0}&gt; debajo del elemento &lt;{1}&gt;. Si pretendía que fuera una propiedad, escríbala dentro de un elemento &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">La resolución del SDK "{0}" devolvió null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Ensamblado cargado durante {0}{1}: {2} (ubicación: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Esta es una excepción no controlada en MSBuild. VOTE POR UN PROBLEMA EXISTENTE O PRESENTE UNO NUEVO EN https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Esta es una excepción no controlada en MSBuild. VOTE POR UN PROBLEMA EXISTENTE O PRESENTE UNO NUEVO EN https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index c38b649d037..79d33d365df 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: la variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a un format non valide. Activation de toutes les versions des vagues de changements. Valeur entrée : {0}. Vagues de changements actuelles : {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: la variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a une valeur correspondant à une version hors rotation. Utilisation par défaut de la vague de changements version {0}. Valeur entrée : {1}. Vagues de changements actuelles : {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: Le programme de résolution du SDK par défaut n’a pas pu résoudre le SDK «{0}», car le répertoire «{1}» n’existait pas.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Propriété '{0}' avec la valeur '{1}' développée à partir de l’environnement.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Impossible de résoudre le SDK «{0}». Exactement l’un des messages de sondage ci-dessous indique pourquoi nous n’avons pas pu résoudre le Kit de développement logiciel (SDK). Examinez et résolvez ce message pour spécifier correctement le Kit de développement logiciel (SDK).
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: La définition de l’élément '{0}' dans la cible se référence elle-même via la métadonnée '{1}' (qualifiée ou non qualifiée). Cela peut entraîner l’expansion involontaire et l’application croisée d’éléments préexistants. Plus d’informations : https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Chargement du plug-in de cache de projet suivant :{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Réutilisation du {0} de nœud (PID : {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: L’élément &lt;{0}&gt; sous l’élément &lt;{1}&gt; n’est pas reconnu. Si vous souhaitiez qu’il s’agit d’une propriété, placez-la dans un élément &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Le programme de résolution du Kit de développement logiciel (SDK) «{0}» a retourné null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Assembly chargé pendant {0}{1}: {2} (emplacement : {3}, MVID : {4}, AppDomain : {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Il s’agit d’une exception non gérée dans MSBuild -- VOTEZ POUR UN PROBLÈME EXISTANT OU ENTREZ UN NOUVEAU FICHIER À https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Il s’agit d’une exception non gérée dans MSBuild -- VOTEZ POUR UN PROBLÈME EXISTANT OU ENTREZ UN NOUVEAU FICHIER À https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 4c4932631a8..47a775d5d43 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: la variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION è impostata su un formato non valido. Verranno abilitate tutte le versioni con flussi di modifiche. Valore immesso: {0}. Flussi di modifiche correnti: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: la variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION è impostata su una versione esclusa dalla rotazione. Per impostazione predefinita, verrà usata la versione con flussi di modifiche: {0}. Valore immesso: {1}. Flussi di modifiche correnti: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: il resolver SDK predefinito non è riuscito a risolvere l'SDK "{0}" perché la directory "{1}" non esiste.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">La proprietà '{0}' con valore '{1}' espansa dall'ambiente.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Non è stato possibile risolvere l'SDK "{0}". Uno dei messaggi di verifica riportati seguenti indica il motivo per cui non è stato possibile risolvere l'SDK. Esaminare e risolvere il messaggio per specificare correttamente l'SDK.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: la definizione dell'elemento '{0}' all'interno del target fa riferimento a se stessa tramite il metadatum (qualificato o non qualificato) '{1}'. Ciò può causare un'espansione involontaria e l'applicazione incrociata di elementi preesistenti. Altre informazioni: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Caricamento del plug-in della cache del progetto seguente: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Riutilizzo del nodo {0} (PID: {1} ).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: l'elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non è riconosciuto. Se era destinato a essere una proprietà, racchiuderlo in un elemento &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Il resolver SDK "{0}" ha restituito null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Assembly caricato durante {0}{1}: {2} (percorso: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Si tratta di un'eccezione non gestita in MSBuild-- ESEGUIRE L'UPVOTE DI UN PROBLEMA ESISTENTE O DI UN FILE NUOVO IN https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Si tratta di un'eccezione non gestita in MSBuild-- ESEGUIRE L'UPVOTE DI UN PROBLEMA ESISTENTE O DI UN FILE NUOVO IN https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 0ab12ba89e3..738f5c09007 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: 環境変数 MSBUILDDISABLEFEATURESFROMVERSION が無効な形式に設定されています。すべての変更ウェーブ バージョンを有効にしています。入力された値: {0}。現在の変更ウェーブ: {1}。</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: 環境変数 MSBUILDDISABLEFEATURESFROMVERSION が、ローテーションから外れているバージョンに設定されています。変更ウェーブ バージョンを既定値にしています: {0}。入力された値: {1}。現在の変更ウェーブ: {2}。</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: ディレクトリ "{0}" が存在しなかったため、既定の SDK リゾルバーは SDK "{1}" を解決できませんでした。</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">環境から展開された '{1}' 値を持つプロパティ '{0}'。</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">SDK "{0}" を解決できませんでした。以下のプローブ メッセージの 1 つは、SDK を解決できなかった理由を示しています。SDK を正しく指定するには、そのメッセージを調査して解決してください。
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: ターゲット内の項目 '{0}' 定義は、メタダタム '{1}' を介して (修飾または非修飾) 参照自体を参照しています。これにより、意図しない展開や既存のアイテムのクロス適用が発生する可能性があります。詳細情報: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">次のプロジェクト キャッシュ プラグインを読み込んでいます: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">ノード {0} を再利用しています (PID: {1})。</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: 要素 &lt;{0}&gt; の下 &lt;{1}&gt; 要素を認識できません。これをプロパティにする場合は、&lt;PropertyGroup&gt; 要素内で囲んでください。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK リゾルバー "{0}" が null を返しました。</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">{0}{1} 中にアセンブリが読み込まれました: {2} (場所: {3}、MVID: {4}、AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">これは MSBuild でハンドルされない例外です -- 既存の問題に賛成票を投じるか、https://aka.ms/msbuild/unhandled で新しい問題を提起してください。
+        <target state="needs-review-translation">これは MSBuild でハンドルされない例外です -- 既存の問題に賛成票を投じるか、https://aka.ms/msbuild/unhandled で新しい問題を提起してください。
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 8101d90c436..371e4c97c42 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: 환경 변수 MSBUILDDISABLEFEATURESFROMVERSION이 잘못된 형식으로 설정되어 있습니다. 변경 웨이브 버전을 모두 사용하도록 설정합니다. 입력한 값: {0}. 현재 변경 웨이브: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: 환경 변수 MSBUILDDISABLEFEATURESFROMVERSION이 순환되지 않는 버전으로 설정되어 있습니다. 기본값인 변경 웨이브 버전 {0}(으)로 설정합니다. 입력한 값: {1}. 현재 변경 웨이브: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: 디렉터리 "{0}"이(가) 없으므로 기본 SDK 확인자가 SDK "{1}"을(를) 확인하지 못했습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">환경에서 값이 '{0}'인 속성 '{1}'이(가) 확장되었습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">SDK "{0}"을(를) 확인할 수 없습니다. 아래 검색 메시지 중 정확히 하나는 SDK를 확인할 수 없는 이유를 나타냅니다. 해당 메시지를 조사하고 확인하여 SDK를 올바르게 지정합니다.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: 대상 내의 '{0}' 항목 정의는 (정규화된 또는 정규화되지 않은) 메타데이터 '{1}'를 통해 자신을 참조합니다. 이로 인해 의도하지 않은 확장 및 기존 항목의 교차 적용이 발생할 수 있습니다. 추가 정보: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">다음 프로젝트 캐시 플러그 인을 로드하는 중:{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">노드 {0}을(를) 다시 사용하는 중입니다(PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: 요소 &lt;{0}&gt; 아래에 요소 &lt;{1}&gt;을(를) 인식할 수 없습니다. 속성이 되도록 하려면 &lt;PropertyGroup&gt; 요소 내에 묶습니다.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK 확인자 "{0}"이(가) null을 반환했습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">{0}{1} 동안 로드된 어셈블리: {2}(위치: {3}%1, MVID: {4}%2, AppDomain: {5}%2).</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">MSBuild에서 처리되지 않은 예외입니다. https://aka.ms/msbuild/unhandled에서 기존 문제에 찬성 투표하거나 새 문제를 제출하세요.
+        <target state="needs-review-translation">MSBuild에서 처리되지 않은 예외입니다. https://aka.ms/msbuild/unhandled에서 기존 문제에 찬성 투표하거나 새 문제를 제출하세요.
  {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 334e24ff11e..a633bd3e33d 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: Zmienna środowiskowa MSBUILDDISABLEFEATURESFROMVERSION ma nieprawidłowy format. Włączenie wszystkich wersji fali zmian. Wprowadzona wartość: {0}. Bieżące fale zmian: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: Zmienna środowiskowa MSBUILDDISABLEFEATURESFROMVERSION jest ustawiona na wersję, która jest poza rotacją. Domyślnie ustawiona na Zmień wersję fali: {0}. Wprowadzona wartość: {1}. Aktualna wersja funkcji Zmień fale: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: Domyślne narzędzie Resolver zestawu SDK nie może rozpoznać zestawu SDK „{0}”, ponieważ katalog „{1}” nie istnieje.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Właściwość „{0}” o wartości „{1}” rozwinięto ze środowiska.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Nie można rozpoznać zestawu SDK „{0}”. Dokładnie jeden z poniższych komunikatów sondujących wskazuje, dlaczego nie mogliśmy rozpoznać zestawu SDK. Zbadaj i rozwiąż ten komunikat, aby poprawnie określić zestaw SDK.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: Definicja „{0}” elementu w miejscu docelowym odwołuje się do siebie za pośrednictwem metadanych (kwalifikowanych lub niekwalifikowanych) „{1}”. Może to prowadzić do niezamierzonego rozszerzenia i krzyżowego  zastosowania wcześniej istniejących elementów. Więcej informacji: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Ładowanie następującej wtyczki pamięci podręcznej projektu: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Ponowne użycie węzła {0} (identyfikator PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; jest nierozpoznany. Jeśli ma to być właściwość, umieść ją w elemencie &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Narzędzie Resolver zestawu SDK „{0}” zwróciło wartość null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Załadowano zestaw podczas {0}{1}: {2} (lokalizacja: {3}, MVID: {4}, domena aplikacji: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">To jest nieobsługiwany wyjątek w programie MSBuild — POPRZYJ ISTNIEJĄCY PROBLEM LUB ZAREJESTRUJ NOWY NA https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">To jest nieobsługiwany wyjątek w programie MSBuild — POPRZYJ ISTNIEJĄCY PROBLEM LUB ZAREJESTRUJ NOWY NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 1231fa2b51b..bccc96e741f 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: A variável de ambiente MSBUILDDISABLEFEATURESFROMVERSION está definida para um formato inválido. Habilitando todas as versões de onda de mudança. Valor inserido: {0}. Ondas de Mudança Atuais: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: A variável de ambiente MSBUILDDISABLEFEATURESFROMVERSION está definida para uma versão que está fora de rotação. Padrão para alterar a versão do Wave: {0}. Valor inserido: {1}. Ondas de Mudança Atuais: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: O resolvedor SDK padrão falhou ao resolver SDK "{0}" porque o diretório "{1}" não existia.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Imóvel '{0}' com valor '{1}' expandido do ambiente.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Não foi possível resolver SDK "{0}". Exatamente uma das mensagens de investigação abaixo indica por que não foi possível resolver o SDK. Investigue e resolva essa mensagem para especificar corretamente o SDK.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: A definição do item '{0}' dentro do destino faz referência a si mesmo via metadado (qualificado ou não qualificado) '{1}'. Isso pode levar à expansão não intencional e à aplicação cruzada de itens pré-existentes. Mais informações: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Carregando o seguinte plug-in de cache do projeto: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Reutilizando nó {0} (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; não é reconhecido. Se você pretende que seja uma propriedade, coloque-a dentro de um elemento &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">O resolvedor do SDK "{0}" retornou nulo.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Montagem carregada durante {0}{1}: {2} (localização: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Esta é uma exceção sem tratamento no MSBuild -- VOTE A FAVOR DE UM PROBLEMA EXISTENTE OU REGISTRE UM NOVO EM https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Esta é uma exceção sem tratamento no MSBuild -- VOTE A FAVOR DE UM PROBLEMA EXISTENTE OU REGISTRE UM NOVO EM https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 2858ea61d4b..76545e16958 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: для переменной среды MSBUILDDISABLEFEATURESFROMVERSION задан недопустимый формат. Идет включение всех версий волн изменений. Введенное значение: {0}. Текущие волны изменений: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: для переменной среды MSBUILDDISABLEFEATURESFROMVERSION задана версия, которая больше не используется. По умолчанию будет использоваться версия волны изменений {0}. Введенное значение: {1}. Текущие волны изменений: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: стандартному сопоставителю пакетов SDK не удалось разрешить пакет SDK "{0}", так как каталог "{1}" не существует.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">Свойство "{0}" со значением "{1}" развернуто из окружения.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">Не удалось разрешить пакет SDK "{0}". В одном из приведенных ниже сообщений проверки указано, почему не удалось разрешить пакет SDK. Изучите и устраните возникшую проблему, чтобы правильно указать пакет SDK.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: определение элемента "{0}" в целевом объекте ссылается на себя через метаданные "{1}" (квалифицированные или неквалифицированные). Это может привести к непреднамеренному расширению и перекрестному применению существующих элементов. Дополнительные сведения: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Идет загрузка следующего подключаемого модуля кэша проектов: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Повторное использование узла {0} (ИД процесса: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: элемент &lt;{0}&gt; под элементом &lt;{1}&gt; не распознан. Если вы хотите использовать его как свойство, включите его в элемент &lt;PropertyGroup&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">Сопоставитель пакетов SDK "{0}" вернул значение null.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Сборка загружена во время {0}{1}: {2} (расположение: {3}, MVID: {4}, домен приложения: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Это необработанное исключение в MSBuild — ПРОГОЛОСУЙТЕ ЗА СУЩЕСТВУЮЩУЮ ПРОБЛЕМУ ИЛИ СОЗДАЙТЕ НОВУЮ на сайте https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Это необработанное исключение в MSBuild — ПРОГОЛОСУЙТЕ ЗА СУЩЕСТВУЮЩУЮ ПРОБЛЕМУ ИЛИ СОЗДАЙТЕ НОВУЮ на сайте https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index dda58e54d67..2da4f4f34ca 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: MSBUILDDISABLEFEATURESFROMVERSION ortam değişkeni geçersiz bir biçime ayarlandı. Tüm değişiklik dalgası sürümleri etkinleştiriliyor. Girilen değer: {0}. Geçerli Değişiklik Dalgaları: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: MSBUILDDISABLEFEATURESFROMVERSION ortam değişkeni, düzenli değişiklik dışı bir sürüme ayarlandı. Varsayılan Değişiklik Dalgası sürümüne dönülüyor: {0}. Girilen değer: {1}. Geçerli Değişiklik Dalgaları: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: "{1}" dizini olmadığından, varsayılan SDK çözümleyicisi "{0}" SDK’sını çözümleyemedi.</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">'{1}' değerine sahip '{0}' özelliği ortamdan genişletildi.</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">SDK "{0}" çözümlenemedi. Aşağıdaki yoklama iletilerinden tam olarak biri, SDK'yı neden çözümleyemediğimizi gösterir. SDK'yı doğru şekilde belirtmek için bu iletiyi inceleyin ve çözümleyin.
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: (Nitelikli veya niteliksiz) meta veri dosyası '{1}' aracılığıyla hedef içindeki '{0}' öğesinin tanımı kendi kendisine başvuruyor. Bu, önceden var olan öğelerin istenmeyen şekilde genişlemesine ve çapraz olarak uygulanmasına neden olabilir. Daha fazla bilgi: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">Şu proje önbelleği eklentisi yükleniyor:{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">Düğüm {0} yeniden kullanılıyor (PID: {1}).</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; altındaki &lt;{0}&gt; öğesi tanınmıyor. Bunun bir özellik olmasını amaçladıysanız, bir &lt;PropertyGroup&gt; öğesi içine ekleyin.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK çözümleyici "{0}" null döndürdü.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">Derleme {0}{1} sırasında yüklendi: {2} (konum: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Bu, MSBuild'de işlenmeyen bir özel durumdur -- LÜTFEN MEVCUT BIR SORUNA DESTEK OYU VERIN VEYA MEVCUT BIR SORUNU BİLDİRİN: https://aka.ms/msbuild/unhandled.
+        <target state="needs-review-translation">Bu, MSBuild'de işlenmeyen bir özel durumdur -- LÜTFEN MEVCUT BIR SORUNA DESTEK OYU VERIN VEYA MEVCUT BIR SORUNU BİLDİRİN: https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 8a2d41f5a59..666dfa53602 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: 设置的环境变量 MSBUILDDISABLEFEATURESFROMVERSION 格式无效。正在启用所有更改批次版本。输入的值: {0}。当前更改批次:{1}。</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: 设置的环境变量 MSBUILDDISABLEFEATURESFROMVERSION 版本不在轮换范围内。默认为“更改批次”版本: {0}。输入的值: {1}。当前更改批次: {2}。</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: 默认 SDK 解析程序解析 SDK“{0}”失败，因为目录“{1}”不存在。</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">值为“{1}”的属性“{0}”从环境中展开。</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">无法解析 SDK“{0}”。下面的探测消息中正好有一条指示我们无法解析 SDK 的原因。调查并解决该消息以正确指定 SDK。
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: 目标内的项“{0}”定义通过(限定或非限定)元数据“{1}”引用自身。这可能导致意外扩展和交叉应用预先存在的项。详细信息: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">正在加载以下项目缓存插件: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">正在重复使用节点 {0} (PID: {1})。</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: 无法识别元素 &lt;{0}&gt; 下方 &lt;{1}&gt; 元素。如果打算将其作为属性，请将其封闭在 &lt;PropertyGroup&gt; 元素中。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK 解析程序“{0}”返回 null。</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">程序集加载期间 {0}{1}: {2} (位置: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">这是 MSBuild 中未经处理的异常 -- 请对现有问题投赞成票或在 https://aka.ms/msbuild/unhandled 上提交新问题。
+        <target state="needs-review-translation">这是 MSBuild 中未经处理的异常 -- 请对现有问题投赞成票或在 https://aka.ms/msbuild/unhandled 上提交新问题。
     {0}</target>
         <note />
       </trans-unit>
@@ -2386,7 +2386,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="InvalidSdkFormat">
         <source>MSB4229: The value "{0}" is not valid for an Sdk specification. The attribute should be a semicolon-delimited list of Sdk-name/minimum-version pairs, separated by a forward slash.</source>
-        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对（用正斜杠分隔）的列表。</target>
+        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对 (用正斜杠分隔) 的列表。</target>
         <note>{StrBegin="MSB4229: "}</note>
       </trans-unit>
       <trans-unit id="TaskInstantiationFailureNotSupported">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 3bae314d441..5417bf07605 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
+        <target state="translated">MSB4271: 環境變數 MSBUILDDISABLEFEATURESFROMVERSION 設為無效的格式。正在啟用所有變更波段版本。輸入的值: {0}。目前的變更波段: {1}。</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
+        <target state="translated">MSB4272: 環境變數 MSBUILDDISABLEFEATURESFROMVERSION 設為無法輪替的版本。預設為變更波段版本: {0}。輸入的值: {1}。目前的變更波段: {2}。</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -94,7 +94,7 @@
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
-        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <target state="translated">MSB4276: 預設的 SDK 解析程式無法解析 SDK "{0}"，因為目錄 "{1}" 不存在。</target>
         <note />
       </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
@@ -109,7 +109,7 @@
       </trans-unit>
       <trans-unit id="EnvironmentDerivedPropertyRead">
         <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <target state="translated">從環境展開值為 '{1}' 的屬性 '{0}'。</target>
         <note />
       </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
@@ -130,7 +130,7 @@
       <trans-unit id="FailedToResolveSDK">
         <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</source>
-        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+        <target state="translated">無法解析 SDK "{0}"。下面有一個確切探查訊息會指出無法解析 SDK 的原因。請調查並解析該訊息以正確指定 SDK。
   {1}</target>
         <note />
       </trans-unit>
@@ -156,7 +156,7 @@
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
         <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
-        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <target state="translated">MSB4120: 目標內的項目 '{0}' 定義透過 (限定或不限定) 中繼資料 '{1}' 參考本身。這可能會導致意外的擴充和交叉套用既有的項目。詳細資訊: https://aka.ms/msbuild/metadata-self-ref</target>
         <note>{StrBegin="MSB4120: "}</note>
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
@@ -166,7 +166,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="new">Loading the following project cache plugin: {0}</target>
+        <target state="translated">載入下列專案快取外掛程式: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -198,7 +198,7 @@
       </trans-unit>
       <trans-unit id="NodeReused">
         <source>Reusing node {0} (PID: {1}).</source>
-        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <target state="translated">重複使用節點 {0} (PID: {1})。</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -231,7 +231,7 @@
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="translated">MatchOnMetadata 無法在 &lt;目標&gt; 之外使用。</target>
+        <target state="translated">MatchOnMetadata 無法在 &lt;Target&gt; 之外使用。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -352,7 +352,7 @@
       </trans-unit>
       <trans-unit id="PropertyOutsidePropertyGroupInTarget">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
-        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <target state="translated">MSB4067: 無法辨識元素 &lt;{1}&gt; 下的元素 &lt;{0}&gt;。如果您想要將此項目設為屬性，請將它括在 &lt;PropertyGroup&gt; 元素內。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
@@ -372,7 +372,7 @@
       </trans-unit>
       <trans-unit id="SDKResolverReturnedNull">
         <source>SDK resolver "{0}" returned null.</source>
-        <target state="new">SDK resolver "{0}" returned null.</target>
+        <target state="translated">SDK 解析程式 "{0}" 傳回 Null。</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
@@ -428,7 +428,7 @@
       </trans-unit>
       <trans-unit id="TaskAssemblyLoaded">
         <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
-        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <target state="translated">組件在 {0}{1} 期間載入: {2} (位置: {3}，MVID: {4}，AppDomain: {5})</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
@@ -455,9 +455,9 @@
     </note>
       </trans-unit>
       <trans-unit id="UnhandledMSBuildError">
-        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled.
+        <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">這是 MSBuild 中未處理的例外狀況 -- 請針對現有的問題附議，或在 https://aka.ms/msbuild/unhandled 提交新的問題。
+        <target state="needs-review-translation">這是 MSBuild 中未處理的例外狀況 -- 請針對現有的問題附議，或在 https://aka.ms/msbuild/unhandled 提交新的問題。
     {0}</target>
         <note />
       </trans-unit>
@@ -1891,7 +1891,7 @@
       </trans-unit>
       <trans-unit id="WhenNotAllowedAfterOtherwise">
         <source>MSB4084: A &lt;When&gt; element may not follow an &lt;Otherwise&gt; element in a &lt;Choose&gt;.</source>
-        <target state="translated">MSB4084: 在 &lt;Choose&gt; 中，&lt;When&gt; 項目不能接在 &lt;Otherwise&gt; 項目後面。</target>
+        <target state="translated">MSB4084: 在 &lt;Choose&gt; 中，&lt;When&gt; 元素不能接在 &lt;Otherwise&gt; 元素後面。</target>
         <note>{StrBegin="MSB4084: "}</note>
       </trans-unit>
       <trans-unit id="MustCallInitializeBeforeApplyParameter">
diff --git a/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs b/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
index b9c06e9905e..0be6d375ffb 100644
--- a/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
+++ b/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
@@ -10,10 +10,10 @@ namespace Microsoft.Build.Internal;
 
 internal static class ReaderWriterLockSlimExtensions
 {
-    public static UpgradeableReadLockDisposer EnterDisposableUpgradeableReadLock(this ReaderWriterLockSlim rwLock)
+    public static DisposableReadLock EnterDisposableReadLock(this ReaderWriterLockSlim rwLock)
     {
-        rwLock.EnterUpgradeableReadLock();
-        return new UpgradeableReadLockDisposer(rwLock);
+        rwLock.EnterReadLock();
+        return new DisposableReadLock(rwLock);
     }
 
     public static DisposableWriteLock EnterDisposableWriteLock(this ReaderWriterLockSlim rwLock)
@@ -22,44 +22,21 @@ public static DisposableWriteLock EnterDisposableWriteLock(this ReaderWriterLock
         return new DisposableWriteLock(rwLock);
     }
 
-    // Officially, Dispose() being called more than once is allowable, but in this case if that were to happen
-    // that means something is very, very wrong. Since it's an internal type, better to be strict.
-
-    internal struct UpgradeableReadLockDisposer : IDisposable
+    internal readonly struct DisposableReadLock : IDisposable
     {
-        private ReaderWriterLockSlim? _rwLock;
-
-        public UpgradeableReadLockDisposer(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
-
-        public void Dispose()
-        {
-            var rwLockToDispose = Interlocked.Exchange(ref _rwLock, null);
+        private readonly ReaderWriterLockSlim _rwLock;
 
-            if (rwLockToDispose is null)
-            {
-                throw new ObjectDisposedException($"Somehow a {nameof(UpgradeableReadLockDisposer)} is being disposed twice.");
-            }
+        public DisposableReadLock(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
 
-            rwLockToDispose.ExitUpgradeableReadLock();
-        }
+        public void Dispose() => _rwLock.ExitReadLock();
     }
 
-    internal struct DisposableWriteLock : IDisposable
+    internal readonly struct DisposableWriteLock : IDisposable
     {
-        private ReaderWriterLockSlim? _rwLock;
+        private readonly ReaderWriterLockSlim _rwLock;
 
         public DisposableWriteLock(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
 
-        public void Dispose()
-        {
-            var rwLockToDispose = Interlocked.Exchange(ref _rwLock, null);
-
-            if (rwLockToDispose is null)
-            {
-                throw new ObjectDisposedException($"Somehow a {nameof(DisposableWriteLock)} is being disposed twice.");
-            }
-
-            rwLockToDispose.ExitWriteLock();
-        }
+        public void Dispose() => _rwLock.ExitWriteLock();
     }
 }
diff --git a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
index acd3388da81..8fc5e75a7b5 100644
--- a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
@@ -63,7 +63,7 @@ public XmlElementChildIterator GetEnumerator()
                 return this;
             }
 
-            public XmlElementWithLocation Current
+            public readonly XmlElementWithLocation Current
             {
                 get
                 {
@@ -73,7 +73,7 @@ public XmlElementWithLocation Current
                 }
             }
 
-            private XmlElementWithLocation GetNextNode(XmlNode child)
+            private readonly XmlElementWithLocation GetNextNode(XmlNode child)
             {
                 while (child != null)
                 {
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index 25667c21f6c..c5ef688824e 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -16,12 +17,17 @@ namespace Microsoft.Build.Internal
     /// <summary>
     /// Exception indicating that we tried to build a type of project MSBuild did not recognize.
     /// </summary>
-    internal sealed class UnbuildableProjectTypeException : Exception
+    internal sealed class UnbuildableProjectTypeException : BuildExceptionBase
     {
         internal UnbuildableProjectTypeException(string file)
             : base(file)
         {
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal UnbuildableProjectTypeException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 
     /// <summary>
diff --git a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
index 5a7f8163273..64fd843cc3b 100644
--- a/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
+++ b/src/Deprecated/Conversion.UnitTests/ProjectFileConverter_Tests.cs
@@ -1860,9 +1860,9 @@ public void ConvertEverettProjectWithSpecialCharaceters()
                                     HintPath = `D:\WINDOWS\Microsoft.NET\Framework\v1.1.4322\System.XML.dll`
                                 />
                                 <Reference
-                                    Name = `Microsoft.My'Crazy;Assemb%ly`
-                                    AssemblyName = `Microsoft.My'Crazy;Assemb%ly`
-                                    HintPath = `D:\myapps\Microsoft.My'Crazy;Assemb%ly.dll`
+                                    Name = `Microsoft.My'Different;Assemb%ly`
+                                    AssemblyName = `Microsoft.My'Different;Assemb%ly`
+                                    HintPath = `D:\myapps\Microsoft.My'Different;Assemb%ly.dll`
                                 />
                             </References>
                         </Build>
@@ -1954,9 +1954,9 @@ public void ConvertEverettProjectWithSpecialCharaceters()
                         <ErrorReport>prompt</ErrorReport>
                     </PropertyGroup>
                     <ItemGroup>
-                        <Reference Include=`Microsoft.My%27Crazy%3bAssemb%25ly`>
-                            <Name>Microsoft.My%27Crazy%3bAssemb%25ly</Name>
-                            <HintPath>D:\myapps\Microsoft.My%27Crazy%3bAssemb%25ly.dll</HintPath>
+                        <Reference Include=`Microsoft.My%27Different%3bAssemb%25ly`>
+                            <Name>Microsoft.My%27Different%3bAssemb%25ly</Name>
+                            <HintPath>D:\myapps\Microsoft.My%27Different%3bAssemb%25ly.dll</HintPath>
                         </Reference>
                         <Reference Include=`System`>
                             <Name>System</Name>
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
index a29a9aaf8a6..7367de52082 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/AddNewImport_Tests.cs
@@ -332,7 +332,7 @@ public void AddNewImportToBecomeSelfReferential()
                 InvokeAddNewImportMethod(p, projectPath, "true");
                 Assertion.AssertEquals(0, p.Imports.Count);
                 object o = p.EvaluatedItems;  // force evaluation of imported projects.
-                Assertion.AssertEquals(0, p.Imports.Count); // This is bonkers, should be 1 because the XML DOES contain the import node.
+                Assertion.AssertEquals(0, p.Imports.Count); // Should be 1 because the XML DOES contain the import node.
             }
             finally
             {
diff --git a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
index 6a7ee297fd3..78659e6084c 100644
--- a/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
+++ b/src/Deprecated/Engine.UnitTests/Compatibility/CompatibilityTestData.cs
@@ -150,7 +150,7 @@ internal static class TestData
         /// <summary>
         /// Test Data Item
         /// </summary>
-        internal const string ContentSimpleInvalidEncoding = @"<?xml version='1.0' encoding='crazy'?>
+        internal const string ContentSimpleInvalidEncoding = @"<?xml version='1.0' encoding='different'?>
                     <Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <Target Name='TestTarget'>
                             <Message Text='Executed TestTarget'/>
diff --git a/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs b/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs
index 19716b7d824..972fb0ebc53 100644
--- a/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EngineProxy_Tests.cs
@@ -213,8 +213,8 @@ public void CustomBuildErrorEventIsPreserved()
             engine.RegisterLogger(myLogger);
             // Create a custom build event args that derives from MSBuild's BuildErrorEventArgs.
             // Set a custom field on this event (FXCopRule).
-            MyCustomBuildErrorEventArgs fxcopError = new MyCustomBuildErrorEventArgs("Your code is lame.");
-            fxcopError.FXCopRule = "CodeLamenessViolation";
+            MyCustomBuildErrorEventArgs fxcopError = new MyCustomBuildErrorEventArgs("Your code is bad.");
+            fxcopError.FXCopRule = "CodeBadnessViolation";
 
             // Log the custom event args.  (Pretend that the task actually did this.)
             engineProxy.LogErrorEvent(fxcopError);
@@ -225,8 +225,8 @@ public void CustomBuildErrorEventIsPreserved()
 
             // Make sure the special fields in the custom event match what we originally logged.
             fxcopError = myLogger.lastError as MyCustomBuildErrorEventArgs;
-            Assertion.AssertEquals("Your code is lame.", fxcopError.Message);
-            Assertion.AssertEquals("CodeLamenessViolation", fxcopError.FXCopRule);
+            Assertion.AssertEquals("Your code is bad.", fxcopError.Message);
+            Assertion.AssertEquals("CodeBadnessViolation", fxcopError.FXCopRule);
         }
 
         /// <summary>
@@ -400,7 +400,7 @@ public void ContinueOnErrorShouldConvertErrorsToWarnings()
                     </Target>
 
                 </Project>
-        
+
                 ");
 
             Assertion.AssertEquals("Expected zero errors", 0, logger.ErrorCount);
@@ -426,8 +426,8 @@ public void IsRunningMultipleNodes()
             // Verify TEM is running singleProc mode before we can test to make sure EngineProxy is correctly using the value
             Assertion.Assert("Expected TEM to be running singleProcMode", taskExecutionModule.GetExecutionModuleMode() == TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode);
             Assertion.Assert("Expected EngineProxy for TEM running in singleProc mode to return false for IsRunningMultipleNodes", engineProxy.IsRunningMultipleNodes == false);
-            
-            // Verify TEM is running MultiProc mode before we can test to make sure EngineProxy is correctly using the value 
+
+            // Verify TEM is running MultiProc mode before we can test to make sure EngineProxy is correctly using the value
             TaskExecutionModule.TaskExecutionModuleMode moduleMode = taskExecutionModule2.GetExecutionModuleMode();
             Assertion.Assert("Expected TEM to be not be running SingleProcMode",moduleMode != TaskExecutionModule.TaskExecutionModuleMode.SingleProcMode);
             Assertion.Assert("Expected EngineProxy for TEM running in MultiProc mode to return true for IsRunningMultipleNodes", engineProxy2.IsRunningMultipleNodes);
@@ -620,7 +620,7 @@ public void UseSameProjectObjectIfChildIsEquivalent()
 
             //            string childProjectFullPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("child.proj", @"
             //                      <Project ToolsVersion='44.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
-            //                          <UsingTask TaskName='CreateItem' AssemblyName='Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+            //                          <UsingTask TaskName='CreateItem' AssemblyName='Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
             //                          <Target Name='BuildTarget'>
             //                              <CreateItem Include='BuildTargetRan'>
             //                                  <Output TaskParameter='Include' ItemName='BuildTargetRan'/>
diff --git a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
index 5904741689e..e724f3d0969 100644
--- a/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/EscapingInProjects_Tests.cs
@@ -752,13 +752,13 @@ public class Class1
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
-        /// have all sorts of crazy characters in their name (courtesy of DanMose who apparently
+        /// have all sorts of different characters in their name (courtesy of DanMose who apparently
         /// just ran his fingers up and down the on the upper row of his keyboard :) ).  There
         /// is even a P2P reference between the two projects in the .SLN.
         /// </summary>
         /// <owner>RGoel</owner>
         [Test]
-        public void SolutionWithLotsaCrazyCharacters()
+        public void SolutionWithLotsaDifferentCharacters()
         {
             if (ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35) == null)
             {
diff --git a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
index 5fd283b96b8..5338d973fe7 100644
--- a/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Lookup_Tests.cs
@@ -984,7 +984,7 @@ public void SetPropertyOnDifferentThread()
         }
 
         /// <summary>
-        /// Lame but simple way to get the lookup from another thread
+        /// Bad but simple way to get the lookup from another thread
         /// </summary>
         private static Lookup lookupPassedBetweenThreads;
 
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index 15f8d543192..fe15c1e9287 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -425,13 +425,13 @@ internal ItemsAndMetadataPair(Hashtable items, Dictionary<string, MetadataRefere
 
         internal Hashtable Items
         {
-            get { return items; }
+            readonly get { return items; }
             set { items = value; }
         }
 
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get { return metadata; }
+            readonly get { return metadata; }
             set { metadata = value; }
         }
     }
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index f7fd9fdf988..1f574b8af5e 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -117,7 +117,6 @@ public override void Initialize(IEventSource eventSource, int nodeCount)
         /// <summary>
         /// The handler for the write delegate of the console logger we are deriving from.
         /// </summary>
-        /// <owner>KieranMo</owner>
         /// <param name="text">The text to write to the log</param>
         private void Write(string text)
         {
@@ -143,7 +142,6 @@ private void Write(string text)
         /// <summary>
         /// Shutdown method implementation of ILogger - we need to flush and close our logfile.
         /// </summary>
-        /// <owner>KieranMo</owner>
         public override void Shutdown()
         {
             fileWriter?.Close();
@@ -152,7 +150,6 @@ public override void Shutdown()
         /// <summary>
         /// Parses out the logger parameters from the Parameters string.
         /// </summary>
-        /// <owner>KieranMo</owner>
         private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
@@ -180,7 +177,6 @@ private void ParseFileLoggerParameters()
         /// <summary>
         /// Apply a parameter parsed by the file logger.
         /// </summary>
-        /// <owner>KieranMo</owner>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
             switch (parameterName.ToUpperInvariant())
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf
index c4dc32ae020..5505503def8 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.es.xlf
@@ -1963,7 +1963,7 @@
       </trans-unit>
       <trans-unit id="STARequired">
         <source>MSB4056: The MSBuild engine must be called on a single-threaded-apartment. Current threading model is "{0}". Proceeding, but some tasks may not function correctly.</source>
-        <target state="translated">MSB4056: Se debe llamar al motor de MSBuild en Singlethread-Apartment. El modelo de subprocesos actual es '"{0}". El proceso continúa, pero es posible que algunas tareas no funcionen correctamente.</target>
+        <target state="translated">MSB4056: Se debe llamar al motor de MSBuild en Singlethread-Apartment. El modelo de subprocesos actual es "{0}". El proceso continúa, pero es posible que algunas tareas no funcionen correctamente.</target>
         <note>{StrBegin="MSB4056: "}</note>
         <alt-trans match-quality="100%" tool="BlackBox/MSR MT">
           <target state-qualifier="tm-suggestion">MSB4056: Das MSBuild-Modul muss in einem Singlethread-Apartment aufgerufen werden. Das aktuelle Threadmodell ist {0}. Der Vorgang wird fortgesetzt, aber einige Aufgaben werden möglicherweise nicht ordnungsgemäß ausgeführt.</target>
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
index 9d065a332ba..250ba817679 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
@@ -2419,7 +2419,7 @@
       </trans-unit>
       <trans-unit id="WhenNotAllowedAfterOtherwise">
         <source>MSB4084: A &lt;When&gt; element may not follow an &lt;Otherwise&gt; element in a &lt;Choose&gt;.</source>
-        <target state="translated">MSB4084: 在 &lt;Choose&gt; 中，&lt;When&gt; 項目不能接在 &lt;Otherwise&gt; 項目後面。</target>
+        <target state="translated">MSB4084: 在 &lt;Choose&gt; 中，&lt;When&gt; 元素不能接在 &lt;Otherwise&gt; 元素後面。</target>
         <note>{StrBegin="MSB4084: "}</note>
         <alt-trans match-quality="100%" tool="BlackBox/MSR MT">
           <target state-qualifier="mt-suggestion">MSB4084: A &lt; &gt;-Element kein Element &lt; Otherwise &gt; &lt; auswählen &gt; folgen.</target>
diff --git a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
index 42750cc2964..1d28600ad11 100644
--- a/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Deprecated/Engine/Shared/UnitTests/ObjectModelHelpers.cs
@@ -290,7 +290,7 @@ static internal void AssertItemsMatch(string expectedItemsString, ITaskItem[] ac
         }
 
         /// <summary>
-        /// Parses the crazy string passed into AssertItemsMatch and returns a list of ITaskItems.
+        /// Parses the different string passed into AssertItemsMatch and returns a list of ITaskItems.
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <returns></returns>
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index f6809d2e4bf..fd9dc2a5974 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -15,7 +15,7 @@
     <!-- Ensure that compiler errors emit full paths so that files
          can be correctly annotated in GitHub. -->
     <GenerateFullPaths>true</GenerateFullPaths>
-    
+
     <!-- https://github.com/NuGet/Home/issues/8684 -->
     <NoWarn>$(NoWarn);NU5131</NoWarn>
 
@@ -36,7 +36,7 @@
     <PlatformTarget>AnyCPU</PlatformTarget>
 
     <!-- Target frameworks for Exe and unit test projects (ie projects with runtime output) -->
-    <RuntimeOutputTargetFrameworks>net7.0</RuntimeOutputTargetFrameworks>
+    <RuntimeOutputTargetFrameworks>$(LatestDotNetCoreForMSBuild)</RuntimeOutputTargetFrameworks>
     <RuntimeOutputTargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);$(RuntimeOutputTargetFrameworks)</RuntimeOutputTargetFrameworks>
     <RuntimeOutputTargetFrameworks Condition="'$(MonoBuild)' == 'true'">$(FullFrameworkTFM)</RuntimeOutputTargetFrameworks>
 
diff --git a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
index 8e2bf7db11b..f0cdf2232cd 100644
--- a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
@@ -29,7 +29,8 @@ public void SerializationDeserializationTest()
             stream.Position = 0;
             using BinaryReader br = new BinaryReader(stream);
             AssemblyLoadBuildEventArgs argDeserialized = new();
-            argDeserialized.CreateFromStream(br, 0);
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+            argDeserialized.CreateFromStream(br, packetVersion);
 
             argDeserialized.LoadingInitiator.ShouldBe(loadingInitiator);
             argDeserialized.AssemblyName.ShouldBe(assemblyName);
@@ -37,6 +38,7 @@ public void SerializationDeserializationTest()
             argDeserialized.MVID.ShouldBe(mvid);
             argDeserialized.AppDomainDescriptor.ShouldBe(appDomainName);
             argDeserialized.LoadingContext.ShouldBe(context);
+            argDeserialized.Importance.ShouldBe(arg.Importance);
         }
     }
 }
diff --git a/src/Framework/AssemblyLoadBuildEventArgs.cs b/src/Framework/AssemblyLoadBuildEventArgs.cs
index bb9d8e58e6f..4c6c8292cbc 100644
--- a/src/Framework/AssemblyLoadBuildEventArgs.cs
+++ b/src/Framework/AssemblyLoadBuildEventArgs.cs
@@ -24,7 +24,7 @@ public AssemblyLoadBuildEventArgs(
             Guid mvid,
             string? customAppDomainDescriptor,
             MessageImportance importance = MessageImportance.Low)
-            : base(null, null, null, importance, DateTime.UtcNow, assemblyName, assemblyPath, mvid)
+            : base(null, null, null, importance, DateTime.UtcNow, null)
         {
             LoadingContext = loadingContext;
             LoadingInitiator = loadingInitiator;
@@ -44,6 +44,8 @@ public AssemblyLoadBuildEventArgs(
 
         internal override void WriteToStream(BinaryWriter writer)
         {
+            base.WriteToStream(writer);
+
             writer.Write7BitEncodedInt((int)LoadingContext);
             writer.WriteTimestamp(RawTimestamp);
             writer.WriteOptionalBuildEventContext(BuildEventContext);
@@ -56,6 +58,8 @@ internal override void WriteToStream(BinaryWriter writer)
 
         internal override void CreateFromStream(BinaryReader reader, int version)
         {
+            base.CreateFromStream(reader, version);
+
             LoadingContext = (AssemblyLoadingContext)reader.Read7BitEncodedInt();
             RawTimestamp = reader.ReadTimestamp();
             BuildEventContext = reader.ReadOptionalBuildEventContext();
diff --git a/src/Framework/BinaryReaderFactory.cs b/src/Framework/BinaryReaderFactory.cs
new file mode 100644
index 00000000000..5cc76fe84ea
--- /dev/null
+++ b/src/Framework/BinaryReaderFactory.cs
@@ -0,0 +1,14 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.IO;
+
+namespace Microsoft.Build;
+
+/// <summary>
+/// Opaque holder of shared buffer.
+/// </summary>
+internal abstract class BinaryReaderFactory
+{
+    public abstract BinaryReader Create(Stream stream);
+}
diff --git a/src/Shared/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
similarity index 97%
rename from src/Shared/BinaryTranslator.cs
rename to src/Framework/BinaryTranslator.cs
index 055d34bb141..a2eab07d302 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -8,7 +8,7 @@
 using System.IO;
 using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -22,14 +22,16 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal static class BinaryTranslator
     {
+#nullable enable
         /// <summary>
         /// Returns a read-only serializer.
         /// </summary>
         /// <returns>The serializer.</returns>
-        internal static ITranslator GetReadTranslator(Stream stream, SharedReadBuffer buffer)
+        internal static ITranslator GetReadTranslator(Stream stream, BinaryReaderFactory buffer)
         {
             return new BinaryReadTranslator(stream, buffer);
         }
+#nullable disable
 
         /// <summary>
         /// Returns a write-only serializer.
@@ -56,14 +58,16 @@ private class BinaryReadTranslator : ITranslator
             /// </summary>
             private BinaryReader _reader;
 
+#nullable enable
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
             /// </summary>
-            public BinaryReadTranslator(Stream packetStream, SharedReadBuffer buffer)
+            public BinaryReadTranslator(Stream packetStream, BinaryReaderFactory buffer)
             {
                 _packetStream = packetStream;
-                _reader = InterningBinaryReader.Create(packetStream, buffer);
+                _reader = buffer.Create(packetStream);
             }
+#nullable disable
 
             /// <summary>
             /// Delegates the Dispose call the to the underlying BinaryReader.
@@ -88,7 +92,7 @@ public BinaryWriter Writer
             {
                 get
                 {
-                    ErrorUtilities.ThrowInternalError("Cannot get writer from reader.");
+                    EscapeHatches.ThrowInternalError("Cannot get writer from reader.");
                     return null;
                 }
             }
@@ -477,7 +481,18 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                TranslateDotNet<Exception>(ref value);
+                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+                {
+                    TranslateDotNet<Exception>(ref value);
+                    return;
+                }
+
+                if (!TranslateNullable(value))
+                {
+                    return;
+                }
+
+                value = BuildExceptionBase.ReadExceptionFromTranslator(this);
             }
 
 
@@ -761,7 +776,7 @@ public BinaryReader Reader
             {
                 get
                 {
-                    ErrorUtilities.ThrowInternalError("Cannot get reader from writer.");
+                    EscapeHatches.ThrowInternalError("Cannot get reader from writer.");
                     return null;
                 }
             }
@@ -1100,7 +1115,18 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                TranslateDotNet<Exception>(ref value);
+                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+                {
+                    TranslateDotNet<Exception>(ref value);
+                    return;
+                }
+
+                if (!TranslateNullable(value))
+                {
+                    return;
+                }
+
+                BuildExceptionBase.WriteExceptionToTranslator(this, value);
             }
 
             /// <summary>
diff --git a/src/Framework/BuildEngineResult.cs b/src/Framework/BuildEngineResult.cs
index 9bb2a0c0b08..4371726a8a3 100644
--- a/src/Framework/BuildEngineResult.cs
+++ b/src/Framework/BuildEngineResult.cs
@@ -42,7 +42,7 @@ public BuildEngineResult(bool result, List<IDictionary<string, ITaskItem[]>> tar
         /// <summary>
         /// Did the build pass or fail. True means the build succeeded, False means the build failed.
         /// </summary>
-        public bool Result
+        public readonly bool Result
         {
             get
             {
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
new file mode 100644
index 00000000000..acb93434e0e
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -0,0 +1,154 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+public abstract class BuildExceptionBase : Exception
+{
+    private string? _remoteTypeName;
+    private string? _remoteStackTrace;
+
+    private protected BuildExceptionBase()
+        : base()
+    { }
+
+    private protected BuildExceptionBase(string message)
+        : base(message)
+    { }
+
+    private protected BuildExceptionBase(
+        string message,
+        Exception? inner)
+        : base(message, inner)
+    { }
+
+    // This is needed to allow opting back in to BinaryFormatter serialization
+    private protected BuildExceptionBase(SerializationInfo info, StreamingContext context)
+        : base(info, context)
+    { }
+
+    public override string? StackTrace => string.IsNullOrEmpty(_remoteStackTrace) ? base.StackTrace : _remoteStackTrace;
+
+    public override string ToString() => string.IsNullOrEmpty(_remoteTypeName) ? base.ToString() : $"{_remoteTypeName}->{base.ToString()}";
+
+    /// <summary>
+    /// Override this method to recover subtype-specific state from the remote exception.
+    /// </summary>
+    protected virtual void InitializeCustomState(IDictionary<string, string?>? customKeyedSerializedData)
+    { }
+
+    /// <summary>
+    /// Override this method to provide subtype-specific state to be serialized.
+    /// </summary>
+    /// <returns></returns>
+    protected virtual IDictionary<string, string?>? FlushCustomState()
+    {
+        return null;
+    }
+
+    private void InitializeFromRemoteState(BuildExceptionRemoteState remoteState)
+    {
+        _remoteTypeName = remoteState.RemoteTypeName;
+        _remoteStackTrace = remoteState.RemoteStackTrace;
+        base.Source = remoteState.Source;
+        base.HelpLink = remoteState.HelpLink;
+        base.HResult = remoteState.HResult;
+        if (remoteState.Source != null)
+        {
+            InitializeCustomState(remoteState.CustomKeyedSerializedData);
+        }
+    }
+
+    internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)
+    {
+        BinaryWriter writer = translator.Writer;
+        writer.Write(exception.InnerException != null);
+        if (exception.InnerException != null)
+        {
+            WriteExceptionToTranslator(translator, exception.InnerException);
+        }
+
+        string serializationType = BuildExceptionSerializationHelper.GetExceptionSerializationKey(exception.GetType());
+        writer.Write(serializationType);
+        writer.Write(exception.Message);
+        writer.WriteOptionalString(exception.StackTrace);
+        writer.WriteOptionalString(exception.Source);
+        writer.WriteOptionalString(exception.HelpLink);
+        // HResult is completely protected up till net4.5
+#if NET || NET45_OR_GREATER
+        int? hresult = exception.HResult;
+#else
+            int? hresult = null;
+#endif
+        writer.WriteOptionalInt32(hresult);
+
+        IDictionary<string, string?>? customKeyedSerializedData = (exception as BuildExceptionBase)?.FlushCustomState();
+        if (customKeyedSerializedData == null)
+        {
+            writer.Write((byte)0);
+        }
+        else
+        {
+            writer.Write((byte)1);
+            writer.Write(customKeyedSerializedData.Count);
+            foreach (var pair in customKeyedSerializedData)
+            {
+                writer.Write(pair.Key);
+                writer.WriteOptionalString(pair.Value);
+            }
+        }
+
+        Debug.Assert((exception.Data?.Count ?? 0) == 0,
+            "Exception Data is not supported in BuildTransferredException");
+    }
+
+    internal static Exception ReadExceptionFromTranslator(ITranslator translator)
+    {
+        BinaryReader reader = translator.Reader;
+        Exception? innerException = null;
+        if (reader.ReadBoolean())
+        {
+            innerException = ReadExceptionFromTranslator(translator);
+        }
+
+        string serializationType = reader.ReadString();
+        string message = reader.ReadString();
+        string? deserializedStackTrace = reader.ReadOptionalString();
+        string? source = reader.ReadOptionalString();
+        string? helpLink = reader.ReadOptionalString();
+        int hResult = reader.ReadOptionalInt32();
+
+        IDictionary<string, string?>? customKeyedSerializedData = null;
+        if (reader.ReadByte() == 1)
+        {
+            int count = reader.ReadInt32();
+            customKeyedSerializedData = new Dictionary<string, string?>(count, StringComparer.CurrentCulture);
+
+            for (int i = 0; i < count; i++)
+            {
+                customKeyedSerializedData[reader.ReadString()] = reader.ReadOptionalString();
+            }
+        }
+
+        BuildExceptionBase exception = BuildExceptionSerializationHelper.CreateExceptionFactory(serializationType)(message, innerException);
+
+        exception.InitializeFromRemoteState(
+            new BuildExceptionRemoteState(
+                serializationType,
+                deserializedStackTrace,
+                source,
+                helpLink,
+                hResult,
+                customKeyedSerializedData));
+
+        return exception;
+    }
+}
diff --git a/src/Framework/BuildException/BuildExceptionRemoteState.cs b/src/Framework/BuildException/BuildExceptionRemoteState.cs
new file mode 100644
index 00000000000..b4d8786f43d
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionRemoteState.cs
@@ -0,0 +1,35 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+/// <summary>
+/// Remote exception internal data serving as the source for the exception deserialization.
+/// </summary>
+internal class BuildExceptionRemoteState
+{
+    public BuildExceptionRemoteState(
+        string remoteTypeName,
+        string? remoteStackTrace,
+        string? source,
+        string? helpLink,
+        int hResult,
+        IDictionary<string, string?>? customKeyedSerializedData)
+    {
+        RemoteTypeName = remoteTypeName;
+        RemoteStackTrace = remoteStackTrace;
+        Source = source;
+        HelpLink = helpLink;
+        HResult = hResult;
+        CustomKeyedSerializedData = customKeyedSerializedData;
+    }
+
+    public string RemoteTypeName { get; init; }
+    public string? RemoteStackTrace { get; init; }
+    public string? Source { get; init; }
+    public string? HelpLink { get; init; }
+    public int HResult { get; init; }
+    public IDictionary<string, string?>? CustomKeyedSerializedData { get; init; }
+}
diff --git a/src/Framework/BuildException/BuildExceptionSerializationHelper.cs b/src/Framework/BuildException/BuildExceptionSerializationHelper.cs
new file mode 100644
index 00000000000..030fd532e00
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionSerializationHelper.cs
@@ -0,0 +1,91 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Threading;
+
+namespace Microsoft.Build.Framework.BuildException
+{
+    internal static class BuildExceptionSerializationHelper
+    {
+        public class TypeConstructionTuple
+        {
+            public TypeConstructionTuple(Type type, Func<string, Exception?, BuildExceptionBase> factory)
+            {
+                Type = type;
+                Factory = factory;
+            }
+
+            public Type Type { get; }
+            public Func<string, Exception?, BuildExceptionBase> Factory { get; }
+        }
+
+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>>? s_exceptionFactories;
+
+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =
+            (message, innerException) => new GenericBuildTransferredException(message, innerException);
+
+        internal static bool IsSupportedExceptionType(Type type)
+        {
+            return type.IsClass &&
+                   !type.IsAbstract &&
+                   type.IsSubclassOf(typeof(Exception)) &&
+                   type.IsSubclassOf(typeof(BuildExceptionBase));
+        }
+
+        internal static void InitializeSerializationContract(params TypeConstructionTuple[] exceptionsAllowlist)
+        {
+            InitializeSerializationContract((IEnumerable<TypeConstructionTuple>)exceptionsAllowlist);
+        }
+
+        internal static void InitializeSerializationContract(IEnumerable<TypeConstructionTuple> exceptionsAllowlist)
+        {
+            if (s_exceptionFactories != null)
+            {
+                return;
+            }
+
+            var exceptionFactories = new Dictionary<string, Func<string, Exception?, BuildExceptionBase>>();
+
+            foreach (TypeConstructionTuple typeConstructionTuple in exceptionsAllowlist)
+            {
+                Type exceptionType = typeConstructionTuple.Type;
+                Func<string, Exception?, BuildExceptionBase> exceptionFactory = typeConstructionTuple.Factory;
+
+                if (!IsSupportedExceptionType(exceptionType))
+                {
+                    EscapeHatches.ThrowInternalError($"Type {exceptionType.FullName} is not recognized as a build exception type.");
+                }
+
+                string key = GetExceptionSerializationKey(exceptionType);
+                exceptionFactories[key] = exceptionFactory;
+            }
+
+            if (Interlocked.Exchange(ref s_exceptionFactories, exceptionFactories) != null)
+            {
+                EscapeHatches.ThrowInternalError("Serialization contract was already initialized.");
+            }
+        }
+
+        internal static string GetExceptionSerializationKey(Type exceptionType)
+        {
+            return exceptionType.FullName ?? exceptionType.ToString();
+        }
+
+        internal static Func<string, Exception?, BuildExceptionBase> CreateExceptionFactory(string serializationType)
+        {
+            Func<string, Exception?, BuildExceptionBase>? factory = null;
+            if (s_exceptionFactories == null)
+            {
+                EscapeHatches.ThrowInternalError("Serialization contract was not initialized.");
+            }
+            else
+            {
+                s_exceptionFactories.TryGetValue(serializationType, out factory);
+            }
+
+            return factory ?? s_defaultFactory;
+        }
+    }
+}
diff --git a/src/Framework/BuildException/GenericBuildTransferredException.cs b/src/Framework/BuildException/GenericBuildTransferredException.cs
new file mode 100644
index 00000000000..0c0261c80d5
--- /dev/null
+++ b/src/Framework/BuildException/GenericBuildTransferredException.cs
@@ -0,0 +1,22 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+/// <summary>
+/// A catch-all type for remote exceptions that we don't know how to deserialize.
+/// </summary>
+internal sealed class GenericBuildTransferredException : BuildExceptionBase
+{
+    public GenericBuildTransferredException()
+        : base()
+    { }
+
+    internal GenericBuildTransferredException(
+        string message,
+        Exception? inner)
+        : base(message, inner)
+    { }
+}
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 2af7392c4d2..00507237987 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -24,10 +24,10 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave17_2 = new Version(17, 2);
         internal static readonly Version Wave17_4 = new Version(17, 4);
         internal static readonly Version Wave17_6 = new Version(17, 6);
-        internal static readonly Version[] AllWaves = { Wave17_2, Wave17_4, Wave17_6 };
+        internal static readonly Version Wave17_8 = new Version(17, 8);
+        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
@@ -125,7 +125,7 @@ internal static void ApplyChangeWave()
                 ConversionState = ChangeWaveConversionState.Valid;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (!Version.TryParse(msbuildDisableFeaturesFromVersion, out _cachedWave))
+            else if (!TryParseVersion(msbuildDisableFeaturesFromVersion, out _cachedWave))
             {
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
@@ -173,5 +173,23 @@ internal static void ResetStateForTests()
             _cachedWave = null;
             _state = ChangeWaveConversionState.NotConvertedYet;
         }
+
+        private static bool TryParseVersion(string stringVersion, out Version version)
+        {
+#if FEATURE_NET35_TASKHOST
+            try
+            {
+                version = new Version(stringVersion);
+                return true;
+            }
+            catch (Exception)
+            {
+                version = null;
+                return false;
+            }
+#else
+            return Version.TryParse(stringVersion, out version);
+#endif
+        }
     }
 }
diff --git a/src/Framework/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
index 9ad987bd730..298c740da96 100644
--- a/src/Framework/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -3,11 +3,15 @@
 
 using System;
 using System.Diagnostics;
+using System.Globalization;
 using System.IO;
 using System.Linq;
+using System.Runtime.InteropServices;
+using System.Security;
 using System.Text;
 
 using Microsoft.Build.Framework;
+using Microsoft.Win32;
 
 #nullable disable
 
@@ -247,5 +251,96 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
                         : EncodingUtilities.Utf8WithoutBom;
             }
         }
+#nullable enable
+        /// <summary>
+        /// The .NET SDK and Visual Studio both have environment variables that set a custom language. MSBuild should respect the SDK variable.
+        /// To use the corresponding UI culture, in certain cases the console encoding must be changed. This function will change the encoding in these cases.
+        /// This code introduces a breaking change in .NET 8 due to the encoding of the console being changed.
+        /// If the environment variables are undefined, this function should be a no-op.
+        /// </summary>
+        /// <returns>
+        /// The custom language that was set by the user for an 'external' tool besides MSBuild.
+        /// Returns <see langword="null"/> if none are set.
+        /// </returns>
+        public static CultureInfo? GetExternalOverriddenUILanguageIfSupportableWithEncoding()
+        {
+            if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+            {
+                return null;
+            }
+
+            CultureInfo? externalLanguageSetting = GetExternalOverriddenUILanguage();
+            if (externalLanguageSetting != null)
+            {
+                if (
+                    !externalLanguageSetting.TwoLetterISOLanguageName.Equals("en", StringComparison.InvariantCultureIgnoreCase) &&
+                    CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding()
+                    )
+                {
+                    // Setting both encodings causes a change in the CHCP, making it so we don't need to P-Invoke CHCP ourselves.
+                    Console.OutputEncoding = Encoding.UTF8;
+                    // If the InputEncoding is not set, the encoding will work in CMD but not in PowerShell, as the raw CHCP page won't be changed.
+                    Console.InputEncoding = Encoding.UTF8;
+                    return externalLanguageSetting;
+                }
+                else if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+                {
+                    return externalLanguageSetting;
+                }
+            }
+
+            return null;
+        }
+
+        public static bool CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding()
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && Environment.OSVersion.Version.Major >= 10) // UTF-8 is only officially supported on 10+.
+            {
+                try
+                {
+                    using RegistryKey? windowsVersionRegistry = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion");
+                    string? buildNumber = windowsVersionRegistry?.GetValue("CurrentBuildNumber")?.ToString();
+                    const int buildNumberThatOfficiallySupportsUTF8 = 18363;
+                    return buildNumber != null && (int.Parse(buildNumber) >= buildNumberThatOfficiallySupportsUTF8 || ForceUniversalEncodingOptInEnabled());
+                }
+                catch (Exception ex) when (ex is SecurityException or ObjectDisposedException)
+                {
+                    // We don't want to break those in VS on older versions of Windows with a non-en language.
+                    // Allow those without registry permissions to force the encoding, however.
+                    return ForceUniversalEncodingOptInEnabled();
+                }
+            }
+
+            return false;
+        }
+
+        private static bool ForceUniversalEncodingOptInEnabled()
+        {
+            return string.Equals(Environment.GetEnvironmentVariable("DOTNET_CLI_FORCE_UTF8_ENCODING"), "true", StringComparison.OrdinalIgnoreCase);
+        }
+
+        /// <summary>
+        /// Look at UI language overrides that can be set by known external invokers. (DOTNET_CLI_UI_LANGUAGE.)
+        /// Does NOT check System Locale or OS Display Language.
+        /// Ported from the .NET SDK: https://github.com/dotnet/sdk/blob/bcea1face15458814b8e53e8785b52ba464f6538/src/Cli/Microsoft.DotNet.Cli.Utils/UILanguageOverride.cs
+        /// </summary>
+        /// <returns>The custom language that was set by the user for an 'external' tool besides MSBuild.
+        /// Returns null if none are set.</returns>
+        private static CultureInfo? GetExternalOverriddenUILanguage()
+        {
+            // DOTNET_CLI_UI_LANGUAGE=<culture name> is the main way for users to customize the CLI's UI language via the .NET SDK.
+            string? dotnetCliLanguage = Environment.GetEnvironmentVariable("DOTNET_CLI_UI_LANGUAGE");
+            if (dotnetCliLanguage != null)
+            {
+                try
+                {
+                    return new CultureInfo(dotnetCliLanguage);
+                }
+                catch (CultureNotFoundException) { }
+            }
+
+            return null;
+        }
     }
 }
+
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 7270bb0b681..271bc7d33c7 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -24,7 +24,7 @@ public abstract class EngineServices
         /// An explicit version of this class. Must be incremented whenever new members are added. Derived classes should override
         /// the property to return the version actually being implemented.
         /// </summary>
-        public virtual int Version => Version1; // Not updated since we have not shipped 17.0 yet. This comment is meant to bypass RequiredVersionBumps check in build.ps1 for PR #8336. If the changes in the file are cosmetic, change PR# in this comment to silence the build error on CI build.
+        public virtual int Version => Version1; // Not updated since we have not shipped 17.0 yet. This comment is meant to bypass RequiredVersionBumps check in build.ps1 for PR #470646. If the changes in the file are cosmetic, change PR# in this comment to silence the build error on CI build.
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
diff --git a/src/Shared/ITranslatable.cs b/src/Framework/ITranslatable.cs
similarity index 100%
rename from src/Shared/ITranslatable.cs
rename to src/Framework/ITranslatable.cs
diff --git a/src/Shared/ITranslator.cs b/src/Framework/ITranslator.cs
similarity index 100%
rename from src/Shared/ITranslator.cs
rename to src/Framework/ITranslator.cs
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index 86383e09bbb..4aef7c049ea 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Diagnostics;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -15,7 +16,7 @@ namespace Microsoft.Build.Framework
     /// did wrong.
     /// </summary>
     [Serializable]
-    internal sealed class InternalErrorException : Exception
+    internal sealed class InternalErrorException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -45,9 +46,27 @@ internal InternalErrorException(
         internal InternalErrorException(
             String message,
             Exception innerException) :
-            base("MSB0001: Internal MSBuild Error: " + message + (innerException == null ? String.Empty : ("\n=============\n" + innerException.ToString() + "\n\n")), innerException)
+            this(message, innerException, false)
+        { }
+
+        internal static InternalErrorException CreateFromRemote(string message, Exception innerException)
+        {
+            return new InternalErrorException(message, innerException, true /* calledFromDeserialization */);
+        }
+
+        private InternalErrorException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : "MSB0001: Internal MSBuild Error: " + message + (innerException == null
+                        ? String.Empty
+                        : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                innerException)
         {
-            ConsiderDebuggerLaunch(message, innerException);
+            if (!calledFromDeserialization)
+            {
+                ConsiderDebuggerLaunch(message, innerException);
+            }
         }
 
         #region Serialization (update when adding new class members)
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index ba423ceba87..a671142368a 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions; // for SecurityPermissionAttribute
 #endif
@@ -20,7 +22,7 @@ namespace Microsoft.Build.Framework
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public class LoggerException : Exception
+    public class LoggerException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -104,6 +106,21 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("helpKeyword", helpKeyword);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+        }
+
         #endregion
 
         #region Properties
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index dbf6df5b071..29e9e67abfb 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -316,7 +316,7 @@ public void ParseStop(string projectFileName)
         }
 
         /// <summary>
-        /// Call this method to notify listeners of profiling for the method that removes blacklisted references from the reference table. It puts primary and dependency references in invalid file lists.
+        /// Call this method to notify listeners of profiling for the method that removes denylisted references from the reference table. It puts primary and dependency references in invalid file lists.
         /// </summary>
         [Event(35, Keywords = Keywords.All)]
         public void RarRemoveReferencesMarkedForExclusionStart()
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 03a978ad042..c71d9f49ff6 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -345,7 +345,7 @@ private struct PROCESS_BASIC_INFORMATION
         public UIntPtr UniqueProcessId;
         public UIntPtr InheritedFromUniqueProcessId;
 
-        public uint Size
+        public readonly uint Size
         {
             get
             {
@@ -1531,6 +1531,8 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         {
             // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
             acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
+            // It wasn't redirected as tested above so we assume output is screen/console
+            outputIsScreen = true; 
         }
         return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
     }
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index 43dc75bf28d..9f8f95ee9a6 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -101,7 +101,7 @@ public struct EvaluationLocation
         public EvaluationLocationKind Kind { get; }
 
         /// <nodoc/>
-        public bool IsEvaluationPass => File == null;
+        public readonly bool IsEvaluationPass => File == null;
 
         /// <nodoc/>
         public static EvaluationLocation CreateLocationForCondition(long? parentId, EvaluationPass evaluationPass, string evaluationDescription, string file,
@@ -183,7 +183,7 @@ public EvaluationLocation(EvaluationPass evaluationPass, string evaluationPassDe
         public static EvaluationLocation EmptyLocation { get; } = CreateEmptyLocation();
 
         /// <nodoc/>
-        public EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
+        public readonly EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
         {
             return new EvaluationLocation(this.Id, evaluationPass, passDescription ?? PassDefaultDescription[evaluationPass],
                 this.File, this.Line, this.ElementName, this.ElementDescription, this.Kind);
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 7a4db37105c..871d648e4ea 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Globalization;
 
 #nullable disable
 
@@ -474,7 +475,7 @@ public enum SdkReferencePropertyExpansionMode
         /// then we can give them this undocumented environment variable as an immediate workaround.
         /// </summary>
         /// <remarks>
-        /// Clone from ErrorUtilities which isn't (yet?) available in Framework.
+        /// Clone from ErrorUtilities which isn't available in Framework.
         /// </remarks>
         private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
 
@@ -482,7 +483,7 @@ public enum SdkReferencePropertyExpansionMode
         /// Throws InternalErrorException.
         /// </summary>
         /// <remarks>
-        /// Clone of ErrorUtilities.ThrowInternalError which isn't (yet?) available in Framework.
+        /// Clone of ErrorUtilities.ThrowInternalError which isn't available in Framework.
         /// </remarks>
         internal static void ThrowInternalError(string message)
         {
@@ -491,5 +492,66 @@ internal static void ThrowInternalError(string message)
                 throw new InternalErrorException(message);
             }
         }
+
+        /// <summary>
+        /// Throws InternalErrorException.
+        /// This is only for situations that would mean that there is a bug in MSBuild itself.
+        /// </summary>
+        /// <remarks>
+        /// Clone from ErrorUtilities which isn't available in Framework.
+        /// </remarks>
+        internal static void ThrowInternalError(string message, params object[] args)
+        {
+            if (s_throwExceptions)
+            {
+                throw new InternalErrorException(FormatString(message, args));
+            }
+        }
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// 
+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// 
+        /// Thread safe.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="args">Optional arguments for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        /// <remarks>
+        /// Clone from ResourceUtilities which isn't available in Framework.
+        /// </remarks>
+        internal static string FormatString(string unformatted, params object[] args)
+        {
+            string formatted = unformatted;
+
+            // NOTE: String.Format() does not allow a null arguments array
+            if ((args?.Length > 0))
+            {
+#if DEBUG
+                // If you accidentally pass some random type in that can't be converted to a string, 
+                // FormatResourceString calls ToString() which returns the full name of the type!
+                foreach (object param in args)
+                {
+                    // Check it has a real implementation of ToString() and the type is not actually System.String
+                    if (param != null)
+                    {
+                        if (string.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal) &&
+                            param.GetType() != typeof(string))
+                        {
+                            ThrowInternalError("Invalid resource parameter type, was {0}",
+                                param.GetType().FullName);
+                        }
+                    }
+                }
+#endif
+                // Format the string, using the variable arguments passed in.
+                // NOTE: all String methods are thread-safe
+                formatted = String.Format(CultureInfo.CurrentCulture, unformatted, args);
+            }
+
+            return formatted;
+        }
     }
 }
diff --git a/src/MSBuild.UnitTests/LiveLogger_Tests.cs b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
index b8f2fba7ec8..1a359d69aad 100644
--- a/src/MSBuild.UnitTests/LiveLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
@@ -4,33 +4,60 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
+using System.IO;
+using System.Text.RegularExpressions;
+using System.Threading;
+using System.Threading.Tasks;
+
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging.LiveLogger;
-using Shouldly;
+
+using VerifyTests;
+using VerifyXunit;
 using Xunit;
 
+using static VerifyXunit.Verifier;
+
 namespace Microsoft.Build.UnitTests
 {
+    [UsesVerify]
     public class LiveLogger_Tests : IEventSource, IDisposable
     {
         private const int _nodeCount = 8;
-        private const int _terminalWidth = 80;
-        private const int _terminalHeight = 40;
         private const string _eventSender = "Test";
-        private const string _projectFile = @"C:\src\project.proj";
+        private readonly string _projectFile = NativeMethods.IsUnixLike ? "/src/project.proj" : @"C:\src\project.proj";
 
-        private readonly MockTerminal _mockTerminal;
+        private StringWriter _outputWriter = new();
+
+        private readonly Terminal _mockTerminal;
         private readonly LiveLogger _liveLogger;
 
         private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);
         private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);
 
+        private VerifySettings _settings = new();
+
+        private static Regex s_elapsedTime = new($@"\d+{Regex.Escape(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator)}\ds", RegexOptions.Compiled);
+
         public LiveLogger_Tests()
         {
-            _mockTerminal = new MockTerminal(_terminalWidth, _terminalHeight);
+            _mockTerminal = new Terminal(_outputWriter);
             _liveLogger = new LiveLogger(_mockTerminal);
 
             _liveLogger.Initialize(this, _nodeCount);
+
+            UseProjectRelativeDirectory("Snapshots");
+
+            // Scrub timestamps on intermediate execution lines,
+            // which are subject to the vagaries of the test machine
+            // and OS scheduler.
+            _settings.AddScrubber(static lineBuilder =>
+            {
+                string line = lineBuilder.ToString();
+                lineBuilder.Clear();
+                lineBuilder.Append(s_elapsedTime.Replace(line, "0.0s"));
+            });
         }
 
         #region IEventSource implementation
@@ -171,6 +198,8 @@ private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additi
 
             additionalCallbacks();
 
+            Thread.Sleep(1_000);
+
             TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
             TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
 
@@ -179,39 +208,82 @@ private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additi
         }
 
         [Fact]
-        public void PrintsBuildSummary_Succeeded()
+        public Task PrintsBuildSummary_Succeeded()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: true, () => { });
-            _mockTerminal.GetLastLine().ShouldBe("Build succeeded in 5.0s");
+
+            return Verify(_outputWriter.ToString(), _settings);
         }
 
         [Fact]
-        public void PrintBuildSummary_SucceededWithWarnings()
+        public Task PrintBuildSummary_SucceededWithWarnings()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
             {
                 WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
             });
-            _mockTerminal.GetLastLine().ShouldBe("Build succeeded with warnings in 5.0s");
+
+            return Verify(_outputWriter.ToString(), _settings);
         }
 
         [Fact]
-        public void PrintBuildSummary_Failed()
+        public Task PrintBuildSummary_Failed()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: false, () => { });
-            _mockTerminal.GetLastLine().ShouldBe("Build failed in 5.0s");
+            return Verify(_outputWriter.ToString(), _settings);
         }
 
         [Fact]
-        public void PrintBuildSummary_FailedWithErrors()
+        public Task PrintBuildSummary_FailedWithErrors()
         {
-            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+           InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+           {
+               ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+           });
+
+           return Verify(_outputWriter.ToString(), _settings);
+        }
+
+        #endregion
+
+        [Fact]
+        public void DisplayNodesShowsCurrent()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, async () =>
             {
-                ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+                _liveLogger.DisplayNodes();
+
+                await Verify(_outputWriter.ToString(), _settings);
             });
-            _mockTerminal.GetLastLine().ShouldBe("Build failed with errors in 5.0s");
         }
 
-        #endregion
+        [Fact]
+        public async Task DisplayNodesOverwritesWithNewTargetFramework()
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+
+            ProjectStartedEventArgs pse = MakeProjectStartedEventArgs(_projectFile, "Build");
+            pse.GlobalProperties = new Dictionary<string, string>() { ["TargetFramework"] = "tfName" };
+
+            ProjectStarted?.Invoke(_eventSender, pse);
+
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+
+            _liveLogger.DisplayNodes();
+
+            // This is a bit fast and loose with the events that would be fired
+            // in a real "stop building that TF for the project and start building
+            // a new TF of the same project" situation, but it's enough now.
+            ProjectStartedEventArgs pse2 = MakeProjectStartedEventArgs(_projectFile, "Build");
+            pse2.GlobalProperties = new Dictionary<string, string>() { ["TargetFramework"] = "tf2" };
+
+            ProjectStarted?.Invoke(_eventSender, pse2);
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+
+            _liveLogger.DisplayNodes();
+
+            await Verify(_outputWriter.ToString(), _settings);
+        }
     }
 }
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index f7c8683c7af..abb5f36de05 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -9,6 +9,7 @@
   <ItemGroup>
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
+    <PackageReference Include="Verify.Xunit" />
   </ItemGroup>
 
   <ItemGroup>
@@ -45,9 +46,6 @@
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
-    <Compile Remove="LiveLogger_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
-    <Compile Remove="MockTerminal.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
-
     <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.Core.xsd">
       <Link>Microsoft.Build.Core.xsd</Link>
       <SubType>
diff --git a/src/MSBuild.UnitTests/MockTerminal.cs b/src/MSBuild.UnitTests/MockTerminal.cs
deleted file mode 100644
index 915a1e15c8b..00000000000
--- a/src/MSBuild.UnitTests/MockTerminal.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Logging.LiveLogger;
-
-namespace Microsoft.Build.UnitTests
-{
-    /// <summary>
-    /// A test implementation of <see cref="ITerminal"/>.
-    /// </summary>
-    internal sealed class MockTerminal : ITerminal
-    {
-        private readonly int _width;
-        private readonly int _height;
-
-        /// <summary>
-        /// Contains output lines written to the terminal.
-        /// </summary>
-        private List<string> _outputLines = new();
-
-        private StringBuilder _bufferedOutput = new();
-        private bool _isBuffering = false;
-
-        public MockTerminal(int width, int height)
-        {
-            _width = width;
-            _height = height;
-            _outputLines.Add("");
-        }
-
-        /// <summary>
-        /// Gets the last line written to the terminal.
-        /// </summary>
-        /// <remarks>
-        /// If the last character was \n, it returns characters between the second to last \n and last \n.
-        /// If the last character was not \n, it returns characters between the last \n and the end of the output.
-        /// </remarks>
-        public string GetLastLine()
-        {
-            string lastLine = _outputLines[^1];
-            if (lastLine.Length == 0 && _outputLines.Count > 1)
-            {
-                lastLine = _outputLines[^2];
-            }
-            return lastLine;
-        }
-
-        /// <summary>
-        /// Adds a string to <see cref="_outputLines"/>.
-        /// </summary>
-        private void AddOutput(string text)
-        {
-            if (_isBuffering)
-            {
-                _bufferedOutput.Append(text);
-            }
-            else
-            {
-                string[] lines = text.Split('\n');
-                _outputLines[^1] += lines[0];
-                for (int i = 1; i < lines.Length; i++)
-                {
-                    _outputLines.Add("");
-                    _outputLines[^1] += lines[i];
-                }
-            }
-        }
-
-        #region ITerminal implementation
-
-        public int Width => _width;
-        public int Height => _height;
-
-        public void BeginUpdate()
-        {
-            if (_isBuffering)
-            {
-                throw new InvalidOperationException();
-            }
-            _isBuffering = true;
-        }
-
-        public void EndUpdate()
-        {
-            if (!_isBuffering)
-            {
-                throw new InvalidOperationException();
-            }
-            _isBuffering = false;
-
-            AddOutput(_bufferedOutput.ToString());
-            _bufferedOutput.Clear();
-        }
-
-        public void Write(string text) => AddOutput(text);
-        public void Write(ReadOnlySpan<char> text) { AddOutput(text.ToString()); }
-        public void WriteColor(TerminalColor color, string text) => AddOutput(text);
-        public void WriteColorLine(TerminalColor color, string text) { AddOutput(text); AddOutput("\n"); }
-        public void WriteLine(string text) { AddOutput(text); AddOutput("\n"); }
-        public void WriteLineFitToWidth(ReadOnlySpan<char> text)
-        {
-            AddOutput(text.Slice(0, Math.Min(text.Length, _width - 1)).ToString());
-            AddOutput("\n");
-        }
-
-        #endregion
-
-        #region IDisposable implementation
-
-        public void Dispose()
-        { }
-
-        #endregion
-    }
-}
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt
new file mode 100644
index 00000000000..5420c4eab35
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt
@@ -0,0 +1,5 @@
+﻿]9;4;3;\[?25l[1F
+  project [36;1mtfName[m Build (0.0s)
+[?25h[?25l[2F
+  project [36;1mtf2[m Build (0.0s)[K
+[?25h
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt
new file mode 100644
index 00000000000..0fb8b744327
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt
@@ -0,0 +1,3 @@
+﻿]9;4;3;\[?25l[1F
+  project Build (0.0s)
+[?25h
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt
new file mode 100644
index 00000000000..a761905358e
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\[?25l[1F
+[?25h
+Build [31;1mfailed[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt
new file mode 100644
index 00000000000..3657a549d75
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt
@@ -0,0 +1,6 @@
+﻿]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+[31;1m    ❌︎[7D[6C MSBUILD : error : Error![m
+[?25l[1F
+[?25h
+Build [31;1mfailed with errors[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt
new file mode 100644
index 00000000000..405fa3a221f
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt
@@ -0,0 +1,6 @@
+﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+[33;1m    ⚠︎[7D[6C MSBUILD : warning : Warning![m
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt
new file mode 100644
index 00000000000..f62b3f5ddba
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c6029b73765..dd838ef172f 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -9,6 +9,7 @@
 using System.IO.Compression;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.InteropServices;
 using System.Threading;
 using Microsoft.Build.CommandLine;
 using Microsoft.Build.Framework;
@@ -642,6 +643,84 @@ public void SetConsoleUICulture()
             thisThread.CurrentUICulture = originalUICulture;
         }
 
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && !EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
+            {
+                return; // The feature to detect .NET SDK Languages is not enabled on this machine, so don't test it.
+            }
+
+            const string DOTNET_CLI_UI_LANGUAGE = nameof(DOTNET_CLI_UI_LANGUAGE);
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            // Save the current environment info so it can be restored.
+            var originalUILanguage = Environment.GetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE);
+
+            var originalOutputEncoding = Console.OutputEncoding;
+            var originalInputEncoding = Console.InputEncoding;
+            Thread thisThread = Thread.CurrentThread;
+            CultureInfo originalUICulture = thisThread.CurrentUICulture;
+
+            try
+            {
+                // Set the UI language based on the SDK environment var.
+                testEnvironment.SetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE, "ja"); // Japanese chose arbitrarily.
+                ChangeWaves.ResetStateForTests();
+                if (!enableFeature)
+                {
+                    testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_8.ToString());
+                }
+                MSBuildApp.SetConsoleUI();
+
+                Assert.Equal(enableFeature ? new CultureInfo("ja") : CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture(), thisThread.CurrentUICulture);
+                if (enableFeature)
+                {
+                    Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
+                }
+            }
+            finally
+            {
+                // Restore the current UI culture back to the way it was at the beginning of this unit test.
+                thisThread.CurrentUICulture = originalUICulture;
+                // Restore for full framework
+                CultureInfo.CurrentCulture = originalUICulture;
+                CultureInfo.DefaultThreadCurrentUICulture = originalUICulture;
+
+                // MSBuild should also restore the encoding upon exit, but we don't create that context here.
+                Console.OutputEncoding = originalOutputEncoding;
+                Console.InputEncoding = originalInputEncoding;
+
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+        }
+
+        /// <summary>
+        /// We shouldn't change the UI culture if the current UI culture is invariant.
+        /// In other cases, we can get an exception on CultureInfo creation when System.Globalization.Invariant enabled.
+        /// </summary>
+
+        [Fact]
+        public void SetConsoleUICultureInInvariantCulture()
+        {
+            Thread thisThread = Thread.CurrentThread;
+
+            // Save the current UI culture, so we can restore it at the end of this unit test.
+            CultureInfo originalUICulture = thisThread.CurrentUICulture;
+
+            thisThread.CurrentUICulture = CultureInfo.InvariantCulture;
+            MSBuildApp.SetConsoleUI();
+
+            // Make sure we don't change culture.
+            thisThread.CurrentUICulture.ShouldBe(CultureInfo.InvariantCulture);
+
+            // Restore the current UI culture back to the way it was at the beginning of this unit test.
+            thisThread.CurrentUICulture = originalUICulture;
+        }
+
+
 #if FEATURE_SYSTEM_CONFIGURATION
         /// <summary>
         /// Invalid configuration file should not dump stack.
@@ -798,6 +877,10 @@ public void TestEnvironmentTest()
         [Fact]
         public void MSBuildEngineLogger()
         {
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            testEnvironment.SetEnvironmentVariable("DOTNET_CLI_UI_LANGUAGE", "en"); // build machines may have other values.
+            CultureInfo.CurrentUICulture = new CultureInfo("en"); // Validate that the thread will produce an english log regardless of the machine OS language
+
             string oldValueForMSBuildLoadMicrosoftTargetsReadOnly = Environment.GetEnvironmentVariable("MSBuildLoadMicrosoftTargetsReadOnly");
             string projectString =
                    "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
@@ -834,6 +917,8 @@ public void MSBuildEngineLogger()
 
                 var logFileContents = File.ReadAllText(logFile);
 
+                Assert.Equal(new CultureInfo("en"), Thread.CurrentThread.CurrentUICulture);
+
                 logFileContents.ShouldContain("Process = ");
                 logFileContents.ShouldContain("MSBuild executable path = ");
                 logFileContents.ShouldContain("Command line arguments = ");
diff --git a/src/MSBuild/AutomaticEncodingRestorer.cs b/src/MSBuild/AutomaticEncodingRestorer.cs
new file mode 100644
index 00000000000..b5696d62ab8
--- /dev/null
+++ b/src/MSBuild/AutomaticEncodingRestorer.cs
@@ -0,0 +1,68 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Security;
+using System.Text;
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// Ported from https://github.com/dotnet/sdk/blob/bcea1face15458814b8e53e8785b52ba464f6538/src/Cli/dotnet/AutomaticEncodingRestorer.cs.
+    /// A program can change the encoding of the console which would affect other programs.
+    /// We would prefer to have a pattern where the program does not affect encoding of other programs.
+    /// Create this class in a function akin to Main and let it manage the console encoding resources to return it to the state before execution upon destruction.
+    /// </summary>
+    public class AutomaticEncodingRestorer : IDisposable
+    {
+        private Encoding? _originalOutputEncoding = null;
+        private Encoding? _originalInputEncoding = null;
+
+        public AutomaticEncodingRestorer()
+        {
+            try
+            {
+#if NET7_0_OR_GREATER
+                if (OperatingSystem.IsIOS() || OperatingSystem.IsAndroid() || OperatingSystem.IsTvOS()) // Output + Input Encoding are unavailable on these platforms per docs, and they're only available past net 5.
+                {
+                    return;
+                }
+#endif
+                _originalOutputEncoding = Console.OutputEncoding;
+
+#if NET7_0_OR_GREATER
+                if (OperatingSystem.IsBrowser()) // Input Encoding is also unavailable in this platform. (No concern for net472 as browser is unavailable.)
+                {
+                    return;
+                }
+#endif
+                _originalInputEncoding = Console.InputEncoding;
+            }
+            catch (Exception ex) when (ex is IOException || ex is SecurityException)
+            {
+                // The encoding is unavailable. Do nothing.
+            }
+        }
+
+        public void Dispose()
+        {
+            try
+            {
+                if (_originalOutputEncoding != null)
+                {
+                    Console.OutputEncoding = _originalOutputEncoding;
+                }
+                if (_originalInputEncoding != null)
+                {
+                    Console.InputEncoding = _originalInputEncoding;
+                }
+            }
+            catch (Exception ex) when (ex is IOException || ex is SecurityException)
+            {
+                // The encoding is unavailable. Do nothing.
+            }
+        }
+    }
+}
diff --git a/src/MSBuild/LiveLogger/AnsiCodes.cs b/src/MSBuild/LiveLogger/AnsiCodes.cs
index 2b61583bbbe..2984f957dc4 100644
--- a/src/MSBuild/LiveLogger/AnsiCodes.cs
+++ b/src/MSBuild/LiveLogger/AnsiCodes.cs
@@ -60,6 +60,14 @@ internal static class AnsiCodes
     /// </remarks>
     public const string MoveForward = "C";
 
+    /// <summary>
+    /// Moves backward (to the left) the specified number of characters.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveBackward"/> to move N characters backward.
+    /// </remarks>
+    public const string MoveBackward = "D";
+
     /// <summary>
     /// Clears everything from cursor to end of screen.
     /// </summary>
@@ -85,4 +93,24 @@ internal static class AnsiCodes
     /// Shows/restores the cursor.
     /// </summary>
     public const string ShowCursor = "\x1b[?25h";
+
+    /// <summary>
+    /// Set progress state to a busy spinner.
+    /// </summary>
+    public const string SetProgressIndeterminate = "\x1b]9;4;3;\x1b\\";
+
+    /// <summary>
+    /// Remove progress state, restoring taskbar status to normal.
+    /// </summary>
+    public const string RemoveProgress = "\x1b]9;4;0;\x1b\\";
+
+    public static string Colorize(string? s, TerminalColor color)
+    {
+        if (string.IsNullOrWhiteSpace(s))
+        {
+            return s ?? "";
+        }
+
+        return $"{CSI}{(int)color}{SetColor}{s}{SetDefaultColor}";
+    }
 }
diff --git a/src/MSBuild/LiveLogger/ITerminal.cs b/src/MSBuild/LiveLogger/ITerminal.cs
index 6a2f1e67faa..ace2f0656c3 100644
--- a/src/MSBuild/LiveLogger/ITerminal.cs
+++ b/src/MSBuild/LiveLogger/ITerminal.cs
@@ -64,19 +64,3 @@ internal interface ITerminal : IDisposable
     /// </summary>
     void WriteColorLine(TerminalColor color, string text);
 }
-
-/// <summary>
-/// Enumerates the text colors supported by <see cref="ITerminal"/>.
-/// </summary>
-internal enum TerminalColor
-{
-    Black = 30,
-    Red = 31,
-    Green = 32,
-    Yellow = 33,
-    Blue = 34,
-    Magenta = 35,
-    Cyan = 36,
-    White = 37,
-    Default = 39
-}
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 5bcb21138d1..ccfc71e3825 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -42,9 +42,20 @@ internal record NodeStatus(string Project, string? TargetFramework, string Targe
     {
         public override string ToString()
         {
+            string duration = Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+
             return string.IsNullOrEmpty(TargetFramework)
-                ? $"{Indentation}{Project} {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)"
-                : $"{Indentation}{Project} [{TargetFramework}] {Target} ({Stopwatch.Elapsed.TotalSeconds:F1}s)";
+                ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_NoTF",
+                    Indentation,
+                    Project,
+                    Target,
+                    duration)
+                : ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_WithTF",
+                    Indentation,
+                    Project,
+                    AnsiCodes.Colorize(TargetFramework, TargetFrameworkColor),
+                    Target,
+                    duration);
         }
     }
 
@@ -53,6 +64,8 @@ public override string ToString()
     /// </summary>
     private const string Indentation = "  ";
 
+    private const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
+
     /// <summary>
     /// Protects access to state shared between the logger callbacks and the rendering thread.
     /// </summary>
@@ -81,6 +94,11 @@ public override string ToString()
     /// </summary>
     private DateTime _buildStartTime;
 
+    /// <summary>
+    /// The working directory when the build starts, to trim relative output paths.
+    /// </summary>
+    private readonly string _initialWorkingDirectory = Environment.CurrentDirectory;
+
     /// <summary>
     /// True if the build has encountered at least one error.
     /// </summary>
@@ -91,6 +109,11 @@ public override string ToString()
     /// </summary>
     private bool _buildHasWarnings;
 
+    /// <summary>
+    /// True if restore failed and this failure has already been reported.
+    /// </summary>
+    private bool _restoreFailed;
+
     /// <summary>
     /// The project build context corresponding to the <c>Restore</c> initial target, or null if the build is currently
     /// bot restoring.
@@ -112,6 +135,11 @@ public override string ToString()
     /// </summary>
     private ITerminal Terminal { get; }
 
+    /// <summary>
+    /// Should the logger's test environment refresh the console output manually instead of using a background thread?
+    /// </summary>
+    private bool _manualRefresh;
+
     /// <summary>
     /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
     /// </summary>
@@ -149,6 +177,7 @@ public LiveLogger()
     internal LiveLogger(ITerminal terminal)
     {
         Terminal = terminal;
+        _manualRefresh = true;
     }
 
     #region INodeLogger implementation
@@ -198,10 +227,15 @@ public void Shutdown()
     /// </summary>
     private void BuildStarted(object sender, BuildStartedEventArgs e)
     {
-        _refresher = new Thread(ThreadProc);
-        _refresher.Start();
+        if (!_manualRefresh)
+        {
+            _refresher = new Thread(ThreadProc);
+            _refresher.Start();
+        }
 
         _buildStartTime = e.Timestamp;
+
+        Terminal.Write(AnsiCodes.SetProgressIndeterminate);
     }
 
     /// <summary>
@@ -217,22 +251,32 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
         Terminal.BeginUpdate();
         try
         {
+            string duration = (e.Timestamp - _buildStartTime).TotalSeconds.ToString("F1");
+            string buildResult = RenderBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);
 
             Terminal.WriteLine("");
-            Terminal.Write("Build ");
-
-            PrintBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);
-
-            double duration = (e.Timestamp - _buildStartTime).TotalSeconds;
-            Terminal.WriteLine($" in {duration:F1}s");
+            if (_restoreFailed)
+            {
+                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
+                    buildResult,
+                    duration));
+            }
+            else
+            {
+                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("BuildFinished",
+                    buildResult,
+                    duration));
+            }
         }
         finally
         {
+            Terminal.Write(AnsiCodes.RemoveProgress);
             Terminal.EndUpdate();
         }
 
         _buildHasErrors = false;
         _buildHasWarnings = false;
+        _restoreFailed = false;
     }
 
     /// <summary>
@@ -286,89 +330,117 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
 
         ProjectContext c = new(buildEventContext);
 
-        // First check if we're done restoring.
-        if (_restoreContext is ProjectContext restoreContext && c == restoreContext)
+        if (_projects.TryGetValue(c, out Project? project))
         {
             lock (_lock)
             {
-                _restoreContext = null;
-
-                Stopwatch projectStopwatch = _projects[restoreContext].Stopwatch;
-                double duration = projectStopwatch.Elapsed.TotalSeconds;
-                projectStopwatch.Stop();
-
                 Terminal.BeginUpdate();
                 try
                 {
                     EraseNodes();
-                    Terminal.WriteLine($"Restore complete ({duration:F1}s)");
-                    DisplayNodes();
-                }
-                finally
-                {
-                    Terminal.EndUpdate();
-                }
-                return;
-            }
-        }
 
-        // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.
-        if (_projects.TryGetValue(c, out Project? project) && (project.OutputPath is not null || project.BuildMessages is not null))
-        {
-            lock (_lock)
-            {
-                Terminal.BeginUpdate();
-                try
-                {
-                    EraseNodes();
-
-                    double duration = project.Stopwatch.Elapsed.TotalSeconds;
+                    string duration = project.Stopwatch.Elapsed.TotalSeconds.ToString("F1");
                     ReadOnlyMemory<char>? outputPath = project.OutputPath;
 
-                    Terminal.Write(Indentation);
+                    string projectFile = e.ProjectFile is not null ?
+                        Path.GetFileNameWithoutExtension(e.ProjectFile) :
+                        string.Empty;
 
-                    if (e.ProjectFile is not null)
-                    {
-                        ReadOnlySpan<char> projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile.AsSpan());
-                        Terminal.Write(projectFile);
-                        Terminal.Write(" ");
-                    }
-                    if (!string.IsNullOrEmpty(project.TargetFramework))
-                    {
-                        Terminal.Write($"[{project.TargetFramework}] ");
-                    }
-
-                    // Print 'failed', 'succeeded with warnings', or 'succeeded' depending on the build result and diagnostic messages
+                    // Build result. One of 'failed', 'succeeded with warnings', or 'succeeded' depending on the build result and diagnostic messages
                     // reported during build.
                     bool haveErrors = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Error) == true;
                     bool haveWarnings = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Warning) == true;
-                    PrintBuildResult(e.Succeeded, haveErrors, haveWarnings);
 
-                    _buildHasErrors |= haveErrors;
-                    _buildHasWarnings |= haveWarnings;
+                    string buildResult = RenderBuildResult(e.Succeeded, haveErrors, haveWarnings);
 
-                    // Print the output path as a link if we have it.
-                    if (outputPath is not null)
+                    // Check if we're done restoring.
+                    if (c == _restoreContext)
                     {
-                        ReadOnlySpan<char> url = outputPath.Value.Span;
-                        try
+                        if (e.Succeeded)
                         {
-                            // If possible, make the link point to the containing directory of the output.
-                            url = Path.GetDirectoryName(url);
+                            if (haveErrors || haveWarnings)
+                            {
+                                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
+                                    buildResult,
+                                    duration));
+                            }
+                            else
+                            {
+                                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreComplete",
+                                    duration));
+                            }
                         }
-                        catch
+                        else
                         {
-                            // Ignore any GetDirectoryName exceptions.
+                            // It will be reported after build finishes.
+                            _restoreFailed = true;
                         }
-#if NETCOREAPP
-                        Terminal.WriteLine($" ({duration:F1}s) → {AnsiCodes.LinkPrefix}{url}{AnsiCodes.LinkInfix}{outputPath}{AnsiCodes.LinkSuffix}");
-#else
-                        Terminal.WriteLine($" ({duration:F1}s) → {AnsiCodes.LinkPrefix}{url.ToString()}{AnsiCodes.LinkInfix}{outputPath.ToString()}{AnsiCodes.LinkSuffix}");
-#endif
+
+                        _restoreContext = null;
                     }
-                    else
+                    // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.
+                    else if (project.OutputPath is not null || project.BuildMessages is not null)
                     {
-                        Terminal.WriteLine($" ({duration:F1}s)");
+                        // Show project build complete and its output
+
+                        if (string.IsNullOrEmpty(project.TargetFramework))
+                        {
+                            Terminal.Write(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_NoTF",
+                                Indentation,
+                                projectFile,
+                                buildResult,
+                                duration));
+                        }
+                        else
+                        {
+                            Terminal.Write(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_WithTF",
+                                Indentation,
+                                projectFile,
+                                AnsiCodes.Colorize(project.TargetFramework, TargetFrameworkColor),
+                                buildResult,
+                                duration));
+                        }
+
+                        // Print the output path as a link if we have it.
+                        if (outputPath is not null)
+                        {
+                            ReadOnlySpan<char> outputPathSpan = outputPath.Value.Span;
+                            ReadOnlySpan<char> url = outputPathSpan;
+                            try
+                            {
+                                // If possible, make the link point to the containing directory of the output.
+                                url = Path.GetDirectoryName(url);
+                            }
+                            catch
+                            {
+                                // Ignore any GetDirectoryName exceptions.
+                            }
+
+                            // Generates file:// schema url string which is better handled by various Terminal clients than raw folder name.
+                            string urlString = url.ToString();
+                            if (Uri.TryCreate(urlString, UriKind.Absolute, out Uri? uri))
+                            {
+                                urlString = uri.AbsoluteUri;
+                            }
+
+                            // If the output path is under the initial working directory, make the console output relative to that to save space.
+                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))
+                            {
+                                if (outputPathSpan.Length > _initialWorkingDirectory.Length
+                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar
+                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))
+                                {
+                                    outputPathSpan = outputPathSpan.Slice(_initialWorkingDirectory.Length + 1);
+                                }
+                            }
+
+                            Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_OutputPath",
+                                $"{AnsiCodes.LinkPrefix}{urlString}{AnsiCodes.LinkInfix}{outputPathSpan.ToString()}{AnsiCodes.LinkSuffix}"));
+                        }
+                        else
+                        {
+                            Terminal.WriteLine(string.Empty);
+                        }
                     }
 
                     // Print diagnostic output under the Project -> Output line.
@@ -382,10 +454,26 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                                 MessageSeverity.Error => TerminalColor.Red,
                                 _ => TerminalColor.Default,
                             };
-                            Terminal.WriteColorLine(color, $"{Indentation}{Indentation}{buildMessage.Message}");
+                            char symbol = buildMessage.Severity switch
+                            {
+                                MessageSeverity.Warning => '⚠',
+                                MessageSeverity.Error => '❌',
+                                _ => ' ',
+                            };
+
+                            // The error and warning symbols may be rendered with different width on some terminals. To make sure that the message text
+                            // is always aligned, we print the symbol, move back to the start of the line, then move forward to the desired column, and
+                            // finally print the message text.
+                            int maxSymbolWidth = 2;
+                            int messageStartColumn = Indentation.Length + Indentation.Length + maxSymbolWidth;
+                            Terminal.WriteColorLine(color, $"{Indentation}{Indentation}{symbol}\uFE0E{AnsiCodes.CSI}{messageStartColumn + 1}{AnsiCodes.MoveBackward}" +
+                                $"{AnsiCodes.CSI}{messageStartColumn}{AnsiCodes.MoveForward} {buildMessage.Message}");
                         }
                     }
 
+                    _buildHasErrors |= haveErrors;
+                    _buildHasWarnings |= haveWarnings;
+
                     DisplayNodes();
                 }
                 finally
@@ -483,7 +571,7 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
             string message = EventArgsFormatting.FormatEventMessage(e, false);
-            project.AddBuildMessage(MessageSeverity.Warning, $"⚠\uFE0E {message}");
+            project.AddBuildMessage(MessageSeverity.Warning, message);
         }
     }
 
@@ -496,7 +584,7 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
             string message = EventArgsFormatting.FormatEventMessage(e, false);
-            project.AddBuildMessage(MessageSeverity.Error, $"❌\uFE0E {message}");
+            project.AddBuildMessage(MessageSeverity.Error, message);
         }
     }
 
@@ -526,7 +614,7 @@ private void ThreadProc()
     /// Render Nodes section.
     /// It shows what all build nodes do.
     /// </summary>
-    private void DisplayNodes()
+    internal void DisplayNodes()
     {
         NodesFrame newFrame = new NodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
 
@@ -655,21 +743,22 @@ public string Render(NodesFrame previousFrame)
                     if (!previous.SequenceEqual(needed))
                     {
                         int commonPrefixLen = previous.CommonPrefixLength(needed);
-                        if (commonPrefixLen == 0)
+
+                        if (commonPrefixLen != 0 && needed.Slice(0, commonPrefixLen).IndexOf('\x1b') == -1)
                         {
-                            // whole string
-                            sb.Append(needed);
+                            // no escape codes, so can trivially skip substrings
+                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
+                            sb.Append(needed.Slice(commonPrefixLen));
                         }
                         else
                         {
-                            // set cursor to different char
-                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
-                            sb.Append(needed.Slice(commonPrefixLen));
-                            // Shall we clear rest of line
-                            if (needed.Length < previous.Length)
-                            {
-                                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
-                            }
+                            sb.Append(needed);
+                        }
+
+                        // Shall we clear rest of line
+                        if (needed.Length < previous.Length)
+                        {
+                            sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
                         }
                     }
                 }
@@ -708,26 +797,26 @@ public void Clear()
     /// <param name="succeeded">True if the build completed with success.</param>
     /// <param name="hasError">True if the build has logged at least one error.</param>
     /// <param name="hasWarning">True if the build has logged at least one warning.</param>
-    private void PrintBuildResult(bool succeeded, bool hasError, bool hasWarning)
+    private string RenderBuildResult(bool succeeded, bool hasError, bool hasWarning)
     {
         if (!succeeded)
         {
             // If the build failed, we print one of three red strings.
             string text = (hasError, hasWarning) switch
             {
-                (true, _) => "failed with errors",
-                (false, true) => "failed with warnings",
-                _ => "failed",
+                (true, _) => ResourceUtilities.GetResourceString("BuildResult_FailedWithErrors"),
+                (false, true) => ResourceUtilities.GetResourceString("BuildResult_FailedWithWarnings"),
+                _ => ResourceUtilities.GetResourceString("BuildResult_Failed"),
             };
-            Terminal.WriteColor(TerminalColor.Red, text);
+            return AnsiCodes.Colorize(text, TerminalColor.Red);
         }
         else if (hasWarning)
         {
-            Terminal.WriteColor(TerminalColor.Yellow, "succeeded with warnings");
+            return AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_SucceededWithWarnings"), TerminalColor.Yellow);
         }
         else
         {
-            Terminal.WriteColor(TerminalColor.Green, "succeeded");
+            return AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_Succeeded"), TerminalColor.Green);
         }
     }
 
diff --git a/src/MSBuild/LiveLogger/Terminal.cs b/src/MSBuild/LiveLogger/Terminal.cs
index 9b187391778..1d78fcce6d6 100644
--- a/src/MSBuild/LiveLogger/Terminal.cs
+++ b/src/MSBuild/LiveLogger/Terminal.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
 using System.Text;
 #if NETFRAMEWORK
 using Microsoft.Build.Shared;
@@ -29,11 +30,37 @@ internal sealed class Terminal : ITerminal
     /// </summary>
     private bool _isBuffering = false;
 
+    internal TextWriter Output { private get; set; } = Console.Out;
+
+    private const int BigUnknownDimension = 2 << 23;
+
     /// <inheritdoc/>
-    public int Height => Console.BufferHeight;
+    public int Height
+    {
+        get
+        {
+            if (Console.IsOutputRedirected)
+            {
+                return BigUnknownDimension;
+            }
+
+            return Console.BufferHeight;
+        }
+    }
 
     /// <inheritdoc/>
-    public int Width => Console.BufferWidth;
+    public int Width
+    {
+        get
+        {
+            if (Console.IsOutputRedirected)
+            {
+                return BigUnknownDimension;
+            }
+
+            return Console.BufferWidth;
+        }
+    }
 
     public Terminal()
     {
@@ -41,6 +68,13 @@ public Terminal()
         Console.OutputEncoding = Encoding.UTF8;
     }
 
+    internal Terminal(TextWriter output)
+    {
+        Output = output;
+
+        _originalOutputEncoding = Encoding.UTF8;
+    }
+
     /// <inheritdoc/>
     public void BeginUpdate()
     {
@@ -60,7 +94,7 @@ public void EndUpdate()
         }
         _isBuffering = false;
 
-        Console.Write(_outputBuilder.ToString());
+        Output.Write(_outputBuilder.ToString());
         _outputBuilder.Clear();
     }
 
@@ -73,7 +107,7 @@ public void Write(string text)
         }
         else
         {
-            Console.Write(text);
+            Output.Write(text);
         }
     }
 
@@ -86,7 +120,7 @@ public void Write(ReadOnlySpan<char> text)
         }
         else
         {
-            Console.Out.Write(text);
+            Output.Write(text);
         }
     }
 
@@ -99,7 +133,7 @@ public void WriteLine(string text)
         }
         else
         {
-            Console.WriteLine(text);
+            Output.WriteLine(text);
         }
     }
 
@@ -114,7 +148,7 @@ public void WriteLineFitToWidth(ReadOnlySpan<char> text)
         }
         else
         {
-            Console.Out.WriteLine(truncatedText);
+            Output.WriteLine(truncatedText);
         }
     }
 
@@ -132,7 +166,7 @@ public void WriteColor(TerminalColor color, string text)
         }
         else
         {
-            Write($"{AnsiCodes.CSI}{(int)color}{AnsiCodes.SetColor}{text}{AnsiCodes.SetDefaultColor}");
+            Write(AnsiCodes.Colorize(text, color));
         }
     }
 
diff --git a/src/MSBuild/LiveLogger/TerminalColor.cs b/src/MSBuild/LiveLogger/TerminalColor.cs
new file mode 100644
index 00000000000..ec27040eb3e
--- /dev/null
+++ b/src/MSBuild/LiveLogger/TerminalColor.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Enumerates the text colors supported by <see cref="ITerminal"/>.
+/// </summary>
+internal enum TerminalColor
+{
+    Black = 30,
+    Red = 31,
+    Green = 32,
+    Yellow = 33,
+    Blue = 34,
+    Magenta = 35,
+    Cyan = 36,
+    White = 37,
+    Default = 39
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2e320bdfc9a..219437cdacf 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -48,7 +48,8 @@
     <NoPackageAnalysis>true</NoPackageAnalysis>
     <AddAppConfigToBuildOutputs>false</AddAppConfigToBuildOutputs>
 
-    <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType><!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/dotnet/msbuild/pull/5070 for context. -->
+    <!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/dotnet/msbuild/pull/5070 for context. -->
+    <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType>
     <DefineConstants>$(DefineConstants);MSBUILDENTRYPOINTEXE</DefineConstants>
   </PropertyGroup>
 
@@ -126,10 +127,7 @@
     <Compile Include="..\Shared\INodePacketFactory.cs" />
     <Compile Include="..\Shared\NodePacketFactory.cs" />
     <Compile Include="..\Shared\INodePacketHandler.cs" />
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
@@ -163,6 +161,7 @@
     <Compile Include="AssemblyResources.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="AutomaticEncodingRestorer.cs" />
     <Compile Include="CommandLineSwitches.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -218,13 +217,13 @@
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
-    <!-- Manually download this library for RoslynCodeTaskFactory.
+  <!-- Manually download this library for RoslynCodeTaskFactory.
            See target AddRefAssemblies below. -->
-    <ItemGroup>
-      <PackageDownload Include="netstandard.library">
-        <Version>[2.0.3]</Version>
-      </PackageDownload>
-    </ItemGroup>
+  <ItemGroup>
+    <PackageDownload Include="netstandard.library">
+      <Version>[2.0.3]</Version>
+    </PackageDownload>
+  </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- File for Assemblies we depend on -->
     <Reference Include="System" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index c3e4ab12b4d..73d3a516d44 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1419,6 +1419,11 @@ elementFormDefault="qualified">
     <xs:element name="CLRSupport" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="UseDebugLibraries" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="CodePage" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="CompilerGeneratedFilesOutputPath" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="CompilerGeneratedFilesOutputPath" _locComment="" -->Controls where source generated files are saved.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="Configuration" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationOverrideFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1700,6 +1705,11 @@ elementFormDefault="qualified">
         </xs:annotation>
     </xs:element>
     <xs:element name="DocumentationFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="EmitCompilerGeneratedFiles" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EmitCompilerGeneratedFiles" _locComment="" -->Controls whether source generated files will be saved.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="EnableASPDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableASPXDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableSQLServerDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1834,6 +1844,11 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="EnableDefaultItems" _locComment="" -->Defaults to true, and if set to false will disable all default item globs.</xs:documentation>
         </xs:annotation>
     </xs:element>
+    <xs:element name="IsAotCompatible" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="IsAotCompatible" _locComment="" -->Indicates whether a class library is compatible with native AOT. Setting to true will enable analyzers for trimming, single file, and AOT.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="JCPA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="Keyword" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 679f83d8d36..94b963cb2ec 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -277,6 +277,10 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </value>
     <comment>
       LOCALIZATION: The following should not be localized:
@@ -1231,6 +1235,15 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="InvalidLowPriorityValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1064: Low priority value is not valid. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="AbortingBuild" UESanitized="true" Visibility="Public">
     <value>Attempting to cancel the build...</value>
   </data>
@@ -1366,10 +1379,114 @@
   <data name="UnsupportedSwitchForSolutionFiles" Visibility="Public">
     <value>The '{0}' switch is not supported for solution files.</value>
   </data>
+  <!-- **** LiveLogger strings begin **** -->
+  <data name="RestoreComplete" xml:space="preserve">
+    <value>Restore complete ({0}s)</value>
+    <comment>
+      {0}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="RestoreCompleteWithMessage" xml:space="preserve">
+    <value>Restore {0} in {1}s</value>
+    <comment>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="BuildFinished" xml:space="preserve">
+    <value>Build {0} in {1}s</value>
+    <comment>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithErrors" xml:space="preserve">
+    <value>failed with errors</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithWarnings" xml:space="preserve">
+    <value>failed with warnings</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Failed" xml:space="preserve">
+    <value>failed</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Succeeded" xml:space="preserve">
+    <value>succeeded</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_SucceededWithWarnings" xml:space="preserve">
+    <value>succeeded with warnings</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="ProjectFinished_NoTF" xml:space="preserve">
+    <value>{0}{1} {2} ({3}s)</value>
+    <comment>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectFinished_WithTF" xml:space="preserve">
+    <value>{0}{1} {2} {3} ({4}s)</value>
+    <comment>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectFinished_OutputPath" xml:space="preserve">
+    <value> → {0}</value>
+    <comment>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </comment>
+  </data>
+  <data name="ProjectBuilding_NoTF" xml:space="preserve">
+    <value>{0}{1} {2} ({3}s)</value>
+    <comment>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectBuilding_WithTF" xml:space="preserve">
+    <value>{0}{1} {2} {3} ({4}s)</value>
+    <comment>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <!-- **** LiveLogger strings end **** -->
+
     <!--
         The command line message bucket is: MSB1001 - MSB1999
 
-        Next error code should be MSB1063.
+        Next error code should be MSB1065.
 
         Don't forget to update this comment after using the new code.
   -->
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index db244d38b7f..696651c235e 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Sestavení {0} za {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">neúspěšné</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">selhalo s chybami</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">selhalo s upozorněními</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">úspěšné</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">úspěšně dokončeno s upozorněními</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,33 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (experimentální) Dotaz, jestli je dochází k práci na sestavení.
+                     MSBuild zobrazí chybu při zjištění cíle nebo úkolu
+,
+                     který může být přírůstkový (obsahuje vstupy a výstupy),
+                     ale není aktuální.
+                     (Krátký tvar: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: Hodnota s nízkou prioritou není platná. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">MSBuild verze {0} pro {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +226,28 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| Nepravda]
+                     Způsobí, že MSBuild sestaví každý projekt v izolaci.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
+                     tvar „Zpráva“), jsou serializovány pouze výsledky z cílů nejvyšší úrovně
+                     pokud je dodán přepínač -outputResultsCache
+.
+                     Tímto se zmírní pravděpodobnost
+                     cíle porušujícího izolaci v projektu závislosti pomocí
+                     nesprávného stavu kvůli své závislosti na cíli uloženém v mezipaměti
+,
+                     jehož vedlejší účinky by se nezohlednily.
+                     (Například definice vlastnosti.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                    Toto je přísnější režim MSBuildu, protože vyžaduje
+,
+                     aby byl graf projektu staticky zjistitelný v
+                     období vyhodnocování, ale může zlepšit plánování a snížit
+                     režie paměti při sestavování velké sady projektů.
+                     (Krátký tvar: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Tento příznak je experimentální a nemusí fungovat podle očekávání.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +362,14 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Seznam kódů upozornění, které se nemají považovat za chyby.
+                     K oddělení
+ více kódů upozornění použijte středník 
+                     nebo čárku. Nemá žádný vliv, pokud přepínač -warnaserror
+                     není nastavený.
 
-                     Example:
+                     Příklad:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -466,20 +525,17 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;protok_nást&gt;   Použít daný protokolovací nástroj k protokolování
-                     událostí nástroje MSBuild. Chcete-li zadat více protokolovacích.
-                     nástrojů, musíte je zadat jednotlivě.
-                     Syntaxe hodnoty &lt;protok_nást&gt;:
-                        [&lt;třída_protok_nást&gt;,]&lt;sestavení_protok_nást&gt;
-                        [;&lt;param_protok_nást&gt;]
-                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
-                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
-                     Syntaxe hodnoty &lt;sestavení_protok_nást&gt;:
-                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
+        <target state="translated">  -logger:&lt;logger&gt;   Použít daný protokolovací nástroj k protokolování událostí nástroje MSBuild. Pokud chcete zadat 
+                     více protokolovacích nástrojů, musíte je zadat jednotlivě.
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
-                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se 
-                     protokolovacímu nástroji přesně v tom tvaru, v jakém
-                     byly zadány. (Krátký tvar: -l)
+                     Parametry &lt;logger parameters&gt; jsou volitelné a předávají se
+                     protokolovacímu nástroji přesně v tom tvaru, v jakém byly zadány. (Krátký tvar: -l)
                      Příklady:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
@@ -499,12 +555,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;úroveň&gt; Zobrazení daného množství informací v protokolu
-                     událostí. Dostupné úrovně podrobností: q[uiet], m[inimal],
+        <target state="translated">  -verbosity:&lt;level&gt; Zobrazí toto množství informací v protokolu událostí.
+                     Dostupné úrovně podrobnosti: q[uiet], m[inimal],
                      n[ormal], d[etailed] a diag[nostic]. (Krátký tvar: -v)
                      Příklad:
                        -verbosity:quiet
+
+                     Poznámka: Podrobnost protokolování souborů
+                           je nastavena samostatně přes
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -553,40 +617,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleloggerparameters:&lt;parameters&gt;
+                     Parametry do protokolovacího nástroje konzoly. (Krátký tvar: -clp)
+                     Dostupné parametry jsou:
+                        PerformanceSummary – zobrazí dobu zpracování úloh, cílů
+                            a projektů.
+                        Summary – zobrazí souhrn chyb a upozornění na konci.
+                        NoSummary – nezobrazí souhrny chyb a upozornění na
+                            konci.
+                        ErrorsOnly – zobrazí jenom chyby.
+                        WarningsOnly – zobrazí jenom upozornění.
+                        NoItemAndPropertyList – nezobrazí na začátku sestavení každého
+                            projektu seznamy položek a vlastností.
+                        ShowCommandLine – zobrazí zprávy TaskCommandLineEvent.
+                        ShowTimestamp – před každou zprávou zobrazí
+                            časové razítko.
+                        ShowEventId – zobrazí ID události pro spuštěné a dokončené
+                            události a zprávy.
+                        ForceNoAlign – nenastav9 text podle velikosti vyrovnávací
+                            paměti konzoly.
+                        DisableConsoleColor – použije výchozí barvy konzoly
+                            pro všechny zprávy protokolování.
+                        DisableMPLogging – zakáže víceprocesorový styl výstupu
+                            protokolování při práci v jiném než víceprocesorovém
+                            režimu.
+                        EnableMPLogging – povolí víceprocesorový styl výstupu
+                            protokolování i při práci v jiném
+                            režimu. Tento styl protokolování je výchozí. 
+                        ForceConsoleColor – použije barvy konzoly ANSI,
+                            i když to konzola nepodporuje.
+                        PreferConsoleColor– použije barvy konzoly ANSI, pouze pokud
+                            to cílová konzola podporuje.
+                        Verbosity – potlačí nastavení -verbosity
+                            pro tento protokolovací nástroj.
+                     Příklad:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -687,10 +751,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Středníky oddělený seznam vstupních souborů mezipaměti, které MSBuild
+                     načte výsledky sestavení. Pokud je parametr -isolateProjects nastaven
+                     na hodnotu False, toto ho nastaví na hodnotu True. (krátký tvar: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -704,11 +768,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     výstupní soubor mezipaměti, do kterého nástroj MSBuild zapíše obsah
+                     mezipaměti výsledků sestavení na konci sestavení.
+                     Pokud je parametr -isolateProjects nastaven na hodnotu False, toto ho                                nastaví na hodnotu True.
+                     (krátký tvar: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -740,23 +804,20 @@
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;                     
-                     Použít zadaný protokolovací nástroj pro protokolování událostí
-                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci 
-                     protokolovacího nástroje. Chcete-li zadat více 
-                     protokolovacích nástrojů, uveďte je jednotlivě. 
+        <target state="translated">  -distributedLogger:&lt;central logger&gt;*&lt;forwarding logger&gt;
+                     Použít zadaný protokolovací nástroj pro protokolování událostí z nástroje MSBuild; ke každému uzlu připojit
+                     jinou instanci protokolovacího nástroje. Pokud chcete zadat více
+                     protokolovacích nástrojů, uveďte je jednotlivě.
                      (Krátký tvar: -dl)
-                     Syntaxe hodnoty &lt;protok_nást&gt;:
-                        [&lt;třída_protok_nást&gt;,]&lt;sestav_protok_nást&gt;
-                        [;&lt;param_protok_nást&gt;]
-                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
-                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
-                     Syntaxe hodnoty &lt;sestav_protok_nást&gt;:
-                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
                      Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se
-                     protokolovacímu nástroji přesně v zadaném tvaru.
-                     (Krátký tvar: -l)
+                     protokolovacímu nástroji přesně v zadaném tvaru. (Krátký tvar: -l)
                      Příklady:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
@@ -944,7 +1005,7 @@
                                              Verbosity=diagnostic;Encoding=UTF-8
 
                        -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1334,6 +1395,60 @@
         <target state="translated">Proces = {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Soubor projektu neexistuje.</target>
@@ -1379,6 +1494,22 @@
         <target state="translated">{0} přišla z {1}</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Obnovení dokončeno ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Obnoví se {0} za {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1442,7 +1573,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">Přepínač „{0}“ se pro soubory řešení nepodporuje.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 48a5797486c..4890de22d59 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Erstellen von {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">Fehlgeschlagen</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">Fehlgeschlagen mit Fehlern</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">Fehlgeschlagen mit Warnungen</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">Erfolgreich</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">Erfolgreich mit Warnungen</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (Experimentell) Fragen Sie, ob Buildarbeiten vorhanden sind.
+                     MSBuild führt einen Fehler aus, wenn ein Ziel oder eine Aufgabe erkannt wird,
+                     das/die inkrementell sein kann (mit Eingaben und Ausgaben),
+                     aber nicht auf dem neuesten Stand ist.
+                     (Kurzform: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: Der Wert mit niedriger Priorität ist ungültig. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">MSBuild-Version {0} für {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| False]
+                     Führt dazu, dass MSBuild jedes Projekt isoliert erstellt.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Bei Festlegung auf "MessageUponIsolationViolation" (oder die zugehörige Kurzform
+                      "Message"), werden die Resultate von Top Level-Zielen
+                     nur serialisiert, wenn der Parameter "-outputResultsCache"
+                     angegeben wurde. Dies dient dazu, die Wahrscheinlichkeit eines
+                     gegen die Isolation verstoßenden Ziels für ein Abhängigkeitsprojekt mithilfe von
+                     Falscher Status aufgrund seiner Abhängigkeit von einem zwischengespeicherten Ziel,
+                     dessen Nebenwirkungen nicht berücksichtigt würden, abzuschwächen.
+                     (Beispiel: Die Definition einer Eigenschaft.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
+                     dass das Projektdiagramm zum Zeitpunkt der Auswertung statisch auffindbar ist,
+                     jedoch kann die Planung kann verbessert und
+                     der Arbeitsspeicheraufwand reduziert werden, wenn große Gruppen von Projekten erstellt werden.
+                     (Kurzform: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Dieses Kennzeichen ist experimentell und funktioniert möglicherweise nicht wie vorgesehen.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Liste der Warnungscodes, die nicht als Fehler behandelt werden.
+                     Semikolon oder Komma zum Trennen 
+                     mehrerer Warnungscodes verwenden. Hat keine Auswirkungen, wenn der Switch -warnaserror
+                     nicht festgelegt ist.
 
-                     Example:
+                     Beispiel:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -496,12 +550,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;Grad&gt; Zeigt diesen Grad von Informationen im Ereignisprotokoll an.
-                     Folgende Ausführlichkeitsgrade sind verfügbar: q[uiet], m[inimal],
+        <target state="translated">  -verbosity:&lt;level&gt; Zeigt diese Menge von Informationen im Ereignisprotokoll an.
+                     Folgende Ausführlichkeitsstufen sind verfügbar: q[uiet], m[inimal],
                      n[ormal], d[etailed] und diag[nostic]. (Kurzform: -v)
                      Beispiel:
                        -verbosity:quiet
+
+Hinweis: Ausführlichkeit der Dateiprotokollierungen
+                           wird separat festgelegt durch
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -550,40 +612,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleloggerparameters:&lt;Parameter&gt;
+                     Parameter für die Konsolenprotokollierung. (Kurzform: -clp)
+                     Folgende Parameter sind verfügbar:
+                        PerformanceSummary: Zeigt die in Aufgaben, Zielen und
+                            Projekten verbrachte Zeit an.
+                        Summary: Zeigt abschließend eine Zusammenfassung der Fehler und Warnungen an.
+                        NoSummary: Zeigt keine Fehler- und Warnungsübersicht am
+                            Ende an.
+                        ErrorsOnly: Zeigt nur Fehler an.
+                        WarningsOnly: Zeigt nur Warnungen an.
+                        NoItemAndPropertyList: Zeigt keine Liste der Elemente
+                            und Eigenschaften am Anfang jeder Projekterstellung an.
+                        ShowCommandLine: Zeigt TaskCommandLineEvent-Meldungen an. 
+                        ShowTimestamp: Zeigt den Timestamp als Präfix einer
+                            Meldung an.
+                        ShowEventId: Zeigt die eventId für gestartete
+                            Ereignisse, abgeschlossene Ereignisse und Meldungen an.
+                        ForceNoAlign: Richtet den Text nicht an der Größe des
+                            Konsolenpuffers aus.
+                        DisableConsoleColor: Verwendet die Standardkonsolenfarben
+                            für alle Protokollierungsmeldungen.
+                        DisableMPLogging: Deaktiviert die Ausgabe wie
+                            bei der Mehrprozessorprotokollierung im Modus mit nur einem Prozessor.
+                        EnableMPLogging: Aktiviert das Format der
+                            Mehrprozessorprotokollierung auch bei der Ausführung
+                            im Modus mit nur einem Prozessor.
+Dieses Protokollierungsformat ist standardmäßig aktiviert.
+                         ForceConsoleColor: Verwendet selbst dann
+                            ANSI-Konsolenfarben, wenn die Konsole dies nicht unterstützt.
+                        PreferConsoleColor: Verwendet ANSI-Konsolenfarben nur,
+                            wenn die Zielkonsole dies unterstützt.
+                     Verbosity: Überschreibt die Einstellung für -verbosity für
+                            diese Protokollierung.
+                     Beispiel:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -684,10 +746,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Durch Semikolon getrennte Liste der Eingabecachedateien, aus denen MSBuild
+                     Buildergebnisse liest. Wenn "-isolateProjects"
+                     auf "False" festgelegt ist, wird dieser Wert auf "True" festgelegt. (Kurzform: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -701,11 +763,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Ausgabecachedatei, in die MSBuild den Inhalt
+                     des Buildergebniscaches am Ende des Builds schreibt.
+                     Wenn "-isolateProjects" auf "False" festgelegt ist, wird diese Einstellung auf "True" festgelegt.
+                     (Kurzform: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1326,6 +1388,60 @@
         <target state="translated">Prozess = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Die Projektdatei ist nicht vorhanden.</target>
@@ -1371,6 +1487,22 @@
         <target state="translated">„{0}“ stammt aus „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Wiederherstellung abgeschlossen ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Wiederherstellen von {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1434,7 +1566,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">Der Switch "{0}" wird für Projektmappendateien nicht unterstützt.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index bb62e3d2cb3..c97e3a646ee 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Compilación {0} en {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">erróneo</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">error con errores</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">error con advertencias</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">realizado correctamente</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">correcto con advertencias</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (Experimental) Pregunta si hay algún trabajo de compilación.
+                     MSBuild generará un error cuando detecte un destino o tarea
+                     que puede ser incremental (tiene entradas y salidas),
+                     pero no está actualizado.
+                     (Forma corta: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: El valor de prioridad baja no es válido. {0}.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Versión de MSBuild {0} para {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| Falso]
+                     Hace que MSBuild compile cada proyecto de forma aislada.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Cuando se establece en "MessageUponIsolationViolation" (o su valor corto
+                     forma "Mensaje"), solo los resultados de los destinos de nivel superior
+                     se serializan si el modificador -outputResultsCache es
+                     Suministrado. Esto es para mitigar las posibilidades de un
+                     destino que infringe el aislamiento en un proyecto de dependencia mediante
+                     un estado incorrecto debido a su dependencia en un destino almacenado en caché
+                     cuyos efectos secundarios no se tendrán en cuenta.
+                     (Por ejemplo, la definición de una propiedad.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Este es un modo más restrictivo de MSBuild, ya que requiere
+                     que el gráfico del proyecto se pueda detectar estáticamente en
+                     tiempo de evaluación, pero puede mejorar la programación y reducir
+                     la sobrecarga de memoria al compilar un gran conjunto de proyectos.
+                     (Forma corta: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Esta marca es experimental y puede que no funcione según lo previsto.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Lista de códigos de advertencia para que no se traten como errores.
+                     Use un punto y coma o una coma para separar
+                     varios códigos de advertencia. No tiene efecto si el modificador -warnaserror
+                     no se ha establecido.
 
-                     Example:
+                     Ejemplo:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -500,12 +554,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;nivel&gt; Muestra en el registro de eventos la cantidad de información especificada.
+        <target state="translated">  -verbosity:&lt;level&gt; Muestra esta cantidad de información en el registro de eventos.
                      Los niveles de detalle disponibles son: q[uiet], m[inimal],
                      n[ormal], d[etailed] y diag[nostic]. (Forma corta: -v)
                      Ejemplo:
                        -verbosity:quiet
+
+                     Nota: nivel de detalle de los registradores de archivos
+                           se establece por separado por
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -554,40 +616,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parámetros del registrador de consola. (Forma corta: -clp)
+                     Los parámetros disponibles son:
+                        PerformanceSummary: muestra el tiempo empleado en tareas, destinos
+                            y proyectos.
+                        Summary: muestra un resumen de errores y advertencias al final.
+                        NoSummary: no muestra el resumen de errores y advertencias al
+                            final.
+                        ErrorsOnly: muestra solo errores.
+                        WarningsOnly: muestra solo advertencias.
+                        NoItemAndPropertyList: no muestra la lista de elementos y
+                            propiedades al principio de cada compilación del proyecto.
+                        ShowCommandLine: muestra los mensajes de TaskCommandLineEvent
+                        ShowTimestamp: muestra la marca de tiempo como un prefijo en los
+                            mensajes.
+                        ShowEventId: muestra el identificador de evento para los eventos iniciados, los eventos 
+                            finalizados y los mensajes.
+                        ForceNoAlign: no alinea el texto al tamaño del
+                            búfer de la consola
+                        DisableConsoleColor: usa los colores de consola predeterminados
+                            para todos los mensajes de registro.
+                        DisableMPLogging: deshabilita el estilo de registro de resultados
+                            de multiprocesador al ejecutarse en el
+                            modo de no multiprocesador.
+                        EnableMPLogging: habilita el estilo de registro de
+                            multiprocesador aunque se ejecute en el modo de
+                            no multiprocesador. Este estilo de registro está habilitado de forma predeterminada.
+                     ForceConsoleColor: usa los colores de consola ANSI incluso si
+                            la consola no lo admite.
+                        PreferConsoleColor--usa los colores de consola ANSI solo si
+                            la consola lo admite
+                        Verbosity: invalida el valor -verbosity para este
+                            registrador.
+                     Ejemplo:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -688,10 +750,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Lista separada por punto y coma de los archivos de caché de entrada que MSBuild
+                     leerá los resultados de la compilación. Si se establece -isolateProjects
+                     en False, esta se establece en True. (forma corta: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -705,11 +767,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[archivo-de-caché]
+                     Archivo de caché de salida donde MSBuild escribe el contenido de
+                     las memorias caché de resultados de compilación cuando esta acaba.
+                     Si se establece -isolateProjects en False, esta se establece en True.
+                     (forma corta: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1333,6 +1395,60 @@
         <target state="translated">Proceso: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: El archivo de proyecto no existe.</target>
@@ -1378,6 +1494,22 @@
         <target state="translated">'{0}' procedía de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauración completada ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurar {0} en {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1441,7 +1573,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">El modificador '{0}' no es compatible con los archivos de solución.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index c0367b98145..d477903f11c 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Générer {0} dans {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">échec</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">a échoué avec des erreurs</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">a échoué avec des avertissements</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">a réussi</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">a réussi avec des avertissements</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (Expérimental) Spécifiez s’il existe un travail de build.
+                     MSBuild génère une erreur lorsqu’il détecte une cible ou une tâche
+                     qui peut être incrémentielle (a des entrées et des sorties),
+                     mais n’est pas à jour.
+                     (Forme abrégée : -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: la valeur basse priorité n’est pas valide. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Version MSBuild {0} pour {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageCalculIsolationViolation| Faux]
+                     Force MSBuild à générer chaque projet en isolement.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Lorsqu’il est défini sur « MessageCalculIsolationViolation » (ou sa valeur
+                     formulaire « Message »), seuls les résultats des cibles de niveau supérieur
+                     sont sérialisées si le commutateur -outputResultsCache
+                     fourni. Ceci permet d’atténuer les chances d’une
+                     violation d’isolation de la cible sur un projet de dépendance à l’aide de
+                     état incorrect en raison de sa dépendance sur une cible mise en cache
+                     dont les effets secondaires ne sont pas pris en compte.
+                     (Par exemple, définition d’une propriété.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+Il s’agit d’un mode plus restrictif de MSBuild, car il nécessite
+                     que le graphe du projet soit statiquement détectable sur
+                     temps d’évaluation, mais peut améliorer la planification et réduire
+                     surcharge mémoire lors de la génération d’un grand ensemble de projets.
+                     (Forme abrégée : -isolate)
 
-                     This flag is experimental and may not work as intended.
+Cet indicateur est expérimental et peut ne pas fonctionner comme prévu.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Liste des codes d’avertissement à traiter non comme des erreurs.
+                     Utiliser un point-virgule ou une virgule pour séparer
+                     plusieurs codes d’avertissement. N’a aucun effet si -warnaserror
+                     n’est pas défini.
 
-                     Example:
+                     Exemple:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -496,12 +550,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;niveau&gt; Volume d'inform. affiché dans le journal des événements
-         Les niveaux de détail disponibles sont : q[uiet], m[inimal],
-         n[ormal], d[etailed] et diag[nostic]. (Forme abrégée : -v)
-         Exemple :
-           -verbosity:quiet
+        <target state="translated">  -verbosity:&lt;level&gt; Affiche cette quantité d’informations dans le journal des événements.
+                     Les niveaux de verbosité disponibles sont : q[uiet], m[inimal],
+                     n[ormal], d[etailed] et diag[nostic]. (Forme abrégée : -v)
+                     Exemple:
+                       -verbosity:quiet
+
+Remarque : verbosité des enregistreurs d’événements de fichiers
+                           est défini séparément par
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -550,42 +612,42 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;paramètres&gt;
+         Paramètres du journaliseur de la console. (Forme abrégée : -clp)
+         Paramètres disponibles :
+            PerformanceSummary--Affiche la durée des tâches, des cibles
+                et des projets.
+            Summary--Récapitulatif des erreurs et des avertissements à la fin.
+            NoSummary--Aucun récapitulatif des erreurs et des avertissements
+                à la fin.
+            ErrorsOnly--Affiche uniquement les erreurs.
+            WarningsOnly--Affiche uniquement les avertissements.
+            NoItemAndPropertyList--N'affiche pas la liste des éléments et
+                des propriétés au début de chaque build de projet.
+            ShowCommandLine--Affiche les messages de TaskCommandLineEvent
+            ShowTimestamp--Affiche l'horodatage en tant que préfixe des
+                messages.
+            ShowEventId--Affiche eventId pour les événements démarrés et
+                achevés ainsi que les messages
+            ForceNoAlign--N'aligne pas le texte par rapport à la taille de la
+                mémoire tampon de la console
+            DisableConsoleColor--Utilise les couleurs de la console par défaut
+                pour tous les messages de journalisation.
+            DisableMPLogging--Désactive le style de journalisation
+                multiprocesseur de la sortie durant l'exécution en
+                mode non multiprocesseur.
+            EnableMPLogging--Active le style de journalisation multiprocesseur
+                même durant l'exécution en mode non
+                multiprocesseur. Style de journalisation activé par défaut.
+            ForceConsoleColor--Utilise les couleurs de la console ANSI même si
+                cela n'est pas pris en charge par la console
+            PreferConsoleColor-Utilise les couleurs de console ANSI uniquement si
+                            la console cible le prend en charge
+                     Verbosity--Remplace le paramètre -verbosity pour ce
+                            journaliseur.
+                     Exemple:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                                                 Verbosity=minimal
+                         Verbosity=minimal
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -684,10 +746,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Liste séparée par des points-virgules des fichiers de cache d’entrée que MSBuild
+                     lirea les résultats de build à partir de. Si -isolateProjects est défini
+                     à False, ce qui la définit sur True. (forme abrégée : -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -701,11 +763,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Fichier cache de sortie dans lequel MSBuild écrit le contenu de
+                     ses caches de résultats de build à la fin de la build.
+                     Si -isolateProjects a la valeur False, la valeur est True.
+                     (forme abrégée : -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1326,6 +1388,60 @@
         <target state="translated">Processus = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Le fichier projet n'existe pas.</target>
@@ -1371,6 +1487,22 @@
         <target state="translated">'{0}' provient de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauration terminée ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurer {0} en {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1434,7 +1566,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">Le commutateur '{0}' n’est pas pris en charge pour les fichiers solution.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 69fdd84340c..c73aa55fa05 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Compilazione {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">non riuscito</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">non riuscito con errori</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">non riuscito con avvisi</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">operazione riuscita</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">completato con avvisi</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -domanda
+                     (Sperimentale) Domanda se sono presenti attività di compilazione.
+                     MSBuild genera un errore quando rileva una destinazione o un'attività
+                     che può essere incrementale (con input e output),
+                     ma non è aggiornata.
+                     (Forma breve: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: il valore di priorità bassa non è valido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Versione di MSBuild Ł{0} per {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -172,25 +226,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| False]
+                     Fa in modo che MSBuild compili ogni progetto in isolamento.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+Se impostato su "MessageUponIsolationViolation" (o sul relativo breve
+                     modulo "Messaggio"), solo i risultati delle destinazioni di primo livello
+                     vengono serializzati se l'opzione -outputResultsCache è
+                     Fornito. Consente di ridurre le probabilità di un
+                     destinazione che viola l'isolamento in un progetto di dipendenza tramite
+                     stato non corretto a causa della dipendenza da una destinazione memorizzata nella cache
+                     i cui effetti collaterali non verrebbero presi in considerazione.
+                     (Ad esempio, la definizione di una proprietà.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+Questa è una modalità più restrittiva di MSBuild perché richiede
+                     che il grafico del progetto sia individuabile in modo statico
+                     tempo di valutazione, ma può migliorare la pianificazione e ridurre
+                     sovraccarico di memoria durante la compilazione di un set di progetti di grandi dimensioni.
+                     (Forma breve: -isolate)
 
-                     This flag is experimental and may not work as intended.
+Questo flag è sperimentale e potrebbe non funzionare come previsto.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -308,13 +362,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Elenco di codici di avviso da non considerare come errori.
+                     Usare un punto e virgola o una virgola per separare
+                     più codici di avviso. Non ha alcun effetto se l’opzione -warnaserror
+                     non è impostata.
 
-                     Example:
+                     Esempio:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -503,12 +557,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;livello&gt; Visualizza la quantità di informazioni specificata nel log eventi.
+        <target state="translated">  -verbosity:&lt;level&gt; Visualizza questa quantità di informazioni nel registro eventi.
                      I livelli di dettaglio disponibili sono: q[uiet], m[inimal],
-                     n[ormal], d[etailed] e diag[nostic]. Forma breve: -v.
+                     n[ormal], d[etailed] e diag[nostic]. (Forma breve: -v)
                      Esempio:
-                     -verbosity:quiet
+                       -verbosity:quiet
+
+Nota: livello di dettaglio dei logger di file
+                           è impostato separatamente da
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -557,40 +619,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parametri per il logger di console. (Forma breve: -clp)
+                     I parametri disponibili sono:
+                        PerformanceSummary: indica il tempo impiegato per le attività, le destinazioni
+                            e i progetti.
+                        Summary: visualizza un riepilogo degli errori e degli avvisi alla fine.
+                        NoSummary: non visualizza un riepilogo degli errori e degli avvisi alla
+                            fine.
+                        ErrorsOnly: visualizza solo gli errori.
+                        WarningsOnly: visualizza solo gli avvisi.
+                        NoItemAndPropertyList: non visualizza l'elenco di elementi e
+                            propertà all’inizio di ogni compilazione del progetto.
+                        ShowCommandLine: visualizza i messaggi TaskCommandLineEvent
+                        ShowTimestamp: visualizza il timestamp sotto forma di prefisso per ogni
+                            messaggio.
+                        ShowEventId: mostra l'ID evento per gli eventi iniziati, gli eventi finiti
+                            e i messaggi
+                        ForceNoAlign: non allinea il testo alle dimensioni del
+                            buffer della console
+                        DisableConsoleColor: usa i colori predefiniti della console
+                            per tutti i messaggi di registrazione.
+                        DisableMPLogging: disabilita lo stile di registrazione
+                            multiprocessore dell'output quando è in esecuzione in
+                             modalità non multiprocessore.
+                        EnableMPLogging: abilita lo stile di registrazione
+                            multiprocessore anche quando è in esecuzione in modalità non multiprocessore
+                            .  Si tratta dello stile di registrazione predefinito.
+                        ForceConsoleColor: usa i colori della console ANSI anche
+                            se non sono supportati dalla console.
+                        PreferConsoleColor: usa i colori della console ANSI solo se la
+                            console target li supporta.
+                     Verbosity: esegue l'override dell'impostazione per questo
                             logger.
-                     Example:
+                     Esempio:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -691,10 +753,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Elenco di file di cache di input separati da punto e virgola da cui MSBuild
+                     leggerà i risultati della compilazione. Se -isolateProjects è impostato
+                     su False, questo viene impostato su True. (forma breve: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -708,11 +770,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     File della cache di output in cui MSBuild scriverà il contenuto di
+                     cache dei risultati di compilazione al termine della compilazione.
+                     Se -isolateProjects è impostato su False, questo viene impostato su True.
+                     (forma breve: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -873,9 +935,8 @@
                      è la directory corrente. Per impostazione predefinita, ai
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
-                     essere specificati aggiungendo l'opzione
+                     essere specificati aggiungendo l'opzione "-fileLoggerParameters".
 
-                     "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito userà il nome
                      file come modello e aggiungerà l'ID del nodo per creare un
@@ -1337,6 +1398,60 @@
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: il file di progetto non esiste.</target>
@@ -1382,6 +1497,22 @@
         <target state="translated">'{0}' proviene da '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Ripristino completato ({0})</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Ripristinare {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1445,7 +1576,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">L'opzione '{0}' non è supportata per i file di soluzione.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
@@ -1808,16 +1939,15 @@ Esegue la profilatura della valutazione di MSBuild e scrive
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                      Imposta queste proprietà a livello di progetto o ne esegue
-                      l'override solo durante il ripristino e non usa le
-                      proprietà specificate con l'argomento -property.
-                      &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
-                      valore della proprietà. Usare il punto e virgola o la
-                      virgola per delimitare più proprietà o specificare ogni
-                      proprietà separatamente.
-                      Forma breve: -rp.
-                      Esempio:
-                        -restoreProperty:IsRestore=true;MyProperty=value
+                     Imposta queste proprietà a livello di progetto o ne esegue
+                     l'override solo durante il ripristino e non usa le
+                     proprietà specificate con l'argomento -property.
+                     &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
+                     valore della proprietà. Usare il punto e virgola o la
+                     virgola per delimitare più proprietà o specificare ogni proprietà separatamente.
+                     (Forma breve: -rp)
+                     Esempio:
+                       -restoreProperty:IsRestore=true;MyProperty=value
     </target>
         <note>
       LOCALIZATION: "-restoreProperty" and "-rp" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index a5be53ec818..5f6a0724a12 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">{1} 秒後に {0} をビルド</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">失敗しました</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">エラーで失敗しました</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">失敗し、警告が発生しました</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">成功しました</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">警告付きで成功</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (試験段階) ビルド作業があるかどうかに関する質問。
+                     ターゲットまたはタスクが検出されると MSBuild でエラーが発生し
+                     インクリメンタルである可能性はあるが (入力と出力を含む)、
+                     最新の状態ではありません。
+                     (短縮形: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: 低優先度値が無効です。 {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">MSBuild のバージョン {0} ({1})</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     MSBuild で各プロジェクトを分離してビルドするようにします。
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     "MessageUponIsolationViolation" (またはその短縮形
+                     "Message") に設定した場合、最上位レベルのターゲットからの結果のみ
+                     -outputResultsCache スイッチが供給された場合にシリアル化されます。
+                     これは、次の可能性を軽減するためです:
+                     ターゲットがキャッシュされたターゲットへの依存関係が原因で
+                     状態が正しくなく、依存関係プロジェクトの分離違反の場合、
+                     その副作用は考慮されません。
+                     (たとえば、プロパティの定義など)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     これは MSBuild のより制限の厳しいモードです。
+                     プロジェクト グラフが評価時に静的に検出可能な必要性があり、
+                     スケジュールを改善し、プロジェクトの大規模なセットをビルドするとき
+                     のメモリ オーバーヘッド削減することができるためです。
+                     (短縮形: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     このフラグは試験段階であるため、意図したとおりに動作しない可能性があります。
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     エラーとして扱わない警告コードのリスト。
+                     セミコロンまたはコンマを使用して、複数の警告コード
+                     を区切ります。-warnaserror スイッチが設定されていない場合
+                     効果はありません
 
-                     Example:
+                     例:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -496,12 +550,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; イベント ログに表示する情報量です。
-                     利用可能な詳細レベル: q[uiet]、m[inimal]、
-                     n[ormal]、d[etailed]、diag[nostic]。(短縮形: -v)
-                     例:
+        <target state="translated">  -verbosity:&lt;level&gt; この量の情報をイベント ログに表示します。
+                     利用可能な詳細レベル: q[uiet], m[inimal]、
+                     n[ormal], d[etailed]、および diag[nostic]。(短縮形: -v)
+                     例: 
                        -verbosity:quiet
+
+                     注意: ファイル ロガーの詳細度は
+                           以下によって個別に設定されます
+                           -fileloggerparameters。
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -550,40 +612,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     コンソール ロガーへのパラメーターです。(短縮形: -clp)
+                     利用可能なパラメーター: 
+                        PerformanceSummary--タスク、ターゲット、プロジェクトにかかった時間を
+                            表示します。
+                        Summary--最後にエラーと警告の概要を表示します。
+                        NoSummary--最後にエラーと警告の概要を表示
+                            しません。
+                        ErrorsOnly--エラーのみを表示します。
+                        WarningsOnly--警告のみを表示します。
+                        NoItemAndPropertyList--各プロジェクトのビルド開始時に、
+                            項目とプロパティのリストを表示しません。
+                        ShowCommandLine--TaskCommandLineEvent メッセージを表示します
+                        ShowTimestamp--Timestamp を任意のメッセージへのプレフィックスとして
+                            表示します。
+                        ShowEventId--開始されたイベント、終了したイベント、
+                            メッセージの eventId を表示します。
+                        ForceNoAlign--テキストを、コンソール バッファーの
+                            サイズに合わせません
+                        DisableConsoleColor--すべてのログ メッセージに対して
+                            既定のコンソール カラーを使用します。
+                        DisableMPLogging-- 非マルチプロセッサ モードで
+                            実行する際、マルチプロセッサの
+                            出力ログ形式を無効にします。
+                        EnableMPLogging--非マルチプロセッサ モードで
+                            実行する場合も、マルチプロセッサのログ形式を有効にします。
+                            このログ形式は、既定で有効です。
+                        ForceConsoleColor--コンソールでサポートされていない場合でも、
+                            ANSI コンソール カラーを使用します
+                        PreferConsoleColor--ターゲット コンソールでサポートしている場合のみ
+                            ANSI コンソール カラーを使用します
+                     Verbosity--このロガーの -verbosity 設定を
+                            上書きします。
+                     例::
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -684,10 +746,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild が入力キャッシュ ファイルのセミコロン区切りの一覧の
+                     ビルド結果の読み取り元。-isolateProjects が
+                     False に設定された場合、True に設定されます。(短縮形: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -701,11 +763,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                      MSBuild がビルドの終了時にビルド結果キャッシュ
+                     の内容を書き込む出力キャッシュ ファイル。
+                     -isolateProjects が False に設定されている場合、True に設定されます。
+                     (短縮形: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1326,6 +1388,60 @@
         <target state="translated">プロセス = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} 秒)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: プロジェクト ファイルが存在しません。</target>
@@ -1371,6 +1487,22 @@
         <target state="translated">`{0}`からの `{1}`</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">復元が完了しました ({0} 秒)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{1} 秒後に {0} を復元する</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1434,7 +1566,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">'{0}' スイッチはソリューション ファイルではサポートされていません。</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 1301551dbbf..5b6404ff8be 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">{0} 빌드({1}초)</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">실패</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">실패(오류 발생)</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">실패(경고 발생)</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">성공</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">성공(경고 발생)</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (실험) 빌드 작업이 있는지 질문합니다.
+                     증분할 수 있지만(입력 및 출력이 있음)
+                     최신 상태가 아닌 대상 또는 작업을 감지하면
+                     MSBuild에서 오류가 발생합니다.
+                     (약식: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: 낮은 우선 순위 값이 유효하지 않습니다. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">msbuild 버전 {0}({1}용)</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     MSBuild가 각 프로젝트를 격리 모드로 빌드하도록 합니다.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     "MessageUponIsolationViolation"(또는 약식 "Message")으로
+                     설정하면 -outputResultsCache 스위치가 제공되는
+                     경우 최상위 수준 대상의 결과만 직렬화됩니다.
+                     이는 부작용이 고려되지 않는 캐시된 대상에 대한
+                     종속성으로 인해 잘못된 상태를 사용하는 종속성
+                     프로젝트의 격리 위반 대상 존재 가능성을
+                     완화하기 위한 것입니다.
+                     (예: 속성 정의)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     이 모드는 평가 시 프로젝트 그래프를 정적으로
+                     검색할 수 있어야 하므로 보다 제한적인 MSBuild
+                     모드이지만 대규모 프로젝트 집합을 빌드할 때 예약
+                     기능을 개선하고 메모리 오버헤드를 줄일 수 있습니다.
+                     (약식: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     이 플래그는 실험적이며 의도한 대로 작동하지 않을 수 있습니다.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     오류로 처리하지 않을 경고 코드 목록입니다.
+                     세미콜론이나 쉼표를 사용하여 여러 경고 코드를
+                     구분합니다. -warnaserror 스위치가 설정되어 있지
+                     않으면 효과가 없습니다.
 
-                     Example:
+                     예:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -496,12 +550,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; 이벤트 로그에 이 정보의 양을 표시합니다.
-                     사용 가능한 세부 정보 표시 수준은 다음과 같습니다. q[uiet], m[inimal],
-                     n[ormal], d[etailed], 및 diag[nostic]. (약식: -v)
+        <target state="translated">  -verbosity:&lt;level&gt; 이벤트 로그에 이 정도 양의 정보를 표시합니다.
+                     사용 가능한 세부 정보 표시 수준에는 q[uiet], m[inimal],
+                     n[ormal], d[etailed], diag[nostic]이 있습니다. (약식: -v)
                      예:
                        -verbosity:quiet
+
+                     참고: 파일 로거의 세부 정보 표시는
+                           -fileloggerparameters에 의해
+                           별도로 설정됩니다.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -550,40 +612,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     콘솔 로거에 대한 매개 변수입니다. (약식: -clp)
+                     사용 가능한 매개 변수는 다음과 같습니다.
+                        PerformanceSummary--작업, 대상, 프로젝트에서 소요된 시간을 
+                            표시합니다.
+                        Summary--종료 시 오류 및 경고 요약을 표시합니다.
+                        NoSummary--종료 시 오류 및 경고 요약을 표시하지
+                            않습니다.
+                        ErrorsOnly--오류만 표시합니다.
+                        WarningsOnly--경고만 표시합니다.
+                        NoItemAndPropertyList--각 프로젝트 빌드를 시작할 때 항목 및 속성 목록을 
+                            표시하지 않습니다.
+                        ShowCommandLine--TaskCommandLineEvent 메시지를 표시합니다.
+                        ShowTimestamp--메시지 접두사로 타임스탬프를 
+                            표시합니다.
+                        ShowEventId--시작된 이벤트, 완료된 이벤트, 메시지의 eventId를 
+                            표시합니다.
+                        ForceNoAlign--콘솔 버퍼 크기에 텍스트를 맞추지 
+                            않습니다.
+                        DisableConsoleColor--모든 로깅 메시지에 기본 콘솔 색을
+                            사용합니다.
+                        DisableMPLogging--다중 프로세서가 아닌 모드에서 실행할 경우
+                            출력의 다중 프로세서 로깅 스타일을 
+                            사용하지 않도록 설정합니다.
+                        EnableMPLogging--다중 프로세서가 아닌 모드에서 실행할 경우에도
+                            다중 프로세서 로깅 스타일을 사용하도록 설정합니다.
+                            이 로깅 스타일은 기본적으로 활성화됩니다.
+                        ForceConsoleColor--콘솔에서 지원하지 않더라도 ANSI 콘솔 색을
+                            사용합니다
+                        PreferConsoleColor--대상 콘솔에서 지원되는 경우에만
+                             ANSI 콘솔 색을 사용합니다.
+                     Verbosity--이 로거에 대한 -verbosity 설정을 
+                            재정의합니다.
+                     예:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -684,10 +746,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild가 빌드 결과를 읽을 입력 캐시 파일의
+                     세미콜론으로 구분된 목록입니다. -isolateProjects가
+                     False로 설정된 경우 이로 인해 True로 설정됩니다. (약식: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -701,11 +763,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     빌드가 끝날 때 MSBuild에서 빌드 결과 캐시의
+                     콘텐츠를 쓸 출력 캐시 파일입니다.
+                     -isolateProjects가 False로 설정된 경우 이로 인해 True로 설정됩니다.
+                     (약식: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1326,6 +1388,60 @@
         <target state="translated">프로세스 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}초)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}초)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}초)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}초)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 프로젝트 파일이 없습니다.</target>
@@ -1371,6 +1487,22 @@
         <target state="translated">'{0}'은(는) '{1}'에서 제공되었습니다.</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">복원 완료({0}초)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{0} 복원({1}초)</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1434,7 +1566,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">솔루션 파일에는 '{0}' 스위치가 지원되지 않습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index ad89de51e2e..a201a075ab6 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Kompiluj {0} w {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">niepowodzenie</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">zakończono niepowodzeniem, z błędami</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">zakończono niepowodzeniem, z ostrzeżeniami.</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">powodzenie</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">zakończono powodzeniem, z ostrzeżeniem</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (Eksperymentalne) Pytanie, czy istnieje jakakolwiek kompilacja.
+                     Program MSBuild wyrzuci błąd, gdy wykryje element docelowy lub zadanie
+                     , które może być przyrostowe (ma dane wejściowe i wyjściowe),
+                     ale nie jest aktualne.
+                     (Skrócona forma: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: wartość niskiego priorytetu jest nieprawidłowa. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Wersja programu MSBuild {0} dla {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -172,25 +226,26 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Powoduje, że program MSBuild kompiluje każdy projekt osobno.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Po ustawieniu na wartość „MessageUponIsolationViolation” (lub jej skróconą
+                     formę „Message”), serializowane są tylko wyniki z celów najwyższego poziomu
+                     , jeśli przełącznik -outputResultsCache jest
+                     dostarczony. Ma to na celu zmniejszenie szans na to, że cel 
+                     naruszy izolację w projekcie zależnym przy użyciu
+                     nieprawidłowego stanu z powodu jego zależności od buforowanego celu
+                     którego efekty uboczne nie byłyby brane pod uwagę.
+                     (Na przykład definicja właściwości).
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Jest to bardziej restrykcyjny tryb MSBuild, ponieważ wymaga
+,
+                     aby graf projektu był statycznie wykrywalny w
+                     czasie ewaluacji, ale może też poprawiać planowanie i zmniejszyć
+                     pamięć podczas budowania dużego zestawu projektów.
+                     (Skrócona forma: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Ta flaga jest eksperymentalna i może nie działać zgodnie z przeznaczeniem.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -308,13 +363,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Lista kodów ostrzeżeń, które nie są traktowane jako błędy.
+                     Użyj średnika lub przecinka, aby oddzielić
+                     wiele kodów ostrzeżeń. Nie ma wpływu, jeśli przełącznik -warnaserror
+                     nie jest ustawiony.
 
-                     Example:
+                     Przykład:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -470,17 +525,14 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania
-                         zdarzeń pochodzących z programu MSBuild. Aby określić
-                     wiele rejestratorów, określ każdy z nich osobno.
+        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania zdarzeń pochodzących
+                     z programu MSBuild. Aby określić wiele rejestratorów, określ każdy z nich osobno.
                      Składnia elementu &lt;rejestrator&gt;:
-                        [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
-                        [;&lt;parametry rejestratora&gt;]
+                      [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt; [;&lt;parametry rejestratora&gt;]
                      Składnia elementu &lt;klasa rejestratora&gt;:
-                        [&lt;częściowa lub pełna przestrzeń nazw&gt;.]
-                        &lt;nazwa klasy rejestratora&gt;
+                       [&lt;częściowa lub pełna przestrzeń nazw&gt;.] &lt;nazwa klasy rejestratora&gt;
                      Składnia elementu &lt;zestaw rejestratora&gt;:
-                        {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                       {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
                      Wartości &lt;parametry rejestratora&gt; są opcjonalne i są
                      przekazywane do rejestratora dokładnie tak, jak zostały
                      wpisane. (Krótka wersja: -l)
@@ -503,12 +555,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;poziom&gt; Wyświetla podaną ilość informacji w dzienniku zdarzeń.
-                     Dostępne poziomy szczegółowości: q[uiet], m[inimal],
-                     n[ormal], d[etailed] i diag[nostic]. (Krótka wersja: /v)
+        <target state="translated">  -verbosity:&lt;level&gt; Wyświetl tę ilość informacji w dzienniku zdarzeń.
+                     Dostępne poziomy szczegółowości to: q[uiet], m[inimal],
+                     n[ormal], d[etailed], and diag[nostic]. (Skrócona forma: -v)
                      Przykład:
-                       -verbosity:quiet
+                       -verbosity:cichy
+
+                     Note: szczegółowość rejestratorów plików
+                           jest ustawiana oddzielnie przez
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -557,40 +617,41 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parametry rejestratora konsoli. (Krótka wersja: -clp)
+                     Dostępne parametry:
+                        PerformanceSummary--pokazuje czas spędzony na zadaniach, elementach docelowych
+                        i projektach.
+                        Summary--pokazuje na końcu podsumowanie błędów i ostrzeżeń.
+                        NoSummary--nie pokazuje na końcu podsumowania błędów
+                        i ostrzeżeń.
+                        ErrorsOnly--pokazuje tylko błędy.
+                        WarningsOnly--pokazuje tylko ostrzeżenia.
+                        NoItemAndPropertyList--nie pokazuje listy elementów i
+                        właściwości na początku każdej kompilacji projektu.
+                        ShowCommandLine--pokazuje komunikaty TaskCommandLineEvent
+                        ShowTimestamp--wyświetla sygnaturę czasową jako prefiks każdego
+                        komunikatu.
+                        ShowEventId--pokazuje identyfikator zdarzenia dla rozpoczętych zdarzeń, zakończonych
+                        zdarzeń i komunikatów.
+                        ForceNoAlign--nie dopasowuje tekstu do rozmiaru
+                        buforu konsoli.
+                        DisableConsoleColor--używa domyślnych kolorów konsoli
+                            dla wszystkich komunikatów dotyczących rejestrowania.
+                        DisableMPLogging--wyłącza styl rejestrowania
+                        wieloprocesorowego wyników podczas działania w
+                        trybie nie-wieloprocesorowym.
+                        EnableMPLogging--włącza styl rejestrowania wieloprocesorowego
+                        nawet podczas działania w trybie nie-wieloprocesorowym
+                        Ten styl rejestrowania jest włączony domyślnie.
+                        ForceConsoleColor--używa kolorów konsoli ANSI nawet wtedy
+,
+                            gdy konsola ich nie obsługuje
+                        PreferConsoleColor--używa kolorów konsoli ANSI tylko gdy
+                            konsola docelowa obsługuje tę funkcję
+                        Verbosity--zastępuje ustawienie -szczegółowość dla tego
+                        rejestratora.
+                     Przykład:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -691,10 +752,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Rozdzielona średnikami lista wejściowych plików pamięci podręcznej, z których MSBuild 
+                     odczyta wyniki kompilacji. Jeśli jest ustawione -isolateProjects
+                     na wartość Fałsz, ta opcja ustawia ją na wartość Prawda. (skrócona forma: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -708,11 +769,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Wyjściowy plik pamięci podręcznej, w którym program MSBuild zapisze zawartość
+                     pamięci podręcznej wyników kompilacji na końcu kompilacji.
+                     Jeśli -isolateProjects jest ustawiona na wartość Fałsz, to ustawia je na wartość Prawda.
+                     (skrócona forma: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -780,7 +841,7 @@
                      Example:
                        -ignoreProjectExtensions:.sln
     </source>
-        <target state="translated">-ignoreProjectExtensions:&lt;rozszerzenia&gt;
+        <target state="translated">  -ignoreProjectExtensions:&lt;rozszerzenia&gt;
                      Lista rozszerzeń, które mają zostać zignorowane podczas
                      ustalania pliku projektu do kompilacji. Przy użyciu średnika lub przecinka
                      można rozdzielać wiele rozszerzeń.
@@ -866,13 +927,11 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     Rejestruje dane wyjściowe kompilacji w wielu plikach
-                     dziennika, po jednym pliku na węzeł programu MSBuild.
-                     Początkową lokalizacją tych plików jest bieżący katalog.
-                     Domyślnie pliki mają nazwę
+                     Rejestruje dane wyjściowe kompilacji w wielu plikach dziennika,po jednym pliku
+                     na węzeł programu MSBuild. Początkową lokalizacją tych plików
+                     jest bieżący katalog. Domyślnie pliki mają nazwę
                      „MSBuild&lt;identyfikator węzła&gt;.log”. Lokalizację plików
                      i inne parametry rejestratora plików można określić
-
                      przez dodanie przełącznika „-fileLoggerParameters”.
 
                      Jeśli nazwa pliku zostanie ustawiona za pomocą przełącznika
@@ -1335,6 +1394,60 @@
         <target state="translated">Proces = „{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: plik projektu nie istnieje.</target>
@@ -1380,6 +1493,22 @@
         <target state="translated">Element „{0}“ pochodzi z „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Zakończono przywracanie ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Przywróć {0} w {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1443,7 +1572,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">Przełącznik „{0}” nie jest obsługiwany dla plików rozwiązań.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
@@ -1786,7 +1915,7 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
                      w określonym pliku. Jeśli rozszerzenie określonego
                      pliku to „md”, wynik jest generowany w formacie znaczników
                      markdown. W przeciwnym razie jest tworzony plik rozdzielany tabulatorami.
-</target>
+    </target>
         <note />
       </trans-unit>
       <trans-unit id="HelpMessage_33_RestorePropertySwitch">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 6748b6a2266..7099c69d7bd 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Construir {0} em {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">falhou</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">falhou com erros</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">falhou com avisos</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">êxito</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">êxito com avisos</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -pergunta
+                     (Experimental) Questione se há algum trabalho de construção.
+                     O MSBuild apresentará um erro ao detectar um destino ou tarefa
+                     que pode ser incremental (possui entradas e saídas),
+                     não está atualizado.
+                     (forma abreviada: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: o valor de baixa prioridade não é válido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Versão do MSBuild {0} para {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -172,25 +226,25 @@ arquivo de resposta.
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolarProjects[:True|MessageUponIsolationViolation|False]
+                     Faz com que o MSBuild crie cada projeto isoladamente.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Quando definido como "MessageUponIsolationViolation" (ou sua abreviação
+                     formulário "Mensagem"), apenas os resultados dos alvos de nível superior
+                     são serializados se a opção -outputResultsCache for
+                     fornecido. Isso é para mitigar as chances de um
+                     alvo de violação de isolamento em um projeto de dependência usando
+                     estado incorreto devido à sua dependência de um destino armazenado em cache
+                     cujos efeitos colaterais não seriam levados em consideração.
+                     (Por exemplo, a definição de uma propriedade.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Este é um modo mais restritivo do MSBuild, pois requer
+                     que o gráfico do projeto seja descoberto estaticamente em
+                     tempo de avaliação, mas pode melhorar o agendamento e reduzir
+                     sobrecarga de memória ao criar um grande conjunto de projetos.
+                     (forma abreviada: -isolar)
 
-                     This flag is experimental and may not work as intended.
+                     Este sinalizador é experimental e pode não funcionar conforme o esperado.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -305,13 +359,13 @@ arquivo de resposta.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warningNotAsError[:code[;code2]]
+                     Lista de códigos de aviso para tratar e não tratar como erros.
+                     Use ponto e vírgula ou vírgula para separar
+                     vários códigos de advertência. Não tem efeito se o -warnaserror
+                     interruptor não está definido.
 
-                     Example:
+                     Exemplo:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -497,12 +551,20 @@ arquivo de resposta.
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; Exibir este volume de informações no log de eventos.
-                     Os níveis de detalhamento disponíveis são: q[uiet], m[inimal],
-                     n[ormal], d[etailed] e diag[nostic]. (Forma abreviada: -v)
+        <target state="translated">  -verbosidade:&lt;level&gt; Exibe essa quantidade de informações no log de eventos.
+                     Os níveis de verbosidade disponíveis são: q[uiet], m[inimal],
+                     n[ormal], d[detalhado] e diag[nóstico]. (forma abreviada: -v)
                      Exemplo:
-                       -verbosity:quiet
+                       - verbosidade: quieto
+
+                     Nota: verbosidade dos registradores de arquivos
+                           é definido separadamente por
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -551,42 +613,42 @@ arquivo de resposta.
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parâmetros para o logger do console. (forma abreviada: -clp)
+                     Os parâmetros disponíveis são:
+                        PerformanceSummary--Mostra o tempo gasto em tarefas, alvos
+                            e projetos.
+                        Resumo--Mostra o resumo do erro e do aviso no final.
+                        NoSummary--Não mostra o resumo de erros e avisos no
+                            fim.
+                        ErrorOnly--Mostrar apenas erros.
+                        WarningsOnly--Mostra apenas avisos.
+                        NoItemAndPropertyList--Não mostra a lista de itens e
+                            properties no início de cada compilação do projeto.
+                        ShowCommandLine--Mostra mensagens TaskCommandLineEvent
+                        ShowTimestamp--Exibe o timestamp como um prefixo para qualquer
+                            mensagem.
+                        ShowEventId--Mostra eventId para eventos iniciados, concluídos
+                            eventos e mensagens
+                        ForceNoAlign--Não alinha o texto ao tamanho de
+                            o buffer do console
+                        DisableConsoleColor--Use as cores padrão do console
+                            para todas as mensagens de registro.
+                        DisableMPLogging-- Desativa o multiprocessador
+                            estilo de registro de saída ao executar em
+                            modo não multiprocessador.
+                        EnableMPLogging--Habilita o log do multiprocessador
+                            estilo mesmo quando executado em não multiprocessador
+                            modo. Esse estilo de criação de log está ativado por padrão.
+                        ForceConsoleColor--Use as cores do console ANSI mesmo se
+                            o console não suporta isso
+                        PreferConsoleColor--Use as cores do console ANSI somente se
+                            o console de destino suporta isso
+                     Verbosity--substitui a configuração -verbosity para este
+                            registrador.
+                     Exemplo:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                                                 Verbosity=minimal
+                                                 Verbosidade=mínimo
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -685,10 +747,10 @@ arquivo de resposta.
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Lista separada por ponto-e-vírgula de arquivos de cache de entrada que o MSBuild
+                     irá ler os resultados da compilação. Se -isolateProjects estiver definido
+                     para Falso, isso o define como Verdadeiro. (forma abreviada: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -702,11 +764,11 @@ arquivo de resposta.
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     Arquivo de cache de saída onde o MSBuild gravará o conteúdo de
+                     seu resultado de compilação é armazenado em cache no final da compilação.
+                     Se -isolateProjects for definido como False, isso o definirá como True.
+                     (forma abreviada: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1327,6 +1389,60 @@ arquivo de resposta.
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Arquivo de projeto não existe.</target>
@@ -1372,6 +1488,22 @@ arquivo de resposta.
         <target state="translated">'{0}' proveniente de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauração concluída ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurar {0} em {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1435,7 +1567,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">A opção '{0}' não é suportada para arquivos de solução.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index cc0e700b31a..ffda16e7ca3 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Сборка {0} через {1} с</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">сбой</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">сбой с ошибками</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">сбой с предупреждениями</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">успешно выполнено</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">успешно выполнено с предупреждением</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (Экспериментальный параметр) Запрашивает, есть ли работа по сборке.
+                     MSBuild выдает ошибку при обнаружении целевого объекта или задачи,
+                     которые могут быть добавочными (с входными и выходными данными),
+                     но не обновлены.
+                     (Краткая форма: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: недопустимое значение низкого приоритета. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">Версия MSBuild {0} для {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -170,25 +224,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     MSBuild выполняет сборку каждого проекта изолированно.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     Если задано значение "MessageUponIsolationViolation" или его краткая
+                     форма "Message"), то происходит сериализация результатов только целевых объектов
+                     верхнего уровня, если указан параметр -outputResultsCache.
+                     Этот параметр позволяет исключить ситуацию, когда
+                     нарушающий изоляцию целевой объект в проекте зависимости может использовать
+                     неверное состояние из-за зависимости от кэшированного целевого объекта,
+                     побочные эффекты которого не учитываются.
+                     (Например, определение какого-либо свойства.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Это режим MSBuild с более строгими ограничениями,
+                     поскольку для него требуется, чтобы граф проекта был статически обнаруживаемым во
+                     время проверки. Тем не менее, при этом улучшается планирование и снижается
+                     избыточное использование памяти при сборки крупного набора проектов.
+                     (Краткая форма: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Это экспериментальный флаг, он может работать неправильно.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -303,13 +357,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:код[;код2]]
+                     Список кодов предупреждений, которые не следует обрабатывать в качестве ошибок.
+                     Используйте точку с запятой или запятую, чтобы разделить
+                     несколько кодов предупреждения. Не действует, если параметр -warnaserror
+                     не задан.
 
-                     Example:
+                     Пример:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -495,12 +549,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;уровень&gt; Отображать эти сведения в журнале событий.
-                     Доступными уровнями детализации являются: q[uiet], m[inimal],
-                     n[ormal], d[etailed] и diag[nostic]. (Краткая форма: -v)
+        <target state="translated">  -verbosity:&lt;уровень&gt; Уровень детализации сведений в журнале событий.
+                     Доступные уровни детализации: q (или quiet) — отсутствует, m (или minimal) — минимальный,
+                     n (или normal) — обычный, d (или detailed) — подробный, diag (или diagnostic) — диагностика. (Краткая форма: -v)
                      Пример:
                        -verbosity:quiet
+
+                     Примечание. Детализация средств ведения журналов файлов
+                           устанавливается отдельно с помощью
+                           -fileloggerparameters.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -549,40 +611,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;параметры&gt;
+                     Параметры средства ведения журнала консоли. (Краткая форма: -clp)
+                     Доступны следующие параметры:
+                        PerformanceSummary--показывать время, затраченное на выполнение задач,
+                            целевых объектов и проектов.
+                        Summary--показывать сводку ошибок и предупреждений по завершении работы.
+                        NoSummary--не показывать сводку ошибок и предупреждений по
+                            завершении работы.
+                        ErrorsOnly--показывать только ошибки.
+                        WarningsOnly--показывать только предупреждения.
+                        NoItemAndPropertyList--не показывать список элементов и
+                            свойств в начале сборки каждого проекта.
+                        ShowCommandLine--показывать сообщения TaskCommandLineEvent
+                        ShowTimestamp--показывать метку времени в качестве префикса к любому
+                            сообщению.
+                        ShowEventId--показывать код события eventId для запущенных событий,
+                            завершенных событий и сообщений
+                        ForceNoAlign--не выравнивать текст относительно размера
+                            буфера консоли
+                        DisableConsoleColor--использовать цвета консоли по умолчанию
+                            для всех сообщений ведения журнала.
+                        DisableMPLogging--отключить многопроцессорный
+                            стиль ведения журнала выходных данных при работе в
+                            режиме, отличном от многопроцессорного.
+                        EnableMPLogging--включить многопроцессорный стиль ведения журнала
+                            даже при работе в режиме, отличном от
+                            многопроцессорного. Этот стиль ведения журнала включен по умолчанию.
+                        ForceConsoleColor--использовать цвета консоли ANSI, даже если
+                            консоль не поддерживает их
+                        PreferConsoleColor--использовать цвета консоли ANSI лишь в случае, если
+                            целевая консоль поддерживает их
+                     Verbosity--переопределяет параметр -verbosity (уровень детализации) для этого
+                            средства ведения журнала.
+                     Пример:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -683,10 +745,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;файл кэша&gt;...
+                     Список входных файлов кэша (разделитель — точка с запятой), из которых MSBuild
+                     будет читать результаты сборки. Если для параметра -isolateProjects задано значение
+                     "False", то оно будет изменено на "True". (Краткая форма: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -700,11 +762,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[файл кэша]
+                     Выходной файл кэша, в который MSBuild будет записывать содержимое
+                     кэша результата сборки по окончании сборки.
+                     Если для параметра -isolateProjects задано значение "False", оно будет изменено на "True".
+                     (Краткая форма: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1325,6 +1387,60 @@
         <target state="translated">Процесс = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} с)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} с)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} с)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} с)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: файл проекта не существует.</target>
@@ -1370,6 +1486,22 @@
         <target state="translated">\"{0}\" получен из \"{1}\"</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Восстановление завершено ({0} с)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Восстановление {0} через {1} с</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1433,7 +1565,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">Параметр "{0}" не поддерживается для файлов решений.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 1b5386bf3fd..2e8fde26de2 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">"{1}" sn'de {0} oluşturun</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">başarısız oldu</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">hatalarla başarısız oldu</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">uyarılarla başarısız oldu</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">başarılı</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">uyarılarla birlikte başarılı</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -soru
+                     (Deneysel) Derleme çalışması olup olmadığını sorgulayın.
+                     MSBuild bir hedef veya görev algılandığında hataya neden olacak
+                     artımlı (girişler ve çıkışlar içeren),
+                     ancak güncel değil.
+                     (Kısa biçim: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: Düşük öncelikli değer geçerli değil. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">{1} için MSBuild sürüm {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True| MessageUponIsolationViolation| False]
+                     MSBuild'in her projeyi yalıtımda derlemesini sağlar.
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     "MessageUponIsolationViolation" olarak ayarlandığında (veya kısa
+                     form "İleti"), yalnızca üst düzey hedeflerden gelen sonuçlar
+                     -outputResultsCache anahtarı şu olduğunda seri hale getirilebilir:
+                     Sağlanan. Bu, bir
+                     yalıtım ihlal eden hedef, bir bağımlılık projesini kullanan
+                     önbelleğe alınmış bir hedefte bağımlılığı nedeniyle hatalı durum
+                     yan etkileri hesaplanmadı.
+                     (Örneğin, bir özelliğin tanımı.)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     Bu, gerektirdiği şekilde daha kısıtlayıcı bir MSBuild modu
+                     proje grafiği statik olarak bulunabilir
+                     ancak zamanlamanın geliştirilmesine ve daha az
+                     büyük bir proje kümesi oluşturulurken bellek ek yükü.
+                     (Kısa form: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     Bu bayrak deneyseldir ve amaçlandık şekilde çalışmayabilir.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     Hata olarak değerlendirilmeyecek uyarı kodlarının listesi.
+                     Birden çok uyarı kodunu ayırmak için noktalı virgül
+                     veya virgül kullanın. -warnaserror anahtarı ayarlanmamışsa
+                     hiçbir etkisi yoktur.
 
-                     Example:
+                     Örnek:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -496,12 +550,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;düzey&gt; Olay günlüğünde bu miktarda bilgi görüntüler.
-                     Kullanılabilen ayrıntı düzeyleri: q[uiet], m[inimal],
-                     n[ormal], d[etailed] ve diag[nostic]. (Kısa biçim: -v)
+        <target state="translated">  -verbosity:&lt;level&gt; Bu miktarda bilgiyi olay günlüğünde görüntüle.
+                     Kullanılabilir verbosity seviyeleri şunlardır: q[uiet], m[inimal],
+                     n[ormal], d[etailed], and diag[nostic]. (Kısa biçim: -v)
                      Örnek:
-                       /verbosity:quiet
+                       -verbosity:quiet
+
+                     Not: Dosya kaydedicilerin verbosity’si
+                           -fileloggerparameters tarafından
+                           ayrı olarak ayarlanır.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -550,40 +612,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Konsol günlüğü için parametreler. (Kısa form: -clp)
+                     Mevcut parametreler:
+                        PerformanceSummary--Görevlerde, hedeflerde harcanan zamanı göster
+                            ve projelerde.
+                        Summary--Sonunda hata ve uyarı özetini göster.
+                        NoSummary--Sonunda hata ve uyarı özeti
+                            gösterme.
+                        ErrorsOnly--Yalnızca hataları göster.
+                        WarningsOnly--Yalnızca uyarıları göster.
+                        NoItemAndPropertyList--Her proje derlemesinin başlangıcında öğe
+                            ve özellik listesini gösterme.
+                        ShowCommandLine--TaskCommandLineEvent mesajlarını göster
+                        ShowTimestamp--Zaman Damgasını herhangi bir iletinin öneki olarak
+                            görüntüleyin.
+                        ShowEventId--Başlatılan olaylar, biten olaylar ve mesajlar için
+                            eventId'i göster
+                        ForceNoAlign--Metni konsol arabelleğinin boyutuna
+                            hizalamaz
+                        DisableConsoleColor--Tüm günlük iletileri için varsayılan konsol
+                            renklerini kullanın.
+                        DisableMPLogging-- Çok işlemcili olmayan modda
+                            çalışırken çıktının çok işlemcili günlüğe kaydetme stilini
+                            devre dışı bırakın.
+                        EnableMPLogging--Çok işlemcili olmayan modda çalışırken bile
+                            çok işlemcili günlüğe kaydetme stilini
+                            etkinleştirin. Bu günlük kaydı stili varsayılan olarak açıktır.
+                        ForceConsoleColor--Konsol desteklemese bile ANSI
+                            konsol renklerini kullanın
+                        PreferConsoleColor--ANSI konsol renklerini yalnızca
+                            hedef konsol destekliyorsa kullanın
+                     Verbosity--bu günlükçü için -verbosity ayarını geçersiz
+                            kılar.
+                     Örnek:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -684,10 +746,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild tarafından sağlanan giriş önbelleği dosyalarının noktalı virgülle ayrılmış listesi
+                     derleme sonuçlarını okuyacak. -isolateProjects False olarak
+                      ayarlanırsa bunu True olarak ayarlar. (kısa biçim: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -701,11 +763,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     MSBuild'in içeriklerini yazacağı çıktı önbellek dosyası
+                     derlemenin sonundaki derleme sonucu önbellekleri.
+                     -isolateProjects False olarak ayarlanırsa, bunu True olarak ayarlar.
+                     (kısa biçim: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -774,10 +836,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantılar&gt;
-                     Hangi proje dosyasının oluşturulacağı belirlenirken 
-                     yoksayılacak uzantıların listesi. Birden çok uzantıyı 
-                     birbirinden ayırmak için noktalı virgül veya 
-                     virgül kullanın.
+                     Hangi proje dosyasının oluşturulacağı belirlenirken
+                     yoksayılacak uzantıların listesi. Birden çok uzantıyı
+                     birbirinden ayırmak için noktalı virgül veya virgül kullanın.
                      (Kısa biçim: -ignore)
                      Örnek:
                        -ignoreProjectExtensions:.sln
@@ -867,7 +928,6 @@
                      Dosyaların konumu ve fileLogger'ın diğer parametreleri 
                      "/fileLoggerParameters" anahtarının eklenmesi yoluyla
                      belirtilebilir.
-
                      Günlük dosyası adı fileLoggerParameters anahtarı
                      aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName 
                      değerini şablon olarak kullanıp her düğümün günlük dosyasını
@@ -914,32 +974,31 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya günlükçüleri için ek parametreler sağlar.
-                     Bu anahtarın olması karşılık gelen -fileLogger[n] 
+                     Bu anahtarın olması karşılık gelen -fileLogger[n]
                      anahtarının olduğu anlamına gelir.
                      "n" varsa, 1-9 arasında bir rakam olabilir.
-                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters 
-                     bunlar tarafından da kullanılır; -distributedFileLogger 
-                     açıklamasına bakın.
+                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters
+                     bunlar tarafından da kullanılır; -distributedFileLogger açıklamasına bakın.
                      (Kısa biçim: -flp[n])
-                     Konsol günlükçüsü için listelenenlerle aynı parametreler 
+                     Konsol günlükçüsü için listelenenlerle aynı parametreler
                      kullanılabilir. Kullanılabilecek bazı ek parametreler:
-                        LogFile--Oluşturma günlüğünün yazılacağı günlük 
+                        LogFile--Oluşturma günlüğünün yazılacağı günlük
                             dosyasının yolu.
-                        Append--Derleme günlüğünün gün dosyasının sonuna mı 
-                            ekleneceğini yoksa üzerine mi yazılacağını 
-                            belirler. Anahtar ayarlandığında oluşturma günlüğü 
-                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında 
-                            varolan günlük dosyasının üzerine yazılır. 
+                        Append--Derleme günlüğünün gün dosyasının sonuna mı
+                            ekleneceğini yoksa üzerine mi yazılacağını
+                            belirler. Anahtar ayarlandığında oluşturma günlüğü
+                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında
+                            varolan günlük dosyasının üzerine yazılır.
                             Varsayılan: günlük dosyasının sonuna eklenmez.
-                        Encoding--Dosyanın kodlamasını belirtir; örneğin, 
+                        Encoding--Dosyanın kodlamasını belirtir; örneğin,
                             UTF-8, Unicode veya ASCII
                      Varsayılan ayrıntı düzeyi ayarı Detailed'dır.
                      Örnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -963,8 +1022,7 @@
                        -nr:true
     </source>
         <target state="translated">  -nodeReuse:&lt;parametreler&gt;
-                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir
-                     veya devre dışı bırakır.
+                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir veya devre dışı bırakır.
                      Parametreler:
                      True --Derleme tamamlandıktan sonra düğümler kalır ve
                             izleyen derlemelerde yeniden kullanılır (varsayılan)
@@ -1330,6 +1388,60 @@
         <target state="translated">İşlem = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}sn)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3}({4}sn)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}sn)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3}({4}sn)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Proje dosyası yok.</target>
@@ -1375,6 +1487,22 @@
         <target state="translated">'{0}', '{1}' kaynağından geldi</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Geri yükleme tamamlandı ({0}sn)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{1}sn içinde {0} geri yükle</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1438,7 +1566,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">Çözüm dosyaları için '{0}' anahtarı desteklenmez.</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
@@ -1781,7 +1909,7 @@
                      belirtilen dosyaya yazar. Belirtilen dosyanın uzantısı
                      '.md' ise, sonuç markdown biçiminde oluşturulur.
                      Aksi halde, sekme ayrılmış bir dosya oluşturulur.
-</target>
+    </target>
         <note />
       </trans-unit>
       <trans-unit id="HelpMessage_33_RestorePropertySwitch">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 49cea80b9e3..863ffedade5 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">在 {1} 中生成 {0}</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">失败</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">失败，出现错误</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">失败，出现警告</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">已成功</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">成功，但出现警告</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (实验性)问题，是否存在任何生成工作。
+                     当MSBuild检测到一个可以增量执行的
+                     目标或任务，但不是最新
+                     版本时，将会报错。
+                     (缩写: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: 低优先级值无效。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">适用于 {1} MSBuild 版本 {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     使 MSBuild 以隔离方式生成每个项目。
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     设置为 “MessageUponIsolationViolation” (或其缩写
+                     窗体“Message”)时，仅在提供了 -outputResultsCache 开关的情况下才会
+                     序列化来自顶级目标的
+                     结果。这是为了减少依赖项目上的孤立
+                     违规目标使用不正确状态的
+                     可能性，因为它依赖于一个缓存目标
+                     其副作用不会被考虑在内。
+                     (例如，属性的定义。)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     这是 MSBuild 的更严格的模式，因为它需要
+                     在评估时静态地发现项目图
+                     但可以改善调度并减少构建
+                     大量项目时的内存开销。
+                     (缩写: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     此标志是实验性的，可能无法按预期工作。
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     不视为错误的警告代码列表.
+                     使用分号或逗号分隔
+                     多个警告代码。如果未设置 -warnaserror
+                     开关，则不会产生任何影响。
 
-                     Example:
+                     示例:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -496,12 +550,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;level&gt; 在事件日志中显示此级别的信息量。
-           可用的详细程度有: q[uiet]、 m[inimal]、
-           n[ormal]、d[etailed] 和 diag[nostic]。(缩写: -v)
-           示例:
+        <target state="translated">  -verbosity:&lt;level&gt; 事件日志中显示此信息量。
+                     可用的详细级别为: q[uiet]、m[inimal]、
+                     n[ormal]、d[etailed] 和 diag[nostic]。(缩写: -v)
+                     示例:
                        -verbosity:quiet
+
+                     注意: 文件记录器的详细程度
+                           由 -fileloggerparameters
+                           单独设置。
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -550,42 +612,42 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
-                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                                                 Verbosity=minimal
+        <target state="translated">  -consoleloggerparameters:&lt;parameters&gt;
+           控制台记录器的参数。(缩写: -clp)
+           可用参数包括:
+            PerformanceSummary -- 显示在任务、目标和项目上
+              花费的时间。
+            Summary -- 结束时显示错误和警告的摘要。
+            NoSummary -- 结束时不显示错误和警告
+              的摘要。
+            ErrorsOnly -- 仅显示错误。
+            WarningsOnly -- 仅显示警告。
+            NoItemAndPropertyList -- 在开始生成每个项目时不显示
+              项和属性的列表。
+            ShowCommandLine -- 显示 TaskCommandLineEvent 消息 
+            ShowTimestamp -- 将时间戳作为所有消息的前缀
+              显示。                      
+            ShowEventId -- 显示已开始事件、已完成事件和消息
+              的事件 ID。
+            ForceNoAlign -- 不将文本与控制台缓冲区的大小
+              匹配。
+            DisableConsoleColor -- 将默认控制台颜色
+              用于所有记录消息。
+            DisableMPLogging -- 在非多处理器
+              模式下运行时，禁用输出的多处理器
+              日志记录样式。
+            EnableMPLogging -- 即使在非多处理器
+              模式下运行，也启用多处理器
+              日志记录样式。默认情况下启用此日志记录样式。
+                        ForceConsoleColor--使用 ANSI 控制台颜色，即使
+                            控制台不支持它
+                        PreferConsoleColor--仅在目标控制台支持时
+                            使用 ANSI 控制台颜色
+                     Verbosity -- 重写此记录器的 -verbosity
+              设置。
+           示例:
+                        -consoleloggerparameters:PerformanceSummary;NoSummary;
+                         Verbosity=minimal
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -684,10 +746,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     分号分隔的输入缓存文件列表，MSBuild
+                     将从中读取构建结果。如果 -isolateProjects 设置
+                     为 False，则将其设置为 True。(缩写: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -701,11 +763,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     将构建结果缓存内容写入 MSBuild 将在
+                     构建结束时生成的输出缓存文件。
+                     如果 -isolateProjects 设置为 False，则将其设置为 True。
+                     (缩写: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1326,6 +1388,60 @@
         <target state="translated">进程 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3})</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4})</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3})</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4})</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 项目文件不存在。</target>
@@ -1371,6 +1487,22 @@
         <target state="translated">“{0}”来自“{1}”</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">还原完成({0})</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">在 {1} 中还原 {0}</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1434,7 +1566,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">解决方案文件不支持“{0}”开关。</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b44006c9790..fcf5a24ad65 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">在 {1} 秒內建置 {0}</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">失敗</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="translated">失敗但有錯誤</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="translated">失敗但有警告</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">成功</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="translated">成功但有警告</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -36,22 +80,32 @@
                      but isn't up to date.
                      (Short form: -q)
     </source>
-        <target state="new">  -question
-                     (Experimental) Question whether there is any build work.
-                     MSBuild will error out when it detects a target or task
-                     that can be incremental (has inputs and outputs),
-                     but isn't up to date.
-                     (Short form: -q)
+        <target state="translated">  -question
+                     (實驗性) 問題: 是否有任何組建可運作。
+                     MSBuild 偵測到可增量 (有輸入和輸出)
+                     但並非最新的目標或工作時，
+                     它會發生錯誤。
+                     (簡短形式: -q)
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidLowPriorityValue">
+        <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1064: 低優先順序值無效。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1064: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="new">MSBuild version {0} for {1}</target>
+        <target state="translated">{1} 的 MSBuild 版本 {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -171,25 +225,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
-                     Causes MSBuild to build each project in isolation.
+        <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     導致 MSBuild 在隔離中建置每個專案。
 
-                     When set to "MessageUponIsolationViolation" (or its short
-                     form "Message"), only the results from top-level targets
-                     are serialized if the -outputResultsCache switch is
-                     supplied. This is to mitigate the chances of an
-                     isolation-violating target on a dependency project using
-                     incorrect state due to its dependency on a cached target
-                     whose side effects would not be taken into account.
-                     (For example, the definition of a property.)
+                     設定為 "MessageUponIsolationViolation" 
+                     (或其簡短形式 "Message") 時，如果提供 
+                     -outputResultsCache 切換，則只會序列化來自
+                     頂層目標的結果。這是為了降低相依性專案上，
+                     由於其相依性位於快取目標上 (其副作用
+                     不會納入考量)，而使用不正確狀態
+                     造成違反隔離目標的機會。
+                     (例如，屬性的定義。)
 
-                     This is a more restrictive mode of MSBuild as it requires
-                     that the project graph be statically discoverable at
-                     evaluation time, but can improve scheduling and reduce
-                     memory overhead when building a large set of projects.
-                     (Short form: -isolate)
+                     這是 MSBuild 更具限制的模式，
+                     因為它要求專案圖形在評估階段可靜態探索，
+                     但可能會改善排程，並減少建置大量專案時
+                     的記憶體額外負荷。
+                     (簡短形式: -isolate)
 
-                     This flag is experimental and may not work as intended.
+                     此旗標是實驗性，可能無法如預期運作。
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -304,13 +358,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="new">  -warnNotAsError[:code[;code2]]
-                     List of warning codes to treats not treat as errors.
-                     Use a semicolon or a comma to separate
-                     multiple warning codes. Has no effect if the -warnaserror
-                     switch is not set.
+        <target state="translated">  -warnNotAsError[:code[;code2]]
+                     要視為不視為錯誤的警告代碼清單。
+                     使用分號或逗號分隔
+                     多個警告代碼。如果未設定 -warnaserror
+                     切換，則沒有作用。
 
-                     Example:
+                     範例:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -496,12 +550,20 @@
                      n[ormal], d[etailed], and diag[nostic]. (Short form: -v)
                      Example:
                        -verbosity:quiet
+
+                     Note: File loggers' verbosity
+                           is set separately by
+                           -fileloggerparameters.
 </source>
-        <target state="translated">  -verbosity:&lt;層級&gt; 在事件記錄檔中顯示此數量的資訊。
-                     可用的詳細程度層級為: q[uiet]、m[inimal]、
+        <target state="translated">  -verbosity:&lt;level&gt; 在事件記錄中顯示此數量的資訊。
+                    可用的詳細層級為: q[uiet]、m[inimal]、
                      n[ormal]、d[etailed] 和 diag[nostic]。(簡短形式: -v)
-                     範例:
+                    範例:
                        -verbosity:quiet
+
+                     注意: 檔案記錄器的詳細層級
+                           是由 -fileloggerparameters
+                           個別設定。
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -550,40 +612,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parameters to console logger. (Short form: -clp)
-                     The available parameters are:
-                        PerformanceSummary--Show time spent in tasks, targets
-                            and projects.
-                        Summary--Show error and warning summary at the end.
-                        NoSummary--Don't show error and warning summary at the
-                            end.
-                        ErrorsOnly--Show only errors.
-                        WarningsOnly--Show only warnings.
-                        NoItemAndPropertyList--Don't show list of items and
-                            properties at the start of each project build.
-                        ShowCommandLine--Show TaskCommandLineEvent messages
-                        ShowTimestamp--Display the Timestamp as a prefix to any
-                            message.
-                        ShowEventId--Show eventId for started events, finished
-                            events, and messages
-                        ForceNoAlign--Does not align the text to the size of
-                            the console buffer
-                        DisableConsoleColor--Use the default console colors
-                            for all logging messages.
-                        DisableMPLogging-- Disable the multiprocessor
-                            logging style of output when running in
-                            non-multiprocessor mode.
-                        EnableMPLogging--Enable the multiprocessor logging
-                            style even when running in non-multiprocessor
-                            mode. This logging style is on by default.
-                        ForceConsoleColor--Use ANSI console colors even if
-                            console does not support it
-                        PreferConsoleColor--Use ANSI console colors only if
-                            target console does support it
-                     Verbosity--overrides the -verbosity setting for this
-                            logger.
-                     Example:
+        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+                     主控台記錄器的參數。(簡短形式: -clp)
+                     可用的參數為:
+                        PerformanceSummary--顯示工作、目標
+                            及專案所花費的時間。
+                        Summary--結束時顯示錯誤與警告摘要。
+                        NoSummary--結束時不顯示錯誤
+                            與警告摘要。
+                        ErrorsOnly--只顯示錯誤。
+                        WarningsOnly--只顯示警告。
+                        NoItemAndPropertyList--不在每個專案開始建置時，
+                            顯示專案與屬性清單。
+                        ShowCommandLine--顯示 TaskCommandLineEvent 訊息
+                        ShowTimestamp--在所有訊息開頭顯示
+                            時間戳記。
+                        ShowEventId--顯示已開始之事件、已完成之事件
+                            以及訊息的事件識別碼
+                        ForceNoAlign--不將文字調整成主控台
+                            緩衝區的大小
+                        DisableConsoleColor--為所有記錄訊息使用預設的
+                            主控台色彩。
+                        DisableMPLogging-- 在非多處理器模式下執行時，
+                            停用輸出的多處理器
+                            記錄樣式。
+                        EnableMPLogging--在非多處理器模式下執行時，
+                            啟用多處理器記錄樣式。
+                            此記錄樣式預設為啟用。
+                        ForceConsoleColor--即使主控台不支援 ANSI 主控台色彩，
+                            也一律使用該色彩
+                        PreferConsoleColor--僅在目標主控台目標確實支援 ANSI 主控台色彩時
+                            才使用它
+                     Verbosity--覆寫此記錄器的 -verbosity
+                             設定。
+                     範例:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
@@ -684,10 +746,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Semicolon separated list of input cache files that MSBuild
-                     will read build results from. If -isolateProjects is set
-                     to False, this sets it to True. (short form: -irc)
+        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild 會從中讀取建置結果的輸入快取檔案
+                     以分號分隔的清單。如果已將 -isolateProjects
+                     設為 False，則這會將它設為 True。(簡短形式: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -701,11 +763,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="new">  -outputResultsCache:[cacheFile]
-                     Output cache file where MSBuild will write the contents of
-                     its build result caches at the end of the build.
-                     If -isolateProjects is set to False, this sets it to True.
-                     (short form: -orc)
+        <target state="translated">  -outputResultsCache:[cacheFile]
+                     MSBuild 將在建置結束時寫入其建置結果快取內容
+                     所在的輸出快取檔案。
+                     如果已將 -isolateProjects 設為 False，則這會將它設為 True。
+                     (簡短形式: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1326,6 +1388,60 @@
         <target state="translated">流程 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} 秒)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 專案檔不存在。</target>
@@ -1371,6 +1487,22 @@
         <target state="translated">'{0}' 來自 '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">還原完成 ({0} 秒)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">在 {1} 秒內還原 {0}</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1434,7 +1566,7 @@
       </trans-unit>
       <trans-unit id="UnsupportedSwitchForSolutionFiles">
         <source>The '{0}' switch is not supported for solution files.</source>
-        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <target state="translated">解決方案檔案不支援 '{0}' 切換。</target>
         <note />
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 0d0fa710bd2..06c53027f78 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -220,6 +220,10 @@ string[] args
             )
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         {
+            // Setup the console UI.
+            using AutomaticEncodingRestorer _ = new();
+            SetConsoleUI();
+
             DebuggerLaunchCheck();
 
             // Initialize new build telemetry and record start of this build.
@@ -663,9 +667,6 @@ public static ExitType Execute(
                 // check the operating system the code is running on
                 VerifyThrowSupportedOS();
 
-                // Setup the console UI.
-                SetConsoleUI();
-
                 // reset the application state for this new build
                 ResetBuildState();
 
@@ -1672,14 +1673,20 @@ internal static void SetConsoleUI()
             Thread thisThread = Thread.CurrentThread;
 
             // Eliminate the complex script cultures from the language selection.
-            thisThread.CurrentUICulture = CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture();
+            var desiredCulture = EncodingUtilities.GetExternalOverriddenUILanguageIfSupportableWithEncoding() ?? CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture();
+            thisThread.CurrentUICulture = desiredCulture;
+
+            // For full framework, both the above and below must be set. This is not true in core, but it is a no op in core.
+            // https://learn.microsoft.com/dotnet/api/system.globalization.cultureinfo.defaultthreadcurrentculture#remarks
+            CultureInfo.CurrentUICulture = desiredCulture;
+            CultureInfo.DefaultThreadCurrentUICulture = desiredCulture;
 
             // Determine if the language can be displayed in the current console codepage, otherwise set to US English
             int codepage;
 
             try
             {
-                codepage = System.Console.OutputEncoding.CodePage;
+                codepage = Console.OutputEncoding.CodePage;
             }
             catch (NotSupportedException)
             {
@@ -1693,7 +1700,8 @@ internal static void SetConsoleUI()
                     &&
                     codepage != thisThread.CurrentUICulture.TextInfo.OEMCodePage
                     &&
-                    codepage != thisThread.CurrentUICulture.TextInfo.ANSICodePage)
+                    codepage != thisThread.CurrentUICulture.TextInfo.ANSICodePage
+                    && !Equals(CultureInfo.InvariantCulture, thisThread.CurrentUICulture))
             {
                 thisThread.CurrentUICulture = new CultureInfo("en-US");
                 return;
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 0628e295bd9..c2e0bb5b8c1 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -70,9 +70,12 @@
     </Compile>
     <Compile Include="..\Shared\Constants.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
-    <Compile Include="..\Shared\ErrorUtilities.cs">
+    <Compile Include="..\Framework\ErrorUtilities.cs">
       <Link>ErrorUtilities.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\ErrorUtilities.cs">
+      <Link>SharedErrorUtilities.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\EscapingUtilities.cs">
       <Link>EscapingUtilities.cs</Link>
     </Compile>
@@ -97,10 +100,10 @@
     <Compile Include="..\Shared\INodePacketHandler.cs">
       <Link>INodePacketHandler.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ITranslatable.cs">
+    <Compile Include="..\Framework\ITranslatable.cs">
       <Link>ITranslatable.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ITranslator.cs">
+    <Compile Include="..\Framework\ITranslator.cs">
       <Link>ITranslator.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
@@ -110,6 +113,15 @@
     <Compile Include="..\Shared\InterningBinaryReader.cs">
       <Link>InterningBinaryReader.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BinaryReaderFactory.cs">
+      <Link>BinaryReaderFactory.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\BinaryReaderExtensions.cs">
+      <Link>BinaryReaderExtensions.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\BinaryWriterExtensions.cs">
+      <Link>BinaryWriterExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\LogMessagePacketBase.cs">
       <Link>LogMessagePacketBase.cs</Link>
     </Compile>
@@ -132,9 +144,21 @@
     <Compile Include="..\Shared\NodePacketFactory.cs">
       <Link>NodePacketFactory.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\BinaryTranslator.cs">
+    <Compile Include="..\Framework\BinaryTranslator.cs">
       <Link>BinaryTranslator.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionBase.cs">
+      <Link>BuildExceptionBase.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionRemoteState.cs">
+      <Link>BuildExceptionRemoteState.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionSerializationHelper.cs">
+      <Link>BuildExceptionSerializationHelper.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\GenericBuildTransferredException.cs">
+      <Link>GenericBuildTransferredException.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
     </Compile>
@@ -167,6 +191,9 @@
     </Compile>
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyResources.cs" />
+    <Compile Include="..\Framework\ChangeWaves.cs">
+      <Link>ChangeWaves.cs</Link>
+    </Compile>
     <Compile Include="Concurrent\ConcurrentDictionary.cs" />
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
     <Compile Include="Immutable\ImmutableDictionary.cs" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index c1c33c9aee8..3780b51c588 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -36,7 +36,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
-  file source=$(TaskHostBinPath)MSBuildTaskHost.exe vs.file.ngenArchitecture=x86 vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuildTaskHost.exe" 
+  file source=$(TaskHostBinPath)MSBuildTaskHost.exe 
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -174,7 +174,7 @@ folder InstallDir:\MSBuild\Current\Bin\zh-Hant
 
 folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X64BinPath)MSBuild.exe vs.file.ngenArchitecture=x64
-  file source=$(TaskHostX64BinPath)MSBuildTaskHost.exe vs.file.ngenArchitecture=x64 vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuildTaskHost.exe" 
+  file source=$(TaskHostX64BinPath)MSBuildTaskHost.exe
   file source=$(X64BinPath)MSBuild.exe.config
   file source=$(TaskHostX64BinPath)MSBuildTaskHost.exe.config
 
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index cb3857ff100..316a1180878 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -10,13 +10,25 @@ namespace Microsoft.Build.Shared
 {
     internal static class BinaryReaderExtensions
     {
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static string? ReadOptionalString(this BinaryReader reader)
         {
             return reader.ReadByte() == 0 ? null : reader.ReadString();
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
+        public static int ReadOptionalInt32(this BinaryReader reader)
+        {
+            return reader.ReadByte() == 0 ? 0 : reader.ReadInt32();
+        }
+
+#if !TASKHOST
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static int Read7BitEncodedInt(this BinaryReader reader)
         {
             // Read out an Int32 7 bits at a time.  The high bit
@@ -41,7 +53,9 @@ public static int Read7BitEncodedInt(this BinaryReader reader)
             return count;
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static DateTime ReadTimestamp(this BinaryReader reader)
         {
             long timestampTicks = reader.ReadInt64();
@@ -50,6 +64,7 @@ public static DateTime ReadTimestamp(this BinaryReader reader)
             return timestamp;
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static BuildEventContext? ReadOptionalBuildEventContext(this BinaryReader reader)
         {
@@ -75,8 +90,11 @@ public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
             var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
             return buildEventContext;
         }
+#endif
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static unsafe Guid ReadGuid(this BinaryReader reader)
         {
             return new Guid(reader.ReadBytes(sizeof(Guid)));
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index 2a221d573a5..211e91f3edc 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -10,7 +10,9 @@ namespace Microsoft.Build.Shared
 {
     internal static class BinaryWriterExtensions
     {
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteOptionalString(this BinaryWriter writer, string? value)
         {
             if (value == null)
@@ -24,14 +26,34 @@ public static void WriteOptionalString(this BinaryWriter writer, string? value)
             }
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
+        public static void WriteOptionalInt32(this BinaryWriter writer, int? value)
+        {
+            if (value == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.Write(value.Value);
+            }
+        }
+
+#if !TASKHOST
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteTimestamp(this BinaryWriter writer, DateTime timestamp)
         {
             writer.Write(timestamp.Ticks);
             writer.Write((Int32)timestamp.Kind);
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
         {
             // Write out an int 7 bits at a time.  The high bit of the byte,
@@ -46,6 +68,7 @@ public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
             writer.Write((byte)v);
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext? context)
         {
@@ -71,8 +94,11 @@ public static void WriteBuildEventContext(this BinaryWriter writer, BuildEventCo
             writer.Write(context.ProjectInstanceId);
             writer.Write(context.EvaluationId);
         }
+#endif
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteGuid(this BinaryWriter writer, Guid value)
         {
             Guid val = value;
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 76d42a328f6..0e596c6cf56 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -188,6 +188,10 @@ internal static class ItemMetadataNames
         internal const string subType = "SubType";
         internal const string executableExtension = "ExecutableExtension";
         internal const string embedInteropTypes = "EmbedInteropTypes";
+        internal const string frameworkReferenceName = "FrameworkReferenceName";
+        internal const string assemblyName = "AssemblyName";
+        internal const string assemblyVersion = "AssemblyVersion";
+        internal const string publicKeyToken = "PublicKeyToken";
 
         /// <summary>
         /// The output path for a given item.
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 36613d4cd52..e50a6b860d3 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -92,7 +92,7 @@ public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, IReadOnl
                 path,
                 pattern,
                 projectDirectory,
-                stripProjectDirectory).ToArray(),
+                stripProjectDirectory),
             fileEntryExpansionCache)
         {
         }
@@ -135,8 +135,8 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE
                         ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
                         : allEntriesForPath;
                     return stripProjectDirectory
-                        ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
-                        : filteredEntriesForPath.ToArray();
+                        ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToList()
+                        : filteredEntriesForPath.ToList();
                 };
         }
 
@@ -252,7 +252,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                         ? fileSystem.EnumerateFileSystemEntries(path, pattern)
                             .Where(o => IsFileNameMatch(o, pattern))
                         : fileSystem.EnumerateFileSystemEntries(path, pattern))
-                        .ToArray();
+                        .ToList();
                 }
                 // for OS security
                 catch (UnauthorizedAccessException)
@@ -349,7 +349,7 @@ private static IReadOnlyList<string> GetAccessibleFiles(
                     files = RemoveInitialDotSlash(files);
                 }
 
-                return files.ToArray();
+                return files.ToList();
             }
             catch (System.Security.SecurityException)
             {
@@ -405,7 +405,7 @@ private static IReadOnlyList<string> GetAccessibleDirectories(
                     directories = RemoveInitialDotSlash(directories);
                 }
 
-                return directories.ToArray();
+                return directories.ToList();
             }
             catch (System.Security.SecurityException)
             {
@@ -501,7 +501,7 @@ internal static string GetLongPathName(
                     }
                     else
                     {
-                        // getFileSystemEntries(...) returns an empty enumerable if longPath doesn't exist.
+                        // getFileSystemEntries(...) returns an empty list if longPath doesn't exist.
                         IReadOnlyList<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);
 
                         if (0 == entries.Count)
@@ -796,7 +796,7 @@ private struct RecursionState
             /// <summary>
             /// True if a SearchData.DirectoryPattern is specified but we have not descended into a matching directory.
             /// </summary>
-            public bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
+            public readonly bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
         }
 
         /// <summary>
diff --git a/src/Shared/FileSystem/WindowsNative.cs b/src/Shared/FileSystem/WindowsNative.cs
index 63640a185be..8df4a0b2a2c 100644
--- a/src/Shared/FileSystem/WindowsNative.cs
+++ b/src/Shared/FileSystem/WindowsNative.cs
@@ -141,7 +141,7 @@ public EnumerateDirectoryResult(string directory, EnumerateDirectoryStatus statu
             /// <summary>
             /// Indicates if enumeration succeeded.
             /// </summary>
-            public bool Succeeded
+            public readonly bool Succeeded
             {
                 get { return Status == EnumerateDirectoryStatus.Success; }
             }
@@ -153,7 +153,7 @@ public bool Succeeded
             /// <remarks>
             /// This is a good <c>default:</c> case when switching on every possible <see cref="EnumerateDirectoryStatus"/>
             /// </remarks>
-            public NativeWin32Exception ThrowForUnknownError()
+            public readonly NativeWin32Exception ThrowForUnknownError()
             {
                 Debug.Assert(Status == EnumerateDirectoryStatus.UnknownError);
                 throw CreateExceptionForError();
@@ -173,7 +173,7 @@ public NativeWin32Exception ThrowForKnownError()
             /// <summary>
             /// Creates (but does not throw) an exception for this result. The result must not be successful.
             /// </summary>
-            public NativeWin32Exception CreateExceptionForError()
+            public readonly NativeWin32Exception CreateExceptionForError()
             {
                 Debug.Assert(Status != EnumerateDirectoryStatus.Success);
                 if (Status == EnumerateDirectoryStatus.UnknownError)
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 1fc332a0639..8513d60cee5 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -191,11 +191,19 @@ public override String ReadString()
         /// <remarks>
         /// The caller is responsible for managing the lifetime of the returned buffer and for passing it to <see cref="Create"/>.
         /// </remarks>
-        internal static SharedReadBuffer CreateSharedBuffer()
+        internal static BinaryReaderFactory CreateSharedBuffer()
         {
             return new Buffer();
         }
 
+        /// <summary>
+        /// A placeholder instructing InterningBinaryReader to use pooled buffer (to avoid extra allocations).
+        /// </summary>
+        /// <remarks>
+        /// Lifetime of the pooled buffer is managed by InterningBinaryReader (tied to BinaryReader lifetime wrapping the buffer)
+        /// </remarks> 
+        internal static BinaryReaderFactory PoolingBuffer => NullBuffer.Instance;
+
         /// <summary>
         /// Gets a buffer from the pool or creates a new one.
         /// </summary>
@@ -232,7 +240,7 @@ protected override void Dispose(bool disposing)
         /// Create a BinaryReader. It will either be an interning reader or standard binary reader
         /// depending on whether the interning reader is possible given the buffer and stream.
         /// </summary>
-        internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer)
+        private static BinaryReader Create(Stream stream, BinaryReaderFactory sharedBuffer)
         {
             Buffer buffer = (Buffer)sharedBuffer;
             if (buffer != null)
@@ -245,7 +253,7 @@ internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer
         /// <summary>
         /// Holds thepreallocated buffer. 
         /// </summary>
-        private class Buffer : SharedReadBuffer
+        private class Buffer : BinaryReaderFactory
         {
             private char[] _charBuffer;
             private byte[] _byteBuffer;
@@ -280,13 +288,24 @@ internal byte[] ByteBuffer
                     return _byteBuffer;
                 }
             }
+
+            public override BinaryReader Create(Stream stream)
+            {
+                return InterningBinaryReader.Create(stream, this);
+            }
         }
-    }
 
-    /// <summary>
-    /// Opaque holder of shared buffer.
-    /// </summary>
-    internal abstract class SharedReadBuffer
-    {
+        private class NullBuffer : BinaryReaderFactory
+        {
+            private NullBuffer()
+            { }
+
+            public static readonly BinaryReaderFactory Instance = new NullBuffer();
+
+            public override BinaryReader Create(Stream stream)
+            {
+                return InterningBinaryReader.Create(stream, null);
+            }
+        }
     }
 }
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index ac7f5509236..f9abb54236e 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -101,7 +101,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// <summary>
         /// Per-node shared read buffer.
         /// </summary>
-        private SharedReadBuffer _sharedReadBuffer;
+        private BinaryReaderFactory _sharedReadBuffer;
 
         /// <summary>
         /// A way to cache a byte array when writing out packets
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
index 85e688acb50..ef5073b4835 100644
--- a/src/Shared/Pair.cs
+++ b/src/Shared/Pair.cs
@@ -44,7 +44,7 @@ public Pair(TKey key, TValue value)
         /// <summary>
         /// Key
         /// </summary>
-        internal TKey Key
+        internal readonly TKey Key
         {
             get { return _key; }
         }
@@ -52,7 +52,7 @@ internal TKey Key
         /// <summary>
         /// Value
         /// </summary>
-        internal TValue Value
+        internal readonly TValue Value
         {
             get { return _value; }
         }
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 575278045ee..e7cbc0f16c6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Hodnota {0} atributu {1} v elementu &lt;{2}&gt; v souboru {3} je zástupný znak, jehož výsledkem je výčet všech souborů na jednotce, což pravděpodobně nebylo zamýšleno. Zkontrolujte, jestli jsou odkazované vlastnosti vždy definovány.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 3b3a861a769..d70a172eaad 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Der Wert "{0}" des Attributs "{1}" in Element &lt;{2}&gt; in der Datei "{3}" ist ein Platzhalter, der dazu führt, dass alle Dateien auf dem Laufwerk aufgelistet werden, was wahrscheinlich nicht beabsichtigt war. Überprüfen Sie, ob Eigenschaften, auf die verwiesen wird, immer definiert sind.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 9193d9bf3b8..d419bac3b60 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: El valor “{0}” del atributo “{1}” en el elemento &lt;{2}&gt; en el archivo "{3}" es un carácter comodín que da como resultado la enumeración de todos los archivos de la unidad, lo que probablemente no estaba previsto. Compruebe que siempre se definan las propiedades a las que se hace referencia.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 7ba650edd28..7ae2294313e 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: La valeur «{0}» de l’attribut «{1}» dans l’élément &lt;{2}&gt; dans le fichier «{3}» est un caractère générique qui entraîne l’énumération de tous les fichiers sur le lecteur, ce qui n’était probablement pas prévu. Vérifiez que les propriétés référencées sont toujours définies.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 5d0abb3e4e0..2e870832100 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: il valore "{0}" dell'attributo "{1}" nell'elemento &lt;{2}&gt; nel file "{3}" è un carattere jolly che determina l'enumerazione di tutti i file nell'unità, che probabilmente non era previsto. Verificare che le proprietà di riferimento siano sempre definite.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 2bfc6c3463f..7c8bbc70a2b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: ファイル "{3}" 内の要素 &lt;{2}&gt; の "{1}" 属性の値 "{0}" はワイルドカードであり、ドライブ上のすべてのファイルが列挙されます。それは意図されてはいないと思われます。参照されるプロパティが常に定義されていることを確認してください。</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 503baf9f4b0..dfbab37ab95 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: 파일 "{3}"에 있는 요소 &lt;{2}&gt; 요소의 "{1}" 특성의 값 "{0}"은(는) 의도하지 않은 드라이브의 모든 파일을 열거하는 와일드카드입니다. 참조된 속성이 항상 정의되어 있는지 확인하세요.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index c026f00091e..7ac1dc23e0a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: Wartość „{0}” atrybutu „{1}” w elemencie &lt;{2}&gt; w pliku „{3}” jest symbolem wieloznacznym, który powoduje wyliczenie wszystkich plików na dysku, co prawdopodobnie nie było zamierzone. Sprawdź, aby przywoływane właściwości były zawsze zdefiniowane.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 848ba95c3da..b10d4fe1344 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: O valor "{0}" do atributo "{1}" no elemento &lt;{2}&gt; no arquivo "{3}" é um curinga que resulta na enumeração de todos os arquivos na unidade, o que provavelmente não foi planejado. Verifique se as propriedades referenciadas estão sempre definidas.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index c23b63e3b4b..5e249678bda 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: значение "{0}" атрибута "{1}" в элементе &lt;{2}&gt; в файле "{3}" является подстановочным знаком, который приводит к перечислению всех файлов на диске, что, вероятно, не предполагалось. Убедитесь, что ссылочные свойства всегда определены.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 09e4f9aeae1..a00104c3111 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: "{3}" dosyasındaki &lt;{2}&gt; öğesinde "{1}" özniteliğinin "{0}" değeri, sürücüdeki tüm dosyaların numaralandırılmasıyla sonuçlanan (büyük olasılıkla bunun olması amaçlanmıyordu) bir joker karakterdir. Başvurulan özelliklerin her zaman tanımlı olduğundan emin olun.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index e8a04e0bba0..855947f34fe 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: 文件 "{3}" 中元素 &lt;{2}&gt; 中 "{1}" 属性的值 "{0}" 是通配符，可导致枚举驱动器上的所有文件，这可能不是预期的行为。请检查是否始终定义了所引用的属性。</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index a63f80f76e2..dd4e123d08e 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -310,7 +310,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
-        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <target state="translated">MSB5029: 檔案「{3}」元素 &lt;{2}&gt; 中屬性「{1}」的值「{0}」是萬用字元，導致列舉磁碟機上的所有檔案，這很可能不是預期的結果。檢查是否一直定義參考屬性。</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/Shared/SolutionConfiguration.cs b/src/Shared/SolutionConfiguration.cs
index 99c5b0a33fc..a271f2645f4 100644
--- a/src/Shared/SolutionConfiguration.cs
+++ b/src/Shared/SolutionConfiguration.cs
@@ -17,6 +17,8 @@ internal sealed class SolutionConfiguration
 
         public const string BuildProjectInSolutionAttribute = "BuildProjectInSolution";
 
+        public static readonly char[] ConfigPlatformSeparator = { '|' };
+
         // This field stores pre-cached project elements for project guids for quicker access by project guid
         private readonly Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
 
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index e3a4a2b9f7d..4e0c4548bd7 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -503,6 +503,23 @@ public void LogMessageFromResources(MessageImportance importance, string message
 #endif
         }
 
+        /// <summary>
+        /// Flatten the inner exception message
+        /// </summary>
+        /// <param name="e">Exception to flatten.</param>
+        /// <returns></returns>
+        public static string GetInnerExceptionMessageString(Exception e)
+        {
+            StringBuilder flattenedMessage = new StringBuilder(e.Message);
+            Exception excep = e;
+            while (excep.InnerException != null)
+            {
+                excep = excep.InnerException;
+                flattenedMessage.Append(" ---> ").Append(excep.Message);
+            }
+            return flattenedMessage.ToString();
+        }
+
         #endregion
 
         #region ExternalProjectStarted/Finished logging methods
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 12ef8396ae8..8aa828b533c 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -758,7 +758,7 @@ public void VerifyAssemblyNameExSerializationByTranslator(string assemblyName)
             writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
 
             serializationStream.Seek(0, SeekOrigin.Begin);
-            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
 
             readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
 
@@ -782,7 +782,7 @@ public void VerifyAssemblyNameExSerializationWithRemappedFromByTranslator()
             writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
 
             serializationStream.Seek(0, SeekOrigin.Begin);
-            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
 
             readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
 
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 9a9bec6d5c9..c52765ccd49 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -282,8 +282,13 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                             bool logMessage = !(eventArgs is BuildFinishedEventArgs) || LogBuildFinished;
                             if (logMessage)
                             {
-                                _fullLog.AppendLine(eventArgs.Message);
-                                _testOutputHelper?.WriteLine(eventArgs.Message);
+                                string msg = eventArgs.Message;
+                                if (eventArgs is BuildMessageEventArgs m && m.LineNumber != 0)
+                                {
+                                    msg = $"{m.File}({m.LineNumber},{m.ColumnNumber}): {msg}";
+                                }
+                                _fullLog.AppendLine(msg);
+                                _testOutputHelper?.WriteLine(msg);
                             }
                             break;
                         }
@@ -496,9 +501,9 @@ internal void AssertLogDoesntContain(string contains)
         /// </summary>
         internal void AssertNoWarnings() => Assert.Equal(0, WarningCount);
 
-        internal void AssertMessageCount(string message, int expectedCount)
+        internal void AssertMessageCount(string message, int expectedCount, bool regexSearch = true)
         {
-            var matches = Regex.Matches(FullLog, message);
+            var matches = Regex.Matches(FullLog, regexSearch ? message : Regex.Escape(message));
             matches.Count.ShouldBe(expectedCount);
         }
     }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 31ce5b63c29..659aea6dab9 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -499,7 +499,7 @@ internal static void AssertArrayContentsMatch(object[] expected, object[] actual
         }
 
         /// <summary>
-        /// Parses the crazy string passed into AssertItemsMatch and returns a list of ITaskItems.
+        /// Parses the string passed into AssertItemsMatch and returns a list of ITaskItems.
         /// </summary>
         /// <param name="expectedItemsString"></param>
         /// <returns></returns>
@@ -1155,6 +1155,11 @@ internal static string GetOSPlatformAsString()
         /// </summary>
         internal static int Count(IEnumerable enumerable)
         {
+            if (enumerable is ICollection c)
+            {
+                return c.Count;
+            }
+
             int i = 0;
             foreach (object _ in enumerable)
             {
@@ -1341,7 +1346,7 @@ internal static MockLogger BuildProjectWithNewOMExpectSuccess(string content, Di
         /// </summary>
         private static void BuildProjectWithNewOM(string content, ref MockLogger logger, out bool result, bool allowTaskCrash, Dictionary<string, string> globalProperties = null)
         {
-            // Replace the crazy quotes with real ones
+            // Replace the nonstandard quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             Project project = new Project(XmlReader.Create(new StringReader(content)), globalProperties, toolsVersion: null);
@@ -1367,7 +1372,7 @@ public static MockLogger BuildProjectContentUsingBuildManagerExpectResult(string
 
         public static BuildResult BuildProjectContentUsingBuildManager(string content, MockLogger logger, BuildParameters parameters = null)
         {
-            // Replace the crazy quotes with real ones
+            // Replace the nonstandard quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
 
             using (var env = TestEnvironment.Create())
@@ -1421,7 +1426,7 @@ internal enum ExpectedBuildResult
         }
 
         /// <summary>
-        /// Verify that a drive enumerating wildcard warning is logged or exception is thrown. 
+        /// Verify that a drive enumerating wildcard warning is logged or exception is thrown.
         /// </summary>
         internal static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(string content, string failOnDriveEnumerationEnvVar, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
         {
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 5d7d3d22d65..ad715d6c44b 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -9,6 +9,7 @@
 using System.IO.Compression;
 using System.Linq;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
@@ -95,6 +96,7 @@ private void Cleanup()
                 }
 
                 SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "");
+                ChangeWaves.ResetStateForTests();
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
             }
         }
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index e37749e172c..27e32d603cb 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -32,9 +32,8 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 return oldElement;
             }
 
-            XmlElementWithLocation newElement = (xmlNamespace == null)
-                ? (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName)
-                : (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName, xmlNamespace);
+            XmlElementWithLocation newElement =
+                (XmlElementWithLocation)((XmlDocumentWithLocation)oldElement.OwnerDocument).CreateElement(newElementName, xmlNamespace ?? string.Empty, oldElement.Location);
 
             // Copy over all the attributes.
             foreach (XmlAttribute oldAttribute in oldElement.Attributes)
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 57789ab0700..4328bbc084e 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -57,7 +57,7 @@ public Enumerator(InternableString spanBuilder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
+            public readonly char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
 
             /// <summary>
             /// Moves to the next character.
@@ -88,7 +88,7 @@ public bool MoveNext()
         /// <summary>
         /// A convenience getter to ensure that we always operate on a non-null string.
         /// </summary>
-        private string FirstString => _firstString ?? string.Empty;
+        private readonly string FirstString => _firstString ?? string.Empty;
 
         /// <summary>
         /// Constructs a new InternableString wrapping the given string.
@@ -116,13 +116,13 @@ internal InternableString(SpanBasedStringBuilder builder)
         /// <summary>
         /// Gets the length of the string.
         /// </summary>
-        public int Length => (_builder == null ? FirstString.Length : _builder.Length);
+        public readonly int Length => (_builder == null ? FirstString.Length : _builder.Length);
 
         /// <summary>
         /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
         /// </summary>
         /// <returns>The enumerator.</returns>
-        public Enumerator GetEnumerator()
+        public readonly Enumerator GetEnumerator()
         {
             return new Enumerator(this);
         }
@@ -132,7 +132,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -163,7 +163,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public string ExpensiveConvertToString()
+        public readonly string ExpensiveConvertToString()
         {
             // Special case: if we hold just one string, we can directly return it.
             if (_firstString != null)
@@ -178,9 +178,9 @@ public string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
-            return Object.ReferenceEquals(str, _firstString);
+            return ReferenceEquals(str, _firstString);
         }
 
         /// <summary>
@@ -198,7 +198,7 @@ public override unsafe string ToString()
         /// Implements the simple yet very decently performing djb2 hash function (xor version).
         /// </summary>
         /// <returns>A stable hashcode of the string represented by this instance.</returns>
-        public override int GetHashCode()
+        public override readonly int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool isOddIndex = false;
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 413aad9fb88..7e657d56cdb 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -43,7 +43,7 @@ internal Enumerator(scoped ref InternableString str)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public ref readonly char Current
+            public readonly ref readonly char Current
             {
                 get
                 {
@@ -178,7 +178,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -210,7 +210,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public unsafe string ExpensiveConvertToString()
+        public readonly unsafe string ExpensiveConvertToString()
         {
             if (Length == 0)
             {
@@ -268,7 +268,7 @@ public unsafe string ExpensiveConvertToString()
 
                 // The invariant that Length is the sum of span lengths is critical in this unsafe method.
                 // Violating it may lead to memory corruption and, since this code tends to run under a lock,
-                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now, 
+                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now,
                 // before the corruption causes further problems.
                 if (destPtr != resultPtr + Length)
                 {
@@ -283,7 +283,7 @@ public unsafe string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
             if (_inlineSpan.Length == Length)
             {
@@ -317,7 +317,7 @@ public override string ToString()
         /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for
         /// a given string regardless of how it's split into spans (e.g. { "AB" } and { "A", "B" } have the same hash code).
         /// </remarks>
-        public override unsafe int GetHashCode()
+        public override readonly unsafe int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool hashedOddNumberOfCharacters = false;
diff --git a/src/StringTools/SpanBasedStringBuilder.Simple.cs b/src/StringTools/SpanBasedStringBuilder.Simple.cs
index 6090363a24f..a9c88b590c9 100644
--- a/src/StringTools/SpanBasedStringBuilder.Simple.cs
+++ b/src/StringTools/SpanBasedStringBuilder.Simple.cs
@@ -35,7 +35,7 @@ public Enumerator(StringBuilder builder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => _builder[_charIndex];
+            public readonly char Current => _builder[_charIndex];
 
             /// <summary>
             /// Moves to the next character.
diff --git a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
index 74fa0155f91..49a843cbd54 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
@@ -187,15 +187,15 @@ public void BadAppconfigNewVersion()
         /// - An app.config was passed in that promotes UnifyMe version from 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        /// -Version 2.0.0.0 of UnifyMe is in the Black List
+        /// -Version 2.0.0.0 of UnifyMe is in the Deny List
         /// Expected:
         /// - There should be a warning indicating that DependsOnUnified has a dependency UnifyMe 2.0.0.0 which is not in a TargetFrameworkSubset.
         /// - There will be no unified message.
         /// Rationale:
-        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the black list it should be removed and warned.
+        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the deny list it should be removed and warned.
         /// </summary>
         [Fact]
-        public void ExistsPromotedDependencyInTheBlackList()
+        public void ExistsPromotedDependencyInTheDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index d8a3e63f4e9..9caae9580dd 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -11,13 +12,14 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests.Shared;
+using Microsoft.Build.Tasks.AssemblyDependency;
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
 using Xunit.NetCore.Extensions;
+using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 
 #nullable disable
@@ -71,7 +73,7 @@ public sealed class Miscellaneous : ResolveAssemblyReferenceTestFixture
             "</FileList >";
 
         /// <summary>
-        /// The contents of a subsetFile which only contain the Microsoft.Build.Engine assembly in the white list
+        /// The contents of a subsetFile which only contain the Microsoft.Build.Engine assembly in the allow list
         /// </summary>
         private string _engineOnlySubset =
             "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -79,7 +81,7 @@ public sealed class Miscellaneous : ResolveAssemblyReferenceTestFixture
             "</FileList >";
 
         /// <summary>
-        /// The contents of a subsetFile which only contain the System.Xml assembly in the white list
+        /// The contents of a subsetFile which only contain the System.Xml assembly in the allow list
         /// </summary>
         private string _xmlOnlySubset =
             "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -87,7 +89,7 @@ public sealed class Miscellaneous : ResolveAssemblyReferenceTestFixture
             "</FileList >";
 
         /// <summary>
-        /// The contents of a subsetFile which contain both the Microsoft.Build.Engine and System.Xml assemblies in the white list
+        /// The contents of a subsetFile which contain both the Microsoft.Build.Engine and System.Xml assemblies in the allow list
         /// </summary>
         private string _engineAndXmlSubset =
             "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -5564,39 +5566,39 @@ public void GetRedistListPathsFromDisk_ThrowsArgumentNullException()
         }
 
         /// <summary>
-        /// Test the case where the redist list is empty and we pass in an empty set of white lists
-        /// We should return null as there is no point generating a white list if there is nothing to subtract from.
-        /// ResolveAssemblyReference will see this as null and log a warning indicating no redist assemblies were found therefore no black list could be
+        /// Test the case where the redist list is empty and we pass in an empty set of allow lists
+        /// We should return null as there is no point generating an allow list if there is nothing to subtract from.
+        /// ResolveAssemblyReference will see this as null and log a warning indicating no redist assemblies were found therefore no deny list could be
         /// generated
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListEmptyAssemblyInfoNoRedistAssemblies()
+        public void RedistListGenerateDenyListEmptyAssemblyInfoNoRedistAssemblies()
         {
             RedistList redistList = RedistList.GetRedistList(Array.Empty<AssemblyTableInfo>());
-            List<Exception> whiteListErrors = new List<Exception>();
-            List<string> whiteListErrorFileNames = new List<string>();
-            Dictionary<string, string> blackList = redistList.GenerateBlackList(Array.Empty<AssemblyTableInfo>(), whiteListErrors, whiteListErrorFileNames);
-            Assert.Null(blackList); // "Should return null if the AssemblyTableInfo is empty and the redist list is empty"
+            List<Exception> allowListErrors = new List<Exception>();
+            List<string> allowListErrorFileNames = new List<string>();
+            Dictionary<string, string> denyList = redistList.GenerateDenyList(Array.Empty<AssemblyTableInfo>(), allowListErrors, allowListErrorFileNames);
+            Assert.Null(denyList); // "Should return null if the AssemblyTableInfo is empty and the redist list is empty"
         }
 
         /// <summary>
-        /// Verify that when we go to generate a black list but there were no subset list files passed in that we get NO black list generated as there is nothing to subtract.
+        /// Verify that when we go to generate a deny list but there were no subset list files passed in that we get NO deny list generated as there is nothing to subtract.
         /// Nothing meaning, we don't have any matching subset list files to say there are no good files.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListEmptyAssemblyInfoWithRedistAssemblies()
+        public void RedistListGenerateDenyListEmptyAssemblyInfoWithRedistAssemblies()
         {
             string redistFile = CreateGenericRedistList();
             try
             {
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(Array.Empty<AssemblyTableInfo>(), whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(Array.Empty<AssemblyTableInfo>(), allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
             }
             finally
             {
@@ -5605,32 +5607,32 @@ public void RedistListGenerateBlackListEmptyAssemblyInfoWithRedistAssemblies()
         }
 
         /// <summary>
-        /// Test the case where the subset lists cannot be read. The expectation is that the black list will be empty as we have no proper white lists to compare it to.
+        /// Test the case where the subset lists cannot be read. The expectation is that the deny list will be empty as we have no proper allow lists to compare it to.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListNotFoundSubsetFiles()
+        public void RedistListGenerateDenyListNotFoundSubsetFiles()
         {
             string redistFile = CreateGenericRedistList();
             try
             {
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
 
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(
                                                                    new AssemblyTableInfo[]
                                                                                          {
                                                                                            new AssemblyTableInfo("c:\\RandomDirectory.xml", "TargetFrameworkDirectory"),
                                                                                            new AssemblyTableInfo("c:\\AnotherRandomDirectory.xml", "TargetFrameworkDirectory")
                                                                                           },
-                                                                                          whiteListErrors,
-                                                                                          whiteListErrorFileNames);
+                                                                                          allowListErrors,
+                                                                                          allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Equal(2, whiteListErrors.Count); // "Expected there to be two errors in the whiteListErrors, one for each missing file"
-                Assert.Equal(2, whiteListErrorFileNames.Count); // "Expected there to be two errors in the whiteListErrorFileNames, one for each missing file"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Equal(2, allowListErrors.Count); // "Expected there to be two errors in the allowListErrors, one for each missing file"
+                Assert.Equal(2, allowListErrorFileNames.Count); // "Expected there to be two errors in the allowListErrorFileNames, one for each missing file"
             }
             finally
             {
@@ -5640,10 +5642,10 @@ public void RedistListGenerateBlackListNotFoundSubsetFiles()
 
         /// <summary>
         /// Test the case where there is random goo in the subsetList file. Expect the file to not be read in and a warning indicating the file was skipped due to a read error.
-        /// This should also cause the white list to be empty as the badly formatted file was the only whitelist subset file.
+        /// This should also cause the allow list to be empty as the badly formatted file was the only allowlist subset file.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGarbageSubsetListFiles()
+        public void RedistListGenerateDenyListGarbageSubsetListFiles()
         {
             string redistFile = CreateGenericRedistList();
             string garbageSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5656,14 +5658,14 @@ public void RedistListGenerateBlackListGarbageSubsetListFiles()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(garbageSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Single(whiteListErrors); // "Expected there to be an error in the whiteListErrors"
-                Assert.Single(whiteListErrorFileNames); // "Expected there to be an error in the whiteListErrorFileNames"
-                Assert.DoesNotContain("MSB3257", ((Exception)whiteListErrors[0]).Message); // "Expect to not have the null redist warning"
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Single(allowListErrors); // "Expected there to be an error in the allowListErrors"
+                Assert.Single(allowListErrorFileNames); // "Expected there to be an error in the allowListErrorFileNames"
+                Assert.DoesNotContain("MSB3257", ((Exception)allowListErrors[0]).Message); // "Expect to not have the null redist warning"
             }
             finally
             {
@@ -5679,7 +5681,7 @@ public void RedistListGenerateBlackListGarbageSubsetListFiles()
         ///
         /// Expected:
         ///     Expect a warning that a redist list or subset list has no redist name.
-        ///     There should be no black list generated as no sub set lists were read in.
+        ///     There should be no deny list generated as no sub set lists were read in.
         ///
         /// Rational:
         ///     If we have no redist name to compare to the redist list redist name we cannot subtract the lists correctly.
@@ -5701,16 +5703,16 @@ public void RedistListNoSubsetListName()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
-
-                // If the names do not match then i expect there to be no black list items
-                Assert.Empty(blackList); // "Expected to have no assembly in the black list"
-                Assert.Single(whiteListErrors); // "Expected there to be one error in the whiteListErrors"
-                Assert.Single(whiteListErrorFileNames); // "Expected there to be one error in the whiteListErrorFileNames"
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
+
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Empty(denyList); // "Expected to have no assembly in the deny list"
+                Assert.Single(allowListErrors); // "Expected there to be one error in the allowListErrors"
+                Assert.Single(allowListErrorFileNames); // "Expected there to be one error in the allowListErrorFileNames"
                 string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.NoSubSetRedistListName", subsetFile);
-                Assert.Contains(message, ((Exception)whiteListErrors[0]).Message); // "Expected assertion to contain correct error code"
+                Assert.Contains(message, ((Exception)allowListErrors[0]).Message); // "Expected assertion to contain correct error code"
             }
             finally
             {
@@ -5725,7 +5727,7 @@ public void RedistListNoSubsetListName()
         ///     Subset list which has a redist name and entries
         ///
         /// Expected:
-        ///     Expect no black list to be generated and no warnings to be emitted
+        ///     Expect no deny list to be generated and no warnings to be emitted
         ///
         /// Rational:
         ///     Since the redist list name is null or empty we have no way of matching any subset list up to it.
@@ -5754,14 +5756,14 @@ public void RedistListNullkRedistListName()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // If the names do not match then i expect there to be no black list items
-                Assert.Empty(blackList); // "Expected to have no assembly in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no errors in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no errors in the whiteListErrorFileNames"
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Empty(denyList); // "Expected to have no assembly in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no errors in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no errors in the allowListErrorFileNames"
             }
             finally
             {
@@ -5776,11 +5778,11 @@ public void RedistListNullkRedistListName()
         ///     Subset list which has entries but has a different redist name than the redist list
         ///
         /// Expected:
-        ///     There should be no black list generated as no sub set lists with matching names were found.
+        ///     There should be no deny list generated as no sub set lists with matching names were found.
         ///
         /// Rational:
         ///     If the redist name does not match then that subset list should not be subtracted from the redist list.
-        ///     We only add assemblies to the black list if there is a corosponding white list even if it is empty to inform us what assemblies are good and which are not.
+        ///     We only add assemblies to the deny list if there is a corosponding allow list even if it is empty to inform us what assemblies are good and which are not.
         /// </summary>
         [Fact]
         public void RedistListDifferentNameToSubSet()
@@ -5799,14 +5801,14 @@ public void RedistListDifferentNameToSubSet()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // If the names do not match then i expect there to be no black list items
-                Assert.Empty(blackList); // "Expected to have no assembly in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Empty(denyList); // "Expected to have no assembly in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -5817,7 +5819,7 @@ public void RedistListDifferentNameToSubSet()
 
         /// <summary>
         /// Test the case where the subset list has the same name as the redist list but it has no entries In this case
-        /// the black list should contain ALL redist list entries because there are no white list files to remove from the black list.
+        /// the deny list should contain ALL redist list entries because there are no allow list files to remove from the deny list.
         /// </summary>
         [Fact]
         public void RedistListEmptySubsetMatchingName()
@@ -5834,19 +5836,19 @@ public void RedistListEmptySubsetMatchingName()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(subsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // If the names do not match then i expect there to be no black list items
-                Assert.Equal(2, blackList.Count); // "Expected to have two assembly in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // If the names do not match then i expect there to be no deny list items
+                Assert.Equal(2, denyList.Count); // "Expected to have two assembly in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
 
-                ArrayList whiteListErrors2 = new ArrayList();
-                ArrayList whiteListErrorFileNames2 = new ArrayList();
-                Dictionary<string, string> blackList2 = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
-                Assert.Same(blackList, blackList2);
+                ArrayList allowListErrors2 = new ArrayList();
+                ArrayList allowListErrorFileNames2 = new ArrayList();
+                Dictionary<string, string> denyList2 = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
+                Assert.Same(denyList, denyList2);
             }
             finally
             {
@@ -5857,8 +5859,8 @@ public void RedistListEmptySubsetMatchingName()
 
         /// <summary>
         /// Test the case where, no redist assemblies are read in.
-        /// In this case no blacklist can be generated.
-        /// We should get a warning informing us that we could not create a black list.
+        /// In this case no denylist can be generated.
+        /// We should get a warning informing us that we could not create a deny list.
         /// </summary>
         [Fact]
         public void RedistListNoAssembliesinRedistList()
@@ -5906,10 +5908,10 @@ public void RedistListNoAssembliesinRedistList()
 
         /// <summary>
         /// Test the case where the subset list is a subset of the redist list. Make sure that
-        /// even though there are two files in the redist list that only one shows up in the black list.
+        /// even though there are two files in the redist list that only one shows up in the deny list.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
+        public void RedistListGenerateDenyListGoodListsSubsetIsSubsetOfRedist()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5920,14 +5922,14 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                Assert.Single(blackList); // "Expected to have one assembly in the black list"
-                Assert.True(blackList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                Assert.Single(denyList); // "Expected to have one assembly in the deny list"
+                Assert.True(denyList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -5937,12 +5939,12 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         }
 
         /// <summary>
-        /// Test the case where we generate a black list based on a set of subset file paths, and then ask for
-        /// another black list using the same file paths. We expect to get the exact same Dictionary out
+        /// Test the case where we generate a deny list based on a set of subset file paths, and then ask for
+        /// another deny list using the same file paths. We expect to get the exact same Dictionary out
         /// as it should be pulled from the cache.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListVerifyBlackListCache()
+        public void RedistListGenerateDenyListVerifyDenyListCache()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5953,20 +5955,20 @@ public void RedistListGenerateBlackListVerifyBlackListCache()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Single(blackList); // "Expected to have one assembly in the black list"
-                Assert.True(blackList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Single(denyList); // "Expected to have one assembly in the deny list"
+                Assert.True(denyList.ContainsKey("System.Xml, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")); // "Expected System.xml to be in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
 
-                List<Exception> whiteListErrors2 = new List<Exception>();
-                List<string> whiteListErrorFileNames2 = new List<string>();
-                Dictionary<string, string> blackList2 = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors2, whiteListErrorFileNames2);
-                Assert.Same(blackList, blackList2);
+                List<Exception> allowListErrors2 = new List<Exception>();
+                List<string> allowListErrorFileNames2 = new List<string>();
+                Dictionary<string, string> denyList2 = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors2, allowListErrorFileNames2);
+                Assert.Same(denyList, denyList2);
             }
             finally
             {
@@ -5976,14 +5978,14 @@ public void RedistListGenerateBlackListVerifyBlackListCache()
         }
 
         /// <summary>
-        /// Test the case where the white list and the redist list are identical
-        /// In this case the black list should be empty.
+        /// Test the case where the allow list and the redist list are identical
+        /// In this case the deny list should be empty.
         ///
         /// We are also in a way testing the combining of subset files as we read in one assembly from two
         /// different subset lists while the redist list already contains both assemblies.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
+        public void RedistListGenerateDenyListGoodListsSubsetIsSameAsRedistList()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -5998,13 +6000,13 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
                 AssemblyTableInfo subsetListInfo2 = new AssemblyTableInfo(goodSubsetFile2, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
 
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo, subsetListInfo2 }, whiteListErrors, whiteListErrorFileNames);
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo, subsetListInfo2 }, allowListErrors, allowListErrorFileNames);
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6014,13 +6016,13 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
         }
 
         /// <summary>
-        /// Test the case where the white list is a superset of the redist list.
-        /// This means there are more assemblies in the white list than in the black list.
+        /// Test the case where the allow list is a superset of the redist list.
+        /// This means there are more assemblies in the allow list than in the deny list.
         ///
-        /// The black list should be empty.
+        /// The deny list should be empty.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
+        public void RedistListGenerateDenyListGoodListsSubsetIsSuperSet()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -6037,14 +6039,14 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6058,7 +6060,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
         /// list are case sensitive or not, they should not be case sensitive.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
+        public void RedistListGenerateDenyListGoodListsCheckCaseInsensitive()
         {
             string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -6069,14 +6071,14 @@ public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFileNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFileNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFileNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFileNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFileNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFileNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6086,11 +6088,11 @@ public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
         }
 
         /// <summary>
-        /// Verify that when we go to generate a black list but there were no subset list files passed in that we get NO black list generated as there is nothing to subtract.
+        /// Verify that when we go to generate a deny list but there were no subset list files passed in that we get NO deny list generated as there is nothing to subtract.
         /// Nothing meaning, we don't have any matching subset list files to say there are no good files.
         /// </summary>
         [Fact]
-        public void RedistListGenerateBlackListGoodListsMultipleIdenticalAssembliesInRedistList()
+        public void RedistListGenerateDenyListGoodListsMultipleIdenticalAssembliesInRedistList()
         {
             string redistFile = FileUtilities.GetTemporaryFileName();
             string goodSubsetFile = FileUtilities.GetTemporaryFileName();
@@ -6110,14 +6112,14 @@ public void RedistListGenerateBlackListGoodListsMultipleIdenticalAssembliesInRed
                 AssemblyTableInfo redistListInfo = new AssemblyTableInfo(redistFile, "TargetFrameworkDirectory");
                 AssemblyTableInfo subsetListInfo = new AssemblyTableInfo(goodSubsetFile, "TargetFrameworkDirectory");
                 RedistList redistList = RedistList.GetRedistList(new AssemblyTableInfo[] { redistListInfo });
-                List<Exception> whiteListErrors = new List<Exception>();
-                List<string> whiteListErrorFilesNames = new List<string>();
-                Dictionary<string, string> blackList = redistList.GenerateBlackList(new AssemblyTableInfo[] { subsetListInfo }, whiteListErrors, whiteListErrorFilesNames);
+                List<Exception> allowListErrors = new List<Exception>();
+                List<string> allowListErrorFilesNames = new List<string>();
+                Dictionary<string, string> denyList = redistList.GenerateDenyList(new AssemblyTableInfo[] { subsetListInfo }, allowListErrors, allowListErrorFilesNames);
 
-                // Since there were no white list expect the black list to return null
-                Assert.Empty(blackList); // "Expected to have no assemblies in the black list"
-                Assert.Empty(whiteListErrors); // "Expected there to be no error in the whiteListErrors"
-                Assert.Empty(whiteListErrorFilesNames); // "Expected there to be no error in the whiteListErrorFileNames"
+                // Since there were no allow list expect the deny list to return null
+                Assert.Empty(denyList); // "Expected to have no assemblies in the deny list"
+                Assert.Empty(allowListErrors); // "Expected there to be no error in the allowListErrors"
+                Assert.Empty(allowListErrorFilesNames); // "Expected there to be no error in the allowListErrorFileNames"
             }
             finally
             {
@@ -6312,10 +6314,10 @@ public void IgnoreDefaultInstalledAssemblyTables()
         }
 
         /// <summary>
-        /// A null black list should be the same as an empty one.
+        /// A null deny list should be the same as an empty one.
         /// </summary>
         [Fact]
-        public void ReferenceTableNullBlackList()
+        public void ReferenceTableNullDenyList()
         {
             TaskLoggingHelper log = new TaskLoggingHelper(new ResolveAssemblyReference());
             ReferenceTable referenceTable = MakeEmptyReferenceTable(log);
@@ -6337,10 +6339,10 @@ public void ReferenceTableNullBlackList()
         }
 
         /// <summary>
-        /// Test the case where the blacklist is empty.
+        /// Test the case where the denylist is empty.
         /// </summary>
         [Fact]
-        public void ReferenceTableEmptyBlackList()
+        public void ReferenceTableEmptyDenyList()
         {
             TaskLoggingHelper log = new TaskLoggingHelper(new ResolveAssemblyReference());
             ReferenceTable referenceTable = MakeEmptyReferenceTable(log);
@@ -6362,10 +6364,10 @@ public void ReferenceTableEmptyBlackList()
         }
 
         /// <summary>
-        /// Verify the case where there are primary references in the reference table which are also in the black list
+        /// Verify the case where there are primary references in the reference table which are also in the deny list
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryItemInBlackList()
+        public void ReferenceTablePrimaryItemInDenyList()
         {
             MockEngine mockEngine = new MockEngine(_output);
             ResolveAssemblyReference rar = new ResolveAssemblyReference();
@@ -6383,12 +6385,12 @@ public void ReferenceTablePrimaryItemInBlackList()
             table.Add(engineAssemblyName, reference);
             table.Add(xmlAssemblyName, new Reference(isWinMDFile, fileExists, getRuntimeVersion));
 
-            var blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            blackList[engineAssemblyName.FullName] = null;
+            var denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            denyList[engineAssemblyName.FullName] = null;
             string[] targetFrameworks = new string[] { "Client", "Web" };
             string subSetName = ResolveAssemblyReference.GenerateSubSetName(targetFrameworks, null);
 
-            referenceTable.MarkReferencesForExclusion(blackList);
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(false, subSetName);
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
@@ -6401,10 +6403,10 @@ public void ReferenceTablePrimaryItemInBlackList()
         }
 
         /// <summary>
-        /// Verify the case where there are primary references in the reference table which are also in the black list
+        /// Verify the case where there are primary references in the reference table which are also in the deny list
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryItemInBlackListSpecificVersionTrue()
+        public void ReferenceTablePrimaryItemInDenyListSpecificVersionTrue()
         {
             MockEngine mockEngine = new MockEngine(_output);
             ResolveAssemblyReference rar = new ResolveAssemblyReference();
@@ -6423,11 +6425,11 @@ public void ReferenceTablePrimaryItemInBlackListSpecificVersionTrue()
             table.Add(engineAssemblyName, reference);
             table.Add(xmlAssemblyName, new Reference(isWinMDFile, fileExists, getRuntimeVersion));
 
-            var blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            blackList[engineAssemblyName.FullName] = null;
+            var denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            denyList[engineAssemblyName.FullName] = null;
             string[] targetFrameworks = new string[] { "Client", "Web" };
             string subSetName = ResolveAssemblyReference.GenerateSubSetName(targetFrameworks, null);
-            referenceTable.MarkReferencesForExclusion(blackList);
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(false, subSetName);
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
@@ -6481,7 +6483,7 @@ public void TestGenerateFrameworkName()
         /// Verify the case where we just want to remove the references before conflict resolution and not print out the warning.
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryItemInBlackListRemoveOnlyNoWarn()
+        public void ReferenceTablePrimaryItemInDenyListRemoveOnlyNoWarn()
         {
             MockEngine mockEngine = new MockEngine(_output);
             ResolveAssemblyReference rar = new ResolveAssemblyReference();
@@ -6499,9 +6501,9 @@ public void ReferenceTablePrimaryItemInBlackListRemoveOnlyNoWarn()
             table.Add(engineAssemblyName, reference);
             table.Add(xmlAssemblyName, new Reference(isWinMDFile, fileExists, getRuntimeVersion));
 
-            var blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            blackList[engineAssemblyName.FullName] = null;
-            referenceTable.MarkReferencesForExclusion(blackList);
+            var denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            denyList[engineAssemblyName.FullName] = null;
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(true, String.Empty);
 
             Dictionary<AssemblyNameExtension, Reference> table2 = referenceTable.References;
@@ -6515,16 +6517,16 @@ public void ReferenceTablePrimaryItemInBlackListRemoveOnlyNoWarn()
         }
 
         /// <summary>
-        /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference : sqlDependencyReference is in black list
+        /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference : sqlDependencyReference is in deny list
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList()
+        public void ReferenceTableDependentItemsInDenyList()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6548,7 +6550,7 @@ public void ReferenceTableDependentItemsInBlackList()
 
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6557,17 +6559,17 @@ public void ReferenceTableDependentItemsInBlackList()
 
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
-        /// and enginePrimary->sqlDependencyReference: sqlDependencyReference is in black list
+        /// and enginePrimary->sqlDependencyReference: sqlDependencyReference is in deny list
         /// and systemxml->enginePrimary
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList2()
+        public void ReferenceTableDependentItemsInDenyList2()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6592,7 +6594,7 @@ public void ReferenceTableDependentItemsInBlackList2()
 
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6603,12 +6605,12 @@ public void ReferenceTableDependentItemsInBlackList2()
         /// Testing case  enginePrimary->XmlPrimary with XMLPrimary in the BL
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
+        public void ReferenceTablePrimaryToPrimaryDependencyWithOneInDenyList()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension xmlAssemblyName = new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             Reference enginePrimaryReference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
@@ -6628,7 +6630,7 @@ public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, null, null, xmlAssemblyName, enginePrimaryReference, null, null, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { xmlAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { xmlAssemblyName }, out denyList);
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, xmlAssemblyName.FullName, subsetName);
             string warningMessage2 = rar.Log.FormatResourceString("ResolveAssemblyReference.FailedToResolveReferenceBecausePrimaryAssemblyInExclusionList", taskItem2.ItemSpec, subsetName);
@@ -6644,12 +6646,12 @@ public void ReferenceTablePrimaryToPrimaryDependencyWithOneInBlackList()
         /// Testing case  enginePrimary->XmlPrimary->dataDependency with dataDependency in the BL
         /// </summary>
         [Fact]
-        public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
+        public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInDenyList()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension xmlAssemblyName = new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6674,7 +6676,7 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, null, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, null, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { dataAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { dataAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6690,16 +6692,16 @@ public void ReferenceTablePrimaryToPrimaryToDependencyWithOneInBlackList()
 
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
-        /// and xmlPrimary->sqlDependencyReference: sqlDependencyReference is in black list
+        /// and xmlPrimary->sqlDependencyReference: sqlDependencyReference is in deny list
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList3()
+        public void ReferenceTableDependentItemsInDenyList3()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6726,7 +6728,7 @@ public void ReferenceTableDependentItemsInBlackList3()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6736,11 +6738,11 @@ public void ReferenceTableDependentItemsInBlackList3()
 
         /// <summary>
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
-        /// and xmlPrimary->dataDependencyReference: sqlDependencyReference is in black list
+        /// and xmlPrimary->dataDependencyReference: sqlDependencyReference is in deny list
         /// expect to see one dependency warning message
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList4()
+        public void ReferenceTableDependentItemsInDenyList4()
         {
             ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
 #if FEATURE_WIN32_REGISTRY
@@ -6749,7 +6751,7 @@ public void ReferenceTableDependentItemsInBlackList4()
                 null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6776,7 +6778,7 @@ public void ReferenceTableDependentItemsInBlackList4()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6788,16 +6790,16 @@ public void ReferenceTableDependentItemsInBlackList4()
         /// Testing case  enginePrimary -> dataDependencyReference->sqlDependencyReference
         /// enginePrimary -> dataDependencyReference
         /// xmlPrimaryReference ->DataDependency
-        /// dataDependencyReference and sqlDependencyReference are in black list
+        /// dataDependencyReference and sqlDependencyReference are in deny list
         /// expect to see two dependency warning messages in the enginePrimaryCase and one in the xmlPrimarycase
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackList5()
+        public void ReferenceTableDependentItemsInDenyList5()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6824,7 +6826,7 @@ public void ReferenceTableDependentItemsInBlackList5()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem.ItemSpec, sqlclientAssemblyName.FullName, subsetName);
@@ -6851,17 +6853,17 @@ public void ReferenceTableDependentItemsInBlackList5()
         /// Testing case
         /// enginePrimary -> dataDependencyReference   also enginePrimary->sqlDependencyReference   specific version = true on the primary
         /// xmlPrimaryReference ->dataDependencyReference specific version = false on the primary
-        /// dataDependencyReference and sqlDependencyReference is in the black list.
+        /// dataDependencyReference and sqlDependencyReference is in the deny list.
         /// Expect to see one dependency warning messages xmlPrimarycase and no message for enginePrimary
         /// Also expect to resolve all files except for xmlPrimaryReference
         /// </summary>
         [Fact]
-        public void ReferenceTableDependentItemsInBlackListPrimaryWithSpecificVersion()
+        public void ReferenceTableDependentItemsInDenyListPrimaryWithSpecificVersion()
         {
             ReferenceTable referenceTable;
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
-            Dictionary<string, string> blackList;
+            Dictionary<string, string> denyList;
             AssemblyNameExtension engineAssemblyName = new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension dataAssemblyName = new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             AssemblyNameExtension sqlclientAssemblyName = new AssemblyNameExtension("System.SqlClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
@@ -6892,7 +6894,7 @@ public void ReferenceTableDependentItemsInBlackListPrimaryWithSpecificVersion()
             InitializeMockEngine(out referenceTable, out mockEngine, out rar);
             AddReferencesToReferenceTable(referenceTable, engineAssemblyName, dataAssemblyName, sqlclientAssemblyName, xmlAssemblyName, enginePrimaryReference, dataDependencyReference, sqlDependencyReference, xmlPrimaryReference);
 
-            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out blackList);
+            InitializeExclusionList(referenceTable, new AssemblyNameExtension[] { sqlclientAssemblyName, dataAssemblyName }, out denyList);
 
             string subsetName = ResolveAssemblyReference.GenerateSubSetName(new string[] { "Client" }, null);
             string warningMessage = rar.Log.FormatResourceString("ResolveAssemblyReference.FailBecauseDependentAssemblyInExclusionList", taskItem2.ItemSpec, dataAssemblyName.FullName, subsetName);
@@ -6929,7 +6931,7 @@ private static ReferenceTable MakeEmptyReferenceTable(TaskLoggingHelper log)
         }
 
         /// <summary>
-        /// Verify the correct references are still in the references table and that references which are in the black list are not in the references table
+        /// Verify the correct references are still in the references table and that references which are in the deny list are not in the references table
         /// Also verify any expected warning messages are seen in the log.
         /// </summary>
         private static void VerifyReferenceTable(ReferenceTable referenceTable, MockEngine mockEngine, AssemblyNameExtension engineAssemblyName, AssemblyNameExtension dataAssemblyName, AssemblyNameExtension sqlclientAssemblyName, AssemblyNameExtension xmlAssemblyName, string[] warningMessages)
@@ -7086,7 +7088,7 @@ private static void AddReferencesToReferenceTable(ReferenceTable referenceTable,
         }
 
         /// <summary>
-        /// Initialize the mock engine so we can look at the warning messages, also put the assembly name which is to be in the black list into the black list.
+        /// Initialize the mock engine so we can look at the warning messages, also put the assembly name which is to be in the deny list into the deny list.
         /// Call remove references so that we can then validate the results.
         /// </summary>
         private void InitializeMockEngine(out ReferenceTable referenceTable, out MockEngine mockEngine, out ResolveAssemblyReference rar)
@@ -7099,17 +7101,17 @@ private void InitializeMockEngine(out ReferenceTable referenceTable, out MockEng
         }
 
         /// <summary>
-        /// Initialize the black list and use it to remove references from the reference table
+        /// Initialize the deny list and use it to remove references from the reference table
         /// </summary>
-        private void InitializeExclusionList(ReferenceTable referenceTable, AssemblyNameExtension[] assembliesForBlackList, out Dictionary<string, string> blackList)
+        private void InitializeExclusionList(ReferenceTable referenceTable, AssemblyNameExtension[] assembliesForDenyList, out Dictionary<string, string> denyList)
         {
-            blackList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            foreach (AssemblyNameExtension assemblyName in assembliesForBlackList)
+            denyList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            foreach (AssemblyNameExtension assemblyName in assembliesForDenyList)
             {
-                blackList[assemblyName.FullName] = null;
+                denyList[assemblyName.FullName] = null;
             }
 
-            referenceTable.MarkReferencesForExclusion(blackList);
+            referenceTable.MarkReferencesForExclusion(denyList);
             referenceTable.RemoveReferencesMarkedForExclusion(false, "Client");
         }
 
@@ -7342,7 +7344,7 @@ public void FakeSubsetListPathsNoAdditionalSubsets()
 
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
-        /// black list is not used.
+        /// deny list is not used.
         /// </summary>
         [Fact]
         public void ResolveAssemblyReferenceVerifyFullClientName()
@@ -7375,7 +7377,7 @@ public void ResolveAssemblyReferenceVerifyFullClientName()
 
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
-        /// black list is not used.
+        /// deny list is not used.
         /// </summary>
         [Fact]
         public void ResolveAssemblyReferenceVerifyFullClientNameWithSubsetTables()
@@ -7410,7 +7412,7 @@ public void ResolveAssemblyReferenceVerifyFullClientNameWithSubsetTables()
 
         /// <summary>
         /// This test will verify when the full client name is passed in and it appears in the TargetFrameworkSubsetList, that the
-        /// black list is not used.
+        /// deny list is not used.
         /// </summary>
         [Fact]
         public void ResolveAssemblyReferenceVerifyFullClientNameNoTablesPassedIn()
@@ -7443,7 +7445,7 @@ public void ResolveAssemblyReferenceVerifyFullClientNameNoTablesPassedIn()
         }
 
         /// <summary>
-        /// Verify the correct references are still in the references table and that references which are in the black list are not in the references table
+        /// Verify the correct references are still in the references table and that references which are in the deny list are not in the references table
         /// Also verify any expected warning messages are seen in the log.
         /// </summary>
         private static void VerifyReferenceTable(ReferenceTable referenceTable, MockEngine mockEngine, AssemblyNameExtension engineAssemblyName, AssemblyNameExtension dataAssemblyName, AssemblyNameExtension sqlclientAssemblyName, AssemblyNameExtension xmlAssemblyName, string warningMessage, string warningMessage2)
@@ -8238,7 +8240,7 @@ public void VerifyAssemblyInRedistListDiffSimpleName()
         }
 
         /// <summary>
-        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly un-resolve them if they depend on references which are in the black list for the profile.
+        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly un-resolve them if they depend on references which are in the deny list for the profile.
         /// </summary>
         [Fact]
         public void Verifyp2pAndProfile()
@@ -8286,7 +8288,7 @@ public void Verifyp2pAndProfile()
         }
 
         /// <summary>
-        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly resolve them if they depend on references which are in the black list for the profile but have specific version set to true.
+        /// Verify when a p2p (assemblies in the AssemblyFiles property) are passed to rar that we properly resolve them if they depend on references which are in the deny list for the profile but have specific version set to true.
         /// </summary>
         [Fact]
         public void Verifyp2pAndProfile2()
@@ -8483,7 +8485,7 @@ public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
         }
 
         /// <summary>
-        /// Make sure when reading in the full framework redist list or when reading in the white list xml files.
+        /// Make sure when reading in the full framework redist list or when reading in the allow list xml files.
         /// Errors in reading the file should be logged as warnings and no assemblies should be excluded.
         ///
         /// </summary>
@@ -8564,5 +8566,87 @@ private static void GenerateRedistAndProfileXmlLocations(string fullRedistConten
 
             File.WriteAllText(profileRedistList, profileListContents);
         }
+
+        [Fact]
+        public void SDKReferencesAreResolvedWithoutIO()
+        {
+            InitializeRARwithMockEngine(_output, out MockEngine mockEngine, out ResolveAssemblyReference rar);
+
+            string refPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
+
+            TaskItem item = new TaskItem(refPath);
+            item.SetMetadata("ExternallyResolved", "true");
+
+            item.SetMetadata("FrameworkReferenceName", "Microsoft.NETCore.App");
+            item.SetMetadata("FrameworkReferenceVersion", "8.0.0");
+
+            item.SetMetadata("AssemblyName", "System.Candy");
+            item.SetMetadata("AssemblyVersion", "8.1.2.3");
+            item.SetMetadata("PublicKeyToken", "b03f5f7f11d50a3a");
+
+            rar.Assemblies = new ITaskItem[] { item };
+            rar.SearchPaths = new string[]
+            {
+                "{CandidateAssemblyFiles}",
+                "{HintPathFromItem}",
+                "{TargetFrameworkDirectory}",
+                "{RawFileName}",
+            };
+            rar.WarnOrErrorOnTargetArchitectureMismatch = "Warning";
+
+            // Execute RAR and assert that we receive no I/O callbacks because the task gets what it needs from item metadata.
+            rar.Execute(
+                _ => throw new ShouldAssertException("Unexpected FileExists callback"),
+                directoryExists,
+                getDirectories,
+                _ => throw new ShouldAssertException("Unexpected GetAssemblyName callback"),
+                (string path, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache, out AssemblyNameExtension[] dependencies, out string[] scatterFiles, out FrameworkNameVersioning frameworkName)
+                  => throw new ShouldAssertException("Unexpected GetAssemblyMetadata callback"),
+#if FEATURE_WIN32_REGISTRY
+                getRegistrySubKeyNames,
+                getRegistrySubKeyDefaultValue,
+#endif
+                _ => throw new ShouldAssertException("Unexpected GetLastWriteTime callback"),
+                _ => throw new ShouldAssertException("Unexpected GetAssemblyRuntimeVersion callback"),
+#if FEATURE_WIN32_REGISTRY
+                openBaseKey,
+#endif
+                checkIfAssemblyIsInGac,
+                isWinMDFile,
+                readMachineTypeFromPEHeader).ShouldBeTrue();
+
+            rar.ResolvedFiles.Length.ShouldBe(1);
+            rar.ResolvedFiles[0].ItemSpec.ShouldBe(refPath);
+            rar.ResolvedFiles[0].GetMetadata("FusionName").ShouldBe("System.Candy, Version=8.1.2.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
+
+            // The reference is not worth persisting in the per-instance cache.
+            rar._cache.IsDirty.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void ManagedRuntimeVersionReaderSupportsWindowsRuntime()
+        {
+            // This is a prefix of a .winmd file built using the Universal Windows runtime component project in Visual Studio.
+            string windowsRuntimeAssemblyHeaderBase64Encoded =
+                "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1v" +
+                "ZGUuDQ0KJAAAAAAAAABQRQAATAEDAFD4XWQAAAAAAAAAAOAAIiALATAAAAwAAAAGAAAAAAAAXioAAAAgAAAAQAAAAAAAEAAgAAAAAgAABAAAAAAAAAAGAAIAAAAAAACAAAAAAgAAAAAAAAMAYIUAABAA" +
+                "ABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAAAkqAABPAAAAAEAAANADAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAwAAABwKQAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
+                "AAAAIAAACAAAAAAAAAAAAAAACCAAAEgAAAAAAAAAAAAAAC50ZXh0AAAAZAoAAAAgAAAADAAAAAIAAAAAAAAAAAAAAAAAACAAAGAucnNyYwAAANADAAAAQAAAAAQAAAAOAAAAAAAAAAAAAAAAAABAAABA" +
+                "LnJlbG9jAAAMAAAAAGAAAAACAAAAEgAAAAAAAAAAAAAAAAAAQAAAQgAAAAAAAAAAAAAAAAAAAAA9KgAAAAAAAEgAAAACAAUAWCAAABgJAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
+                "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4CKAEAAAoqQlNKQgEAAQAAAAAAJAAAAFdpbmRvd3NSdW50aW1lIDEuNDtDTFIgdjQuMC4zMDMxOQAAAAAABQCEAAAA+AIAACN+AAB8AwAAoAMAACNTdHJpbmdz" +
+                "AAAAABwHAAAIAAAAI1VTACQHAAAQAAAAI0dVSUQAAAA0BwAA5AEAACNCbG9iAAAAAAAAAAIAAAFHFwACCQAAAAD6ATMAFgAAAQAAABwAAAAEAAAAAwAAAAEAAAADAAAAFwAAABwAAAABAAAAAQAAAAMA" +
+                "AAAAAE0AAQAAAAAABgCWA9ACCgCWA9ACDgBlANcCBgDdATQDBgBbAjQDBgC4AAIDGwBUAwAABgD1AOoCBgCPAeoCBgBwAeoCBgBCAuoCBgD9AeoCBgAWAuoCBgAfAeoCBgBTAeoCBgDhABUDBgA6AX8C" +
+                "DgDBASgADgCAACgADgAMASgADgDBAigADgBfASgADgDMACgADgAxAigABgCPADQDDgCqACgADgCsASgACgCKANACAAAAAB8AAAAAAAEAAQAABRAAAQANAAUAAQABAAFBEAAGAA0ACQABAAIAoEAAAGMD" +
+                "DQAAAAEABABQIAAAAACGGPwCAQABAAAAAAADAIYY/AIBAAEAAAAAAAMA4QGZAgUAAQAAAAAAeQICABAAAwAQAAMADQAJAPwCAQAZALgCBQAhAPwCCQApAPwCAQAxAPwCDgBBAPwCFABJAPwCFABRAPwC" +
+                "FABZAPwCFABhAPwCFABpAPwCFABxAPwCFAB5APwCFACBAPwCGQCJAPwCFACRAPwCHgChAPwCJACxAPwCKgC5APwCKgDBAPwCAQDJAPwCAQDRAPwCLwDZAPwCPgAlAKMAqgEuABsA2AAuACMA4QAuACsA" +
+                "AAEuADMACQEuADsAIAEuAEMAIAEuAEsAIAEuAFMACQEuAFsAJgEuAGMAIAEuAGsAPgEuAHMAIAEuAHsASwFDAIMAAAFDAIsAmAFDAJMAoQFDAJsAoQFFAKMAqgFjAIMAAAFjAIsAmAFjAJMAoQFjAKsA" +
+                "qgFjAJsAoQGDAKsAqgGDALMArwGDAJMAoQGDALsAxAEDAAYABQAEgAAAAQAAAAAAAAAAAgAAAAANAAAABAACAAEAAAAAAAAARABxAAAAAAD/AP8A/wD/AAAAAABNAEQAAABWAAQAAAAAAAAAAAIAAAAA";
+
+            using MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(windowsRuntimeAssemblyHeaderBase64Encoded));
+            using BinaryReader reader = new BinaryReader(memoryStream);
+            string runtimeVersion = ManagedRuntimeVersionReader.GetRuntimeVersion(reader);
+
+            runtimeVersion.ShouldBe("WindowsRuntime 1.4;CLR v4.0.30319");
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
index 8c5291e2f7a..5607a413d21 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
@@ -20,6 +20,8 @@ public class ResolveAssemblyReferenceCacheSerialization : IDisposable
         private readonly string _rarCacheFile;
         private readonly TaskLoggingHelper _taskLoggingHelper;
 
+        private static readonly DateTime s_now = DateTime.Now;
+
         public ResolveAssemblyReferenceCacheSerialization()
         {
             var tempPath = Path.GetTempPath();
@@ -38,14 +40,22 @@ public void Dispose()
             }
         }
 
+        private static DateTime GetLastWriteTime(string path) => path switch
+        {
+            "path1" => s_now,
+            "path2" => s_now,
+            "dllName" => s_now.AddSeconds(-10),
+            _ => throw new ArgumentException(),
+        };
+
         [Fact]
         public void RoundTripEmptyState()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
 
-            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
+            var deserialized = StateFileBase.DeserializeCache<SystemState>(_rarCacheFile, _taskLoggingHelper);
 
             deserialized.ShouldNotBeNull();
         }
@@ -55,7 +65,7 @@ public void CorrectFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
                 cacheStream.Seek(0, SeekOrigin.Begin);
@@ -63,7 +73,7 @@ public void CorrectFileVersion()
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
+            var deserialized = StateFileBase.DeserializeCache<SystemState>(_rarCacheFile, _taskLoggingHelper);
 
             deserialized.ShouldNotBeNull();
         }
@@ -73,7 +83,7 @@ public void WrongFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
                 cacheStream.Seek(0, SeekOrigin.Begin);
@@ -81,7 +91,7 @@ public void WrongFileVersion()
                 cacheStream.Close();
             }
 
-            var deserialized = SystemState.DeserializeCache(_rarCacheFile, _taskLoggingHelper, typeof(SystemState));
+            var deserialized = StateFileBase.DeserializeCache<SystemState>(_rarCacheFile, _taskLoggingHelper);
 
             deserialized.ShouldBeNull();
         }
@@ -90,21 +100,30 @@ public void WrongFileVersion()
         public void ValidateSerializationAndDeserialization()
         {
             Dictionary<string, SystemState.FileState> cache = new() {
-                    { "path1", new SystemState.FileState(DateTime.Now) },
-                    { "path2", new SystemState.FileState(DateTime.Now) { Assembly = new AssemblyNameExtension("hi") } },
-                    { "dllName", new SystemState.FileState(DateTime.Now.AddSeconds(-10)) {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) { Assembly = new AssemblyNameExtension("hi") } },
+                    { "dllName", new SystemState.FileState(GetLastWriteTime("dllName")) {
                         Assembly = null,
                         RuntimeVersion = "v4.0.30319",
                         FrameworkNameAttribute = new FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
                         scatterFiles = new string[] { "first", "second" } } } };
             SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
             sysState.instanceLocalFileStateCache = cache;
+
+            // Get all FileState entries to make sure they are marked as having been used.
+            _ = sysState.GetFileState("path1");
+            _ = sysState.GetFileState("path2");
+            _ = sysState.GetFileState("dllName");
+
+            sysState.HasStateToSave.ShouldBe(true);
+
             SystemState sysState2 = null;
             using (TestEnvironment env = TestEnvironment.Create())
             {
                 TransientTestFile file = env.CreateFile();
                 sysState.SerializeCache(file.Path, null);
-                sysState2 = SystemState.DeserializeCache(file.Path, null, typeof(SystemState)) as SystemState;
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
             }
 
             Dictionary<string, SystemState.FileState> cache2 = sysState2.instanceLocalFileStateCache;
@@ -119,5 +138,58 @@ public void ValidateSerializationAndDeserialization()
             dll2.scatterFiles.Length.ShouldBe(dll.scatterFiles.Length);
             dll2.scatterFiles[1].ShouldBe(dll.scatterFiles[1]);
         }
+
+        [Fact]
+        public void OutgoingCacheIsSmallerThanIncomingCache()
+        {
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) } };
+            SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
+            sysState.instanceLocalFileStateCache = cache;
+
+            // Get only the first FileState entry.
+            _ = sysState.GetFileState("path1");
+
+            sysState.HasStateToSave.ShouldBe(true);
+
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
+            }
+
+            // The new cache has only the entry that was actually used.
+            Dictionary<string, SystemState.FileState> cache2 = sysState2.instanceLocalFileStateCache;
+            cache2.Count.ShouldBe(1);
+            cache2.ShouldContainKey("path1");
+        }
+
+        [Fact]
+        public void OutgoingCacheIsEmpty()
+        {
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) } };
+            SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
+            sysState.instanceLocalFileStateCache = cache;
+
+            sysState.HasStateToSave.ShouldBe(false);
+
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
+            }
+
+            // The new cache was not written to disk at all because none of the entries were actually used.
+            sysState2.ShouldBeNull();
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 748cce32307..6b025c4256d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2911,7 +2911,7 @@ private static DateTime GetLastWriteTime(string path)
         /// </summary>
         /// <param name="appConfigFile"></param>
         /// <param name="redirects"></param>
-        protected static string WriteAppConfig(string redirects)
+        protected static string WriteAppConfig(string redirects, string appConfigNameSuffix = null)
         {
             string appConfigContents =
             "<configuration>\n" +
@@ -2920,7 +2920,7 @@ protected static string WriteAppConfig(string redirects)
             "    </runtime>\n" +
             "</configuration>";
 
-            string appConfigFile = FileUtilities.GetTemporaryFileName();
+            string appConfigFile = FileUtilities.GetTemporaryFileName() + appConfigNameSuffix;
             File.WriteAllText(appConfigFile, appConfigContents);
             return appConfigFile;
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
index 1c67ddd8750..c4f0bd34510 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
@@ -38,13 +38,16 @@ public StronglyNamedDependencyAppConfig(ITestOutputHelper output) : base(output)
         /// - An app.config was passed in that promotes UnifyMe version from 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
+        /// - The case is attempted on special unicode characters in path as well.
         /// Expected:
         /// - The resulting UnifyMe returned should be 2.0.0.0.
         /// Rationale:
         /// Strongly named dependencies should unify according to the bindingRedirects in the app.config.
         /// </summary>
-        [Fact]
-        public void Exists()
+        [Theory]
+        [InlineData(null)]
+        [InlineData("\uE025\uE026")]
+        public void Exists(string appConfigNameSuffix)
         {
             // Create the engine.
             MockEngine engine = new MockEngine(_output);
@@ -59,7 +62,8 @@ public void Exists()
                     "        <dependentAssembly>\n" +
                     "            <assemblyIdentity name='UnifyMe' PublicKeyToken='b77a5c561934e089' culture='neutral' />\n" +
                     "            <bindingRedirect oldVersion='1.0.0.0' newVersion='2.0.0.0' />\n" +
-                    "        </dependentAssembly>\n");
+                    "        </dependentAssembly>\n",
+                    appConfigNameSuffix);
 
             // Now, pass feed resolved primary references into ResolveAssemblyReference.
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -88,15 +92,15 @@ public void Exists()
         /// - An app.config was passed in that promotes UnifyMe version from 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        /// -Version 2.0.0.0 of UnifyMe is in the Black List
+        /// -Version 2.0.0.0 of UnifyMe is in the Deny List
         /// Expected:
         /// - There should be a warning indicating that DependsOnUnified has a dependency UnifyMe 2.0.0.0 which is not in a TargetFrameworkSubset.
         /// - There will be no unified message.
         /// Rationale:
-        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the black list it should be removed and warned.
+        /// Strongly named dependencies should unify according to the bindingRedirects in the app.config, if the unified version is in the deny list it should be removed and warned.
         /// </summary>
         [Fact]
-        public void ExistsPromotedDependencyInTheBlackList()
+        public void ExistsPromotedDependencyInTheDenyList()
         {
             string engineOnlySubset =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
index a283f172b13..d971ece54a5 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
@@ -100,15 +100,15 @@ internal void ExistsImpl(RARSimulationMode rarSimulationMode = RARSimulationMode
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        ///   - DependsOnUnified 2.0.0.0 is on the black list. 
+        ///   - DependsOnUnified 2.0.0.0 is on the deny list. 
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
         /// Rationale:
         /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
-        /// dependency seen. However if the higher assembly is a dependency of an assembly in the black list it should not be considered during unification.
+        /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
-        public void ExistsWithPrimaryReferenceOnBlackList()
+        public void ExistsWithPrimaryReferenceOnDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -178,16 +178,16 @@ public void ExistsWithPrimaryReferenceOnBlackList()
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        /// - UnifyMe 2.0.0.0 is on the black list
+        /// - UnifyMe 2.0.0.0 is on the deny list
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 1.0.0.0.
-        ///  Also there should be a warning about the primary reference DependsOnUnified 2.0.0.0 having a dependency which was in the black list.
+        ///  Also there should be a warning about the primary reference DependsOnUnified 2.0.0.0 having a dependency which was in the deny list.
         /// Rationale:
         /// When AutoUnify is true, we need to resolve to the highest version of each particular assembly 
-        /// dependency seen. However if the higher assembly is a dependency of an assembly in the black list it should not be considered during unification.
+        /// dependency seen. However if the higher assembly is a dependency of an assembly in the deny list it should not be considered during unification.
         /// </summary>
         [Fact]
-        public void ExistsPromotedDependencyInTheBlackList()
+        public void ExistsPromotedDependencyInTheDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -258,14 +258,14 @@ public void ExistsPromotedDependencyInTheBlackList()
         /// - The AutoUnify flag is set to 'true'.
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
-        ///   - UnifyMe 2.0.0.0 is on the black list because it is higher than what is in the redist list, 1.0.0.0 is also in a black list because it is not in the subset but is in the redist list.
+        ///   - UnifyMe 2.0.0.0 is on the deny list because it is higher than what is in the redist list, 1.0.0.0 is also in a deny list because it is not in the subset but is in the redist list.
         /// Expected:
         /// - There should be no UnifyMe dependency returned 
-        /// There should be a warning indicating the primary reference DependsOnUnified 1.0.0.0 has a dependency that in the black list
-        /// There should be a warning indicating the primary reference DependsOnUnified 2.0.0.0 has a dependency that in the black list
+        /// There should be a warning indicating the primary reference DependsOnUnified 1.0.0.0 has a dependency that in the deny list
+        /// There should be a warning indicating the primary reference DependsOnUnified 2.0.0.0 has a dependency that in the deny list
         /// </summary>
         [Fact]
-        public void ExistsWithBothDependentReferenceOnBlackList()
+        public void ExistsWithBothDependentReferenceOnDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
@@ -333,7 +333,7 @@ public void ExistsWithBothDependentReferenceOnBlackList()
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
         /// - Version 3.0.0.0 of UnifyMe exists.
-        /// - Version 3.0.0.0 of DependsOn is on black list
+        /// - Version 3.0.0.0 of DependsOn is on deny list
         /// Expected:
         /// - There should be exactly one UnifyMe dependency returned and it should be version 2.0.0.0.
         /// - There should be messages saying that 2.0.0.0 was unified from 1.0.0.0.
@@ -341,7 +341,7 @@ public void ExistsWithBothDependentReferenceOnBlackList()
         /// AutoUnify works even when unifying multiple prior versions.
         /// </summary>
         [Fact]
-        public void MultipleUnifiedFromNamesMiddlePrimaryOnBlackList()
+        public void MultipleUnifiedFromNamesMiddlePrimaryOnDenyList()
         {
             string implicitRedistListContents =
                 "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
diff --git a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
index bf6e3c2a05c..af533432c22 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
@@ -59,7 +59,7 @@ private ITranslator GetReadTranslator()
             }
 
             _serializationStream.Seek(0, SeekOrigin.Begin);
-            return BinaryTranslator.GetReadTranslator(_serializationStream, null);
+            return BinaryTranslator.GetReadTranslator(_serializationStream, InterningBinaryReader.PoolingBuffer);
         }
 
         private ITranslator GetWriteTranslator()
diff --git a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
index 8cf97318e7a..58e3021af56 100644
--- a/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyRegistrationCache_Tests.cs
@@ -40,7 +40,7 @@ public void ExerciseCacheSerialization()
             {
                 TransientTestFile file = env.CreateFile();
                 arc.SerializeCache(file.Path, null);
-                arc2 = StateFileBase.DeserializeCache(file.Path, null, typeof(AssemblyRegistrationCache)) as AssemblyRegistrationCache;
+                arc2 = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(file.Path, null);
             }
 
             arc2._assemblies.Count.ShouldBe(arc._assemblies.Count);
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 0832273c79b..1792dad790f 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -27,19 +27,47 @@ namespace Microsoft.Build.UnitTests
 {
     public class Copy_Tests : IDisposable
     {
-        public bool UseHardLinks { get; protected set; }
+        /// <summary>
+        /// Gets data for testing with combinations of isUseHardLinks and isUseSymbolicLinks.
+        /// Index 0 is the value for isUseHardLinks.
+        /// Index 1 is the value for isUseSymbolicLinks.
+        /// </summary>
+        public static IEnumerable<object[]> GetHardLinksSymLinks() => new List<object[]>
+        {
+            new object[] { false, false },
+            new object[] { false, true },
+            new object[] { true, false },
 
-        public bool UseSymbolicLinks { get; protected set; }
+            /* Cases not covered
+            new object[] { true, true },
+            */
+        };
 
-        public bool UseSingleThreadedCopy
+        /// <summary>
+        /// Gets data for testing with combinations of isUseHardLinks, isUseSymbolicLinks, and isUseSingleThreadedCopy.
+        /// Index 0 is the value for isUseHardLinks.
+        /// Index 1 is the value for isUseSymbolicLinks.
+        /// Index 2 is the value for isUseSingleThreadedCopy.
+        /// </summary>
+        public static IEnumerable<object[]> GetHardLinksSymLinksSingleThreaded() => new List<object[]>
         {
-            get => _parallelismThreadCount == NoParallelismThreadCount;
-            protected set => _parallelismThreadCount = value ? NoParallelismThreadCount : DefaultParallelismThreadCount;
-        }
+            new object[] { false, false, false },
+            new object[] { false, false, true },
+            new object[] { false, true, false },
+            new object[] { true, false, false },
+
+            /* Cases not covered
+            new object[] { false, true, true },
+            new object[] { true, false, true },
+            new object[] { true, true, false },
+            new object[] { true, true, true },
+            */
+        };
 
         private const int NoParallelismThreadCount = 1;
         private const int DefaultParallelismThreadCount = int.MaxValue;
-        private int _parallelismThreadCount = DefaultParallelismThreadCount;
+
+        private int GetParallelismThreadCount(bool isUseSingleThreadedCopy) => isUseSingleThreadedCopy ? NoParallelismThreadCount : DefaultParallelismThreadCount;
 
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
@@ -88,8 +116,9 @@ public void Dispose()
         /// If OnlyCopyIfDifferent is set to "true" then we shouldn't copy over files that
         /// have the same date and time.
         /// </summary>
-        [Fact]
-        public void DontCopyOverSameFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void DontCopyOverSameFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string file = FileUtilities.GetTemporaryFile();
             try
@@ -111,11 +140,11 @@ public void DontCopyOverSameFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
-                t.Execute(m.CopyFile, _parallelismThreadCount);
+                t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -131,8 +160,9 @@ public void DontCopyOverSameFile()
         /// <summary>
         /// Question should not copy any files.
         /// </summary>
-        [Fact]
-        public void QuestionCopyFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void QuestionCopyFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile(null, ".tmp", false);
@@ -157,12 +187,12 @@ public void QuestionCopyFile()
                     BuildEngine = new MockEngine(_testOutputHelper),
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, _parallelismThreadCount));
+                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -178,8 +208,9 @@ public void QuestionCopyFile()
         /// <summary>
         /// Question copy should not error if copy did no work.
         /// </summary>
-        [Fact]
-        public void QuestionCopyFileSameContent()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void QuestionCopyFileSameContent(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -216,12 +247,12 @@ public void QuestionCopyFileSameContent()
                     BuildEngine = new MockEngine(_testOutputHelper),
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     SkipUnchangedFiles = true,
                     FailIfNotIncremental = true,
                 };
-                Assert.True(t.Execute(m.CopyFile, _parallelismThreadCount));
+                Assert.True(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -238,8 +269,9 @@ public void QuestionCopyFileSameContent()
         /// <summary>
         /// Question copy should error if a copy will occur.
         /// </summary>
-        [Fact]
-        public void QuestionCopyFileNotSameContent()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void QuestionCopyFileNotSameContent(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -267,13 +299,13 @@ public void QuestionCopyFileNotSameContent()
                     BuildEngine = new MockEngine(_testOutputHelper),
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     SkipUnchangedFiles = true,
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, _parallelismThreadCount));
+                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -290,10 +322,11 @@ public void QuestionCopyFileNotSameContent()
         /// <summary>
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void DoNotNormallyCopyOverReadOnlyFile()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotNormallyCopyOverReadOnlyFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -324,8 +357,8 @@ public void DoNotNormallyCopyOverReadOnlyFile()
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
                     // OverwriteReadOnlyFiles defaults to false
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should fail: target is readonly
@@ -352,10 +385,11 @@ public void DoNotNormallyCopyOverReadOnlyFile()
         /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when
         /// OverwriteReadOnlyFiles is false
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void CopyOverReadOnlyFileEnvironmentOverride()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyOverReadOnlyFileEnvironmentOverride(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -390,8 +424,8 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
                     OverwriteReadOnlyFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should not fail although target is readonly
@@ -417,10 +451,11 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         /// <summary>
         /// If MSBUILDALWAYSRETRY is set, keep retrying the copy.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void AlwaysRetryCopyEnvironmentOverride()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void AlwaysRetryCopyEnvironmentOverride(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -457,8 +492,8 @@ public void AlwaysRetryCopyEnvironmentOverride()
                     SkipUnchangedFiles = true,
                     OverwriteReadOnlyFiles = false,
                     Retries = 5,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // The file is read-only, so the retries will all fail.
@@ -488,10 +523,11 @@ public void AlwaysRetryCopyEnvironmentOverride()
         /// <summary>
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void CopyOverReadOnlyFileParameterIsSet()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyOverReadOnlyFileParameterIsSet(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source = FileUtilities.GetTemporaryFile();
             string destination = FileUtilities.GetTemporaryFile();
@@ -522,8 +558,8 @@ public void CopyOverReadOnlyFileParameterIsSet()
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
                     OverwriteReadOnlyFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should not fail although target is readonly
@@ -547,8 +583,9 @@ public void CopyOverReadOnlyFileParameterIsSet()
         /// <summary>
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
-        [Fact]
-        public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string source1 = FileUtilities.GetTemporaryFile();
             string source2 = FileUtilities.GetTemporaryFile();
@@ -593,8 +630,8 @@ public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destinationFolder),
                     OverwriteReadOnlyFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 // Should not fail although one target is readonly
@@ -631,8 +668,9 @@ public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
          * If OnlyCopyIfDifferent is set to "true" then we should still copy over files that
          * have different dates or sizes.
          */
-        [Fact]
-        public void DoCopyOverDifferentFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoCopyOverDifferentFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -658,8 +696,8 @@ public void DoCopyOverDifferentFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 t.Execute();
@@ -688,9 +726,13 @@ public void DoCopyOverDifferentFile()
          * If SkipUnchangedFiles is set to "true" then we should never copy over files that have same dates and sizes.
          */
         [Theory(Skip = "https://github.com/dotnet/msbuild/issues/4126")]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
+        [InlineData(false, false, false)]
+        [InlineData(false, false, true)]
+        [InlineData(false, true, false)]
+        [InlineData(true, false, false)]
+        [InlineData(true, false, true)]
+        [InlineData(true, true, false)]
+        public void DoCopyOverCopiedFile(bool skipUnchangedFiles, bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             using (var env = TestEnvironment.Create())
             {
@@ -710,8 +752,8 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
                         SourceFiles = new[] { new TaskItem(sourceFile) },
                         DestinationFiles = new[] { new TaskItem(destinationFile) },
                         SkipUnchangedFiles = skipUnchangedFiles,
-                        UseHardlinksIfPossible = UseHardLinks,
-                        UseSymboliclinksIfPossible = UseSymbolicLinks,
+                        UseHardlinksIfPossible = isUseHardLinks,
+                        UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     };
 
                     var success = t.Execute();
@@ -721,10 +763,10 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
                                         i == 1 &&
                                         // SkipUnchanged check will always fail for symbolic links,
                                         // because we compare attributes of real file with attributes of symbolic link.
-                                        !UseSymbolicLinks &&
+                                        !isUseSymbolicLinks &&
                                         // On Windows and MacOS File.Copy already preserves LastWriteTime, but on Linux extra step is needed.
                                         // TODO - this need to be fixed on Linux
-                                        (!NativeMethodsShared.IsLinux || UseHardLinks);
+                                        (!NativeMethodsShared.IsLinux || isUseHardLinks);
 
                     if (shouldNotCopy)
                     {
@@ -758,8 +800,9 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
          * If OnlyCopyIfDifferent is set to "true" then we should still copy over files that
          * don't exist.
          */
-        [Fact]
-        public void DoCopyOverNonExistentFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoCopyOverNonExistentFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -788,8 +831,8 @@ public void DoCopyOverNonExistentFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 t.Execute();
@@ -807,8 +850,9 @@ public void DoCopyOverNonExistentFile()
         /// <summary>
         /// Make sure we do not retry when the source file has a misplaced colon
         /// </summary>
-        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Colon is special only on Windows.")]
-        public void DoNotRetryCopyNotSupportedException()
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Colon is special only on Windows.")]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyNotSupportedException(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = "foobar:";
@@ -826,8 +870,8 @@ public void DoNotRetryCopyNotSupportedException()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -846,8 +890,9 @@ public void DoNotRetryCopyNotSupportedException()
         /// <summary>
         /// Make sure we do not retry when the source file does not exist
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyNonExistentSourceFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyNonExistentSourceFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = "Nannanacat";
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -872,8 +917,8 @@ public void DoNotRetryCopyNonExistentSourceFile()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -892,8 +937,9 @@ public void DoNotRetryCopyNonExistentSourceFile()
         /// <summary>
         /// Make sure we do not retry when the source file is a folder
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyWhenSourceIsFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyWhenSourceIsFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = Path.GetTempPath();
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -918,8 +964,8 @@ public void DoNotRetryCopyWhenSourceIsFolder()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -938,10 +984,11 @@ public void DoNotRetryCopyWhenSourceIsFolder()
         /// <summary>
         /// Most important case is when destination is locked
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void DoRetryWhenDestinationLocked()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoRetryWhenDestinationLocked(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string destinationFile = Path.GetTempFileName();
             string sourceFile = Path.GetTempFileName();
@@ -959,8 +1006,8 @@ public void DoRetryWhenDestinationLocked()
                         BuildEngine = engine,
                         SourceFiles = sourceFiles,
                         DestinationFiles = new ITaskItem[] { new TaskItem(destinationFile) },
-                        UseHardlinksIfPossible = UseHardLinks,
-                        UseSymboliclinksIfPossible = UseSymbolicLinks,
+                        UseHardlinksIfPossible = isUseHardLinks,
+                        UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     };
 
                     bool result = t.Execute();
@@ -989,8 +1036,9 @@ public void DoRetryWhenDestinationLocked()
         /// <summary>
         /// When destination is inaccessible due to ACL, do NOT retry
         /// </summary>
-        [Fact]
-        public void DoNotRetryWhenDestinationLockedDueToAcl()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryWhenDestinationLockedDueToAcl(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), "DoNotRetryWhenDestinationLockedDueToAcl");
             string destinationFile = Path.Combine(tempDirectory, "DestinationFile.txt");
@@ -1029,8 +1077,8 @@ public void DoNotRetryWhenDestinationLockedDueToAcl()
                     BuildEngine = engine,
                     SourceFiles = new ITaskItem[] { new TaskItem(sourceFile) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(destinationFile) },
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -1061,8 +1109,9 @@ public void DoNotRetryWhenDestinationLockedDueToAcl()
         /// <summary>
         /// Make sure we do not retry when the destination file is a folder
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyWhenDestinationFolderIsFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyWhenDestinationFolderIsFile(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string destinationFile = FileUtilities.GetTemporaryFile();
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -1084,8 +1133,8 @@ public void DoNotRetryCopyWhenDestinationFolderIsFile()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destinationFile),
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -1106,8 +1155,9 @@ public void DoNotRetryCopyWhenDestinationFolderIsFile()
         /// <summary>
         /// Make sure we do not retry when the destination file is a folder
         /// </summary>
-        [Fact]
-        public void DoNotRetryCopyWhenDestinationFileIsFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotRetryCopyWhenDestinationFileIsFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string destinationFile = Path.GetTempPath();
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -1130,8 +1180,8 @@ public void DoNotRetryCopyWhenDestinationFileIsFolder()
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -1147,28 +1197,13 @@ public void DoNotRetryCopyWhenDestinationFileIsFolder()
             }
         }
 
-        internal sealed class CopyMonitor
-        {
-            internal int copyCount;
-
-            /*
-            * Method:   CopyFile
-            *
-            * Don't really copy the file, just count how many times this was called.
-            */
-            internal bool? CopyFile(FileState source, FileState destination)
-            {
-                Interlocked.Increment(ref copyCount);
-                return true;
-            }
-        }
-
         /// <summary>
         /// CopiedFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Under Unix all filenames are valid and this test is not useful.")]
-        public void OutputsOnlyIncludeSuccessfulCopies()
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Under Unix all filenames are valid and this test is not useful.")]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void OutputsOnlyIncludeSuccessfulCopies(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string inFile1 = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A392");
@@ -1197,8 +1232,8 @@ public void OutputsOnlyIncludeSuccessfulCopies()
                 {
                     RetryDelayMilliseconds = 1,  // speed up tests!
                     BuildEngine = engine,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 ITaskItem i1 = new TaskItem(inFile1);
@@ -1254,8 +1289,9 @@ public void OutputsOnlyIncludeSuccessfulCopies()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false.
         /// </summary>
-        [Fact]
-        public void CopyFileOnItself()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyFileOnItself(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string file = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A395");
@@ -1281,8 +1317,8 @@ public void CopyFileOnItself()
                     SourceFiles = new ITaskItem[] { new TaskItem(file) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(file) },
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1300,8 +1336,8 @@ public void CopyFileOnItself()
                     SourceFiles = new ITaskItem[] { new TaskItem(file) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(file) },
                     SkipUnchangedFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 success = t.Execute();
@@ -1323,8 +1359,9 @@ public void CopyFileOnItself()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false. Variation with different casing/relativeness.
         /// </summary>
-        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
-        public void CopyFileOnItself2()
+        [WindowsOnlyTheory(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyFileOnItself2(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string currdir = Directory.GetCurrentDirectory();
             string filename = "2A333ED756AF4dc392E728D0F864A396";
@@ -1351,8 +1388,8 @@ public void CopyFileOnItself2()
                     SourceFiles = new ITaskItem[] { new TaskItem(file) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(filename.ToLowerInvariant()) },
                     SkipUnchangedFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1373,10 +1410,11 @@ public void CopyFileOnItself2()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false. Variation with a second copy failure.
         /// </summary>
-        [Fact]
+        [Theory]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void CopyFileOnItselfAndFailACopy()
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyFileOnItselfAndFailACopy(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string file = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A395");
@@ -1404,8 +1442,8 @@ public void CopyFileOnItselfAndFailACopy()
                     SourceFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(invalidFile) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(dest2) },
                     SkipUnchangedFiles = false,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1438,8 +1476,9 @@ public void CopyFileOnItselfAndFailACopy()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        public void CopyToDestinationFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyToDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             string temp = Path.GetTempPath();
@@ -1464,8 +1503,8 @@ public void CopyToDestinationFolder()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destFolder),
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1479,7 +1518,7 @@ public void CopyToDestinationFolder()
                     destinationFileContents = sr.ReadToEnd();
                 }
 
-                if (!UseHardLinks)
+                if (!isUseHardLinks)
                 {
                     MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
                     me.AssertLogDoesntContainMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
@@ -1508,8 +1547,9 @@ public void CopyToDestinationFolder()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        public void CopyDoubleEscapableFileToDestinationFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void CopyDoubleEscapableFileToDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFileEscaped = Path.GetTempPath() + "a%253A_" + Guid.NewGuid().ToString("N") + ".txt";
             string sourceFile = EscapingUtilities.UnescapeAll(sourceFileEscaped);
@@ -1535,8 +1575,8 @@ public void CopyDoubleEscapableFileToDestinationFolder()
                     SourceFiles = sourceFiles,
                     DestinationFolder = new TaskItem(destFolder),
                     SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1569,8 +1609,9 @@ public void CopyDoubleEscapableFileToDestinationFolder()
         /// Copying duplicates should only perform the actual copy once for each unique source/destination pair
         /// but should still produce outputs for all specified source/destination pairs.
         /// </summary>
-        [Fact]
-        public void CopyWithDuplicatesUsingFolder()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void CopyWithDuplicatesUsingFolder(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string tempPath = Path.GetTempPath();
 
@@ -1598,8 +1639,8 @@ public void CopyWithDuplicatesUsingFolder()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = sourceFiles,
                 DestinationFolder = new TaskItem(Path.Combine(tempPath, "foo")),
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
@@ -1609,7 +1650,7 @@ public void CopyWithDuplicatesUsingFolder()
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, _parallelismThreadCount);
+            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(success);
             Assert.Equal(2, filesActuallyCopied.Count);
@@ -1625,8 +1666,9 @@ public void CopyWithDuplicatesUsingFolder()
         /// Copying duplicates should only perform the actual copy once for each unique source/destination pair
         /// but should still produce outputs for all specified source/destination pairs.
         /// </summary>
-        [Fact]
-        public void CopyWithDuplicatesUsingFiles()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void CopyWithDuplicatesUsingFiles(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             string tempPath = Path.GetTempPath();
 
@@ -1664,8 +1706,8 @@ public void CopyWithDuplicatesUsingFiles()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = sourceFiles,
                 DestinationFiles = destFiles,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
@@ -1675,7 +1717,7 @@ public void CopyWithDuplicatesUsingFiles()
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, _parallelismThreadCount);
+            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(success);
             Assert.Equal(4, filesActuallyCopied.Count);
@@ -1701,8 +1743,9 @@ public void CopyWithDuplicatesUsingFiles()
         /// DestinationFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [Fact]
-        public void DestinationFilesLengthNotEqualSourceFilesLength()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DestinationFilesLengthNotEqualSourceFilesLength(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string temp = Path.GetTempPath();
             string inFile1 = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
@@ -1732,8 +1775,8 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
                     BuildEngine = engine,
                     SourceFiles = new ITaskItem[] { new TaskItem(inFile1), new TaskItem(inFile2) },
                     DestinationFiles = new ITaskItem[] { new TaskItem(outFile1) },
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool success = t.Execute();
@@ -1757,8 +1800,9 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
         /// If the destination path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [WindowsFullFrameworkOnlyFact]
-        public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
+        [WindowsFullFrameworkOnlyTheory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void Regress451057_ExitGracefullyIfPathNameIsTooLong(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
             const string destinationFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
@@ -1779,8 +1823,8 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
                     BuildEngine = new MockEngine(_testOutputHelper),
                     SourceFiles = sourceFiles,
                     DestinationFiles = destinationFiles,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
                 bool result = t.Execute();
@@ -1800,8 +1844,9 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         /// If the source path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [WindowsFullFrameworkOnlyFact]
-        public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
+        [WindowsFullFrameworkOnlyTheory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void Regress451057_ExitGracefullyIfPathNameIsTooLong2(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             const string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
             string destinationFile = FileUtilities.GetTemporaryFile();
@@ -1816,8 +1861,8 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = sourceFiles,
                 DestinationFiles = destinationFiles,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1832,8 +1877,9 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         /// <summary>
         /// If the SourceFiles parameter is given invalid path characters, make sure the task exits gracefully.
         /// </summary>
-        [Fact]
-        public void ExitGracefullyOnInvalidPathCharacters()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void ExitGracefullyOnInvalidPathCharacters(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             var t = new Copy
             {
@@ -1841,8 +1887,8 @@ public void ExitGracefullyOnInvalidPathCharacters()
                 BuildEngine = new MockEngine(_testOutputHelper),
                 SourceFiles = new ITaskItem[] { new TaskItem("foo | bar") },
                 DestinationFolder = new TaskItem("dest"),
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1866,8 +1912,6 @@ public void InvalidRetryCount()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = -1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1890,8 +1934,6 @@ public void InvalidRetryDelayCount()
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 1,
                 RetryDelayMilliseconds = -1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
             };
 
             bool result = t.Execute();
@@ -1904,8 +1946,9 @@ public void InvalidRetryDelayCount()
         /// Verifies that we do not log the retrying warning if we didn't request
         /// retries.
         /// </summary>
-        [Fact]
-        public void FailureWithNoRetries()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void FailureWithNoRetries(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1915,12 +1958,12 @@ public void FailureWithNoRetries()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 0,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.False(result);
             engine.AssertLogDoesntContain("MSB3026");
@@ -1970,8 +2013,9 @@ public void DefaultNoHardlink()
         /// Verifies that we get the one retry we ask for after the first attempt fails,
         /// and we get appropriate messages.
         /// </summary>
-        [Fact]
-        public void SuccessAfterOneRetry()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void SuccessAfterOneRetry(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -1981,12 +2025,12 @@ public void SuccessAfterOneRetry()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -1996,8 +2040,9 @@ public void SuccessAfterOneRetry()
         /// <summary>
         /// Verifies that after a successful retry we continue to the next file
         /// </summary>
-        [Fact]
-        public void SuccessAfterOneRetryContinueToNextFile()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void SuccessAfterOneRetryContinueToNextFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -2007,12 +2052,12 @@ public void SuccessAfterOneRetryContinueToNextFile()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source"), new TaskItem("c:\\source2") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination"), new TaskItem("c:\\destination2") },
                 Retries = 1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -2027,8 +2072,9 @@ public void SuccessAfterOneRetryContinueToNextFile()
         /// The copy delegate can return false, or throw on failure.
         /// This test tests returning false.
         /// </summary>
-        [Fact]
-        public void TooFewRetriesReturnsFalse()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void TooFewRetriesReturnsFalse(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -2038,12 +2084,12 @@ public void TooFewRetriesReturnsFalse()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 2,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(4, false /* do not throw */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
@@ -2055,8 +2101,9 @@ public void TooFewRetriesReturnsFalse()
         /// The copy delegate can return false, or throw on failure.
         /// This test tests the throw case.
         /// </summary>
-        [Fact]
-        public void TooFewRetriesThrows()
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinksSingleThreaded))]
+        public void TooFewRetriesThrows(bool isUseHardLinks, bool isUseSymbolicLinks, bool isUseSingleThreadedCopy)
         {
             var engine = new MockEngine(true /* log to console */);
             var t = new Copy
@@ -2066,19 +2113,22 @@ public void TooFewRetriesThrows()
                 SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
                 DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
                 Retries = 1,
-                UseHardlinksIfPossible = UseHardLinks,
-                UseSymboliclinksIfPossible = UseSymbolicLinks,
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
             };
 
             var copyFunctor = new CopyFunctor(3, true /* throw */);
-            bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
+            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
             engine.AssertLogContains("MSB3027");
         }
 
-        internal virtual void ErrorIfLinkFailedCheck()
+        [WindowsOnlyTheory]
+        [InlineData(false, true)]
+        [InlineData(true, false)]
+        public void ErrorIfLinkFailedCheck(bool isUseHardLinks, bool isUseSymbolicLinks)
         {
             using (var env = TestEnvironment.Create())
             {
@@ -2091,8 +2141,8 @@ internal virtual void ErrorIfLinkFailedCheck()
                 Copy t = new Copy
                 {
                     RetryDelayMilliseconds = 1,
-                    UseHardlinksIfPossible = UseHardLinks,
-                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    UseHardlinksIfPossible = isUseHardLinks,
+                    UseSymboliclinksIfPossible = isUseSymbolicLinks,
                     ErrorIfLinkFails = true,
                     BuildEngine = engine,
                     SourceFiles = new ITaskItem[] { new TaskItem(source) },
@@ -2104,248 +2154,6 @@ internal virtual void ErrorIfLinkFailedCheck()
             }
         }
 
-        /// <summary>
-        /// Helper functor for retry tests.
-        /// Simulates the File.Copy method without touching the disk.
-        /// First copy fails as requested, subsequent copies succeed.
-        /// </summary>
-        private sealed class CopyFunctor
-        {
-            /// <summary>
-            /// Protects the counts and lists below.
-            /// </summary>
-            private readonly object _lockObj = new object();
-
-            /// <summary>
-            /// On what attempt count should we stop failing?
-            /// </summary>
-            private readonly int _countOfSuccess;
-
-            /// <summary>
-            /// Should we throw when we fail, instead of just returning false?
-            /// </summary>
-            private readonly bool _throwOnFailure;
-
-            /// <summary>
-            /// How many tries have we done so far
-            /// </summary>
-            private int _tries;
-
-            /// <summary>
-            /// Which files we actually copied
-            /// </summary>
-            internal List<FileState> FilesCopiedSuccessfully { get; } = new List<FileState>();
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
-            {
-                _countOfSuccess = countOfSuccess;
-                _throwOnFailure = throwOnFailure;
-            }
-
-            /// <summary>
-            /// Pretend to be File.Copy.
-            /// </summary>
-            internal bool? Copy(FileState source, FileState destination)
-            {
-                lock (_lockObj)
-                {
-                    _tries++;
-
-                    // 2nd and subsequent copies always succeed
-                    if (FilesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
-                    {
-                        Console.WriteLine("Copied {0} to {1} OK", source, destination);
-                        FilesCopiedSuccessfully.Add(source);
-                        return true;
-                    }
-                }
-
-                if (_throwOnFailure)
-                {
-                    throw new IOException("oops");
-                }
-
-                return null;
-            }
-        }
-    }
-
-    public class CopySingleThreaded_Tests : Copy_Tests
-    {
-        public CopySingleThreaded_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseSingleThreadedCopy = true;
-        }
-    }
-
-    public class CopyNotHardLink_Tests : Copy_Tests
-    {
-        public CopyNotHardLink_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseHardLinks = false;
-        }
-    }
-
-    public class CopyHardAndSymbolicLink_Tests
-    {
-        /// <summary>
-        /// Verify build sucessfully when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true 
-        /// </summary>
-        [Fact]
-        public void CopyWithHardAndSymbolicLinks()
-        {
-            string sourceFile = FileUtilities.GetTemporaryFile();
-            string temp = Path.GetTempPath();
-            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
-            string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
-
-            try
-            {
-                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
-
-                MockEngine me = new MockEngine(true);
-                Copy t = new Copy
-                {
-                    RetryDelayMilliseconds = 1, // speed up tests!
-                    UseHardlinksIfPossible = true,
-                    UseSymboliclinksIfPossible = true,
-                    BuildEngine = me,
-                    SourceFiles = sourceFiles,
-                    DestinationFolder = new TaskItem(destFolder),
-                    SkipUnchangedFiles = true
-                };
-
-                bool success = t.Execute();
-
-                Assert.True(success);
-                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
-                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
-            }
-            finally
-            {
-                Helpers.DeleteFiles(sourceFile, destFile);
-            }
-        }
-
-        /// <summary>
-        /// Verifies that we error when ErrorIfLinkFailed is true when UseHardlinksIfPossible
-        /// and UseSymboliclinksIfPossible are false.
-        /// </summary>
-        [Fact]
-        public void InvalidErrorIfLinkFailed()
-        {
-            var engine = new MockEngine(true);
-            var t = new Copy
-            {
-                BuildEngine = engine,
-                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
-                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
-                UseHardlinksIfPossible = false,
-                UseSymboliclinksIfPossible = false,
-                ErrorIfLinkFails = true,
-            };
-
-            bool result = t.Execute();
-
-            Assert.False(result);
-            engine.AssertLogContains("MSB3892");
-        }
-
-        /// <summary>
-        /// An existing link source should not be modified.
-        /// </summary>
-        /// <remarks>
-        /// Related to issue [#8273](https://github.com/dotnet/msbuild/issues/8273)
-        /// </remarks>
-        [Theory]
-        [InlineData(false, false)]
-        [InlineData(false, true)]
-        [InlineData(true, false)]
-        public void DoNotCorruptSourceOfLink(bool useHardLink, bool useSymbolicLink)
-        {
-            string sourceFile1 = FileUtilities.GetTemporaryFile();
-            string sourceFile2 = FileUtilities.GetTemporaryFile();
-            string temp = Path.GetTempPath();
-            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
-            string destFile = Path.Combine(destFolder, "The Destination");
-
-            try
-            {
-                File.WriteAllText(sourceFile1, "This is the first source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
-                File.WriteAllText(sourceFile2, "This is the second source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
-
-                // Don't create the dest folder, let task do that
-
-                ITaskItem[] sourceFiles = { new TaskItem(sourceFile1) };
-                ITaskItem[] destinationFiles = { new TaskItem(destFile) };
-
-                var me = new MockEngine(true);
-                var t = new Copy
-                {
-                    RetryDelayMilliseconds = 1, // speed up tests!
-                    BuildEngine = me,
-                    SourceFiles = sourceFiles,
-                    DestinationFiles = destinationFiles,
-                    SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = useHardLink,
-                    UseSymboliclinksIfPossible = useSymbolicLink,
-                };
-
-                bool success = t.Execute();
-
-                Assert.True(success); // "success"
-                Assert.True(File.Exists(destFile)); // "destination exists"
-
-                string destinationFileContents = File.ReadAllText(destFile);
-                Assert.Equal("This is the first source temp file.", destinationFileContents);
-
-                sourceFiles = new TaskItem[] { new TaskItem(sourceFile2) };
-
-                t = new Copy
-                {
-                    RetryDelayMilliseconds = 1, // speed up tests!
-                    BuildEngine = me,
-                    SourceFiles = sourceFiles,
-                    DestinationFiles = destinationFiles,
-                    SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = false,
-                    UseSymboliclinksIfPossible = false,
-                };
-
-                success = t.Execute();
-
-                Assert.True(success); // "success"
-                Assert.True(File.Exists(destFile)); // "destination exists"
-
-                destinationFileContents = File.ReadAllText(destFile);
-                Assert.Equal("This is the second source temp file.", destinationFileContents);
-
-                // Read the source file (it should not have been overwritten)
-                string sourceFileContents = File.ReadAllText(sourceFile1);
-                Assert.Equal("This is the first source temp file.", sourceFileContents);
-
-                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
-            }
-            finally
-            {
-                Helpers.DeleteFiles(sourceFile1, sourceFile2, destFile);
-            }
-        }
-    }
-
-    public class CopyHardLink_Tests : Copy_Tests
-    {
-        public CopyHardLink_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseHardLinks = true;
-        }
-
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
@@ -2602,21 +2410,6 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
             }
         }
 
-        [WindowsOnlyFact]
-        internal override void ErrorIfLinkFailedCheck()
-        {
-            base.ErrorIfLinkFailedCheck();
-        }
-    }
-
-    public class CopySymbolicLink_Tests : Copy_Tests
-    {
-        public CopySymbolicLink_Tests(ITestOutputHelper testOutputHelper)
-            : base(testOutputHelper)
-        {
-            UseSymbolicLinks = true;
-        }
-
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
@@ -2683,10 +2476,225 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
             }
         }
 
-        [WindowsOnlyFact]
-        internal override void ErrorIfLinkFailedCheck()
+        /// <summary>
+        /// Verify build successful when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true
+        /// </summary>
+        [Fact]
+        public void CopyWithHardAndSymbolicLinks()
         {
-            base.ErrorIfLinkFailedCheck();
+            string sourceFile = FileUtilities.GetTemporaryFile();
+            string temp = Path.GetTempPath();
+            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
+            string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
+
+            try
+            {
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+
+                MockEngine me = new MockEngine(true);
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1, // speed up tests!
+                    UseHardlinksIfPossible = true,
+                    UseSymboliclinksIfPossible = true,
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true
+                };
+
+                bool success = t.Execute();
+
+                Assert.True(success);
+                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
+                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
+            }
+            finally
+            {
+                Helpers.DeleteFiles(sourceFile, destFile);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error when ErrorIfLinkFailed is true when UseHardlinksIfPossible
+        /// and UseSymboliclinksIfPossible are false.
+        /// </summary>
+        [Fact]
+        public void InvalidErrorIfLinkFailed()
+        {
+            var engine = new MockEngine(true);
+            var t = new Copy
+            {
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                UseHardlinksIfPossible = false,
+                UseSymboliclinksIfPossible = false,
+                ErrorIfLinkFails = true,
+            };
+
+            bool result = t.Execute();
+
+            Assert.False(result);
+            engine.AssertLogContains("MSB3892");
+        }
+
+        /// <summary>
+        /// An existing link source should not be modified.
+        /// </summary>
+        /// <remarks>
+        /// Related to issue [#8273](https://github.com/dotnet/msbuild/issues/8273)
+        /// </remarks>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void DoNotCorruptSourceOfLink(bool useHardLink, bool useSymbolicLink)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile sourceFile1 = env.CreateFile("source1.tmp", "This is the first source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+            TransientTestFile sourceFile2 = env.CreateFile("source2.tmp", "This is the second source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+            TransientTestFolder destFolder = env.CreateFolder(createFolder: false);
+            string destFile = Path.Combine(destFolder.Path, "The Destination");
+
+            // Don't create the dest folder, let task do that
+            ITaskItem[] sourceFiles = { new TaskItem(sourceFile1.Path) };
+            ITaskItem[] destinationFiles = { new TaskItem(destFile) };
+
+            var me = new MockEngine(true);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = me,
+                SourceFiles = sourceFiles,
+                DestinationFiles = destinationFiles,
+                SkipUnchangedFiles = true,
+                UseHardlinksIfPossible = useHardLink,
+                UseSymboliclinksIfPossible = useSymbolicLink,
+            };
+
+            t.Execute().ShouldBeTrue();
+            File.Exists(destFile).ShouldBeTrue();
+            File.ReadAllText(destFile).ShouldBe("This is the first source temp file.");
+
+            sourceFiles = new TaskItem[] { new TaskItem(sourceFile2.Path) };
+
+            t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = me,
+                SourceFiles = sourceFiles,
+                DestinationFiles = destinationFiles,
+                SkipUnchangedFiles = true,
+                UseHardlinksIfPossible = false,
+                UseSymboliclinksIfPossible = false,
+            };
+
+            t.Execute().ShouldBeTrue();
+            File.Exists(destFile).ShouldBeTrue();
+            File.ReadAllText(destFile).ShouldBe("This is the second source temp file.");
+
+            // Read the source file (it should not have been overwritten)
+            File.ReadAllText(sourceFile1.Path).ShouldBe("This is the first source temp file.");
+            ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+
+            destinationFiles = new TaskItem[] { new TaskItem(
+                Path.Combine(Path.GetDirectoryName(sourceFile2.Path), ".", Path.GetFileName(sourceFile2.Path))) // sourceFile2.Path with a "." inserted before the file name
+            };
+
+            t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = me,
+                SourceFiles = sourceFiles,
+                DestinationFiles = destinationFiles,
+                SkipUnchangedFiles = true,
+            };
+
+            t.Execute().ShouldBeTrue();
+            File.Exists(sourceFile2.Path).ShouldBeTrue();
+        }
+
+        internal sealed class CopyMonitor
+        {
+            internal int copyCount;
+
+            /*
+            * Method:   CopyFile
+            *
+            * Don't really copy the file, just count how many times this was called.
+            */
+            internal bool? CopyFile(FileState source, FileState destination)
+            {
+                Interlocked.Increment(ref copyCount);
+                return true;
+            }
+        }
+
+        /// <summary>
+        /// Helper functor for retry tests.
+        /// Simulates the File.Copy method without touching the disk.
+        /// First copy fails as requested, subsequent copies succeed.
+        /// </summary>
+        private sealed class CopyFunctor
+        {
+            /// <summary>
+            /// Protects the counts and lists below.
+            /// </summary>
+            private readonly object _lockObj = new object();
+
+            /// <summary>
+            /// On what attempt count should we stop failing?
+            /// </summary>
+            private readonly int _countOfSuccess;
+
+            /// <summary>
+            /// Should we throw when we fail, instead of just returning false?
+            /// </summary>
+            private readonly bool _throwOnFailure;
+
+            /// <summary>
+            /// How many tries have we done so far
+            /// </summary>
+            private int _tries;
+
+            /// <summary>
+            /// Which files we actually copied
+            /// </summary>
+            internal List<FileState> FilesCopiedSuccessfully { get; } = new List<FileState>();
+
+            /// <summary>
+            /// Constructor
+            /// </summary>
+            internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
+            {
+                _countOfSuccess = countOfSuccess;
+                _throwOnFailure = throwOnFailure;
+            }
+
+            /// <summary>
+            /// Pretend to be File.Copy.
+            /// </summary>
+            internal bool? Copy(FileState source, FileState destination)
+            {
+                lock (_lockObj)
+                {
+                    _tries++;
+
+                    // 2nd and subsequent copies always succeed
+                    if (FilesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
+                    {
+                        Console.WriteLine("Copied {0} to {1} OK", source, destination);
+                        FilesCopiedSuccessfully.Add(source);
+                        return true;
+                    }
+                }
+
+                if (_throwOnFailure)
+                {
+                    throw new IOException("oops");
+                }
+
+                return null;
+            }
         }
     }
 }
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index 800a3d7cb1a..599a5750961 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -78,6 +78,7 @@ private bool ResolveHintPath(string hintPath)
                 sdkName: "",
                 rawFileNameCandidate: "FakeSystem.Net.Http",
                 isPrimaryProjectReference: true,
+                isImmutableFrameworkReference: false,
                 wantSpecificVersion: false,
                 executableExtensions: new string[] { ".winmd", ".dll", ".exe" },
                 hintPath: hintPath,
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 473207bfe6f..a69b7fa2ea3 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -15,10 +15,7 @@
   </ItemGroup>
 
   <ItemGroup>
-    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
-
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
@@ -30,9 +27,11 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <PackageReference Include="System.Security.Principal.Windows" />
     <Reference Include="System" />
     <Reference Include="System.Core" />
     <Reference Include="System.IO.Compression" />
+    <Reference Include="System.Net.Http" />
     <Reference Include="System.Xaml" />
     <Reference Include="System.Xml" />
     <Reference Include="PresentationFramework" Condition="$([MSBuild]::IsOSPlatform('windows'))" />
@@ -76,10 +75,10 @@
     </None>
   </ItemGroup>
 
-  <ItemGroup> 
-    <Content Include="TestDocuments\**"> 
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> 
-    </Content> 
+  <ItemGroup>
+    <Content Include="TestDocuments\**">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
index 062eab76b12..d3c94688e18 100644
--- a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
+++ b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
@@ -21,14 +21,18 @@ public void TestPrecomputedCacheOutput()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
+                DateTime now = DateTime.Now;
                 TransientTestFile standardCache = env.CreateFile(".cache");
                 ResolveAssemblyReference t = new ResolveAssemblyReference()
                 {
                     _cache = new SystemState()
                 };
                 t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
-                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
-                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t._cache.SetGetLastWriteTime(_ => now);
+                _ = t._cache.GetFileState("assembly1");
+                _ = t._cache.GetFileState("assembly2");
                 t._cache.IsDirty = true;
                 t.StateFile = standardCache.Path;
                 t.WriteStateFile();
@@ -52,13 +56,18 @@ public void StandardCacheTakesPrecedence()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
+                DateTime now = DateTime.Now;
                 TransientTestFile standardCache = env.CreateFile(".cache");
                 ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
                 {
                     _cache = new SystemState()
                 };
-                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>();
+                rarWriterTask._cache.instanceLocalFileStateCache = new() {
+                    { "path1", new SystemState.FileState(now) },
+                };
+                rarWriterTask._cache.SetGetLastWriteTime(_ => now);
                 rarWriterTask.StateFile = standardCache.Path;
+                _ = rarWriterTask._cache.GetFileState("path1");
                 rarWriterTask._cache.IsDirty = true;
                 // Write standard cache
                 rarWriterTask.WriteStateFile();
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 8f40034025d..2bce4b5064f 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -74,7 +74,7 @@ public void TestSerializationAndDeserialization()
             {
                 TransientTestFile file = env.CreateFile();
                 cache.SerializeCache(file.Path, null);
-                cache2 = StateFileBase.DeserializeCache(file.Path, null, typeof(ResolveComReferenceCache)) as ResolveComReferenceCache;
+                cache2 = StateFileBase.DeserializeCache<ResolveComReferenceCache>(file.Path, null);
             }
 
             cache2.tlbImpLocation.ShouldBe(cache.tlbImpLocation);
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 10a4e43738a..e449c1e8dea 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -68,12 +68,10 @@ public sealed class XslTransformation_Tests
         private readonly string _xslDocument = "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\" exclude-result-prefixes=\"msxsl\"><xsl:output method=\"xml\" indent=\"yes\"/><xsl:template match=\"@* | node()\"><surround><xsl:copy><xsl:apply-templates select=\"@* | node()\"/></xsl:copy></surround></xsl:template></xsl:stylesheet>";
 
 
-#if FEATURE_COMPILED_XSL
         /// <summary>
         /// The contents of another xsl document for tests
         /// </summary>
         private readonly string _xslDocument2 = "<?xml version = \"1.0\" ?><xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"><xsl:template match = \"myInclude\"><xsl:apply-templates select = \"document(@path)\"/></xsl:template><xsl:template match = \"@*|node()\"><xsl:copy><xsl:apply-templates select = \"@*|node()\"/></xsl:copy></xsl:template></xsl:stylesheet>";
-#endif
         /// <summary>
         /// The contents of xslparameters for tests.
         /// </summary>
@@ -1040,7 +1038,6 @@ public void MultipleXmlInputs_NotMatching()
             CleanUp(dir);
         }
 
-#if FEATURE_COMPILED_XSL
         /// <summary>
         /// Validate that the XslTransformation task allows use of the document function
         /// </summary>
@@ -1094,7 +1091,6 @@ public void XslDocumentFunctionWorks()
 
             CleanUp(dir);
         }
-#endif
 
         /// <summary>
         /// Prepares the test environment, creates necessary files.
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 018a2ee5932..bc250b945f3 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
 using System.Xml;
 
 using Microsoft.Build.Shared;
@@ -24,13 +25,16 @@ internal void Load(string appConfigFile)
             XmlReader reader = null;
             try
             {
-                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true};
 
                 // it's important to normalize the path as it may contain two slashes
                 // see https://github.com/dotnet/msbuild/issues/4335 for details.
                 appConfigFile = FileUtilities.NormalizePath(appConfigFile);
 
-                reader = XmlReader.Create(appConfigFile, readerSettings);
+                // Need a filestream as the XmlReader doesn't support nonstandard unicode characters in path.
+                // No need to dispose - as 'CloseInput' was passed to XmlReaderSettings
+                FileStream fs = File.OpenRead(appConfigFile);
+                reader = XmlReader.Create(fs, readerSettings);
                 Read(reader);
             }
             catch (XmlException e)
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index 7aabd28ea93..51df4d81cad 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -183,26 +183,13 @@ private void LazyInitialize()
             }
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName">The sdkname of the reference.</param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index 00fbece8e58..2268765cfbf 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -151,26 +151,13 @@ private void LazyInitialize()
             }
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName">Not used by this type.</param>
-        /// <param name="rawFileNameCandidate">Not used by this type.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">Not used by this type.</param>
-        /// <param name="assemblyFolderKey">Not used by this type.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 998e8abf552..9d1d89e75ab 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -27,26 +27,13 @@ public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAsse
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName">The sdk name of the reference.</param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index a77c9b03360..2a247374d79 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -866,216 +866,216 @@ private class HeaderInfo
         }
 
         /// <summary>
-        /// Given a path get the CLR runtime version of the file
+        /// Given a path get the CLR runtime version of the file.
         /// </summary>
         /// <param name="path">path to the file</param>
         /// <returns>The CLR runtime version or empty if the path does not exist or the file is not an assembly.</returns>
         public static string GetRuntimeVersion(string path)
         {
-            using (var sr = new BinaryReader(File.OpenRead(path)))
+            if (!FileSystems.Default.FileExists(path))
             {
-                if (!FileSystems.Default.FileExists(path))
-                {
-                    return string.Empty;
-                }
-
-                // This algorithm for getting the runtime version is based on
-                // the ECMA Standard 335: The Common Language Infrastructure (CLI)
-                // http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf
+                return string.Empty;
+            }
 
-                try
-                {
-                    const uint PEHeaderPointerOffset = 0x3c;
-                    const uint PEHeaderSize = 20;
-                    const uint OptionalPEHeaderSize = 224;
-                    const uint OptionalPEPlusHeaderSize = 240;
-                    const uint SectionHeaderSize = 40;
+            using Stream stream = File.OpenRead(path);
+            using BinaryReader reader = new BinaryReader(stream);
+            return GetRuntimeVersion(reader);
+        }
 
-                    // The PE file format is specified in section II.25
+        /// <summary>
+        /// Given a <see cref="BinaryReader"/> get the CLR runtime version of the underlying file.
+        /// </summary>
+        /// <param name="sr">A <see cref="BinaryReader"/> positioned at the first byte of the file.</param>
+        /// <returns>The CLR runtime version or empty if the data does not represent an assembly.</returns>
+        internal static string GetRuntimeVersion(BinaryReader sr)
+        {
+            // This algorithm for getting the runtime version is based on
+            // the ECMA Standard 335: The Common Language Infrastructure (CLI)
+            // http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf
 
-                    // A PE image starts with an MS-DOS header followed by a PE signature, followed by the PE file header,
-                    // and then the PE optional header followed by PE section headers.
-                    // There must be room for all of that.
+            try
+            {
+                const uint PEHeaderPointerOffset = 0x3c;
+                const uint PEHeaderSize = 20;
+                const uint OptionalPEHeaderSize = 224;
+                const uint OptionalPEPlusHeaderSize = 240;
+                const uint SectionHeaderSize = 40;
 
-                    if (sr.BaseStream.Length < PEHeaderPointerOffset + 4 + PEHeaderSize + OptionalPEHeaderSize +
-                        SectionHeaderSize)
-                    {
-                        return string.Empty;
-                    }
+                // The PE file format is specified in section II.25
 
-                    // The PE format starts with an MS-DOS stub of 128 bytes.
-                    // At offset 0x3c in the DOS header is a 4-byte unsigned integer offset to the PE
-                    // signature (shall be “PE\0\0”), immediately followed by the PE file header
+                // A PE image starts with an MS-DOS header followed by a PE signature, followed by the PE file header,
+                // and then the PE optional header followed by PE section headers.
+                // There must be room for all of that.
 
-                    sr.BaseStream.Position = PEHeaderPointerOffset;
-                    var peHeaderOffset = sr.ReadUInt32();
+                if (sr.BaseStream.Length < PEHeaderPointerOffset + 4 + PEHeaderSize + OptionalPEHeaderSize +
+                    SectionHeaderSize)
+                {
+                    return string.Empty;
+                }
 
-                    if (peHeaderOffset + 4 + PEHeaderSize + OptionalPEHeaderSize + SectionHeaderSize >=
-                        sr.BaseStream.Length)
-                    {
-                        return string.Empty;
-                    }
+                // The PE format starts with an MS-DOS stub of 128 bytes.
+                // At offset 0x3c in the DOS header is a 4-byte unsigned integer offset to the PE
+                // signature (shall be “PE\0\0”), immediately followed by the PE file header
 
-                    // The PE header is specified in section II.25.2
-                    // Read the PE header signature
+                sr.BaseStream.Position = PEHeaderPointerOffset;
+                var peHeaderOffset = sr.ReadUInt32();
 
-                    sr.BaseStream.Position = peHeaderOffset;
-                    if (!ReadBytes(sr, (byte)'P', (byte)'E', 0, 0))
-                    {
-                        return string.Empty;
-                    }
+                if (peHeaderOffset + 4 + PEHeaderSize + OptionalPEHeaderSize + SectionHeaderSize >=
+                    sr.BaseStream.Length)
+                {
+                    return string.Empty;
+                }
 
-                    // The PE header immediately follows the signature
-                    var peHeaderBase = peHeaderOffset + 4;
+                // The PE header is specified in section II.25.2
+                // Read the PE header signature
 
-                    // At offset 2 of the PE header there is the number of sections
-                    sr.BaseStream.Position = peHeaderBase + 2;
-                    var numberOfSections = sr.ReadUInt16();
-                    if (numberOfSections > 96)
-                    {
-                        return string.Empty; // There can't be more than 96 sections, something is wrong
-                    }
+                sr.BaseStream.Position = peHeaderOffset;
+                if (!ReadBytes(sr, (byte)'P', (byte)'E', 0, 0))
+                {
+                    return string.Empty;
+                }
 
-                    // Immediately after the PE Header is the PE Optional Header.
-                    // This header is optional in the general PE spec, but always
-                    // present in assembly files.
-                    // From this header we'll get the CLI header RVA, which is
-                    // at offset 208 for PE32, and at offset 224 for PE32+
+                // The PE header immediately follows the signature
+                var peHeaderBase = peHeaderOffset + 4;
 
-                    var optionalHeaderOffset = peHeaderBase + PEHeaderSize;
+                // At offset 2 of the PE header there is the number of sections
+                sr.BaseStream.Position = peHeaderBase + 2;
+                var numberOfSections = sr.ReadUInt16();
+                if (numberOfSections > 96)
+                {
+                    return string.Empty; // There can't be more than 96 sections, something is wrong
+                }
 
-                    uint cliHeaderRvaOffset;
-                    uint optionalPEHeaderSize;
+                // Immediately after the PE Header is the PE Optional Header.
+                // This header is optional in the general PE spec, but always
+                // present in assembly files.
+                // From this header we'll get the CLI header RVA, which is
+                // at offset 208 for PE32, and at offset 224 for PE32+
 
-                    sr.BaseStream.Position = optionalHeaderOffset;
-                    var magicNumber = sr.ReadUInt16();
+                var optionalHeaderOffset = peHeaderBase + PEHeaderSize;
 
-                    if (magicNumber == 0x10b) // PE32
-                    {
-                        optionalPEHeaderSize = OptionalPEHeaderSize;
-                        cliHeaderRvaOffset = optionalHeaderOffset + 208;
-                    }
-                    else if (magicNumber == 0x20b) // PE32+
-                    {
-                        optionalPEHeaderSize = OptionalPEPlusHeaderSize;
-                        cliHeaderRvaOffset = optionalHeaderOffset + 224;
-                    }
-                    else
-                    {
-                        return string.Empty;
-                    }
+                uint cliHeaderRvaOffset;
+                uint optionalPEHeaderSize;
 
-                    // Read the CLI header RVA
+                sr.BaseStream.Position = optionalHeaderOffset;
+                var magicNumber = sr.ReadUInt16();
 
-                    sr.BaseStream.Position = cliHeaderRvaOffset;
-                    var cliHeaderRva = sr.ReadUInt32();
-                    if (cliHeaderRva == 0)
-                    {
-                        return string.Empty; // No CLI section
-                    }
+                if (magicNumber == 0x10b) // PE32
+                {
+                    optionalPEHeaderSize = OptionalPEHeaderSize;
+                    cliHeaderRvaOffset = optionalHeaderOffset + 208;
+                }
+                else if (magicNumber == 0x20b) // PE32+
+                {
+                    optionalPEHeaderSize = OptionalPEPlusHeaderSize;
+                    cliHeaderRvaOffset = optionalHeaderOffset + 224;
+                }
+                else
+                {
+                    return string.Empty;
+                }
 
-                    // Immediately following the optional header is the Section
-                    // Table, which contains a number of section headers.
-                    // Section headers are specified in section II.25.3
+                // Read the CLI header RVA
 
-                    // Each section header has the base RVA, size, and file
-                    // offset of the section. To find the file offset of the
-                    // CLI header we need to find a section that contains
-                    // its RVA, and the calculate the file offset using
-                    // the base file offset of the section.
+                sr.BaseStream.Position = cliHeaderRvaOffset;
+                var cliHeaderRva = sr.ReadUInt32();
+                if (cliHeaderRva == 0)
+                {
+                    return string.Empty; // No CLI section
+                }
 
-                    var sectionOffset = optionalHeaderOffset + optionalPEHeaderSize;
+                // Immediately following the optional header is the Section
+                // Table, which contains a number of section headers.
+                // Section headers are specified in section II.25.3
 
-                    // Read all section headers, we need them to make RVA to
-                    // offset conversions.
+                // Each section header has the base RVA, size, and file
+                // offset of the section. To find the file offset of the
+                // CLI header we need to find a section that contains
+                // its RVA, and the calculate the file offset using
+                // the base file offset of the section.
 
-                    var sections = new HeaderInfo[numberOfSections];
-                    for (int n = 0; n < numberOfSections; n++)
-                    {
-                        // At offset 8 of the section is the section size
-                        // and base RVA. At offset 20 there is the file offset
-                        sr.BaseStream.Position = sectionOffset + 8;
-                        var sectionSize = sr.ReadUInt32();
-                        var sectionRva = sr.ReadUInt32();
-                        sr.BaseStream.Position = sectionOffset + 20;
-                        var sectionDataOffset = sr.ReadUInt32();
-                        sections[n] = new HeaderInfo
-                        {
-                            VirtualAddress = sectionRva,
-                            Size = sectionSize,
-                            FileOffset = sectionDataOffset
-                        };
-                        sectionOffset += SectionHeaderSize;
-                    }
+                var sectionOffset = optionalHeaderOffset + optionalPEHeaderSize;
 
-                    uint cliHeaderOffset = RvaToOffset(sections, cliHeaderRva);
+                // Read all section headers, we need them to make RVA to
+                // offset conversions.
 
-                    // CLI section not found
-                    if (cliHeaderOffset == 0)
+                var sections = new HeaderInfo[numberOfSections];
+                for (int n = 0; n < numberOfSections; n++)
+                {
+                    // At offset 8 of the section is the section size
+                    // and base RVA. At offset 20 there is the file offset
+                    sr.BaseStream.Position = sectionOffset + 8;
+                    var sectionSize = sr.ReadUInt32();
+                    var sectionRva = sr.ReadUInt32();
+                    sr.BaseStream.Position = sectionOffset + 20;
+                    var sectionDataOffset = sr.ReadUInt32();
+                    sections[n] = new HeaderInfo
                     {
-                        return string.Empty;
-                    }
-
-                    // The CLI header is specified in section II.25.3.3.
-                    // It contains all of the runtime-specific data entries and other information.
-                    // From the CLI header we need to get the RVA of the metadata root,
-                    // which is located at offset 8.
-
-                    sr.BaseStream.Position = cliHeaderOffset + 8;
-                    var metadataRva = sr.ReadUInt32();
+                        VirtualAddress = sectionRva,
+                        Size = sectionSize,
+                        FileOffset = sectionDataOffset
+                    };
+                    sectionOffset += SectionHeaderSize;
+                }
 
-                    var metadataOffset = RvaToOffset(sections, metadataRva);
-                    if (metadataOffset == 0)
-                    {
-                        return string.Empty;
-                    }
+                uint cliHeaderOffset = RvaToOffset(sections, cliHeaderRva);
 
-                    // The metadata root is specified in section II.24.2.1
-                    // The first 4 bytes contain a signature.
-                    // The version string is at offset 12.
+                // CLI section not found
+                if (cliHeaderOffset == 0)
+                {
+                    return string.Empty;
+                }
 
-                    sr.BaseStream.Position = metadataOffset;
-                    if (!ReadBytes(sr, 0x42, 0x53, 0x4a, 0x42)) // Metadata root signature
-                    {
-                        return string.Empty;
-                    }
+                // The CLI header is specified in section II.25.3.3.
+                // It contains all of the runtime-specific data entries and other information.
+                // From the CLI header we need to get the RVA of the metadata root,
+                // which is located at offset 8.
 
-                    // Read the version string length
-                    sr.BaseStream.Position = metadataOffset + 12;
-                    var length = sr.ReadInt32();
-                    if (length > 255 || length <= 0 || sr.BaseStream.Position + length >= sr.BaseStream.Length)
-                    {
-                        return string.Empty;
-                    }
+                sr.BaseStream.Position = cliHeaderOffset + 8;
+                var metadataRva = sr.ReadUInt32();
 
-                    // Read the version string
-                    var v = Encoding.UTF8.GetString(sr.ReadBytes(length));
-                    if (v.Length < 2 || v[0] != 'v')
-                    {
-                        return string.Empty;
-                    }
+                var metadataOffset = RvaToOffset(sections, metadataRva);
+                if (metadataOffset == 0)
+                {
+                    return string.Empty;
+                }
 
-                    // Per II.24.2.1, version string length is rounded up
-                    // to a multiple of 4. So we may read eg "4.0.30319\0\0"
-                    // Version.Parse works fine, but it's not pretty in the log.
-                    int firstNull = v.IndexOf('\0');
-                    if (firstNull > 0)
-                    {
-                        v = v.Substring(0, firstNull);
-                    }
+                // The metadata root is specified in section II.24.2.1
+                // The first 4 bytes contain a signature.
+                // The version string is at offset 12.
 
-                    // Make sure it is a version number
-                    if (!Version.TryParse(v.Substring(1), out _))
-                    {
-                        return string.Empty;
-                    }
-                    return v;
+                sr.BaseStream.Position = metadataOffset;
+                if (!ReadBytes(sr, 0x42, 0x53, 0x4a, 0x42)) // Metadata root signature
+                {
+                    return string.Empty;
                 }
-                catch
+
+                // Read the version string length
+                sr.BaseStream.Position = metadataOffset + 12;
+                var length = sr.ReadInt32();
+                if (length > 255 || length <= 0 || sr.BaseStream.Position + length >= sr.BaseStream.Length)
                 {
-                    // Something went wrong in spite of all checks. Corrupt file?
                     return string.Empty;
                 }
+
+                // Read the version string
+                var v = Encoding.UTF8.GetString(sr.ReadBytes(length));
+
+                // Per II.24.2.1, version string length is rounded up
+                // to a multiple of 4. So we may read eg "4.0.30319\0\0"
+                // Version.Parse works fine, but it's not pretty in the log.
+                int firstNull = v.IndexOf('\0');
+                if (firstNull > 0)
+                {
+                    v = v.Substring(0, firstNull);
+                }
+
+                return v;
+            }
+            catch
+            {
+                // Something went wrong in spite of all checks. Corrupt file?
+                return string.Empty;
             }
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
index 91f87bd654e..818a00a7fe4 100644
--- a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
@@ -19,7 +19,7 @@ internal struct AssemblyNameReference : IComparable<AssemblyNameReference>
         /// <summary>
         /// Display as string.
         /// </summary>
-        public override string ToString()
+        public override readonly string ToString()
         {
             return assemblyName + ", " + reference;
         }
@@ -27,7 +27,7 @@ public override string ToString()
         /// <summary>
         /// Compare by assembly name.
         /// </summary>
-        public int CompareTo(AssemblyNameReference other)
+        public readonly int CompareTo(AssemblyNameReference other)
         {
             return assemblyName.CompareTo(other.assemblyName);
         }
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index 2653a30a416..0d6ba23d997 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -34,6 +34,7 @@ internal static class AssemblyResolution
         /// <param name="sdkName"></param>
         /// <param name="rawFileNameCandidate">The file name to match if {RawFileName} is seen. (May be null).</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
+        /// <param name="isImmutableFrameworkReference">True if <paramref name="rawFileNameCandidate"/> is immutable and guaranteed to exist.</param>
         /// <param name="wantSpecificVersion"></param>
         /// <param name="executableExtensions">The filename extension of the assembly. Must be this or its no match.</param>
         /// <param name="hintPath">This reference's hintpath</param>
@@ -48,6 +49,7 @@ internal static string ResolveReference(
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
@@ -79,6 +81,7 @@ internal static string ResolveReference(
                             sdkName,
                             rawFileNameCandidate,
                             isPrimaryProjectReference,
+                            isImmutableFrameworkReference,
                             wantSpecificVersion,
                             executableExtensions,
                             hintPath,
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 352b3e463a3..328bb6984a2 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -36,26 +36,13 @@ public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string se
             _candidateAssemblyFiles = candidateAssemblyFiles;
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/DirectoryResolver.cs b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
index be0fe39554d..fedf7c18e38 100644
--- a/src/Tasks/AssemblyDependency/DirectoryResolver.cs
+++ b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
@@ -22,26 +22,13 @@ public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyNa
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index d51805918d3..cd57aa7d6b5 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -30,26 +30,13 @@ public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies instal
             _installedAssemblies = installedAssemblies;
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index ac47511c1dc..bf416cc56ed 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -35,26 +35,13 @@ public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchit
             _getAssemblyPathInGac = getAssemblyPathInGac;
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assembly name object of the assembly.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/HintPathResolver.cs b/src/Tasks/AssemblyDependency/HintPathResolver.cs
index 1ae57169ce7..96a3b920491 100644
--- a/src/Tasks/AssemblyDependency/HintPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/HintPathResolver.cs
@@ -23,26 +23,13 @@ public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyNam
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
index 5273445e3f8..72f1afb79a2 100644
--- a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
+++ b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
@@ -23,26 +23,13 @@ public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssembly
         {
         }
 
-        /// <summary>
-        /// Resolve a reference to a specific file name.
-        /// </summary>
-        /// <param name="assemblyName">The assemblyname of the reference.</param>
-        /// <param name="sdkName"></param>
-        /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
-        /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
-        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
-        /// <param name="executableExtensions">Allowed executable extensions.</param>
-        /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
-        /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
-        /// <param name="foundPath">The path where the file was found.</param>
-        /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
-        /// <returns>True if the file was resolved.</returns>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
@@ -57,7 +44,7 @@ public override bool Resolve(
             if (rawFileNameCandidate != null)
             {
                 // {RawFileName} was passed in.
-                if (fileExists(rawFileNameCandidate))
+                if (isImmutableFrameworkReference || fileExists(rawFileNameCandidate))
                 {
                     userRequestedSpecificFile = true;
                     foundPath = rawFileNameCandidate;
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index f25e796f1a7..5819184dc59 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -226,7 +226,7 @@ internal void AddDependee(Reference dependee)
         }
 
         /// <summary>
-        /// A dependee may be removed because it or its dependee's are in the black list
+        /// A dependee may be removed because it or its dependee's are in the deny list
         /// </summary>
         internal void RemoveDependee(Reference dependeeToRemove)
         {
@@ -234,7 +234,7 @@ internal void RemoveDependee(Reference dependeeToRemove)
         }
 
         /// <summary>
-        /// A dependency may be removed because it may not be referenced any more due this reference being in the black list or being removed due to it depending on something in the black list
+        /// A dependency may be removed because it may not be referenced any more due this reference being in the deny list or being removed due to it depending on something in the deny list
         /// </summary>
         internal void RemoveDependency(Reference dependencyToRemove)
         {
@@ -1140,7 +1140,7 @@ public override string ToString()
 
         /// <summary>
         /// There are a number of properties which are set when we generate exclusion lists and it is useful to have this information on the references so that
-        /// the correct reasons can be logged for these references being in the black list.
+        /// the correct reasons can be logged for these references being in the deny list.
         /// </summary>
         internal class ExclusionListProperties
         {
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 4272a5e149e..41cdfe24dd6 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -40,6 +40,11 @@ internal sealed class ReferenceTable
         /// </summary>
         private readonly HashSet<string> _externallyResolvedPrimaryReferences = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
+        /// <summary>
+        /// The keys are normalized full paths of primary references resolved by an external entity to RAR and considered immutable, the values are assembly names or null if not known.
+        /// </summary>
+        private readonly Dictionary<string, AssemblyNameExtension> _externallyResolvedImmutableFiles = new Dictionary<string, AssemblyNameExtension>(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>The table of remapped assemblies. Used for Unification.</summary>
         private IEnumerable<DependentAssembly> _remappedAssemblies = Enumerable.Empty<DependentAssembly>();
 
@@ -148,9 +153,9 @@ internal sealed class ReferenceTable
 
         /// <summary>
         /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is.
-        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message
-        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we
-        /// discover an assembly in the black list we can log the correct message.
+        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different deny list. We need to log a specific message
+        /// depending on which deny list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a deny list so that when we
+        /// discover an assembly in the deny list we can log the correct message.
         /// </summary>
         internal delegate void LogExclusionReason(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
 
@@ -823,6 +828,34 @@ private static void TryGetAssemblyNameComponent(string fusionName, string compon
             }
         }
 
+        /// <summary>
+        /// Tries to create an <see cref="AssemblyNameExtension"/> out of a primary reference metadata.
+        /// </summary>
+        private static AssemblyNameExtension GetAssemblyNameFromItemMetadata(ITaskItem item)
+        {
+            string version = item.GetMetadata(ItemMetadataNames.assemblyVersion);
+            if (string.IsNullOrEmpty(version))
+            {
+                return null;
+            }
+
+            string publicKeyToken = item.GetMetadata(ItemMetadataNames.publicKeyToken);
+            if (string.IsNullOrEmpty(publicKeyToken))
+            {
+                return null;
+            }
+
+            string name = item.GetMetadata(ItemMetadataNames.assemblyName);
+            if (string.IsNullOrEmpty(name))
+            {
+                // Fall back to inferring assembly name from file name.
+                name = item.GetMetadata(FileUtilities.ItemSpecModifiers.Filename);
+            }
+
+            AssemblyName assemblyName = new AssemblyName($"{name}, Version={version}, Culture=neutral, PublicKeyToken={publicKeyToken}");
+            return new AssemblyNameExtension(assemblyName);
+        }
+
         /// <summary>
         /// Given an item that refers to a file name, make it a primary reference.
         /// </summary>
@@ -1225,6 +1258,17 @@ private void ResolveReference(
             string rawFileNameCandidate,
             Reference reference)
         {
+            bool isImmutableFrameworkReference = false;
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+            {
+                // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
+                if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
+                {
+                    string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
+                    isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
+                }
+            }
+
             // Now, resolve this reference.
             string resolvedPath = null;
             string resolvedSearchPath = String.Empty;
@@ -1272,6 +1316,7 @@ private void ResolveReference(
                     reference.SDKName,
                     rawFileNameCandidate,
                     reference.IsPrimary,
+                    isImmutableFrameworkReference,
                     reference.WantSpecificVersion,
                     reference.GetExecutableExtensions(_allowedAssemblyExtensions),
                     reference.HintPath,
@@ -1291,7 +1336,13 @@ private void ResolveReference(
             // If the path was resolved, then specify the full path on the reference.
             if (resolvedPath != null)
             {
-                reference.FullPath = FileUtilities.NormalizePath(resolvedPath);
+                resolvedPath = FileUtilities.NormalizePath(resolvedPath);
+                if (isImmutableFrameworkReference)
+                {
+                    _externallyResolvedImmutableFiles[resolvedPath] = GetAssemblyNameFromItemMetadata(reference.PrimarySourceItem);
+                }
+                reference.FullPath = resolvedPath;
+
                 reference.ResolvedSearchPath = resolvedSearchPath;
                 reference.UserRequestedSpecificFile = userRequestedSpecificFile;
             }
@@ -1308,15 +1359,15 @@ private void ResolveReference(
         }
 
         /// <summary>
-        /// This method will remove references from the reference table which are contained in the blacklist.
-        /// References which are primary references but are in the black list will be placed in the invalidResolvedFiles list.
-        /// References which are dependency references but are in the black list will be placed in the invalidResolvedDependencyFiles list.
+        /// This method will remove references from the reference table which are contained in the denylist.
+        /// References which are primary references but are in the deny list will be placed in the invalidResolvedFiles list.
+        /// References which are dependency references but are in the deny list will be placed in the invalidResolvedDependencyFiles list.
         /// </summary>
         internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, string subsetName)
         {
             MSBuildEventSource.Log.RarRemoveReferencesMarkedForExclusionStart();
             {
-                // Create a table which will contain the references which are not in the black list
+                // Create a table which will contain the references which are not in the deny list
                 var goodReferences = new Dictionary<AssemblyNameExtension, Reference>(AssemblyNameComparer.GenericComparer);
 
                 // List of references which were removed from the reference table, we will loop through these and make sure that we get rid of the dependent references also.
@@ -1330,7 +1381,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     subsetName = String.Empty;
                 }
 
-                // Go through each of the references, we go through this table because in general it will be considerably smaller than the blacklist. (10's of references vs 100's of black list items)
+                // Go through each of the references, we go through this table because in general it will be considerably smaller than the denylist. (10's of references vs 100's of deny list items)
                 foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
                 {
                     AssemblyNameExtension assemblyName = assembly.Key;
@@ -1338,14 +1389,14 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
 
                     AddToDependencyGraph(dependencyGraph, assemblyName, assemblyReference);
 
-                    // Is the assembly name not in the black list. This means the assembly could be allowed.
+                    // Is the assembly name not in the deny list. This means the assembly could be allowed.
                     bool isMarkedForExclusion = assemblyReference.ExclusionListLoggingProperties.IsInExclusionList;
                     LogExclusionReason logExclusionReason = assemblyReference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate;
 
                     // Case one, the assembly is a primary reference
                     if (assemblyReference.IsPrimary)
                     {
-                        // The assembly is good if it is not in the black list or it has specific version set to true.
+                        // The assembly is good if it is not in the deny list or it has specific version set to true.
                         if (!isMarkedForExclusion || assemblyReference.WantSpecificVersion)
                         {
                             // Do not add the reference to the good list if it has been added to the removed references list, possibly because of us processing another reference.
@@ -1364,16 +1415,16 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     // the current primary reference and they need to be removed.
                     ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
 
-                    // Need to deal with dependencies, this can also include primary references who are dependencies themselves and are in the black list
+                    // Need to deal with dependencies, this can also include primary references who are dependencies themselves and are in the deny list
                     if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees?.Count > 1)))
                     {
                         // Does the assembly have specific version true, or does any of its primary parent references have specific version true.
-                        // This is checked because, if an assembly is in the black list, the only way it can possibly be allowed is if
+                        // This is checked because, if an assembly is in the deny list, the only way it can possibly be allowed is if
                         // ANY of the primary references which caused it have specific version set to true. To see if any primary references have the metadata we pass true to the method indicating 
                         // we want to know if any primary references have specific version set to true.
                         bool hasSpecificVersionTrue = assemblyReference.CheckForSpecificVersionMetadataOnParentsReference(true);
 
-                        // A dependency is "good" if it is not in the black list or any of its parents have specific version set to true
+                        // A dependency is "good" if it is not in the deny list or any of its parents have specific version set to true
                         if (!isMarkedForExclusion || hasSpecificVersionTrue)
                         {
                             // Do not add the reference to the good list if it has been added to the removed references list, possibly because of us processing another reference.
@@ -1383,8 +1434,8 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                             }
                         }
 
-                        // If the dependency is in the black list we need to remove the primary references which depend on this refernce.
-                        // note, a reference can both be in the good references list and in the black list. This can happen if a multiple primary references
+                        // If the dependency is in the deny list we need to remove the primary references which depend on this refernce.
+                        // note, a reference can both be in the good references list and in the deny list. This can happen if a multiple primary references
                         // depend on a single dependency. The dependency can be good for one reference but not allowed for the other.
                         if (isMarkedForExclusion)
                         {
@@ -1429,7 +1480,7 @@ private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAss
         }
 
         /// <summary>
-        /// We have determined the given assembly reference is in the black list, we now need to find the primary references which caused it and make sure those are removed from the list of references.
+        /// We have determined the given assembly reference is in the deny list, we now need to find the primary references which caused it and make sure those are removed from the list of references.
         /// </summary>
         private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, Dictionary<AssemblyNameExtension, Reference> goodReferences, List<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference)
         {
@@ -1477,7 +1528,7 @@ private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionR
         }
 
         /// <summary>
-        /// A primary references has been determined to be in the black list, it needs to be removed from the list of references by not being added to the list of good references
+        /// A primary references has been determined to be in the deny list, it needs to be removed from the list of references by not being added to the list of good references
         /// and added to the list of removed references.
         /// </summary>
         private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, List<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference)
@@ -1510,7 +1561,7 @@ internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
 
         /// <summary>
         /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other
-        /// assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the black list.
+        /// assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the deny list.
         /// </summary>
         /// <param name="removedReference">Reference to remove dependencies for</param>
         /// <param name="referenceList">Reference list which contains reference to be used in unification and returned as resolved items</param>
@@ -3156,5 +3207,28 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
 
             return anyMarkedReference;
         }
+
+        /// <summary>
+        /// Returns true if the full path passed in <paramref name="path"/> represents a file that came from an external trusted
+        /// entity and is guaranteed to be immutable.
+        /// </summary>
+        /// <param name="path">The path to check.</param>
+        /// <returns>True if known to be immutable, false otherwise.</returns>
+        internal bool IsImmutableFile(string path)
+        {
+            return _externallyResolvedImmutableFiles.ContainsKey(path);
+        }
+
+        /// <summary>
+        /// Returns the assembly name of a file if the file came from an external trusted entity and is considered immutable.
+        /// </summary>
+        /// <param name="path">The file path.</param>
+        /// <returns>Assembly name or null if not known.</returns>
+        internal AssemblyNameExtension GetImmutableFileAssemblyName(string path)
+        {
+            return _externallyResolvedImmutableFiles.TryGetValue(path, out AssemblyNameExtension assemblyNameExtension)
+                ? assemblyNameExtension
+                : null;
+        }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index afdde42ef14..45d87afb04c 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -41,6 +41,11 @@ public class ResolveAssemblyReference : TaskExtension, IIncrementalTask
         /// </summary>
         private const string NETStandardAssemblyName = "netstandard";
 
+        /// <summary>
+        /// The well-known CLR 4.0 metadata version used in all managed assemblies.
+        /// </summary>
+        private const string DotNetAssemblyRuntimeVersion = "v4.0.30319";
+
         /// <summary>
         /// Delegate to a method that takes a targetFrameworkDirectory and returns an array of redist or subset list paths
         /// </summary>
@@ -1963,7 +1968,7 @@ private void LogImageRuntime(Reference reference, MessageImportance importance)
             if (!reference.IsUnresolvable && !reference.IsBadImage)
             {
                 // Don't log the overwhelming default as it just pollutes the logs.
-                if (reference.ImageRuntime != "v4.0.30319")
+                if (reference.ImageRuntime != DotNetAssemblyRuntimeVersion)
                 {
                     Log.LogMessage(importance, Strings.ImageRuntimeVersion, reference.ImageRuntime);
                 }
@@ -2031,7 +2036,7 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// </summary>
         internal void ReadStateFile(FileExists fileExists)
         {
-            _cache = SystemState.DeserializeCache(_stateFile, Log, typeof(SystemState)) as SystemState;
+            _cache = SystemState.DeserializeCache<SystemState>(_stateFile, Log);
 
             // Construct the cache only if we can't find any caches.
             if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
@@ -2050,12 +2055,14 @@ internal void ReadStateFile(FileExists fileExists)
         /// </summary>
         internal void WriteStateFile()
         {
-            if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
             {
                 _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log);
             }
-            else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
+            else if (!string.IsNullOrEmpty(_stateFile) && (_cache.IsDirty || _cache.instanceLocalOutgoingFileStateCache.Count < _cache.instanceLocalFileStateCache.Count))
             {
+                // Either the cache is dirty (we added or updated an item) or the number of items actually used is less than what
+                // we got by reading the state file prior to execution. Serialize the cache into the state file.
                 if (FailIfNotIncremental)
                 {
                     Log.LogErrorFromResources("ResolveAssemblyReference.WritingCacheFile", _stateFile);
@@ -2217,7 +2224,7 @@ internal bool Execute(
                             inclusionListSubsetTableInfo = GetInstalledAssemblyTableInfo(IgnoreDefaultInstalledAssemblySubsetTables, InstalledAssemblySubsetTables, new GetListPath(inclusionList.GetSubsetListPathsFromDisk), TargetFrameworkDirectories);
                             if (inclusionListSubsetTableInfo.Length > 0 && (redistList?.Count > 0))
                             {
-                                exclusionList = redistList.GenerateBlackList(inclusionListSubsetTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
+                                exclusionList = redistList.GenerateDenyList(inclusionListSubsetTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
                             }
                             else
                             {
@@ -2291,16 +2298,46 @@ internal bool Execute(
 
                     // Load any prior saved state.
                     ReadStateFile(fileExists);
-                    _cache.SetGetLastWriteTime(getLastWriteTime);
                     _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
 
                     // Cache delegates.
-                    getAssemblyName = _cache.CacheDelegate(getAssemblyName);
                     getAssemblyMetadata = _cache.CacheDelegate(getAssemblyMetadata);
                     fileExists = _cache.CacheDelegate();
                     directoryExists = _cache.CacheDelegate(directoryExists);
                     getDirectories = _cache.CacheDelegate(getDirectories);
-                    getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
+
+                    ReferenceTable dependencyTable = null;
+
+                    // Wrap the GetLastWriteTime callback with a check for SDK/immutable files.
+                    _cache.SetGetLastWriteTime(path =>
+                    {
+                        if (dependencyTable?.IsImmutableFile(path) == true)
+                        {
+                            // We don't want to perform I/O to see what the actual timestamp on disk is so we return a fixed made up value.
+                            // Note that this value makes the file exist per the check in SystemState.FileTimestampIndicatesFileExists.
+                            return SystemState.FileState.ImmutableFileLastModifiedMarker;
+                        }
+                        return getLastWriteTime(path);
+                    });
+
+                    // Wrap the GetAssemblyName and GetRuntimeVersion callbacks with a check for SDK/immutable files.
+                    GetAssemblyName originalGetAssemblyName = getAssemblyName;
+                    getAssemblyName = _cache.CacheDelegate(path =>
+                    {
+                        AssemblyNameExtension assemblyName = dependencyTable?.GetImmutableFileAssemblyName(path);
+                        return assemblyName ?? originalGetAssemblyName(path);
+                    });
+
+                    GetAssemblyRuntimeVersion originalGetRuntimeVersion = getRuntimeVersion;
+                    getRuntimeVersion = _cache.CacheDelegate(path =>
+                    {
+                        if (dependencyTable?.IsImmutableFile(path) == true)
+                        {
+                            // There are no WinRT assemblies in the SDK, everything has the .NET metadata version.
+                            return DotNetAssemblyRuntimeVersion;
+                        }
+                        return originalGetRuntimeVersion(path);
+                    });
 
                     _projectTargetFramework = FrameworkVersionFromString(_projectTargetFrameworkAsString);
 
@@ -2330,7 +2367,7 @@ internal bool Execute(
                             : null;
 
                     // Start the table of dependencies with all of the primary references.
-                    ReferenceTable dependencyTable = new ReferenceTable(
+                    dependencyTable = new ReferenceTable(
                         BuildEngine,
                         _findDependencies,
                         _findSatellites,
@@ -2737,7 +2774,7 @@ private void HandleProfile(AssemblyTableInfo[] installedAssemblyTableInfo, out A
                     // Any errors reading the profile redist list will already be logged, we do not need to re-log the errors here.
                     List<Exception> inclusionListErrors = new List<Exception>();
                     List<string> inclusionListErrorFilesNames = new List<string>();
-                    exclusionList = fullFrameworkRedistList.GenerateBlackList(installedAssemblyTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
+                    exclusionList = fullFrameworkRedistList.GenerateDenyList(installedAssemblyTableInfo, inclusionListErrors, inclusionListErrorFilesNames);
                 }
 
                 // Could get into this situation if the redist list files were full of junk and no assemblies were read in.
@@ -2860,7 +2897,7 @@ private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableIn
                 }
             }
 
-            Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader");
+            Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.TargetFrameworkAllowListLogHeader");
             if (inclusionListSubsetTableInfo != null)
             {
                 foreach (AssemblyTableInfo inclusionListInfo in inclusionListSubsetTableInfo)
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index b854a4015e5..667493a611d 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -72,6 +72,7 @@ protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, Fi
         /// <param name="sdkName">The name of the sdk to resolve.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
+        /// <param name="isImmutableFrameworkReference">True if <paramref name="rawFileNameCandidate"/> is guaranteed to exist on disk and never change.</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">Allowed executable extensions.</param>
         /// <param name="hintPath">The item's hintpath value.</param>
@@ -85,6 +86,7 @@ public abstract bool Resolve(
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/AssemblyRegistrationCache.cs b/src/Tasks/AssemblyRegistrationCache.cs
index 8ac4f9ff065..b4975263b99 100644
--- a/src/Tasks/AssemblyRegistrationCache.cs
+++ b/src/Tasks/AssemblyRegistrationCache.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
@@ -13,8 +12,6 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// This class is a caching mechanism for the Register/UnregisterAssembly task to keep track of registered assemblies to clean up
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class AssemblyRegistrationCache : StateFileBase, ITranslatable
     {
         /// <summary>
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 343eabff36d..2480c599bce 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -99,11 +99,11 @@ public class AssignCulture : TaskExtension
         /// The culture will only be stripped if it is a valid culture identifier.
         /// So for example,
         /// 
-        ///      MyCrazyFile.XX.txt
+        ///      MyDifferentFile.XX.txt
         /// 
         /// will result in exactly the same file name:
         /// 
-        ///      MyCrazyFile.XX.txt
+        ///      MyDifferentFile.XX.txt
         /// 
         /// because 'XX' is not a valid culture identifier.
         /// </summary>
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 2a47fce7737..74894b3aa5e 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -157,8 +157,6 @@ public string VcxToDefaultPlatformMapping
         private const string attrSetConfiguration = "SetConfiguration";
         private const string attrSetPlatform = "SetPlatform";
 
-        private static readonly char[] s_configPlatformSeparator = { '|' };
-
         private IDictionary<string, string> _vcxToDefaultMap;
         private IDictionary<string, string> _defaultToVcxMap;
         private bool _mappingsPopulated;
@@ -287,14 +285,14 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                 {
                     if (_defaultToVcxMap.TryGetValue(CurrentProjectPlatform, out transformedPlatform))
                     {
-                        projectConfiguration = CurrentProjectConfiguration + s_configPlatformSeparator[0] + transformedPlatform;
+                        projectConfiguration = CurrentProjectConfiguration + SolutionConfiguration.ConfigPlatformSeparator[0] + transformedPlatform;
                     }
                 }
                 else
                 {
                     if (_vcxToDefaultMap.TryGetValue(CurrentProjectPlatform, out transformedPlatform))
                     {
-                        projectConfiguration = CurrentProjectConfiguration + s_configPlatformSeparator[0] + transformedPlatform;
+                        projectConfiguration = CurrentProjectConfiguration + SolutionConfiguration.ConfigPlatformSeparator[0] + transformedPlatform;
                     }
                 }
             }
@@ -306,7 +304,7 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                 resolvedProjectWithConfiguration = projectRef;
                 resolvedProjectWithConfiguration.SetMetadata(attrFullConfiguration, projectConfiguration);
 
-                string[] configurationPlatformParts = projectConfiguration.Split(s_configPlatformSeparator);
+                string[] configurationPlatformParts = projectConfiguration.Split(SolutionConfiguration.ConfigPlatformSeparator);
                 resolvedProjectWithConfiguration.SetMetadata(attrSetConfiguration, "Configuration=" + configurationPlatformParts[0]);
                 resolvedProjectWithConfiguration.SetMetadata(attrConfiguration, configurationPlatformParts[0]);
 
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index 9de8725cd65..f998d3be668 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -66,7 +66,7 @@ public AnalyzedTypesInfoKey(Guid guid, short major, short minor, int lcid, int i
                 this.index = index;
             }
 
-            public override string ToString()
+            public override readonly string ToString()
             {
                 return string.Format(CultureInfo.InvariantCulture, "{0}.{1}.{2}.{3}:{4}",
                     this.guid, this.wMajorVerNum,
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 979c9652291..bd2e536cb74 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -225,8 +225,8 @@ private void LogDiagnostic(string message, params object[] messageArgs)
         /// </summary>
         /// <returns>Return true to indicate success, return false to indicate failure and NO retry, return NULL to indicate retry.</returns>
         private bool? CopyFileWithLogging(
-            FileState sourceFileState,      // The source file
-            FileState destinationFileState)  // The destination file
+            FileState sourceFileState,
+            FileState destinationFileState)
         {
             if (destinationFileState.DirectoryExists)
             {
@@ -276,9 +276,7 @@ private void LogDiagnostic(string message, params object[] messageArgs)
 
             if (FailIfNotIncremental)
             {
-                string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);
-                string destinationFilePath = FileUtilities.GetFullPathNoThrow(destinationFileState.Name);
-                Log.LogError(FileComment, sourceFilePath, destinationFilePath);
+                Log.LogError(FileComment, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
                 return false;
             }
 
@@ -287,10 +285,7 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 MakeFileWriteable(destinationFileState, true);
             }
 
-            // If the destination file is a hard or symbolic link, File.Copy would overwrite the source.
-            // To prevent this, we need to delete the existing entry before we Copy or create a link.
-            // We could try to figure out if the file is a link, but I can't think of a reason to not simply delete it always.
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && destinationFileState.FileExists && !destinationFileState.IsReadOnly)
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) && destinationFileState.FileExists && !destinationFileState.IsReadOnly)
             {
                 FileUtilities.DeleteNoThrow(destinationFileState.Name);
             }
@@ -308,11 +303,11 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                     if (UseSymboliclinksIfPossible)
                     {
                         // This is a message for fallback to SymbolicLinks if HardLinks fail when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true
-                        Log.LogMessage(MessageImportance.Normal, RetryingAsSymbolicLink, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsSymbolicLink, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath, errorMessage);
                     }
                     else
                     {
-                        Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath, errorMessage);
                     }
                 }
             }
@@ -328,13 +323,13 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                         errorMessage = Log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "symlink()", errorMessage);
                     }
 
-                    Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                    Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath, errorMessage);
                 }
             }
 
             if (ErrorIfLinkFails && !hardLinkCreated && !symbolicLinkCreated)
             {
-                Log.LogErrorWithCodeFromResources("Copy.LinkFailed", sourceFileState.Name, destinationFileState.Name);
+                Log.LogErrorWithCodeFromResources("Copy.LinkFailed", sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
                 return false;
             }
 
@@ -343,20 +338,18 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             if (!hardLinkCreated && !symbolicLinkCreated)
             {
                 // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-                string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);
-                string destinationFilePath = FileUtilities.GetFullPathNoThrow(destinationFileState.Name);
-                Log.LogMessage(MessageImportance.Normal, FileComment, sourceFilePath, destinationFilePath);
+                Log.LogMessage(MessageImportance.Normal, FileComment, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
 
                 File.Copy(sourceFileState.Name, destinationFileState.Name, true);
+            }
 
-                // If the destinationFile file exists, then make sure it's read-write.
-                // The File.Copy command copies attributes, but our copy needs to
-                // leave the file writeable.
-                if (sourceFileState.IsReadOnly)
-                {
-                    destinationFileState.Reset();
-                    MakeFileWriteable(destinationFileState, false);
-                }
+            // If the destinationFile file exists, then make sure it's read-write.
+            // The File.Copy command copies attributes, but our copy needs to
+            // leave the file writeable.
+            if (sourceFileState.IsReadOnly)
+            {
+                destinationFileState.Reset();
+                MakeFileWriteable(destinationFileState, false);
             }
 
             // Files were successfully copied or linked. Those are equivalent here.
@@ -751,14 +744,7 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                         "true");
                     MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, true);
                 }
-
-                // We only do the cheap check for identicalness here, we try the more expensive check
-                // of comparing the fullpaths of source and destination to see if they are identical,
-                // in the exception handler lower down.
-                else if (!String.Equals(
-                             sourceFileState.Name,
-                             destinationFileState.Name,
-                             StringComparison.OrdinalIgnoreCase))
+                else if (!PathsAreIdentical(sourceFileState, destinationFileState))
                 {
                     MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, false);
 
@@ -849,7 +835,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                             }
                             else if (code == NativeMethods.ERROR_INVALID_FILENAME)
                             {
-                                // Invalid characters used in file name, no point retrying.
+                                // Invalid characters used in file name; no point retrying.
                                 throw;
                             }
 
@@ -865,13 +851,6 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                 throw;
                             }
 
-                            // if this was just because the source and destination files are the
-                            // same file, that's not a failure.
-                            // Note -- we check this exceptional case here, not before the copy, for perf.
-                            if (PathsAreIdentical(sourceFileState.Name, destinationFileState.Name))
-                            {
-                                return true;
-                            }
                             break;
                     }
 
@@ -969,12 +948,16 @@ public override bool Execute()
         /// Compares two paths to see if they refer to the same file. We can't solve the general
         /// canonicalization problem, so we just compare strings on the full paths.
         /// </summary>
-        private static bool PathsAreIdentical(string source, string destination)
+        private static bool PathsAreIdentical(FileState source, FileState destination)
         {
-            string fullSourcePath = Path.GetFullPath(source);
-            string fullDestinationPath = Path.GetFullPath(destination);
-            StringComparison filenameComparison = NativeMethodsShared.IsWindows ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
-            return String.Equals(fullSourcePath, fullDestinationPath, filenameComparison);
+            if (string.Equals(source.Name, destination.Name, FileUtilities.PathComparison))
+            {
+                return true;
+            }
+
+            source.FileNameFullPath = Path.GetFullPath(source.Name);
+            destination.FileNameFullPath = Path.GetFullPath(destination.Name);
+            return string.Equals(source.FileNameFullPath, destination.FileNameFullPath, FileUtilities.PathComparison);
         }
 
         private static int GetParallelismFromEnvironment()
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 359a2dc7b03..9908267c4a8 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -14,9 +14,12 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Represents a single input to a compilation-style task.
     /// Keeps track of timestamp for later comparison.
+    ///
+    /// Must be serializable because instances may be marshaled cross-AppDomain, see <see cref="ProcessResourceFiles.PortableLibraryCacheInfo"/>.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+#if FEATURE_APPDOMAIN
     [Serializable]
+#endif
     internal class DependencyFile
     {
         // Filename
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 8119588a35f..efe54f514ca 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.Net;
 using System.Net.Http;
-using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
@@ -128,14 +127,8 @@ private async Task<bool> ExecuteAsync()
                     }
                     else
                     {
-                        StringBuilder flattenedMessage = new StringBuilder(actualException.Message);
-                        Exception excep = actualException;
-                        while (excep.InnerException != null)
-                        {
-                            excep = excep.InnerException;
-                            flattenedMessage.Append(" ---> ").Append(excep.Message);
-                        }
-                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, flattenedMessage.ToString());
+                        string flattenedMessage = TaskLoggingHelper.GetInnerExceptionMessageString(e);
+                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, flattenedMessage);
                         Log.LogMessage(MessageImportance.Low, actualException.ToString());
                         break;
                     }
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index f992f7bc76b..4e00e4af725 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -231,6 +231,11 @@ public void ThrowException()
         /// </summary>
         private readonly string _filename;
 
+        /// <summary>
+        /// Holds the full path equivalent of _filename
+        /// </summary>
+        public string FileNameFullPath;
+
         /// <summary>
         /// Actual file or directory information
         /// </summary>
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 16985d1bb3d..c5bc3724e33 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -931,7 +931,7 @@ internal SDKInfo LoadAssemblyListFromCacheFile(string sdkIdentity, string sdkRoo
                     if (!string.IsNullOrEmpty(cacheFile))
                     {
                         using FileStream fs = new FileStream(cacheFile, FileMode.Open);
-                        using var translator = BinaryTranslator.GetReadTranslator(fs, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(fs, InterningBinaryReader.PoolingBuffer);
                         SDKInfo sdkInfo = new SDKInfo();
                         sdkInfo.Translate(translator);
                         return sdkInfo;
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 101d5b29dc2..9fd40f7963e 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -30,14 +30,13 @@ public InstalledSDKResolver(Dictionary<string, ITaskItem> resolvedSDKs, string s
             _resolvedSDKs = resolvedSDKs;
         }
 
-        /// <summary>
-        /// Resolve references which are found in a specific SDK
-        /// </summary>
+        /// <inheritdoc/>
         public override bool Resolve(
             AssemblyNameExtension assemblyName,
             string sdkName,
             string rawFileNameCandidate,
             bool isPrimaryProjectReference,
+            bool isImmutableFrameworkReference,
             bool wantSpecificVersion,
             string[] executableExtensions,
             string hintPath,
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 01a5da96803..7cf93927c04 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -838,7 +838,7 @@ internal static string GetCommandLineParameters(string certThumbprint, Uri times
             {
                 commandLine.AppendFormat(CultureInfo.InvariantCulture,
                                             "{0} {1} ",
-                                            useRFC3161Timestamp ? "/tr" : "/t",
+                                            useRFC3161Timestamp ? "/td sha256 /tr" : "/t",
                                             timestampUrl.ToString());
             }
             commandLine.AppendFormat(CultureInfo.InvariantCulture, "\"{0}\"", path);
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 29c34e47730..ef14371aa36 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -883,7 +883,7 @@ private static void TimestampSignedLicenseDom(XmlDocument licenseDom, string tim
                 // Try RFC3161 first
                 XmlElement signatureValueNode = licenseDom.SelectSingleNode("r:license/r:issuer/ds:Signature/ds:SignatureValue", nsm) as XmlElement;
                 string signatureValue = signatureValueNode.InnerText;
-                timestamp = ObtainRFC3161Timestamp(timeStampUrl, signatureValue, useSha256);
+                timestamp = ObtainRFC3161Timestamp(timeStampUrl, signatureValue, true);
             }
             // Catch CryptographicException to ensure fallback to old code (non-RFC3161)
             catch (CryptographicException)
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index a7ab39b6a7e..72ea1091d20 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -30,9 +30,6 @@
   </ItemGroup>
   <ItemGroup>
     <!-- Binary serialization by ITranslatable -->
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
   </ItemGroup>
@@ -972,7 +969,6 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
-
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
@@ -992,28 +988,29 @@
     <PackageReference Include="Microsoft.Net.Compilers.Toolset" ExcludeAssets="all" Condition="'$(UsingToolMicrosoftNetCompilers)' == 'false'" />
   </ItemGroup>
 
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'">
+    <PackageReference Include="System.Threading.Tasks.Dataflow" />
+  </ItemGroup>
+
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
-    <PackageReference Include="System.Threading.Tasks.Dataflow" />
-
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net472\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="Microsoft.Win32.Registry" />
+    <PackageReference Include="System.Reflection.Metadata" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
-    <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
     <PackageReference Include="System.Security.Cryptography.Xml" />
     <PackageReference Include="System.Security.Permissions" />
-    <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
-    <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net6.0\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
+    <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcore\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(MonoBuild)' == 'true'">
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index af1a6b18164..44bed1b25ba 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -76,6 +76,34 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    Target that allows targets consuming source control confirmation to establish a dependency on targets producing this information.
+
+    Any target that reads SourceRevisionId, PrivateRepositoryUrl, SourceRoot, and other source control properties and items
+    should depend on this target and be conditioned on '$(SourceControlInformationFeatureSupported)' == 'true'.
+
+    SourceRevisionId property uniquely identifies the source control revision of the repository the project belongs to.
+    For Git repositories this id is a commit hash, for TFVC repositories it's the changeset number, etc.
+
+    PrivateRepositoryUrl property stores the URL of the repository supplied by the CI server or retrieved from source control manager.
+    Targets consuming this property shall not publish its value implicitly as it might inadvertently reveal an internal URL.
+    Instead, they shall only do so if the project sets PublishRepositoryUrl property to true. For example, the NuGet Pack target
+    may include the repository URL in the nuspec file generated for NuGet package produced by the project if PublishRepositoryUrl is true.
+
+    SourceRoot item group lists all source roots that the project source files reside under and their mapping to source control server URLs,
+    if available. This includes both source files under source control as well as source files in source packages. SourceRoot items are
+    used by compilers to determine path map in deterministic build and by SourceLink provider, which maps local paths to URLs of source files
+    stored on the source control server.
+
+    Source control information provider that sets these properties and items shall execute before this target (by including
+    InitializeSourceControlInformation in its BeforeTargets) and set source control properties and items that haven't been initialized yet.
+  -->
+  <Target Name="InitializeSourceControlInformation" />
+
+  <PropertyGroup>
+    <SourceControlInformationFeatureSupported>true</SourceControlInformationFeatureSupported>
+  </PropertyGroup>
+
   <!--
   ============================================================
                                        DispatchToInnerBuilds
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index f36e079ea3b..18ac9baa9a4 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1027,6 +1027,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
+    <ProjectReferenceTargets Include="BuildGenerateSources" Targets="BuildGenerateSources" />
+  </ItemGroup>
+
   <!--
     ============================================================
                                         BuildCompile
@@ -1052,6 +1056,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
+    <ProjectReferenceTargets Include="BuildCompile" Targets="BuildCompile" />
+  </ItemGroup>
+
   <!--
     ============================================================
                                         BuildLink
@@ -1077,6 +1085,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
+    <ProjectReferenceTargets Include="BuildLink" Targets="BuildLink" />
+  </ItemGroup>
+
   <!--
     ============================================================
                                         CopyRunEnvironmentFiles
@@ -1232,7 +1244,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         RootPath="$(TargetFrameworkRootPath)"
         TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)"
         BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)"
-        >
+        ContinueOnError="!$(BuildingProject)">
       <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories"/>
       <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths"/>
       <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''"/>
@@ -1288,7 +1300,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
                                         AssignLinkMetadata
 
-       For items of a certain set of whitelisted types, make sure that
+       For items of a certain set of allowlisted types, make sure that
        if they are defined in a file other than the project file, that
        they have "Link" metadata set to an appropriate default.
     ============================================================
@@ -2698,6 +2710,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </MSBuild>
   </Target>
 
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(FindInvalidProjectReferences)' == 'true'">
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetPathWithTargetPlatformMoniker" />
+  </ItemGroup>
+
    <!--
     ============================================================
 
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index a14fea277c2..e3771628bdd 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -29,8 +29,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
   </PropertyGroup>
 
+  <Import Project="$(CustomBeforeDirectoryBuildProps)" Condition="'$(CustomBeforeDirectoryBuildProps)' != ''" />
+
   <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')"/>
 
+  <Import Project="$(CustomAfterDirectoryBuildProps)" Condition="'$(CustomAfterDirectoryBuildProps)' != ''" />
+
   <!--
       Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
         $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props
diff --git a/src/Tasks/Microsoft.Common.targets b/src/Tasks/Microsoft.Common.targets
index e4f83cd7640..4e71065ca26 100644
--- a/src/Tasks/Microsoft.Common.targets
+++ b/src/Tasks/Microsoft.Common.targets
@@ -48,6 +48,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
   </PropertyGroup>
 
+  <Import Project="$(CustomBeforeDirectoryBuildTargets)" Condition="'$(CustomBeforeDirectoryBuildTargets)' != ''" />
+
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
+  <Import Project="$(CustomAfterDirectoryBuildTargets)" Condition="'$(CustomAfterDirectoryBuildTargets)' != ''" />
+
 </Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index d91e88e9861..beab1878e60 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -16,9 +16,9 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombineXmlElements"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Copy"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -32,7 +32,6 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FindInList"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FindInvalidProjectReferences"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-
   <UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -53,8 +52,9 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Hash"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.LC"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -72,15 +72,13 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveKeySource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveManifestFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNativeReference"                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.SGen"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.SignFile"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -90,21 +88,21 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.VerifyFileHash"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Warning"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XmlPoke"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XslTransformation"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ZipDirectory"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
   <!-- Roslyn tasks are now in an assembly owned and shipped by Roslyn -->
+  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
-  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
 
 </Project>
diff --git a/src/Tasks/Microsoft.NET.props b/src/Tasks/Microsoft.NET.props
index 7ce88ca6f2a..b983647d821 100644
--- a/src/Tasks/Microsoft.NET.props
+++ b/src/Tasks/Microsoft.NET.props
@@ -7,22 +7,13 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
           impossible to load or build your projects from the command-line or the IDE.
 
 This file contains .NET-specific properties, and items. This file is imported for .NET Core, .NET Standard, and .NET Framework projects.
+these two files are used to encapsulate the multi-targeting and framework specific build process.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
 <Project>
 
-  <!--
-    ============================================================
-                                        Reference Assemblies
-    Enable the production of a reference assembly by all .NET projects, by default.
-    ============================================================
-  -->
-  <PropertyGroup>
-    <ProduceReferenceAssembly Condition=" '$(ProduceReferenceAssembly)' == '' and '$(ProduceOnlyReferenceAssembly)' != 'true' ">true</ProduceReferenceAssembly>
-  </PropertyGroup>
-
   <!--
     ============================================================
                                         GetToolPaths
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 2337f450180..cd306bff23c 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -66,8 +66,8 @@ internal sealed class RedistList
         /// </summary>
         private readonly ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension> _remappingCache = new ConcurrentDictionary<AssemblyNameExtension, AssemblyNameExtension>(AssemblyNameComparer.GenericComparerConsiderRetargetable);
 
-        // List of cached BlackList RedistList objects, the key is a semi-colon delimited list of data file paths
-        private readonly ConcurrentDictionary<string, Dictionary<string, string>> _cachedBlackList = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
+        // List of cached DenyList RedistList objects, the key is a semi-colon delimited list of data file paths
+        private readonly ConcurrentDictionary<string, Dictionary<string, string>> _cachedDenyList = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
 
         /***************Fields which are only set in the constructor and should not be modified by the class. **********************/
         // Array of errors encountered while reading files.
@@ -500,27 +500,27 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         }
 
         /// <summary>
-        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the
-        /// assemblies listed in the WhiteList from the RedistList.
+        /// This method will take a list of AssemblyTableInfo and generate a deny list by subtracting the
+        /// assemblies listed in the AllowList from the RedistList.
         ///
         /// 1) If there are assemblies in the redist list and one or more client subset files are read in with matching names then
-        ///    the subtraction will take place. If there were no matching redist lists read in the black list will be empty.
+        ///    the subtraction will take place. If there were no matching redist lists read in the deny list will be empty.
         ///
-        /// 2) If the subset has a matching name but there are no files inside of it then the black list will contain ALL files in the redist list.
+        /// 2) If the subset has a matching name but there are no files inside of it then the deny list will contain ALL files in the redist list.
         ///
-        /// 3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for black list generation.
+        /// 3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for deny list generation.
         ///
-        /// When generating the blacklist, we will first see if the black list is in the appdomain wide cache
-        /// so that we do not regenerate one for multiple calls using the same whiteListAssemblyTableInfo.
+        /// When generating the denylist, we will first see if the deny list is in the appdomain wide cache
+        /// so that we do not regenerate one for multiple calls using the same allowListAssemblyTableInfo.
         ///
         /// </summary>
-        /// <param name="whiteListAssemblyTableInfo">List of paths to white list xml files</param>
-        /// <param name="whiteListErrors">List of white listed errors</param>
-        /// <param name="whiteListErrorFileNames">List of white listed error file names</param>
-        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value.
+        /// <param name="allowListAssemblyTableInfo">List of paths to allow list xml files</param>
+        /// <param name="allowListErrors">List of allow listed errors</param>
+        /// <param name="allowListErrorFileNames">List of allow listed error file names</param>
+        /// <returns>A dictionary containing the full assembly names of deny listed assemblies as the key, and null as the value.
         ///          If there is no assemblies in the redist list null is returned.
         /// </returns>
-        internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableInfo, List<Exception> whiteListErrors, List<string> whiteListErrorFileNames)
+        internal Dictionary<string, string> GenerateDenyList(AssemblyTableInfo[] allowListAssemblyTableInfo, List<Exception> allowListErrors, List<string> allowListErrorFileNames)
         {
             // Return null if there are no assemblies in the redist list.
             if (_assemblyList.Count == 0)
@@ -528,44 +528,44 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
                 return null;
             }
 
-            // Sort so that the same set of whiteListAssemblyTableInfo will generate the same key for the cache
-            Array.Sort(whiteListAssemblyTableInfo);
+            // Sort so that the same set of allowListAssemblyTableInfo will generate the same key for the cache
+            Array.Sort(allowListAssemblyTableInfo);
 
-            var keyBuilder = whiteListAssemblyTableInfo.Length > 0 ? new StringBuilder(whiteListAssemblyTableInfo[0].Descriptor) : new StringBuilder();
+            var keyBuilder = allowListAssemblyTableInfo.Length > 0 ? new StringBuilder(allowListAssemblyTableInfo[0].Descriptor) : new StringBuilder();
 
-            // Concatenate the paths to the whitelist xml files together to get the key into the blacklist cache.
-            for (int i = 1; i < whiteListAssemblyTableInfo.Length; ++i)
+            // Concatenate the paths to the allowlist xml files together to get the key into the denylist cache.
+            for (int i = 1; i < allowListAssemblyTableInfo.Length; ++i)
             {
                 keyBuilder.Append(';');
-                keyBuilder.Append(whiteListAssemblyTableInfo[i].Descriptor);
+                keyBuilder.Append(allowListAssemblyTableInfo[i].Descriptor);
             }
 
             string key = keyBuilder.ToString();
 
-            if (!_cachedBlackList.TryGetValue(key, out Dictionary<string, string> returnTable))
+            if (!_cachedDenyList.TryGetValue(key, out Dictionary<string, string> returnTable))
             {
-                var whiteListAssemblies = new List<AssemblyEntry>();
+                var allowListAssemblies = new List<AssemblyEntry>();
 
                 // Unique list of redist names in the subset files read in. We use this to make sure we are subtracting from the correct framework list.
                 var uniqueClientListNames = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
-                // Get the assembly entries for the white list
-                foreach (AssemblyTableInfo info in whiteListAssemblyTableInfo)
+                // Get the assembly entries for the allow list
+                foreach (AssemblyTableInfo info in allowListAssemblyTableInfo)
                 {
-                    var whiteListAssembliesReadIn = new List<AssemblyEntry>();
+                    var allowListAssembliesReadIn = new List<AssemblyEntry>();
 
                     // Need to know how many errors are in the list before the read file call so that if the redist name is null due to an error
                     // we do not get a "redist name is null or empty" error when in actual fact it was a file not found error.
-                    int errorsBeforeReadCall = whiteListErrors.Count;
+                    int errorsBeforeReadCall = allowListErrors.Count;
 
                     // Read in the subset list file. 
-                    string redistName = ReadFile(info, whiteListAssembliesReadIn, whiteListErrors, whiteListErrorFileNames, null);
+                    string redistName = ReadFile(info, allowListAssembliesReadIn, allowListErrors, allowListErrorFileNames, null);
 
                     // Get the client subset name which has been read in.
                     if (!String.IsNullOrEmpty(redistName))
                     {
-                        // Populate the list of assemblies which are to be used as white list assemblies.
-                        whiteListAssemblies.AddRange(whiteListAssembliesReadIn);
+                        // Populate the list of assemblies which are to be used as allow list assemblies.
+                        allowListAssemblies.AddRange(allowListAssembliesReadIn);
 
                         // We may have the same redist name for multiple files, we only want to get the set of unique names.
                         if (!uniqueClientListNames.ContainsKey(redistName))
@@ -577,22 +577,22 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
                     {
                         // There are no extra errors reading in the subset list file which would have caused the redist list name to be null or empty.
                         // This means the redist name read in must be null or empty
-                        if (whiteListErrors.Count == errorsBeforeReadCall)
+                        if (allowListErrors.Count == errorsBeforeReadCall)
                         {
-                            // The whiteList errors passes back problems reading the redist file through the use of an array containing exceptions
-                            whiteListErrors.Add(new Exception(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.NoSubSetRedistListName", info.Path)));
-                            whiteListErrorFileNames.Add(info.Path);
+                            // The allowList errors passes back problems reading the redist file through the use of an array containing exceptions
+                            allowListErrors.Add(new Exception(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.NoSubSetRedistListName", info.Path)));
+                            allowListErrorFileNames.Add(info.Path);
                         }
                     }
                 }
 
                 // Dont care about the case of the assembly name
-                var blackList = new Hashtable(StringComparer.OrdinalIgnoreCase);
+                var denyList = new Hashtable(StringComparer.OrdinalIgnoreCase);
 
                 // Do we have any subset names?
                 bool uniqueClientNamesExist = uniqueClientListNames.Count > 0;
 
-                // Fill the hashtable with the entries, if there are no white list assemblies the black list will contain all assemblies in the redist list
+                // Fill the hashtable with the entries, if there are no allow list assemblies the deny list will contain all assemblies in the redist list
                 foreach (AssemblyEntry entry in _assemblyList)
                 {
                     string entryFullName = entry.FullName;
@@ -605,32 +605,32 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
 
                     string hashKey = entryFullName + "," + redistName;
 
-                    // If there were no subset list names read in we cannot generate a black list. (warnings will be logged as part of the reading of the subset list).
+                    // If there were no subset list names read in we cannot generate a deny list. (warnings will be logged as part of the reading of the subset list).
                     if (uniqueClientNamesExist)
                     {
-                        if (!blackList.ContainsKey(hashKey) && uniqueClientListNames.ContainsKey(redistName))
+                        if (!denyList.ContainsKey(hashKey) && uniqueClientListNames.ContainsKey(redistName))
                         {
-                            blackList[hashKey] = entryFullName;
+                            denyList[hashKey] = entryFullName;
                         }
                     }
                 }
 
-                // Go through each of the white list assemblies and remove it from the black list. Do this based on the assembly name and the redist name
-                foreach (AssemblyEntry whiteListEntry in whiteListAssemblies)
+                // Go through each of the allow list assemblies and remove it from the deny list. Do this based on the assembly name and the redist name
+                foreach (AssemblyEntry allowListEntry in allowListAssemblies)
                 {
-                    blackList.Remove(whiteListEntry.FullName + "," + whiteListEntry.RedistName);
+                    denyList.Remove(allowListEntry.FullName + "," + allowListEntry.RedistName);
                 }
 
                 // The output dictionary needs to be just the full names and not the names + redist name
-                var blackListOfAssemblyNames = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                foreach (string name in blackList.Values)
+                var denyListOfAssemblyNames = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                foreach (string name in denyList.Values)
                 {
-                    blackListOfAssemblyNames[name] = null;
+                    denyListOfAssemblyNames[name] = null;
                 }
 
-                _cachedBlackList.TryAdd(key, blackListOfAssemblyNames);
+                _cachedDenyList.TryAdd(key, denyListOfAssemblyNames);
 
-                return blackListOfAssemblyNames;
+                return denyListOfAssemblyNames;
             }
 
             return returnTable;
@@ -929,7 +929,7 @@ public int Compare(AssemblyEntry firstEntry, AssemblyEntry secondEntry)
     }
 
     /// <summary>
-    /// Internal class representing a redist list or whitelist and its corresponding framework directory.
+    /// Internal class representing a redist list or allowlist and its corresponding framework directory.
     /// </summary>
     internal class AssemblyTableInfo : IComparable
     {
@@ -955,7 +955,7 @@ public int CompareTo(object obj)
     }
 
     /// <summary>
-    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders
+    /// Provide a mechanism to determine where the subset allow lists are located by searching the target framework folders
     /// for a list of provided subset list names.
     /// </summary>
     internal class SubsetListFinder
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 3ce50fcde06..0fb8e616bb3 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -76,7 +76,7 @@ public override bool Execute()
 
             if ((AssemblyListFile?.ItemSpec.Length > 0))
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log) ??
                             new AssemblyRegistrationCache();
             }
 
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 2a3c042cff0..706899188d7 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -23,11 +23,7 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// This class is a caching mechanism for the resgen task to keep track of linked
     /// files within processed .resx files.
-    /// 
-    /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class ResGenDependencies : StateFileBase, ITranslatable
     {
         /// <summary>
@@ -189,9 +185,9 @@ internal void UpdatePortableLibrary(PortableLibraryFile library)
         /// <summary>
         /// Writes the contents of this object out to the specified file.
         /// </summary>
-        internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
+        internal override void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState = false)
         {
-            base.SerializeCache(stateFile, log);
+            base.SerializeCache(stateFile, log, serializeEmptyState);
             _isDirty = false;
         }
 
@@ -200,7 +196,7 @@ internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// </summary>
         internal static ResGenDependencies DeserializeCache(string stateFile, bool useSourcePath, TaskLoggingHelper log)
         {
-            var retVal = (ResGenDependencies)DeserializeCache(stateFile, log, typeof(ResGenDependencies)) ?? new ResGenDependencies();
+            var retVal = DeserializeCache<ResGenDependencies>(stateFile, log) ?? new ResGenDependencies();
 
             // Ensure that the cache is properly initialized with respect to how resgen will 
             // resolve linked files within .resx files.  ResGen has two different
@@ -218,11 +214,7 @@ internal static ResGenDependencies DeserializeCache(string stateFile, bool useSo
 
         /// <remarks>
         /// Represents a single .resx file in the dependency cache.
-        /// 
-        /// This is an on-disk serialization format, don't change field names or types or use readonly.
         /// </remarks>
-        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-        [Serializable]
         internal sealed class ResXFile : DependencyFile, ITranslatable
         {
             // Files contained within this resx file.
@@ -325,10 +317,11 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
         /// Represents a single assembly in the dependency cache, which may produce 
         /// 0 to many ResW files.
         /// 
-        /// This is an on-disk serialization format, don't change field names or types or use readonly.
+        /// Must be serializable because instances may be marshaled cross-AppDomain, see <see cref="ProcessResourceFiles.PortableLibraryCacheInfo"/>.
         /// </remarks>
-        /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
+#if FEATURE_APPDOMAIN
         [Serializable]
+#endif
         internal sealed class PortableLibraryFile : DependencyFile, ITranslatable
         {
             internal string[] outputFiles;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 0c7348a73ac..0a3eb949eef 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -333,7 +333,7 @@ public override bool Execute()
             allProjectRefs = new List<ComReferenceInfo>();
             allDependencyRefs = new List<ComReferenceInfo>();
 
-            _timestampCache = (ResolveComReferenceCache)StateFileBase.DeserializeCache(StateFile, Log, typeof(ResolveComReferenceCache));
+            _timestampCache = StateFileBase.DeserializeCache<ResolveComReferenceCache>(StateFile, Log);
 
             if (_timestampCache?.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath) != true)
             {
diff --git a/src/Tasks/ResolveComReferenceCache.cs b/src/Tasks/ResolveComReferenceCache.cs
index b140ed58af7..2972c86df93 100644
--- a/src/Tasks/ResolveComReferenceCache.cs
+++ b/src/Tasks/ResolveComReferenceCache.cs
@@ -16,11 +16,7 @@ namespace Microsoft.Build.Tasks
     /// an earlier revision of a COM component, its timestamp can go back in time and we still need to regenerate its
     /// wrapper. So in ResolveComReference we compare the stored timestamp with the current component timestamp, and if 
     /// they are different, we regenerate the wrapper.
-    /// 
-    /// This is an on-disk serialization format, don't change field names or types or use readonly.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class ResolveComReferenceCache : StateFileBase, ITranslatable
     {
         /// <summary>
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 664927523f3..05c2e50efe6 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -206,7 +206,15 @@ private static void ParseData(
                         resources.Add(new BinaryFormatterByteArrayResource(name, binaryFormatterBytes, resxFilename));
                         return;
                     default:
-                        throw new NotSupportedException($"Resource \"{name}\" in \"{resxFilename}\"uses MIME type \"{mimetype}\", which is not supported by .NET Core MSBuild.");
+                        if (log is null)
+                        {
+                            throw new NotSupportedException(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("GenerateResource.MimeTypeNotSupportedOnCore", name, resxFilename, mimetype));
+                        }
+                        else
+                        {
+                            log.LogErrorFromResources("GenerateResource.MimeTypeNotSupportedOnCore", name, resxFilename, mimetype);
+                            return;
+                        }
                 }
             }
         }
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index c9326aeb55c..fdf44f5268a 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1166,10 +1166,14 @@
   </data>
   <data name="GenerateResource.BinaryFormatterUse">
     <value>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</value>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</value>
     <comment>{StrBegin="MSB3825: "}</comment>
   </data>
 
+  <data name="GenerateResource.MimeTypeNotSupportedOnCore">
+    <value>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</value>
+    <comment>{StrBegin="MSB3826: "}</comment>
+  </data>
 
   <!--
         The GetAssemblyIdentity message bucket is: MSB3441 - MSB3450
@@ -1744,7 +1748,7 @@
   <data name="ResolveAssemblyReference.TargetFrameworkSubsetLogHeader">
     <value>TargetFramework Profile List Information:</value>
   </data>
-  <data name="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+  <data name="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
     <value>TargetFramework Profile List Paths:</value>
   </data>
   <data name="ResolveAssemblyReference.TargetFrameworkRedistLogHeader">
@@ -2329,6 +2333,9 @@
   </data>
   <data name="XslTransform.UseTrustedSettings" xml:space="preserve">
     <value>The usage of the document() method and embedded scripts is prohibited by default, due to risks of foreign code execution.  If "{0}" is a trusted source that requires those constructs, please set the "UseTrustedSettings" parameter to "true" to allow their execution.</value>
+  </data>
+  <data name="XslTransform.SecuritySettingsViaUseTrustedSettings" xml:space="preserve">
+    <value>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</value>
   </data>
     <data name="XslTransform.PrecompiledXsltError" xml:space="preserve">
     <value>MSB3705: XslCompiledDllPath is not supported when building with .NET Core.</value>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index bca774edb0c..6d7ab91ff93 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Volání knihovny {0} se nezdařilo s následujícím kódem chyby: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Nepovedlo se použít pevný odkaz ke zkopírování „{0}“ do „{1}“. Místo toho se soubor kopíruje pomocí symbolického odkazu. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} je neplatný počet opakování. Hodnota nesmí být záporná.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} je neplatné zpoždění opakování. Hodnota nesmí být záporná.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Nelze odstranit soubor „{0}“. Začátek {1} opakování za {2}ms {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Vytváření souboru přesměrování vazby „{0}“.</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: Prostředek „{0}“ typu „{1}“ je deserializován prostřednictvím BinaryFormatter za běhu. BinaryFormatter je zastaralý kvůli možným bezpečnostním rizikům a odebere se s .NET 9. Pokud ho chcete používat dál, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false. 
+           Další informace: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: Nešlo zpracovat soubor {0}, protože je v zóně Internet nebo Omezené nebo má na souboru značku webu. Pokud chcete tyto soubory zpracovat, odeberte značku webu.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: Prostředek \"{0}\" v \"{1}\" používá typ MIME \"{2}\", který MSBuild při spuštění v .NET nepodporuje.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Výstupní soubor {0} neexistuje.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution je true, ale odkazovaný projekt {0} nemá nastavená metadata Platforms ani Platform. Sestaví se bez zadané platformy.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Vlastnost platformy odkazovaného projektu {0} odpovídá platformě aktuálního projektu: {1}. Odkazovaný projekt se sestaví bez globální vlastnosti platformy.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Do adresáře RemoveDir byl předán prázdný adresář a byl ignorován.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Tento odkaz není CopyLocal, protože se jedná o chybný obrázek. Může se jednat o nativní binární soubor, nebo se nemusí vůbec jednat o sestavení.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Informace o seznamu profilu TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Cesty seznamu profilu TargetFramework:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Aktualizuje se soubor mezipaměti sestavení „{0}“.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">Podepisování PFX se v .NET Core nepodporuje.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Položka je mimo cílový adresář: „{0}“</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Atribut „WriteOnlyWhenDifferent“ pro „{0}“ se projeví jenom v případě, že overwrite="true"</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath se při sestavování pomocí .NET Core nepodporuje.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Povolujete uvolněná nastavení zabezpečení XSLT prostřednictvím parametru UseTrustedSettings. Další podrobnosti o důsledcích zabezpečení tohoto nastavení najdete v https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Nelze zpracovat argument XsltParameters pro úlohu XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 02fc298ff4d..30b13e9fd4e 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Fehler beim Aufruf der {0}-Bibliothek. Fehlercode: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Es konnte kein fester Link verwendet werden, um "{0}" in "{1}" zu kopieren. Stattdessen wird die Datei mit einer symbolischen Verknüpfung kopiert. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} ist eine ungültige Anzahl von Wiederholungen. Der Wert darf nicht negativ sein.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} ist eine ungültige Wiederholungsverzögerung. Der Wert darf nicht negativ sein.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Die Datei "{0}" konnte nicht gelöscht werden. Wiederholungsversuch {1} wird in {2}ms gestartet. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Bindungsumleitungsdatei "{0}" wird erstellt.</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: Die Ressource "{0}" vom Typ "{1}" wird zur Laufzeit über BinaryFormatter deserialisiert. BinaryFormatter ist aufgrund möglicher Sicherheitsrisiken veraltet und wird mit .NET 9 entfernt. Wenn Sie sie weiterhin verwenden möchten, legen Sie die Eigenschaft "GenerateResourceWarnOnBinaryFormatterUse" auf "false" fest.
+           Weitere Informationen: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: Die Datei "{0}" konnte nicht verarbeitet werden, weil sie sich im Internet oder in der Zone eingeschränkter Websites befindet oder die Webmarkierung aufweist. Entfernen Sie die Webmarkierung, wenn Sie diese Dateien verarbeiten möchten.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: Die Ressource \"{0}\" in \"{1}\" verwendet den MIME-Typ \"{2}\", der von MSBuild bei der Ausführung unter .NET nicht unterstützt wird.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Die Ausgabedatei "{0}" ist nicht vorhanden.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution ist \"true\", aber auf das Projekt \"{0}\" wird verwiesen, für das keine \"Plattformen\"- oder \"Plattform\"-Metadaten festgelegt sind. Er wird ohne eine angegebene Plattform erstellt.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Die Plattformeigenschaft des Referenzprojekts \"{0}\" entspricht der Plattform des aktuellen Projekts: \"{1}\". Das Projekt, auf das verwiesen wird, wird ohne globale Plattformeigenschaft erstellt.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Ein leeres Verzeichnis wurde an RemoveDir übergeben und ignoriert.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Dieser Verweis ist nicht "CopyLocal", da es sich um ein ungültiges Bild handelt. Möglicherweise handelt es sich um eine native Binärdatei, oder es handelt sich überhaupt nicht um eine Assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Informationen zur TargetFramework-Profilliste:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Pfade der TargetFramework-Profilliste:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Aktualisiert Assemblycachedatei "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX-Signierung wird für .NET Core nicht unterstützt.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Der Eintrag befindet sich außerhalb des Zielverzeichnisses: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Das Attribut "WriteOnlyWhenDifferent" für "{0}" wird nur bei "Overwrite="true"" wirksam.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath wird bei der Kompilierung mit .NET Core nicht unterstützt.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Sie aktivieren lockere XSLT-Sicherheitseinstellungen über den Parameter "UseTrustedSettings". Weitere Informationen zu den Auswirkungen dieser Einstellung auf die Sicherheit finden Sie unter https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Das XsltParameters-Argument für die XslTransformation-Aufgabe kann nicht verarbeitet werden. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index e1d93e25454..c6b688f1a58 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -118,7 +118,7 @@
       </trans-unit>
       <trans-unit id="AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3654: Delay signing requires that at least a public key be specified.  Please either supply a public key using the KeyFile or KeyContainer properties, or disable delay signing.</source>
-        <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
+        <target state="translated">MSB3654: La firma retrasada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retrasada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Error en la llamada a la biblioteca {0} con el siguiente código de error: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">No se puede usar un vínculo físico para copiar "{0}" en "{1}". Se va a copiar el archivo en un vínculo simbólico su lugar. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,22 +308,22 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} no es un número de reintentos válido. El valor no puede ser negativo.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} no es un número de reintentos válido. El valor no puede ser negativo.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: No se pudo eliminar el archivo "{0}". Iniciando reintento {1} en {2}ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
-        <target state="translated">El archivo"{0}" no existe. Se omitirá.</target>
+        <target state="translated">El archivo "{0}" no existe. Se omitirá.</target>
         <note />
       </trans-unit>
       <trans-unit id="DownloadFile.DidNotDownloadBecauseOfFileMatch">
@@ -541,7 +541,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="translated">MSB3096: La tarea “{0}” solo se admite cuando se compila en Windows.</target>
+        <target state="translated">MSB3096: La tarea "{0}" solo se admite cuando se compila en Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Creando el archivo de redirección de enlace "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: El recurso "{0}" de tipo "{1}" se deserializa a través de BinaryFormatter en tiempo de ejecución. BinaryFormatter está en desuso debido a posibles riesgos de seguridad y se quitará con .NET 9. Si desea seguir usándola, establezca la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en falso.
+           Más información: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: No se puede procesar el archivo {0} porque está en Internet o en una zona restringida, o bien tiene la marca de la Web. Quite esta marca si desea procesar los archivos.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: El recurso \"{0}\" de \"{1}\" usa el tipo MIME \"{2}\", que MSBuild no admite cuando se ejecuta en .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">El archivo de salida "{0}" no existe.</target>
@@ -1285,12 +1290,12 @@
       </trans-unit>
       <trans-unit id="GenerateResource.CannotWriteAssembly">
         <source>MSB3575: GenerateResource cannot write assemblies, only read from them. Cannot create assembly "{0}".</source>
-        <target state="translated">MSB3575: GenerateResource no puede escribir ensamblados, solo leerlos. No se puede crear el ensamblado"{0}".</target>
+        <target state="translated">MSB3575: GenerateResource no puede escribir ensamblados, solo leerlos. No se puede crear el ensamblado "{0}".</target>
         <note>{StrBegin="MSB3575: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CreatingCultureInfoFailed">
         <source>MSB3576: Creating the CultureInfo failed for assembly "{2}". Note the set of cultures supported is Operating System-dependent, and the Operating System has removed some cultures from time to time (ie, some Serbian cultures are split up in Windows 7).  The culture may be a user-defined custom culture that we can't currently load on this machine.  Exception info: {0}: {1}</source>
-        <target state="translated">MSB3576: Error al crear CultureInfo para el ensamblado"{2}". Tenga en cuenta que el conjunto de referencias culturales admitido depende del sistema operativo y este ha quitado algunas referencias culturales de vez en cuando (por ejemplo, en Windows 7, algunas referencias culturales de serbio están divididas).  La referencia cultural puede ser una referencia cultural personalizada definida por el usuario que no se pueda cargar actualmente en este equipo.  Información de la excepción: {0}: {1}</target>
+        <target state="translated">MSB3576: Error al crear CultureInfo para el ensamblado "{2}". Tenga en cuenta que el conjunto de referencias culturales admitido depende del sistema operativo y este ha quitado algunas referencias culturales de vez en cuando (por ejemplo, en Windows 7, algunas referencias culturales de serbio están divididas).  La referencia cultural puede ser una referencia cultural personalizada definida por el usuario que no se pueda cargar actualmente en este equipo.  Información de la excepción: {0}: {1}</target>
         <note>{StrBegin="MSB3576: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.DuplicateOutputFilenames">
@@ -1340,7 +1345,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.CannotLoadAssemblyLoadFromFailed">
         <source>MSB3816: Loading assembly "{0}" failed. {1}</source>
-        <target state="translated">MSB3816: Error al cargar el ensamblado"{0}". {1}</target>
+        <target state="translated">MSB3816: Error al cargar el ensamblado "{0}". {1}</target>
         <note>{StrBegin="MSB3816: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.MainAssemblyMissingNeutralResourcesLanguage">
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution es true, pero el proyecto al que se hace referencia, “{0}”, no tiene establecido ningún conjunto de metadatos “Platforms” o “Platform”. Se compilará sin una plataforma especificada.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">La propiedad “Platform” del proyecto al que se hace referencia “{0}” coincide con la plataforma del proyecto actual: “{1}”. El proyecto al que se hace referencia se compilará sin una propiedad de plataforma global.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Se pasó un directorio vacío a RemoveDir y se omitió.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Esta referencia no es "CopyLocal" porque es una imagen incorrecta. Puede ser un binario nativo o no ser un ensamblado.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Información de listas de perfiles de TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Rutas de acceso de listas de perfiles de TargetFramework:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Actualizando el archivo de caché de ensamblado "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2272,7 +2277,7 @@
       </trans-unit>
       <trans-unit id="ResolveComReference.LoadingDelaySignedAssemblyWithStrongNameVerificationEnabled">
         <source>MSB3295: Failed to load an assembly. Please make sure you have disabled strong name verification for your public key if you want to generate delay signed wrappers. {0}</source>
-        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma retardada. {0}</target>
+        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma con retraso. {0}</target>
         <note>{StrBegin="MSB3295: "}</note>
       </trans-unit>
       <trans-unit id="ResolveComReference.MissingOrUnknownComReferenceAttribute">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">No se admite la firma PFX en .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2481,7 +2486,7 @@
       </trans-unit>
       <trans-unit id="StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3353: Public key necessary for delay signing was not specified.</source>
-        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma retardada.</target>
+        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma con retraso.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
@@ -2576,12 +2581,12 @@
       </trans-unit>
       <trans-unit id="UnregisterAssembly.UnregisterTlbCantLoadFile">
         <source>MSB3397: Cannot unregister type library "{0}" - cannot load file, check to make sure it's a valid type library.</source>
-        <target state="translated">MSB3397: No se puede anular el registro de la biblioteca de tipos ""{0}"". No se puede cargar el archivo. Asegúrese de que es una biblioteca de tipos válida.</target>
+        <target state="translated">MSB3397: No se puede anular el registro de la biblioteca de tipos "{0}". No se puede cargar el archivo. Asegúrese de que es una biblioteca de tipos válida.</target>
         <note>{StrBegin="MSB3397: "}</note>
       </trans-unit>
       <trans-unit id="UnregisterAssembly.UnregisterTlbFileDoesNotExist">
         <source>Cannot unregister type library "{0}" - file doesn't exist.</source>
-        <target state="translated">No puede anularse el registro de la biblioteca de tipos ""{0}"". El archivo no existe.</target>
+        <target state="translated">No puede anularse el registro de la biblioteca de tipos "{0}". El archivo no existe.</target>
         <note />
       </trans-unit>
       <trans-unit id="UnregisterAssembly.UnregisterTlbFileNotRegistered">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">La entrada está fuera del directorio de destino: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">El atributo 'WriteOnlyWhenDifferent' de "{0}" solo surte efecto cuando 'Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: No se admite XslCompiledDllPath cuando se compila con .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Está habilitando la configuración de seguridad XSLT relajada mediante el parámetro UseTrustedSettings. Para obtener más información sobre las implicaciones de seguridad de esta configuración, consulte https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: No se puede procesar el argumento XsltParameters para la tarea XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 3d90e34c124..f17956ba2d6 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">L’appel de bibliothèque {0} a échoué avec le code d’erreur suivant : {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Impossible d’utiliser un lien physique pour copier «{0}» vers «{1}». Copie du fichier avec un lien symbolique à la place. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} n'est pas un nombre de nouvelles tentatives valide. La valeur ne doit pas être négative.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} n'est pas un délai de nouvelle tentative valide. La valeur ne doit pas être négative.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Impossible de supprimer le fichier "{0}« . Début du {1} de nouvelles tentatives en {2}ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Création du fichier de redirection de liaison «{0}».</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: La ressource «{0}» de type «{1}» est désérialisée via BinaryFormatter au moment de l’exécution. BinaryFormatter est déconseillé en raison de risques de sécurité possibles et sera supprimé avec .NET 9. Si vous souhaitez continuer à l’utiliser, définissez la propriété « GenerateResourceWarnOnBinaryFormatterUse » sur false.
+           Plus d’informations : https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: Impossible de traiter le fichier {0} car il se trouve dans la zone Internet ou Restreinte ou il contient Mark of the Web. Pour traiter ces fichiers, supprimez Mark of the Web.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: La ressource \"{0}\" dans \"{1}\" utilise le type MIME \"{2}\", qui n’est pas pris en charge par MSBuild lors de l’exécution sur .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Le fichier de sortie "{0}" n'existe pas.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution a la valeur true, mais le projet référencé '{0}' n’a pas de métadonnées 'Platforms' ou 'Platform' définies. Il sera généré sans plateforme spécifiée.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">La propriété platform du '{0}' de projet référencé correspond à la plateforme du projet actuel : '{1}'. Le projet référencé sera généré sans propriété De plateforme globale.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Un répertoire vide a été passé à RemoveDir et a été ignoré.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Cette référence n’est pas « CopyLocal », car il s’agit d’une image incorrecte. Il peut s’agir d’un fichier binaire natif ou d’un assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Informations de listes de profil TargetFramework :</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Chemins d'accès de listes de profil TargetFramework :</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Mise à jour du fichier de cache d’assembly «{0}».</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">La signature PFX n’est pas prise en charge sur .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">L’entrée se trouve en dehors du répertoire cible : «{0}»</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">L’attribut 'WriteOnlyWhenDifferent' sur "{0}" prend effet uniquement quand 'Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath n'est pas pris en charge lors de la génération avec .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Vous activez des paramètres de sécurité XSLT souples via le paramètre UseTrustedSettings. Pour plus d’informations sur les implications en matière de sécurité de ce paramètre, consultez https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Impossible de traiter l'argument XsltParameters de la tâche XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 6f5a9844c92..25da14abc43 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">La chiamata alla libreria {0} non è riuscita con il codice di errore seguente: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Impossibile utilizzare un collegamento reale per copiare "{0}" in "{1}". Verrà invece copiato il file con collegamento simbolico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} non corrisponde a un numero di tentativi valido. Il valore non deve essere negativo.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} non corrisponde a un ritardo del tentativo valido. Il valore non deve essere negativo.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: non è stato possibile eliminare il file "{0}". Inizio dei tentativi {1} in {2}ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Creazione del file di reindirizzamento del binding "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: la risorsa "{0}" di tipo "{1}" viene deserializzata tramite BinaryFormatter in fase di esecuzione. BinaryFormatter è deprecato a causa di possibili rischi per la sicurezza e verrà rimosso con .NET 9. Per continuare a utilizzarla, impostare la proprietà "GenerateResourceWarnOnBinaryFormatterUse" su false.
+           Altre informazioni: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: non è stato possibile elaborare il file {0} perché si trova nell'area Internet o Siti con restrizioni o presenta il contrassegno del Web. Rimuovere il contrassegno del Web se si intende elaborare questi file.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: la risorsa \"{0}\" in \"{1}\" usa il tipo MIME \"{2}\", che non è supportato da MSBuild durante l'esecuzione in .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Il file di output "{0}" non esiste.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution è true, ma il progetto di riferimento '{0}' non ha set di metadati 'Platforms' o 'Platform'. Verrà compilato senza una piattaforma specificata.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">La proprietà Platform del progetto di riferimento '{0}' corrisponde alla proprietà Platform del progetto corrente: '{1}'. Il progetto a cui viene fatto riferimento verrà compilato senza una proprietà Platform globale.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: una directory vuota è stata passata a RemoveDir ed è stata ignorata.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Questo riferimento non è "CopyLocal" perché è un'immagine non valida. Potrebbe essere un file binario nativo o non essere affatto un assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Informazioni sull'elenco di profili TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Percorsi dell'elenco di profili TargetFramework:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Aggiornamento del file della cache di assembly "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">La firma PFX non è supportata in .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Il valore immesso non è compreso nella directory di destinazione: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">L'attributo 'WriteOnlyWhenDifferent' su "{0}" ha effetto solo quando 'Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath non è supportato quando si compila con .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Si stanno abilitando impostazioni di sicurezza XSLT flessibili tramite il parametro UseTrustedSettings. Per altri dettagli sulle implicazioni di sicurezza di questa impostazione, vedere https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: non è possibile elaborare l'argomento XsltParameters per l'attività XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index c6e45115596..5649ff6e95e 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">{0} ライブラリの呼び出しは次のエラー コードで失敗しました: {1}。</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">ハード リンクを使用して "{0}" を "{1}" にコピーできませんでした。代わりにシンボリック リンクを使用してファイルをコピーしています。 {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} は無効な再試行回数です。値を負にすることはできません。</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} は無効な再試行遅延です。値を負にすることはできません。</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: ファイル "{0}" を削除できませんでした。{1} の再試行を {2}ミリ秒で開始します。{3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">バインド リダイレクト ファイル "{0}" を作成しています。</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: "{0}" 型のリソース "{1}" は、実行時に BinaryFormatter を介して逆シリアル化されます。BinaryFormatter は、セキュリティ上のリスクが発生する可能性があるため非推奨であり、.NET 9 を使用して削除されます。引き続き使用する場合は、プロパティ "GenerateResourceWarnOnBinaryFormatterUse" を false に設定してください。
+           詳細情報: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: ファイル {0} を処理できませんでした。インターネットまたは制限付きゾーン内にあるか、ファイルに Web のマークがあるためです。これらのファイルを処理するには、Web のマークを削除してください。</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" のリソース \"{0}\" は MIME の種類 \"{2}\" を使用します。これは、.NET で実行されている場合、MSBuild ではサポートされていません。</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">出力ファイル "{0}" は存在しません。</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution は true ですが、参照対象プロジェクト '{0}' に 'Platforms' または 'Platform' メタデータが設定されていません。これは、指定されたプラットフォームなしでビルドされます。</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">参照されたプロジェクト '{0}' の Platform プロパティは現在のプロジェクトのプラットフォーム '{1}' と一致します。参照されたプロジェクトは、グローバル Platform プロパティなしでビルドされます。</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: 空のディレクトリが RemoveDir に渡され、無視されました。</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">この参照は無効なイメージであるため、"CopyLocal" ではありません。ネイティブ バイナリであるか、アセンブリではない可能性があります。</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">TargetFramework プロファイルのリスト情報:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework プロファイルのリストのパス:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">アセンブリ キャッシュ ファイル "{0}" を更新しています。</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX 署名は .NET Core ではサポートされていません。</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">エントリがターゲット ディレクトリの外部にあります: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}" の 'WriteOnlyWhenDifferent' 属性は、'Overwrite="true"' の場合にのみ有効になります。</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath は、.NET Core を使用してビルドしている場合サポートされません。</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">UseTrustedSettings パラメーターを使用して、緩和された XSLT セキュリティ設定を有効にしています。この設定のセキュリティへの影響の詳細については、https://aka.ms/msbuild/xsltransformation-task を参照してください</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: XslTransformation タスクの XsltParameters 引数を処理できません。{0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 247e0bd0d38..1a1f4416e11 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">오류 코드 {1}(으)로 인해 {0} 라이브러리 호출이 실패했습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">하드 링크를 사용하여 "{0}(를) "{1}"에 복사할 수 없습니다. 대신 바로 가기 링크로 파일을 복사합니다. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0}은(는) 잘못된 재시도 횟수입니다. 값은 음수일 수 없습니다.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0}은(는) 잘못된 재시도 간격입니다. 값은 음수일 수 없습니다.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: "{0}" 파일을 삭제할 수 없습니다. {2} ms에서 다시 시도 {1}을(를) 시작합니다. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">바인딩 리디렉션 파일 "{0}"을(를) 만드는 중입니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: "{1}" 유형의 "{0}" 리소스가 런타임 시 BinaryFormatter를 통해 역직렬화됩니다. BinaryFormatter는 가능한 보안 위험으로 인해 사용되지 않으며 .NET 9에서 제거됩니다. 계속 사용하려면 "GenerateResourceWarnOnBinaryFormatterUse" 속성을 false로 설정하세요.
+            추가 정보: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: {0} 파일은 인터넷 또는 제한 영역에 있거나 파일에 웹 표시가 있으므로 처리할 수 없습니다. 이러한 파일을 처리하려면 웹 표시를 제거하세요.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\"의 리소스 \"{0}\"은(는) .NET에서 실행할 때 MSBuild에서 지원하지 않는 MIME 형식 \"{2}\"을 사용합니다.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">출력 파일 "{0}"이(가) 없습니다.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution이 true이지만 참조된 프로젝트 '{0}'에 'Platforms' 또는 'Platform' 메타데이터 세트가 없습니다. 지정된 플랫폼 없이 구축됩니다.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">참조된 프로젝트 '{0}'의 플랫폼 속성이 현재 프로젝트의 플랫폼 '{1}'과(와) 일치합니다. 참조된 프로젝트는 전역 Platform 속성 없이 빌드됩니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: 빈 디렉터리가 RemoveDir에 전달되어 무시되었습니다.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">이 참조는 잘못된 이미지이므로 "CopyLocal"이 아닙니다. 네이티브 이진이거나 어셈블리가 아닐 수 있습니다.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">TargetFramework 프로필 목록 정보:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework 프로필 목록 경로:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">어셈블리 캐시 파일 "{0}"을(를) 업데이트하는 중입니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX 서명은 .NET Core에서 지원되지 않습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">항목이 대상 디렉터리 "{0}" 외부에 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}"의 'WriteOnlyWhenDifferent' 특성은 'Overwrite="true"'인 경우에만 적용됩니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath는 .NET Core로 빌드할 때 지원되지 않습니다.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">UseTrustedSettings 매개 변수를 통해 완화된 XSLT 보안 설정을 사용하도록 설정합니다. 이 설정의 보안 영향에 대한 자세한 내용은 https://aka.ms/msbuild/xsltransformation-task를 참조하세요.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: XslTransformation 작업에 대해 XsltParameters 인수를 처리할 수 없습니다. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 556b24e7acc..1b21b90581d 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Wywołanie biblioteki {0} nie powiodło się. Kod błędu: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Nie można użyć twardego linku do skopiowania „{0}” do „{1}”. Zamiast tego kopiuje plik za pomocą linku symbolicznego. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} jest nieprawidłową liczbą ponownych prób. Wartość nie może być ujemna.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} jest nieprawidłowym opóźnieniem ponownych prób. Wartość nie może być ujemna.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: nie można usunąć pliku „{0}”. Rozpoczynanie ponawiania próby {1} za {2} ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Tworzenie pliku przekierowania powiązania „{0}”.</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: zasób „{0}” typu „{1}” jest deserializowany za pośrednictwem elementu BinaryFormatter w czasie wykonywania. Element BinaryFormatter jest przestarzały z powodu możliwych zagrożeń bezpieczeństwa i zostanie usunięty z platformy .NET 9. Jeśli chcesz nadal go używać, ustaw właściwość „GenerateResourceWarnOnBinaryFormatterUse” na wartość false.
+           Więcej informacji: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: Nie można przetworzyć pliku {0}, ponieważ znajduje się on w strefie Internet lub Witryny z ograniczeniami albo zawiera znacznik strony internetowej. Jeśli chcesz przetwarzać te pliki, usuń znacznik strony internetowej.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: zasób „{0}” w „{1}” używa typu MIME „{2}”, który nie jest obsługiwany przez program MSBuild w przypadku uruchamiania na platformie .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Plik wyjściowy „{0}” nie istnieje.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: element EnableDynamicPlatformResolution ma wartość True, ale projekt „{0}”, do którego się odnosi, nie ma ustawionych metadanych „Platform” lub „Platformy”. Zostanie on skompilowany bez określonej platformy.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Właściwość platformy przywoływanego projektu „{0}” jest zgodna z platformą bieżącego projektu: „{1}”. Przywoływany projekt zostanie utworzony bez globalnej właściwości platformy.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Pusty katalog został przekazany do narzędzia RemoveDir i został zignorowany.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">To odwołanie nie jest „CopyLocal”, ponieważ jest to zły obraz. Może to być natywny plik binarny lub w ogóle nie jest on zestawem.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Informacje o liście profilów TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Ścieżki listy profilów TargetFramework:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Aktualizowanie pliku pamięci podręcznej zestawu „{0}”.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">Podpisywanie PFX nie jest obsługiwane na platformie .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Wpis znajduje się poza katalogiem docelowym: „{0}”</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Atrybut „WriteOnlyWhenDifferent” w elemencie „{0}” obowiązuje tylko wtedy, gdy atrybut „Overwrite="true"”.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: Element XslCompiledDllPath nie jest obsługiwany podczas kompilowania przy użyciu platformy .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Włączasz swobodne ustawienia zabezpieczeń XSLT za pośrednictwem parametru UseTrustedSettings. Aby uzyskać więcej informacji na temat wpływu tego ustawienia na zabezpieczenia, zobacz https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Nie można przetwarzać argumentu XsltParameters dla zadania XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index ff5f0631ac6..29688c97d43 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Falha na chamada à biblioteca {0} com o seguinte código de erro: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Não foi possível usar um link físico para copiar "{0}" para "{1}". Em vez disso, copiando o arquivo com link simbólico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} é um número de novas tentativas inválido. O valor não deve ser negativo.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} é um atraso de nova tentativa inválido. O valor não deve ser negativo.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: Não foi possível excluir o arquivo "{0}". Iniciando repetição {1} em {2} ms. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Criando arquivo de redirecionamento de associação "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: o recurso "{0}" do tipo "{1}" é desserializado por meio de BinaryFormatter no runtime. O BinaryFormatter foi preterido devido a possíveis riscos de segurança e será removido com o .NET 9. Se você quiser continuar a usá-lo, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como false.
+           Mais informações: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: não foi possível processar o arquivo {0} porque ele está na Internet ou na zona restrita ou tem a marca da Web no arquivo. Remova a marca da Web se você quiser processar esses arquivos.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: O recurso \"{0}\" em \"{1}\" usa o tipo MIME \"{2}\", que não tem suporte do MSBuild ao ser executado no .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">O arquivo de saída "{0}" não existe.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution é true, mas o projeto referenciado '{0}' não tem um conjunto de metadados 'Platforms' ou 'Platform'. Ele será construído sem uma plataforma especificada.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">A propriedade de plataforma do projeto referenciado '{0}' corresponde à plataforma do projeto atual: '{1}'. O projeto referenciado será construído sem uma propriedade global Platform.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: um diretório vazio foi passado para RemoveDir e foi ignorado.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Essa referência não é "CopyLocal" porque é uma imagem inválida. Ele pode ser um binário nativo ou pode não ser um assembly.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Informações da Lista de Perfis TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Caminhos da Lista de Perfis TargetFramework:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Atualizando o arquivo de cache do assembly "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">Não há suporte para a assinatura PFX no .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">A entrada está fora do diretório de destino: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">O atributo "WriteOnlyWhenDifferent" em "{0}" entra em vigor somente quando "Overwrite="true"'.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: Não há suporte para XslCompiledDllPath ao compilar com o .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Você está habilitando configurações de segurança XSLT reduzidas por meio do parâmetro UseTrustedSettings. Para obter mais detalhes sobre as implicações de segurança dessa configuração, consulte https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Não é possível processar o argumento XsltParameters para a tarefa XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index b5f6f6d6e45..a9d39748dee 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Сбой вызова библиотеки {0}. Код ошибки: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">Не удалось использовать жесткую связь для копирования "{0}" в "{1}". Выполняется копирование файла с символьной ссылкой. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} — недопустимое число повторных попыток. Значение не должно быть отрицательным.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} — недопустимое значение задержки повторной попытки. Значение не должно быть отрицательным.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: не удалось удалить файл "{0}". Запуск повторной попытки {1} через {2} мс. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Создание файла перенаправления привязки "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: ресурс "{0}" с типом "{1}" десериализуется с помощью BinaryFormatter во время выполнения. BinaryFormatter является устаревшим в связи с возможными угрозами безопасности и будет удален с .NET 9. Чтобы продолжить использование, задайте свойству "GenerateResourceWarnOnBinaryFormatterUse" значение "false".
+           Дополнительные сведения: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: не удалось обработать файл "{0}", так как он находится в Интернете или ограниченной зоне либо имеет веб-метку. Чтобы обрабатывать такие файлы, следует удалить веб-метку.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: ресурс \"{0}\" в \"{1}\" использует тип MIME \"{2}\", который не поддерживается MSBuild при работе в .NET.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">Выходной файл "{0}" не существует.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution имеет значение true, но указанный проект ''{0}'' не имеет ''Платформы'' или набора метаданных ''Платформы''. Он будет построен без указанной платформы.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Свойство платформы указанного проекта ''{0}'' соответствует платформе текущего проекта: ''{1}''. Ссылочный проект будет построен без глобального свойства платформы.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: в RemoveDir передан пустой каталог, который был проигнорирован.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Так как эта ссылка — неверный образ, она не является "CopyLocal". Она может быть нативным двоичным кодом или может полностью не относиться к сборке.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">Данные списка профилей TargetFramework:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">Пути к списку профилей TargetFramework:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Обновление файла кэша сборки "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">Подписание PFX не поддерживается в .NET Core.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Запись находится за пределами целевого каталога: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">Атрибут "WriteOnlyWhenDifferent" в "{0}" активируется, только если "Overwrite="true"".</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: XslCompiledDllPath не поддерживается при сборке с использованием .NET Core.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">Вы включаете нестрогие параметры безопасности XSLT с помощью параметра "UseTrustedSettings". Дополнительные сведения о последствиях для безопасности этого параметра см. на странице: https://aka.ms/msbuild/xsltransformation-task.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: Не удалось обработать аргумент XsltParameters для задачи XslTransformation. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index a3895944b7c..a3888b80675 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">Kitaplık çağrısı {0} şu hata koduyla başarısız oldu: {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak için sabit bağlantı kullanılamadı. Dosya bunun yerine sembolik bağlantı ile kopyalanıyor. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} geçersiz bir yeniden deneme sayısı. Değer negatif olamaz.</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} geçersiz bir yeniden deneme gecikmesi. Değer negatif olamaz.</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: "{0}" dosyası silinemedi. {1}. yeniden deneme {2} ms içinde başlıyor. {3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">Bağlama yeniden yönlendirme dosyası "{0}" oluşturuluyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: "{1}" türündeki "{0}" kaynağı, çalışma zamanında BinaryFormatter aracılığıyla seri durumdan çıkarılır. BinaryFormatter, olası güvenlik riskleri nedeniyle kullanım dışı bırakıldı ve .NET 9 ile kaldırılacak. Kullanmaya devam etmek istiyorsanız, "GenerateResourceWarnOnBinaryFormatterUse" özelliğini false olarak ayarlayın.
+           Daha fazla bilgi: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: {0} dosyası İnternet’te veya Kısıtlı bölgede olduğu ya da dosyada web işaretine sahip olduğu için işlenemedi. Bu dosyaları işlemek istiyorsanız web işaretlerini kaldırın.</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" öğesindeki \"{0}\" kaynağı .NET üzerinde çalışırken MSBuild tarafından desteklenmeyen \"{2}\" MIME türünü kullanıyor.</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">"{0}" çıkış dosyası yok.</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution doğru ancak başvurulan proje '{0}', 'Platforms' veya 'Platform' meta veri kümesine sahip değil. Proje belirli bir platform olmadan oluşturulur.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">Başvurulan '{0}' projesinin platform özelliği mevcut projenin platformuyla eşleşiyor: '{1}'. Başvurulan proje, genel bir Platform özelliği olmadan oluşturulur.</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: Boş bir dizin RemoveDir’e aktarıldı ve yoksayıldı.</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">Hatalı bir görüntü olduğundan bu başvuru "CopyLocal" değil. Yerel bir ikili olabilir veya bütünleştirilmiş kod olmayabilir.</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">TargetFramework Profil Listesi Bilgisi:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework Profil Listesi Yolları:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">Derleme önbelleği dosyası "{0}" güncelleştiriliyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">PFX imzalama .NET Core üzerinde desteklenmiyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">Girdi, hedef dizinin dışında: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}" üzerindeki 'WriteOnlyWhenDifferent' özniteliği, yalnızca 'Overwrite="true"' olduğunda etkili olur.</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: .NET Core ile derlenirken XslCompiledDllPath desteklenmez.</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">UseTrustedSettings parametresi aracılığıyla esnek XSLT güvenlik ayarlarını etkinleştiriyorsunuz. Bu ayarın güvenlik üzerindeki etkileri hakkında daha fazla bilgi için lütfen https://aka.ms/msbuild/xsltransformation-task adresine bakın.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: XslTransformation görevi için XsltParameters bağımsız değişkeni işlenemiyor. {0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.xlf b/src/Tasks/Resources/xlf/Strings.xlf
index c4900cd99f9..d3e5dbba7d6 100644
--- a/src/Tasks/Resources/xlf/Strings.xlf
+++ b/src/Tasks/Resources/xlf/Strings.xlf
@@ -1511,7 +1511,7 @@
         <source>TargetFramework Profile List Information:</source>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <note />
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 90455729587..03f075ffd8f 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">{0} 库调用失败，错误代码如下: {1}。</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">无法使用硬链接将“{0}”复制到“{1}”。改为使用符号链接复制文件。 {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} 是无效的重试计数。值不能为负数。</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} 是无效的重试延迟时间。值不能为负数。</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: 无法删除文件“{0}”。 {2} 毫秒后开始重试 {1}。{3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">正在创建绑定重定向文件“{0}”。</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: “{1}”类型的资源“{0}”在运行时通过 BinaryFormatter 进行反序列化。由于可能存在安全风险，BinaryFormatter 已被弃用，并将使用 .NET 9 移除它。如果要继续使用它，请将属性 "GenerateResourceWarnOnBinaryFormatterUse" 设置为 false。
+           详细信息: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: 无法处理文件 {0}，因为它位于 Internet 或受限区域中，或者文件上具有 Web 标记。要想处理这些文件，请删除 Web 标记。</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" 中的资源 \"{0}\" 使用 MIME 类型 \"{2}\"，这在 .NET 上运行时不受 MSBuild 支持。</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">输出文件“{0}”不存在。</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution 为 true，但引用的项目 \"{0}\" 没有设置 \"Platforms\" 或 \"Platform\" 元数据。它将在没有指定平台的情况下生成。</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">引用项目 \"{0}\" 的平台属性与当前项目的平台 \"{1}\" 匹配。将在不使用全局平台属性的情况下生成引用的项目。</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: 已向 RemoveDir 传递一个空目录，并且已被忽略。</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">此引用不是“CopyLocal”，因为它是错误的图像。它可能是本机二进制文件，或者根本不是程序集。</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">TargetFramework 配置文件列表信息:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework 配置文件列表路径:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">正在更新程序集缓存文件“{0}”。</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">.NET Core 不支持 PFX 签名。</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">条目在目标目录:“{0}”之外</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">只有当 “'Overwrite="true"”时，“{0}”上的 “WriteOnlyWhenDifferent”特性才会生效。</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: 使用 .NET Core 生成时不支持 XslCompiledDllPath。</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">正在通过 UseTrustedSettings 参数启用宽松的 XSLT 安全设置。有关此设置的安全含义的详细信息，请参阅 https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: 无法处理 XslTransformation 任务的 XsltParameters 参数。{0}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 7b9058dccae..e10b6185596 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -188,7 +188,7 @@
       </trans-unit>
       <trans-unit id="Copy.NonWindowsLinkErrorMessage">
         <source>The {0} library call failed with the following error code: {1}.</source>
-        <target state="new">The {0} library call failed with the following error code: {1}.</target>
+        <target state="translated">{0} 媒體庫呼叫失敗，發生下列錯誤碼: {1}。</target>
         <note />
       </trans-unit>
       <trans-unit id="Copy.RetryingAsFileCopy">
@@ -208,7 +208,7 @@
       </trans-unit>
       <trans-unit id="Copy.RetryingAsSymbolicLink">
         <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
-        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <target state="translated">無法使用永久連結將 "{0}" 複製到 "{1}"。請改為使用符號連結複製檔案。{2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
@@ -308,17 +308,17 @@
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
-        <target state="new">MSB3028: {0} is an invalid retry count. Value must not be negative.</target>
+        <target state="translated">MSB3028: {0} 是無效的重試計數。值不得為負數。</target>
         <note>{StrBegin="MSB3028: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryDelay">
         <source>MSB3029: {0} is an invalid retry delay. Value must not be negative.</source>
-        <target state="new">MSB3029: {0} is an invalid retry delay. Value must not be negative.</target>
+        <target state="translated">MSB3029: {0} 是無效的重試延遲。值不得為負數。</target>
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
         <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="new">MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</target>
+        <target state="translated">MSB3062: 無法刪除檔案 "{0}"。將在 {2} 毫秒內開始重試 {1}。{3}</target>
         <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
@@ -626,7 +626,7 @@
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
         <source>Creating binding redirection file "{0}".</source>
-        <target state="new">Creating binding redirection file "{0}".</target>
+        <target state="translated">建立連結重新導向檔案 "{0}"。</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
@@ -1046,9 +1046,9 @@
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
-        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
-           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+           More information: https://aka.ms/msbuild/net8-binaryformatter</source>
+        <target state="translated">MSB3825: 類型 "{1}" 的資源 "{0}" 在執行階段透過 BinaryFormatter 還原序列化。BinaryFormatter 已因可能的安全性風險而被取代，並將隨著 .NET 9 移除。如果您要繼續使用它，請將屬性 "GenerateResourceWarnOnBinaryFormatterUse" 設定為 false。
+           詳細資訊: https://aka.ms/msbuild/net8-binaryformatter</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
@@ -1081,6 +1081,11 @@
         <target state="translated">MSB3821: 因為檔案 {0} 位於網際網路或是限制區域上，或是檔案上標有 Web 字樣，所以無法處理該檔案。若希望處理這些檔案，請移除 Web 字樣。</target>
         <note>{StrBegin="MSB3821: "} "Internet zone", "Restricted zone", and "mark of the web" are Windows concepts that may have a specific translation.</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.MimeTypeNotSupportedOnCore">
+        <source>MSB3826: Resource \"{0}\" in \"{1}\" uses MIME type \"{2}\", which is not supported by MSBuild when running on .NET.</source>
+        <target state="translated">MSB3826: \"{1}\" 中的資源 \"{0}\" 使用 MIME 類型 \"{2}\"，MSBuild 在 .NET 上執行時不支援此類型。</target>
+        <note>{StrBegin="MSB3826: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.OutputDoesntExist">
         <source>Output file "{0}" does not exist.</source>
         <target state="translated">輸出檔 "{0}" 不存在。</target>
@@ -1400,12 +1405,12 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
+        <target state="translated">MSB3982: EnableDynamicPlatformResolution 為 true，但參考的專案 '{0}' 未設定 'Platforms' 或 'Platform' 中繼資料。它將在沒有指定平台的情況下建置。</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
         <source>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</source>
-        <target state="new">Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</target>
+        <target state="translated">參考專案的平台屬性 '{0}' 符合目前專案的平太: '{1}'。將建置參考的專案，但不使用全域平台屬性。</target>
         <note />
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.SamePlatform">
@@ -1591,7 +1596,7 @@
       </trans-unit>
       <trans-unit id="RemoveDir.EmptyPath">
         <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
-        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <target state="translated">MSB3232: 已傳遞空白目錄至 RemoveDir 並已加以略過。</target>
         <note>{StrBegin="MSB3232: "}</note>
       </trans-unit>
       <trans-unit id="RemoveDir.Error">
@@ -1651,7 +1656,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
         <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
-        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <target state="translated">此參考不是 "CopyLocal"，因為它是錯誤的映像。它可能是原生二進位檔案，或可能完全不是組件。</target>
         <note>
       LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
     </note>
@@ -2120,7 +2125,7 @@
         <target state="translated">TargetFramework 設定檔清單資訊:</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.TargetFrameworkWhiteListLogHeader">
+      <trans-unit id="ResolveAssemblyReference.TargetFrameworkAllowListLogHeader">
         <source>TargetFramework Profile List Paths:</source>
         <target state="translated">TargetFramework 設定檔清單資路徑:</target>
         <note />
@@ -2147,7 +2152,7 @@
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
         <source>Updating assembly cache file "{0}".</source>
-        <target state="new">Updating assembly cache file "{0}".</target>
+        <target state="translated">更新組件快取檔案 "{0}"。</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
@@ -2372,7 +2377,7 @@
       </trans-unit>
       <trans-unit id="ResolveKeySource.PfxUnsupported">
         <source>PFX signing not supported on .NET Core.</source>
-        <target state="new">PFX signing not supported on .NET Core.</target>
+        <target state="translated">.NET Core 上不支援 PFX 簽署。</target>
         <note />
       </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
@@ -2646,7 +2651,7 @@
       </trans-unit>
       <trans-unit id="Unzip.ZipSlipExploit">
         <source>Entry is outside the target directory: "{0}"</source>
-        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <target state="translated">項目位於目標目錄外部: "{0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
@@ -2726,7 +2731,7 @@
       </trans-unit>
       <trans-unit id="WriteLinesToFile.UnusedWriteOnlyWhenDifferent">
         <source>'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</source>
-        <target state="new">'WriteOnlyWhenDifferent' attribute on "{0}" takes effect only when 'Overwrite="true"'.</target>
+        <target state="translated">"{0}" 上的 'WriteOnlyWhenDifferent' 屬性只會在 'Overwrite="true" 時生效。</target>
         <note />
       </trans-unit>
       <trans-unit id="Xaml.DuplicatePropertyName">
@@ -2804,6 +2809,11 @@
         <target state="translated">MSB3705: 在使用 .NET Core 建置時，不支援 XslCompiledDllPath。</target>
         <note>{StrBegin="MSB3705: "}</note>
       </trans-unit>
+      <trans-unit id="XslTransform.SecuritySettingsViaUseTrustedSettings">
+        <source>You are enabling relaxed XSLT security settings via the UseTrustedSettings parameter. For more details on security implications of this setting please see https://aka.ms/msbuild/xsltransformation-task</source>
+        <target state="translated">您正在透過 UseTrustedSettings 參數啟用寬鬆的 XSLT 安全性設定。如需此設定安全性含意的詳細資料，請參閱 https://aka.ms/msbuild/xsltransformation-task</target>
+        <note />
+      </trans-unit>
       <trans-unit id="XslTransform.XsltArgumentsError">
         <source>MSB3702: Unable to process the XsltParameters argument for the XslTransformation task. {0}</source>
         <target state="translated">MSB3702: 無法處理 XslTransformation 工作的 XsltParameters 引數。{0}</target>
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 6b18c794e8f..96a4e7d7ce8 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -15,8 +15,6 @@ namespace Microsoft.Build.Tasks
     /// <remarks>
     /// Base class for task state files.
     /// </remarks>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal abstract class StateFileBase
     {
         // Current version for serialization. This should be changed when breaking changes
@@ -30,10 +28,15 @@ internal abstract class StateFileBase
         // Version this instance is serialized with.
         private byte _serializedVersion = CurrentSerializationVersion;
 
+        /// <summary>
+        /// True if <see cref="SerializeCache"/> should create the state file and serialize ourselves, false otherwise.
+        /// </summary>
+        internal virtual bool HasStateToSave => true;
+
         /// <summary>
         /// Writes the contents of this object out to the specified file.
         /// </summary>
-        internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
+        internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState = false)
         {
             try
             {
@@ -44,11 +47,14 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
                         File.Delete(stateFile);
                     }
 
-                    using (var s = new FileStream(stateFile, FileMode.CreateNew))
+                    if (serializeEmptyState || HasStateToSave)
                     {
-                        var translator = BinaryTranslator.GetWriteTranslator(s);
-                        translator.Translate(ref _serializedVersion);
-                        Translate(translator);
+                        using (var s = new FileStream(stateFile, FileMode.CreateNew))
+                        {
+                            var translator = BinaryTranslator.GetWriteTranslator(s);
+                            translator.Translate(ref _serializedVersion);
+                            Translate(translator);
+                        }
                     }
                 }
             }
@@ -67,9 +73,9 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// <summary>
         /// Reads the specified file from disk into a StateFileBase derived object.
         /// </summary>
-        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType)
+        internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) where T : StateFileBase
         {
-            StateFileBase retVal = null;
+            T retVal = null;
 
             // First, we read the cache from disk if one exists, or if one does not exist, we create one.
             try
@@ -78,7 +84,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                 {
                     using (FileStream s = File.OpenRead(stateFile))
                     {
-                        using var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(s, InterningBinaryReader.PoolingBuffer);
 
                         byte version = 0;
                         translator.Translate(ref version);
@@ -90,21 +96,20 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                             return null;
                         }
 
-                        var constructors = requiredReturnType.GetConstructors();
+                        var constructors = typeof(T).GetConstructors();
                         foreach (var constructor in constructors)
                         {
                             var parameters = constructor.GetParameters();
                             if (parameters.Length == 1 && parameters[0].ParameterType == typeof(ITranslator))
                             {
-                                retVal = constructor.Invoke(new object[] { translator }) as StateFileBase;
+                                retVal = constructor.Invoke(new object[] { translator }) as T;
                             }
                         }
 
-                        if (retVal == null || !requiredReturnType.IsInstanceOfType(retVal))
+                        if (retVal == null)
                         {
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
                                 log.FormatResourceString("General.IncompatibleStateFileType"));
-                            retVal = null;
                         }
                     }
                 }
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 9e174d054ca..8774ba6773b 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -22,8 +22,6 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Class is used to cache system state.
     /// </summary>
-    /// Serializable should be included in all state files. It permits BinaryFormatter-based calls, including from GenerateResource, which we cannot move off BinaryFormatter.
-    [Serializable]
     internal sealed class SystemState : StateFileBase, ITranslatable
     {
         /// <summary>
@@ -33,10 +31,21 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         private Dictionary<string, FileState> upToDateLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
-        /// Cache at the SystemState instance level. It is serialized and reused between instances.
+        /// Cache at the SystemState instance level.
         /// </summary>
+        /// <remarks>
+        /// Before starting execution, RAR attempts to populate this field by deserializing a per-project cache file. During execution,
+        /// <see cref="FileState"/> objects that get actually used are inserted into <see cref="instanceLocalOutgoingFileStateCache"/>.
+        /// After execution, <see cref="instanceLocalOutgoingFileStateCache"/> is serialized and written to disk if it's different from
+        /// what we originally deserialized into this field.
+        /// </remarks>
         internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
+        /// <summary>
+        /// Cache at the SystemState instance level. It is serialized to disk and reused between instances via <see cref="instanceLocalFileStateCache"/>.
+        /// </summary>
+        internal Dictionary<string, FileState> instanceLocalOutgoingFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
         /// cache this for long periods of time since there's no way (without actually 
@@ -106,7 +115,6 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// <summary>
         /// Class that holds the current file state.
         /// </summary>
-        [Serializable]
         internal sealed class FileState : ITranslatable
         {
             /// <summary>
@@ -210,6 +218,16 @@ internal FrameworkName FrameworkNameAttribute
                 get { return frameworkName; }
                 set { frameworkName = value; }
             }
+
+            /// <summary>
+            /// The last-modified value to use for immutable framework files which we don't do I/O on.
+            /// </summary>
+            internal static DateTime ImmutableFileLastModifiedMarker => DateTime.MaxValue;
+
+            /// <summary>
+            /// It is wasteful to persist entries for immutable framework files.
+            /// </summary>
+            internal bool IsWorthPersisting => lastModified != ImmutableFileLastModifiedMarker;
         }
 
         /// <summary>
@@ -248,7 +266,7 @@ public override void Translate(ITranslator translator)
             }
 
             translator.TranslateDictionary(
-                ref instanceLocalFileStateCache,
+                ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,
                 StringComparer.OrdinalIgnoreCase,
                 (ITranslator t) => new FileState(t));
 
@@ -257,8 +275,11 @@ public override void Translate(ITranslator translator)
             IsDirty = false;
         }
 
+        /// <inheritdoc />
+        internal override bool HasStateToSave => instanceLocalOutgoingFileStateCache.Count > 0;
+
         /// <summary>
-        /// Flag that indicates
+        /// Flag that indicates that <see cref="instanceLocalFileStateCache"/> has been modified.
         /// </summary>
         /// <value></value>
         internal bool IsDirty
@@ -335,11 +356,11 @@ internal GetAssemblyRuntimeVersion CacheDelegate(GetAssemblyRuntimeVersion getAs
             return GetRuntimeVersion;
         }
 
-        private FileState GetFileState(string path)
+        internal FileState GetFileState(string path)
         {
             // Looking up an assembly to get its metadata can be expensive for projects that reference large amounts
             // of assemblies. To avoid that expense, we remember and serialize this information betweeen runs in
-            // XXXResolveAssemblyReferencesInput.cache files in the intermediate directory and also store it in an
+            // <ProjectFileName>.AssemblyReference.cache files in the intermediate directory and also store it in an
             // process-wide cache to share between successive builds.
             //
             // To determine if this information is up-to-date, we use the last modified date of the assembly, however,
@@ -365,19 +386,30 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             bool isInstanceFileStateUpToDate = isCachedInInstance && lastModified == cachedInstanceFileState.LastModified;
             bool isProcessFileStateUpToDate = isCachedInProcess && lastModified == cachedProcessFileState.LastModified;
 
-            // If the process-wide cache contains an up-to-date FileState, always use it
+            // If the process-wide cache contains an up-to-date FileState, always use it.
             if (isProcessFileStateUpToDate)
             {
-                // For the next build, we may be using a different process. Update the file cache.
-                if (!isInstanceFileStateUpToDate)
+                // For the next build, we may be using a different process. Update the file cache if the entry is worth persisting.
+                if (cachedProcessFileState.IsWorthPersisting)
                 {
-                    instanceLocalFileStateCache[path] = cachedProcessFileState;
-                    isDirty = true;
+                    if (!isInstanceFileStateUpToDate)
+                    {
+                        instanceLocalFileStateCache[path] = cachedProcessFileState;
+                        isDirty = true;
+                    }
+
+                    // Remember that this FileState was actually used by adding it to the outgoing dictionary.
+                    instanceLocalOutgoingFileStateCache[path] = cachedProcessFileState;
                 }
                 return cachedProcessFileState;
             }
             if (isInstanceFileStateUpToDate)
             {
+                if (cachedInstanceFileState.IsWorthPersisting)
+                {
+                    // Remember that this FileState was actually used by adding it to the outgoing dictionary.
+                    instanceLocalOutgoingFileStateCache[path] = cachedInstanceFileState;
+                }
                 return s_processWideFileStateCache[path] = cachedInstanceFileState;
             }
 
@@ -399,9 +431,16 @@ private DateTime GetAndCacheLastModified(string path)
         private FileState InitializeFileState(string path, DateTime lastModified)
         {
             var fileState = new FileState(lastModified);
-            instanceLocalFileStateCache[path] = fileState;
+
+            // Dirty the instance-local cache only with entries that are worth persisting.
+            if (fileState.IsWorthPersisting)
+            {
+                instanceLocalFileStateCache[path] = fileState;
+                instanceLocalOutgoingFileStateCache[path] = fileState;
+                isDirty = true;
+            }
+
             s_processWideFileStateCache[path] = fileState;
-            isDirty = true;
 
             return fileState;
         }
@@ -450,7 +489,10 @@ private AssemblyNameExtension GetAssemblyName(string path)
                 {
                     fileState.Assembly = AssemblyNameExtension.UnnamedAssembly;
                 }
-                isDirty = true;
+                if (fileState.IsWorthPersisting)
+                {
+                    isDirty = true;
+                }
             }
 
             if (fileState.Assembly.IsUnnamedAssembly)
@@ -471,7 +513,10 @@ private string GetRuntimeVersion(string path)
             if (String.IsNullOrEmpty(fileState.RuntimeVersion))
             {
                 fileState.RuntimeVersion = getAssemblyRuntimeVersion(path);
-                isDirty = true;
+                if (fileState.IsWorthPersisting)
+                {
+                    isDirty = true;
+                }
             }
 
             return fileState.RuntimeVersion;
@@ -503,7 +548,10 @@ private void GetAssemblyMetadata(
                     out fileState.scatterFiles,
                     out fileState.frameworkName);
 
-                isDirty = true;
+                if (fileState.IsWorthPersisting)
+                {
+                    isDirty = true;
+                }
             }
 
             dependencies = fileState.dependencies;
@@ -527,7 +575,7 @@ internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles,
             foreach (ITaskItem stateFile in stateFiles)
             {
                 // Verify that it's a real stateFile. Log message but do not error if not.
-                SystemState sysState = DeserializeCache(stateFile.ToString(), log, typeof(SystemState)) as SystemState;
+                SystemState sysState = DeserializeCache<SystemState>(stateFile.ToString(), log);
                 if (sysState == null)
                 {
                     continue;
@@ -559,10 +607,10 @@ internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles,
         /// <param name="log">How to log</param>
         internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
         {
-            // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
-            // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.
-            Dictionary<string, FileState> oldFileStateCache = instanceLocalFileStateCache;
-            instanceLocalFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
+            // Save a copy of instanceLocalOutgoingFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
+            // instanceLocalOutgoingFileStateCache by default, so change that to the relativized form, then change it back.
+            Dictionary<string, FileState> oldFileStateCache = instanceLocalOutgoingFileStateCache;
+            instanceLocalOutgoingFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
 
             try
             {
@@ -574,7 +622,7 @@ internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
             }
             finally
             {
-                instanceLocalFileStateCache = oldFileStateCache;
+                instanceLocalOutgoingFileStateCache = oldFileStateCache;
             }
         }
 
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index fb74aec9202..4c297df27fd 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -53,7 +53,7 @@ public override bool Execute()
 
             if (AssemblyListFile != null)
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache));
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log);
 
                 // no cache file, nothing to do. In case there was a problem reading the cache file, we can't do anything anyway.
                 if (cacheFile == null)
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 33f00f1f19a..c2829bd8851 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -114,14 +114,14 @@ public override bool Execute()
             // Check if OutputPath has same number of parameters as xmlInputPaths.
             if (XmlInputPaths != null && XmlInputPaths.Length != _outputPaths.Length)
             {
-                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, XmlInputPaths.Length, "XmlContent", "XmlInputPaths");
+                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, XmlInputPaths.Length, "OutputPaths", "XmlInputPaths");
                 return false;
             }
 
             // Check if OutputPath has 1 parameter if xmlString is specified.
             if (XmlContent != null && _outputPaths.Length != 1)
             {
-                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, 1, "XmlContent", "OutputPaths");
+                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _outputPaths.Length, 1, "OutputPaths", "XmlContent");
                 return false;
             }
 
@@ -159,13 +159,18 @@ public override bool Execute()
             // Do the transformation.
             try
             {
+                if (UseTrustedSettings)
+                {
+                    Log.LogMessageFromResources(MessageImportance.High, "XslTransform.SecuritySettingsViaUseTrustedSettings");
+                }
+
                 for (int i = 0; i < xmlinput.Count; i++)
                 {
                     using (XmlWriter xmlWriter = XmlWriter.Create(_outputPaths[i].ItemSpec, xslct.OutputSettings))
                     {
                         using (XmlReader xr = xmlinput.CreateReader(i))
                         {
-                            xslct.Transform(xr, arguments, xmlWriter);
+                            xslct.Transform(xr, arguments, xmlWriter, new XmlUrlResolver());
                         }
 
                         xmlWriter.Close();
@@ -174,7 +179,9 @@ public override bool Execute()
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XslTransform.TransformError", e.Message);
+                string flattenedMessage = TaskLoggingHelper.GetInnerExceptionMessageString(e);
+                Log.LogErrorWithCodeFromResources("XslTransform.TransformError", flattenedMessage);
+                Log.LogMessage(MessageImportance.Low, e.ToString());
                 return false;
             }
 
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 06811207770..b40b91cd8fa 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -846,10 +846,12 @@ public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int follo
         {
             using var env = TestEnvironment.Create(_output);
 
+            MockEngine engine = new();
+
             // Task under test:
             var task = new ToolTaskThatSleeps
             {
-                BuildEngine = new MockEngine(),
+                BuildEngine = engine,
                 InitialDelay = initialDelay,
                 FollowupDelay = followupDelay,
                 Timeout = timeout
@@ -861,6 +863,9 @@ public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int follo
             {
                 // Execute the task:
                 result = task.Execute();
+
+                _output.WriteLine(engine.Log);
+
                 task.RepeatCount.ShouldBe(i);
 
                 // The first execution may fail (timeout), but all following ones should succeed:
@@ -881,8 +886,8 @@ public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int follo
         /// </remarks>
         private sealed class ToolTaskThatSleeps : ToolTask
         {
-            // PowerShell command to sleep:
-            private readonly string _powerShellSleep = "-ExecutionPolicy RemoteSigned -Command \"Start-Sleep -Milliseconds {0}\"";
+            // Windows prompt command to sleep:
+            private readonly string _windowsSleep = "/c start /wait timeout {0}";
 
             // UNIX command to sleep:
             private readonly string _unixSleep = "-c \"sleep {0}\"";
@@ -893,8 +898,8 @@ private sealed class ToolTaskThatSleeps : ToolTask
             public ToolTaskThatSleeps()
                 : base()
             {
-                // Determines shell to use: PowerShell for Windows, sh for UNIX-like systems:
-                _pathToShell = NativeMethodsShared.IsUnixLike ? "/bin/sh" : FindOnPath("PowerShell.exe");
+                // Determines shell to use: cmd for Windows, sh for UNIX-like systems:
+                _pathToShell = NativeMethodsShared.IsUnixLike ? "/bin/sh" : "cmd.exe";
             }
 
             /// <summary>
@@ -935,7 +940,7 @@ public ToolTaskThatSleeps()
             protected override string GenerateCommandLineCommands() =>
                 NativeMethodsShared.IsUnixLike ?
                 string.Format(_unixSleep, RepeatCount < 2 ? InitialDelay / 1000.0 : FollowupDelay / 1000.0) :
-                string.Format(_powerShellSleep, RepeatCount < 2 ? InitialDelay : FollowupDelay);
+                string.Format(_windowsSleep, RepeatCount < 2 ? InitialDelay / 1000.0 : FollowupDelay / 1000.0);
 
             /// <summary>
             /// Ensures that test parameters make sense.
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index 57b8c235b02..1bc7875d9a4 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Úlohu nelze přeskočit, protože není aktuální.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.de.xlf b/src/Utilities/Resources/xlf/Strings.de.xlf
index ac2253af2ef..0af0c457c9b 100644
--- a/src/Utilities/Resources/xlf/Strings.de.xlf
+++ b/src/Utilities/Resources/xlf/Strings.de.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Die Aufgabe kann nicht übersprungen werden, da sie nicht auf dem neuesten Stand ist.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.es.xlf b/src/Utilities/Resources/xlf/Strings.es.xlf
index 85a458060bd..f9486f06794 100644
--- a/src/Utilities/Resources/xlf/Strings.es.xlf
+++ b/src/Utilities/Resources/xlf/Strings.es.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">No se puede omitir la tarea porque no está actualizada.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index 4b4e3e2ce99..50d2d0ff50d 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Nous n’avons pas pu ignorer la tâche, car elle n’est pas à jour.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.it.xlf b/src/Utilities/Resources/xlf/Strings.it.xlf
index e3adf9c22fb..041eafbc30d 100644
--- a/src/Utilities/Resources/xlf/Strings.it.xlf
+++ b/src/Utilities/Resources/xlf/Strings.it.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Non è possibile ignorare l'attività perché non è aggiornata.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index c7e01f40257..18b643717e6 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">タスクは最新ではないため、スキップできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index cbc95195c50..f65456c66a9 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">작업이 최신 상태가 아니므로 건너뛸 수 없습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 62554d2c96d..15964078175 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Nie można pominąć zadania, ponieważ nie jest ono aktualne.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
index b5a62e5a024..e038f133a82 100644
--- a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Não foi possível ignorar a tarefa porque ela não está atualizada.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.ru.xlf b/src/Utilities/Resources/xlf/Strings.ru.xlf
index d3f5b246605..10f45a152d3 100644
--- a/src/Utilities/Resources/xlf/Strings.ru.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ru.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Невозможно пропустить задачу, поскольку она не обновлена.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index cf7f608206d..65439a1c618 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">Güncel olmadığı için görev atlanamıyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index e4a7a1f5090..e29b9863623 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">无法跳过任务，因为它不是最新的。</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index 6f1465f1627..30482a69ceb 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -64,7 +64,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
-        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <target state="translated">無法略過工作，因為它不是最新的。</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 09ef2296248..daee4074552 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -1398,7 +1398,7 @@ public override bool Execute()
 
                         string batchFileForCommandLine = _temporaryBatchFile;
 
-                        // If for some crazy reason the path has a & character and a space in it
+                        // If for some reason the path has a & character and a space in it
                         // then get the short path of the temp path, which should not have spaces in it
                         // and then escape the &
                         if (batchFileForCommandLine.Contains("&") && !batchFileForCommandLine.Contains("^&"))
