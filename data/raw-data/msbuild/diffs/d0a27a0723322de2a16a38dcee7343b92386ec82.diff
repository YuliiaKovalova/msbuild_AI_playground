diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 00000000000..2909e3ff6cd
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,80 @@
+{
+    // See https://go.microsoft.com/fwlink/?LinkId=733558
+    // for the documentation about the tasks.json format
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "label": "dotnet msbuild MSBuild.Dev.slnf",
+            "command": "dotnet",
+            "type": "process",
+            "args": [
+                "msbuild",
+                // Ask MSBuild to generate full paths for file names.
+                "/property:GenerateFullPaths=true",
+                // Do not generate summary otherwise it leads to duplicate errors in Problems panel
+                "/consoleloggerparameters:NoSummary",
+                "${workspaceFolder}/MSBuild.Dev.slnf"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "full build",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-bl",
+                "/property:CreateBootstrap=true",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "build -test",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-test",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": {
+                "kind": "test",
+                "isDefault": true
+            },
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        }
+    ]
+}
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index bbbf0897830..3d9fff4f089 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -7,7 +7,7 @@ jobs:
 - job: BootstrapMSBuildOnFullFrameworkWindows
   displayName: "Windows Full"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -53,7 +53,7 @@ jobs:
 - job: BootstrapMSBuildOnCoreWindows
   displayName: "Windows Core"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -100,7 +100,7 @@ jobs:
 - job: FullReleaseOnWindows
   displayName: "Windows Full Release (no bootstrap)"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild.cmd
@@ -197,7 +197,7 @@ jobs:
 - job: CoreOnMac
   displayName: "macOS Core"
   pool:
-    vmImage: 'macOS-10.14'
+    vmImage: 'macOS-latest'
   steps:
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh'
     displayName: CI Build
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 415fa36b412..c6ed508dfc8 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -52,7 +52,7 @@ stages:
 
   - job: Windows_NT
     pool:
-      name: VSEngSS-MicroBuild2019-1ES
+      name: VSEngSS-MicroBuild2022-1ES
       demands:
       - agent.os -equals Windows_NT
 
@@ -90,14 +90,14 @@ stages:
         signType: $(SignType)
         zipSources: false
       condition: and(succeeded(), in(variables['SignType'], 'test', 'real'))
-      
+
     - task: MicroBuildOptProfPlugin@6
       inputs:
         ProfilingInputsDropName: '$(VisualStudio.DropName)'
         ShouldSkipOptimize: true
         AccessToken: '$(System.AccessToken)'
         feedSource: 'https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/MicroBuildToolset/nuget/v3/index.json'
-      displayName: 'Install OptProf Plugin'      
+      displayName: 'Install OptProf Plugin'
 
     # Required by MicroBuildBuildVSBootstrapper
     - task: ms-vseng.MicroBuildTasks.32f78468-e895-4f47-962c-58a699361df8.MicroBuildSwixPlugin@1
diff --git a/documentation/Built-in-Propeties.md b/documentation/Built-in-Propeties.md
new file mode 100644
index 00000000000..01c880aeb56
--- /dev/null
+++ b/documentation/Built-in-Propeties.md
@@ -0,0 +1,21 @@
+# MSBuild's reserved and built-in properties
+
+The MSBuild engine itself sets some properties for all projects. There is normal documentation for the [reserved properties and their meanings](https://docs.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties). This document describes the implementation of these properties in MSBuild itself.
+
+There are actually two different implementations of this functionality in MSBuild.
+
+## Built-in properties
+
+When evaluating an individual project, Pass 0 of the evaluation calls [`AddBuiltInProperties()`][addbuiltinproperties] which in turn calls [`SetBuiltInProperty()`][setbuiltinproperty] which sets the property basically as normal.
+
+However, properties set there are not available at all parts of execution, and specifically they're not available when evaluating the `.tasks` file that makes MSBuild's built-in tasks available by default to all projects.
+
+## Reserved properties
+
+Reserved properties are [set by the toolset][toolset_reservedproperties] and are available _only_ in the `.tasks` and `.overridetasks` cases. Properties set there are not available in normal project evaluation.
+
+[addbuiltinproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L609-L612
+
+[setbuiltinproperty]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L1257
+
+[toolset_reservedproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Definition/Toolset.cs#L914-L921
diff --git a/documentation/Changelog.md b/documentation/Changelog.md
index 19f97e2e2e7..be02ae3e952 100644
--- a/documentation/Changelog.md
+++ b/documentation/Changelog.md
@@ -1,5 +1,104 @@
 # MSBuild Changelog
 
+## MSBuild 17.0.0
+
+This version of MSBuild shipped with Visual Studio 2022 version 17.0.0 and .NET SDK 6.0.100.
+
+### What's new
+
+* MSBuild now reports its version as `17` and uses Visual Studio 2022 versions of tasks where appropriate.
+* MSBuild now targets .NET Framework 4.7.2 and .NET 6.0.
+* 64-bit MSBuild is now used for builds from Visual Studio.
+* Binary logs are smaller and have more information.
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds.
+* The method `GetType()` can no longer be called in property functions.
+
+### Detailed release notes
+
+#### Added
+
+* Intrinsic tasks now log their location (#6397). Thanks, @KirillOsenkov!
+* `TargetSkippedEventArgs` now has `TargetSkipReason` and `OriginalBuildEventContext` (#6402, #6577). Thanks, @KirillOsenkov!
+* `TaskStarted` events now log line and column (#6399). Thanks, @KirillOsenkov!
+* ETW trace events for PerformDependencyAnalysis (#6658), WriteLinesToFile (#6670), CopyUpToDate (#6661).
+* If the environment variable `MSBuildDebugEngine` is set, MSBuild will create binary logs for all operations to `MSBUILDDEBUGPATH` regardless of how it is called (#6639, #6792).
+* `ProjectReference`s can now negotiate `Platform` (#6655, #6724, #6889).
+* Tasks can now call `TaskLoggingHelper.LogsMessagesOfImportance` to determine if any attached logger would preserve a log message before constructing it (to save time in the not-being-logged case) (#6381, #6737).
+* Support referencing assemblies with generic attributes (#6735). Thanks, @davidwrighton!
+* XSD-based MSBuild IntelliSense now supports `ImplicitUsings` and `Using` items (#6755), `InternalsVisibleTo` (#6778), Windows Forms properties (#6860), `DebugType` (#6849), and `SatelliteResourceLanguages` (#6861). Thanks, @pranavkm, @DamianEdwards, @RussKie, and @drewnoakes!
+* Tasks can now call `TaskLoggingHelper.IsTaskInputLoggingEnabled` and avoid redundant logging of inputs (#6803).
+* Support extracting resource namespace from C# source that uses file-scoped namespaces (#6881).
+
+#### Changed
+
+* The on-disk format of serialized caches has changed (#6350, #6324, #6490, #6674).
+* MSBuild is now [signed with a new certificate](https://github.com/dotnet/announcements/issues/184) (#6448).
+* `BuildParameters.DisableInprocNode` now applies to more processes (#6400).
+* `VCTargetsPath` now defaults to `v170` (#6550).
+* MSBuild no longer logs `Building with tools version "Current"` (#6627). Thanks, @KirillOsenkov!
+* Text loggers now log properties and items at the end of evaluation (#6535).
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds (#6622, #6703).
+* MSBuild on .NET 6 has improved task-assembly-reference fallback behavior (#6558).
+* MSBuild features gated on the 16.8 changewave are now nonconfigurable (#6634).
+* The deprecated import of `$(CoreCrossTargetingTargetsPath)` was removed (#6668). Thanks, @Nirmal4G!
+* Improved error message for `MSB4213` (#6640).
+* The method `GetType()` can no longer be called in property functions (#6769).
+* MSBuild is now fully NGENed by Visual Studio setup (#6764).
+* MSBuild (and Visual Studio) now reference `System.Text.Json` 5.0.2 (#6784). Thanks, @JakeRadMSFT!
+* Default to SHA2 digest for ClickOnce manifest when certificate signing algorithm is sha256/384/512 (#6882).
+
+#### Fixed
+
+* Solution builds should work when using the secret environment variable `MSBUILDNOINPROCNODE` (#6385).
+* Solution extensions can now use `BeforeTargets="ValidateSolutionConfiguration"` (#6454).
+* Performance improvements (#6529, #6556, #6598, #6632, #6669, #6671, #6666, #6678, #6680, #6705, #6595, #6716, #6786, #6816, #6832, #6845).
+* Single-file ClickOnce publish includes file association icons (#6578).
+* Improved robustness in error handling of libraries without resources (#6546).
+* Fixed missing information in `Project`'s `DebuggerDisplay` (#6650).
+* `ResolveAssemblyReferences` output paths are now output in normalized form (#6533).
+* Improved handling of satellite assemblies in ClickOnce (#6665).
+* Roslyn code analyzers are no longer run during XAML precompilation (#6676). Thanks, @jlaanstra!
+* 64-bit API callers no longer need to set `MSBUILD_EXE_PATH` (#6683, #6746).
+* `EvaluateStop` ETW events are now automatically correlated with `EvaluateStart` (#6725).
+* Evaluation time is included in text performance traces (#6725).
+* Add PackageDescription to `Microsoft.NET.StringTools` (#6740).
+* Fixed deadlock between `ExecuteSubmission` and `LoggingService` (#6717).
+* Narrowed conditions where MSBuild would blame NuGet for SDK resolution problems (#6742).
+* `CombineTargetFrameworkInfoProperties` no longer fails on portable framework names (#6699).
+* Avoid needless builds of `GenerateBindingRedirects` (#6726).
+* The solution configuration is now passed to experimental cache plugins (#6738).
+* Clearer errors when SDK resolvers throw exceptions (#6763).
+* Improved errors from `InternableString.ExpensiveConvertToString` (#6798).
+* Binding redirects for all `System.*` assemblies updated (#6830).
+* Fixed deadlock between `BuildManager` and `LoggingService` (#6837).
+* Log message arguments for warnings and errors (#6804). Thanks, @KirillOsenkov!
+* Use static CoreClrAssemblyLoader for SDK resolvers (#6864). Thanks, @marcin-krystianc!
+* Avoid break caused by fix and workaround for AL path colliding (#6884).
+* Support private-use area Unicode characters in paths passed to `XslTransformation` (#6863, #6946). Thanks, @lanfeust69!
+* Use the correct .NET host when called from a .NET 6.0 application (#6890).
+
+#### Infrastructure
+
+* This repo now builds with Arcade 6.0 (#6143).
+* Use newer Ubuntu versions for Linux CI builds (#6488).
+* MSBuild now uses [Arcade-powered source build](https://github.com/dotnet/source-build/tree/ba0b33e9f96354b8d07317c3cdf406ce666921f8/Documentation/planning/arcade-powered-source-build) (#6387).
+* Improved repo issue templates and automation (#6557).
+* Whitespace cleanup (#6565).
+* This repo no longer needs to double-specify the SDK version (#6596).
+* Simplify references to `TargetFramework` using new intrinsics (#5799).
+* Reference the `Microsoft.DotNet.XUnitExtensions` package from Arcade instead of our fork (#6638).
+* Use [`BannedApiAnalyzers`](https://www.nuget.org/packages/Microsoft.CodeAnalysis.BannedApiAnalyzers/) (#6675).
+* Enable analyzers for the MSBuild repo with rules similar to `dotnet/runtime` (#5656). Thanks, @elachlan!
+* Improved internal OptProf training scenarios (#6758).
+* Delete Unreachable code (#6805). Thanks, @KirillOsenkov!
+* Upgrade System.Net.Http package version used in tests (#6879).
+
+#### Documentation
+
+* Use GitHub-generated Markdown tables of contents (#6760).
+* Fixed validation issues in docs build (#6744).
+* Descriptions of labels in use in this repo (#6873).
+
 ## MSBuild 16.11.0
 
 This version of MSBuild shipped with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
diff --git a/global.json b/global.json
index a5953c76126..3d50b269200 100644
--- a/global.json
+++ b/global.json
@@ -4,11 +4,6 @@
   },
   "tools": {
     "dotnet": "6.0.100-rc.1.21458.32",
-    "runtimes": {
-      "dotnet/x64": [
-        "2.1.7"
-      ]
-    },
     "vs": {
       "version": "16.0"
     }
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 5323c0fd85e..3abcf608f97 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -3733,7 +3733,7 @@ public void GetAllGlobsShouldProduceGlobThatMatches(string itemContents, string[
 
             var getAllGlobsResult = ObjectModelHelpers.CreateInMemoryProject(projectContents).GetAllGlobs();
 
-            var uberGlob = new CompositeGlob(getAllGlobsResult.Select(r => r.MsBuildGlob).ToImmutableArray());
+            var uberGlob = CompositeGlob.Create(getAllGlobsResult.Select(r => r.MsBuildGlob));
 
             foreach (var matchingString in stringsThatShouldMatch)
             {
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index c31ba2c3cdb..aab3620f407 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -6,7 +6,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Engine.OM.UnitTests</AssemblyName>
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index d49cc341887..106e03beaf3 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -184,8 +184,8 @@ public void CreatableByTaskFactoryMatchingIdentity()
             SetupTaskFactory(factoryIdentityParameters, false /* don't want task host */);
 
             IDictionary<string, string> taskIdentityParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
-            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.MSBuildArchitectureValues.any);
+            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
+            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
             Assert.True(_taskFactory.TaskNameCreatableByFactory("TaskToTestFactories", taskIdentityParameters, String.Empty, null, ElementLocation.Create(".", 1, 1)));
         }
@@ -309,7 +309,7 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
             try
             {
                 IDictionary<string, string> taskParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
                 taskParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
                 createdTask = _taskFactory.CreateTaskInstance(ElementLocation.Create("MSBUILD"), null, new MockHost(), taskParameters,
@@ -406,7 +406,7 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
             try
             {
                 IDictionary<string, string> factoryParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
 
                 SetupTaskFactory(factoryParameters, false /* don't want task host */);
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 1587123afc0..761597bd4e1 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1598,7 +1598,7 @@ public void CancelledBuildWithDelay20()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST && !NO_MSBUILDTASKHOST
+#if !NO_MSBUILDTASKHOST
         // Run this test only if we expect MSBuildTaskHost to have been produced, which requires that MSBuildTaskHost.csproj
         // be built with full-framework MSBuild (so that it can target .NET 3.5).
 
@@ -1672,7 +1672,6 @@ public void CancelledBuildWithDelay40()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should
         /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
@@ -1706,7 +1705,6 @@ public void CancelledBuildInTaskHostWithDelay40()
             // Task host should not have exited prematurely
             _logger.AssertLogDoesntContain("MSB4217");
         }
-#endif
 
         /// <summary>
         /// This test verifies that builds of the same project instance in sequence are permitted.
@@ -4360,10 +4358,8 @@ public override bool Execute()
         [Theory]
         [InlineData("", false)] // regular task host, input logging disabled
         [InlineData("", true)] // regular task host, input logging enabled
-#if NETFRAMEWORK // https://github.com/microsoft/msbuild/issues/5158
         [InlineData("TaskHostFactory", false)] // OOP task host, input logging disabled
         [InlineData("TaskHostFactory", true)] // OOP task host, input logging enabled
-#endif
         public void TaskInputLoggingIsExposedToTasks(string taskFactory, bool taskInputLoggingEnabled)
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index b7d3098dd5c..2476d984cbf 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -372,12 +372,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", @"
+                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
                   </PropertyGroup>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 897b6a5751f..fa4146484e9 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -12,7 +12,6 @@ namespace Microsoft.Build.Engine.UnitTests.BackEnd
     public sealed class TaskHostFactory_Tests
     {
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/microsoft/msbuild/issues/5158")]
         [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
         {
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index e1ad11a9be0..edd37ea0144 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -21,6 +21,7 @@
 using ResourceUtilities = Microsoft.Build.Shared.ResourceUtilities;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.UnitTests.EscapingInProjects_Tests
 {
@@ -94,7 +95,6 @@ public void SemicolonInPropertyPassedIntoStringParam()
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Make sure I can define a property with escaped characters and pass it into
         /// a string parameter of a task, in this case the Message task.
@@ -117,7 +117,6 @@ public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
-#endif
 
 #if FEATURE_ASSEMBLY_LOCATION
         /// <summary>
@@ -588,7 +587,6 @@ public void ItemTransformContainingSemicolon()
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Do an item transform, where the transform expression contains an unescaped semicolon as well
         /// as an escaped percent sign.
@@ -616,7 +614,6 @@ public void ItemTransformContainingSemicolon_InTaskHost()
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
-#endif
 
         /// <summary>
         /// Tests that when we add an item and are in a directory with characters in need of escaping, and the
@@ -710,7 +707,6 @@ public void EscapedWildcardsShouldNotBeExpanded()
             }
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// If %2A (escaped '*') or %3F (escaped '?') is in an item's Include, it should be treated
         /// literally, not as a wildcard
@@ -747,7 +743,6 @@ public void EscapedWildcardsShouldNotBeExpanded_InTaskHost()
                 ObjectModelHelpers.DeleteTempProjectDirectory();
             }
         }
-#endif
 
         /// <summary>
         /// Parity with Orcas: Target names are always unescaped, and in fact, if there are two targets,
@@ -954,12 +949,13 @@ public void SemicolonInConfiguration()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1002,7 +998,6 @@ public class Class1
             logger.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\a;b'c\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Escaping in conditionals is broken.
         /// </summary>
@@ -1019,12 +1014,13 @@ public void SemicolonInConfiguration_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1071,7 +1067,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
@@ -1084,12 +1079,13 @@ public void SemicolonInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1127,7 +1123,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class;Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
         /// </summary>
@@ -1144,12 +1139,13 @@ public void SemicolonInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1191,7 +1187,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
@@ -1204,12 +1199,13 @@ public void DollarSignInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1247,7 +1243,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class$(prop)Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
         /// </summary>
@@ -1264,12 +1259,13 @@ public void DollarSignInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1311,7 +1307,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
@@ -1324,12 +1319,13 @@ public void SemicolonInSourceCodeFilename()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1367,7 +1363,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
         /// </summary>
@@ -1384,12 +1379,13 @@ public void SemicolonInSourceCodeFilename_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1431,7 +1427,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
@@ -1599,7 +1594,6 @@ public class Class1
             Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); //                     @"Did not find expected file Console;!@(foo)'^(Application1.exe"
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
         /// have all sorts of crazy characters in their name. There
@@ -1775,7 +1769,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
     }
 #endif
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index f6f733c34a9..c8c590e79cd 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1874,19 +1874,19 @@ public void TestItemSpecModiferEscaping()
         [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToReferenceAssembliesAsFunction()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) == null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) == null)
             {
                 // if there aren't any reference assemblies installed on the machine in the first place, of course
                 // we're not going to find them. :)
                 return;
             }
 
-            string content = @"
+            string content = $@"
                 <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
 
                     <PropertyGroup>
                         <TargetFrameworkIdentifier>.NETFramework</TargetFrameworkIdentifier>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <TargetFrameworkProfile></TargetFrameworkProfile>
                         <TargetFrameworkMoniker>$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
                     </PropertyGroup>
diff --git a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
index 6aec4235e18..ca0efc0d850 100644
--- a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
@@ -138,5 +138,37 @@ public void MSBuildGlobVisitorShouldFindAllLeaves()
                 Assert.Contains(expectedGlob, leafGlobs);
             }
         }
+
+        [Fact]
+        public void CreateShouldHandleZeroChildren()
+        {
+            IMSBuildGlob composite = CompositeGlob.Create(Enumerable.Empty<IMSBuildGlob>());
+
+            Assert.False(composite.IsMatch(""));
+        }
+
+        [Fact]
+        public void CreateShouldReturnSingleChildUnchanged()
+        {
+            var glob = MSBuildGlob.Parse("");
+
+            IMSBuildGlob composite = CompositeGlob.Create(new[] { glob });
+
+            Assert.Same(glob, composite);
+        }
+
+        [Fact]
+        public void CreateShouldReturnNewCompositeWhenMultipleProvided()
+        {
+            var glob1 = MSBuildGlob.Parse("");
+            var glob2 = MSBuildGlob.Parse("");
+
+            IMSBuildGlob result = CompositeGlob.Create(new[] { glob1, glob2 });
+
+            var composite = Assert.IsType<CompositeGlob>(result);
+            Assert.Same(glob1, composite.Globs.First());
+            Assert.Same(glob2, composite.Globs.Skip(1).First());
+            Assert.Equal(2, composite.Globs.Count());
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
index 9dc8a506fcf..fd742516500 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Engine.UnitTests.Globbing
     public class MSBuildGlobWithGaps_Tests
     {
         [Fact]
-        public void GlobWithGapsShoulWorkWithNoGaps()
+        public void GlobWithGapsShouldWorkWithNoGaps()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), Enumerable.Empty<IMSBuildGlob>());
 
@@ -19,7 +19,7 @@ public void GlobWithGapsShoulWorkWithNoGaps()
         }
 
         [Fact]
-        public void GlobWithGapsShoulMatchIfNoGapsMatch()
+        public void GlobWithGapsShouldMatchIfNoGapsMatch()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), MSBuildGlob.Parse("b*"));
 
@@ -27,7 +27,7 @@ public void GlobWithGapsShoulMatchIfNoGapsMatch()
         }
 
         [Fact]
-        public void GlobWithGapsShoulNotMatchIfGapsMatch()
+        public void GlobWithGapsShouldNotMatchIfGapsMatch()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), MSBuildGlob.Parse("*b"));
 
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index d357c472750..c550d10b888 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -90,7 +90,7 @@ public void GlobFromRootWithInvalidPathThrows()
             "../d/e/**",
             "a/b/d/e"
             )]
-        public void GlobWithRelativeFixedDirectoryPartShouldMissmatchTheGlobRoot(string globRoot, string filespec, string expectedFixedDirectoryPart)
+        public void GlobWithRelativeFixedDirectoryPartShouldMismatchTheGlobRoot(string globRoot, string filespec, string expectedFixedDirectoryPart)
         {
             var glob = MSBuildGlob.Parse(globRoot, filespec);
 
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index dc3a40ef3ce..817d408f8a1 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
     <AssemblyName>Microsoft.Build.Engine.UnitTests</AssemblyName>
 
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 3efd05703f6..4a7e4b27904 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -32,11 +32,12 @@ public void TargetARM()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>arm</PlatformTarget>
@@ -134,18 +135,18 @@ public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -186,7 +187,7 @@ public void AnyCPUWinMDObjProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -241,10 +242,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>winmdobj</OutputType>
                         <Configuration>Debug</Configuration>
@@ -253,10 +254,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -298,17 +299,17 @@ public void AnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -348,18 +349,18 @@ public void ExplicitAnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -400,7 +401,7 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -434,10 +435,10 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
         /// <summary>
         /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are 
-        /// targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default. 
+        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default. 
         /// </summary>
         [Fact]
-        public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
+        public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
         {
             string file = null;
             string outputPath = Path.GetTempPath() + "\\" + Guid.NewGuid().ToString("N");
@@ -449,18 +450,18 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -470,7 +471,7 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
 
                 project.Build();
 
-                logger.AssertLogContains(" /platform:AnyCPU ");
+                logger.AssertLogContains("Platform=AnyCPU");
             }
             finally
             {
@@ -500,21 +501,21 @@ public void AnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
                       </PropertyGroup>
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
-                           we need to be .NET 4.5 or greater -->
+                           we need to be .NET 4.5 or greater, but 4.8 is on the CI machine -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -556,10 +557,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
@@ -568,10 +569,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -613,19 +614,19 @@ public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`Current` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <Prefer32Bit>true</Prefer32Bit>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -665,17 +666,17 @@ public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -715,17 +716,17 @@ public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -867,20 +868,20 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + files[0] + @"` />
-                        <None Include=`" + files[1] + @"` />
-                        <Content Include=`" + files[2] + @"` />
+                        <Compile Include=`{files[0]}` />
+                        <None Include=`{files[1]}` />
+                        <Content Include=`{files[2]}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
@@ -952,17 +953,17 @@ public void SynthesizeLinkMetadataForItemsOnWhitelist()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
@@ -1030,17 +1031,17 @@ public void DontSynthesizeLinkMetadataIfPropertyNotSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>false</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 132cb665bb1..5f73ac08e8b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -29,12 +29,10 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         /// <param name="host">The component host.</param>
         /// <param name="enableReuse">Whether this node may be reused for a later build.</param>
         /// <param name="lowPriority">Whether this node is low priority.</param>
         internal NodeEndpointOutOfProc(
-            string pipeName, 
             IBuildComponentHost host,
             bool enableReuse,
             bool lowPriority)
@@ -44,7 +42,7 @@ internal NodeEndpointOutOfProc(
             _enableReuse = enableReuse;
             _lowPriority = lowPriority;
 
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 11ea72ba505..3472c8ff01d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -76,7 +76,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
-            if (_nodeContexts.Count == ComponentHost.BuildParameters.MaxNodeCount)
+            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 864b6f8ce81..9d7adfb26a6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -355,7 +355,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(nodeProcessId);
 
             NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 2a917d6eaee..5d6c5f8f2cc 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -372,7 +372,9 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
 
                     if (s_msbuildName == null)
                     {
-                        s_msbuildName = "MSBuild.exe";
+                        s_msbuildName = (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET
+                            ? "MSBuild.dll"
+                            : "MSBuild.exe";
                     }
                 }
 
@@ -498,7 +500,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
-            if (AvailableNodes == 0)
+            if (AvailableNodes <= 0)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 9e500181510..ae59a7b50af 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -239,9 +239,8 @@ public NodeEngineShutdownReason Run(bool enableReuse, out Exception shutdownExce
         public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception shutdownException)
         {
             // Console.WriteLine("Run called at {0}", DateTime.Now);
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + Process.GetCurrentProcess().Id);
 
-            _nodeEndpoint = new NodeEndpointOutOfProc(pipeName, this, enableReuse, lowPriority);
+            _nodeEndpoint = new NodeEndpointOutOfProc(this, enableReuse, lowPriority);
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 2cc6ab1f7b4..6d55273c55c 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -768,7 +768,7 @@ Func<string, bool> GetReferenceFilter()
                     }
 
                     var fragments = items.SelectMany(i => ExpressionShredder.SplitSemiColonSeparatedList(i.EvaluatedInclude));
-                    var glob = new CompositeGlob(
+                    var glob = CompositeGlob.Create(
                         fragments
                             .Select(s => MSBuildGlob.Parse(Project.Directory, s)));
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index ff29b8ec3a5..df1d8ed8eb4 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2575,7 +2575,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 }
 
                 ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.TextFragment).ToImmutableArray();
-                var includeGlob = new CompositeGlob(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
+                var includeGlob = CompositeGlob.Create(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
 
                 IEnumerable<string> excludeFragmentStrings = Enumerable.Empty<string>();
                 IMSBuildGlob excludeGlob = null;
@@ -2594,7 +2594,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
                 {
                     removeFragmentStrings = removeItemElement.FragmentStrings;
-                    removeGlob = new CompositeGlob(removeItemElement.Globs);
+                    removeGlob = CompositeGlob.Create(removeItemElement.Globs);
                 }
 
                 var includeGlobWithGaps = CreateIncludeGlobWithGaps(includeGlob, excludeGlob, removeGlob);
@@ -2604,17 +2604,13 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
 
             private static IMSBuildGlob CreateIncludeGlobWithGaps(IMSBuildGlob includeGlob, IMSBuildGlob excludeGlob, IMSBuildGlob removeGlob)
             {
-                if (excludeGlob == null)
+                return (excludeGlob, removeGlob) switch
                 {
-                    return removeGlob == null ? includeGlob :
-                        new MSBuildGlobWithGaps(includeGlob, removeGlob);
-                }
-                else
-                {
-                    return new MSBuildGlobWithGaps(includeGlob,
-                        removeGlob == null ? excludeGlob :
-                        new CompositeGlob(excludeGlob, removeGlob));
-                }
+                    (null,     null)     => includeGlob,
+                    (not null, null)     => new MSBuildGlobWithGaps(includeGlob, excludeGlob),
+                    (null,     not null) => new MSBuildGlobWithGaps(includeGlob, removeGlob),
+                    (not null, not null) => new MSBuildGlobWithGaps(includeGlob, new CompositeGlob(excludeGlob, removeGlob))
+                };
             }
 
             private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dictionary<string, CumulativeRemoveElementData> removeElementCache)
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 8193377caeb..b623fed7040 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -920,6 +920,17 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
 
+                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
+#if RUNTIME_TYPE_NETCORE
+                        "Core",
+#elif MONO
+                        NativeMethodsShared.IsMono ? "Mono" : "Full");
+#else
+                        "Full",
+#endif
+                        mayBeReserved: true));
+
+
                     // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
                     // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
                     int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index fbc0b6f6b1a..b2f33e70f30 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -97,7 +97,13 @@ public override IMSBuildGlob ToMSBuildGlob()
 
             protected override IMSBuildGlob CreateMsBuildGlob()
             {
-                return new CompositeGlob(ReferencedItems.Select(i => i.ItemAsValueFragment.ToMSBuildGlob()));
+                if (ReferencedItems.Count == 1)
+                {
+                    // Optimize the common case, avoiding allocation of enumerable/enumerator.
+                    return ReferencedItems[0].ItemAsValueFragment.ToMSBuildGlob();
+                }
+
+                return CompositeGlob.Create(ReferencedItems.Select(i => i.ItemAsValueFragment.ToMSBuildGlob()));
             }
 
             private bool InitReferencedItemsIfNecessary()
@@ -368,7 +374,13 @@ public IList<string> IntersectsWith(IReadOnlyDictionary<string, ItemDataCollecti
         /// </summary>
         public IMSBuildGlob ToMSBuildGlob()
         {
-            return new CompositeGlob(Fragments.Select(f => f.ToMSBuildGlob()));
+            if (Fragments.Count == 1)
+            {
+                // Optimize the common case, avoiding allocation of enumerable/enumerator.
+                return Fragments[0].ToMSBuildGlob();
+            }
+
+            return CompositeGlob.Create(Fragments.Select(f => f.ToMSBuildGlob()));
         }
 
         /// <summary>
diff --git a/src/Build/Globbing/CompositeGlob.cs b/src/Build/Globbing/CompositeGlob.cs
index 58687130fa4..96606323bc9 100644
--- a/src/Build/Globbing/CompositeGlob.cs
+++ b/src/Build/Globbing/CompositeGlob.cs
@@ -5,33 +5,30 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Globbing
 {
     /// <summary>
-    ///     A Composite glob
+    ///     A composite glob that returns a match for an input if any of its
+    ///     inner globs match the input (disjunction).
     /// </summary>
     public class CompositeGlob : IMSBuildGlob
     {
+        private readonly ImmutableArray<IMSBuildGlob> _globs;
+
         /// <summary>
         /// The direct children of this composite
         /// </summary>
-        public IEnumerable<IMSBuildGlob> Globs { get; }
+        public IEnumerable<IMSBuildGlob> Globs => _globs;
 
         /// <summary>
         ///     Constructor
         /// </summary>
         /// <param name="globs">Children globs. Input gets shallow cloned</param>
         public CompositeGlob(IEnumerable<IMSBuildGlob> globs)
-        {
-            // ImmutableArray also does this check, but copied it here just in case they remove it
-            if (globs is ImmutableArray<IMSBuildGlob>)
-            {
-                Globs = (ImmutableArray<IMSBuildGlob>)globs;
-            }
-
-            Globs = globs.ToImmutableArray();
-        }
+            : this(globs is ImmutableArray<IMSBuildGlob> immutableGlobs ? immutableGlobs : globs.ToImmutableArray())
+        {}
 
         /// <summary>
         ///     Constructor
@@ -40,13 +37,114 @@ public CompositeGlob(IEnumerable<IMSBuildGlob> globs)
         public CompositeGlob(params IMSBuildGlob[] globs) : this(globs.ToImmutableArray())
         {}
 
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="glob1">First child glob.</param>
+        /// <param name="glob2">Second child glob.</param>
+        internal CompositeGlob(IMSBuildGlob glob1, IMSBuildGlob glob2)
+            : this(ImmutableArray.Create(glob1, glob2))
+        {}
+
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="globs">Children globs.</param>
+        private CompositeGlob(ImmutableArray<IMSBuildGlob> globs)
+        {
+            _globs = globs;
+        }
+
         /// <inheritdoc />
         public bool IsMatch(string stringToMatch)
         {
             // Threadpools are a scarce resource in Visual Studio, do not use them.
             //return Globs.AsParallel().Any(g => g.IsMatch(stringToMatch));
 
-            return Globs.Any(g => g.IsMatch(stringToMatch));
+            return _globs.Any(g => g.IsMatch(stringToMatch));
+        }
+
+        /// <summary>
+        ///     Creates an <see cref="IMSBuildGlob"/> that aggregates multiple other globs
+        ///     such that the resulting glob matches when any inner glob matches (disjunction).
+        /// </summary>
+        /// <remarks>
+        ///     <para>
+        ///         When <paramref name="globs"/> contains no elements, a singleton glob is
+        ///         returned that never matches, regardless of input.
+        ///     </para>
+        ///     <para>
+        ///         When <paramref name="globs"/> contains one element, that single element is
+        ///         returned directly. This avoids allocating a redundant wrapper instance.
+        ///     </para>
+        /// </remarks>
+        /// <param name="globs">An enumeration of globs to compose.</param>
+        /// <returns>The logical disjunction of the input globs.</returns>
+        public static IMSBuildGlob Create(IEnumerable<IMSBuildGlob> globs)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(globs, nameof(globs));
+
+            if (globs is ImmutableArray<IMSBuildGlob> immutableGlobs)
+            {
+                // Avoid allocations in the case that the input is an ImmutableArray
+                return immutableGlobs.Length switch
+                {
+                    0 => NeverMatchingGlob.Instance,
+                    1 => immutableGlobs[0],
+                    _ => new CompositeGlob(immutableGlobs)
+                };
+            }
+
+            // Use explicit enumeration so we can do minimal work in the case
+            // that the input set of globs is either empty or only contains a
+            // single item.
+
+            using var enumerator = globs.GetEnumerator();
+
+            if (!enumerator.MoveNext())
+            {
+                // The input is empty, so return our singleton that doesn't
+                // match anything.
+                return NeverMatchingGlob.Instance;
+            }
+
+            var first = enumerator.Current;
+
+            if (!enumerator.MoveNext())
+            {
+                // The input contains only a single glob. Disjunction has no
+                // effect on a single input, so return it directly and avoid
+                // allocating a CompositeGlob instance.
+                return first;
+            }
+
+            // We have more than one input glob, to add them all to a builder
+            // and create a new CompositeGlob.
+
+            var builder = ImmutableArray.CreateBuilder<IMSBuildGlob>();
+
+            builder.Add(first);
+            builder.Add(enumerator.Current);
+
+            while (enumerator.MoveNext())
+            {
+                builder.Add(enumerator.Current);
+            }
+
+            return new CompositeGlob(builder.ToImmutable());
+        }
+
+        /// <summary>
+        ///    A glob that never returns a match.
+        /// </summary>
+        private sealed class NeverMatchingGlob : IMSBuildGlob
+        {
+            /// <summary>
+            ///    Singleton instance of this type.
+            /// </summary>
+            public static NeverMatchingGlob Instance { get; } = new();
+
+            public bool IsMatch(string stringToMatch) => false;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/IMSBuildGlob.cs b/src/Build/Globbing/IMSBuildGlob.cs
index 59e630fd225..c6b9279ab50 100644
--- a/src/Build/Globbing/IMSBuildGlob.cs
+++ b/src/Build/Globbing/IMSBuildGlob.cs
@@ -15,7 +15,7 @@ public interface IMSBuildGlob
         ///     - arguments representing relative paths are normalized against the glob's root.
         ///     For example, the glob **/*.cs does not match ../a.cs, since ../a.cs points outside of the glob root.
         /// 
-        ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters>
+        ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters.
         /// </summary>
         /// <param name="stringToMatch">The string to match. If the string represents a relative path, it will get normalized against the glob's root. Cannot be null.</param>
         /// <returns></returns>
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 9460958a40f..3fdf05a6b9c 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -260,7 +260,7 @@ public static MSBuildGlob Parse(string fileSpec)
         /// <summary>
         ///     Return type of <see cref="MSBuildGlob.MatchInfo" />
         /// </summary>
-        public struct MatchInfoResult
+        public readonly struct MatchInfoResult
         {
             /// <summary>
             ///     Whether the <see cref="MSBuildGlob.MatchInfo" /> argument was matched against the glob
diff --git a/src/Build/Globbing/MSBuildGlobWithGaps.cs b/src/Build/Globbing/MSBuildGlobWithGaps.cs
index 1a1abe4d149..fd6cf67baf4 100644
--- a/src/Build/Globbing/MSBuildGlobWithGaps.cs
+++ b/src/Build/Globbing/MSBuildGlobWithGaps.cs
@@ -32,6 +32,20 @@ public class MSBuildGlobWithGaps : IMSBuildGlob
         /// </summary>
         public IMSBuildGlob Gaps { get; }
 
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="mainGlob">The main glob</param>
+        /// <param name="gaps">The gap glob</param>
+        internal MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IMSBuildGlob gaps)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(mainGlob, nameof(mainGlob));
+            ErrorUtilities.VerifyThrowArgumentNull(gaps, nameof(gaps));
+
+            MainGlob = mainGlob;
+            Gaps = gaps;
+        }
+
         /// <summary>
         ///     Constructor
         /// </summary>
@@ -43,7 +57,7 @@ public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IEnumerable<IMSBuildGlob> gaps
             ErrorUtilities.VerifyThrowArgumentNull(gaps, nameof(gaps));
 
             MainGlob = mainGlob;
-            Gaps = new CompositeGlob(gaps);
+            Gaps = CompositeGlob.Create(gaps);
         }
 
         /// <summary>
diff --git a/src/Build/Globbing/Visitor/GlobVisitor.cs b/src/Build/Globbing/Visitor/GlobVisitor.cs
index 26a349c2c35..972af2443ad 100644
--- a/src/Build/Globbing/Visitor/GlobVisitor.cs
+++ b/src/Build/Globbing/Visitor/GlobVisitor.cs
@@ -7,25 +7,22 @@ internal abstract class GlobVisitor
     {
         public void Visit(IMSBuildGlob glob)
         {
-            var msbuildGlob = glob as MSBuildGlob;
-            if (msbuildGlob != null)
+            if (glob is MSBuildGlob msbuildGlob)
             {
                 VisitMSBuildGlob(msbuildGlob);
             }
 
-            var compositGlob = glob as CompositeGlob;
-            if (compositGlob != null)
+            if (glob is CompositeGlob compositeGlob)
             {
-                VisitCompositeGlob(compositGlob);
+                VisitCompositeGlob(compositeGlob);
 
-                foreach (var globPart in compositGlob.Globs)
+                foreach (var globPart in compositeGlob.Globs)
                 {
                     Visit(globPart);
                 }
             }
 
-            var globWithGaps = glob as MSBuildGlobWithGaps;
-            if (globWithGaps != null)
+            if (glob is MSBuildGlobWithGaps globWithGaps)
             {
                 VisitGlobWithGaps(globWithGaps);
 
@@ -37,7 +34,7 @@ protected virtual void VisitGlobWithGaps(MSBuildGlobWithGaps globWithGaps)
         {
         }
 
-        protected virtual void VisitCompositeGlob(CompositeGlob compositGlob)
+        protected virtual void VisitCompositeGlob(CompositeGlob compositeGlob)
         {
         }
 
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 6237ac280ed..4596be57f52 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -355,15 +355,12 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 
                 mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                string runtime = null;
-                string architecture = null;
-
-                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.runtime))
                 {
-                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.MSBuildRuntimeValues.clr4;
+                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.GetCurrentMSBuildRuntime();
                 }
 
-                if (!mergedParameters.TryGetValue(XMakeAttributes.architecture, out architecture))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.architecture))
                 {
                     mergedParameters[XMakeAttributes.architecture] = XMakeAttributes.GetCurrentMSBuildArchitecture();
                 }
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index 5b9fbfe4d6d..c095b7f8e50 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -8,4 +8,5 @@ Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string
 Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
 Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
 Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
\ No newline at end of file
+Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
+static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
\ No newline at end of file
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 5b9fbfe4d6d..c095b7f8e50 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -8,4 +8,5 @@ Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string
 Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
 Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
 Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
\ No newline at end of file
+Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
+static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
\ No newline at end of file
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index ce322f9833b..cb6fabf4c0d 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -80,7 +80,6 @@
     <DefineConstants>$(DefineConstants);FEATURE_SYSTEMPAGESIZE</DefineConstants>
     <FeatureSystemConfiguration>true</FeatureSystemConfiguration>
     <DefineConstants>$(DefineConstants);FEATURE_TASK_GENERATERESOURCES</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_TASKHOST</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_ABORT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_CULTURE</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_PRIORITY</DefineConstants>
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 17594f48d2f..08aaad0b333 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -105,6 +105,7 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\NativeMethodsShared.cs">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 6643148f7ff..d3511c927b5 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -720,7 +720,15 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="Compile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                             <xs:element name="VBMyExtensionTemplateID"/>
                         </xs:choice>
                     </xs:sequence>
@@ -730,6 +738,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Compile_Include" _locComment="" -->Semi-colon separated list of source files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -770,7 +788,15 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                             <xs:element name="LogicalName"/>
                         </xs:choice>
                     </xs:sequence>
@@ -780,6 +806,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="EmbeddedResource_Include" _locComment="" -->Semi-colon separated list of resource files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -819,15 +855,29 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
-                            <xs:element name="CopyToPublishDirectory" type="msb:boolean">
+                            <xs:element name="CopyToPublishDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -837,6 +887,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Content_Include" _locComment="" -->Semi-colon separated list of content files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -865,10 +925,17 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, Never, PreserveNewest or Always, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -878,6 +945,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Page_Include" _locComment="" -->Semi-colon separated list of XAML files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -906,10 +983,17 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -919,6 +1003,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Resource_Include" _locComment="" -->Semi-colon separated list of files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -947,13 +1041,30 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -985,7 +1096,15 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="None_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                         </xs:choice>
                     </xs:sequence>
                 </xs:extension>
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index a03db6f636f..1714165cad1 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -16,10 +16,9 @@ internal class NodeEndpointOutOfProcTaskHost : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal NodeEndpointOutOfProcTaskHost(string pipeName)
+        internal NodeEndpointOutOfProcTaskHost()
         {
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion // Constructors and Factories
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 6dc795d6762..d4212f1d09b 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -612,9 +612,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
             // Snapshot the current environment
             _savedEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
 
-            string pipeName = "MSBuild" + Process.GetCurrentProcess().Id;
-
-            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost(pipeName);
+            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost();
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 66f5bc78f00..b26225401f6 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -108,6 +108,7 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\NativeMethodsShared.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 4b118f31594..3c472f898d0 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -60,7 +60,12 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with administrator privileges
         /// </summary>
-        Administrator = 32
+        Administrator = 32,
+
+        /// <summary>
+        /// Using the .NET Core/.NET 5.0+ runtime
+        /// </summary>
+        NET = 64,
     }
 
     internal readonly struct Handshake
@@ -75,7 +80,7 @@ internal readonly struct Handshake
 
         internal Handshake(HandshakeOptions nodeType)
         {
-            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // We currently use 7 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
             // This indicates in the first byte that we are a modern build.
             options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
 
-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 2;
+                    } 
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 4;
+                    }
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.net, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 5;
+                    }
+                    else
+                    {
+                        ErrorUtilities.ThrowInternalErrorUnreachable();
+                    }
+
                     is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
@@ -501,10 +522,26 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
             {
                 context |= HandshakeOptions.X64;
             }
-            if (clrVersion == 2)
+
+            switch (clrVersion)
             {
-                context |= HandshakeOptions.CLR2;
+                case 0:
+                    // Not a taskhost, runtime must match
+                case 4:
+                    // Default for MSBuild running on .NET Framework 4,
+                    // not represented in handshake
+                    break;
+                case 2:
+                    context |= HandshakeOptions.CLR2;
+                    break;
+                case >= 5:
+                    context |= HandshakeOptions.NET;
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalErrorUnreachable();
+                    break;
             }
+
             if (nodeReuse)
             {
                 context |= HandshakeOptions.NodeReuse;
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 6289ef54bef..9a36fc1816e 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -77,6 +77,16 @@ internal static class MSBuildConstants
         /// </summary>
         internal const string DefaultTargetsMarker = ".default";
 
+        /// <summary>
+        /// Framework version against which our test projects should be built.
+        /// </summary>
+        /// <remarks>
+        /// The targeting pack for this version of .NET Framework must be installed
+        /// on any machine that wants to run tests successfully, so this can be
+        /// periodically updated.
+        /// </remarks>
+        internal const string StandardTestTargetFrameworkVersion = "v4.8";
+
         /// <summary>
         /// Symbol used in ProjectReferenceTarget items to represent targets specified on the ProjectReference item
         /// with fallback to default targets if the ProjectReference item has no targets specified.
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index afdbc7fefec..42237dde8c9 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -976,13 +976,10 @@ internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootP
 
             try
             {
-                string path = targetFrameworkRootPath;
-                path = Path.Combine(path, frameworkName.Identifier);
-                path = Path.Combine(path, "v" + frameworkName.Version.ToString());
+                string path = Path.Combine(targetFrameworkRootPath, frameworkName.Identifier, "v" + frameworkName.Version.ToString());
                 if (!String.IsNullOrEmpty(frameworkName.Profile))
                 {
-                    path = Path.Combine(path, "Profile");
-                    path = Path.Combine(path, frameworkName.Profile);
+                    path = Path.Combine(path, "Profile", frameworkName.Profile);
                 }
 
                 return Path.GetFullPath(path);
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index a7f8913e7d7..e3b1341515f 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -1,15 +1,24 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
+using System.Diagnostics;
 using System.IO;
 
+#nullable enable
+
 namespace Microsoft.Build.Shared
 {
     internal static class NamedPipeUtil
     {
-        internal static string GetPipeNameOrPath(string pipeName)
+        internal static string GetPipeNameOrPath(int? processId = null)
         {
+            if (processId is null)
+            {
+                processId = Process.GetCurrentProcess().Id;
+            }
+
+            string pipeName = $"MSBuild{processId}";
+
             if (NativeMethodsShared.IsUnixLike)
             {
                 // If we're on a Unix machine then named pipes are implemented using Unix Domain Sockets.
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 3d468e23e95..4562c4309d7 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -183,11 +183,8 @@ public void SendData(INodePacket packet)
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal void InternalConstruct(string pipeName)
+        internal void InternalConstruct()
         {
-            ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
-
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
@@ -195,6 +192,8 @@ internal void InternalConstruct(string pipeName)
             _packetStream = new MemoryStream();
             _binaryWriter = new BinaryWriter(_packetStream);
 
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath();
+
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
             {
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index f3c58b19237..70cf960d823 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
+
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -47,35 +49,82 @@ public void TestIsNonBatchingTargetAttribute()
         public void TestRuntimeValuesMatch()
         {
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime));
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.net));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any));
+#if NET5_0_OR_GREATER
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.net));
+#else
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4));
+#endif
 
+            // Never true
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2));
+
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.net));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.net));
         }
 
-        [Fact]
-        public void TestMergeRuntimeValues()
+        [Theory]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr2)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        public void TestMergeRuntimeValues(string left, string right, bool success, string expected)
         {
-            string mergedRuntime;
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            XMakeAttributes.TryMergeRuntimeValues(left, right, out string mergedRuntime)
+                .ShouldBe(success);
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(expected);
+        }
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr2, mergedRuntime);
+        [Fact]
+        public void TestMergeRuntimeValuesAnyAcceptsCurrent()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any,
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                out string mergedRuntime)
+                .ShouldBeTrue();
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(XMakeAttributes.GetCurrentMSBuildRuntime());
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
+            "Tests whether 'current' merges with 'clr4' which is true only on Framework")]
+        public void TestMergeRuntimeValuesCurrentToClr4()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.clr4);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework,
+            "Tests whether 'current' merges with 'net' which is true only on core")]
+        public void TestMergeRuntimeValuesCurrentToCore()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.net);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
         }
 
         [Fact]
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 461bc2ef740..d290eee6246 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Runtime.CompilerServices;
 
 namespace Microsoft.Build.Shared
 {
@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues
             internal const string clr2 = "CLR2";
             internal const string clr4 = "CLR4";
             internal const string currentRuntime = "CurrentRuntime";
+            internal const string net = "NET";
             internal const string any = "*";
         }
 
@@ -99,7 +101,7 @@ internal struct MSBuildArchitectureValues
 
         private static readonly HashSet<string> KnownBatchingTargetAttributes = new HashSet<string> { name, condition, dependsOnTargets, beforeTargets, afterTargets };
 
-        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.any };
+        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.net, MSBuildRuntimeValues.any };
 
         private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
 
@@ -179,10 +181,10 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
                 return true;
             }
 
-            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase)) ||
-                (runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
+            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase)) ||
+                (runtimeA.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
             {
-                // CLR4 is the current runtime, so this is also a match. 
+                // Matches the current runtime, so match.
                 return true;
             }
 
@@ -216,13 +218,15 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 runtimeB = MSBuildRuntimeValues.any;
             }
 
+            string actualCurrentRuntime = GetCurrentMSBuildRuntime();
+
             // if they're equal, then there's no problem -- just return the equivalent runtime.  
             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))
             {
                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                     runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
                 {
-                    mergedRuntime = MSBuildRuntimeValues.clr4;
+                    mergedRuntime = actualCurrentRuntime;
                 }
                 else
                 {
@@ -232,21 +236,22 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.  
+            // if both A and B are one of actual-current-runtime, don't care or current,
+            // then the end result will be current-runtime no matter what.  
             if (
                 (
-                 runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeA.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 ) &&
                 (
-                 runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeB.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 )
                )
             {
-                mergedRuntime = MSBuildRuntimeValues.clr4;
+                mergedRuntime = actualCurrentRuntime;
                 return true;
             }
 
@@ -320,8 +325,8 @@ internal static string GetExplicitMSBuildRuntime(string runtime)
                 MSBuildRuntimeValues.any.Equals(runtime, StringComparison.OrdinalIgnoreCase) ||
                 MSBuildRuntimeValues.currentRuntime.Equals(runtime, StringComparison.OrdinalIgnoreCase))
             {
-                // Default to CLR4.
-                return MSBuildRuntimeValues.clr4;
+                // Default to current.
+                return GetCurrentMSBuildRuntime();
             }
             else
             {
@@ -425,6 +430,18 @@ internal static string GetCurrentMSBuildArchitecture()
             return currentArchitecture;
         }
 
+        /// <summary>
+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. 
+        /// </summary>
+        internal static string GetCurrentMSBuildRuntime()
+        {
+#if NET40_OR_GREATER
+            return MSBuildRuntimeValues.clr4;
+#else
+            return MSBuildRuntimeValues.net;
+#endif
+        }
+
         /// <summary>
         /// Given an MSBuildArchitecture value that may be non-explicit -- e.g. "CurrentArchitecture" or "Any" --
         /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map 
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index 88f8cf4959f..a88113e0319 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -23,9 +23,9 @@ sealed public class GetReferenceAssmeblyPath_Tests
         [Fact]
         public void TestGeneralFrameworkMonikerGood()
         {
-            string targetFrameworkMoniker = ".NetFramework, Version=v4.5";
-            MockEngine engine = new MockEngine();
-            GetReferenceAssemblyPaths getReferencePaths = new GetReferenceAssemblyPaths();
+            string targetFrameworkMoniker = ".NetFramework, Version=v4.8";
+            MockEngine engine = new();
+            GetReferenceAssemblyPaths getReferencePaths = new();
             getReferencePaths.BuildEngine = engine;
             getReferencePaths.TargetFrameworkMoniker = targetFrameworkMoniker;
             getReferencePaths.Execute();
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 05200fcfac9..04ef5ffcd1d 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 
@@ -350,12 +351,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), @"
+                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 98ae00b9da8..74020be52f0 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Tasks.UnitTests</AssemblyName>
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index f400cef6a24..f9aabd40908 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -52,13 +52,16 @@ public void OverrideBaseIntermediateOutputPathSucceeds()
         [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows))]
         public void AssemblyAttributesLocation()
         {
-            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.0.AssemblyAttributes.cs");
+            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.8.AssemblyAttributes.cs");
 
             var project = ObjectModelHelpers.CreateInMemoryProject($@"
 <Project>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.Common.props"" />
+  <PropertyGroup>
+    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
+  </PropertyGroup>
   <ItemGroup>
-    <Compile Include=""a.cs""/>       
+    <Compile Include=""a.cs""/>
   </ItemGroup>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.CSharp.targets"" />
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 6d055df7140..8ffdf31868d 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -2369,14 +2369,15 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
 
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2546,13 +2547,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 99e3d7066b0..3e20f81bc0f 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -2730,14 +2730,14 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2908,13 +2908,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index be72b128729..350f9d70f69 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -52,13 +52,13 @@ internal abstract class Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
+        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
         {
             this.searchPathElement = searchPathElement;
             this.getAssemblyName = getAssemblyName;
             this.fileExists = fileExists;
             this.getRuntimeVersion = getRuntimeVersion;
-            this.targetedRuntimeVersion = targetedRuntimeVesion;
+            this.targetedRuntimeVersion = targetedRuntimeVersion;
             this.targetProcessorArchitecture = targetedProcessorArchitecture;
             this.compareProcessorArchitecture = compareProcessorArchitecture;
         }
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index f6b98da83af..f909cc1afe2 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -122,8 +122,9 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="NET" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''  and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -141,8 +142,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -164,8 +165,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index 2051aed69cf..0eea164b802 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <AssemblyName>Microsoft.Build.Utilities.UnitTests</AssemblyName>
     <IsTestProject>true</IsTestProject>
     <RootNamespace>Microsoft.Build.Utilities.UnitTests</RootNamespace>
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index b2099ce44c5..e2588de3155 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -1950,26 +1950,30 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
             }
            );
         }
+
         /// <summary>
-        /// Verify the method correctly returns the 4.5 reference assembly location information if .net 4.5 and
+        /// Verify the method correctly returns the 4.8 reference assembly location information if .net 4.8 and
         /// its corresponding reference assemblies are installed.
-        /// If they are not installed, the test should be ignored.
+        /// .NET 4.8 should always be installed for our tests. We cannot validly verify on Windows that by adding a check
+        /// that ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48)
+        /// returns something reasonable because later versions of the framework overwrote the current version in
+        /// place, which means it just looks for a folder starting with v4.0 in the right spot for any higher version.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
-        public void GetPathToReferenceAssembliesDefaultLocation45()
+        public void GetPathToReferenceAssembliesDefaultLocation48()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) != null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) != null)
             {
-                FrameworkNameVersioning frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
+                FrameworkNameVersioning frameworkName = new(".NETFramework", new Version("4.8"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
                 directories.Count.ShouldBe(1); // "Expected the method to return one path."
 
-                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45);
+                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48);
                 directories[0].ShouldBe(referenceAssemblyPath, StringCompareShould.IgnoreCase);
             }
             // else
-            // "Ignored because v4.5 did not seem to be installed"
+            // "Ignored because v4.8 did not seem to be installed"
         }
 
         /// <summary>
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index e34d6eef2af..6237b17f4c7 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2199,7 +2199,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
                 }
             }
 
-            return new List<string>();
+            return pathsList ?? new List<string>();
         }
 
         /// <summary>
