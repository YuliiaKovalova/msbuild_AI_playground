diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index fe3485b6f5c..c32ce098b34 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -23,9 +23,12 @@ variables:
   - name: SourceBranch
     value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
+  # NOTE: the code is temporarily fixed. For the branches that should use opt-prof from the main branch we should use the latest working Opt-Prof collected from main 20230217.4.
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
+    - name: OptProfDrop
+      value: 'OptimizationData/DotNet-msbuild-Trusted/main/20230217.4/7352286/1'   
     - name: SourceBranch
-      value: main
+      value: ''
   # if OptProfDropName is set as a parameter, set OptProfDrop to the parameter and unset SourceBranch
   - ${{ if ne(parameters.OptProfDropName, 'default') }}:
     - name: OptProfDrop
diff --git a/Directory.Build.props b/Directory.Build.props
index ffdf91c5c7d..43bebf10428 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -90,6 +90,8 @@
     <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
     <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
     <DirectoryPackagesPropsPath>$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)', 'eng', 'Packages.props'))</DirectoryPackagesPropsPath>
+
+    <AccelerateBuildsInVisualStudio>true</AccelerateBuildsInVisualStudio>
   </PropertyGroup>
 
   <!-- Enable SDK supplied netanalyzers for all target frameworks -->
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 5d3feeccf3a..4ef85d8de35 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,6 +27,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
 - [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
 - [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
+- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
diff --git a/eng/Build.props b/eng/Build.props
index f2afe806410..92315cd00ab 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -2,9 +2,13 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
 
+<!-- Commented out as a temporary fix for the msbuild CI.
+Waiting for https://github.com/NuGet/NuGet.Client/pull/5010 fix to flow to CI machines. -->
+<!--
   <PropertyGroup>
     <RestoreUseStaticGraphEvaluation Condition="'$(DotNetBuildFromSource)' != 'true'">true</RestoreUseStaticGraphEvaluation>
   </PropertyGroup>
+-->
 
   <ItemGroup>
 	<!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 009a31bbea5..3e9137b82ad 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -10,9 +10,9 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>ca5029046d7b6e55f322c45abb7b342054543710</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-1.23109.10">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-2.23152.6">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>73338d92270b9f26982eca2e8872037a0214b912</Sha>
+      <Sha>1314d090671dc1a1500c5303c4b5ae9150f40d98</Sha>
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23114.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1b66f02385a..49ba3076264 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -51,7 +51,7 @@
     <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23114.5</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.6.0-1.23109.10</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.6.0-2.23152.6</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.5.0-rc.149</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 6f66f263d26..c91df2ca317 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -84,6 +85,32 @@ public void TasksAreDiscoveredWhenTaskConditionTrue()
             logger.AssertLogDoesntContain("Made it");
         }
 
+        [Fact]
+        public void TasksOnlyLogStartedEventOnceEach()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectFileContents = ObjectModelHelpers.CleanupFileContents(
+            @"<Project>
+              <Target Name='t'>
+                  <Message Text='Made it'/>
+              </Target>
+            </Project>");
+
+            TransientTestFile projectFile = env.CreateFile("myProj.proj", projectFileContents);
+            env.SetEnvironmentVariable("DOTNET_PERFLOG_DIR", @"C:\Users\namytelk\Desktop");
+
+            string results = RunnerUtilities.ExecMSBuild(projectFile.Path + " /v:diag", out bool success);
+
+            int count = 0;
+            for (int index = results.IndexOf("Task \"Message\""); index >= 0; index = results.IndexOf("Task \"Message\"", index))
+            {
+                count++;
+                index += 14; // Skip to the end of this string
+            }
+
+            count.ShouldBe(1);
+        }
+
         /// <summary>
         /// Tests that when the task condition is false, Execute still returns true even though we never loaded
         /// the task.  We verify that we never loaded the task because if we did try, the task load itself would
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 73e28782ed8..10e697437e2 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -188,6 +188,55 @@ public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
             }
         }
 
+        [Fact]
+        public void AssemblyLoadsDuringTaskRunLogged()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                string contents = $"""
+                    <Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Hello">
+                      <!-- This simple inline task displays "Hello, world!" -->
+                      <UsingTask
+                        TaskName="HelloWorld"
+                        TaskFactory="RoslynCodeTaskFactory"
+                        AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
+                        <ParameterGroup />
+                        <Task> 
+                          <Using Namespace="System"/>
+                          <Using Namespace="System.IO"/>
+                          <Using Namespace="System.Reflection"/>
+                          <Code Type="Fragment" Language="cs">
+                    <![CDATA[
+                        // Display "Hello, world!"
+                        Log.LogMessage("Hello, world!");
+                    	//load assembly
+                    	var assemblies = AppDomain.CurrentDomain.GetAssemblies();
+                    	var diagAssembly = Assembly.LoadFrom(Path.Combine(Path.GetDirectoryName(assemblies[0].Location), "System.Diagnostics.Debug.dll"));
+                    	Log.LogMessage("Loaded: " + diagAssembly);
+                    ]]>
+                          </Code>
+                        </Task>
+                      </UsingTask>
+
+                    <Target Name="Hello">
+                      <HelloWorld />
+                    </Target>
+                    </Project>
+                    """;
+                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+                BinaryLogger logger = new();
+                logger.Parameters = _logFile;
+                env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters}", out bool success);
+                success.ShouldBeTrue();
+                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+                success.ShouldBeTrue();
+                string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
+                text.ShouldContain("Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug");
+            }
+        }
+
         [Fact]
         public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
         {
diff --git a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
index c08c92c9134..0e9ea26e3c7 100644
--- a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
+++ b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
@@ -5,7 +5,10 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Xml;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -254,5 +257,92 @@ public void ProjectEvaluationShouldRespectConditionsIfProjectLoadSettingsSaysSo(
                 });
             }
         }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromFile(string, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromFileInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                Project project = Project.FromFile(
+                    projectRootElement.FullPath,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromProjectRootElement(ProjectRootElement, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromProjectRootElementInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                Project project = Project.FromProjectRootElement(
+                    projectRootElement,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromXmlReader(XmlReader, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromXmlReaderInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                using (XmlReader xmlReader = XmlReader.Create(projectRootElement.FullPath))
+                {
+                    Project project = Project.FromXmlReader(
+                        xmlReader,
+                        new ProjectOptions
+                        {
+                            Interactive = interactive,
+                            ProjectCollection = projectCollection,
+                        });
+
+                    project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+                }
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index fdce69b8b3b..679e8a48178 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -34,6 +34,33 @@ namespace Microsoft.Build.Graph.UnitTests
     public class ProjectGraphSetPlatformTests
     {
 
+        [Fact]
+        public void ValidateGlobalPropertyCopyByValueNotReference()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" />
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+            }
+        }
+
         [Fact]
         public void ValidateSetPlatformOverride()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index 546c42c9432..9cbb3ea8b5f 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
@@ -68,11 +69,11 @@ public void GetTaskRegistrations()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Assert.Equal(3, project.TaskRegistry.TaskRegistrations.Count);
-                Assert.Equal(Path.Combine(Directory.GetCurrentDirectory(), "af0"), project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile);
-                Assert.Equal(Path.Combine(Directory.GetCurrentDirectory(), "af1a"), project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile);
-                Assert.Equal("an1", project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][1].TaskFactoryAssemblyLoadInfo.AssemblyName);
-                Assert.Equal("an2", project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyName);
+                project.TaskRegistry.TaskRegistrations.Count.ShouldBe(3);
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af0"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af1a"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][1].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an1");
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an2");
             }
             finally
             {
@@ -115,8 +116,8 @@ public void InitialTargetsDefaultTargets()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Helpers.AssertListsValueEqual(new string[] { "d0a", "d0b" }, project.DefaultTargets);
-                Helpers.AssertListsValueEqual(new string[] { "i0a", "i0b", "i1a", "i1b", "i3a", "i3b", "i2a", "i2b" }, project.InitialTargets);
+                project.DefaultTargets.ShouldBe(new string[] { "d0a", "d0b" });
+                project.InitialTargets.ShouldBe(new string[] { "i0a", "i0b", "i1a", "i1b", "i3a", "i3b", "i2a", "i2b" });
             }
             finally
             {
@@ -140,8 +141,8 @@ public void InitialTargetsDefaultTargetsEscaped()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Helpers.AssertListsValueEqual(new string[] { "d0a;d0b" }, project.DefaultTargets);
-                Helpers.AssertListsValueEqual(new string[] { "i0a;i0b" }, project.InitialTargets);
+                project.DefaultTargets.ShouldBe(new string[] { "d0a;d0b" });
+                project.InitialTargets.ShouldBe(new string[] { "i0a;i0b" });
             }
             finally
             {
@@ -169,16 +170,16 @@ public void GetPropertyGroupUnderTarget()
             ProjectInstance p = GetProjectInstance(content);
             ProjectPropertyGroupTaskInstance propertyGroup = (ProjectPropertyGroupTaskInstance)(p.Targets["t"].Children[0]);
 
-            Assert.Equal("c1", propertyGroup.Condition);
+            propertyGroup.Condition.ShouldBe("c1");
 
             List<ProjectPropertyGroupTaskPropertyInstance> properties = Helpers.MakeList(propertyGroup.Properties);
-            Assert.Equal(2, properties.Count);
+            properties.Count.ShouldBe(2);
 
-            Assert.Equal("c2", properties[0].Condition);
-            Assert.Equal("v1", properties[0].Value);
+            properties[0].Condition.ShouldBe("c2");
+            properties[0].Value.ShouldBe("v1");
 
-            Assert.Equal(String.Empty, properties[1].Condition);
-            Assert.Equal(String.Empty, properties[1].Value);
+            properties[1].Condition.ShouldBe(String.Empty);
+            properties[1].Value.ShouldBe(String.Empty);
         }
 
         /// <summary>
@@ -207,41 +208,41 @@ public void GetItemGroupUnderTarget()
             ProjectInstance p = GetProjectInstance(content);
             ProjectItemGroupTaskInstance itemGroup = (ProjectItemGroupTaskInstance)(p.Targets["t"].Children[0]);
 
-            Assert.Equal("c1", itemGroup.Condition);
+            itemGroup.Condition.ShouldBe("c1");
 
             List<ProjectItemGroupTaskItemInstance> items = Helpers.MakeList(itemGroup.Items);
-            Assert.Equal(3, items.Count);
+            items.Count.ShouldBe(3);
 
-            Assert.Equal("i1", items[0].Include);
-            Assert.Equal("e1", items[0].Exclude);
-            Assert.Equal(String.Empty, items[0].Remove);
-            Assert.Equal("c2", items[0].Condition);
+            items[0].Include.ShouldBe("i1");
+            items[0].Exclude.ShouldBe("e1");
+            items[0].Remove.ShouldBe(String.Empty);
+            items[0].Condition.ShouldBe("c2");
 
-            Assert.Equal(String.Empty, items[1].Include);
-            Assert.Equal(String.Empty, items[1].Exclude);
-            Assert.Equal("r1", items[1].Remove);
-            Assert.Equal(String.Empty, items[1].Condition);
+            items[1].Include.ShouldBe(String.Empty);
+            items[1].Exclude.ShouldBe(String.Empty);
+            items[1].Remove.ShouldBe("r1");
+            items[1].Condition.ShouldBe(String.Empty);
 
-            Assert.Equal(String.Empty, items[2].Include);
-            Assert.Equal(String.Empty, items[2].Exclude);
-            Assert.Equal(String.Empty, items[2].Remove);
-            Assert.Equal(String.Empty, items[2].Condition);
+            items[2].Include.ShouldBe(String.Empty);
+            items[2].Exclude.ShouldBe(String.Empty);
+            items[2].Remove.ShouldBe(String.Empty);
+            items[2].Condition.ShouldBe(String.Empty);
 
             List<ProjectItemGroupTaskMetadataInstance> metadata1 = Helpers.MakeList(items[0].Metadata);
             List<ProjectItemGroupTaskMetadataInstance> metadata2 = Helpers.MakeList(items[1].Metadata);
             List<ProjectItemGroupTaskMetadataInstance> metadata3 = Helpers.MakeList(items[2].Metadata);
 
-            Assert.Equal(2, metadata1.Count);
-            Assert.Empty(metadata2);
-            Assert.Single(metadata3);
+            metadata1.Count.ShouldBe(2);
+            metadata2.ShouldBeEmpty();
+            metadata3.ShouldHaveSingleItem();
 
-            Assert.Equal("c3", metadata1[0].Condition);
-            Assert.Equal("m1", metadata1[0].Value);
-            Assert.Equal(String.Empty, metadata1[1].Condition);
-            Assert.Equal("n1", metadata1[1].Value);
+            metadata1[0].Condition.ShouldBe("c3");
+            metadata1[0].Value.ShouldBe("m1");
+            metadata1[1].Condition.ShouldBe(String.Empty);
+            metadata1[1].Value.ShouldBe("n1");
 
-            Assert.Equal(String.Empty, metadata3[0].Condition);
-            Assert.Equal("o1", metadata3[0].Value);
+            metadata3[0].Condition.ShouldBe(String.Empty);
+            metadata3[0].Value.ShouldBe("o1");
         }
 
         /// <summary>
@@ -252,7 +253,7 @@ public void GetTaskRegistry()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.True(p.TaskRegistry != null);
+            p.TaskRegistry.ShouldNotBeNull();
         }
 
         /// <summary>
@@ -263,8 +264,8 @@ public void GetGlobalProperties()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.Equal("v1", p.GlobalPropertiesDictionary["g1"].EvaluatedValue);
-            Assert.Equal("v2", p.GlobalPropertiesDictionary["g2"].EvaluatedValue);
+            p.GlobalPropertiesDictionary["g1"].EvaluatedValue.ShouldBe("v1");
+            p.GlobalPropertiesDictionary["g2"].EvaluatedValue.ShouldBe("v2");
         }
 
         /// <summary>
@@ -275,7 +276,7 @@ public void GetToolsVersion()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
+            p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         [Fact]
@@ -298,9 +299,9 @@ public void CloneToolsetData()
             CreateMockToolsetIfNotExists("TESTTV", projectCollection);
             ProjectInstance first = GetSampleProjectInstance(null, null, projectCollection, toolsVersion: "TESTTV");
             ProjectInstance second = first.DeepCopy();
-            Assert.Equal(first.ToolsVersion, second.ToolsVersion);
-            Assert.Equal(first.ExplicitToolsVersion, second.ExplicitToolsVersion);
-            Assert.Equal(first.ExplicitToolsVersionSpecified, second.ExplicitToolsVersionSpecified);
+            second.ToolsVersion.ShouldBe(first.ToolsVersion);
+            second.ExplicitToolsVersion.ShouldBe(first.ExplicitToolsVersion);
+            second.ExplicitToolsVersionSpecified.ShouldBe(first.ExplicitToolsVersionSpecified);
         }
 
         /// <summary>
@@ -317,16 +318,16 @@ public void GetSubToolsetVersion()
 
                 ProjectInstance p = GetSampleProjectInstance(null, null, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal(p.Toolset.DefaultSubToolsetVersion, p.SubToolsetVersion);
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe(p.Toolset.DefaultSubToolsetVersion);
 
                 if (p.Toolset.DefaultSubToolsetVersion == null)
                 {
-                    Assert.Equal(MSBuildConstants.CurrentVisualStudioVersion, p.GetPropertyValue("VisualStudioVersion"));
+                    p.GetPropertyValue("VisualStudioVersion").ShouldBe(MSBuildConstants.CurrentVisualStudioVersion);
                 }
                 else
                 {
-                    Assert.Equal(p.Toolset.DefaultSubToolsetVersion, p.GetPropertyValue("VisualStudioVersion"));
+                    p.GetPropertyValue("VisualStudioVersion").ShouldBe(p.Toolset.DefaultSubToolsetVersion);
                 }
             }
             finally
@@ -350,9 +351,9 @@ public void GetSubToolsetVersion_FromEnvironment()
 
                 ProjectInstance p = GetSampleProjectInstance(null, null, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCD", p.SubToolsetVersion);
-                Assert.Equal("ABCD", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCD");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCD");
             }
             finally
             {
@@ -377,9 +378,9 @@ public void GetSubToolsetVersion_FromProjectGlobalProperties()
 
                 ProjectInstance p = GetSampleProjectInstance(null, globalProperties, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCDE", p.SubToolsetVersion);
-                Assert.Equal("ABCDE", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDE");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDE");
             }
             finally
             {
@@ -416,9 +417,9 @@ public void GetSubToolsetVersion_FromConstructor()
 
                 ProjectInstance p = new ProjectInstance(xml, globalProperties, ObjectModelHelpers.MSBuildDefaultToolsVersion, "ABCDEF", new ProjectCollection(projectCollectionGlobalProperties));
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCDEF", p.SubToolsetVersion);
-                Assert.Equal("ABCDEF", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDEF");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDEF");
             }
             finally
             {
@@ -434,7 +435,7 @@ public void GetDefaultTargets()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Helpers.AssertListsValueEqual(new string[] { "dt" }, p.DefaultTargets);
+            p.DefaultTargets.ShouldBe(new string[] { "dt" });
         }
 
         /// <summary>
@@ -445,7 +446,7 @@ public void GetInitialTargets()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Helpers.AssertListsValueEqual(new string[] { "it" }, p.InitialTargets);
+            p.InitialTargets.ShouldBe(new string[] { "it" });
         }
 
         /// <summary>
@@ -460,13 +461,14 @@ public void CloneTargets()
             ProjectInstance second = first.DeepCopy();
 
             // Targets, tasks are immutable so we can expect the same objects
-            Assert.True(Object.ReferenceEquals(first.Targets, second.Targets));
-            Assert.True(Object.ReferenceEquals(first.Targets["t"], second.Targets["t"]));
+            first.Targets.ShouldBeSameAs(second.Targets);
+
+            first.Targets["t"].ShouldBeSameAs(second.Targets["t"]);
 
             var firstTasks = first.Targets["t"];
             var secondTasks = second.Targets["t"];
 
-            Assert.True(Object.ReferenceEquals(firstTasks.Children[0], secondTasks.Children[0]));
+            firstTasks.Children[0].ShouldBeSameAs(secondTasks.Children[0]);
         }
 
         /// <summary>
@@ -479,7 +481,7 @@ public void CloneTaskRegistry()
             ProjectInstance second = first.DeepCopy();
 
             // Task registry object should be immutable
-            Assert.Same(first.TaskRegistry, second.TaskRegistry);
+            first.TaskRegistry.ShouldBeSameAs(second.TaskRegistry);
         }
 
         /// <summary>
@@ -491,8 +493,8 @@ public void CloneGlobalProperties()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.Equal("v1", second.GlobalPropertiesDictionary["g1"].EvaluatedValue);
-            Assert.Equal("v2", second.GlobalPropertiesDictionary["g2"].EvaluatedValue);
+            second.GlobalPropertiesDictionary["g1"].EvaluatedValue.ShouldBe("v1");
+            second.GlobalPropertiesDictionary["g2"].EvaluatedValue.ShouldBe("v2");
         }
 
         /// <summary>
@@ -504,7 +506,7 @@ public void CloneDefaultTargets()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Helpers.AssertListsValueEqual(new string[] { "dt" }, second.DefaultTargets);
+            second.DefaultTargets.ShouldBe(new string[] { "dt" });
         }
 
         /// <summary>
@@ -516,7 +518,7 @@ public void CloneInitialTargets()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Helpers.AssertListsValueEqual(new string[] { "it" }, second.InitialTargets);
+            second.InitialTargets.ShouldBe(new string[] { "it" });
         }
 
         /// <summary>
@@ -528,7 +530,7 @@ public void CloneToolsVersion()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.Equal(first.Toolset, second.Toolset);
+            second.Toolset.ShouldBe(first.Toolset);
         }
 
         /// <summary>
@@ -542,7 +544,7 @@ public void CloneStateTranslation()
 
             ProjectInstance second = first.DeepCopy();
 
-            Assert.True(second.TranslateEntireState);
+            second.TranslateEntireState.ShouldBeTrue();
         }
 
         /// <summary>
@@ -574,7 +576,7 @@ public void Build()
             loggers.Add(mockLogger);
             bool success = projectInstance.Build("Build", loggers);
 
-            Assert.True(success);
+            success.ShouldBeTrue();
             mockLogger.AssertLogContains(new string[] { "Building...", "Completed!" });
         }
 
@@ -684,7 +686,7 @@ public void ProjectInstanceCanSerializeEntireStateViaTranslator(string projectCo
             ((ITranslatable)original).Translate(TranslationHelpers.GetWriteTranslator());
             var copy = ProjectInstance.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(original, copy, new ProjectInstanceComparer());
+            new ProjectInstanceComparer().Equals(original, copy).ShouldBeTrue($"{nameof(copy)} and {original} should be equal according to the {nameof(ProjectInstanceComparer)}");
         }
 
         public delegate ProjectInstance ProjectInstanceFactory(string file, ProjectRootElement xml, ProjectCollection collection);
@@ -757,7 +759,7 @@ public void ProjectInstanceHasEvaluationId(ProjectInstanceFactory projectInstanc
                 xml.Save(file);
 
                 var projectInstance = projectInstanceFactory.Invoke(file, xml, projectCollection);
-                Assert.NotEqual(BuildEventContext.InvalidEvaluationId, projectInstance.EvaluationId);
+                projectInstance.EvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
             }
         }
 
@@ -773,27 +775,27 @@ public void AddTargetAddsNewTarget()
 
             ProjectTargetInstance targetInstance = projectInstance.AddTarget("b", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true);
 
-            Assert.Equal(2, projectInstance.Targets.Count);
-            Assert.Equal(targetInstance, projectInstance.Targets["b"]);
-            Assert.Equal("b", targetInstance.Name);
-            Assert.Equal("1==1", targetInstance.Condition);
-            Assert.Equal("inputs", targetInstance.Inputs);
-            Assert.Equal("outputs", targetInstance.Outputs);
-            Assert.Equal("returns", targetInstance.Returns);
-            Assert.Equal("keepDuplicateOutputs", targetInstance.KeepDuplicateOutputs);
-            Assert.Equal("dependsOnTargets", targetInstance.DependsOnTargets);
-            Assert.Equal("beforeTargets", targetInstance.BeforeTargets);
-            Assert.Equal("afterTargets", targetInstance.AfterTargets);
-            Assert.Equal(projectInstance.ProjectFileLocation, targetInstance.Location);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.ConditionLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.InputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.OutputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.ReturnsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.KeepDuplicateOutputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.DependsOnTargetsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.BeforeTargetsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.AfterTargetsLocation);
-            Assert.True(targetInstance.ParentProjectSupportsReturnsAttribute);
+            projectInstance.Targets.Count.ShouldBe(2);
+            projectInstance.Targets["b"].ShouldBe(targetInstance);
+            targetInstance.Name.ShouldBe("b");
+            targetInstance.Condition.ShouldBe("1==1");
+            targetInstance.Inputs.ShouldBe("inputs");
+            targetInstance.Outputs.ShouldBe("outputs");
+            targetInstance.Returns.ShouldBe("returns");
+            targetInstance.KeepDuplicateOutputs.ShouldBe("keepDuplicateOutputs");
+            targetInstance.DependsOnTargets.ShouldBe("dependsOnTargets");
+            targetInstance.BeforeTargets.ShouldBe("beforeTargets");
+            targetInstance.AfterTargets.ShouldBe("afterTargets");
+            targetInstance.Location.ShouldBe(projectInstance.ProjectFileLocation);
+            targetInstance.ConditionLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.InputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.OutputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.ReturnsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.KeepDuplicateOutputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.DependsOnTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.BeforeTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.AfterTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.ParentProjectSupportsReturnsAttribute.ShouldBeTrue();
         }
 
         [Fact]
@@ -806,7 +808,7 @@ public void AddTargetThrowsWithExistingTarget()
             ProjectRootElement rootElement = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
             ProjectInstance projectInstance = new ProjectInstance(rootElement);
 
-            Assert.Throws<InternalErrorException>(() => projectInstance.AddTarget("a", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true));
+            Should.Throw<InternalErrorException>(() => projectInstance.AddTarget("a", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true));
         }
 
         [Theory]
@@ -856,8 +858,8 @@ public void GetImportPathsAndImportPathsIncludingDuplicates(bool useDirectConstr
                     ? new string[] { import1Path, import2Path, import3Path, import2Path, import1Path }
                     : expectedImportPaths;
 
-                Helpers.AssertListsValueEqual(expectedImportPaths, projectInstance.ImportPaths.ToList());
-                Helpers.AssertListsValueEqual(expectedImportPathsIncludingDuplicates, projectInstance.ImportPathsIncludingDuplicates.ToList());
+                projectInstance.ImportPaths.ToList().ShouldBe(expectedImportPaths);
+                projectInstance.ImportPathsIncludingDuplicates.ToList().ShouldBe(expectedImportPathsIncludingDuplicates);
             }
             finally
             {
@@ -865,6 +867,62 @@ public void GetImportPathsAndImportPathsIncludingDuplicates(bool useDirectConstr
             }
         }
 
+        /// <summary>
+        /// Verifies that when calling <see cref="ProjectInstance.FromFile(string, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectInstanceFromFileInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                ProjectInstance projectInstance = ProjectInstance.FromFile(
+                    projectRootElement.FullPath,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                projectInstance.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="ProjectInstance.FromProjectRootElement(ProjectRootElement, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectInstanceFromProjectRootElementInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                ProjectInstance projectInstance = ProjectInstance.FromProjectRootElement(
+                    projectRootElement,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                projectInstance.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
         /// <summary>
         /// Create a ProjectInstance from provided project content
         /// </summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 3e926e2e75e..1ded6e6fc8a 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -5,8 +5,9 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
-using Microsoft.Build.Execution;
+using System.Linq;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Execution;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
@@ -289,15 +290,7 @@ public List<BuildRequestConfiguration> GetUnresolvedConfigurationsToIssue()
         /// </summary>
         public string[] GetActiveTargets()
         {
-            var activeTargets = new string[RequestConfiguration.ActivelyBuildingTargets.Count];
-
-            int index = 0;
-            foreach (string target in RequestConfiguration.ActivelyBuildingTargets.Keys)
-            {
-                activeTargets[index++] = target;
-            }
-
-            return activeTargets;
+            return RequestConfiguration.ActivelyBuildingTargets.Keys.ToArray();
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 3b88899af8b..7346954557d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -286,6 +286,11 @@ bool TryReuseAnyFromPossibleRunningNodes(int nodeId)
                     {
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeToReuse.Id);
+                        string msg = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("NodeReused", nodeId, nodeToReuse.Id);
+                        _componentHost.LoggingService.LogBuildEvent(new BuildMessageEventArgs(msg, null, null, MessageImportance.Low)
+                        {
+                            BuildEventContext = new BuildEventContext(nodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId)
+                        });
 
                         CreateNodeContext(nodeId, nodeToReuse, nodeStream);
                         return true;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 1998da2733d..0f80c152ba5 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -8,6 +8,8 @@
 using System.Linq;
 using System.Reflection;
 using System.Threading;
+using Microsoft.Build.BackEnd.Components.RequestBuilder;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
@@ -1589,8 +1591,20 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
         /// <exception cref="Exception">Any exception which is a ExceptionHandling.IsCriticalException will not be wrapped</exception>
         private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
         {
+            ILogger UnwrapLoggerType(ILogger log)
+            {
+                while (log is ProjectCollection.ReusableLogger reusableLogger)
+                {
+                    log = reusableLogger.OriginalLogger;
+                }
+
+                return log;
+            }
+
             try
             {
+                using var assemblyLoadTracker = AssemblyLoadsTracker.StartTracking(this, AssemblyLoadingContext.LoggerInitialization, UnwrapLoggerType(logger).GetType());
+
                 INodeLogger nodeLogger = logger as INodeLogger;
                 if (nodeLogger != null)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
new file mode 100644
index 00000000000..0f9f1858b52
--- /dev/null
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -0,0 +1,174 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+#if FEATURE_APPDOMAIN
+using System.Collections.Generic;
+using System.Linq;
+#endif
+using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BackEnd.Components.RequestBuilder
+{
+    internal sealed class AssemblyLoadsTracker : MarshalByRefObject, IDisposable
+    {
+#if FEATURE_APPDOMAIN
+        private static readonly List<AssemblyLoadsTracker> s_instances = new();
+#endif
+        private readonly LoggingContext? _loggingContext;
+        private readonly LoggingService? _loggingService;
+        private readonly AssemblyLoadingContext _context;
+        private readonly string? _initiator;
+        private readonly AppDomain _appDomain;
+
+        private AssemblyLoadsTracker(
+            LoggingContext? loggingContext,
+            LoggingService? loggingService,
+            AssemblyLoadingContext context,
+            Type? initiator,
+            AppDomain appDomain)
+        {
+            _loggingContext = loggingContext;
+            _loggingService = loggingService;
+            _context = context;
+            _initiator = initiator?.FullName;
+            _appDomain = appDomain;
+        }
+
+        public static IDisposable StartTracking(
+            LoggingContext loggingContext,
+            AssemblyLoadingContext context,
+            Type? initiator,
+            AppDomain? appDomain = null)
+            => StartTracking(loggingContext, null, context, initiator, null, appDomain);
+
+        public static IDisposable StartTracking(
+            LoggingContext loggingContext,
+            AssemblyLoadingContext context,
+            string? initiator = null,
+            AppDomain? appDomain = null)
+            => StartTracking(loggingContext, null, context, null, initiator, appDomain);
+
+        public static IDisposable StartTracking(
+            LoggingService loggingService,
+            AssemblyLoadingContext context,
+            Type initiator,
+            AppDomain? appDomain = null)
+            => StartTracking(null, loggingService, context, initiator, null, appDomain);
+
+
+
+#if FEATURE_APPDOMAIN
+        public static void StopTracking(AppDomain appDomain)
+        {
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !appDomain.IsDefaultAppDomain())
+            {
+                lock (s_instances)
+                {
+                    foreach (AssemblyLoadsTracker tracker in s_instances.Where(t => t._appDomain == appDomain))
+                    {
+                        tracker.StopTracking();
+                    }
+
+                    s_instances.RemoveAll(t => t._appDomain == appDomain);
+                }
+            }
+        }
+#endif
+
+        public void Dispose()
+        {
+            StopTracking();
+        }
+
+        private static bool IsBuiltinType(string? typeName)
+        {
+            if (string.IsNullOrEmpty(typeName))
+            {
+                return false;
+            }
+
+            return typeName!.StartsWith("Microsoft.Build", StringComparison.Ordinal) ||
+                   typeName.StartsWith("Microsoft.NET.Build", StringComparison.Ordinal) ||
+                   typeName.StartsWith("Microsoft.NET.Sdk", StringComparison.Ordinal);
+        }
+
+        private static IDisposable StartTracking(
+            LoggingContext? loggingContext,
+            LoggingService? loggingService,
+            AssemblyLoadingContext context,
+            Type? initiatorType,
+            string? initiatorName,
+            AppDomain? appDomain)
+        {
+            if (
+                // Feature is not enabled
+                !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
+                (
+                    // We do not want to load all assembly loads (including those triggered by builtin types)
+                    !Traits.Instance.LogAllAssemblyLoads &&
+                    (
+                        // Load will be initiated by internal type - so we are not interested in those
+                        initiatorType?.Assembly == Assembly.GetExecutingAssembly()
+                        ||
+                        IsBuiltinType(initiatorType?.FullName)
+                        ||
+                        IsBuiltinType(initiatorName)
+                    )
+                )
+            )
+            {
+                return EmptyDisposable.Instance;
+            }
+
+            var tracker = new AssemblyLoadsTracker(loggingContext, loggingService, context, initiatorType, appDomain ?? AppDomain.CurrentDomain);
+#if FEATURE_APPDOMAIN
+            if (appDomain != null && !appDomain.IsDefaultAppDomain())
+            {
+                lock (s_instances)
+                {
+                    s_instances.Add(tracker);
+                }
+            }
+#endif
+            tracker.StartTracking();
+            return tracker;
+        }
+
+        private void StartTracking()
+        {
+            _appDomain.AssemblyLoad += CurrentDomainOnAssemblyLoad;
+        }
+
+        private void StopTracking()
+        {
+            _appDomain.AssemblyLoad -= CurrentDomainOnAssemblyLoad;
+        }
+
+        private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs args)
+        {
+            string? assemblyName = args.LoadedAssembly.FullName;
+            string assemblyPath = args.LoadedAssembly.IsDynamic ? string.Empty : args.LoadedAssembly.Location;
+            Guid mvid = args.LoadedAssembly.ManifestModule.ModuleVersionId;
+            string? appDomainDescriptor = _appDomain.IsDefaultAppDomain()
+                ? null
+                : $"{_appDomain.Id}|{_appDomain.FriendlyName}";
+
+
+            AssemblyLoadBuildEventArgs buildArgs = new(_context, _initiator, assemblyName, assemblyPath, mvid, appDomainDescriptor)
+            {
+                BuildEventContext = _loggingContext?.BuildEventContext ?? BuildEventContext.Invalid
+            };
+            _loggingContext?.LogBuildEvent(buildArgs);
+            _loggingService?.LogBuildEvent(buildArgs);
+        }
+
+        private class EmptyDisposable : IDisposable
+        {
+            public static readonly IDisposable Instance = new EmptyDisposable();
+            public void Dispose() { }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index bb99f7d5237..2f444fce909 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -200,7 +200,7 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
                          * 
                          */
                         ErrorUtilities.VerifyThrow(itemVectorsReferencedInBothTargetInputsAndOutputs.Count > 0, "The target must have inputs.");
-                        ErrorUtilities.VerifyThrow(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs).Count > 0, "The target must have inputs.");
+                        ErrorUtilities.VerifyThrow(!IsItemVectorEmpty(itemVectorsInTargetInputs), "The target must have inputs.");
 
                         result = PerformDependencyAnalysisIfDiscreteInputs(itemVectorsInTargetInputs,
                                     itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs, itemVectorsReferencedOnlyInTargetInputs,
@@ -510,7 +510,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteInputs(
             // cannot correlate them to any output item
             foreach (string itemVectorType in itemVectorsReferencedOnlyInTargetInputs)
             {
-                discreteTargetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs, itemVectorType));
+                discreteTargetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs, itemVectorType, itemVectorsInTargetInputs[itemVectorType]));
             }
 
             // if there are any discrete input items, we can treat them as "meta" inputs, because:
@@ -840,6 +840,19 @@ private void SeparateItemVectorsFromDiscreteItems(
             }
         }
 
+        private static bool IsItemVectorEmpty(ItemVectorPartitionCollection itemVectors)
+        {
+            foreach (KeyValuePair<string, ItemVectorPartition> item in itemVectors)
+            {
+                if (GetItemSpecsFromItemVectors(itemVectors, item.Key, item.Value).Any())
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
         /// <summary>
         /// Retrieves the item-specs of all items in the given item vector collection.
         /// </summary>
@@ -847,11 +860,11 @@ private void SeparateItemVectorsFromDiscreteItems(
         /// <returns>list of item-specs</returns>
         private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors)
         {
-            List<string> itemSpecs = new List<string>();
+            List<string> itemSpecs = new();
 
-            foreach (string itemType in itemVectors.Keys)
+            foreach (KeyValuePair<string, ItemVectorPartition> item in itemVectors)
             {
-                itemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectors, itemType));
+                itemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectors, item.Key, item.Value));
             }
 
             return itemSpecs;
@@ -862,13 +875,10 @@ private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionColle
         /// </summary>
         /// <param name="itemVectors"></param>
         /// <param name="itemType"></param>
+        /// <param name="itemVectorPartition"></param>
         /// <returns>list of item-specs</returns>
-        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, string itemType)
+        private static IEnumerable<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, string itemType, ItemVectorPartition itemVectorPartition)
         {
-            List<string> itemSpecs = new List<string>();
-
-            ItemVectorPartition itemVectorPartition = itemVectors[itemType];
-
             if (itemVectorPartition != null)
             {
                 foreach (IList<ProjectItemInstance> items in itemVectorPartition.Values)
@@ -878,12 +888,10 @@ private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionColle
                         // The item can be null in the case of an item transform.
                         // eg., @(Compile->'%(NonExistentMetadata)')
                         // Nevertheless, include these, so that correlation can still occur.
-                        itemSpecs.Add((item == null) ? null : ((IItem)item).EvaluatedIncludeEscaped);
+                        yield return item == null ? null : ((IItem)item).EvaluatedIncludeEscaped;
                     }
                 }
             }
-
-            return itemSpecs;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index f90ce5d8024..f8768988732 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -13,6 +13,7 @@
 #endif
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Components.RequestBuilder;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -390,12 +391,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             }
 
             // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-            if (MSBuildEventSource.Log.IsEnabled())
-            {
-                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-            }
-
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
@@ -432,6 +427,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                     if (requirements != null)
                     {
                         TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
                         try
@@ -486,6 +482,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                                 // We coerce the failing result to a successful result.
                                 taskResult = new WorkUnitResult(WorkUnitResultCode.Success, taskResult.ActionCode, taskResult.Exception);
                             }
+
+                            MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         }
                     }
                 }
@@ -513,13 +511,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 }
             }
 
-            // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-            if (MSBuildEventSource.Log.IsEnabled())
-            {
-                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-            }
-
             return taskResult;
         }
 
@@ -661,6 +652,8 @@ private async Task<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext t
                 ProjectErrorUtilities.ThrowInvalidProject(_targetChildInstance.Location, "TaskDeclarationOrUsageError", _taskNode.Name);
             }
 
+            using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun, (_taskExecutionHost as TaskExecutionHost)?.TaskInstance?.GetType());
+
             try
             {
                 // UNDONE: Move this and the task host.
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 0c11f731cb5..bedccfe03cd 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -906,53 +906,53 @@ private bool GetSchedulingPlanAndAlgorithm()
         /// </summary>
         private void AssignUnscheduledRequestsWithPlanByMostImmediateReferences(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
-            foreach (int idleNodeId in idleNodes)
-            {
-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();
-
-                // Find the most expensive request in the plan to schedule from among the ones available.
-                foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
-                {
-                    if (CanScheduleRequestToNode(request, idleNodeId))
-                    {
-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;
-                    }
-                }
-
-                if (configsWhichCanBeScheduledToThisNode.Count > 0)
-                {
-                    int configToSchedule = _schedulingPlan.GetConfigWithGreatestNumberOfReferences(configsWhichCanBeScheduledToThisNode.Keys);
-
-                    ErrorUtilities.VerifyThrow(configToSchedule != BuildRequestConfiguration.InvalidConfigurationId, "No configuration returned even though there are some available.");
-                    AssignUnscheduledRequestToNode(configsWhichCanBeScheduledToThisNode[configToSchedule], idleNodeId, responses);
-                }
-            }
+            AssignUnscheduledRequestsWithPlan(responses, idleNodes, (plan1, plan2) => plan1.ReferencesCount < plan2.ReferencesCount);
         }
 
         /// <summary>
         /// Assigns requests to nodes based on those which have the most plan time.
         /// </summary>
         private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleResponse> responses, HashSet<int> idleNodes)
+        {
+            AssignUnscheduledRequestsWithPlan(responses, idleNodes, (plan1, plan2) => plan1.TotalPlanTime < plan2.TotalPlanTime);
+        }
+
+        private void AssignUnscheduledRequestsWithPlan(List<ScheduleResponse> responses, HashSet<int> idleNodes, Func<SchedulingPlan.PlanConfigData, SchedulingPlan.PlanConfigData, bool> comparisonFunction)
         {
             foreach (int idleNodeId in idleNodes)
             {
-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();
+                SchedulingPlan.PlanConfigData bestConfig = null;
+                SchedulableRequest bestRequest = null;
 
                 // Find the most expensive request in the plan to schedule from among the ones available.
                 foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
                 {
                     if (CanScheduleRequestToNode(request, idleNodeId))
                     {
-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;
+                        SchedulingPlan.PlanConfigData configToConsider = _schedulingPlan.GetConfiguration(request.BuildRequest.ConfigurationId);
+                        if (configToConsider is null)
+                        {
+                            if (bestConfig is null)
+                            {
+                                // By default we assume configs we don't know about aren't as important, and will only schedule them
+                                // if nothing else is suitable
+                                bestRequest ??= request;
+                            }
+                        }
+                        else
+                        {
+                            if (bestConfig is null || comparisonFunction(bestConfig, configToConsider))
+                            {
+                                bestConfig = configToConsider;
+                                bestRequest = request;
+                            }
+                        }
                     }
                 }
 
-                if (configsWhichCanBeScheduledToThisNode.Count > 0)
+                if (bestRequest is not null)
                 {
-                    int configToSchedule = _schedulingPlan.GetConfigWithGreatestPlanTime(configsWhichCanBeScheduledToThisNode.Keys);
-
-                    ErrorUtilities.VerifyThrow(configToSchedule != BuildRequestConfiguration.InvalidConfigurationId, "No configuration returned even though there are some available.");
-                    AssignUnscheduledRequestToNode(configsWhichCanBeScheduledToThisNode[configToSchedule], idleNodeId, responses);
+                    AssignUnscheduledRequestToNode(bestRequest, idleNodeId, responses);
                 }
             }
         }
@@ -962,23 +962,7 @@ private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleRe
         /// </summary>
         private void AssignUnscheduledRequestsByTraversalsFirst(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
-            if (idleNodes.Contains(InProcNodeId))
-            {
-                // Assign traversal projects first (to find more work.)
-                List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
-                foreach (SchedulableRequest request in unscheduledRequests)
-                {
-                    if (CanScheduleRequestToNode(request, InProcNodeId))
-                    {
-                        if (IsTraversalRequest(request.BuildRequest))
-                        {
-                            AssignUnscheduledRequestToNode(request, InProcNodeId, responses);
-                            idleNodes.Remove(InProcNodeId);
-                            break;
-                        }
-                    }
-                }
-            }
+            AssignUnscheduledRequestsToInProcNode(responses, idleNodes, request => IsTraversalRequest(request.BuildRequest));
         }
 
         /// <summary>
@@ -986,13 +970,18 @@ private void AssignUnscheduledRequestsByTraversalsFirst(List<ScheduleResponse> r
         /// paying the IPC cost and re-evaluating them on out of proc nodes (they are guaranteed to be evaluated in the Scheduler process).
         /// </summary>
         private void AssignUnscheduledProxyBuildRequestsToInProcNode(List<ScheduleResponse> responses, HashSet<int> idleNodes)
+        {
+            AssignUnscheduledRequestsToInProcNode(responses, idleNodes, request => request.IsProxyBuildRequest());
+        }
+
+        private void AssignUnscheduledRequestsToInProcNode(List<ScheduleResponse> responses, HashSet<int> idleNodes, Func<SchedulableRequest, bool> shouldBeScheduled)
         {
             if (idleNodes.Contains(InProcNodeId))
             {
                 List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
                 foreach (SchedulableRequest request in unscheduledRequests)
                 {
-                    if (CanScheduleRequestToNode(request, InProcNodeId) && request.IsProxyBuildRequest())
+                    if (CanScheduleRequestToNode(request, InProcNodeId) && shouldBeScheduled(request))
                     {
                         AssignUnscheduledRequestToNode(request, InProcNodeId, responses);
                         idleNodes.Remove(InProcNodeId);
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 022b6acf9d0..19f75d8da72 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -56,6 +56,12 @@ public SchedulingPlan(IConfigCache configCache, SchedulingData schedulingData)
             this.MaximumConfigurationId = BuildRequestConfiguration.InvalidConfigurationId;
         }
 
+        public PlanConfigData GetConfiguration(int configId)
+        {
+            _configPathToData.TryGetValue(_configCache[configId].ProjectFullPath, out PlanConfigData data);
+            return data;
+        }
+
         /// <summary>
         /// Returns true if a valid plan was read, false otherwise.
         /// </summary>
@@ -104,11 +110,11 @@ public void WritePlan(int submissionId, ILoggingService loggingService, BuildEve
                     Dictionary<int, double> accumulatedTimeByConfiguration = new Dictionary<int, double>();
                     RecursiveAccumulateConfigurationTimes(rootRequest, accumulatedTimeByConfiguration);
 
-                    List<int> configurationsInOrder = new List<int>(accumulatedTimeByConfiguration.Keys);
-                    configurationsInOrder.Sort();
-                    foreach (int configId in configurationsInOrder)
+                    List<KeyValuePair<int, double>> configurationsInOrder = new(accumulatedTimeByConfiguration);
+                    configurationsInOrder.Sort((KeyValuePair<int, double> l, KeyValuePair<int, double> r) => Comparer<int>.Default.Compare(l.Key, r.Key));
+                    foreach (KeyValuePair<int, double> configuration in configurationsInOrder)
                     {
-                        file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configId, accumulatedTimeByConfiguration[configId], _configCache[configId].ProjectFullPath));
+                        file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configuration.Key, configuration.Value, _configCache[configuration.Key].ProjectFullPath));
                     }
 
                     file.WriteLine();
@@ -192,80 +198,6 @@ public int GetConfigIdForPath(string configPath)
             return config.ConfigId;
         }
 
-        /// <summary>
-        /// Given a list of configuration IDs, returns the id of the config with the greatest number of immediate references.
-        /// </summary>
-        /// <param name="configsToSchedule">The set of configurations to consider.</param>
-        /// <returns>The id of the configuration with the most immediate references.</returns>
-        public int GetConfigWithGreatestNumberOfReferences(IEnumerable<int> configsToSchedule)
-        {
-            return GetConfigWithComparison(configsToSchedule, delegate (PlanConfigData left, PlanConfigData right) { return Comparer<int>.Default.Compare(left.ReferencesCount, right.ReferencesCount); });
-        }
-
-        /// <summary>
-        /// Given a list of real configuration IDs, returns the id of the config with the largest plan time.
-        /// </summary>
-        public int GetConfigWithGreatestPlanTime(IEnumerable<int> realConfigsToSchedule)
-        {
-            return GetConfigWithComparison(realConfigsToSchedule, delegate (PlanConfigData left, PlanConfigData right) { return Comparer<double>.Default.Compare(left.TotalPlanTime, right.TotalPlanTime); });
-        }
-
-        /// <summary>
-        /// Determines how many references a config with a particular path has.
-        /// </summary>
-        public int GetReferencesCountForConfigByPath(string configFullPath)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configFullPath, out data))
-            {
-                return 0;
-            }
-
-            return data.ReferencesCount;
-        }
-
-        /// <summary>
-        /// Advances the state of the plan by removing the specified config from all paths
-        /// </summary>
-        public void VisitConfig(string configName)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configName, out data))
-            {
-                return;
-            }
-
-            // UNDONE: Parallelize
-            foreach (List<Stack<PlanConfigData>> paths in _configIdToPaths.Values)
-            {
-                foreach (Stack<PlanConfigData> path in paths)
-                {
-                    if (path.Count > 0 && path.Peek() == data)
-                    {
-                        path.Pop();
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Advances the state of the plan by zeroing out the time spend on the config.
-        /// </summary>
-        public void CompleteConfig(string configName)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configName, out data))
-            {
-                return;
-            }
-
-            ErrorUtilities.VerifyThrow(data.AccumulatedTimeOfReferences < 0.00001, "Unexpected config completed before references were completed.");
-
-            // Recursively subtract the amount of time from this config's referrers.
-            data.RecursivelyApplyReferenceTimeToReferrers(-data.AccumulatedTime);
-            data.AccumulatedTime = 0;
-        }
-
         /// <summary>
         /// Gets the name of the plan file for a specified submission.
         /// </summary>
@@ -279,39 +211,6 @@ private string GetPlanName(SchedulableRequest rootRequest)
             return _configCache[rootRequest.BuildRequest.ConfigurationId].ProjectFullPath + ".buildplan";
         }
 
-        /// <summary>
-        /// Returns the config id with the greatest value according to the comparer.
-        /// </summary>
-        private int GetConfigWithComparison(IEnumerable<int> realConfigsToSchedule, Comparison<PlanConfigData> comparer)
-        {
-            PlanConfigData bestConfig = null;
-            int bestRealConfigId = BuildRequestConfiguration.InvalidConfigurationId;
-
-            foreach (int realConfigId in realConfigsToSchedule)
-            {
-                PlanConfigData configToConsider;
-                if (!_configPathToData.TryGetValue(_configCache[realConfigId].ProjectFullPath, out configToConsider))
-                {
-                    // By default we assume configs we don't know about aren't as important, and will only schedule them
-                    // if nothing else is suitable
-                    if (bestRealConfigId == BuildRequestConfiguration.InvalidConfigurationId)
-                    {
-                        bestRealConfigId = realConfigId;
-                    }
-
-                    continue;
-                }
-
-                if (bestConfig == null || (comparer(bestConfig, configToConsider) < 0))
-                {
-                    bestConfig = configToConsider;
-                    bestRealConfigId = realConfigId;
-                }
-            }
-
-            return bestRealConfigId;
-        }
-
         /// <summary>
         /// Analyzes the plan data which has been read.
         /// </summary>
@@ -334,12 +233,12 @@ private void AnalyzeData()
         /// </summary>
         private void DetermineConfigsWithGreatestPlanTime()
         {
-            List<int> projectsInOrderOfTotalPlanTime = new List<int>(_configIdToData.Keys);
-            projectsInOrderOfTotalPlanTime.Sort(delegate (int left, int right) { return -Comparer<double>.Default.Compare(_configIdToData[left].TotalPlanTime, _configIdToData[right].TotalPlanTime); });
-            foreach (int configId in projectsInOrderOfTotalPlanTime)
+            List<KeyValuePair<int, PlanConfigData>> projectsInOrderOfTotalPlanTime = new(_configIdToData);
+            projectsInOrderOfTotalPlanTime.Sort((left, right) => Comparer<double>.Default.Compare(right.Value.TotalPlanTime, left.Value.TotalPlanTime));
+            foreach (KeyValuePair<int, PlanConfigData> configuration in projectsInOrderOfTotalPlanTime)
             {
-                PlanConfigData config = _configIdToData[configId];
-                Console.WriteLine("{0}: {1} ({2} referrers) {3}", configId, config.TotalPlanTime, config.ReferrerCount, config.ConfigFullPath);
+                PlanConfigData config = configuration.Value;
+                Console.WriteLine("{0}: {1} ({2} referrers) {3}", configuration.Key, config.TotalPlanTime, config.ReferrerCount, config.ConfigFullPath);
                 foreach (PlanConfigData referrer in config.Referrers)
                 {
                     Console.WriteLine("     {0} {1}", referrer.ConfigId, referrer.ConfigFullPath);
@@ -357,11 +256,11 @@ private void DetermineConfigsWithGreatestPlanTime()
         private void DetermineConfigsWithTheMostImmediateReferences()
         {
             Console.WriteLine("Projects with the most immediate children:");
-            List<int> projectsInOrderOfImmediateChildCount = new List<int>(_configIdToData.Keys);
-            projectsInOrderOfImmediateChildCount.Sort(delegate (int left, int right) { return -Comparer<int>.Default.Compare(_configIdToData[left].ReferencesCount, _configIdToData[right].ReferencesCount); });
-            foreach (int configId in projectsInOrderOfImmediateChildCount)
+            List<KeyValuePair<int, PlanConfigData>> projectsInOrderOfImmediateChildCount = new(_configIdToData);
+            projectsInOrderOfImmediateChildCount.Sort((left, right) => Comparer<int>.Default.Compare(right.Value.ReferencesCount, left.Value.ReferencesCount));
+            foreach (KeyValuePair<int, PlanConfigData> configuration in projectsInOrderOfImmediateChildCount)
             {
-                Console.WriteLine("{0}: {1} {2}", configId, _configIdToData[configId].ReferencesCount, _configIdToData[configId].ConfigFullPath);
+                Console.WriteLine("{0}: {1} {2}", configuration.Key, configuration.Value.ReferencesCount, configuration.Value.ConfigFullPath);
             }
 
             Console.WriteLine();
@@ -577,7 +476,7 @@ private void RecursiveAccumulateConfigurationTimes(SchedulableRequest request, D
         /// <summary>
         /// The data associated with a config as read from a build plan.
         /// </summary>
-        private class PlanConfigData
+        internal class PlanConfigData
         {
             /// <summary>
             /// The configuration id.
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index ca443451880..149ec426518 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -598,9 +598,9 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)
         /// </summary>
         internal void CacheIfPossible()
         {
-            foreach (string target in _resultsByTarget.Keys)
+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget)
             {
-                _resultsByTarget[target].CacheItems(ConfigurationId, target);
+                targetResultPair.Value.CacheItems(ConfigurationId, targetResultPair.Key);
             }
         }
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index c3df653db94..7db7747eea1 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -257,12 +257,12 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -273,7 +273,7 @@ private Project(ProjectRootElement xml, IDictionary<string, string> globalProper
             implementation = defaultImplementation;
 
             _directoryCacheFactory = directoryCacheFactory;
-            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
         }
 
         /// <summary>
@@ -351,12 +351,12 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -367,7 +367,7 @@ private Project(XmlReader xmlReader, IDictionary<string, string> globalPropertie
             implementation = defaultImplementation;
 
             _directoryCacheFactory = directoryCacheFactory;
-            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
         }
 
         /// <summary>
@@ -447,12 +447,12 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -469,7 +469,7 @@ private Project(string projectFile, IDictionary<string, string> globalProperties
             // seems the XmlReader based one should also clean the same way.
             try
             {
-                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
             }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
@@ -500,7 +500,8 @@ public static Project FromFile(string file, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -518,7 +519,8 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -536,7 +538,8 @@ public static Project FromXmlReader(XmlReader reader, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -1871,6 +1874,11 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// </summary>
             private RenameHandlerDelegate _renameHandler;
 
+            /// <summary>
+            /// Indicates if the process of loading the project is allowed to interact with the user.
+            /// </summary>
+            private bool _interactive = false;
+
             /// <summary>
             ///
             /// </summary>
@@ -3733,7 +3741,8 @@ private void Reevaluate(
                     s_buildEventContext,
                     evaluationContext.SdkResolverService,
                     BuildEventContext.InvalidSubmissionId,
-                    evaluationContext);
+                    evaluationContext,
+                    _interactive);
 
                 ErrorUtilities.VerifyThrow(LastEvaluationId != BuildEventContext.InvalidEvaluationId, "Evaluation should produce an evaluation ID");
 
@@ -3766,7 +3775,7 @@ private void Reevaluate(
             /// Global properties may be null.
             /// Tools version may be null.
             /// </summary>
-            internal void Initialize(IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+            internal void Initialize(IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext, bool interactive)
             {
                 Xml.MarkAsExplicitlyLoaded();
 
@@ -3801,6 +3810,7 @@ internal void Initialize(IDictionary<string, string> globalProperties, string to
                 _data = new Data(Owner, globalPropertiesCollection, toolsVersion, subToolsetVersion, canEvaluateElementsWithFalseConditions);
 
                 _loadSettings = loadSettings;
+                _interactive = interactive;
 
                 ErrorUtilities.VerifyThrow(LastEvaluationId == BuildEventContext.InvalidEvaluationId, "This is the first evaluation therefore the last evaluation id is invalid");
 
diff --git a/src/Build/Definition/ProjectOptions.cs b/src/Build/Definition/ProjectOptions.cs
index 5c5e3cee3f9..c03507b3d3c 100644
--- a/src/Build/Definition/ProjectOptions.cs
+++ b/src/Build/Definition/ProjectOptions.cs
@@ -31,7 +31,7 @@ public class ProjectOptions
         public string SubToolsetVersion { get; set; }
 
         /// <summary>
-        /// The <see cref="ProjectCollection"/> the project is added to. Default is <see cref="ProjectCollection.GlobalProjectCollection"/>/>
+        /// The <see cref="ProjectCollection"/> the project is added to. Default is <see cref="ProjectCollection.GlobalProjectCollection"/>.
         /// </summary>
         public ProjectCollection ProjectCollection { get; set; }
 
@@ -49,5 +49,10 @@ public class ProjectOptions
         /// Provides <see cref="IDirectoryCache"/> to be used for evaluation.
         /// </summary>
         public IDirectoryCacheFactory DirectoryCacheFactory { get; set; }
+
+        /// <summary>
+        /// Gets or sets a value indicating if loading the project is allowed to interact with the user.
+        /// </summary>
+        public bool Interactive { get; set; }
     }
 }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index dd25193cec7..35097b0aeda 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -11,6 +11,7 @@
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Components.RequestBuilder;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -596,6 +597,7 @@ private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement t
         private void Evaluate()
         {
             string projectFile = String.IsNullOrEmpty(_projectRootElement.ProjectFileLocation.File) ? "(null)" : _projectRootElement.ProjectFileLocation.File;
+            using (AssemblyLoadsTracker.StartTracking(_evaluationLoggingContext, AssemblyLoadingContext.Evaluation))
             using (_evaluationProfiler.TrackPass(EvaluationPass.TotalEvaluation))
             {
                 ErrorUtilities.VerifyThrow(_data.EvaluationId == BuildEventContext.InvalidEvaluationId, "There is no prior evaluation ID. The evaluator data needs to be reset at this point");
@@ -1843,6 +1845,8 @@ static string EvaluateProperty(string value, IElementLocation location,
                 // Combine SDK path with the "project" relative path
                 try
                 {
+                    using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(_evaluationLoggingContext, AssemblyLoadingContext.SdkResolution, _sdkResolverService.GetType());
+
                     sdkResult = _sdkResolverService.ResolveSdk(_submissionId, sdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio,
                         failOnUnresolvedSdk: !_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) || _loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk));
                 }
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 49e921d8160..80552e8c950 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -9,6 +9,7 @@
 using System.Xml;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -140,45 +141,57 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
         /// </summary>
         private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)
         {
-            if (projectRootElement != null && _autoReloadFromDisk)
+            // When we do not _autoReloadFromDisk we expect that cached value is always valid.
+            // Usually lifespan of cache is expected to be build duration (process will terminate after build).
+            if (projectRootElement == null || !_autoReloadFromDisk)
             {
-                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
+                return false;
+            }
 
-                // If the file doesn't exist on disk, go ahead and use the cached version.
-                // It's an in-memory project that hasn't been saved yet.
-                if (fileInfo != null)
-                {
-                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
-                    {
-                        // File was changed on disk by external means. Cached version is no longer valid.
-                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file
-                        // externally and load a new project over it to see the new content. So we dump it from the cache
-                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
-                        // but clients ought not get themselves into such a state - and unless they save them to disk,
-                        // it may not be a problem.
-                        return true;
-                    }
-                    else if (s_ÑheckFileContent)
-                    {
-                        // QA tests run too fast for the timestamp check to work. This environment variable is for their
-                        // use: it checks the file content as well as the timestamp. That's better than completely disabling
-                        // the cache as we get test coverage of the rest of the cache code.
-                        XmlDocument document = new XmlDocument();
-                        document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
+            // If the project file is non modifiable, assume it is up to date and consider the cached value valid.
+            if (!Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck && FileClassifier.Shared.IsNonModifiable(projectFile))
+            {
+                return false;
+            }
 
-                        using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
-                        {
-                            document.Load(xtr.Reader);
-                        }
+            FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
 
-                        string diskContent = document.OuterXml;
-                        string cacheContent = projectRootElement.XmlDocument.OuterXml;
+            // If the file doesn't exist on disk, go ahead and use the cached version.
+            // It's an in-memory project that hasn't been saved yet.
+            if (fileInfo == null)
+            {
+                return false;
+            }
 
-                        if (diskContent != cacheContent)
-                        {
-                            return true;
-                        }
-                    }
+            if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
+            {
+                // File was changed on disk by external means. Cached version is no longer valid.
+                // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file
+                // externally and load a new project over it to see the new content. So we dump it from the cache
+                // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
+                // but clients ought not get themselves into such a state - and unless they save them to disk,
+                // it may not be a problem.
+                return true;
+            }
+            else if (s_ÑheckFileContent)
+            {
+                // QA tests run too fast for the timestamp check to work. This environment variable is for their
+                // use: it checks the file content as well as the timestamp. That's better than completely disabling
+                // the cache as we get test coverage of the rest of the cache code.
+                XmlDocument document = new XmlDocument();
+                document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
+
+                using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
+                {
+                    document.Load(xtr.Reader);
+                }
+
+                string diskContent = document.OuterXml;
+                string cacheContent = projectRootElement.XmlDocument.OuterXml;
+
+                if (diskContent != cacheContent)
+                {
+                    return true;
                 }
             }
 
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index fa1642fb36b..d4c48ac0ac7 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -119,7 +119,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
 
                 var projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
 
-                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)), globalPropertiesModifiers);
 
                 var requesterPlatform = "";
                 var requesterPlatformLookupTable = "";
@@ -324,6 +324,7 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
         private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
             ProjectItemInstance projectReference,
             PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
+            bool dynamicPlatformEnabled,
             IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers = null)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));
@@ -337,7 +338,7 @@ private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesFo
 
             var globalPropertyParts = globalPropertyModifiers?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;
 
-            if (globalPropertyParts.AllEmpty())
+            if (globalPropertyParts.AllEmpty() && !dynamicPlatformEnabled)
             {
                 return requesterGlobalProperties;
             }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 763a09442b3..9a301afd793 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -241,7 +241,7 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
         {
         }
 
@@ -260,8 +260,9 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
+        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -270,7 +271,10 @@ private ProjectInstance(string projectFile, IDictionary<string, string> globalPr
             // passed a relative path, the caller assumes we will prepend the current directory.
             projectFile = FileUtilities.NormalizePath(projectFile);
 
-            BuildParameters buildParameters = new BuildParameters(projectCollection);
+            BuildParameters buildParameters = new BuildParameters(projectCollection)
+            {
+                Interactive = interactive
+            };
 
             BuildEventContext buildEventContext = new BuildEventContext(buildParameters.NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, true /*Explicitly Loaded*/);
@@ -323,7 +327,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
         {
         }
 
@@ -395,11 +399,18 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
+        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
         {
             BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, new BuildParameters(projectCollection), projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
+
+            BuildParameters buildParameters = new BuildParameters(projectCollection)
+            {
+                Interactive = interactive
+            };
+
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
         }
 
         /// <summary>
@@ -743,7 +754,8 @@ public static ProjectInstance FromFile(string file, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.Interactive);
         }
 
         /// <summary>
@@ -760,7 +772,8 @@ public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElem
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.Interactive);
         }
 
         /// <summary>
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index e6c0d6a2ef7..15bb1ebc0cc 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -8,9 +8,10 @@
 using System.Threading.Tasks;
 #endif
 
+using Microsoft.Build.BackEnd.Components.RequestBuilder;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-
+using System.IO;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
 using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
@@ -210,6 +211,7 @@ public void CleanupTask(ITask task)
 
                 if (appDomain != null)
                 {
+                    AssemblyLoadsTracker.StopTracking(appDomain);
                     // Unload the AppDomain asynchronously to avoid a deadlock that can happen because
                     // AppDomain.Unload blocks for the process's one Finalizer thread to finalize all
                     // objects. Some objects are RCWs for STA COM objects and as such would need the
@@ -269,6 +271,10 @@ internal LoadedType InitializeFactory(
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 _taskName = taskName;
+
+                string assemblyName = loadInfo.AssemblyName ?? Path.GetFileName(loadInfo.AssemblyFile);
+                using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(targetLoggingContext, AssemblyLoadingContext.TaskRun, assemblyName);
+
                 _loadedType = _typeLoader.Load(taskName, loadInfo, _taskHostFactoryExplicitlyRequested);
                 ProjectErrorUtilities.VerifyThrowInvalidProject(_loadedType != null, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, String.Empty);
             }
@@ -384,6 +390,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
                     new TaskLoader.LogError(ErrorLoggingDelegate),
 #if FEATURE_APPDOMAIN
                     appDomainSetup,
+                    appDomain => AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun, _loadedType.Type, appDomain),
 #endif
                     isOutOfProc
 #if FEATURE_APPDOMAIN
@@ -393,10 +400,14 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
 
 #if FEATURE_APPDOMAIN
-                if (taskAppDomain != null)
+                if (taskAppDomain != null && taskInstance != null)
                 {
                     _tasksAndAppDomains[taskInstance] = taskAppDomain;
                 }
+                else if (taskAppDomain != null)
+                {
+                    AssemblyLoadsTracker.StopTracking(taskAppDomain);
+                }
 #endif
 
                 return taskInstance;
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 29dfb17f8f1..9fe1638fd3a 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -34,5 +34,6 @@ internal enum BinaryLogRecordKind
         String,
         TaskParameter,
         ResponseFileUsed,
+        AssemblyLoad,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index fe944b6e87f..29b259d2bef 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -57,7 +57,9 @@ public sealed class BinaryLogger : ILogger
         //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext
         // version 15:
         //   - new record kind: ResponseFileUsedEventArgs
-        internal const int FileFormatVersion = 15;
+        // version 16:
+        //   - AssemblyLoadBuildEventArgs
+        internal const int FileFormatVersion = 16;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index ee7f201ba25..ddb7520a7fd 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -188,6 +188,9 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.PropertyInitialValueSet:
                     result = ReadPropertyInitialValueSetEventArgs();
                     break;
+                case BinaryLogRecordKind.AssemblyLoad:
+                    result = ReadAssemblyLoadEventArgs();
+                    break;
                 default:
                     break;
             }
@@ -800,6 +803,29 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
             return e;
         }
 
+        private AssemblyLoadBuildEventArgs ReadAssemblyLoadEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields(readImportance: false);
+
+            AssemblyLoadingContext context = (AssemblyLoadingContext)ReadInt32();
+            string loadingInitiator = ReadDeduplicatedString();
+            string assemblyName = ReadDeduplicatedString();
+            string assemblyPath = ReadDeduplicatedString();
+            Guid mvid = ReadGuid();
+            string appDomainName = ReadDeduplicatedString();
+
+            var e = new AssemblyLoadBuildEventArgs(
+                context,
+                loadingInitiator,
+                assemblyName,
+                assemblyPath,
+                mvid,
+                appDomainName);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         /// <summary>
         /// For errors and warnings these 8 fields are written out explicitly
         /// (their presence is not marked as a bit in the flags). So we have to
@@ -1205,6 +1231,11 @@ private bool ReadBoolean()
             return binaryReader.ReadBoolean();
         }
 
+        private unsafe Guid ReadGuid()
+        {
+            return new Guid(binaryReader.ReadBytes(sizeof(Guid)));
+        }
+
         private DateTime ReadDateTime()
         {
             return new DateTime(binaryReader.ReadInt64(), (DateTimeKind)ReadInt32());
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 67a2005c284..cf69bcbacbc 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -438,6 +438,7 @@ private void Write(BuildMessageEventArgs e)
                 case EnvironmentVariableReadEventArgs environmentVariableRead: Write(environmentVariableRead); break;
                 case PropertyInitialValueSetEventArgs propertyInitialValueSet: Write(propertyInitialValueSet); break;
                 case CriticalBuildMessageEventArgs criticalBuildMessage: Write(criticalBuildMessage); break;
+                case AssemblyLoadBuildEventArgs assemblyLoad: Write(assemblyLoad); break;
                 default: // actual BuildMessageEventArgs
                     Write(BinaryLogRecordKind.Message);
                     WriteMessageFields(e, writeImportance: true);
@@ -469,6 +470,18 @@ private void Write(TargetSkippedEventArgs e)
             binaryWriter.WriteOptionalBuildEventContext(e.OriginalBuildEventContext);
         }
 
+        private void Write(AssemblyLoadBuildEventArgs e)
+        {
+            Write(BinaryLogRecordKind.AssemblyLoad);
+            WriteMessageFields(e, writeMessage: false, writeImportance: false);
+            Write((int)e.LoadingContext);
+            WriteDeduplicatedString(e.LoadingInitiator);
+            WriteDeduplicatedString(e.AssemblyName);
+            WriteDeduplicatedString(e.AssemblyPath);
+            Write(e.MVID);
+            WriteDeduplicatedString(e.AppDomainDescriptor);
+        }
+
         private void Write(CriticalBuildMessageEventArgs e)
         {
             Write(BinaryLogRecordKind.CriticalBuildMessage);
@@ -1088,6 +1101,15 @@ private void Write(bool boolean)
             binaryWriter.Write(boolean);
         }
 
+        private unsafe void Write(Guid guid)
+        {
+            byte* ptr = (byte*)&guid;
+            for (int i = 0; i < sizeof(Guid); i++, ptr++)
+            {
+                binaryWriter.Write(*ptr);
+            }
+        }
+
         private void WriteDeduplicatedString(string text)
         {
             var (recordId, _) = HashString(text);
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 2c22169321f..54ca8cba62e 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1124,6 +1124,11 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                 return;
             }
 
+            if (e.BuildEventContext == null && e is AssemblyLoadBuildEventArgs)
+            {
+                return;
+            }
+
             ErrorUtilities.VerifyThrowArgumentNull(e.BuildEventContext, "BuildEventContext");
             bool print = false;
             bool lightenText = false;
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index f2bd969073c..c2757e1ff4d 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -158,6 +158,7 @@
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
     <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
+    <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 7b1b4f411e1..52faacfee31 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1977,4 +1977,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="SDKResolverReturnedNull" xml:space="preserve">
     <value>SDK resolver "{0}" returned null.</value>
   </data>
-</root>
+  <data name="TaskAssemblyLoaded" xml:space="preserve">
+    <value>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</value>
+  </data>
+  <data name="NodeReused" xml:space="preserve">
+    <value>Reusing node {0} (PID: {1}).</value>
+  </data>
+</root>
\ No newline at end of file
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 0fd2a55f4a1..482f271ba03 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: V sestavenÃ­ {0} se nenaÅ¡ly Å¾Ã¡dnÃ© moduly plug-in mezipamÄti projektu. Modul plug-in se oÄekÃ¡val.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">PoÅ¾adovanÃ© sestavenÃ­ NuGet se nenaÅ¡lo. OÄekÃ¡vanÃ¡ cesta: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">Ãloha {0} poÅ¾adovala tento poÄet jader: {1}. ZÃ­skala tento poÄet jader: {2}. TeÄ pouÅ¾Ã­vÃ¡ celkem tento poÄet jader: {3}</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Ãloha {0} uvolnila tento poÄet jader: {1}. TeÄ pouÅ¾Ã­vÃ¡ celkem tento poÄet jader: {2}</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznÃ¡n.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznÃ¡n.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 49aab4ca53c..35576a9f7af 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: In der Assembly "{0}" wurde ein Projektcache-Plug-In erwartet, aber keines gefunden.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">Die Aufgabe "{0}" hat {1} Kerne angefordert und {2} Kerne erhalten und belegt jetzt insgesamt {3} Kerne.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Die Aufgabe "{0}" hat {1} Kerne freigegeben und belegt jetzt insgesamt {2} Kerne.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
+        <target state="translated">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 3e8d9e420ce..3b491802de3 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: No se encontrÃ³ ningÃºn complemento de cachÃ© de proyectos en el ensamblado "{0}". Se esperaba uno.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">No se encontrÃ³ un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">La tarea "{0}" solicitÃ³ {1}Â nÃºcleos, adquiriÃ³ {2}Â nÃºcleos y ahora retiene un total de {3}Â nÃºcleos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tarea "{0}" liberÃ³ {1}Â nÃºcleos y ahora retiene un total de {2}Â nÃºcleos.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
+        <target state="translated">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 369cad1fc61..fbbb2252b81 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: plug-ins de cache de projet introuvables dans l'assembly "{0}". Un plug-in est attendu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attenduÂ : {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">La tÃ¢che "{0}" a demandÃ© {1} cÅurs et a obtenu {2} cÅurs. Elle dÃ©tient dÃ©sormais {3} cÅurs au total.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tÃ¢che "{0}" a libÃ©rÃ© {1} cÅur. Elle dÃ©tient dÃ©sormais {2} cÅurs au total.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: L'Ã©lÃ©ment "{0}" situÃ© sous l'Ã©lÃ©ment &lt;{1}&gt; n'est pas reconnu.</target>
+        <target state="translated">MSB4067: L'Ã©lÃ©ment "{0}" situÃ© sous l'Ã©lÃ©ment &lt;{1}&gt; n'est pas reconnu.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 16c46738aa3..a3a5cb9eca1 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: non sono stati trovati plug-in della cache del progetto nell'assembly "{0}". Ne Ã¨ previsto uno.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obbligatorio non Ã¨ stato trovato. Percorso previsto: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">L'attivitÃ  "{0}" ha richiesto {1} core, ha acquisito {2} core e ora contiene {3} core in totale.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">L'attivitÃ  "{0}" ha rilasciato {1} core e ora contiene {2} core in totale.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
+        <target state="translated">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 2767d3b459d..e45710015a8 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: ãã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ã®ãã©ã°ã¤ã³ãã¢ã»ã³ããª "{0}" ã«è¦ã¤ããã¾ããã§ããããã©ã°ã¤ã³ã 1 ã¤å¿è¦ã§ãã</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">å¿è¦ãª NuGet ã¢ã»ã³ããªãè¦ã¤ããã¾ããã§ãããæ³å®ããããã¹: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">ã¿ã¹ã¯ "{0}" ã§ã¯ã{1} åã®ã³ã¢ãè¦æ±ãã{2} åã®ã³ã¢ãåå¾ãããããç¾å¨åè¨ {3} åã®ã³ã¢ãä¿æãã¦ãã¾ãã</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ã¿ã¹ã¯ "{0}" ã§ã¯ã{1} åã®ã³ã¢ãè§£æ¾ãããããç¾å¨åè¨ {2} åã®ã³ã¢ãä¿æãã¦ãã¾ãã</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: è¦ç´  &lt;{1}&gt; ã®ä¸ã®è¦ç´  &lt;{0}&gt; ã¯èªè­ããã¦ãã¾ããã</target>
+        <target state="translated">MSB4067: è¦ç´  &lt;{1}&gt; ã®ä¸ã®è¦ç´  &lt;{0}&gt; ã¯èªè­ããã¦ãã¾ããã</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index a8b9e95d0a2..78c2001194e 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: "{0}" ì´ìë¸ë¦¬ìì íë¡ì í¸ ìºì íë¬ê·¸ ì¸ì ì°¾ì ì ììµëë¤. 1ê°ê° íìí©ëë¤.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">íìí NuGet ì´ìë¸ë¦¬ë¥¼ ì°¾ì ì ììµëë¤. ìì ê²½ë¡: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">"{0}" ìììì ì½ì´ {1}ê°ë¥¼ ìì²­íê³  ì½ì´ {2}ê°ë¥¼ íëíì¼ë©° ì§ê¸ ì´ {3}ê°ì ì½ì´ë¥¼ ë³´ì íê³  ììµëë¤.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" ìììì ì½ì´ {1}ê°ë¥¼ í´ì íê³  ì§ê¸ ì´ {2}ê°ì ì½ì´ë¥¼ ë³´ì íê³  ììµëë¤.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; ìì ìëì &lt;{0}&gt; ììë¥¼ ì¸ìí  ì ììµëë¤.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; ìì ìëì &lt;{0}&gt; ììë¥¼ ì¸ìí  ì ììµëë¤.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index dd63fc75115..bcc1dad73ba 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: nie znaleziono wtyczek pamiÄci podrÄcznej projektu w zestawie â{0}â. Oczekiwano jednej.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ÅcieÅ¼ki {0}.</target>
@@ -416,6 +421,11 @@
         <target state="translated">Zadanie â{0}â Å¼ÄdaÅo {1} rdzeni, uzyskaÅo {2} i teraz jego ÅÄczna liczba rdzeni to {3}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Zadanie â{0}â zwolniÅo rdzenie ({1}) i teraz jego ÅÄczna liczba rdzeni to {2}.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; znajdujÄcy siÄ pod elementem &lt;{1}&gt; nie zostaÅ rozpoznany.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; znajdujÄcy siÄ pod elementem &lt;{1}&gt; nie zostaÅ rozpoznany.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 54b6e04475e..fcfbad3e5df 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: nÃ£o foi encontrado nenhum plug-in de cache do projeto no assembly "{0}". Era esperado um plug-in.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Um assembly NuGet necessÃ¡rio nÃ£o foi encontrado. Caminho Esperado: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">A tarefa "{0}" solicitou {1} nÃºcleos, adquiriu {2} nÃºcleos e agora contÃ©m {3} nÃºcleos no total.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">A tarefa "{0}" liberou {1} nÃºcleos e agora contÃ©m {2} nÃºcleos no total.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; nÃ£o Ã© reconhecido.</target>
+        <target state="translated">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; nÃ£o Ã© reconhecido.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 75cd9f7d0c3..3b33882791c 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÐµÐ¼ÑÐµ Ð¼Ð¾Ð´ÑÐ»Ð¸ ÐºÑÑÐ° Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð² Ð² ÑÐ±Ð¾ÑÐºÐµ "{0}". ÐÐ¾Ð»Ð¶ÐµÐ½ Ð±ÑÑÑ ÑÐºÐ°Ð·Ð°Ð½ Ð¾Ð´Ð¸Ð½ Ð¼Ð¾Ð´ÑÐ»Ñ.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð° Ð¾Ð±ÑÐ·Ð°ÑÐµÐ»ÑÐ½Ð°Ñ ÑÐ±Ð¾ÑÐºÐ° NuGet. ÐÐ¶Ð¸Ð´Ð°ÐµÐ¼ÑÐ¹ Ð¿ÑÑÑ: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">ÐÐ°Ð´Ð°ÑÐ° "{0}" Ð·Ð°Ð¿ÑÐ¾ÑÐ¸Ð»Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ ({1}) Ð¸ Ð¿Ð¾Ð»ÑÑÐ¸Ð»Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ ({2}). Ð¢ÐµÐ¿ÐµÑÑ Ð¾Ð±ÑÐµÐµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ, ÐºÐ¾ÑÐ¾ÑÑÐ¼Ð¸ ÑÐ°ÑÐ¿Ð¾Ð»Ð°Ð³Ð°ÐµÑ Ð·Ð°Ð´Ð°ÑÐ°, ÑÐ°Ð²Ð½Ð¾ {3}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ÐÐ°Ð´Ð°ÑÐ° "{0}" Ð¾ÑÐ²Ð¾Ð±Ð¾Ð´Ð¸Ð»Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ ({1}). Ð¢ÐµÐ¿ÐµÑÑ Ð¾Ð±ÑÐµÐµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ, ÐºÐ¾ÑÐ¾ÑÑÐ¼Ð¸ ÑÐ°ÑÐ¿Ð¾Ð»Ð°Ð³Ð°ÐµÑ Ð·Ð°Ð´Ð°ÑÐ°, ÑÐ°Ð²Ð½Ð¾ {2}.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Ð½ÐµÐ¾Ð¿Ð¾Ð·Ð½Ð°Ð½Ð½ÑÐ¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ &lt;{0}&gt; Ð² ÑÐ»ÐµÐ¼ÐµÐ½ÑÐµ &lt;{1}&gt;.</target>
+        <target state="translated">MSB4067: Ð½ÐµÐ¾Ð¿Ð¾Ð·Ð½Ð°Ð½Ð½ÑÐ¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ &lt;{0}&gt; Ð² ÑÐ»ÐµÐ¼ÐµÐ½ÑÐµ &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 83a86862dee..8822dee74ae 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: "{0}" bÃ¼tÃ¼nleÅtirilmiÅ kodunda proje Ã¶nbelleÄi eklentisi bulunamadÄ±. Bir eklenti bekleniyordu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Gereken NuGet derlemesi bulunamadÄ±. Beklenen Yol: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">"{0}" gÃ¶revi {1} Ã§ekirdek istedi, {2} Ã§ekirdek aldÄ± ve Åu anda toplam {3} Ã§ekirdek tutuyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" gÃ¶revi {1} Ã§ekirdeÄi serbest bÄ±raktÄ±. Åu anda toplam {2} Ã§ekirdek tutuyor.</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; Ã¶Äesinin altÄ±ndaki &lt;{0}&gt; Ã¶Äesi tanÄ±nmÄ±yor.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; Ã¶Äesinin altÄ±ndaki &lt;{0}&gt; Ã¶Äesi tanÄ±nmÄ±yor.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 9be6ea491ba..198d36450b9 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: å¨ç¨åºé "{0}" ä¸­æªæ¾å°é¡¹ç®ç¼å­æä»¶ãåºæä¸ä¸ªæä»¶ã</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">æªæ¾å°æéç NuGet ç¨åºéãæéè·¯å¾: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">ä»»å¡â{0}âè¯·æ±äº {1} ä¸ªæ ¸å¿ï¼å·²è·å {2} ä¸ªæ ¸å¿ï¼ç°æ»å±åå« {3} ä¸ªæ ¸å¿ã</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ä»»å¡â{0}âåå¸äº {1} ä¸ªæ ¸å¿ï¼ç°æ»å±åå« {2} ä¸ªæ ¸å¿ã</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: æ æ³è¯å«åç´  &lt;{1}&gt; ä¸é¢çåç´  &lt;{0}&gt;ã</target>
+        <target state="translated">MSB4067: æ æ³è¯å«åç´  &lt;{1}&gt; ä¸é¢çåç´  &lt;{0}&gt;ã</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 70f6dd3f097..201836b008e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -191,6 +191,11 @@
         <target state="translated">MSB4270: å¨çµä»¶ "{0}" ä¸­æ¾ä¸å°ä»»ä½å°æ¡å¿«åå¤æç¨å¼ï¼ä½æè©²è¦æä¸åå¤æç¨å¼ã</target>
         <note />
       </trans-unit>
+      <trans-unit id="NodeReused">
+        <source>Reusing node {0} (PID: {1}).</source>
+        <target state="new">Reusing node {0} (PID: {1}).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">æ¾ä¸å°å¿è¦ç NuGet åä»¶ãé æçè·¯å¾: {0}</target>
@@ -416,6 +421,11 @@
         <target state="translated">å·¥ä½ "{0}" å·²è¦æ± {1} åæ ¸å¿ãå·²åå¾ {2} åæ ¸å¿ï¼ç¾å¨å±ä¿ç {3} åæ ¸å¿ã</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoaded">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">å·¥ä½ "{0}" å·²ç¼è¡ {1} åæ ¸å¿ï¼ç¾å¨å±ä¿ç {2} åæ ¸å¿ã</target>
@@ -1841,7 +1851,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: ç¡æ³è¾¨èªé ç® &lt;{1}&gt; ä¸çé ç® &lt;{0}&gt;ã</target>
+        <target state="translated">MSB4067: ç¡æ³è¾¨èªé ç® &lt;{1}&gt; ä¸çé ç® &lt;{0}&gt;ã</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
new file mode 100644
index 00000000000..8e2bf7db11b
--- /dev/null
+++ b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
@@ -0,0 +1,42 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class AssemblyLoadBuildEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            string assemblyName = Guid.NewGuid().ToString();
+            string assemblyPath = Guid.NewGuid().ToString();
+            Guid mvid = Guid.NewGuid();
+            string loadingInitiator = Guid.NewGuid().ToString();
+            string appDomainName = Guid.NewGuid().ToString();
+            AssemblyLoadingContext context =
+                (AssemblyLoadingContext)(new Random().Next(Enum.GetNames(typeof(AssemblyLoadingContext)).Length));
+            AssemblyLoadBuildEventArgs arg = new(context, loadingInitiator, assemblyName, assemblyPath, mvid, appDomainName);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            arg.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            AssemblyLoadBuildEventArgs argDeserialized = new();
+            argDeserialized.CreateFromStream(br, 0);
+
+            argDeserialized.LoadingInitiator.ShouldBe(loadingInitiator);
+            argDeserialized.AssemblyName.ShouldBe(assemblyName);
+            argDeserialized.AssemblyPath.ShouldBe(assemblyPath);
+            argDeserialized.MVID.ShouldBe(mvid);
+            argDeserialized.AppDomainDescriptor.ShouldBe(appDomainName);
+            argDeserialized.LoadingContext.ShouldBe(context);
+        }
+    }
+}
diff --git a/src/Framework/AssemblyLoadBuildEventArgs.cs b/src/Framework/AssemblyLoadBuildEventArgs.cs
new file mode 100644
index 00000000000..bb9d8e58e6f
--- /dev/null
+++ b/src/Framework/AssemblyLoadBuildEventArgs.cs
@@ -0,0 +1,83 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable enable
+
+using System;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework
+{
+    public sealed class AssemblyLoadBuildEventArgs : BuildMessageEventArgs
+    {
+        private const string DefaultAppDomainDescriptor = "[Default]";
+
+        public AssemblyLoadBuildEventArgs()
+        { }
+
+        public AssemblyLoadBuildEventArgs(
+            AssemblyLoadingContext loadingContext,
+            string? loadingInitiator,
+            string? assemblyName,
+            string assemblyPath,
+            Guid mvid,
+            string? customAppDomainDescriptor,
+            MessageImportance importance = MessageImportance.Low)
+            : base(null, null, null, importance, DateTime.UtcNow, assemblyName, assemblyPath, mvid)
+        {
+            LoadingContext = loadingContext;
+            LoadingInitiator = loadingInitiator;
+            AssemblyName = assemblyName;
+            AssemblyPath = assemblyPath;
+            MVID = mvid;
+            AppDomainDescriptor = customAppDomainDescriptor;
+        }
+
+        public AssemblyLoadingContext LoadingContext { get; private set; }
+        public string? LoadingInitiator { get; private set; }
+        public string? AssemblyName { get; private set; }
+        public string? AssemblyPath { get; private set; }
+        public Guid MVID { get; private set; }
+        // Null string indicates that load occurred on Default AppDomain (for both Core and Framework).
+        public string? AppDomainDescriptor { get; private set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            writer.Write7BitEncodedInt((int)LoadingContext);
+            writer.WriteTimestamp(RawTimestamp);
+            writer.WriteOptionalBuildEventContext(BuildEventContext);
+            writer.WriteGuid(MVID);
+            writer.WriteOptionalString(LoadingInitiator);
+            writer.WriteOptionalString(AssemblyName);
+            writer.WriteOptionalString(AssemblyPath);
+            writer.WriteOptionalString(AppDomainDescriptor);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            LoadingContext = (AssemblyLoadingContext)reader.Read7BitEncodedInt();
+            RawTimestamp = reader.ReadTimestamp();
+            BuildEventContext = reader.ReadOptionalBuildEventContext();
+            MVID = reader.ReadGuid();
+            LoadingInitiator = reader.ReadOptionalString();
+            AssemblyName = reader.ReadOptionalString();
+            AssemblyPath = reader.ReadOptionalString();
+            AppDomainDescriptor = reader.ReadOptionalString();
+        }
+
+        public override string Message
+        {
+            get
+            {
+                if (RawMessage == null)
+                {
+                    string? loadingInitiator = LoadingInitiator == null ? null : $" ({LoadingInitiator})";
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TaskAssemblyLoaded", LoadingContext.ToString(), loadingInitiator, AssemblyName, AssemblyPath, MVID.ToString(), AppDomainDescriptor ?? DefaultAppDomainDescriptor);
+                }
+
+                return RawMessage;
+            }
+        }
+    }
+}
diff --git a/src/Framework/AssemblyLoadingContext.cs b/src/Framework/AssemblyLoadingContext.cs
new file mode 100644
index 00000000000..66dace0b8e6
--- /dev/null
+++ b/src/Framework/AssemblyLoadingContext.cs
@@ -0,0 +1,12 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework;
+
+public enum AssemblyLoadingContext
+{
+    TaskRun,
+    Evaluation,
+    SdkResolution,
+    LoggerInitialization,
+}
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
index 9c4f18ea8ef..7dc7dbdaf86 100644
--- a/src/Framework/ITaskItemExtensions.cs
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -57,8 +57,7 @@ public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this I
                     Debug.Fail(e.ToString());
                 }
 
-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);
-                i += 1;
+                list[i++] = new KeyValuePair<string, string>(metadataName, valueOrError);
             }
 
             return list;
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 8b7fce908e4..7a4db37105c 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -101,6 +101,11 @@ public Traits()
         /// </summary>
         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
+        /// <summary>
+        /// Log all environment variables whether or not they are used in a build in the binary log.
+        /// </summary>
+        public readonly bool LogAllAssemblyLoads = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLASSEMBLYLOADS"));
+
         /// <summary>
         /// Log all environment variables whether or not they are used in a build in the binary log.
         /// </summary>
diff --git a/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs b/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
index 818795fbe20..0a261bceaba 100644
--- a/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
+++ b/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using System.Windows.Markup;
 
 #nullable disable
@@ -41,16 +42,7 @@ public List<IProjectSchemaNode> Nodes
         [SuppressMessage("Microsoft.Usage", "CA2301:EmbeddableTypesInContainersRule", MessageId = "allTypes", Justification = "All object types come from within this assembly, so there will not be any type equivalence problems")]
         public IEnumerable<Type> GetSchemaObjectTypes()
         {
-            Dictionary<Type, bool> allTypes = new Dictionary<Type, bool>();
-            foreach (IProjectSchemaNode node in Nodes)
-            {
-                foreach (Type t in node.GetSchemaObjectTypes())
-                {
-                    allTypes[t] = true;
-                }
-            }
-
-            return allTypes.Keys;
+            return Nodes.SelectMany(node => node.GetSchemaObjectTypes()).Distinct();
         }
 
         /// <summary>
diff --git a/src/MSBuild/LiveLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
index 369be7d5bea..f787c2949b3 100644
--- a/src/MSBuild/LiveLogger/ANSIBuilder.cs
+++ b/src/MSBuild/LiveLogger/ANSIBuilder.cs
@@ -201,11 +201,6 @@ public static string DoubleUnderlined(string text)
                 return String.Format("\x1b[21m{0}\x1b[24m", text);
             }
 
-            public static string Blinking(string text)
-            {
-                return String.Format("\x1b[5m{0}\x1b[25m", text);
-            }
-
             public static string Inverse(string text)
             {
                 return String.Format("\x1b[7m{0}\x1b[27m", text);
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 278926df9ba..7068886ba69 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Threading.Tasks;
@@ -11,12 +12,12 @@ namespace Microsoft.Build.Logging.LiveLogger
 {
     internal class LiveLogger : ILogger
     {
-        private Dictionary<int, ProjectNode> projects = new Dictionary<int, ProjectNode>();
+        private ConcurrentDictionary<int, ProjectNode> projects = new();
 
         private bool succeeded;
         private int startedProjects = 0;
         private int finishedProjects = 0;
-        private Dictionary<string, int> blockedProjects = new();
+        private ConcurrentDictionary<string, int> blockedProjects = new();
 
         private Stopwatch? _stopwatch;
 
@@ -162,16 +163,17 @@ private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e
             int id = e.BuildEventContext!.ProjectInstanceId;
 
             // If id does not exist...
-            if (!projects.ContainsKey(id))
+            projects.GetOrAdd(id, (_) =>
             {
                 // Add project
                 ProjectNode node = new(e)
                 {
                     ShouldRerender = true,
                 };
-                projects[id] = node;
                 UpdateFooter();
-            }
+
+                return node;
+            });
         }
 
         private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
diff --git a/src/MSBuild/LiveLogger/ProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
index 7abb1a774f8..9561ead1647 100644
--- a/src/MSBuild/LiveLogger/ProjectNode.cs
+++ b/src/MSBuild/LiveLogger/ProjectNode.cs
@@ -59,7 +59,7 @@ public ProjectNode(ProjectStartedEventArgs args)
         public string ToANSIString()
         {
             ANSIBuilder.Formatting.ForegroundColor color = ANSIBuilder.Formatting.ForegroundColor.Default;
-            string icon = ANSIBuilder.Formatting.Blinking(ANSIBuilder.Graphics.Spinner()) + " ";
+            string icon = ANSIBuilder.Graphics.Spinner() + " ";
 
             if (Finished && WarningCount + ErrorCount == 0)
             {
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index e9991973cf6..3f2d3d8cee2 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -6173,5 +6173,11 @@ elementFormDefault="qualified">
       </xs:complexContent>
     </xs:complexType>
   </xs:element>
+  
+  <xs:element name="InvariantGlobalization" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:annotation>
+      <xs:documentation><!-- _locID_text="InvariantGlobalization" _locComment="" -->Indicates whether an app runs in globalization-invariant mode without access to culture-specific data and behavior.</xs:documentation>
+    </xs:annotation>
+  </xs:element>
 
 </xs:schema>
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 49475409d3f..2290f4aa7c9 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -292,6 +292,8 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     new TaskLoader.LogError(LogErrorDelegate),
 #if FEATURE_APPDOMAIN
                     appDomainSetup,
+                    // custom app domain assembly loading won't be available for task host
+                    null,
 #endif
                     true /* always out of proc */
 #if FEATURE_APPDOMAIN
@@ -299,7 +301,6 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
 #endif
                     );
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-
                 wrappedTask.BuildEngine = oopTaskHostNode;
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 31209200c7b..f1f7c3b7ffe 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -982,16 +982,16 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
 
             if (_updateEnvironment)
             {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                foreach (KeyValuePair<string, KeyValuePair<string, string>> variable in s_mismatchedEnvironmentValues)
                 {
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Key;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Value;
+                    string oldValue = variable.Value.Key;
+                    string newValue = variable.Value.Value;
 
                     // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
+                    environment.TryGetValue(variable.Key, out environmentValue);
 
                     if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
                     {
@@ -1009,14 +1009,14 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
                         {
                             if (_updateEnvironmentAndLog)
                             {
-                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable, newValue, environmentValue ?? String.Empty);
+                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable.Key, newValue, environmentValue ?? String.Empty);
                             }
 
-                            updatedEnvironment[variable] = newValue;
+                            updatedEnvironment[variable.Key] = newValue;
                         }
                         else
                         {
-                            updatedEnvironment.Remove(variable);
+                            updatedEnvironment.Remove(variable.Key);
                         }
                     }
                 }
@@ -1045,35 +1045,32 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
 
             if (_updateEnvironment)
             {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                foreach (KeyValuePair<string, KeyValuePair<string, string>> variable in s_mismatchedEnvironmentValues)
                 {
                     // Since this is munging the property list for returning to the parent process,
                     // then the value we wish to replace is the one that is in this process, and the
                     // replacement value is the one that originally came from the parent process,
                     // instead of the other way around.
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Value;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Key;
+                    string oldValue = variable.Value.Value;
+                    string newValue = variable.Value.Key;
 
                     // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
+                    environment.TryGetValue(variable.Key, out environmentValue);
 
                     if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (updatedEnvironment == null)
-                        {
-                            updatedEnvironment = new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
-                        }
+                        updatedEnvironment ??= new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
 
                         if (newValue != null)
                         {
-                            updatedEnvironment[variable] = newValue;
+                            updatedEnvironment[variable.Key] = newValue;
                         }
                         else
                         {
-                            updatedEnvironment.Remove(variable);
+                            updatedEnvironment.Remove(variable.Key);
                         }
                     }
                 }
@@ -1106,36 +1103,36 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
                 // after the node is launched.
                 s_mismatchedEnvironmentValues = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.OrdinalIgnoreCase);
 
-                foreach (string variable in _savedEnvironment.Keys)
+                foreach (KeyValuePair<string, string> variable in _savedEnvironment)
                 {
-                    string oldValue = _savedEnvironment[variable];
+                    string oldValue = variable.Value;
                     string newValue;
-                    if (!environment.TryGetValue(variable, out newValue))
+                    if (!environment.TryGetValue(variable.Key, out newValue))
                     {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(null, oldValue);
+                        s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(null, oldValue);
                     }
                     else
                     {
                         if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
                         {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                            s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, oldValue);
                         }
                     }
                 }
 
-                foreach (string variable in environment.Keys)
+                foreach (KeyValuePair<string, string> variable in environment)
                 {
-                    string newValue = environment[variable];
+                    string newValue = variable.Value;
                     string oldValue;
-                    if (!_savedEnvironment.TryGetValue(variable, out oldValue))
+                    if (!_savedEnvironment.TryGetValue(variable.Key, out oldValue))
                     {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, null);
+                        s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, null);
                     }
                     else
                     {
                         if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
                         {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                            s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, oldValue);
                         }
                     }
                 }
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 827a5cd91a3..5d1c158a617 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     ZpÅ¯sobÃ­, Å¾e MSBuild sestavÃ­ jednotlivÃ© projekty izolovanÄ.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Jde o omezenÄjÅ¡Ã­ reÅ¾im nÃ¡stroje MSBuild, protoÅ¾e vyÅ¾aduje,
-                     aby byl graf projektu staticky zjistitelnÃ½ v okamÅ¾iku
-                     vyhodnocenÃ­, mÅ¯Å¾e ale vylepÅ¡it plÃ¡novÃ¡nÃ­ a snÃ­Å¾it
-                     reÅ¾ii pamÄti pÅi sestavovÃ¡nÃ­ velkÃ© sady projektÅ¯.
-                     (KrÃ¡tkÃ½ tvar: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Tento pÅÃ­znak je experimentÃ¡lnÃ­ a nemusÃ­ fungovat tak, jak byl zamÃ½Å¡len.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -345,9 +354,9 @@
         <target state="translated">  @&lt;soubor&gt;            VloÅ¾enÃ­ nastavenÃ­ pÅÃ­kazovÃ©ho ÅÃ¡dku z textovÃ©ho souboru. Chcete-li zadat
                      vÃ­ce souborÅ¯ odpovÄdÃ­, uveÄte kaÅ¾dÃ½ soubor
                      odpovÄdÃ­ zvlÃ¡Å¡Å¥.
-
-                     Automaticky jsou pouÅ¾ity vÅ¡echny soubory s nÃ¡zvem msbuild.rsp
-                     nachÃ¡zejÃ­cÃ­ se v nÃ¡sledujÃ­cÃ­ch umÃ­stÄnÃ­ch:
+                     
+                     Automaticky jsou pouÅ¾ity vÅ¡echny soubory s nÃ¡zvem msbuild.rsp 
+                     nachÃ¡zejÃ­cÃ­ se v nÃ¡sledujÃ­cÃ­ch umÃ­stÄnÃ­ch: 
                      (1) adresÃ¡Å nÃ¡stroje msbuild.exe
                      (2) adresÃ¡Å prvnÃ­ho sestavenÃ©ho projektu nebo ÅeÅ¡enÃ­
 </target>
@@ -408,7 +417,7 @@
 </source>
         <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  NastavenÃ­ nebo potlaÄenÃ­ danÃ½ch vlastnostÃ­ na Ãºrovni
                      projektu. &lt;n&gt; je nÃ¡zev vlastnosti a &lt;v&gt; je jejÃ­ hodnota. VÃ­ce
-                     vlastnostÃ­ oddÄlte stÅednÃ­kem Äi ÄÃ¡rkou nebo zadejte
+                     vlastnostÃ­ oddÄlte stÅednÃ­kem Äi ÄÃ¡rkou nebo zadejte 
                      kaÅ¾dou vlastnost zvlÃ¡Å¡Å¥. (KrÃ¡tkÃ½ tvar: -p)
                      PÅÃ­klad:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -449,7 +458,7 @@
                      Syntaxe hodnoty &lt;sestavenÃ­_protok_nÃ¡st&gt;:
                         {&lt;nÃ¡zev_sestavenÃ­&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavenÃ­&gt;}
                      Parametry protokolovacÃ­ho nÃ¡stroje urÄujÃ­, jak MSBuild vytvoÅÃ­ protokolovacÃ­ nÃ¡stroj.
-                     Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se
+                     Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se 
                      protokolovacÃ­mu nÃ¡stroji pÅesnÄ v tom tvaru, v jakÃ©m
                      byly zadÃ¡ny. (KrÃ¡tkÃ½ tvar: -l)
                      PÅÃ­klady:
@@ -596,10 +605,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          OvÄÅit projekt podle vÃ½chozÃ­ho schÃ©matu.
+        <target state="translated">  -validate          OvÄÅit projekt podle vÃ½chozÃ­ho schÃ©matu. 
                      (KrÃ¡tkÃ½ tvar: -val)
 
-  -validate:&lt;schÃ©ma&gt; OvÄÅit projekt podle zadanÃ©ho schÃ©matu.
+  -validate:&lt;schÃ©ma&gt; OvÄÅit projekt podle zadanÃ©ho schÃ©matu. 
                      (KrÃ¡tkÃ½ tvar: -val)
                      PÅÃ­klad:
                        -validate:MyExtendedBuildSchema.xsd
@@ -659,11 +668,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Seznam stÅednÃ­kem oddÄlenÃ½ch vstupnÃ­ch souborÅ¯ mezipamÄti, ze kterÃ½ch
-                     MSBuild pÅeÄte vÃ½sledky sestavenÃ­.
-                     NastavenÃ­ tohoto atributu zÃ¡roveÅ zapne izolovanÃ© buildy (-isolate).
-                     (KrÃ¡tkÃ½ tvar: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -677,11 +685,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[souborMezipamÄti]...
-                     VÃ½stupnÃ­ soubor mezipamÄti, do nÄhoÅ¾ bude MSBuild
-                     zapisovat obsah svÃ½ch mezipamÄtÃ­ vÃ½sledkÅ¯ sestavenÃ­.
-                     NastavenÃ­m tÃ©to moÅ¾nosti zapnete takÃ© izolovanÃ© buildy (-isolate).
-                     (krÃ¡tkÃ½ tvar: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -713,11 +721,11 @@
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nÃ¡st&gt;*&lt;pÅedÃ¡v_protok_nÃ¡st&gt;
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nÃ¡st&gt;*&lt;pÅedÃ¡v_protok_nÃ¡st&gt;                     
                      PouÅ¾Ã­t zadanÃ½ protokolovacÃ­ nÃ¡stroj pro protokolovÃ¡nÃ­ udÃ¡lostÃ­
-                     z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅipojit jinou instanci
-                     protokolovacÃ­ho nÃ¡stroje. Chcete-li zadat vÃ­ce
-                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ.
+                     z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅipojit jinou instanci 
+                     protokolovacÃ­ho nÃ¡stroje. Chcete-li zadat vÃ­ce 
+                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ. 
                      (KrÃ¡tkÃ½ tvar: -dl)
                      Syntaxe hodnoty &lt;protok_nÃ¡st&gt;:
                         [&lt;tÅÃ­da_protok_nÃ¡st&gt;,]&lt;sestav_protok_nÃ¡st&gt;
@@ -781,7 +789,7 @@
         <target state="translated">  -toolsversion:&lt;verze&gt;
                      Verze sady nÃ¡strojÅ¯ MSBuild (Ãºloh, cÃ­lÅ¯ apod.), kterÃ¡ mÃ¡ bÃ½t
                      pouÅ¾ita pÅi sestavenÃ­. Tato verze mÃ¡ pÅednost pÅed verzemi
-                     uvedenÃ½mi v jednotlivÃ½ch projektech.
+                     uvedenÃ½mi v jednotlivÃ½ch projektech. 
                      (KrÃ¡tkÃ½ tvar: -tv)
                      PÅÃ­klad:
                        -toolsversion:3.5
@@ -899,25 +907,25 @@
                      popis pÅepÃ­naÄe -distributedFileLogger.
                      (KrÃ¡tkÃ½ tvar: -flp[n])
                      K dispozici jsou stejnÃ© parametry jako ty,
-                     kterÃ© jsou uvedeny u protokolovacÃ­ho nÃ¡stroje
+                     kterÃ© jsou uvedeny u protokolovacÃ­ho nÃ¡stroje 
                      konzoly. NÄkterÃ© dalÅ¡Ã­ dostupnÃ© parametry:
                        LogFile â cesta k souboru protokolu, do nÄjÅ¾ bude zapsÃ¡n
-                                  protokol sestavenÃ­
+                                  protokol sestavenÃ­ 
                        Append  â urÄuje, zda bude protokol sestavenÃ­ pÅipojen
-                                  k souboru protokolu, nebo jej pÅepÃ­Å¡e. PÅi nastavenÃ­
+                                  k souboru protokolu, nebo jej pÅepÃ­Å¡e. PÅi nastavenÃ­ 
                                   pÅepÃ­naÄe bude protokol sestavenÃ­ pÅipojen k souboru
-                                  protokolu. NenÃ­-li pÅepÃ­naÄ nastaven, bude obsah
-                                  existujÃ­cÃ­ho souboru protokolu pÅepsÃ¡n.
+                                  protokolu. NenÃ­-li pÅepÃ­naÄ nastaven, bude obsah 
+                                  existujÃ­cÃ­ho souboru protokolu pÅepsÃ¡n. 
                                   Podle vÃ½chozÃ­ho nastavenÃ­ je soubor protokolu pÅepsÃ¡n.
-                       Encoding â urÄuje kÃ³dovÃ¡nÃ­ souboru, napÅÃ­klad
+                       Encoding â urÄuje kÃ³dovÃ¡nÃ­ souboru, napÅÃ­klad 
                      UTF-8, Unicode nebo ASCII.
                        VÃ½chozÃ­ ÃºroveÅ podrobnostÃ­ je Detailed.
                      PÅÃ­klady:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                              Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1040,7 +1048,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Hodnota izolace projektÅ¯ nenÃ­ platnÃ¡. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Hodnota izolace projektÅ¯ nenÃ­ platnÃ¡. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a48f6fd867d..f814cb4f8b9 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -116,7 +116,7 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     Weist darauf hin, dass fÃ¼r Aktionen im Build eine
+                     Weist darauf hin, dass fÃ¼r Aktionen im Build eine 
                      Interaktion mit dem Benutzer zugelassen ist. Verwenden Sie dieses Argument
                      in einem automatisierten Szenario, in dem keine InteraktivitÃ¤t
                      erwartet wird.
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     FÃ¼hrt dazu, dass MSBuild jedes Projekt isoliert erstellt.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Dies ist ein restriktiverer Modus von MSBuild, da er erfordert, dass
-                     der Projektgraph zur Auswertungszeit statisch ermittelbar ist. Er kann jedoch
-                     die Planung verbessern und den Speichermehraufwand
-                     beim Erstellen einer groÃen Anzahl von Projekten verringern.
-                     (Kurzform: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Dieses Flag ist experimentell und funktioniert mÃ¶glicherweise nicht wie vorgesehen.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -346,8 +355,8 @@ Beispiel:
                      Antwortdateien anzugeben, geben Sie jede Antwortdatei
                      gesondert an.
 
-                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch
-                     in den folgenden Speicherorten verwendet:
+                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch 
+                     in den folgenden Speicherorten verwendet: 
                      (1) Verzeichnis von "msbuild.exe"
                      (2) Verzeichnis des ersten erstellten Projekts oder Projektmappe
 </target>
@@ -438,7 +447,7 @@ Beispiel:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben,
+        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
                        [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
@@ -447,7 +456,7 @@ Beispiel:
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -656,11 +665,10 @@ Beispiel:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Durch Semikolons getrennte Liste von Eingabecachedateien, aus denen MSBuild
-                     Buildergebnisse liest.
-                     Durch Festlegen dieser Option werden auch isolierte Builds aktiviert (-isolate).
-                     (Kurzform: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +682,11 @@ Beispiel:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[Cachedatei]
-                     Ausgabecachedateien, in die MSBuild am Ende des Buildvorgangs die Inhalte
-                     der zugehÃ¶rigen Caches mit Buildergebnissen schreibt.
-                     Durch Festlegung dieser Option werden auÃerdem isolierte Builds aktiviert (-isolate).
-                     (Kurzform: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -711,8 +719,8 @@ Beispiel:
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
         <target state="translated">  -distributedlogger:&lt;Zentrale Protokollierung&gt;*&lt;Weiterleitende Protokollierung&gt;
-                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere
-                     Protokollierungsinstanz angefÃ¼gt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung
+                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere 
+                     Protokollierungsinstanz angefÃ¼gt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung 
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
@@ -722,7 +730,7 @@ Beispiel:
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -747,8 +755,8 @@ Beispiel:
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreprojectextensions:&lt;Erweiterungen&gt;
-                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende
-                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma,
+                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende 
+                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma, 
                      um mehrere Erweiterungen voneinander zu trennen.
                      (Kurzform: -ignore)
                      Beispiel:
@@ -774,8 +782,8 @@ Beispiel:
    </source>
         <target state="translated">  -toolsversion:&lt;Version&gt;
                      Die Version des MSBuild-Toolsets (Aufgaben, Ziele usw.),
-                     die wÃ¤hrend des Erstellens zu verwenden ist. Diese Version Ã¼berschreibt die
-                     von einzelnen Projekten angegebenen Versionen. (Kurzform:
+                     die wÃ¤hrend des Erstellens zu verwenden ist. Diese Version Ã¼berschreibt die 
+                     von einzelnen Projekten angegebenen Versionen. (Kurzform: 
                      -tv)
                      Beispiel:
                        -toolsversion:3.5
@@ -834,14 +842,14 @@ Beispiel:
         <target state="translated">  -distributedFileLogger
                      Protokolliert die Erstellungsausgabe in mehrere Dateien, eine Protokolldatei
                      pro MSBuild-Knoten. Der anfÃ¤ngliche Speicherort fÃ¼r diese Dateien ist
-                     das aktuelle Verzeichnis. StandardmÃ¤Ãig werden die Dateien
+                     das aktuelle Verzeichnis. StandardmÃ¤Ãig werden die Dateien 
                      "MSBuild&lt;Knoten-ID&gt;.log" benannt. Der Speicherort der Datei und
-                     andere Parameter fÃ¼r fileLogger kÃ¶nnen durch das HinzufÃ¼gen
+                     andere Parameter fÃ¼r fileLogger kÃ¶nnen durch das HinzufÃ¼gen 
                      des Schalters "-fileLoggerParameters" angegeben werden.
 
                      Wenn mithilfe des fileLoggerParameters-Parameters ein Protokolldateiname festgelegt wurde,
-                     verwendet die verteilte Protokollierung den Dateinamen als
-                     Vorlage und fÃ¼gt die Knoten-ID an diesen Dateinamen an,
+                     verwendet die verteilte Protokollierung den Dateinamen als 
+                     Vorlage und fÃ¼gt die Knoten-ID an diesen Dateinamen an, 
                      um fÃ¼r jeden Knoten eine Protokolldatei zu erstellen.
     </target>
         <note>
@@ -885,31 +893,31 @@ Beispiel:
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;Parameter&gt;
                      Gibt zusÃ¤tzliche Parameter fÃ¼r Dateiprotokollierungen an.
-                     Dieser Schalter bedeutet, dass der entsprechende
+                     Dieser Schalter bedeutet, dass der entsprechende 
                      Schalter "-fileLogger[n]" ebenfalls vorhanden ist.
                      "n" (optional) kann eine Zahl von 1â9 sein.
-                     "-fileLoggerParameters" wird auch von verteilten
+                     "-fileLoggerParameters" wird auch von verteilten 
                      Dateiprotokollierungen verwendet (siehe Beschreibung zu "-distributedFileLogger").
                      (Kurzform: -flp[n])
                      Es sind dieselben Parameter wie fÃ¼r die Konsolenprotokollierung
                      verfÃ¼gbar. Einige zusÃ¤tzliche Parameter:
-                        LogFile: Pfad der Protokolldatei, in die das
+                        LogFile: Pfad der Protokolldatei, in die das 
                             Buildprotokoll geschrieben wird.
-                        Append: Gibt an, ob das Buildprotokoll erweitert oder
+                        Append: Gibt an, ob das Buildprotokoll erweitert oder 
                             oder Ã¼berschrieben wird. Mit diesem Schalter
                             wird das Buildprotokoll an die Protokolldatei angefÃ¼gt;
-                            Ohne diesen Schalter wird der Inhalt
-                            der vorhandenen Protokolldatei Ã¼berschrieben.
+                            Ohne diesen Schalter wird der Inhalt 
+                            der vorhandenen Protokolldatei Ã¼berschrieben. 
                             StandardmÃ¤Ãig wird die Protokolldatei nicht erweitert.
-                        Encoding: Gibt die Codierung der Datei an,
+                        Encoding: Gibt die Codierung der Datei an, 
                             z. B. UTF-8, Unicode oder ASCII.
                      Die Standardeinstellung fÃ¼r "verbosity" ist "Detailed".
                      Beispiele:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -935,7 +943,7 @@ Beispiel:
         <target state="translated">  -nodeReuse:&lt;Parameter&gt;
                      Aktiviert oder deaktiviert die Wiederverwendung von MSBuild-Knoten.
                      Die Parameter lauten:
-                     True: Knoten bleiben nach dem Abschluss der Erstellung
+                     True: Knoten bleiben nach dem Abschluss der Erstellung 
                      erhalten und werden bei folgenden Erstellungen wiederverwendet (Standardeinstellung).
                      False: Knoten bleiben nach dem Abschluss der Erstellung nicht erhalten.
                      (Kurzform: -nr)
@@ -1032,7 +1040,7 @@ Beispiel:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Der Wert fÃ¼r das Isolieren von Projekten ist nicht gÃ¼ltig. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Der Wert fÃ¼r das Isolieren von Projekten ist nicht gÃ¼ltig. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index bf8d89e1c84..40f88a5277e 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Hace que MSBuild compile cada proyecto en aislamiento.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Este es un modo de MSBuild mÃ¡s restrictivo ya que requiere
-                     que el grafo de proyecto se pueda detectar estÃ¡ticamente en el
-                     momento de evaluaciÃ³n, pero puede mejorar la programaciÃ³n y reducir
-                     la sobrecarga de memoria al compilar un gran conjunto de proyectos.
-                     (Forma corta: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Este indicador es experimental y puede que no funcione como se espera.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -660,11 +669,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;archivoCachÃ©&gt;...
-                     Lista de archivos de cachÃ© de entrada, separados por punto y coma, de la que MSBuild
-                     leerÃ¡ los resultados de la compilaciÃ³n.
-                     Si se establece esta opciÃ³n, se activan tambiÃ©n las compilaciones aisladas (-isolate).
-                     (Forma corta: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -678,13 +686,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[archivo-de-cachÃ©]
-                     Archivo de cachÃ© de salida donde MSBuild escribe
-                     el contenido de las memorias cachÃ© de resultados
-                     de compilaciÃ³n cuando esta acaba.
-                     Si se establece esta opciÃ³n, se activan tambiÃ©n las
-                     compilaciones aisladas (-isolate).
-                     (Forma corta: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -756,8 +762,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensiones&gt;
-                     Lista de extensiones que se omiten al determinar el
-                     archivo del proyecto que se va a compilar. Use el carÃ¡cter de
+                     Lista de extensiones que se omiten al determinar el 
+                     archivo del proyecto que se va a compilar. Use el carÃ¡cter de 
                      punto y coma o coma para separar varias extensiones.
                     (Forma corta: -ignore)
                      Ejemplo:
@@ -908,9 +914,9 @@
                             sobrescribirÃ¡ el archivo de registro. Si se establece el
                             modificador, se adjunta el registro de compilaciÃ³n al archivo de registro;
                             Si no se especifica el modificador, se sobrescribe
-                            el contenido del archivo de registro existente.
+                            el contenido del archivo de registro existente. 
                             El valor predeterminado es adjuntar el archivo de registro.
-                        Encoding: especifica la codificaciÃ³n del archivo,
+                        Encoding: especifica la codificaciÃ³n del archivo, 
                             por ejemplo, UTF-8, Unicode o ASCII
                      El nivel de detalle predeterminado es Detailed.
                      Ejemplos:
@@ -1041,7 +1047,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: El valor de los proyectos aislados no es vÃ¡lido. {0}.</target>
+        <target state="translated">MSBUILD : error MSB1056: El valor de los proyectos aislados no es vÃ¡lido. {0}.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 572e704317d..8e9dc930886 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Force MSBuild Ã  gÃ©nÃ©rer chaque projet de maniÃ¨re isolÃ©e.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Ce mode de MSBuild est plus restrictif car il nÃ©cessite
-                     que le graphe du projet soit statiquement dÃ©couvrable au
-                     moment de l'Ã©valuation, mais il peut amÃ©liorer la planification et rÃ©duire
-                     la surcharge de mÃ©moire lors de la gÃ©nÃ©ration d'un grand nombre de projets.
-                     (Forme abrÃ©gÃ©eÂ : -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Cet indicateur est expÃ©rimental et peut ne pas fonctionner comme prÃ©vu.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -656,11 +665,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;fichierCache&gt;...
-         Liste de fichiers cache d'entrÃ©e sÃ©parÃ©s par des points-virgules, Ã 
-         partir desquels MSBuild va lire les rÃ©sultats de la build.
-         Ce paramÃ¨tre active Ã©galement les builds isolÃ©es (-isolate).
-         (Forme abrÃ©gÃ©eÂ : -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +682,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     Fichier cache de sortie dans lequel MSBuild Ã©crit le contenu de
-                     ses caches de rÃ©sultats de la build Ã  la fin de la build.
-                     Ce paramÃ¨tre active Ã©galement les builds isolÃ©es (-isolate).
-                     (forme abrÃ©gÃ©eÂ : -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1032,7 +1040,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: La valeur dâisolation des projets n'est pas valide. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: La valeur dâisolation des projets n'est pas valide. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1761,7 +1769,7 @@ fois plus petit que le journal
         <target state="translated">  -profileEvaluation:&lt;fichier&gt;
          Profile l'Ã©valuation MSBuild et Ã©crit le rÃ©sultat
          dans le fichier spÃ©cifiÃ©. Si l'extension du fichier spÃ©cifiÃ©
-         est '.md', le rÃ©sultat est gÃ©nÃ©rÃ© au format Markdown.
+         est '.md', le rÃ©sultat est gÃ©nÃ©rÃ© au format Markdown. 
          Sinon, un fichier de valeurs sÃ©parÃ©es par des tabulations est gÃ©nÃ©rÃ©.
     </target>
         <note />
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index d97eee21a68..68cec8932f2 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -151,19 +151,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Fa in modo che MSBuild compili ogni progetto in modalitÃ 
-                     isolamento.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Si tratta di una modalitÃ  piÃ¹ restrittiva di
-                     MSBuild perchÃ© richiede che il grafico del progetto sia
-                     rilevabile staticamente in fase di valutazione, ma puÃ²
-                     migliorare la pianificazione e ridurre il sovraccarico
-                     della memoria quando si compila un set esteso di progetti.
-                     Forma breve: -isolate.
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Questo flag Ã¨ sperimentale e potrebbe non funzionare come
-                     previsto.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -357,7 +363,7 @@ Esempio:
                      separatamente.
 
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
-                     automaticamente dai percorsi seguenti:
+                     automaticamente dai percorsi seguenti: 
                      (1) la directory di msbuild.exe
                      (2) la directory della prima compilazione di soluzione o progetto
 </target>
@@ -666,11 +672,10 @@ Esempio:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;fileCache&gt;...
-                     Elenco di file di cache di input delimitati da punto e virgola da cui MSBuild
-                     leggerÃ  i risultati della compilazione.
-                     Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
-                     Forma breve: -irc
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -684,11 +689,11 @@ Esempio:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[fileCache]
-                     File di cache di output in cui MSBuild scriverÃ  il contenuto delle
-                     cache dei risultati della compilazione al termine della compilazione.
-                     Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
-                     Forma breve: -orc
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1046,7 +1051,7 @@ Esempio:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: il valore di isolateProjects non Ã¨ valido. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: il valore di isolateProjects non Ã¨ valido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index c590ae60203..fd403b69216 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuild ã¯ãåãã­ã¸ã§ã¯ããåé¢ãã¦ãã«ããã¾ãã
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     ããã¯ MSBuild ã®ããå¶éçãªã¢ã¼ãã§ãã
-                     è©ä¾¡æã«ãã­ã¸ã§ã¯ã ã°ã©ããéçã«æ¤åºã§ããªããã°ãªããªãããã§ãã
-                     ããããå¤§ããªãã­ã¸ã§ã¯ã ã»ããããã«ãããã¨ãã«ã
-                     ã¹ã±ã¸ã¥ã¼ã«è¨­å®ãåä¸ãããã¡ã¢ãª ãªã¼ãã¼ããããåæ¸ã§ãã¾ãã
-                     (ç­ãå½¢å¼: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     ãã®ãã©ã°ã¯å®é¨çã§ãæå³ã©ããã«æ©è½ããªãå¯è½æ§ãããã¾ãã
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -214,7 +223,7 @@
     </source>
         <target state="translated">  -targets[:file]
                      ä½¿ç¨å¯è½ãªã¿ã¼ã²ããã®ä¸è¦§ããå®éã®ãã«ãå¦çã
-                     å®è¡ããã«åºåãã¾ããæ¢å®ã§ã¯ãåºåã¯ã³ã³ã½ã¼ã«
+                     å®è¡ããã«åºåãã¾ããæ¢å®ã§ã¯ãåºåã¯ã³ã³ã½ã¼ã« 
                      ã¦ã£ã³ãã¦ã«æ¸ãè¾¼ã¾ãã¾ããåºåãã¡ã¤ã«ã¸ã®ãã¹ã
                      æå®ããå ´åã¯ãä»£ããã«ãã®ãã¡ã¤ã«ãä½¿ç¨ããã¾ãã
                      (ç­ãå½¢å¼:-ts)
@@ -656,11 +665,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuild ããã«ãçµæãèª­ã¿è¾¼ããå¥åã­ã£ãã·ã¥ ãã¡ã¤ã«ã®
-                     ã»ãã³ã­ã³ã§åºåããããªã¹ãã
-                     ãããè¨­å®ããã¨ãåé¢ããããã«ã (-isolate) ãæå¹ã«ãªãã¾ãã
-                     (ç­ç¸®å½¢: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +682,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuild ããã«ãã®æå¾ã«ãã«ãçµæã­ã£ãã·ã¥ã®
-                     åå®¹ãæ¸ãè¾¼ãåºåã­ã£ãã·ã¥ ãã¡ã¤ã«ã
-                     è¨­å®ããã¨ãåé¢ããããã«ããæå¹ã«ãªãã¾ã (-isolate)ã
-                     (ç­ãå½¢å¼: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1032,7 +1040,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Isolate projects å¤ãç¡å¹ã§ãã{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Isolate projects å¤ãç¡å¹ã§ãã{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1700,7 +1708,7 @@
                      (Short form: -r)
     </source>
         <target state="translated">  -restore[:True|False]
-                     ä»ã®ã¿ã¼ã²ããããã«ãããåã« Restore
+                     ä»ã®ã¿ã¼ã²ããããã«ãããåã« Restore 
                      ã¨ããååã®ã¿ã¼ã²ãããå®è¡ãããããã®ã¿ã¼ã²ããã®ãã«ãã
                      ææ°ã®å¾©åãã«ã ã­ã¸ãã¯ãä½¿ç¨ããããã«ãã¾ãã
                      ããã¯ãããã±ã¼ã¸ ããªã¼ã§ããã±ã¼ã¸ããã«ã
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index e136d34da21..7c1bc406e1e 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -116,12 +116,12 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     ë¹ëì ììì´ ì¬ì©ìì ìí¸ ìì©í  ì
-                     ììì ëíëëë¤. ìí¸ ìì©ì´ íìíì§
-                     ìì ìëíë ìëë¦¬ì¤ììë ì´ ì¸ìë¥¼
+                     ë¹ëì ììì´ ì¬ì©ìì ìí¸ ìì©í  ì 
+                     ììì ëíëëë¤. ìí¸ ìì©ì´ íìíì§ 
+                     ìì ìëíë ìëë¦¬ì¤ììë ì´ ì¸ìë¥¼ 
                      ì¬ì©íì§ ë§ì¸ì.
                      -interactiveë¥¼ ì§ì íë ê²ì -interactive:trueë¥¼
-                     ì§ì íë ê²ê³¼ ê°ìµëë¤. ë§¤ê° ë³ìë¥¼
+                     ì§ì íë ê²ê³¼ ê°ìµëë¤. ë§¤ê° ë³ìë¥¼ 
                      ì¬ì©íì¬ ì§ì íì¼ìì ê°ì ¸ì¤ë ê°ì ì¬ì ìí©ëë¤.
     </target>
         <note>
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuildê° ê²©ë¦¬ ëª¨ëìì ê° íë¡ì í¸ë¥¼ ë¹ëíëë¡ í©ëë¤.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     ì´ ëª¨ëë íë¡ì í¸ ê·¸ëíê° íê° ìê°ì ì ì ì¼ë¡
-                     ê²ì ê°ë¥í´ì¼ íë¯ë¡ ë ì íì ì¸ MSBuild ëª¨ëì´ë,
-                     ëê·ëª¨ íë¡ì í¸ë¥¼ ë¹ëí  ê²½ì° ìì½ì ê°ì íê³ 
-                     ë©ëª¨ë¦¬ ì¤ë²í¤ëë¥¼ ì¤ì¼ ì ììµëë¤.
-                     (ì½ì: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     ì´ íëê·¸ë ì¤íì ì´ë©° ììëë¡ ìëíì§ ìì ì ììµëë¤.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -182,9 +191,9 @@
         <target state="translated">  -graphBuild[:True|False]
                      MSBuildê° íë¡ì í¸ ê·¸ëíë¥¼ ìì± ë° ë¹ëíëë¡ í©ëë¤.
 
-                     ê·¸ëí ìì±ìë ì¢ìì±ì íì±íê¸° ìí íë¡ì í¸
-                     ì°¸ì¡° ìë³ì´ ê´ë ¨ë©ëë¤. í´ë¹ ê·¸ëí ë¹ëìë íë¡ì í¸
-                     ì°¸ì¡°ë¥¼ ì°¸ì¡°íë íë¡ì í¸ ì ì íë¡ì í¸ ì°¸ì¡°ë¥¼
+                     ê·¸ëí ìì±ìë ì¢ìì±ì íì±íê¸° ìí íë¡ì í¸ 
+                     ì°¸ì¡° ìë³ì´ ê´ë ¨ë©ëë¤. í´ë¹ ê·¸ëí ë¹ëìë íë¡ì í¸ 
+                     ì°¸ì¡°ë¥¼ ì°¸ì¡°íë íë¡ì í¸ ì ì íë¡ì í¸ ì°¸ì¡°ë¥¼ 
                      ë¹ëíë ìëê° ê´ë ¨ëë©°, ì´ë ê¸°ì¡´ MSBuild
                      ìì½ê³¼ ë¤ë¦ëë¤.
                      (ì½ì: -graph)
@@ -238,7 +247,7 @@
         <target state="translated">  -lowPriority[:True|False]
                      MSBuildê° ë®ì íë¡ì¸ì¤ ì°ì  ììë¡ ì¤íë©ëë¤.
 
-                     -lowPriorityë¥¼ ì§ì íë ê²ì
+                     -lowPriorityë¥¼ ì§ì íë ê²ì 
                      -lowPriority:Trueë¥¼ ì§ì íë ê²ê³¼ ê°ìµëë¤.
                      (ì½ì: -low)
     </target>
@@ -342,11 +351,11 @@
                      (1) the directory of msbuild.exe
                      (2) the directory of the first project or solution built
 </source>
-        <target state="translated">  @&lt;file&gt;            íì¤í¸ íì¼ìì ëªë ¹ì¤ ì¤ì ì ì½ìí©ëë¤.
-                     ì¬ë¬ ì§ì íì¼ì ì§ì íë ¤ë©´ ê° ì§ì íì¼ì ê°ë³ì ì¼ë¡
+        <target state="translated">  @&lt;file&gt;            íì¤í¸ íì¼ìì ëªë ¹ì¤ ì¤ì ì ì½ìí©ëë¤. 
+                     ì¬ë¬ ì§ì íì¼ì ì§ì íë ¤ë©´ ê° ì§ì íì¼ì ê°ë³ì ì¼ë¡ 
                      ì§ì í©ëë¤.
 
-                     "msbuild.rsp"ë¼ë ì§ì íì¼ì´ ë¤ì ìì¹ìì
+                     "msbuild.rsp"ë¼ë ì§ì íì¼ì´ ë¤ì ìì¹ìì 
                      ìëì¼ë¡ ì¬ì©ë©ëë¤.
                      (1) msbuild.exeì ëë í°ë¦¬
                      (2) ë¹ëë ì²« ë²ì§¸ íë¡ì í¸ ëë ìë£¨ìì ëë í°ë¦¬
@@ -383,8 +392,8 @@
                      Example:
                        -target:Resources;Compile
 </source>
-        <target state="translated">  -target:&lt;targets&gt;  ì´ íë¡ì í¸ìì ëìì ë¹ëí©ëë¤. ì¸ë¯¸ì½ë¡  ëë ì¼íë¥¼ ì¬ì©íì¬
-                     ì¬ë¬ ëìì êµ¬ë¶íê±°ë, ê° ëìì
+        <target state="translated">  -target:&lt;targets&gt;  ì´ íë¡ì í¸ìì ëìì ë¹ëí©ëë¤. ì¸ë¯¸ì½ë¡  ëë ì¼íë¥¼ ì¬ì©íì¬ 
+                     ì¬ë¬ ëìì êµ¬ë¶íê±°ë, ê° ëìì 
                      ê°ë³ì ì¼ë¡ ì§ì í©ëë¤. (ì½ì: -t)
                      ì:
                        -target:Resources;Compile
@@ -406,9 +415,9 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  íë¡ì í¸ ìì¤ ìì±ì ì¤ì íê±°ë ì¬ì ìí©ëë¤. &lt;n&gt;ì
-                     ìì± ì´ë¦ì´ê³  &lt;v&gt;ë ìì± ê°ìëë¤.
-                     ì¸ë¯¸ì½ë¡  ëë ì¼íë¥¼ ì¬ì©íì¬ ì¬ë¬ ìì±ì êµ¬ë¶íê±°ë,
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  íë¡ì í¸ ìì¤ ìì±ì ì¤ì íê±°ë ì¬ì ìí©ëë¤. &lt;n&gt;ì 
+                     ìì± ì´ë¦ì´ê³  &lt;v&gt;ë ìì± ê°ìëë¤. 
+                     ì¸ë¯¸ì½ë¡  ëë ì¼íë¥¼ ì¬ì©íì¬ ì¬ë¬ ìì±ì êµ¬ë¶íê±°ë, 
                      ê° ìì±ì ê°ë³ì ì¼ë¡ ì§ì í©ëë¤. (ì½ì: -p)
                      ì:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -593,10 +602,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          ê¸°ë³¸ ì¤í¤ë§ë¥¼ ê¸°ì¤ì¼ë¡ íë¡ì í¸ì ì í¨ì±ì ê²ì¬í©ëë¤.
+        <target state="translated">  -validate          ê¸°ë³¸ ì¤í¤ë§ë¥¼ ê¸°ì¤ì¼ë¡ íë¡ì í¸ì ì í¨ì±ì ê²ì¬í©ëë¤. 
                      (ì½ì: -val)
 
-  -validate:&lt;schema&gt; ì§ì ë ì¤í¤ë§ë¥¼ ê¸°ì¤ì¼ë¡ íë¡ì í¸ì ì í¨ì±ì ê²ì¬í©ëë¤.
+  -validate:&lt;schema&gt; ì§ì ë ì¤í¤ë§ë¥¼ ê¸°ì¤ì¼ë¡ íë¡ì í¸ì ì í¨ì±ì ê²ì¬í©ëë¤. 
                      (ì½ì: -val)
                      ì:
                        -validate:MyExtendedBuildSchema.xsd
@@ -656,11 +665,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuildê° ë¹ë ê²°ê³¼ë¥¼ ì½ë ìì¤ ìë ¥ ìºì íì¼ì
-                     ì¸ë¯¸ì½ë¡ ì¼ë¡ êµ¬ë¶ë ëª©ë¡ìëë¤.
-                     ì´ ì¤ìì¹ë¥¼ ì¤ì íë©´ ê²©ë¦¬ë ë¹ë(-isolate)ë ì¼ì§ëë¤.
-                     (ì½ì: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,10 +682,10 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuildìì ë¹ë ë§ì§ë§ì ë¹ë ê²°ê³¼ ìºìì
-                     ì½íì¸ ë¥¼ ì°ë ì¶ë ¥ ìºì íì¼ìëë¤.
-                     ì¤ì íë©´ ê²©ë¦¬ë ë¹ëììë ì¤ì ë©ëë¤(-isolate).
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </target>
         <note>
@@ -747,8 +755,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensions&gt;
-                     ë¹ëí  íë¡ì í¸ íì¼ì ê²°ì í  ë
-                     ë¬´ìí  íì¥ ëª©ë¡ìëë¤. ì¬ë¬ íì¥ì êµ¬ë¶íë ë°ë
+                     ë¹ëí  íë¡ì í¸ íì¼ì ê²°ì í  ë 
+                     ë¬´ìí  íì¥ ëª©ë¡ìëë¤. ì¬ë¬ íì¥ì êµ¬ë¶íë ë°ë 
                      ì¸ë¯¸ì½ë¡  ëë ì¼íë¥¼ ì¬ì©í©ëë¤.
                      (ì½ì: -ignore)
                      ì:
@@ -774,7 +782,7 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;version&gt;
                      ë¹ë ì¤ì ì¬ì©í  MSBuild ëêµ¬ ì¸í¸(ìì, ëì ë±)ì ë²ì ìëë¤.
-                     ì´ ë²ì ì ê°ë³ íë¡ì í¸ìì ì§ì í ë²ì ì
+                     ì´ ë²ì ì ê°ë³ íë¡ì í¸ìì ì§ì í ë²ì ì 
                      ì¬ì ìí©ëë¤. (ì½ì:
                      -tv)
                      ì:
@@ -803,9 +811,9 @@
                      íì¼ì íì¬ ëë í°ë¦¬ì ìê³ 
                      "msbuild[n].log"ë¡ ì´ë¦ì´ ì§ì ëì´ ììµëë¤. ëª¨ë  ë¸ëì ì´ë²¤í¸ë ë¨ì¼ ë¡ê·¸ë¡
                      ê²°í©ë©ëë¤. íì¼ì ìì¹ ë° fileLoggerì
-                     ë¤ë¥¸ ë§¤ê° ë³ìë "-fileLoggerParameters[n]" ì¤ìì¹ë¥¼
+                     ë¤ë¥¸ ë§¤ê° ë³ìë "-fileLoggerParameters[n]" ì¤ìì¹ë¥¼ 
                      ì¶ê°íì¬ ì§ì í  ì ììµëë¤.
-                     "n"ì 1-9 ì¬ì´ì ì«ìì¼ ì ìì¼ë©° ìµë 10ê°ì
+                     "n"ì 1-9 ì¬ì´ì ì«ìì¼ ì ìì¼ë©° ìµë 10ê°ì 
                      íì¼ ë¡ê±°ê° ì¶ê°ë  ì ììµëë¤. (ì½ì: -fl[n])
     </target>
         <note>
@@ -832,16 +840,16 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     MSBuild ë¸ëë¹ ë¡ê·¸ íì¼ íëì©, ì¬ë¬ ë¡ê·¸ íì¼ì ë¹ë ì¶ë ¥ì
-                     ê¸°ë¡í©ëë¤. í´ë¹ íì¼ì ì´ê¸° ìì¹ë
-                     íì¬ ëë í°ë¦¬ìëë¤. ê¸°ë³¸ì ì¼ë¡ í´ë¹ íì¼ì
-                     "MSBuild&lt;nodeid&gt;.log"ë¼ê³  í©ëë¤. íì¼ ìì¹ ë° fileLoggerì ê¸°í ë§¤ê° ë³ìë
-                     "-fileLoggerParameters" ì¤ìì¹ë¥¼ ì¶ê°í´ì
+                     MSBuild ë¸ëë¹ ë¡ê·¸ íì¼ íëì©, ì¬ë¬ ë¡ê·¸ íì¼ì ë¹ë ì¶ë ¥ì 
+                     ê¸°ë¡í©ëë¤. í´ë¹ íì¼ì ì´ê¸° ìì¹ë 
+                     íì¬ ëë í°ë¦¬ìëë¤. ê¸°ë³¸ì ì¼ë¡ í´ë¹ íì¼ì 
+                     "MSBuild&lt;nodeid&gt;.log"ë¼ê³  í©ëë¤. íì¼ ìì¹ ë° fileLoggerì ê¸°í ë§¤ê° ë³ìë 
+                     "-fileLoggerParameters" ì¤ìì¹ë¥¼ ì¶ê°í´ì 
                      ì§ì í  ì ììµëë¤.
 
-                     ë¡ê·¸ íì¼ ì´ë¦ì´ fileLoggerParameters ì¤ìì¹ë¥¼ íµí´ ì¤ì ëë©´
-                     ë°°í¬ë ë¡ê±°ê° fileNameì ííë¦¿ì¼ë¡ ì¬ì©íê³ 
-                     ë¸ë IDë¥¼ ì´ fileNameì ì¶ê°íì¬
+                     ë¡ê·¸ íì¼ ì´ë¦ì´ fileLoggerParameters ì¤ìì¹ë¥¼ íµí´ ì¤ì ëë©´ 
+                     ë°°í¬ë ë¡ê±°ê° fileNameì ííë¦¿ì¼ë¡ ì¬ì©íê³  
+                     ë¸ë IDë¥¼ ì´ fileNameì ì¶ê°íì¬ 
                      ê° ë¸ëì ë¡ê·¸ íì¼ì ë§ë­ëë¤.
     </target>
         <note>
@@ -885,20 +893,20 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parameters&gt;
                      íì¼ ë¡ê±°ì ì¶ê° ë§¤ê° ë³ìë¥¼ ì ê³µí©ëë¤.
-                     ì´ ì¤ìì¹ê° ìë¤ë ê²ì
+                     ì´ ì¤ìì¹ê° ìë¤ë ê²ì 
                      í´ë¹ fileLogger[n] ì¤ìì¹ë¥¼ ìë¯¸í©ëë¤.
                      "n"(ìë ê²½ì°)ì 1~9ì ì«ìì¼ ì ììµëë¤.
-                     -fileLoggerParametersë ë°°í¬ë íì¼ ë¡ê±°ììë
+                     -fileLoggerParametersë ë°°í¬ë íì¼ ë¡ê±°ììë 
                      ì¬ì©ë©ëë¤. -distributedFileLoggerì ëí ì¤ëªì ì°¸ì¡°íì¸ì.
                      (ì½ì: -flp[n])
                      ì½ì ë¡ê±°ì©ì¼ë¡ ëì´ë ëì¼í ë§¤ê° ë³ìë¥¼ ì¬ì©í  ì ììµëë¤.
                      ë¤ìê³¼ ê°ì ëª ê°ì§ ì¶ê° ë§¤ê° ë³ìë¥¼ ì¬ì©í  ì ììµëë¤.
-                        LogFile--ë¹ë ë¡ê·¸ê° ê¸°ë¡ëë
+                        LogFile--ë¹ë ë¡ê·¸ê° ê¸°ë¡ëë 
                             ë¡ê·¸ íì¼ì ê²½ë¡ìëë¤.
-                        Append--ë¹ë ë¡ê·¸ê° ë¡ê·¸ íì¼ì ì¶ê°ëëì§,
-                            ìëë©´ ë¡ê·¸ íì¼ì ë®ì´ì°ëì§ ì¬ë¶ë¥¼ ê²°ì í©ëë¤.
+                        Append--ë¹ë ë¡ê·¸ê° ë¡ê·¸ íì¼ì ì¶ê°ëëì§, 
+                            ìëë©´ ë¡ê·¸ íì¼ì ë®ì´ì°ëì§ ì¬ë¶ë¥¼ ê²°ì í©ëë¤. 
                             ì¤ìì¹ë¥¼ ì¤ì íë©´ ë¹ë ë¡ê·¸ê° ë¡ê·¸ íì¼ì ì¶ê°ë©ëë¤.
-                            ì¤ìì¹ë¥¼ ì¤ì íì§ ìì¼ë©´ ê¸°ì¡´ ë¡ê·¸ íì¼ì
+                            ì¤ìì¹ë¥¼ ì¤ì íì§ ìì¼ë©´ ê¸°ì¡´ ë¡ê·¸ íì¼ì 
                             ì½íì¸ ë¥¼ ë®ì´ìëë¤.
                             ê¸°ë³¸ê°ì ë¡ê·¸ íì¼ì ì¶ê°íì§ ìë ê²ìëë¤.
                         Encoding--íì¼ì ì¸ì½ë©ì ì§ì í©ëë¤
@@ -935,7 +943,7 @@
         <target state="translated">  -nodeReuse:&lt;parameters&gt;
                      MSBuild ë¸ëë¥¼ ë¤ì ì¬ì©íê±°ë ë¤ì ì¬ì©íì§ ìëë¡ ì¤ì í©ëë¤.
                      ë§¤ê° ë³ìë ë¤ìê° ê°ìµëë¤.
-                     True --ë¹ë ìë£ í ë¸ëê° ì ì§ëê³ 
+                     True --ë¹ë ìë£ í ë¸ëê° ì ì§ëê³  
                             íì ë¹ëìì ë¤ì ì¬ì©ë©ëë¤(ê¸°ë³¸ê°).
                      False--ë¹ë ìë£ í ë¸ëê° ì ì§ëì§ ììµëë¤.
                      (ì½ì: -nr)
@@ -1032,7 +1040,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: íë¡ì í¸ ê²©ë¦¬ ê°ì´ ì í¨íì§ ììµëë¤. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: íë¡ì í¸ ê²©ë¦¬ ê°ì´ ì í¨íì§ ììµëë¤. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1701,10 +1709,10 @@
     </source>
         <target state="translated">  -restore[:True|False]
                      ë¤ë¥¸ ëìì ë¹ëíê¸° ì ì Restoreë¼ë ëìì
-                     ì¤ííê³  ì´ë¬í ëìì ë¹ëì ìµì  ë³µìë
-                     ë¹ë ë¼ë¦¬ê° ì¬ì©ëëì§ íì¸í©ëë¤.
-                     íë¡ì í¸ í¸ë¦¬ë¥¼ ë¹ëíê¸° ì ì
-                     íë¡ì í¸ í¸ë¦¬ìì í¨í¤ì§ë¥¼ ë³µìí´ì¼ íë
+                     ì¤ííê³  ì´ë¬í ëìì ë¹ëì ìµì  ë³µìë 
+                     ë¹ë ë¼ë¦¬ê° ì¬ì©ëëì§ íì¸í©ëë¤. 
+                     íë¡ì í¸ í¸ë¦¬ë¥¼ ë¹ëíê¸° ì ì 
+                     íë¡ì í¸ í¸ë¦¬ìì í¨í¤ì§ë¥¼ ë³µìí´ì¼ íë 
                      ê²½ì°ì ì ì©í©ëë¤. -restoreë¥¼ ì§ì íë ê²ì
                      -restore:Trueë¥¼ ì§ì íë ê²ê³¼ ëì¼í©ëë¤. ì´ ë§¤ê° ë³ìë¥¼ ì¬ì©íì¬
                      ì§ì íì¼ìì ê°ì ¸ì¤ë ê°ì ì¬ì ìí  ì ììµëë¤.
@@ -1742,7 +1750,7 @@
     </source>
         <target state="translated">  -profileEvaluation:&lt;file&gt;
                      MSBuild íê°ë¥¼ íë¡íì¼ë§íê³  ê²°ê³¼ë¥¼ ì§ì ë íì¼ì ê¸°ë¡í©ëë¤.
-                     ì§ì ë íì¼ì íì¥ëªì´ '.md'ì´ë©´
+                     ì§ì ë íì¼ì íì¥ëªì´ '.md'ì´ë©´ 
                      ê²°ê³¼ê° Markdown íìì¼ë¡ ìì±ë©ëë¤.
                      ê·¸ë ì§ ìì¼ë©´ í­ì¼ë¡ êµ¬ë¶ë íì¼ì´ ìì±ë©ëë¤.
     </target>
@@ -1761,9 +1769,9 @@
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     ë³µìíë ëì íë¡ì í¸ ìì¤ ìì±ë§ ì¤ì íê±°ë
-                     ì¬ì ìíê³ , -property ì¸ìë¡ ì§ì ë ìì±ì
-                     ì¬ì©íì§ ììµëë¤. &lt;n&gt;ì ìì± ì´ë¦ì´ê³ 
+                     ë³µìíë ëì íë¡ì í¸ ìì¤ ìì±ë§ ì¤ì íê±°ë 
+                     ì¬ì ìíê³ , -property ì¸ìë¡ ì§ì ë ìì±ì 
+                     ì¬ì©íì§ ììµëë¤. &lt;n&gt;ì ìì± ì´ë¦ì´ê³  
                      &lt;v&gt;ë ìì± ê°ìëë¤.
                      ì¸ë¯¸ì½ë¡  ëë ì¼íë¥¼ ì¬ì©íì¬ ì¬ë¬ ìì±ì êµ¬ë¶íê±°ë,
                      ê° ìì±ì ê°ë³ì ì¼ë¡ ì§ì í©ëë¤.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index acd8432703f..e623fd51e42 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -122,7 +122,7 @@
                      interakcyjnoÅÄ nie jest oczekiwana.
                      Podanie parametru -interactive jest rÃ³wnoznaczne
                      z podaniem parametru -interactive:true. UÅ¼yj tego
-                     parametru, aby przesÅoniÄ wartoÅÄ pochodzÄcÄ z pliku
+                     parametru, aby przesÅoniÄ wartoÅÄ pochodzÄcÄ z pliku 
                      odpowiedzi.
     </target>
         <note>
@@ -151,19 +151,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Powoduje, Å¼e program MSBuild kompiluje kaÅ¼dy projekt
-                     w sposÃ³b izolowany.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Jest to bardziej restrykcyjny tryb programu MSBuild, poniewaÅ¼
-                     wymaga, aby graf projektu byÅ statycznie wykrywalny podczas
-                     oceny, ale moÅ¼e usprawniÄ planowanie i zmniejszyÄ
-                     obciÄÅ¼enie pamiÄci podczas kompilowania duÅ¼ego zestawu
-                     projektÃ³w.
-                     (KrÃ³tka wersja: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Ta flaga jest eksperymentalna i moÅ¼e nie dziaÅaÄ w oczekiwany
-                     sposÃ³b.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -184,7 +190,7 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -graphBuild[:True|False]
-                     Powoduje, Å¼e program MSBuild tworzy i kompiluje graf
+                     Powoduje, Å¼e program MSBuild tworzy i kompiluje graf                 
                      projektu.
 
                      Tworzenie grafu obejmuje identyfikowanie odwoÅaÅ do
@@ -284,7 +290,7 @@
     </source>
         <target state="translated">
  -warnNotAsError[:code[;code2]]
- Lista kodÃ³w ostrzeÅ¼eÅ, ktÃ³re majÄ byÄ traktowane jako bÅÄdy.
+ Lista kodÃ³w ostrzeÅ¼eÅ, ktÃ³re majÄ byÄ traktowane jako bÅÄdy. 
  Rozdziel Årednik lub przecinek
  wiele kodÃ³w ostrzeÅ¼eÅ. Nie ma Å¼adnego efektu, jeÅli przeÅÄcznik -warnaserror
                      switch is not set.
@@ -354,7 +360,7 @@
                      osobno.
 
                      Wszelkie pliki odpowiedzi o nazwie âmsbuild.rspâ bÄdÄ automatycznie
-                     wykorzystywane z nastÄpujÄcych lokalizacji:
+                     wykorzystywane z nastÄpujÄcych lokalizacji: 
                      (1) katalog programu msbuild.exe
                      (2) katalog pierwszej kompilacji projektu lub rozwiÄzania
 </target>
@@ -666,11 +672,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;plik pamiÄci podrÄcznej&gt;...
-                     Rozdzielana Årednikami lista wejÅciowych plikÃ³w pamiÄci podrÄcznej, z ktÃ³rych program MSBuild
-                     bÄdzie odczytywaÄ wyniki kompilacji.
-                     Ustawienie tej opcji wÅÄcza teÅ¼ kompilacje izolowane (-isolate).
-                     (KrÃ³tka wersja: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -684,11 +689,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[plik pamiÄci podrÄcznej]
-                     Plik pamiÄci podrÄcznej, w ktÃ³rym program MSBuild zapisze zawartoÅÄ
-                     swoich pamiÄci podrÄcznych wynikÃ³w kompilacji po zakoÅczeniu kompilacji.
-                     Ustawienie tej opcji wÅÄcza teÅ¼ kompilacje izolowane (-isolate).
-                     (KrÃ³tka wersja: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -906,7 +911,7 @@
                      DostÄpne sÄ parametry takie same, jak podane dla rejestratora
                      konsoli. DostÄpne sÄ rÃ³wnieÅ¼ dodatkowe parametry:
                        LogFile â ÅcieÅ¼ka do pliku dziennika, w ktÃ³rym bÄdzie
-                                 zapisywany dziennik kompilacji.
+                                 zapisywany dziennik kompilacji. 
                        Append â okreÅla, czy plik dziennika kompilacji zostanie
                                 doÅÄczony do pliku dziennika, czy go zastÄpi.
                                 Ustawienie tego przeÅÄcznika powoduje doÅÄczenie dziennika kompilacji
@@ -920,8 +925,8 @@
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1044,7 +1049,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: WartoÅÄ projektÃ³w izolacji jest nieprawidÅowa. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: WartoÅÄ projektÃ³w izolacji jest nieprawidÅowa. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1713,10 +1718,10 @@ dziennikÃ³w                     tekstowych i wykorzystaÄ w innych narzÄdziach
     </source>
         <target state="translated">  -restore[:True|False]
                      Uruchamia element docelowy o nazwie Restore przed skompilowaniem
-                     innych elementÃ³w docelowych i zapewnia, Å¼e kompilacja tych
-                     elementÃ³w docelowych korzysta z najnowszej logiki przywrÃ³conej
-                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga
-                     przywrÃ³cenia pakietÃ³w przed ich skompilowaniem. Podanie parametru
+                     innych elementÃ³w docelowych i zapewnia, Å¼e kompilacja tych 
+                     elementÃ³w docelowych korzysta z najnowszej logiki przywrÃ³conej 
+                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga 
+                     przywrÃ³cenia pakietÃ³w przed ich skompilowaniem. Podanie parametru 
                      -restore jest rÃ³wnoznaczne z podaniem parametru -restore:True.
                      Za pomocÄ tego parametru moÅ¼na przesÅoniÄ wartoÅÄ pochodzÄcÄ
                      z pliku odpowiedzi.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 8ef4d8c30d2..d952f5673fe 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -151,16 +151,25 @@ arquivo de resposta.
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Faz o MSBuild compilar cada projeto
-isoladamente.
-                     Esse Ã© um modo mais restritivo do MSBuild, pois requer
-                     que o grÃ¡fico do projeto seja estatisticamente detectÃ¡vel no
-                     tempo de avaliaÃ§Ã£o, mas pode melhorar o agendamento e reduzir
-                     a sobrecarga de memÃ³ria ao compilar um grande conjunto de projetos.
-                     (Forma abreviada: -isolate)
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Esse sinalizador Ã© experimental e pode nÃ£o funcionar como pretendido.
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -618,10 +627,10 @@ isoladamente.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n] Especifica o nÃºmero mÃ¡ximo de processos simultÃ¢neos a serem
+        <target state="translated">  -maxCpuCount[:n] Especifica o nÃºmero mÃ¡ximo de processos simultÃ¢neos a serem 
                      compilados. Se a opÃ§Ã£o nÃ£o for usada, o valor padrÃ£o
                      usado serÃ¡ 1. Se a opÃ§Ã£o for usada sem um valor, o
-                     MSBuild usarÃ¡ o nÃºmero de processadores do
+                     MSBuild usarÃ¡ o nÃºmero de processadores do 
                      computador. (Forma abreviada: -m[:n])
       </target>
         <note>
@@ -639,7 +648,7 @@ isoladamente.
         <target state="translated">Exemplos:
 
         MSBuild MyApp.sln -t:Rebuild -p:Configuration=Release
-        MSBuild MyApp.csproj -t:Clean
+        MSBuild MyApp.csproj -t:Clean 
                              -p:Configuration=Debug;TargetFrameworkVersion=v3.5
     </target>
         <note>
@@ -657,11 +666,10 @@ isoladamente.
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Lista separada por ponto e vÃ­rgula de arquivos de cache de entrada dos quais o MSBuild
-                     lerÃ¡ os resultados do build.
-                     A definiÃ§Ã£o dessa opÃ§Ã£o tambÃ©m habilita os builds isolados (-isolate).
-                     (forma abreviada: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -675,11 +683,11 @@ isoladamente.
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     Arquivo de cache de saÃ­da no qual o MSBuild gravarÃ¡ o conteÃºdo
-                     dos caches de resultado do build no final do build.
-                     A configuraÃ§Ã£o dessa opÃ§Ã£o tambÃ©m habilita builds isolado (-isolate).
-                     (forma abreviada: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -801,12 +809,12 @@ isoladamente.
                      10 file loggers to be attached. (Short form: -fl[n])
     </source>
         <target state="translated">  -fileLogger[n] Registra a saÃ­da do build em um arquivo. Por padrÃ£o,
-                     o arquivo estÃ¡ no diretÃ³rio atual e tem o nome
+                     o arquivo estÃ¡ no diretÃ³rio atual e tem o nome 
                      "msbuild[n].log". Os eventos de todos os nÃ³s sÃ£o combinados em
                      um Ãºnico log. A localizaÃ§Ã£o do arquivo e outros
-                     parÃ¢metros do fileLogger pode ser especificada por meio
+                     parÃ¢metros do fileLogger pode ser especificada por meio 
                      do acrÃ©scimo da opÃ§Ã£o "-fileLoggerParameters[n]".
-                     "n", se presente, pode ser um dÃ­gito de 1 a 9, permitindo que atÃ©
+                     "n", se presente, pode ser um dÃ­gito de 1 a 9, permitindo que atÃ© 
                      10 agentes de arquivo sejam anexados. (Forma abreviada: -fl[n])
     </target>
         <note>
@@ -959,14 +967,14 @@ isoladamente.
                      Example:
                        -pp:out.txt
     </source>
-        <target state="translated">  -preprocess[:arquivo]
+        <target state="translated">  -preprocess[:arquivo] 
                      Cria um arquivo de projeto Ãºnico e agregado
                      embutindo todos os arquivos que poderiam ser importados durante um
                      build, com seus limites marcados. Isso pode ser
                      Ãºtil para descobrir quais arquivos sÃ£o importados,
                      de qual localizaÃ§Ã£o e como contribuirÃ£o para
                      o build. Por padrÃ£o, a saÃ­da Ã© gravada na
-                     janela do console. Se o caminho de um arquivo de saÃ­da
+                     janela do console. Se o caminho de um arquivo de saÃ­da 
                      for fornecido, ele serÃ¡ usado.
                      (Forma abreviada: -pp)
                      Exemplo:
@@ -1033,7 +1041,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: O valor de projetos isolados nÃ£o Ã© vÃ¡lido. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: O valor de projetos isolados nÃ£o Ã© vÃ¡lido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1547,7 +1555,7 @@ isoladamente.
                        -warnAsError:MSB4130
 
                      Quando um aviso for tratado como um erro, o destino continuarÃ¡
-                     a ser executado como se ele fosse um aviso, mas o
+                     a ser executado como se ele fosse um aviso, mas o 
                      build geral falharÃ¡.
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 252b68b4885..156bc64a2ef 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -149,16 +149,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Ð¡Ð¾Ð¾Ð±ÑÐ°ÐµÑ MSBuild, ÑÑÐ¾ Ð½ÑÐ¶Ð½Ð¾ ÑÐ¾Ð±Ð¸ÑÐ°ÑÑ ÐºÐ°Ð¶Ð´ÑÐ¹ Ð¿ÑÐ¾ÐµÐºÑ Ð¿Ð¾ Ð¾ÑÐ´ÐµÐ»ÑÐ½Ð¾ÑÑÐ¸.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Ð­ÑÐ¾ Ð±Ð¾Ð»ÐµÐµ ÑÑÑÐ¾Ð³Ð¸Ð¹ ÑÐµÐ¶Ð¸Ð¼ MSBuild, ÑÐ°Ðº ÐºÐ°Ðº Ð¾Ð½ ÑÑÐµÐ±ÑÐµÑ,
-                     ÑÑÐ¾Ð±Ñ Ð³ÑÐ°Ñ Ð¿ÑÐ¾ÐµÐºÑÐ° Ð¼Ð¾Ð¶Ð½Ð¾ Ð±ÑÐ»Ð¾ ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸ Ð¾Ð±Ð½Ð°ÑÑÐ¶Ð¸ÑÑ
-                     Ð²Ð¾ Ð²ÑÐµÐ¼Ñ Ð¾ÑÐµÐ½ÐºÐ¸, Ð½Ð¾ Ð¾Ð½ Ð¼Ð¾Ð¶ÐµÑ ÑÐ»ÑÑÑÐ¸ÑÑ Ð¿Ð»Ð°Ð½Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ð¸ ÑÐ¾ÐºÑÐ°ÑÐ¸ÑÑ
-                     Ð¸Ð·Ð´ÐµÑÐ¶ÐºÐ¸ Ð¿Ð°Ð¼ÑÑÐ¸ Ð¿ÑÐ¸ ÑÐ±Ð¾ÑÐºÐµ Ð±Ð¾Ð»ÑÑÐ¸Ñ Ð½Ð°Ð±Ð¾ÑÐ¾Ð² Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð².
-                     (ÐÑÐ°ÑÐºÐ°Ñ ÑÐ¾ÑÐ¼Ð°: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Ð­ÑÐ¾ ÑÐºÑÐ¿ÐµÑÐ¸Ð¼ÐµÐ½ÑÐ°Ð»ÑÐ½ÑÐ¹ ÑÐ»Ð°Ð³. ÐÐ¾Ð¶ÐµÑ ÑÐ°Ð±Ð¾ÑÐ°ÑÑ Ð½Ðµ ÑÐ°Ðº, ÐºÐ°Ðº Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑ.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -655,11 +664,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;ÑÐ°Ð¹Ð»_ÐºÑÑÐ°&gt;...
-                     Ð Ð°Ð·Ð´ÐµÐ»ÐµÐ½Ð½ÑÐ¹ ÑÐ¾ÑÐºÐ°Ð¼ Ñ Ð·Ð°Ð¿ÑÑÐ¾Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐ¾Ð´Ð½ÑÑ ÑÐ°Ð¹Ð»Ð¾Ð² ÐºÑÑÐ°, Ð¾ÑÐºÑÐ´Ð° MSBuild
-                     Ð±ÑÐ´ÐµÑ ÑÑÐ¸ÑÑÐ²Ð°ÑÑ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÑ.
-                     ÐÐ°Ð´Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð³Ð¾ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ° ÑÐ°ÐºÐ¶Ðµ Ð²ÐºÐ»ÑÑÐ°ÐµÑ Ð¸Ð·Ð¾Ð»Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐµ ÑÐ±Ð¾ÑÐºÐ¸ (-isolate).
-                     (ÐÑÐ°ÑÐºÐ°Ñ ÑÐ¾ÑÐ¼Ð°: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -673,11 +681,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[ÑÐ°Ð¹Ð»_ÐºÑÑÐ°]
-                     ÐÑÑÐ¾Ð´Ð½Ð¾Ð¹ ÑÐ°Ð¹Ð» ÐºÑÑÐ°, Ð³Ð´Ðµ MSBuild Ð±ÑÐ´ÐµÑ Ð·Ð°Ð¿Ð¸ÑÑÐ²Ð°ÑÑ ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ð¼Ð¾Ðµ
-                     ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ° ÐºÑÑÐ° ÑÐ±Ð¾ÑÐºÐ¸ Ð² ÐºÐ¾Ð½ÑÐµ.
-                     ÐÑÐ¸ Ð·Ð°Ð´Ð°Ð½Ð¸Ð¸ ÑÑÐ¾Ð³Ð¾ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ° ÑÐ°ÐºÐ¶Ðµ Ð²ÐºÐ»ÑÑÐ°ÑÑÑÑ Ð¸Ð·Ð¾Ð»Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐµ ÑÐ±Ð¾ÑÐºÐ¸ (-isolate).
-                     (ÐÑÐ°ÑÐºÐ°Ñ ÑÐ¾ÑÐ¼Ð°: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1031,7 +1039,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð¸Ð·Ð¾Ð»Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð² ÑÐ²Ð»ÑÐµÑÑÑ Ð½ÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¼. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð¸Ð·Ð¾Ð»Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð¿ÑÐ¾ÐµÐºÑÐ¾Ð² ÑÐ²Ð»ÑÐµÑÑÑ Ð½ÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¼. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 4ff9206f999..fa4daf5abf2 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -120,7 +120,7 @@
                      izin verildiÄini gÃ¶sterir.  EtkileÅimin beklenmediÄi
                      otomatik bir senaryoda bu baÄÄ±msÄ±z deÄiÅkeni
                      kullanmayÄ±n.
-                     -interactive deÄerinin belirtilmesi, -interactive:true
+                     -interactive deÄerinin belirtilmesi, -interactive:true 
                      deÄerinin belirtilmesiyle aynÄ±dÄ±r.  Parametreyi, yanÄ±t
                      dosyasÄ±ndan gelen bir deÄeri geÃ§ersiz kÄ±lmak iÃ§in kullanÄ±n.
     </target>
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuild tarafÄ±ndan her projenin yalÄ±tÄ±lmÄ±Å olarak oluÅturulmasÄ±na yol aÃ§ar.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Bu mod, deÄerlendirme sÄ±rasÄ±nda proje grafiÄinin
-                     istatistiksel olarak keÅfedilebilmesini gerektirdiÄinden
-                     nispeten daha kÄ±sÄ±tlayÄ±cÄ± bir MSBuild modudur, ancak Ã§ok sayÄ±da
-                     proje oluÅturulurken zamanlamayÄ± geliÅtirebilir ve bellek ek yÃ¼kÃ¼nÃ¼ azaltabilir.
-                     (KÄ±sa biÃ§im: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Bu bayrak deneme amaÃ§lÄ±dÄ±r ve amaÃ§landÄ±ÄÄ± gibi Ã§alÄ±Åmayabilir.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -406,7 +415,7 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje dÃ¼zeyi Ã¶zellikleri ayarlayÄ±n veya geÃ§ersiz kÄ±lÄ±n. &lt;n&gt;
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje dÃ¼zeyi Ã¶zellikleri ayarlayÄ±n veya geÃ§ersiz kÄ±lÄ±n. &lt;n&gt; 
                      Ã¶zelliÄin adÄ± ve &lt;v&gt; Ã¶zelliÄin deÄeridir. Birden Ã§ok
                      Ã¶zelliÄi birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya virgÃ¼l
                      kullanÄ±n veya her Ã¶zelliÄi ayrÄ± ayrÄ± belirtin. (KÄ±sa biÃ§im: -p)
@@ -447,7 +456,7 @@
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ derlemesi&gt; sÃ¶z dizimi ÅÃ¶yledir:
                        {&lt;derleme adÄ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasÄ±&gt;}
                      GÃ¼nlÃ¼kÃ§Ã¼ seÃ§enekleri, MSBuild'in gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ oluÅturma biÃ§imini belirtir.
-                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄe baÄlÄ±dÄ±r ve tam olarak
+                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄe baÄlÄ±dÄ±r ve tam olarak 
                      yazdÄ±ÄÄ±nÄ±z Åekliyle gÃ¼nlÃ¼kÃ§Ã¼ye geÃ§irilir. (KÄ±sa biÃ§im: -l)
                      Ãrnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -656,11 +665,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;Ã¶nbellekDosyasÄ±&gt;...
-                     MSBuild'in derleme sonuÃ§larÄ±nÄ± okuyacaÄÄ± giriÅ
-                     Ã¶nbellek dosyalarÄ±nÄ±n noktalÄ± virgÃ¼lle ayrÄ±lmÄ±Å listesi.
-                     AyarlandÄ±ÄÄ±nda yalÄ±tÄ±lmÄ±Å derlemeler de aÃ§Ä±lÄ±r (-isolate).
-                     (kÄ±sa biÃ§im: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +682,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[Ã¶nbellekDosyasÄ±]
-                     MSBuildâin derleme sonunda derleme sonucu Ã¶nbelleklerinin
-                     iÃ§eriÄini yazacaÄÄ± Ã§Ä±kÄ±Å Ã¶nbellek dosyasÄ±.
-                     Bu aÃ§Ä±ldÄ±ÄÄ±nda yalÄ±tÄ±lmÄ±Å derlemeler (-isolate) de aÃ§Ä±lÄ±r.
-                     (kÄ±sa biÃ§im: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -747,9 +755,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantÄ±lar&gt;
-                     Hangi proje dosyasÄ±nÄ±n oluÅturulacaÄÄ± belirlenirken
-                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ±
-                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya
+                     Hangi proje dosyasÄ±nÄ±n oluÅturulacaÄÄ± belirlenirken 
+                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ± 
+                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya 
                      virgÃ¼l kullanÄ±n.
                      (KÄ±sa biÃ§im: -ignore)
                      Ãrnek:
@@ -775,8 +783,8 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;sÃ¼rÃ¼m&gt;
                      Derleme sÄ±rasÄ±nda kullanÄ±lacak MSBuild AraÃ§ KÃ¼mesinin
-                     (gÃ¶revler, hedefler vb.) sÃ¼rÃ¼mÃ¼. Bu sÃ¼rÃ¼m, tek tek projelerde
-                     belirtilen sÃ¼rÃ¼mleri geÃ§ersiz kÄ±lar. (KÄ±sa biÃ§im:
+                     (gÃ¶revler, hedefler vb.) sÃ¼rÃ¼mÃ¼. Bu sÃ¼rÃ¼m, tek tek projelerde 
+                     belirtilen sÃ¼rÃ¼mleri geÃ§ersiz kÄ±lar. (KÄ±sa biÃ§im: 
                      -tv)
                      Ãrnek:
                        -toolsVersion:3.5
@@ -835,14 +843,14 @@
         <target state="translated">  -distributedFileLogger
                      Derleme Ã§Ä±kÄ±ÅÄ±nÄ±, her MSBuild dÃ¼ÄÃ¼mÃ¼ iÃ§in bir gÃ¼nlÃ¼k
                      dosyasÄ± olmak Ã¼zere birden Ã§ok gÃ¼nlÃ¼k dosyasÄ±na kaydeder. Bu
-                     dosyalarÄ±n ilk konumu geÃ§erli dizindir. DosyalarÄ±n
-                     varsayÄ±lan adÄ± "MSBuild&lt;dÃ¼ÄÃ¼mkimliÄi&gt;.log"dur.
-                     DosyalarÄ±n konumu ve fileLogger'Ä±n diÄer parametreleri
+                     dosyalarÄ±n ilk konumu geÃ§erli dizindir. DosyalarÄ±n 
+                     varsayÄ±lan adÄ± "MSBuild&lt;dÃ¼ÄÃ¼mkimliÄi&gt;.log"dur. 
+                     DosyalarÄ±n konumu ve fileLogger'Ä±n diÄer parametreleri 
                      "/fileLoggerParameters" anahtarÄ±nÄ±n eklenmesi yoluyla
                      belirtilebilir.
 
                      GÃ¼nlÃ¼k dosyasÄ± adÄ± fileLoggerParameters anahtarÄ±
-                     aracÄ±lÄ±ÄÄ±yla ayarlanÄ±rsa daÄÄ±tÄ±lmÄ±Å gÃ¼nlÃ¼kÃ§Ã¼ fileName
+                     aracÄ±lÄ±ÄÄ±yla ayarlanÄ±rsa daÄÄ±tÄ±lmÄ±Å gÃ¼nlÃ¼kÃ§Ã¼ fileName 
                      deÄerini Åablon olarak kullanÄ±p her dÃ¼ÄÃ¼mÃ¼n gÃ¼nlÃ¼k dosyasÄ±nÄ±
                      oluÅturmak iÃ§in bu fileName deÄerine dÃ¼ÄÃ¼m kimliÄini ekler.
     </target>
@@ -887,32 +895,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya gÃ¼nlÃ¼kÃ§Ã¼leri iÃ§in ek parametreler saÄlar.
-                     Bu anahtarÄ±n olmasÄ± karÅÄ±lÄ±k gelen -fileLogger[n]
+                     Bu anahtarÄ±n olmasÄ± karÅÄ±lÄ±k gelen -fileLogger[n] 
                      anahtarÄ±nÄ±n olduÄu anlamÄ±na gelir.
                      "n" varsa, 1-9 arasÄ±nda bir rakam olabilir.
-                     DaÄÄ±tÄ±lmÄ±Å dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters
-                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger
+                     DaÄÄ±tÄ±lmÄ±Å dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters 
+                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger 
                      aÃ§Ä±klamasÄ±na bakÄ±n.
                      (KÄ±sa biÃ§im: -flp[n])
-                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler
+                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler 
                      kullanÄ±labilir. KullanÄ±labilecek bazÄ± ek parametreler:
-                        LogFile--OluÅturma gÃ¼nlÃ¼ÄÃ¼nÃ¼n yazÄ±lacaÄÄ± gÃ¼nlÃ¼k
+                        LogFile--OluÅturma gÃ¼nlÃ¼ÄÃ¼nÃ¼n yazÄ±lacaÄÄ± gÃ¼nlÃ¼k 
                             dosyasÄ±nÄ±n yolu.
-                        Append--Derleme gÃ¼nlÃ¼ÄÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ±
-                            ekleneceÄini yoksa Ã¼zerine mi yazÄ±lacaÄÄ±nÄ±
-                            belirler. Anahtar ayarlandÄ±ÄÄ±nda oluÅturma gÃ¼nlÃ¼ÄÃ¼
-                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄÄ±nda
-                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r.
+                        Append--Derleme gÃ¼nlÃ¼ÄÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ± 
+                            ekleneceÄini yoksa Ã¼zerine mi yazÄ±lacaÄÄ±nÄ± 
+                            belirler. Anahtar ayarlandÄ±ÄÄ±nda oluÅturma gÃ¼nlÃ¼ÄÃ¼ 
+                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄÄ±nda 
+                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r. 
                             VarsayÄ±lan: gÃ¼nlÃ¼k dosyasÄ±nÄ±n sonuna eklenmez.
-                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄin,
+                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄin, 
                             UTF-8, Unicode veya ASCII
                      VarsayÄ±lan ayrÄ±ntÄ± dÃ¼zeyi ayarÄ± Detailed'dÄ±r.
                      Ãrnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1036,7 +1044,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Projeleri yalÄ±tma deÄeri geÃ§erli deÄil. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Projeleri yalÄ±tma deÄeri geÃ§erli deÄil. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index a5ec18908f5..655c791a6eb 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     ä½¿ MSBuild ç¬ç«çææ¯ä¸ªé¡¹ç®ã
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     è¿æ¯ MSBuild æ´å·éå¶æ§çæ¨¡å¼ï¼å ä¸ºå®è¦æ±
-                     å¯å¨è¯ä¼°æ¶éæå°åç°é¡¹ç®
-                     å³ç³»å¾ï¼ä½å¯å¨çæå¤§åé¡¹ç®éæ¶
-                     æ¹åè®¡åå¹¶éä½åå­å¼éã
-                     (ç¼©å: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     æ­¤æ è®°å¤äºè¯éªé¶æ®µï¼å¯è½æ æ³æé¢æå·¥ä½ã
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -593,10 +602,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate     ä¾æ®é»è®¤æ¶æéªè¯é¡¹ç®ã(ç¼©å:
+        <target state="translated">  -validate     ä¾æ®é»è®¤æ¶æéªè¯é¡¹ç®ã(ç¼©å: 
            -val)
 
- -validate:&lt;schema&gt; ä¾æ®æå®çæ¶æéªè¯é¡¹ç®ã(ç¼©å:
+ -validate:&lt;schema&gt; ä¾æ®æå®çæ¶æéªè¯é¡¹ç®ã(ç¼©å: 
            -val)
            ç¤ºä¾:
             -validate:MyExtendedBuildSchema.xsd
@@ -656,11 +665,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     è¾å¥ç¼å­æä»¶çåå·åéåè¡¨ï¼MSBuild
-                     å°ä»è¿äºæä»¶ä¸­è¯»åçæç»æã
-                     è®¾ç½®æ­¤åè¡¨è¿å°æå¼åéççæ(-isolate)ã
-                     (ç¼©å: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,10 +682,10 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     è¾åºç¼å­æä»¶ï¼MSBuild å°å¨
-                     çæç»ææ¶åå¥å¶çæç»æç¼å­çåå®¹ã
-                     è®¾ç½®å®ä¹ä¼æå¼éç¦»ççæ (-isolate).
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </target>
         <note>
@@ -775,7 +783,7 @@
         <target state="translated">  -toolsversion:&lt;version&gt;
            è¦å¨çæè¿ç¨ä¸­ä½¿ç¨ç MSBuild å·¥å·é
            (ä»»å¡ãç®æ ç­)ççæ¬ãæ­¤çæ¬å°éå
-           åä¸ªé¡¹ç®æå®ççæ¬ã(ç¼©å:
+           åä¸ªé¡¹ç®æå®ççæ¬ã(ç¼©å: 
            -tv)
            ç¤ºä¾:
             -toolsversion:3.5
@@ -831,17 +839,17 @@
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger
+        <target state="translated">  -distributedFileLogger                            
            å°çæè¾åºè®°å½å°å¤ä¸ªæ¥å¿æä»¶ï¼æ¯ä¸ª MSBuild èç¹
            ä¸ä¸ªæ¥å¿æä»¶ãè¿äºæä»¶çåå§ä½ç½®ä¸º
            å½åç®å½ãé»è®¤æåµä¸ï¼è¿äºæä»¶åä¸º
            âMSBuild&lt;nodeid&gt;.logâãå¯éè¿æ·»å 
-           â-fileLoggerParametersâå¼å³æ¥æå®
+           â-fileLoggerParametersâå¼å³æ¥æå® 
            è¿äºæä»¶çä½ç½®å fileLogger çå¶ä»åæ°ã
 
            å¦ææ¥å¿æä»¶åæ¯éè¿ fileLoggerParameters
            å¼å³è®¾ç½®çï¼åå¸å¼è®°å½å¨å°ä½¿ç¨ fileName ä½ä¸º
-           æ¨¡æ¿å¹¶å°èç¹ ID éå å°æ­¤ fileName
+           æ¨¡æ¿å¹¶å°èç¹ ID éå å°æ­¤ fileName 
            ä»¥ä¾¿ä¸ºæ¯ä¸ªèç¹åå»ºä¸ä¸ªæ¥å¿æä»¶ã
     </target>
         <note>
@@ -883,12 +891,12 @@
                        -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </source>
-        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;
+        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;                
            ä¸ºæä»¶è®°å½å¨æä¾ä»»ä½é¢å¤çåæ°ã
            å­å¨æ­¤å¼å³æå³ç
            å­å¨å¯¹åºç -filelogger[n] å¼å³ã
           ânâ(å¦æå­å¨)å¯ä»¥ä¸º 1-9 çæ°å­ã
-           ä»»ä½åå¸å¼æä»¶è®°å½å¨ä¹å¯ä»¥ä½¿ç¨
+           ä»»ä½åå¸å¼æä»¶è®°å½å¨ä¹å¯ä»¥ä½¿ç¨ 
            -fileloggerparametersï¼å·ä½å¯åé -distributedFileLogger çè¯´æã
            (ç¼©å: -flp[n])
            ä¸ºæ§å¶å°è®°å½å¨ååºçç¸ååæ°
@@ -908,8 +916,8 @@
             -fileLoggerParameters:LogFile=MyLog.log;Append;
                       Verbosity=diagnostic;Encoding=UTF-8
 
-            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-            -flp1:warningsonly;logfile=msbuild.wrn
+            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+            -flp1:warningsonly;logfile=msbuild.wrn 
             -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1032,7 +1040,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: ç¬ç«é¡¹ç®å¼æ æã{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: ç¬ç«é¡¹ç®å¼æ æã{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 521bc7fb13b..49e328d19ea 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -150,16 +150,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     å¼ç¼ MSBuild ç¨ç«å»ºç½®ååå°æ¡ã
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     éæ¯éå¶åº¦è¼é«ç MSBuild æ¨¡å¼ï¼å çº
-                     å°æ¡åå½¢æéè¦å¨è©ä¼°éæ®µå¯ä¾éææ¢ç´¢ï¼
-                     ä½è½å¨å»ºç½®ä¸çµå¤§éå°æ¡ææ¹åæç¨
-                     åéä½è¨æ¶é«é¡å¤è² è·ã
-                     (ç°¡ç­å½¢å¼: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     éæ¯å¯¦é©æ§çææ¨ï¼éä½æå½¢å¯è½ä¸å¦é æã
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -656,11 +665,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;å¿«åæªæ¡&gt;...
-                     ä»¥åèåéçè¼¸å¥å¿«åæªæ¡
-                      (MSBuild å°æå¾æ­¤æªæ¡è®åå»ºç½®çµæ) æ¸å®ã
-                     è¨­å®æ­¤é ç®ä¹æéåéé¢å¼å»ºç½® (-isolate)ã
-                     (ç°¡ç­å½¢å¼: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +682,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuild è¦å¨çµå»ºçµææå¯«å¥
-                     å¶çµå»ºçµæå¿«åå§å®¹çç®æ¨è¼¸åºå¿«åæªæ¡ã
-                     è¨­å®æ­¤é ä¹æéåéé¢çµå»º (-isolate)ã
-                     (ç°¡ç­æ ¼å¼: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -774,8 +782,8 @@
    </source>
         <target state="translated">  -toolsversion:&lt;çæ¬&gt;
                      å»ºç½®æéæä½¿ç¨ç MSBuild å·¥å·çµ (å·¥ä½ãç®æ¨ç­)
-                      çæ¬ãæ­¤çæ¬å°æè¦å¯«
-                     åå¥å°æ¡ææå®ççæ¬ã(ç°¡ç­å½¢å¼:
+                      çæ¬ãæ­¤çæ¬å°æè¦å¯« 
+                     åå¥å°æ¡ææå®ççæ¬ã(ç°¡ç­å½¢å¼: 
                      -tv)
                      ç¯ä¾:
                        -toolsVersion:3.5
@@ -1032,7 +1040,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: ç¨ç«å¼å°æ¡å¼ç¡æã{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: ç¨ç«å¼å°æ¡å¼ç¡æã{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 2ed16d7dafa..9418b75f52a 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3243,8 +3243,12 @@ private static ILogger[] ProcessLoggingSwitches(
                 originalVerbosity = ProcessVerbositySwitch(verbositySwitchParameters[verbositySwitchParameters.Length - 1]);
                 verbosity = originalVerbosity;
             }
+            var loggers = new List<ILogger>();
+
+            var outVerbosity = verbosity;
+            ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);
 
-            var loggers = ProcessLoggerSwitch(loggerSwitchParameters, verbosity);
+            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);
 
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
@@ -3265,11 +3269,11 @@ private static ILogger[] ProcessLoggingSwitches(
 
             ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
 
-            ProcessBinaryLogger(binaryLoggerParameters, loggers, ref verbosity);
-
             // TOOD: Review
             // ProcessLiveLogger(noConsoleLogger, loggers);
 
+            verbosity = outVerbosity;
+
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
 
             return loggers.ToArray();
@@ -3668,10 +3672,8 @@ internal static LoggerVerbosity ProcessVerbositySwitch(string value)
         /// Figures out which additional loggers are going to listen to build events.
         /// </summary>
         /// <returns>List of loggers.</returns>
-        private static List<ILogger> ProcessLoggerSwitch(string[] parameters, LoggerVerbosity verbosity)
+        private static void ProcessLoggerSwitch(string[] parameters, List<ILogger> loggers, LoggerVerbosity verbosity)
         {
-            var loggers = new List<ILogger>();
-
             foreach (string parameter in parameters)
             {
                 string unquotedParameter = QuotingUtilities.Unquote(parameter);
@@ -3683,8 +3685,6 @@ private static List<ILogger> ProcessLoggerSwitch(string[] parameters, LoggerVerb
                     loggers.Add(logger);
                 }
             }
-
-            return loggers;
         }
 
         /// <summary>
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index cd95cc40864..cb3857ff100 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -75,5 +75,11 @@ public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
             var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
             return buildEventContext;
         }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static unsafe Guid ReadGuid(this BinaryReader reader)
+        {
+            return new Guid(reader.ReadBytes(sizeof(Guid)));
+        }
     }
 }
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index 41636982688..2a221d573a5 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -71,5 +71,19 @@ public static void WriteBuildEventContext(this BinaryWriter writer, BuildEventCo
             writer.Write(context.ProjectInstanceId);
             writer.Write(context.EvaluationId);
         }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void WriteGuid(this BinaryWriter writer, Guid value)
+        {
+            Guid val = value;
+            unsafe
+            {
+                byte* ptr = (byte*)&val;
+                for (int i = 0; i < sizeof(Guid); i++, ptr++)
+                {
+                    writer.Write(*ptr);
+                }
+            }
+        }
     }
 }
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index a4c00b30b76..b2f5106d38d 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -599,7 +599,13 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
 
                 MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
                 MSBuildToolsDirectory64 = existsCheck(potentialAmd64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "amd64") : CurrentMSBuildToolsDirectory;
+#if RUNTIME_TYPE_NETCORE
+                // Fall back to "current" for any architecture since .NET SDK doesn't
+                // support cross-arch task invocations.
+                MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : CurrentMSBuildToolsDirectory;
+#else
                 MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
+#endif
             }
 
             MSBuildExtensionsPath = mode == BuildEnvironmentMode.VisualStudio
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index 1ff1e5b762b..6b2f8aed5c8 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -42,8 +42,10 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
             LoadedAssembly = loadedAssembly;
 
 #if !NET35
-            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
+            // This block is reflection only loaded type implementation. Net35 does not support it, and fall backs to former implementation in #else
+            // Property `Properties` set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
             // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.
+
             // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.
             Type t = type;
             while (t is not null)
@@ -104,6 +106,11 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
                     PropertyAssemblyQualifiedNames[i] = Properties[i].PropertyType.AssemblyQualifiedName;
                 }
             }
+#else
+            // For v3.5 fallback to old full type approach, as oppose to reflection only
+            HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);
+            HasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);
+            IsMarshalByRef = this.Type.IsMarshalByRef;
 #endif
         }
 
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 9938e6ac170..b885d081a74 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -139,7 +139,12 @@ internal enum LoggingEventType : int
         /// <summary>
         /// Event is a ResponseFileUsedEventArgs
         /// </summary>
-        ResponseFileUsedEvent = 20
+        ResponseFileUsedEvent = 20,
+
+        /// <summary>
+        /// Event is an AssemblyLoadBuildEventArgs
+        /// </summary>
+        AssemblyLoadEvent = 21,
     }
     #endregion
 
@@ -332,9 +337,9 @@ internal void WriteToStream(ITranslator translator)
                 bool eventCanSerializeItself = methodInfo != null;
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
-                if (_buildEvent is ProjectEvaluationStartedEventArgs ||
-                    _buildEvent is ProjectEvaluationFinishedEventArgs ||
-                    _buildEvent is EnvironmentVariableReadEventArgs)
+                if (_buildEvent is ProjectEvaluationStartedEventArgs
+                    or ProjectEvaluationFinishedEventArgs
+                    or EnvironmentVariableReadEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -524,6 +529,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
                 LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
+                LoggingEventType.AssemblyLoadEvent => new AssemblyLoadBuildEventArgs(),
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
                 LoggingEventType.ProjectEvaluationFinishedEvent => new ProjectEvaluationFinishedEventArgs(),
@@ -588,6 +594,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.Telemetry;
             }
+            else if (eventType == typeof(AssemblyLoadBuildEventArgs))
+            {
+                return LoggingEventType.AssemblyLoadEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index 0dcfd58ba9d..b74e7ce01d8 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Reflection;
-
 using Microsoft.Build.Framework;
 
 #nullable disable
@@ -52,6 +51,7 @@ internal static ITask CreateTask(
             LogError logError,
 #if FEATURE_APPDOMAIN
             AppDomainSetup appDomainSetup,
+            Action<AppDomain> appDomainCreated,
 #endif
             bool isOutOfProc
 #if FEATURE_APPDOMAIN
@@ -118,6 +118,7 @@ bool isOutOfProc
 
                         // Hook up last minute dumping of any exceptions 
                         taskAppDomain.UnhandledException += ExceptionHandling.UnhandledExceptionHandler;
+                        appDomainCreated?.Invoke(taskAppDomain);
                     }
                 }
                 else
diff --git a/src/Shared/UnitTests/EngineTestEnvironment.cs b/src/Shared/UnitTests/EngineTestEnvironment.cs
index e4c8ee3d1a3..c06703a4a66 100644
--- a/src/Shared/UnitTests/EngineTestEnvironment.cs
+++ b/src/Shared/UnitTests/EngineTestEnvironment.cs
@@ -153,8 +153,9 @@ public override void Revert()
         {
             var result = new List<(ILogger logger, Func<string> textGetter)>();
 
-            result.Add(GetMockLogger());
+            // Add binlogger first - so that it get's all messages (the logger initialization messages goes only to so far initialized loggers)
             result.Add(GetBinaryLogger());
+            result.Add(GetMockLogger());
 
 #if MICROSOFT_BUILD_ENGINE_UNITTESTS
             result.Add(GetSerialLogger());
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 00e9c2c6103..4272a5e149e 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -1331,9 +1331,10 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                 }
 
                 // Go through each of the references, we go through this table because in general it will be considerably smaller than the blacklist. (10's of references vs 100's of black list items)
-                foreach (AssemblyNameExtension assemblyName in References.Keys)
+                foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
                 {
-                    Reference assemblyReference = References[assemblyName];
+                    AssemblyNameExtension assemblyName = assembly.Key;
+                    Reference assemblyReference = assembly.Value;
 
                     AddToDependencyGraph(dependencyGraph, assemblyName, assemblyReference);
 
@@ -1495,12 +1496,12 @@ private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason
         /// </summary>
         internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         {
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
-                Reference assemblyReference = References[assemblyName];
+                Reference assemblyReference = assembly.Value;
                 if (assemblyReference.IsPrimary && assemblyReference.PrimarySourceItem.ItemSpec.Equals(itemSpec, StringComparison.OrdinalIgnoreCase))
                 {
-                    return assemblyName;
+                    return assembly.Key;
                 }
             }
 
@@ -1731,14 +1732,14 @@ private bool FindAssociatedFiles()
         /// </summary>
         private void ResolveAssemblyFilenames()
         {
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
-                Reference reference = GetReference(assemblyName);
+                Reference reference = assembly.Value;
 
                 // Has this reference been resolved to a file name?
                 if (!reference.IsResolved && !reference.IsUnresolvable)
                 {
-                    ResolveReference(assemblyName, null, reference);
+                    ResolveReference(assembly.Key, null, reference);
                 }
             }
         }
@@ -2153,16 +2154,19 @@ private Dictionary<string, List<AssemblyNameReference>> BuildSimpleNameTable()
         private static void RemoveReferencesWithoutConflicts(
             Dictionary<string, List<AssemblyNameReference>> baseNameToReferences)
         {
-            string[] baseNames = new string[baseNameToReferences.Count];
-            baseNameToReferences.Keys.CopyTo(baseNames, 0);
-
-            foreach (string baseName in baseNames)
+            List<string> toRemove = new(baseNameToReferences.Count);
+            foreach (KeyValuePair<string, List<AssemblyNameReference>> kvp in baseNameToReferences)
             {
-                if (baseNameToReferences[baseName].Count == 1)
+                if (kvp.Value.Count == 1)
                 {
-                    baseNameToReferences.Remove(baseName);
+                    toRemove.Add(kvp.Key);
                 }
             }
+
+            foreach (string key in toRemove)
+            {
+                baseNameToReferences.Remove(key);
+            }
         }
 
         // TODO: Verify correctness of this implementation and extend to more cases.
@@ -3095,10 +3099,11 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
             bool anyMarkedReference = false;
             ListOfExcludedAssemblies = new List<string>();
 
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
+                AssemblyNameExtension assemblyName = assembly.Key;
+                Reference reference = assembly.Value;
                 string assemblyFullName = assemblyName.FullName;
-                Reference reference = GetReference(assemblyName);
                 reference.ReferenceVersion = assemblyName.Version;
 
                 MarkReferenceWithHighestVersionInCurrentRedistList(assemblyName, reference);
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 9e21604d2d6..a3942efd097 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1067,10 +1067,11 @@ quiet at the engine level.
                 if (!Silent)
                 {
                     // First, loop over primaries and display information.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference primaryCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference primaryCandidate = assembly.Value;
 
                         if (primaryCandidate.IsPrimary && !(primaryCandidate.IsConflictVictim && primaryCandidate.IsCopyLocal))
                         {
@@ -1079,10 +1080,11 @@ quiet at the engine level.
                     }
 
                     // Second, loop over dependencies and display information.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference dependencyCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference dependencyCandidate = assembly.Value;
 
                         if (!dependencyCandidate.IsPrimary && !(dependencyCandidate.IsConflictVictim && dependencyCandidate.IsCopyLocal))
                         {
@@ -1091,10 +1093,11 @@ quiet at the engine level.
                     }
 
                     // Third, show conflicts and their resolution.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference conflictCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference conflictCandidate = assembly.Value;
 
                         if (conflictCandidate.IsConflictVictim)
                         {
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index a55f04aa68c..c173abab5b9 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -809,7 +809,7 @@ internal static bool MakeHardLink(string newFileName, string exitingFileName, re
             else
             {
                 hardLinkCreated = link(exitingFileName, newFileName) == 0;
-                errorMessage = hardLinkCreated ? null : log.FormatResourceString("Copy.LinklibraryFailedPrefix", "link()", Marshal.GetLastWin32Error());
+                errorMessage = hardLinkCreated ? null : log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "link()", Marshal.GetLastWin32Error());
             }
 
             return hardLinkCreated;
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index e8ea34b2e30..d279d8fd9e2 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -1037,11 +1037,11 @@ private void GetSDKManifestAttributes()
                 {
                     if (_sdkManifest.FrameworkIdentities != null)
                     {
-                        foreach (string key in _sdkManifest.FrameworkIdentities.Keys)
+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.FrameworkIdentities)
                         {
-                            if (!FrameworkIdentitiesFromManifest.ContainsKey(key))
+                            if (!FrameworkIdentitiesFromManifest.ContainsKey(kvp.Key))
                             {
-                                FrameworkIdentitiesFromManifest.Add(key, _sdkManifest.FrameworkIdentities[key]);
+                                FrameworkIdentitiesFromManifest.Add(kvp.Key, kvp.Value);
                             }
                         }
                     }
@@ -1054,11 +1054,11 @@ private void GetSDKManifestAttributes()
                 {
                     if (_sdkManifest.AppxLocations != null)
                     {
-                        foreach (string key in _sdkManifest.AppxLocations.Keys)
+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.AppxLocations)
                         {
-                            if (!AppxLocationsFromManifest.ContainsKey(key))
+                            if (!AppxLocationsFromManifest.ContainsKey(kvp.Key))
                             {
-                                AppxLocationsFromManifest.Add(key, _sdkManifest.AppxLocations[key]);
+                                AppxLocationsFromManifest.Add(kvp.Key, kvp.Value);
                             }
                         }
                     }
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 82ed1626244..f687076fbfb 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -884,11 +884,12 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     if (!_maintainCompositeRootingMarkers)
                     {
-                        foreach (string primaryFile in DependencyTable.Keys)
+                        foreach (KeyValuePair<string, Dictionary<string, string>> dependency in DependencyTable)
                         {
+                            string primaryFile = dependency.Key;
                             if (!primaryFile.Contains("|")) // composite roots are not needed
                             {
-                                Dictionary<string, string> dependencies = DependencyTable[primaryFile];
+                                Dictionary<string, string> dependencies = dependency.Value;
                                 inputs.WriteLine("^" + primaryFile);
                                 foreach (string file in dependencies.Keys)
                                 {
@@ -906,10 +907,10 @@ public void SaveTlog(DependencyFilter includeInTLog)
                     {
                         // Just output the rooting markers and their dependencies -- we don't want to
                         // compact out the composite ones.
-                        foreach (string rootingMarker in DependencyTable.Keys)
+                        foreach (KeyValuePair<string, Dictionary<string, string>> dependency in DependencyTable)
                         {
-                            Dictionary<string, string> dependencies = DependencyTable[rootingMarker];
-                            inputs.WriteLine("^" + rootingMarker);
+                            Dictionary<string, string> dependencies = dependency.Value;
+                            inputs.WriteLine("^" + dependency.Key);
                             foreach (string file in dependencies.Keys)
                             {
                                 // Give the task a chance to filter dependencies out of the written TLog
@@ -1060,8 +1061,9 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                 var dependenciesWithoutMissingFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 int keyIndex = 0;
 
-                foreach (string file in dependencies.Keys)
+                foreach (KeyValuePair<string, string> kvp in dependencies)
                 {
+                    string file = kvp.Key;
                     if (keyIndex++ > 0)
                     {
                         // Record whether or not each file exists and cache it.
@@ -1078,7 +1080,7 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                         // Does the cached file exist?
                         if (fileExists)
                         {
-                            dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
+                            dependenciesWithoutMissingFiles.Add(file, kvp.Value);
                         }
                     }
                     else
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 1c19b7868df..ef1ad5bfa5e 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -594,9 +594,10 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 // Write out the dependency information as a new tlog
                 using (StreamWriter outputs = FileUtilities.OpenWrite(firstTlog, false, System.Text.Encoding.Unicode))
                 {
-                    foreach (string rootingMarker in DependencyTable.Keys)
+                    foreach (KeyValuePair<string, Dictionary<string, DateTime>> kvp in DependencyTable)
                     {
-                        Dictionary<string, DateTime> dependencies = DependencyTable[rootingMarker];
+                        string rootingMarker = kvp.Key;
+                        Dictionary<string, DateTime> dependencies = kvp.Value;
                         outputs.WriteLine("^" + rootingMarker);
                         foreach (string file in dependencies.Keys)
                         {
@@ -754,8 +755,9 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                 var dependenciesWithoutMissingFiles = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
                 int keyIndex = 0;
 
-                foreach (string file in dependencies.Keys)
+                foreach (KeyValuePair<string, DateTime> kvp in dependencies)
                 {
+                    string file = kvp.Key;
                     if (keyIndex++ > 0)
                     {
                         // Record whether or not each file exists and cache it.
@@ -772,7 +774,7 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                         // Does the cached file exist?
                         if (fileExists)
                         {
-                            dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
+                            dependenciesWithoutMissingFiles.Add(file, kvp.Value);
                         }
                     }
                     else
