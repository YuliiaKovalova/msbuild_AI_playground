diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 42ff3d408de..2b5e52f187e 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Engine.UnitTests.Globbing;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -755,6 +756,48 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(
             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, "");
         }
 
+        /// <summary>
+        /// Throws exception when an included wildcard evaluates to a drive enumeration.
+        /// </summary>
+        [Fact]
+        public void PropertyEvaluationResultingInDriveEnumeration()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+                string content =
+                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+                    <ItemGroup>
+                        <FilesToCopy Include=""$(Microsoft_WindowsAzure_EngSys)\**\*"" Exclude=""$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*"" />
+                    </ItemGroup>
+                  </Project>
+                ";
+
+                var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
+                Should.Throw<InvalidProjectFileException>(() => { ProjectInstance.FromFile(testFile.Path, new ProjectOptions()); });
+            }
+        }
+
+        /// <summary>
+        /// Throws exception when an imported wildcard evaluates to a drive enumeration.
+        /// </summary>
+        [Fact]
+        public void ImportEvaluationResultingInDriveEnumeration()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+                string content =
+                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+                    <Import Project=""$(Microsoft_WindowsAzure_EngSys)\**\*"" />
+                  </Project>
+                ";
+
+                var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
+                Should.Throw<InvalidProjectFileException>(() => { ProjectInstance.FromFile(testFile.Path, new ProjectOptions()); });
+            }
+        }
+
         private static void TestIncludeExcludeWithDifferentSlashes(string projectContents, string includeString, string excludeString, string[] inputFiles, string[] expectedInclude, bool makeExpectedIncludeAbsolute = false)
         {
             Action<string, string> runTest = (include, exclude) =>
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 02e91aa5a06..272ad1343da 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -15,6 +16,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
 using System.Linq;
+using Shouldly;
 
 #nullable disable
 
@@ -837,6 +839,37 @@ public void MetadataConditionReferringToMetadataOnSameItem()
             Assert.Equal(String.Empty, items[0].GetMetadataValue("m2"));
         }
 
+        /// <summary>
+        /// Tests item inclusion of drive enumeration wildcard within a target.
+        /// </summary>
+        [Fact]
+        public void TargetItemEvaluationResultingInDriveEnumeration()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+                string content =
+                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+                    <Target Name=""TestTarget"">
+                        <ItemGroup>
+                            <FilesToCopy Include=""$(Microsoft_WindowsAzure_EngSys)\**\*"" Exclude=""$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*"" />
+                        </ItemGroup>
+                    </Target>
+                  </Project>
+                ";
+
+                var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
+                var p = ProjectInstance.FromFile(testFile.Path, new ProjectOptions());
+
+                BuildManager buildManager = BuildManager.DefaultBuildManager;
+                BuildRequestData data = new BuildRequestData(p, new[] { "TestTarget" });
+                BuildParameters parameters = new BuildParameters();
+                BuildResult buildResult = buildManager.Build(parameters, data);
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+                buildResult["TestTarget"].Exception?.Message.ShouldContain("this resulted in an attempted drive enumeration");
+            }
+        }
+
         [Fact]
         public void UpdateShouldRespectConditions()
         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index d39ce74cb49..9d3aef593f6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -371,8 +371,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ISet<string> removeMetadata
         )
         {
-            // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
-
+            //todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
             ProjectErrorUtilities.VerifyThrowInvalidProject(!(keepMetadata != null && removeMetadata != null), originalItem.KeepMetadataLocation, "KeepAndRemoveMetadataMutuallyExclusive");
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
@@ -427,24 +426,31 @@ ISet<string> removeMetadata
                 }
                 else
                 {
-                    // The expression is not of the form "@(X)". Treat as string
+                    try
+                    {
+                        // The expression is not of the form "@(X)". Treat as string
 
-                    // Pass the non wildcard expanded excludes here to fix https://github.com/dotnet/msbuild/issues/2621
-                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
-                        Project.Directory,
-                        includeSplit,
-                        excludes);
+                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621
+                        string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
+                            Project.Directory,
+                            includeSplit,
+                            excludes);
 
-                    foreach (string includeSplitFile in includeSplitFiles)
+                        foreach (string includeSplitFile in includeSplitFiles)
+                        {
+                            items.Add(new ProjectItemInstance(
+                                Project,
+                                originalItem.ItemType,
+                                includeSplitFile,
+                                includeSplit /* before wildcard expansion */,
+                                null,
+                                null,
+                                originalItem.Location.File));
+                        }
+                    }
+                    catch (DriveEnumerationWildcardException ex)
                     {
-                        items.Add(new ProjectItemInstance(
-                            Project,
-                            originalItem.ItemType,
-                            includeSplitFile,
-                            includeSplit /* before wildcard expansion */,
-                            null,
-                            null,
-                            originalItem.Location.File));
+                        ProjectErrorUtilities.ThrowInvalidProject(originalItem.IncludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(includeSplit), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
                     }
                 }
             }
@@ -454,11 +460,18 @@ ISet<string> removeMetadata
 
             foreach (string excludeSplit in excludes)
             {
-                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
+                try
+                {
+                    string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
 
-                foreach (string excludeSplitFile in excludeSplitFiles)
+                    foreach (string excludeSplitFile in excludeSplitFiles)
+                    {
+                        excludesUnescapedForComparison.Add(excludeSplitFile);
+                    }
+                }
+                catch (DriveEnumerationWildcardException ex)
                 {
-                    excludesUnescapedForComparison.Add(excludeSplitFile);
+                    ProjectErrorUtilities.ThrowInvalidProject(originalItem.ExcludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(excludeSplit), XMakeAttributes.exclude, XMakeElements.itemGroup, ex.Message);
                 }
             }
 
@@ -536,17 +549,24 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
                 // wildcards.  Then loop through each file returned, and add it
                 // to our hashtable.
 
-                // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
-                // as literals. Everything else is safe to unescape at this point, since we're only matching
-                // against the file system.
-                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
+                try
+                {
+                    // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
+                    // as literals. Everything else is safe to unescape at this point, since we're only matching
+                    // against the file system.
+                    string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
 
-                foreach (string file in fileList)
+                    foreach (string file in fileList)
+                    {
+                        // Now unescape everything, because this is the end of the road for this filename.
+                        // We're just going to compare it to the unescaped include path to filter out the
+                        // file excludes.
+                        specificationsToFind.Add(EscapingUtilities.UnescapeAll(file));
+                    }
+                }
+                catch (DriveEnumerationWildcardException ex)
                 {
-                    // Now unescape everything, because this is the end of the road for this filename.
-                    // We're just going to compare it to the unescaped include path to filter out the
-                    // file excludes.
-                    specificationsToFind.Add(EscapingUtilities.UnescapeAll(file));
+                    ProjectErrorUtilities.ThrowInvalidProject(specificationLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(piece), XMakeAttributes.exclude, XMakeElements.itemGroup, ex.Message);
                 }
             }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b5c40b3cc79..8839a075048 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -399,8 +399,19 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
-                ExecuteIntrinsicTask(bucket);
-                taskResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
+                try
+                {
+                    ExecuteIntrinsicTask(bucket);
+                    taskResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
+                }
+                catch (InvalidProjectFileException e)
+                {
+                    // Make sure the Invalid Project error gets logged *before* TaskFinished.  Otherwise,
+                    // the log is confusing.
+                    _targetLoggingContext.LogInvalidProjectFileError(e);
+                    _continueOnError = ContinueOnError.ErrorAndStop;
+                    taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, e);
+                }
             }
             else
             {
@@ -461,6 +472,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                             // the log is confusing.
                             taskLoggingContext.LogInvalidProjectFileError(e);
                             _continueOnError = ContinueOnError.ErrorAndStop;
+                            taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, e);
                         }
                         finally
                         {
@@ -894,6 +906,10 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                     else if (type == typeof(Exception) || type.GetTypeInfo().IsSubclassOf(typeof(Exception)))
                     {
+                        if ((Environment.GetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration") == "1") && (taskException.Message.Contains("resulted in an attempted drive enumeration")))
+                        {
+                            throw new InvalidProjectFileException("Failed to execute task object for given project instance as this resulted in an attempted drive enumeration.", taskException);
+                        }
                         // Occasionally, when debugging a very uncommon task exception, it is useful to loop the build with 
                         // a debugger attached to break on 2nd chance exceptions.
                         // That requires that there needs to be a way to not catch here, by setting an environment variable.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 19f4c800414..de0cfa63212 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -373,15 +373,22 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem
                     else
                     {
                         // The expression is not of the form "@(X)". Treat as string
-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
-
-                        if (includeSplitFilesEscaped.Length > 0)
+                        try
                         {
-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                            string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
+
+                            if (includeSplitFilesEscaped.Length > 0)
                             {
-                                items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));
+                                foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                                {
+                                    items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));
+                                }
                             }
                         }
+                        catch (DriveEnumerationWildcardException ex)
+                        {
+                            ProjectErrorUtilities.ThrowInvalidProject(itemElement.IncludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(includeSplitEscaped), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
+                        }
                     }
                 }
             }
@@ -2044,6 +2051,10 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     // Expand the wildcards and provide an alphabetical order list of import statements.
                     importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);
                 }
+                catch (DriveEnumerationWildcardException ex)
+                {
+                    ProjectErrorUtilities.ThrowInvalidProject(importLocationInProject, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(importExpressionEscapedItem), XMakeAttributes.project, XMakeElements.import, ex.Message);
+                }
                 catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(importLocationInProject, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(importExpressionEscapedItem), XMakeAttributes.project, XMakeElements.import, ex.Message);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 88d911a7b4a..9d085f9a326 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1976,7 +1976,7 @@ out List<Pair<string, S>> itemsFromCapture
                     Stack<TransformFunction<S>> transformFunctionStack = PrepareTransformStackFromMatch<S>(elementLocation, expressionCapture);
 
                     // iterate over the tranform chain, creating the final items from its results
-                    foreach (Pair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
+                    foreach (Pair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType, elementLocation)))
                     {
                         if (!string.IsNullOrEmpty(itemTuple.Key) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
@@ -2234,21 +2234,32 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
                 /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
+                internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType, IElementLocation elementLocation)
                 {
                     // iterate over the items, and yield out items in the tuple format
                     foreach (var item in itemsOfType)
                     {
                         if (Traits.Instance.UseLazyWildCardEvaluation)
                         {
-                            foreach (
-                                var resultantItem in
-                                EngineFileUtilities.GetFileListEscaped(
-                                    item.ProjectDirectory,
-                                    item.EvaluatedIncludeEscaped,
-                                    forceEvaluate: true))
+                            string[] fileListEscaped = null;
+                            try
+                            {
+                                fileListEscaped = EngineFileUtilities.GetFileListEscaped(
+                                     item.ProjectDirectory,
+                                     item.EvaluatedIncludeEscaped,
+                                     forceEvaluate: true);
+                            }
+                            catch (DriveEnumerationWildcardException ex)
+                            {
+                                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(item.EvaluatedIncludeEscaped), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
+                            }
+
+                            if (fileListEscaped != null)
                             {
-                                yield return new Pair<string, S>(resultantItem, item);
+                                foreach (var resultantItem in fileListEscaped)
+                                {
+                                    yield return new Pair<string, S>(resultantItem, item);
+                                }
                             }
                         }
                         else
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 0fe765844fa..b7147d02737 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -111,23 +111,27 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                             {
                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                             }
-                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
-                            {
-                                includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
-                                    _rootDirectory,
-                                    glob,
-                                    excludePatternsForGlobs,
-                                    fileMatcher: FileMatcher
-                                );
-                            }
-                            if (MSBuildEventSource.Log.IsEnabled())
+
+                            try
                             {
-                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                                using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
+                                {
+                                    includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);
+                                }
+
+                                if (MSBuildEventSource.Log.IsEnabled())
+                                {
+                                    MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                                }
+
+                                foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                                {
+                                    itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
+                                }
                             }
-
-                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                            catch (DriveEnumerationWildcardException ex)
                             {
-                                itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
+                                ProjectErrorUtilities.ThrowInvalidProject(_itemElement.IncludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
                             }
                         }
                     }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c25e4dc39fe..8ee8b514349 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -695,6 +695,10 @@
       <Link>SharedUtilities\FileMatcher.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\DriveEnumerationWildcardException.cs">
+      <Link>SharedUtilities\DriveEnumerationWildcardException.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>SharedUtilities\FileUtilities.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 3c3d850d7c6..66cc20cf7fb 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -43,6 +43,7 @@ public Traits()
         /// </summary>
         public readonly bool UseLazyWildCardEvaluation = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes"));
         public readonly bool LogExpandedWildcards = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGEXPANDEDWILDCARDS"));
+        public readonly bool ThrowOnWildcardDriveEnumeration = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration"));
 
         /// <summary>
         /// Cache file existence for the entire process
diff --git a/src/Shared/DriveEnumerationWildcardException.cs b/src/Shared/DriveEnumerationWildcardException.cs
new file mode 100644
index 00000000000..9106405a394
--- /dev/null
+++ b/src/Shared/DriveEnumerationWildcardException.cs
@@ -0,0 +1,34 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Shared
+{
+    /// <summary>
+    /// Thrown in cases where a drive enumeration wildcard was encountered when finding files that match a given file spec.
+    /// </summary>
+    internal class DriveEnumerationWildcardException : Exception
+    {
+        public DriveEnumerationWildcardException()
+        {
+        }
+
+        public DriveEnumerationWildcardException(string projectDirectory, string wildcardEvaluation)
+            : base(ConstructErrorMessage(projectDirectory, wildcardEvaluation))
+        {
+        }
+
+        public DriveEnumerationWildcardException(string message, Exception innerException)
+            : base(message, innerException)
+        {
+        }
+
+        private static string ConstructErrorMessage(string projectDirectory, string wildcardEvaluation)
+        {
+            return $"Failed to find files in {projectDirectory} that matched the filespec {wildcardEvaluation}, " +
+                    "as this resulted in an attempted drive enumeration. Ensure that items and properties " +
+                    "are properly defined in your project.";
+        }
+    }
+}
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 7af174db82b..ec13897bab0 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -857,7 +857,7 @@ private void GetFilesRecursive(
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs,
             TaskOptions taskOptions)
         {
-            ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec== null) || (recursionState.SearchData.RegexFileMatch == null),
+            ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec == null) || (recursionState.SearchData.RegexFileMatch == null),
                 "File-spec overrides the regular expression -- pass null for file-spec if you want to use the regular expression.");
 
             ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec != null) || (recursionState.SearchData.RegexFileMatch != null),
@@ -1034,7 +1034,7 @@ private void GetFilesRecursive(
             {
                 Parallel.ForEach(
                     _getFileSystemEntries(FileSystemEntity.Directories, recursionState.BaseDirectory, nextStep.DirectoryPattern, null, false),
-                    new ParallelOptions {MaxDegreeOfParallelism = dop},
+                    new ParallelOptions { MaxDegreeOfParallelism = dop },
                     processSubdirectory);
             }
             if (dop <= 0)
@@ -2072,6 +2072,7 @@ enum SearchAction
             RunSearch,
             ReturnFileSpec,
             ReturnEmptyList,
+            ReturnDriveEnumerationWildcard
         }
 
         private SearchAction GetFileSearchData(
@@ -2135,6 +2136,22 @@ out bool isLegalFileSpec
                 return SearchAction.ReturnEmptyList;
             }
 
+            /*
+             * If the fixed directory part contains the drive or simply '/', and the drive enumeration wildcard is set, then an
+             * exception should be thrown.
+             */
+            int fixedDirectoryPartLength = fixedDirectoryPart.Length;
+            if (fixedDirectoryPartLength > 0 && wildcardDirectoryPart.Length >= 2)
+            {
+                if (FileUtilities.IsAnySlash(fixedDirectoryPart[fixedDirectoryPartLength - 1]) && // ex: /**
+                    wildcardDirectoryPart[0] == '*' &&
+                    wildcardDirectoryPart[1] == '*' &&
+                    Traits.Instance.ThrowOnWildcardDriveEnumeration)
+                {
+                    return SearchAction.ReturnDriveEnumerationWildcard;
+                }
+            }
+
             string directoryPattern = null;
             if (wildcardDirectoryPart.Length > 0)
             {
@@ -2143,6 +2160,7 @@ out bool isLegalFileSpec
                 // "**/.*/**" for example, and is worth special-casing so it doesn't fall into the slow regex logic.
                 string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();
                 int wildcardLength = wildcard.Length;
+
                 if (wildcardLength > 6 &&
                     wildcard[0] == '*' &&
                     wildcard[1] == '*' &&
@@ -2339,6 +2357,10 @@ private string[] GetFilesImplementation(
             {
                 return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
             }
+            else if (action == SearchAction.ReturnDriveEnumerationWildcard)
+            {
+                throw new DriveEnumerationWildcardException(projectDirectoryUnescaped, filespecUnescaped);
+            }
             else if (action != SearchAction.RunSearch)
             {
                 // This means the enum value wasn't valid (or a new one was added without updating code correctly)
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index bca3773e17a..e3b06422812 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1374,6 +1374,21 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
             }
         }
 
+        [Fact]
+        public void DriveEnumerationWildcardThrowsException()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+
+                Assert.Throws<DriveEnumerationWildcardException>(() => { FileMatcher.Default.GetFiles(string.Empty, NativeMethodsShared.IsWindows ? @"c:\**\*.cs" : "/**/*.cs"); });
+
+                Assert.Throws<DriveEnumerationWildcardException>(() => { FileMatcher.Default.GetFiles(string.Empty, NativeMethodsShared.IsWindows ? @"c:\**" : "/**"); });
+
+                Assert.Throws<DriveEnumerationWildcardException>(() => { FileMatcher.Default.GetFiles(string.Empty, NativeMethodsShared.IsWindows ? @"\**" : "/**"); });
+            }
+        }
+
         [Fact]
         public void RemoveProjectDirectory()
         {
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 0c422b67892..e0f4c454e11 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -3,8 +3,10 @@
 
 using System.IO;
 using System.Collections.Generic;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
@@ -261,6 +263,58 @@ public void AdditionalMetaDataOverwriteExisting()
             Assert.True(success);
             Assert.Equal("SomeOverwriteValue", t.Include[0].GetMetadata("MyMetaData"));
         }
+
+        /// <summary>
+        /// Throw exception when encountering wildcard drive enumeration during task item creation.
+        /// </summary>
+        [Fact]
+        public void WildcardDriveEnumerationTaskItemThrowsException()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+                CreateItem t = new CreateItem();
+                t.BuildEngine = new MockEngine();
+
+                t.Include = new ITaskItem[] { new TaskItem(@"\**") };
+
+                Assert.Throws<DriveEnumerationWildcardException>(() =>
+                {
+                    t.Execute();
+                });
+            }
+        }
+
+        /// <summary>
+        /// Using the CreateItem task to expand wildcards and result in a failure due to
+        /// attempted drive enumeration.
+        /// </summary>
+        [Fact]
+        public void CreateItemEvaluationResultingInWildcardDriveEnumeration()
+        {
+            using var env = TestEnvironment.Create(_testOutput);
+            env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+
+            string content =
+                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+                    <Target Name =""TestTarget"" Returns=""@(Text)"">
+                      <CreateItem Include=""\**\*.txt"">
+                        <Output TaskParameter=""Include"" ItemName=""Text""/>
+                      </CreateItem>
+                    </Target>
+                  </Project>
+                ";
+
+            var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
+            var p = ProjectInstance.FromFile(testFile.Path, new ProjectOptions());
+
+            BuildManager buildManager = BuildManager.DefaultBuildManager;
+            BuildRequestData data = new BuildRequestData(p, new[] { "TestTarget" });
+            BuildParameters parameters = new BuildParameters();
+            BuildResult buildResult = buildManager.Build(parameters, data);
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            buildResult["TestTarget"].Exception?.Message.ShouldContain("this resulted in an attempted drive enumeration");
+        }
     }
 }
 
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index f386549f525..094d43529b5 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -144,22 +144,29 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                 {
                     if (FileMatcher.HasWildcards(i.ItemSpec))
                     {
-                        string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
-                        foreach (string file in files)
+                        try
                         {
-                            TaskItem newItem = new TaskItem(i) { ItemSpec = file };
-
-                            // Compute the RecursiveDir portion.
-                            FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);
-                            if (match.isLegalFileSpec && match.isMatch)
+                            string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
+                            foreach (string file in files)
                             {
-                                if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))
+                                TaskItem newItem = new TaskItem(i) { ItemSpec = file };
+
+                                // Compute the RecursiveDir portion.
+                                FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);
+                                if (match.isLegalFileSpec && match.isMatch)
                                 {
-                                    newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);
+                                    if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))
+                                    {
+                                        newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);
+                                    }
                                 }
-                            }
 
-                            expanded.Add(newItem);
+                                expanded.Add(newItem);
+                            }
+                        }
+                        catch (DriveEnumerationWildcardException)
+                        {
+                            throw;
                         }
                     }
                     else
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 29e5289bca5..e60f7e0daa5 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -128,6 +128,9 @@
     <Compile Include="..\Shared\FileMatcher.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\DriveEnumerationWildcardException.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 67cb313a50e..743244e1b5c 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -3609,6 +3609,35 @@ public void FlatTrackingExcludeDirectories()
             Assert.Equal(originalNewest, data.NewestFileTimeUtc); // "Timestamp changed when no tracked files changed."
         }
 
+        /// <summary>
+        /// Throws exception upon creation of a new FlatTrackingData object with a task item,
+        /// which has an invalid item spec that attempts to enumerate the drive.
+        /// </summary>
+        [Fact]
+        public void ThrowExceptionOnDriveEnumerationDuringWildcardExpansion()
+        {
+            Console.WriteLine("Test: ThrowExceptionOnDriveEnumerationDuringWildcardExpansion");
+
+            using var env = TestEnvironment.Create();
+            env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+
+            // Get the newest time w/o any exclude paths
+            Dictionary<string, DateTime> sharedLastWriteTimeUtcCache = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
+
+            // Adds wildcard that attempts drive enumeration in task item
+            Assert.Throws<DriveEnumerationWildcardException>(() =>
+            {
+                FlatTrackingData data = new FlatTrackingData
+                (
+                    DependencyTestHelper.ItemArray(new TaskItem(@"\**\*.log")),
+                    null,
+                    DateTime.MinValue,
+                    null,
+                    sharedLastWriteTimeUtcCache
+                );
+            });
+        }
+
         [Fact]
         public void TrackingDataCacheResetOnTlogChange()
         {
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 5e5bcafb605..a47393aac3e 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -71,6 +71,9 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Shared\CopyOnWriteDictionary.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\DriveEnumerationWildcardException.cs">
+      <Link>Shared\DriveEnumerationWildcardException.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\EncodingUtilities.cs">
       <Link>Shared\EncodingUtilities.cs</Link>
     </Compile>
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index de261ee538e..045381088cf 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -35,25 +35,32 @@ public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
             {
                 if (FileMatcher.HasWildcards(item.ItemSpec))
                 {
-                    string[] files;
-                    string directoryName = Path.GetDirectoryName(item.ItemSpec);
-                    string searchPattern = Path.GetFileName(item.ItemSpec);
-
-                    // Very often with TLog files we're talking about
-                    // a directory and a simply wildcarded filename
-                    // Optimize for that case here.
-                    if (!FileMatcher.HasWildcards(directoryName) && FileSystems.Default.DirectoryExists(directoryName))
-                    {
-                        files = Directory.GetFiles(directoryName, searchPattern);
-                    }
-                    else
+                    try
                     {
-                        files = FileMatcher.Default.GetFiles(null, item.ItemSpec);
-                    }
+                        string[] files;
+                        string directoryName = Path.GetDirectoryName(item.ItemSpec);
+                        string searchPattern = Path.GetFileName(item.ItemSpec);
+
+                        // Very often with TLog files we're talking about
+                        // a directory and a simply wildcarded filename
+                        // Optimize for that case here.
+                        if (!FileMatcher.HasWildcards(directoryName) && FileSystems.Default.DirectoryExists(directoryName))
+                        {
+                            files = Directory.GetFiles(directoryName, searchPattern);
+                        }
+                        else
+                        {
+                            files = FileMatcher.Default.GetFiles(null, item.ItemSpec);
+                        }
 
-                    foreach (string file in files)
+                        foreach (string file in files)
+                        {
+                            expanded.Add(new TaskItem(item) { ItemSpec = file });
+                        }
+                    }
+                    catch (DriveEnumerationWildcardException)
                     {
-                        expanded.Add(new TaskItem(item) { ItemSpec = file });
+                        throw;
                     }
                 }
                 else
